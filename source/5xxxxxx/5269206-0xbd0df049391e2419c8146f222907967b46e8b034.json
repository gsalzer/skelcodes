{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/*\r\n*         ##### ##         #####    ##     ###          ##                       ###   ###     \r\n*      ######  /###     ######  /  #### / /####       ####  /                     ###   ###    \r\n*     /#   /  /  ###   /#   /  /   ####/ /   ###      /####/                       ##    ##    \r\n*    /    /  /    ### /    /  /    # #        ###    /   ##                        ##    ##    \r\n*        /  /      ##     /  /     #           ###  /                              ##    ##    \r\n*       ## ##      ##    ## ##     #            ###/         ###  /###     /###    ##    ##    \r\n*       ## ##      ##    ## ##     #             ###          ###/ #### / / ###  / ##    ##    \r\n*     /### ##      /     ## ########             /###          ##   ###/ /   ###/  ##    ##    \r\n*    / ### ##     /      ## ##     #            /  ###         ##       ##    ##   ##    ##    \r\n*       ## ######/       ## ##     ##          /    ###        ##       ##    ##   ##    ##    \r\n*       ## ######        #  ##     ##         /      ###       ##       ##    ##   ##    ##    \r\n*       ## ##               /       ##       /        ###      ##       ##    ##   ##    ##    \r\n*       ## ##           /##/        ##      /          ###   / ##       ##    ##   ##    ##    \r\n*       ## ##          /  #####      ##    /            ####/  ###       ######    ### / ### / \r\n*  ##   ## ##         /     ##            /              ###    ###       ####      ##/   ##/  \r\n* ###   #  /          #                                                                        \r\n*  ###    /            ##                                                                      \r\n*   #####/                                                                                     \r\n*     ###                                                                                      \r\n*  \r\n*       ____\r\n*      /\\' .\\    _____\r\n*     /: \\___\\  / .  /\\\r\n*     \\' / . / /____/..\\\r\n*      \\/___/  \\'  '\\  /\r\n*               \\'__'\\/\r\n*\r\n* // Probably Unfair //\r\n*\r\n* //*** Developed By:\r\n*   _____       _         _         _ ___ _         \r\n*  |_   _|__ __| |_  _ _ (_)__ __ _| | _ (_)___ ___ \r\n*    | |/ -_) _| ' \\| ' \\| / _/ _` | |   / (_-</ -_)\r\n*    |_|\\___\\__|_||_|_||_|_\\__\\__,_|_|_|_\\_/__/\\___|\r\n*   \r\n*   © 2018 TechnicalRise.  Written in March 2018.  \r\n*   All rights reserved.  Do not copy, adapt, or otherwise use without permission.\r\n*   https://www.reddit.com/user/TechnicalRise/\r\n*  \r\n*/\r\n\r\ncontract PHXReceivingContract {\r\n    function tokenFallback(address _from, uint _value, bytes _data) public;\r\n}\r\n\r\ncontract PHXInterface {\r\n    function balanceOf(address who) public view returns (uint);\r\n    function transfer(address _to, uint _value) public returns (bool);\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool);\r\n}\r\n\r\ncontract usingMathLibraries {\r\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n        require(a + b >= a);\r\n        return a + b;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) pure internal returns (uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    } \r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal pure returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n}\r\n\r\ncontract PHXroll is PHXReceivingContract, usingMathLibraries {\r\n    \r\n    /*\r\n     * checks player profit, bet size and player number is within range\r\n    */\r\n    modifier betIsValid(uint _betSize, uint _playerNumber) {      \r\n        require(((((_betSize * (100-(safeSub(_playerNumber,1)))) / (safeSub(_playerNumber,1))+_betSize))*houseEdge/houseEdgeDivisor)-_betSize < maxProfit && _betSize > minBet && _playerNumber > minNumber && _playerNumber < maxNumber);        \r\n\t\t_;\r\n    }\r\n\r\n    /*\r\n     * checks game is currently active\r\n    */\r\n    modifier gameIsActive {\r\n        require(gamePaused == false);\r\n\t\t_;\r\n    }    \r\n\r\n    /*\r\n     * checks payouts are currently active\r\n    */\r\n    modifier payoutsAreActive {\r\n        require(payoutsPaused == false);\r\n\t\t_;\r\n    }    \r\n\r\n    /*\r\n     * checks only owner address is calling\r\n    */\r\n    modifier onlyOwner {\r\n         require(msg.sender == owner);\r\n         _;\r\n    }\r\n\r\n    /*\r\n     * checks only treasury address is calling\r\n    */\r\n    modifier onlyTreasury {\r\n         require(msg.sender == treasury);\r\n         _;\r\n    }    \r\n\r\n    /*\r\n     * game vars\r\n    */ \r\n    uint constant public maxProfitDivisor = 1000000;\r\n    uint constant public houseEdgeDivisor = 1000;    \r\n    uint constant public maxNumber = 99; \r\n    uint constant public minNumber = 2;\r\n\tbool public gamePaused;\r\n    address public owner;\r\n    bool public payoutsPaused; \r\n    address public treasury;\r\n    uint public contractBalance;\r\n    uint public houseEdge;     \r\n    uint public maxProfit;   \r\n    uint public maxProfitAsPercentOfHouse;                    \r\n    uint public minBet; \r\n    //init discontinued contract data        \r\n    int public totalBets = 0;\r\n    //init discontinued contract data \r\n    uint public totalTRsWon = 0;\r\n    //init discontinued contract data  \r\n    uint public totalTRsWagered = 0;    \r\n\r\n    /*\r\n     * player vars\r\n    */\r\n    uint public rngId;\r\n    mapping (uint => address) playerAddress;\r\n    mapping (uint => uint) playerBetId;\r\n    mapping (uint => uint) playerBetValue;\r\n    mapping (uint => uint) playerDieResult;\r\n    mapping (uint => uint) playerNumber;\r\n    mapping (uint => uint) playerProfit;\r\n\r\n    /*\r\n     * events\r\n    */\r\n    /* log bets + output to web3 for precise 'payout on win' field in UI */\r\n    event LogBet(uint indexed BetID, address indexed PlayerAddress, uint indexed RewardValue, uint ProfitValue, uint BetValue, uint PlayerNumber);      \r\n    /* output to web3 UI on bet result*/\r\n    /* Status: 0=lose, 1=win, 2=win + failed send, 3=refund, 4=refund + failed send*/\r\n\tevent LogResult(uint indexed BetID, address indexed PlayerAddress, uint PlayerNumber, uint DiceResult, uint Value, int Status);   \r\n    /* log manual refunds */\r\n    event LogRefund(uint indexed BetID, address indexed PlayerAddress, uint indexed RefundValue);\r\n    /* log owner transfers */\r\n    event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);               \r\n\r\n    address public constant PHXTKNADDR = 0x14b759A158879B133710f4059d32565b4a66140C;\r\n    PHXInterface public PHXTKN;\r\n\r\n    /*\r\n     * init\r\n    */\r\n    function PHXroll() public {\r\n        owner = msg.sender;\r\n        treasury = msg.sender;\r\n        // Initialize the PHX Contract\r\n        PHXTKN = PHXInterface(PHXTKNADDR); \r\n        /* init 990 = 99% (1% houseEdge)*/\r\n        ownerSetHouseEdge(990);\r\n        /* init 10,000 = 1%  */\r\n        ownerSetMaxProfitAsPercentOfHouse(10000);\r\n        /* init min bet (0.1 PHX) */\r\n        ownerSetMinBet(100000000000000000);        \r\n    }\r\n\r\n    // This is a supercheap psuedo-random number generator\r\n    // that relies on the fact that \"who\" will mine and \"when\" they will\r\n    // mine is random.  This is usually vulnerable to \"inside the block\"\r\n    // attacks where someone writes a contract mined in the same block\r\n    // and calls this contract from it -- but we don't accept transactions\r\n    // from other contracts, lessening that risk.  It seems like someone\r\n    // would therefore need to be able to predict the block miner and\r\n    // block timestamp in advance to hack this.  \r\n    // \r\n    // ¯\\_(ツ)_/¯ \r\n    // \r\n    uint seed3;\r\n    function _pRand(uint _modulo) internal view returns (uint) {\r\n        require((1 < _modulo) && (_modulo <= 1000));\r\n        uint seed1 = uint(block.coinbase); // Get Miner's Address\r\n        uint seed2 = now; // Get the timestamp\r\n        seed3++; // Make all pRand calls unique\r\n        return uint(keccak256(seed1, seed2, seed3)) % _modulo;\r\n    }\r\n\r\n    /*\r\n     * public function\r\n     * player submit bet\r\n     * only if game is active & bet is valid\r\n    */\r\n    function _playerRollDice(uint _rollUnder, TKN _tkn) private \r\n        gameIsActive\r\n        betIsValid(_tkn.value, _rollUnder)\r\n\t{\r\n        // Note that msg.sender is the Token Contract Address\r\n    \t// and \"_from\" is the sender of the tokens\r\n    \trequire(_humanSender(_tkn.sender)); // Check that this is a non-contract sender\r\n    \trequire(_phxToken(msg.sender)); // Check that this is a PHX Token Transfer\r\n\t    \r\n\t    // Increment rngId\r\n\t    rngId++;\r\n\t    \r\n        /* map bet id to this wager */\r\n\t\tplayerBetId[rngId] = rngId;\r\n        /* map player lucky number */\r\n\t\tplayerNumber[rngId] = _rollUnder;\r\n        /* map value of wager */\r\n        playerBetValue[rngId] = _tkn.value;\r\n        /* map player address */\r\n        playerAddress[rngId] = _tkn.sender;\r\n        /* safely map player profit */   \r\n        playerProfit[rngId] = 0; \r\n  \r\n        /* provides accurate numbers for web3 and allows for manual refunds */\r\n        emit LogBet(playerBetId[rngId], playerAddress[rngId], safeAdd(playerBetValue[rngId], playerProfit[rngId]), playerProfit[rngId], playerBetValue[rngId], playerNumber[rngId]);       \r\n        \r\n        /* map Die result to player */\r\n        playerDieResult[rngId] = _pRand(100) + 1;\r\n\r\n        /* total number of bets */\r\n        totalBets += 1;\r\n        \r\n        /* total wagered */\r\n        totalTRsWagered += playerBetValue[rngId];                                                           \r\n\r\n        /*\r\n        * pay winner\r\n        * update contract balance to calculate new max bet\r\n        * send reward\r\n        */\r\n        if(playerDieResult[rngId] < playerNumber[rngId]){ \r\n            /* safely map player profit */   \r\n            playerProfit[rngId] = ((((_tkn.value * (100-(safeSub(_rollUnder,1)))) / (safeSub(_rollUnder,1))+_tkn.value))*houseEdge/houseEdgeDivisor)-_tkn.value;\r\n            \r\n            /* safely reduce contract balance by player profit */\r\n            contractBalance = safeSub(contractBalance, playerProfit[rngId]); \r\n\r\n            /* update total Rises won */\r\n            totalTRsWon = safeAdd(totalTRsWon, playerProfit[rngId]);              \r\n\r\n            emit LogResult(playerBetId[rngId], playerAddress[rngId], playerNumber[rngId], playerDieResult[rngId], playerProfit[rngId], 1);                            \r\n\r\n            /* update maximum profit */\r\n            setMaxProfit();\r\n            \r\n            // Transfer profit plus original bet\r\n            PHXTKN.transfer(playerAddress[rngId], playerProfit[rngId] + _tkn.value);\r\n            \r\n            return;\r\n        } else {\r\n            /*\r\n            * no win\r\n            * send 1 Rise to a losing bet\r\n            * update contract balance to calculate new max bet\r\n            */\r\n            emit LogResult(playerBetId[rngId], playerAddress[rngId], playerNumber[rngId], playerDieResult[rngId], playerBetValue[rngId], 0);                                \r\n\r\n            /*  \r\n            *  safe adjust contractBalance\r\n            *  setMaxProfit\r\n            *  send 1 Rise to losing bet\r\n            */\r\n            contractBalance = safeAdd(contractBalance, (playerBetValue[rngId]-1));                                                                         \r\n\r\n            /* update maximum profit */\r\n            setMaxProfit(); \r\n\r\n            /*\r\n            * send 1 Rise               \r\n            */\r\n            PHXTKN.transfer(playerAddress[rngId], 1);\r\n\r\n            return;            \r\n        }\r\n\r\n    } \r\n    \r\n    // !Important: Note the use of the following struct\r\n    struct TKN { address sender; uint value; }\r\n    function tokenFallback(address _from, uint _value, bytes _data) public {\r\n        if(_from == treasury) {\r\n            contractBalance = safeAdd(contractBalance, _value);        \r\n            /* safely update contract balance */\r\n            /* update the maximum profit */\r\n            setMaxProfit();\r\n            return;\r\n        } else {\r\n            TKN memory _tkn;\r\n            _tkn.sender = _from;\r\n            _tkn.value = _value;\r\n            _playerRollDice(parseInt(string(_data)), _tkn);\r\n        }\r\n    }\r\n            \r\n    /*\r\n    * internal function\r\n    * sets max profit\r\n    */\r\n    function setMaxProfit() internal {\r\n        maxProfit = (contractBalance*maxProfitAsPercentOfHouse)/maxProfitDivisor;  \r\n    } \r\n\r\n    /* only owner adjust contract balance variable (only used for max profit calc) */\r\n    function ownerUpdateContractBalance(uint newContractBalanceInTRs) public \r\n\t\tonlyOwner\r\n    {        \r\n       contractBalance = newContractBalanceInTRs;\r\n    }    \r\n\r\n    /* only owner address can set houseEdge */\r\n    function ownerSetHouseEdge(uint newHouseEdge) public \r\n\t\tonlyOwner\r\n    {\r\n        houseEdge = newHouseEdge;\r\n    }\r\n\r\n    /* only owner address can set maxProfitAsPercentOfHouse */\r\n    function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public \r\n\t\tonlyOwner\r\n    {\r\n        /* restrict each bet to a maximum profit of 1% contractBalance */\r\n        require(newMaxProfitAsPercent <= 10000);\r\n        maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\r\n        setMaxProfit();\r\n    }\r\n\r\n    /* only owner address can set minBet */\r\n    function ownerSetMinBet(uint newMinimumBet) public \r\n\t\tonlyOwner\r\n    {\r\n        minBet = newMinimumBet;\r\n    }       \r\n\r\n    /* only owner address can transfer PHX */\r\n    function ownerTransferPHX(address sendTo, uint amount) public \r\n\t\tonlyOwner\r\n    {        \r\n        /* safely update contract balance when sending out funds*/\r\n        contractBalance = safeSub(contractBalance, amount);\t\t\r\n        /* update max profit */\r\n        setMaxProfit();\r\n        require(!PHXTKN.transfer(sendTo, amount));\r\n        emit LogOwnerTransfer(sendTo, amount); \r\n    }\r\n\r\n    /* only owner address can set emergency pause #1 */\r\n    function ownerPauseGame(bool newStatus) public \r\n\t\tonlyOwner\r\n    {\r\n\t\tgamePaused = newStatus;\r\n    }\r\n\r\n    /* only owner address can set emergency pause #2 */\r\n    function ownerPausePayouts(bool newPayoutStatus) public \r\n\t\tonlyOwner\r\n    {\r\n\t\tpayoutsPaused = newPayoutStatus;\r\n    } \r\n\r\n    /* only owner address can set treasury address */\r\n    function ownerSetTreasury(address newTreasury) public \r\n\t\tonlyOwner\r\n\t{\r\n        treasury = newTreasury;\r\n    }         \r\n\r\n    /* only owner address can set owner address */\r\n    function ownerChangeOwner(address newOwner) public \r\n\t\tonlyOwner\r\n\t{\r\n        owner = newOwner;\r\n    }\r\n\r\n    /* only owner address can selfdestruct - emergency */\r\n    function ownerkill() public \r\n\t\tonlyOwner\r\n\t{\r\n        PHXTKN.transfer(owner, contractBalance);\r\n\t\tselfdestruct(owner);\r\n\t}    \r\n\r\n    function _phxToken(address _tokenContract) private pure returns (bool) {\r\n        return _tokenContract == PHXTKNADDR; // Returns \"true\" of this is the PHX Token Contract\r\n    }\r\n    \r\n    // Determine if the \"_from\" address is a contract\r\n    function _humanSender(address _from) private view returns (bool) {\r\n      uint codeLength;\r\n      assembly {\r\n          codeLength := extcodesize(_from)\r\n      }\r\n      return (codeLength == 0); // If this is \"true\" sender is most likely a Wallet\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"sendTo\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ownerTransferPHX\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitAsPercentOfHouse\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHouseEdge\",\"type\":\"uint256\"}],\"name\":\"ownerSetHouseEdge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTRsWagered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutsPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"ownerSetTreasury\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContractBalanceInTRs\",\"type\":\"uint256\"}],\"name\":\"ownerUpdateContractBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PHXTKNADDR\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPayoutStatus\",\"type\":\"bool\"}],\"name\":\"ownerPausePayouts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerChangeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxProfitAsPercent\",\"type\":\"uint256\"}],\"name\":\"ownerSetMaxProfitAsPercentOfHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumBet\",\"type\":\"uint256\"}],\"name\":\"ownerSetMinBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"ownerPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PHXTKN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerkill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rngId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdgeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTRsWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"BetID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"PlayerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"RewardValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ProfitValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"BetValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"PlayerNumber\",\"type\":\"uint256\"}],\"name\":\"LogBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"BetID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"PlayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"PlayerNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"DiceResult\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Status\",\"type\":\"int256\"}],\"name\":\"LogResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"BetID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"PlayerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"RefundValue\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"SentToAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"AmountTransferred\",\"type\":\"uint256\"}],\"name\":\"LogOwnerTransfer\",\"type\":\"event\"}]","ContractName":"PHXroll","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c62405d4c89ca4845c9b57bb40cf696dec5cdbaf49e5971dd3f60c4ab3552b88"}]}