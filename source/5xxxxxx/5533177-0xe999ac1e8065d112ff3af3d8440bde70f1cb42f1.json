{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/*\r\n * @title MerkleProof\r\n * @dev Merkle proof verification\r\n * @note Based on https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\r\n */\r\nlibrary MerkleProof {\r\n  /*\r\n   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\r\n   * and each pair of pre-images is sorted.\r\n   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\r\n   * @param _root Merkle root\r\n   * @param _leaf Leaf of Merkle tree\r\n   */\r\n  function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {\r\n    // Check if proof length is a multiple of 32\r\n    if (_proof.length % 32 != 0) return false;\r\n\r\n    bytes32 proofElement;\r\n    bytes32 computedHash = _leaf;\r\n\r\n    for (uint256 i = 32; i <= _proof.length; i += 32) {\r\n      assembly {\r\n        // Load the current element of the proof\r\n        proofElement := mload(add(_proof, i))\r\n      }\r\n\r\n      if (computedHash < proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(computedHash, proofElement);\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(proofElement, computedHash);\r\n      }\r\n    }\r\n\r\n    // Check if the computed hash (root) is equal to the provided root\r\n    return computedHash == _root;\r\n  }\r\n}\r\n\r\n/**\r\n * @title MerkleMine\r\n * @dev Token distribution based on providing Merkle proofs of inclusion in genesis state to generate allocation\r\n */\r\ncontract MerkleMine {\r\n    using SafeMath for uint256;\r\n\r\n    // ERC20 token being distributed\r\n    ERC20 public token;\r\n    // Merkle root representing genesis state which encodes token recipients\r\n    bytes32 public genesisRoot;\r\n    // Total amount of tokens that can be generated\r\n    uint256 public totalGenesisTokens;\r\n    // Total number of recipients included in genesis state\r\n    uint256 public totalGenesisRecipients;\r\n    // Amount of tokens per recipient allocation. Equal to `totalGenesisTokens` / `totalGenesisRecipients`\r\n    uint256 public tokensPerAllocation;\r\n    // Minimum ETH balance threshold for recipients included in genesis state\r\n    uint256 public balanceThreshold;\r\n    // Block number of genesis - used to determine which ETH accounts are included in the genesis state\r\n    uint256 public genesisBlock;\r\n    // Start block where a third party caller (not the recipient) can generate and split the allocation with the recipient\r\n    // As the current block gets closer to `callerAllocationEndBlock`, the caller receives a larger precentage of the allocation\r\n    uint256 public callerAllocationStartBlock;\r\n    // From this block onwards, a third party caller (not the recipient) can generate and claim the recipient's full allocation\r\n    uint256 public callerAllocationEndBlock;\r\n    // Number of blocks in the caller allocation period as defined by `callerAllocationEndBlock` - `callerAllocationStartBlock`\r\n    uint256 public callerAllocationPeriod;\r\n\r\n    // Track if the generation process is started\r\n    bool public started;\r\n\r\n    // Track the already generated allocations for recipients\r\n    mapping (address => bool) public generated;\r\n\r\n    // Check that a recipient's allocation has not been generated\r\n    modifier notGenerated(address _recipient) {\r\n        require(!generated[_recipient]);\r\n        _;\r\n    }\r\n\r\n    // Check that the generation period is started\r\n    modifier isStarted() {\r\n        require(started);\r\n        _;\r\n    }\r\n\r\n    // Check that the generation period is not started\r\n    modifier isNotStarted() {\r\n        require(!started);\r\n        _;\r\n    }\r\n\r\n    event Generate(address indexed _recipient, address indexed _caller, uint256 _recipientTokenAmount, uint256 _callerTokenAmount, uint256 _block);\r\n\r\n    /**\r\n     * @dev MerkleMine constructor\r\n     * @param _token ERC20 token being distributed\r\n     * @param _genesisRoot Merkle root representing genesis state which encodes token recipients\r\n     * @param _totalGenesisTokens Total amount of tokens that can be generated\r\n     * @param _totalGenesisRecipients Total number of recipients included in genesis state\r\n     * @param _balanceThreshold Minimum ETH balance threshold for recipients included in genesis state\r\n     * @param _genesisBlock Block number of genesis - used to determine which ETH accounts are included in the genesis state\r\n     * @param _callerAllocationStartBlock Start block where a third party caller (not the recipient) can generate and split the allocation with the recipient\r\n     * @param _callerAllocationEndBlock From this block onwards, a third party caller (not the recipient) can generate and claim the recipient's full allocation\r\n     */\r\n    function MerkleMine(\r\n        address _token,\r\n        bytes32 _genesisRoot,\r\n        uint256 _totalGenesisTokens,\r\n        uint256 _totalGenesisRecipients,\r\n        uint256 _balanceThreshold,\r\n        uint256 _genesisBlock,\r\n        uint256 _callerAllocationStartBlock,\r\n        uint256 _callerAllocationEndBlock\r\n    )\r\n        public\r\n    {\r\n        // Address of token contract must not be null\r\n        require(_token != address(0));\r\n        // Number of recipients must be non-zero\r\n        require(_totalGenesisRecipients > 0);\r\n        // Genesis block must be at or before the current block\r\n        require(_genesisBlock <= block.number);\r\n        // Start block for caller allocation must be after current block\r\n        require(_callerAllocationStartBlock > block.number);\r\n        // End block for caller allocation must be after caller allocation start block\r\n        require(_callerAllocationEndBlock > _callerAllocationStartBlock);\r\n\r\n        token = ERC20(_token);\r\n        genesisRoot = _genesisRoot;\r\n        totalGenesisTokens = _totalGenesisTokens;\r\n        totalGenesisRecipients = _totalGenesisRecipients;\r\n        tokensPerAllocation = _totalGenesisTokens.div(_totalGenesisRecipients);\r\n        balanceThreshold = _balanceThreshold;\r\n        genesisBlock = _genesisBlock;\r\n        callerAllocationStartBlock = _callerAllocationStartBlock;\r\n        callerAllocationEndBlock = _callerAllocationEndBlock;\r\n        callerAllocationPeriod = _callerAllocationEndBlock.sub(_callerAllocationStartBlock);\r\n    }\r\n\r\n    /**\r\n     * @dev Start the generation period - first checks that this contract's balance is equal to `totalGenesisTokens`\r\n     * The generation period must not already be started\r\n     */\r\n    function start() external isNotStarted {\r\n        // Check that this contract has a sufficient balance for the generation period\r\n        require(token.balanceOf(this) >= totalGenesisTokens);\r\n\r\n        started = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Generate a recipient's token allocation. Generation period must be started. Starting from `callerAllocationStartBlock`\r\n     * a third party caller (not the recipient) can invoke this function to generate the recipient's token\r\n     * allocation and claim a percentage of it. The percentage of the allocation claimed by the\r\n     * third party caller is determined by how many blocks have elapsed since `callerAllocationStartBlock`.\r\n     * After `callerAllocationEndBlock`, a third party caller can claim the full allocation\r\n     * @param _recipient Recipient of token allocation\r\n     * @param _merkleProof Proof of recipient's inclusion in genesis state Merkle root\r\n     */\r\n    function generate(address _recipient, bytes _merkleProof) external isStarted notGenerated(_recipient) {\r\n        // Check the Merkle proof\r\n        bytes32 leaf = keccak256(_recipient);\r\n        // _merkleProof must prove inclusion of _recipient in the genesis state root\r\n        require(MerkleProof.verifyProof(_merkleProof, genesisRoot, leaf));\r\n\r\n        generated[_recipient] = true;\r\n\r\n        address caller = msg.sender;\r\n\r\n        if (caller == _recipient) {\r\n            // If the caller is the recipient, transfer the full allocation to the caller/recipient\r\n            require(token.transfer(_recipient, tokensPerAllocation));\r\n\r\n            Generate(_recipient, _recipient, tokensPerAllocation, 0, block.number);\r\n        } else {\r\n            // If the caller is not the recipient, the token allocation generation\r\n            // can only take place if we are in the caller allocation period\r\n            require(block.number >= callerAllocationStartBlock);\r\n\r\n            uint256 callerTokenAmount = callerTokenAmountAtBlock(block.number);\r\n            uint256 recipientTokenAmount = tokensPerAllocation.sub(callerTokenAmount);\r\n\r\n            if (callerTokenAmount > 0) {\r\n                require(token.transfer(caller, callerTokenAmount));\r\n            }\r\n\r\n            if (recipientTokenAmount > 0) {\r\n                require(token.transfer(_recipient, recipientTokenAmount));\r\n            }\r\n\r\n            Generate(_recipient, caller, recipientTokenAmount, callerTokenAmount, block.number);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the amount of tokens claimable by a third party caller when generating a recipient's token allocation at a given block\r\n     * @param _blockNumber Block at which to compute the amount of tokens claimable by a third party caller\r\n     */\r\n    function callerTokenAmountAtBlock(uint256 _blockNumber) public view returns (uint256) {\r\n        if (_blockNumber < callerAllocationStartBlock) {\r\n            // If the block is before the start of the caller allocation period, the third party caller can claim nothing\r\n            return 0;\r\n        } else if (_blockNumber >= callerAllocationEndBlock) {\r\n            // If the block is at or after the end block of the caller allocation period, the third party caller can claim everything\r\n            return tokensPerAllocation;\r\n        } else {\r\n            // During the caller allocation period, the third party caller can claim an increasing percentage\r\n            // of the recipient's allocation based on a linear curve - as more blocks pass in the caller allocation\r\n            // period, the amount claimable by the third party caller increases linearly\r\n            uint256 blocksSinceCallerAllocationStartBlock = _blockNumber.sub(callerAllocationStartBlock);\r\n            return tokensPerAllocation.mul(blocksSinceCallerAllocationStartBlock).div(callerAllocationPeriod);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_merkleProof\",\"type\":\"bytes\"}],\"name\":\"generate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"genesisBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"generated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGenesisTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"genesisRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"callerAllocationStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"callerAllocationEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"callerAllocationPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"callerTokenAmountAtBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGenesisRecipients\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_genesisRoot\",\"type\":\"bytes32\"},{\"name\":\"_totalGenesisTokens\",\"type\":\"uint256\"},{\"name\":\"_totalGenesisRecipients\",\"type\":\"uint256\"},{\"name\":\"_balanceThreshold\",\"type\":\"uint256\"},{\"name\":\"_genesisBlock\",\"type\":\"uint256\"},{\"name\":\"_callerAllocationStartBlock\",\"type\":\"uint256\"},{\"name\":\"_callerAllocationEndBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_recipientTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_callerTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"Generate\",\"type\":\"event\"}]","ContractName":"MerkleMine","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ecb81b96e169882b8d6276b87a19cb47efbd1c4a53f35a304a1e1e20d6648e09bb3073ccd44a5bf1638a01355897a71e801879f8000000000000000000000000000000000000000000053f54aa8434ecc3d00000000000000000000000000000000000000000000000000000000000000027a4b7000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000000000000050538900000000000000000000000000000000000000000000000000000000005c0f1700000000000000000000000000000000000000000000000000000000008234b7","Library":"MerkleProof:289ba1701c2f088cf0faf8b3705246331cb8a839","SwarmSource":"bzzr://5d35076b8b058765077c4b44ba0e998f34f5dd270b87b2ee61142443fb50b862"}]}