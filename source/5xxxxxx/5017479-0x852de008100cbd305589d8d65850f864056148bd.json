{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// Owned contract\r\n// -----------------------------------------------------------------------------\r\ncontract Controlled {\r\n\r\n    address public controller;\r\n\r\n    function Controlled() public {\r\n        controller = msg.sender;\r\n    }\r\n\r\n    modifier onlyController() {\r\n        require(msg.sender == controller);\r\n        _;\r\n    }\r\n\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n// Safe maths, borrowed from OpenZeppelin\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n// tokenRecipient contract\r\n// ----------------------------------------------------------------------------\r\ncontract tokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\r\n}\r\n\r\n// standard ERC20 Token interface\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant public returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// AddressLimit contract\r\n// ----------------------------------------------------------------------------\r\ncontract AddressLimit {\r\n    modifier notContractAddress(address _addr) {\r\n        require (!isContractAddress(_addr));\r\n        _;\r\n    }\r\n    \r\n    function isContractAddress(address _addr) internal constant returns(bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// standard ERC20 Token\r\n// ----------------------------------------------------------------------------\r\ncontract standardToken is ERC20Token, AddressLimit {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowances;\r\n    bool public tokenFrozen = true;\r\n    \r\n    /// @param _owner The address that's balance is being requested\r\n    /// @return The balance of `_owner` at the current block\r\n    function balanceOf(\r\n        address _owner) \r\n        constant \r\n        public \r\n        returns (uint256) \r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @notice Send `_value` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value) \r\n        public \r\n        notContractAddress(_to) \r\n        returns (bool success) \r\n    {\r\n        require (!tokenFrozen);                             // Throw if token is frozen\r\n        require (balances[msg.sender] >= _value);           // Throw if sender has insufficient balance\r\n        require (balances[_to] + _value >= balances[_to]);  // Throw if owerflow detected\r\n        balances[msg.sender] -= _value;                     // Deduct senders balance\r\n        balances[_to] += _value;                            // Add recivers balance\r\n        Transfer(msg.sender, _to, _value);                  // Raise Transfer event\r\n        return true;\r\n    }\r\n    \r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(\r\n        address _spender, \r\n        uint256 _value) \r\n        public \r\n        returns (bool success) \r\n    {\r\n        require (!tokenFrozen);                             // Throw if token is frozen\r\n        allowances[msg.sender][_spender] = _value;          // Set allowance\r\n        Approval(msg.sender, _spender, _value);             // Raise Approval event\r\n        return true;\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_value` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(\r\n        address _spender, \r\n        uint256 _value, \r\n        bytes _extraData) \r\n        public \r\n        returns (bool success) \r\n    {\r\n        require (!tokenFrozen);                                         // Throw if token is frozen\r\n        tokenRecipient spender = tokenRecipient(_spender);              // Cast spender to tokenRecipient contract\r\n        approve(_spender, _value);                                      // Set approval to contract for _value\r\n        spender.receiveApproval(msg.sender, _value, this, _extraData);  // Raise method on _spender contract\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send `_value` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value) \r\n        public \r\n        notContractAddress(_to)\r\n        returns (bool success) \r\n    {\r\n        require (!tokenFrozen);                             // Throw if token is frozen\r\n        require (balances[_from] >= _value);                // Throw if sender does not have enough balance\r\n        require (balances[_to] + _value >= balances[_to]);  // Throw if overflow detected\r\n        require (_value <= allowances[_from][msg.sender]);  // Throw if you do not have allowance\r\n        balances[_from] -= _value;                          // Deduct senders balance\r\n        balances[_to] += _value;                            // Add recipient balance\r\n        allowances[_from][msg.sender] -= _value;            // Deduct allowance for this address\r\n        Transfer(_from, _to, _value);                       // Raise Transfer event\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to read the `allowances[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\r\n    function allowance(\r\n        address _owner, \r\n        address _spender) \r\n        constant \r\n        public \r\n        returns (uint256) \r\n    {\r\n        return allowances[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract UseChainToken is standardToken, Controlled {\r\n    \r\n    ///          startCrowdsaleTime                                                          stopCrowdsaleTime          \r\n    ///                  |<private placement>|     |<private presale>|         |<public sale>|\r\n    ///               o-----------------------o----------------------o------------------------------o\r\n    ///                      <10% OFF>                <5%  OFF>   \r\n    ///  payment accepted:   <BTC/ETH>                <BTC/ETH>                <BTC/ETH> \r\n    \r\n    using SafeMath for uint;\r\n\r\n    string constant public name   = \"UseChainToken\";\r\n    string constant public symbol = \"UST\";\r\n    uint constant public decimals = 18;\r\n\r\n    uint256 public totalSupply = 0;\r\n    uint256 constant public topTotalSupply = 2*10**7*10**decimals;\r\n    uint public corporateSupply        = percent(topTotalSupply, 20);\r\n    uint public privatePlacementSupply = percent(topTotalSupply, 8);\r\n    uint public privatePresaleSupply   = percent(topTotalSupply, 12);\r\n    uint public publicSaleSupply       = percent(topTotalSupply, 10);\r\n    uint public ecoFundSupply          = percent(topTotalSupply, 50);\r\n    uint public softCap                = percent(topTotalSupply, 6);\r\n    uint public startCrowdsaleTime;\r\n    uint public stopCrowdsaleTime;\r\n    address public walletAddress;\r\n    bool    public finalized; \r\n    \r\n    /// @notice Several stages\r\n    enum stageAt {\r\n        notStart,\r\n        privatePlacement,\r\n        privatePresale,\r\n        publicSale,\r\n        finalState\r\n    }\r\n    \r\n    /// @notice only Wallet address\r\n    modifier onlyWalletAddr() {\r\n        require (walletAddress == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    /// @dev Fallback to calling deposit when ether is sent directly to contract.\r\n    function() public payable {\r\n        require(!finalized);\r\n        depositToken(msg.value);\r\n        if(this.balance >= 10 ether) {\r\n            walletAddress.transfer(this.balance);\r\n        }\r\n    }\r\n    \r\n    /// @notice Initial function\r\n    function UseChainToken(uint _startCrowdsaleTime, uint _stopCrowdsaleTime, address _walletAddress) public {\r\n        controller = msg.sender;\r\n        startCrowdsaleTime = _startCrowdsaleTime;\r\n        stopCrowdsaleTime = _stopCrowdsaleTime;\r\n        walletAddress = _walletAddress;\r\n    }\r\n    \r\n    /// @dev Buys tokens with Ether.\r\n    function depositToken(uint _value) internal {\r\n        require(_value >= minimalRequire());\r\n        uint tokenAlloc = buyPriceAt(exchangePrice * _value);\r\n        require (tokenAlloc != 0);\r\n        mintTokens(msg.sender, tokenAlloc);\r\n    }\r\n\r\n    /// @dev Issue new tokens\r\n    function mintTokens(address _to, uint _amount) internal {\r\n        require (balances[_to] + _amount >= balances[_to]);      // Check for overflows\r\n        totalSupply = totalSupply.add(_amount);\r\n        require(totalSupply <= topTotalSupply);\r\n        balances[_to] = balances[_to].add(_amount);             // Set minted coins to target\r\n        Transfer(0x0, _to, _amount);                            // Create Transfer event from 0x0\r\n    }\r\n    \r\n    /// @notice Minimal requirement\r\n    function minimalRequire() internal constant returns(uint) {\r\n        if (stageNow() == stageAt.publicSale) {\r\n            return 1 ether;\r\n        }\r\n        if (stageNow() == stageAt.privatePresale) {\r\n            return 10 ether;\r\n        }\r\n        if (stageNow() == stageAt.privatePlacement) {\r\n            return 100 ether;\r\n        }\r\n    }\r\n    \r\n    uint public publicAllocatingToken;\r\n    uint public privatePlacementAllocatingToken;\r\n    uint public privatePresaleAllocatingToken;\r\n    \r\n    /// @notice Calculate exchange:\r\n    /// private Placement Stage : 10% OFF\r\n    /// private Presale Stage   : 5% OFF\r\n    function buyPriceAt(uint256 _tokenAllocWithoutDiscount) internal returns(uint) {\r\n        if (stageNow() == stageAt.publicSale) {\r\n            publicAllocatingToken = publicAllocatingToken.add(_tokenAllocWithoutDiscount);\r\n            require(publicAllocatingToken <= publicSaleSupply);\r\n            return _tokenAllocWithoutDiscount;\r\n        }\r\n        if (stageNow() == stageAt.privatePresale) {\r\n            uint _privatePresaleAlloc = _tokenAllocWithoutDiscount + percent(_tokenAllocWithoutDiscount, 5);\r\n            privatePresaleAllocatingToken = privatePresaleAllocatingToken.add(_privatePresaleAlloc);\r\n            require(privatePresaleAllocatingToken <= privatePresaleSupply);\r\n            return _privatePresaleAlloc;\r\n        }\r\n        if (stageNow() == stageAt.privatePlacement) {\r\n            uint _privatePlacementAlloc = _tokenAllocWithoutDiscount + percent(_tokenAllocWithoutDiscount, 10);\r\n            privatePlacementAllocatingToken = privatePlacementAllocatingToken.add(_privatePlacementAlloc);\r\n            require(privatePlacementAllocatingToken <= privatePlacementSupply);\r\n            return _privatePlacementAlloc;\r\n        }\r\n        if (stageNow() == stageAt.notStart) {\r\n            return 0;\r\n        }\r\n        if (stageNow() == stageAt.finalState) {\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    /// @dev Check the current stage\r\n    function stageNow() constant internal returns (stageAt) {\r\n        if (getTimestamp() < startCrowdsaleTime) {\r\n            return stageAt.notStart;\r\n        }\r\n        else if(getTimestamp() < startCrowdsaleTime + 27 days) {\r\n            return stageAt.privatePlacement;\r\n        }\r\n        else if(getTimestamp() < startCrowdsaleTime + 71 days) {\r\n            return stageAt.privatePresale;\r\n        }\r\n        else if(getTimestamp() < stopCrowdsaleTime) {\r\n            return stageAt.publicSale;\r\n        }\r\n        else {\r\n            return stageAt.finalState;\r\n        }\r\n    }\r\n    \r\n    /// @dev calcute the tokens\r\n    function percent(uint _token, uint _percentage) internal pure returns (uint) {\r\n        return _percentage.mul(_token).div(100);\r\n    }\r\n    \r\n    uint public exchangePrice = 90;\r\n    \r\n    /// @dev Set exchange Price\r\n    function setExchangePrice( uint _price) public onlyController returns(uint) {\r\n        exchangePrice = _price;\r\n    }\r\n    \r\n    /// @dev Get current timestamp\r\n    function getTimestamp() internal constant returns(uint) {\r\n        return now;\r\n    }\r\n    \r\n    function withDraw() public payable onlyController {\r\n        require (walletAddress != address(0));\r\n        walletAddress.transfer(this.balance);\r\n    }\r\n    \r\n    /// @notice unfreeze token transfer\r\n    function unfreezeTokenTransfer(bool _freeze) public onlyController {\r\n        tokenFrozen = !_freeze;\r\n    }\r\n    \r\n    /// @notice only wallet address can set new wallet address\r\n    function setWalletAddress(address _walletAddress) public onlyWalletAddr {\r\n        walletAddress = _walletAddress;\r\n    }\r\n    \r\n    /// @dev allocate private stage tokens\r\n    function allocateTokens(address[] _owners, uint256[] _values) public onlyController {\r\n        require (_owners.length == _values.length);\r\n        for(uint i = 0; i < _owners.length ; i++){\r\n            address owner = _owners[i];\r\n            uint value = _values[i];\r\n            mintTokens(owner, value);\r\n        }\r\n    }\r\n    \r\n\r\n    function allocateCorporateToken(address _corAccount, uint256 _amount) public onlyController {\r\n        require(_corAccount != address(0));\r\n        require(balances[_corAccount] + _amount <= corporateSupply);\r\n        mintTokens(_corAccount, _amount);\r\n    }\r\n    \r\n    uint public ecoFundingSupply;\r\n    \r\n    function allocateEcoFundToken(address[] _owners, uint256[] _values) public onlyController {\r\n        require (_owners.length == _values.length);\r\n        for(uint i = 0; i < _owners.length ; i++){\r\n            address owner = _owners[i];\r\n            uint256 value = _values[i];\r\n            ecoFundingSupply = ecoFundingSupply.add(value);\r\n            require(ecoFundingSupply <= ecoFundSupply);\r\n            mintTokens(owner, value);\r\n        }\r\n    }\r\n        \r\n    /// @notice finalize\r\n    function finalize() public onlyController {\r\n        // only after closed stage\r\n        require(stageNow() == stageAt.finalState);     \r\n        require(totalSupply + ecoFundSupply >= softCap);\r\n        finalized = true;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withDraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopCrowdsaleTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privatePresaleAllocatingToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ecoFundingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicAllocatingToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privatePresaleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"corporateSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privatePlacementSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"allocateEcoFundToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"topTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setExchangePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"allocateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startCrowdsaleTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_walletAddress\",\"type\":\"address\"}],\"name\":\"setWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ecoFundSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"unfreezeTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privatePlacementAllocatingToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicSaleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_corAccount\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"allocateCorporateToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startCrowdsaleTime\",\"type\":\"uint256\"},{\"name\":\"_stopCrowdsaleTime\",\"type\":\"uint256\"},{\"name\":\"_walletAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"UseChainToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005a393780000000000000000000000000000000000000000000000000000000005c2a3d0000000000000000000000000041efd65d4f101ff729d93e7a2b7f9e22f9033332","Library":"","SwarmSource":"bzzr://81f4e4065375c90ba218064c811305fcdb669eb65cf4ad3e248dff55d45e6eb9"}]}