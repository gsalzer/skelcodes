{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Drainable is Ownable {\r\n\tfunction withdrawToken(address tokenaddr) \r\n\t\tonlyOwner\r\n\t\tpublic\r\n\t{\r\n\t\tERC20 token = ERC20(tokenaddr);\r\n\t\tuint bal = token.balanceOf(address(this));\r\n\t\ttoken.transfer(msg.sender, bal);\r\n\t}\r\n\r\n\tfunction withdrawEther() \r\n\t\tonlyOwner\r\n\t\tpublic\r\n\t{\r\n\t    require(msg.sender.send(this.balance));\r\n\t}\r\n}\r\n\r\ncontract ADXExchangeInterface {\r\n\t// events\r\n\tevent LogBidAccepted(bytes32 bidId, address advertiser, bytes32 adunit, address publisher, bytes32 adslot, uint acceptedTime);\r\n\tevent LogBidCanceled(bytes32 bidId);\r\n\tevent LogBidExpired(bytes32 bidId);\r\n\tevent LogBidConfirmed(bytes32 bidId, address advertiserOrPublisher, bytes32 report);\r\n\tevent LogBidCompleted(bytes32 bidId, bytes32 advReport, bytes32 pubReport);\r\n\r\n\tevent LogDeposit(address _user, uint _amnt);\r\n\tevent LogWithdrawal(address _user, uint _amnt);\r\n\r\n\tfunction acceptBid(address _advertiser, bytes32 _adunit, uint _opened, uint _target, uint _rewardAmount, uint _timeout, bytes32 _adslot, uint8 v, bytes32 r, bytes32 s, uint8 sigMode) public;\r\n\tfunction cancelBid(bytes32 _adunit, uint _opened, uint _target, uint _rewardAmount, uint _timeout, uint8 v, bytes32 r, bytes32 s, uint8 sigMode) public;\r\n\tfunction giveupBid(bytes32 _bidId) public;\r\n\tfunction refundBid(bytes32 _bidId) public;\r\n\tfunction verifyBid(bytes32 _bidId, bytes32 _report) public;\r\n\r\n\tfunction deposit(uint _amount) public;\r\n\tfunction withdraw(uint _amount) public;\r\n\r\n\t// constants \r\n\tfunction getBid(bytes32 _bidId) \r\n\t\tconstant external \r\n\t\treturns (\r\n\t\t\tuint, uint, uint, uint, uint, \r\n\t\t\t// advertiser (advertiser, ad unit, confiration)\r\n\t\t\taddress, bytes32, bytes32,\r\n\t\t\t// publisher (publisher, ad slot, confirmation)\r\n\t\t\taddress, bytes32, bytes32\r\n\t\t);\r\n\r\n\tfunction getBalance(address _user)\r\n\t\tconstant\r\n\t\texternal\r\n\t\treturns (uint, uint);\r\n\r\n\tfunction getBidID(address _advertiser, bytes32 _adunit, uint _opened, uint _target, uint _amount, uint _timeout)\r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (bytes32);\r\n}\r\n\r\n\r\ncontract ADXExchange is ADXExchangeInterface, Drainable {\r\n\tstring public name = \"AdEx Exchange\";\r\n\r\n\tERC20 public token;\r\n\r\n\tuint public maxTimeout = 365 days;\r\n\r\n \tmapping (address => uint) balances;\r\n\r\n \t// escrowed on bids\r\n \tmapping (address => uint) onBids; \r\n\r\n \t// bid info\r\n\tmapping (bytes32 => Bid) bids;\r\n\tmapping (bytes32 => BidState) bidStates;\r\n\r\n\r\n\tenum BidState { \r\n\t\tDoesNotExist, // default state\r\n\r\n\t\t// There is no 'Open' state - the Open state is just a signed message that you're willing to place such a bid\r\n\t\tAccepted, // in progress\r\n\r\n\t\t// the following states MUST unlock the ADX amount (return to advertiser)\r\n\t\t// fail states\r\n\t\tCanceled,\r\n\t\tExpired,\r\n\r\n\t\t// success states\r\n\t\tCompleted\r\n\t}\r\n\r\n\tstruct Bid {\r\n\t\t// Links on advertiser side\r\n\t\taddress advertiser;\r\n\t\tbytes32 adUnit;\r\n\r\n\t\t// Links on publisher side\r\n\t\taddress publisher;\r\n\t\tbytes32 adSlot;\r\n\r\n\t\t// when was it accepted by a publisher\r\n\t\tuint acceptedTime;\r\n\r\n\t\t// Token reward amount\r\n\t\tuint amount;\r\n\r\n\t\t// Requirements\r\n\t\tuint target; // how many impressions/clicks/conversions have to be done\r\n\t\tuint timeout; // the time to execute\r\n\r\n\t\t// Confirmations from both sides; any value other than 0 is vconsidered as confirm, but this should usually be an IPFS hash to a final report\r\n\t\tbytes32 publisherConfirmation;\r\n\t\tbytes32 advertiserConfirmation;\r\n\t}\r\n\r\n\t// Schema hash \r\n\t// keccak256(_advertiser, _adunit, _opened, _target, _amount, _timeout, this)\r\n\tbytes32 constant public SCHEMA_HASH = keccak256(\r\n\t\t\"address Advertiser\",\r\n\t\t\"bytes32 Ad Unit ID\",\r\n\t\t\"uint Opened\",\r\n\t\t\"uint Target\",\r\n\t\t\"uint Amount\",\r\n\t\t\"uint Timeout\",\r\n\t\t\"address Exchange\"\r\n\t);\r\n\r\n\t//\r\n\t// MODIFIERS\r\n\t//\r\n\tmodifier onlyBidAdvertiser(bytes32 _bidId) {\r\n\t\trequire(msg.sender == bids[_bidId].advertiser);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyBidPublisher(bytes32 _bidId) {\r\n\t\trequire(msg.sender == bids[_bidId].publisher);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyBidState(bytes32 _bidId, BidState _state) {\r\n\t\trequire(bidStates[_bidId] == _state);\r\n\t\t_;\r\n\t}\r\n\r\n\t// Functions\r\n\r\n\tfunction ADXExchange(address _token)\r\n\t\tpublic\r\n\t{\r\n\t\ttoken = ERC20(_token);\r\n\t}\r\n\r\n\t//\r\n\t// Bid actions\r\n\t// \r\n\r\n\t// the bid is accepted by the publisher\r\n\tfunction acceptBid(address _advertiser, bytes32 _adunit, uint _opened, uint _target, uint _amount, uint _timeout, bytes32 _adslot, uint8 v, bytes32 r, bytes32 s, uint8 sigMode)\r\n\t\tpublic\r\n\t{\r\n\t\trequire(_amount > 0);\r\n\r\n\t\t// It can be proven that onBids will never exceed balances which means this can't underflow\r\n\t\t// SafeMath can't be used here because of the stack depth\r\n\t\trequire(_amount <= (balances[_advertiser] - onBids[_advertiser]));\r\n\r\n\t\t// _opened acts as a nonce here\r\n\t\tbytes32 bidId = getBidID(_advertiser, _adunit, _opened, _target, _amount, _timeout);\r\n\r\n\t\trequire(bidStates[bidId] == BidState.DoesNotExist);\r\n\r\n\t\trequire(didSign(_advertiser, bidId, v, r, s, sigMode));\r\n\t\t\r\n\t\t// advertier and publisher cannot be the same\r\n\t\trequire(_advertiser != msg.sender);\r\n\r\n\t\tBid storage bid = bids[bidId];\r\n\r\n\t\tbid.target = _target;\r\n\t\tbid.amount = _amount;\r\n\r\n\t\t// it is pretty much mandatory for a bid to have a timeout, else tokens can be stuck forever\r\n\t\tbid.timeout = _timeout > 0 ? _timeout : maxTimeout;\r\n\t\trequire(bid.timeout <= maxTimeout);\r\n\r\n\t\tbid.advertiser = _advertiser;\r\n\t\tbid.adUnit = _adunit;\r\n\r\n\t\tbid.publisher = msg.sender;\r\n\t\tbid.adSlot = _adslot;\r\n\r\n\t\tbid.acceptedTime = now;\r\n\r\n\t\tbidStates[bidId] = BidState.Accepted;\r\n\r\n\t\tonBids[_advertiser] += _amount;\r\n\r\n\t\t// static analysis?\r\n\t\t// require(onBids[_advertiser] <= balances[advertiser]);\r\n\r\n\t\tLogBidAccepted(bidId, _advertiser, _adunit, msg.sender, _adslot, bid.acceptedTime);\r\n\t}\r\n\r\n\t// The bid is canceled by the advertiser\r\n\tfunction cancelBid(bytes32 _adunit, uint _opened, uint _target, uint _amount, uint _timeout, uint8 v, bytes32 r, bytes32 s, uint8 sigMode)\r\n\t\tpublic\r\n\t{\r\n\t\t// _opened acts as a nonce here\r\n\t\tbytes32 bidId = getBidID(msg.sender, _adunit, _opened, _target, _amount, _timeout);\r\n\r\n\t\trequire(bidStates[bidId] == BidState.DoesNotExist);\r\n\r\n\t\trequire(didSign(msg.sender, bidId, v, r, s, sigMode));\r\n\r\n\t\tbidStates[bidId] = BidState.Canceled;\r\n\r\n\t\tLogBidCanceled(bidId);\r\n\t}\r\n\r\n\t// The bid is canceled by the publisher\r\n\tfunction giveupBid(bytes32 _bidId)\r\n\t\tpublic\r\n\t\tonlyBidPublisher(_bidId)\r\n\t\tonlyBidState(_bidId, BidState.Accepted)\r\n\t{\r\n\t\tBid storage bid = bids[_bidId];\r\n\r\n\t\tbidStates[_bidId] = BidState.Canceled;\r\n\r\n\t\tonBids[bid.advertiser] -= bid.amount;\r\n\t\r\n\t\tLogBidCanceled(_bidId);\r\n\t}\r\n\r\n\r\n\t// This can be done if a bid is accepted, but expired\r\n\t// This is essentially the protection from never settling on verification, or from publisher not executing the bid within a reasonable time\r\n\tfunction refundBid(bytes32 _bidId)\r\n\t\tpublic\r\n\t\tonlyBidAdvertiser(_bidId)\r\n\t\tonlyBidState(_bidId, BidState.Accepted)\r\n\t{\r\n\t\tBid storage bid = bids[_bidId];\r\n\r\n \t\t// require that we're past the point of expiry\r\n\t\trequire(now > SafeMath.add(bid.acceptedTime, bid.timeout));\r\n\r\n\t\tbidStates[_bidId] = BidState.Expired;\r\n\r\n\t\tonBids[bid.advertiser] -= bid.amount;\r\n\r\n\t\tLogBidExpired(_bidId);\r\n\t}\r\n\r\n\r\n\t// both publisher and advertiser have to call this for a bid to be considered verified\r\n\tfunction verifyBid(bytes32 _bidId, bytes32 _report)\r\n\t\tpublic\r\n\t\tonlyBidState(_bidId, BidState.Accepted)\r\n\t{\r\n\t\tBid storage bid = bids[_bidId];\r\n\r\n\t\trequire(_report != 0);\r\n\t\trequire(bid.publisher == msg.sender || bid.advertiser == msg.sender);\r\n\r\n\t\tif (bid.publisher == msg.sender) {\r\n\t\t\trequire(bid.publisherConfirmation == 0);\r\n\t\t\tbid.publisherConfirmation = _report;\r\n\t\t}\r\n\r\n\t\tif (bid.advertiser == msg.sender) {\r\n\t\t\trequire(bid.advertiserConfirmation == 0);\r\n\t\t\tbid.advertiserConfirmation = _report;\r\n\t\t}\r\n\r\n\t\tLogBidConfirmed(_bidId, msg.sender, _report);\r\n\r\n\t\tif (bid.advertiserConfirmation != 0 && bid.publisherConfirmation != 0) {\r\n\t\t\tbidStates[_bidId] = BidState.Completed;\r\n\r\n\t\t\tonBids[bid.advertiser] = SafeMath.sub(onBids[bid.advertiser], bid.amount);\r\n\t\t\tbalances[bid.advertiser] = SafeMath.sub(balances[bid.advertiser], bid.amount);\r\n\t\t\tbalances[bid.publisher] = SafeMath.add(balances[bid.publisher], bid.amount);\r\n\r\n\t\t\tLogBidCompleted(_bidId, bid.advertiserConfirmation, bid.publisherConfirmation);\r\n\t\t}\r\n\t}\r\n\r\n\t// Deposit and withdraw\r\n\tfunction deposit(uint _amount)\r\n\t\tpublic\r\n\t{\r\n\t\tbalances[msg.sender] = SafeMath.add(balances[msg.sender], _amount);\r\n\t\trequire(token.transferFrom(msg.sender, address(this), _amount));\r\n\r\n\t\tLogDeposit(msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction withdraw(uint _amount)\r\n\t\tpublic\r\n\t{\r\n\t\tuint available = SafeMath.sub(balances[msg.sender], onBids[msg.sender]);\r\n\t\trequire(_amount <= available);\r\n\r\n\t\tbalances[msg.sender] = SafeMath.sub(balances[msg.sender], _amount);\r\n\t\trequire(token.transfer(msg.sender, _amount));\r\n\r\n\t\tLogWithdrawal(msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction didSign(address addr, bytes32 hash, uint8 v, bytes32 r, bytes32 s, uint8 mode)\r\n\t\tpublic\r\n\t\tpure\r\n\t\treturns (bool)\r\n\t{\r\n\t\tbytes32 message = hash;\r\n\t\t\r\n\t\tif (mode == 1) {\r\n\t\t\t// Geth mode\r\n\t\t\tmessage = keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash);\r\n\t\t} else if (mode == 2) {\r\n\t\t\t// Trezor mode\r\n\t\t\tmessage = keccak256(\"\\x19Ethereum Signed Message:\\n\\x20\", hash);\r\n\t\t}\r\n\r\n\t\treturn ecrecover(message, v, r, s) == addr;\r\n\t}\r\n\r\n\t//\r\n\t// Public constant functions\r\n\t//\r\n\tfunction getBid(bytes32 _bidId) \r\n\t\tconstant\r\n\t\texternal\r\n\t\treturns (\r\n\t\t\tuint, uint, uint, uint, uint, \r\n\t\t\t// advertiser (advertiser, ad unit, confiration)\r\n\t\t\taddress, bytes32, bytes32,\r\n\t\t\t// publisher (publisher, ad slot, confirmation)\r\n\t\t\taddress, bytes32, bytes32\r\n\t\t)\r\n\t{\r\n\t\tBid storage bid = bids[_bidId];\r\n\t\treturn (\r\n\t\t\tuint(bidStates[_bidId]), bid.target, bid.timeout, bid.amount, bid.acceptedTime,\r\n\t\t\tbid.advertiser, bid.adUnit, bid.advertiserConfirmation,\r\n\t\t\tbid.publisher, bid.adSlot, bid.publisherConfirmation\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getBalance(address _user)\r\n\t\tconstant\r\n\t\texternal\r\n\t\treturns (uint, uint)\r\n\t{\r\n\t\treturn (balances[_user], onBids[_user]);\r\n\t}\r\n\r\n\tfunction getBidID(address _advertiser, bytes32 _adunit, uint _opened, uint _target, uint _amount, uint _timeout)\r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(\r\n\t\t\tSCHEMA_HASH,\r\n\t\t\tkeccak256(_advertiser, _adunit, _opened, _target, _amount, _timeout, this)\r\n\t\t);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adunit\",\"type\":\"bytes32\"},{\"name\":\"_opened\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_timeout\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"sigMode\",\"type\":\"uint8\"}],\"name\":\"cancelBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCHEMA_HASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"mode\",\"type\":\"uint8\"}],\"name\":\"didSign\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"bytes32\"}],\"name\":\"refundBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"bytes32\"},{\"name\":\"_report\",\"type\":\"bytes32\"}],\"name\":\"verifyBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_advertiser\",\"type\":\"address\"},{\"name\":\"_adunit\",\"type\":\"bytes32\"},{\"name\":\"_opened\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_timeout\",\"type\":\"uint256\"},{\"name\":\"_adslot\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"sigMode\",\"type\":\"uint8\"}],\"name\":\"acceptBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenaddr\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"bytes32\"}],\"name\":\"getBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"bytes32\"}],\"name\":\"giveupBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_advertiser\",\"type\":\"address\"},{\"name\":\"_adunit\",\"type\":\"bytes32\"},{\"name\":\"_opened\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_timeout\",\"type\":\"uint256\"}],\"name\":\"getBidID\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"advertiser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"adunit\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"publisher\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"adslot\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"acceptedTime\",\"type\":\"uint256\"}],\"name\":\"LogBidAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"bytes32\"}],\"name\":\"LogBidCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"bytes32\"}],\"name\":\"LogBidExpired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"advertiserOrPublisher\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"report\",\"type\":\"bytes32\"}],\"name\":\"LogBidConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"advReport\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"pubReport\",\"type\":\"bytes32\"}],\"name\":\"LogBidCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amnt\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amnt\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawal\",\"type\":\"event\"}]","ContractName":"ADXExchange","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004470bb87d77b963a013db939be332f927f2b992e","Library":"","SwarmSource":"bzzr://138093af8d02cda89628de2004a445a562ebd86a76aa008e5301e6810fd23aa4"}]}