{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Sales{\r\n\r\n\tenum ICOSaleState{\r\n\t\tPrivateSale,\r\n\t    PreSale,\r\n\t    PublicSale,\r\n\t    Success,\r\n\t    Failed\r\n\t }\r\n}\r\n\r\ncontract Utils{\r\n\r\n\t//verifies the amount greater than zero\r\n\r\n\tmodifier greaterThanZero(uint256 _value){\r\n\t\trequire(_value>0);\r\n\t\t_;\r\n\t}\r\n\r\n\t///verifies an address\r\n\r\n\tmodifier validAddress(address _add){\r\n\t\trequire(_add!=0x0);\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*  ERC 20 token */\r\ncontract GACToken is Token,Ownable,Sales {\r\n    string public constant name = \"Gladage Care Token\";\r\n    string public constant symbol = \"GAC\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n    uint public valueToBeSent = 1;\r\n\r\n    bool public finalizedICO = false;\r\n\r\n    uint256 public ethraised;\r\n    uint256 public btcraised;\r\n    uint256 public usdraised;\r\n\r\n    bool public istransferAllowed;\r\n\r\n    uint256 public constant GACFund = 5 * (10**8) * 10**decimals; \r\n    uint256 public fundingStartBlock; // crowdsale start unix //now\r\n    uint256 public fundingEndBlock; // crowdsale end unix //1530403200 //07/01/2018 @ 12:00am (UTC)\r\n    uint256 public tokenCreationMax= 275 * (10**6) * 10**decimals;//TODO\r\n    mapping (address => bool) ownership;\r\n    uint256 public minCapUSD = 2000000;\r\n    uint256 public maxCapUSD = 20000000;\r\n\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n      if(!istransferAllowed) throw;\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function burnTokens(uint256 _value) public{\r\n        require(balances[msg.sender]>=_value);\r\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender],_value);\r\n        totalSupply =SafeMath.sub(totalSupply,_value);\r\n    }\r\n\r\n\r\n    //this is the default constructor\r\n    function GACToken(uint256 _fundingStartBlock, uint256 _fundingEndBlock){\r\n        totalSupply = GACFund;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n    }\r\n\r\n    ///change the funding end block\r\n    function changeEndBlock(uint256 _newFundingEndBlock) onlyOwner{\r\n        fundingEndBlock = _newFundingEndBlock;\r\n    }\r\n\r\n    ///change the funding start block\r\n    function changeStartBlock(uint256 _newFundingStartBlock) onlyOwner{\r\n        fundingStartBlock = _newFundingStartBlock;\r\n    }\r\n\r\n    ///the Min Cap USD \r\n    ///function too chage the miin cap usd\r\n    function changeMinCapUSD(uint256 _newMinCap) onlyOwner{\r\n        minCapUSD = _newMinCap;\r\n    }\r\n\r\n    ///fucntion to change the max cap usd\r\n    function changeMaxCapUSD(uint256 _newMaxCap) onlyOwner{\r\n        maxCapUSD = _newMaxCap;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n      if(!istransferAllowed) throw;\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n\r\n    function addToBalances(address _person,uint256 value) {\r\n        if(!ownership[msg.sender]) throw;\r\n        balances[_person] = SafeMath.add(balances[_person],value);\r\n        Transfer(address(this), _person, value);\r\n    }\r\n\r\n    function addToOwnership(address owners) onlyOwner{\r\n        ownership[owners] = true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    function increaseEthRaised(uint256 value){\r\n        if(!ownership[msg.sender]) throw;\r\n        ethraised+=value;\r\n    }\r\n\r\n    function increaseBTCRaised(uint256 value){\r\n        if(!ownership[msg.sender]) throw;\r\n        btcraised+=value;\r\n    }\r\n\r\n    function increaseUSDRaised(uint256 value){\r\n        if(!ownership[msg.sender]) throw;\r\n        usdraised+=value;\r\n    }\r\n\r\n    function finalizeICO(){\r\n        if(!ownership[msg.sender]) throw;\r\n        ///replace the below amount of 10000 with the min cap usd value\r\n        ///havent recieved the valus yet :(\r\n        if(usdraised<minCapUSD) throw;\r\n        finalizedICO = true;\r\n        istransferAllowed = true;\r\n    }\r\n\r\n    function enableTransfers() public onlyOwner{\r\n        istransferAllowed = true;\r\n    }\r\n\r\n    function disableTransfers() public onlyOwner{\r\n        istransferAllowed = false;\r\n    }\r\n\r\n    //functiion to force finalize the ICO by the owner no checks called here\r\n    function finalizeICOOwner() onlyOwner{\r\n        finalizedICO = true;\r\n        istransferAllowed = true;\r\n    }\r\n\r\n    function isValid() returns(bool){\r\n        if(now>=fundingStartBlock && now<fundingEndBlock ){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n        if(usdraised>maxCapUSD) throw;\r\n    }\r\n\r\n    ///do not allow payments on this address\r\n\r\n    function() payable{\r\n        throw;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  modifier stopInEmergency {\r\n    if (paused) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n// Bitcoin transaction parsing library\r\n\r\n// Copyright 2016 rain <https://keybase.io/rain>\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\r\n//\r\n// Raw Bitcoin transaction structure:\r\n//\r\n// field     | size | type     | description\r\n// version   | 4    | int32    | transaction version number\r\n// n_tx_in   | 1-9  | var_int  | number of transaction inputs\r\n// tx_in     | 41+  | tx_in[]  | list of transaction inputs\r\n// n_tx_out  | 1-9  | var_int  | number of transaction outputs\r\n// tx_out    | 9+   | tx_out[] | list of transaction outputs\r\n// lock_time | 4    | uint32   | block number / timestamp at which tx locked\r\n//\r\n// Transaction input (tx_in) structure:\r\n//\r\n// field      | size | type     | description\r\n// previous   | 36   | outpoint | Previous output transaction reference\r\n// script_len | 1-9  | var_int  | Length of the signature script\r\n// sig_script | ?    | uchar[]  | Script for confirming transaction authorization\r\n// sequence   | 4    | uint32   | Sender transaction version\r\n//\r\n// OutPoint structure:\r\n//\r\n// field      | size | type     | description\r\n// hash       | 32   | char[32] | The hash of the referenced transaction\r\n// index      | 4    | uint32   | The index of this output in the referenced transaction\r\n//\r\n// Transaction output (tx_out) structure:\r\n//\r\n// field         | size | type     | description\r\n// value         | 8    | int64    | Transaction value (Satoshis)\r\n// pk_script_len | 1-9  | var_int  | Length of the public key script\r\n// pk_script     | ?    | uchar[]  | Public key as a Bitcoin script.\r\n//\r\n// Variable integers (var_int) can be encoded differently depending\r\n// on the represented value, to save space. Variable integers always\r\n// precede an array of a variable length data type (e.g. tx_in).\r\n//\r\n// Variable integer encodings as a function of represented value:\r\n//\r\n// value           | bytes  | format\r\n// <0xFD (253)     | 1      | uint8\r\n// <=0xFFFF (65535)| 3      | 0xFD followed by length as uint16\r\n// <=0xFFFF FFFF   | 5      | 0xFE followed by length as uint32\r\n// -               | 9      | 0xFF followed by length as uint64\r\n//\r\n// Public key scripts `pk_script` are set on the output and can\r\n// take a number of forms. The regular transaction script is\r\n// called 'pay-to-pubkey-hash' (P2PKH):\r\n//\r\n// OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\r\n//\r\n// OP_x are Bitcoin script opcodes. The bytes representation (including\r\n// the 0x14 20-byte stack push) is:\r\n//\r\n// 0x76 0xA9 0x14 <pubKeyHash> 0x88 0xAC\r\n//\r\n// The <pubKeyHash> is the ripemd160 hash of the sha256 hash of\r\n// the public key, preceded by a network version byte. (21 bytes total)\r\n//\r\n// Network version bytes: 0x00 (mainnet); 0x6f (testnet); 0x34 (namecoin)\r\n//\r\n// The Bitcoin address is derived from the pubKeyHash. The binary form is the\r\n// pubKeyHash, plus a checksum at the end.  The checksum is the first 4 bytes\r\n// of the (32 byte) double sha256 of the pubKeyHash. (25 bytes total)\r\n// This is converted to base58 to form the publicly used Bitcoin address.\r\n// Mainnet P2PKH transaction scripts are to addresses beginning with '1'.\r\n//\r\n// P2SH ('pay to script hash') scripts only supply a script hash. The spender\r\n// must then provide the script that would allow them to redeem this output.\r\n// This allows for arbitrarily complex scripts to be funded using only a\r\n// hash of the script, and moves the onus on providing the script from\r\n// the spender to the redeemer.\r\n//\r\n// The P2SH script format is simple:\r\n//\r\n// OP_HASH160 <scriptHash> OP_EQUAL\r\n//\r\n// 0xA9 0x14 <scriptHash> 0x87\r\n//\r\n// The <scriptHash> is the ripemd160 hash of the sha256 hash of the\r\n// redeem script. The P2SH address is derived from the scriptHash.\r\n// Addresses are the scriptHash with a version prefix of 5, encoded as\r\n// Base58check. These addresses begin with a '3'.\r\n\r\n\r\n\r\n// parse a raw bitcoin transaction byte array\r\nlibrary BTC {\r\n    // Convert a variable integer into something useful and return it and\r\n    // the index to after it.\r\n    function parseVarInt(bytes txBytes, uint pos) returns (uint, uint) {\r\n        // the first byte tells us how big the integer is\r\n        var ibit = uint8(txBytes[pos]);\r\n        pos += 1;  // skip ibit\r\n\r\n        if (ibit < 0xfd) {\r\n            return (ibit, pos);\r\n        } else if (ibit == 0xfd) {\r\n            return (getBytesLE(txBytes, pos, 16), pos + 2);\r\n        } else if (ibit == 0xfe) {\r\n            return (getBytesLE(txBytes, pos, 32), pos + 4);\r\n        } else if (ibit == 0xff) {\r\n            return (getBytesLE(txBytes, pos, 64), pos + 8);\r\n        }\r\n    }\r\n    // convert little endian bytes to uint\r\n    function getBytesLE(bytes data, uint pos, uint bits) returns (uint) {\r\n        if (bits == 8) {\r\n            return uint8(data[pos]);\r\n        } else if (bits == 16) {\r\n            return uint16(data[pos])\r\n                 + uint16(data[pos + 1]) * 2 ** 8;\r\n        } else if (bits == 32) {\r\n            return uint32(data[pos])\r\n                 + uint32(data[pos + 1]) * 2 ** 8\r\n                 + uint32(data[pos + 2]) * 2 ** 16\r\n                 + uint32(data[pos + 3]) * 2 ** 24;\r\n        } else if (bits == 64) {\r\n            return uint64(data[pos])\r\n                 + uint64(data[pos + 1]) * 2 ** 8\r\n                 + uint64(data[pos + 2]) * 2 ** 16\r\n                 + uint64(data[pos + 3]) * 2 ** 24\r\n                 + uint64(data[pos + 4]) * 2 ** 32\r\n                 + uint64(data[pos + 5]) * 2 ** 40\r\n                 + uint64(data[pos + 6]) * 2 ** 48\r\n                 + uint64(data[pos + 7]) * 2 ** 56;\r\n        }\r\n    }\r\n    // scan the full transaction bytes and return the first two output\r\n    // values (in satoshis) and addresses (in binary)\r\n    function getFirstTwoOutputs(bytes txBytes)\r\n             returns (uint, bytes20, uint, bytes20)\r\n    {\r\n        uint pos;\r\n        uint[] memory input_script_lens = new uint[](2);\r\n        uint[] memory output_script_lens = new uint[](2);\r\n        uint[] memory script_starts = new uint[](2);\r\n        uint[] memory output_values = new uint[](2);\r\n        bytes20[] memory output_addresses = new bytes20[](2);\r\n\r\n        pos = 4;  // skip version\r\n\r\n        (input_script_lens, pos) = scanInputs(txBytes, pos, 0);\r\n\r\n        (output_values, script_starts, output_script_lens, pos) = scanOutputs(txBytes, pos, 2);\r\n\r\n        for (uint i = 0; i < 2; i++) {\r\n            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\r\n            output_addresses[i] = pkhash;\r\n        }\r\n\r\n        return (output_values[0], output_addresses[0],\r\n                output_values[1], output_addresses[1]);\r\n    }\r\n    // Check whether `btcAddress` is in the transaction outputs *and*\r\n    // whether *at least* `value` has been sent to it.\r\n        // Check whether `btcAddress` is in the transaction outputs *and*\r\n    // whether *at least* `value` has been sent to it.\r\n    function checkValueSent(bytes txBytes, bytes20 btcAddress, uint value)\r\n             returns (bool,uint)\r\n    {\r\n        uint pos = 4;  // skip version\r\n        (, pos) = scanInputs(txBytes, pos, 0);  // find end of inputs\r\n\r\n        // scan *all* the outputs and find where they are\r\n        var (output_values, script_starts, output_script_lens,) = scanOutputs(txBytes, pos, 0);\r\n\r\n        // look at each output and check whether it at least value to btcAddress\r\n        for (uint i = 0; i < output_values.length; i++) {\r\n            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\r\n            if (pkhash == btcAddress && output_values[i] >= value) {\r\n                return (true,output_values[i]);\r\n            }\r\n        }\r\n    }\r\n    // scan the inputs and find the script lengths.\r\n    // return an array of script lengths and the end position\r\n    // of the inputs.\r\n    // takes a 'stop' argument which sets the maximum number of\r\n    // outputs to scan through. stop=0 => scan all.\r\n    function scanInputs(bytes txBytes, uint pos, uint stop)\r\n             returns (uint[], uint)\r\n    {\r\n        uint n_inputs;\r\n        uint halt;\r\n        uint script_len;\r\n\r\n        (n_inputs, pos) = parseVarInt(txBytes, pos);\r\n\r\n        if (stop == 0 || stop > n_inputs) {\r\n            halt = n_inputs;\r\n        } else {\r\n            halt = stop;\r\n        }\r\n\r\n        uint[] memory script_lens = new uint[](halt);\r\n\r\n        for (var i = 0; i < halt; i++) {\r\n            pos += 36;  // skip outpoint\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            script_lens[i] = script_len;\r\n            pos += script_len + 4;  // skip sig_script, seq\r\n        }\r\n\r\n        return (script_lens, pos);\r\n    }\r\n    // scan the outputs and find the values and script lengths.\r\n    // return array of values, array of script lengths and the\r\n    // end position of the outputs.\r\n    // takes a 'stop' argument which sets the maximum number of\r\n    // outputs to scan through. stop=0 => scan all.\r\n    function scanOutputs(bytes txBytes, uint pos, uint stop)\r\n             returns (uint[], uint[], uint[], uint)\r\n    {\r\n        uint n_outputs;\r\n        uint halt;\r\n        uint script_len;\r\n\r\n        (n_outputs, pos) = parseVarInt(txBytes, pos);\r\n\r\n        if (stop == 0 || stop > n_outputs) {\r\n            halt = n_outputs;\r\n        } else {\r\n            halt = stop;\r\n        }\r\n\r\n        uint[] memory script_starts = new uint[](halt);\r\n        uint[] memory script_lens = new uint[](halt);\r\n        uint[] memory output_values = new uint[](halt);\r\n\r\n        for (var i = 0; i < halt; i++) {\r\n            output_values[i] = getBytesLE(txBytes, pos, 64);\r\n            pos += 8;\r\n\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            script_starts[i] = pos;\r\n            script_lens[i] = script_len;\r\n            pos += script_len;\r\n        }\r\n\r\n        return (output_values, script_starts, script_lens, pos);\r\n    }\r\n    // Slice 20 contiguous bytes from bytes `data`, starting at `start`\r\n    function sliceBytes20(bytes data, uint start) returns (bytes20) {\r\n        uint160 slice = 0;\r\n        for (uint160 i = 0; i < 20; i++) {\r\n            slice += uint160(data[i + start]) << (8 * (19 - i));\r\n        }\r\n        return bytes20(slice);\r\n    }\r\n    // returns true if the bytes located in txBytes by pos and\r\n    // script_len represent a P2PKH script\r\n    function isP2PKH(bytes txBytes, uint pos, uint script_len) returns (bool) {\r\n        return (script_len == 25)           // 20 byte pubkeyhash + 5 bytes of script\r\n            && (txBytes[pos] == 0x76)       // OP_DUP\r\n            && (txBytes[pos + 1] == 0xa9)   // OP_HASH160\r\n            && (txBytes[pos + 2] == 0x14)   // bytes to push\r\n            && (txBytes[pos + 23] == 0x88)  // OP_EQUALVERIFY\r\n            && (txBytes[pos + 24] == 0xac); // OP_CHECKSIG\r\n    }\r\n    // returns true if the bytes located in txBytes by pos and\r\n    // script_len represent a P2SH script\r\n    function isP2SH(bytes txBytes, uint pos, uint script_len) returns (bool) {\r\n        return (script_len == 23)           // 20 byte scripthash + 3 bytes of script\r\n            && (txBytes[pos + 0] == 0xa9)   // OP_HASH160\r\n            && (txBytes[pos + 1] == 0x14)   // bytes to push\r\n            && (txBytes[pos + 22] == 0x87); // OP_EQUAL\r\n    }\r\n    // Get the pubkeyhash / scripthash from an output script. Assumes\r\n    // pay-to-pubkey-hash (P2PKH) or pay-to-script-hash (P2SH) outputs.\r\n    // Returns the pubkeyhash/ scripthash, or zero if unknown output.\r\n    function parseOutputScript(bytes txBytes, uint pos, uint script_len)\r\n             returns (bytes20)\r\n    {\r\n        if (isP2PKH(txBytes, pos, script_len)) {\r\n            return sliceBytes20(txBytes, pos + 3);\r\n        } else if (isP2SH(txBytes, pos, script_len)) {\r\n            return sliceBytes20(txBytes, pos + 2);\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\ncontract PricingStrategy is Ownable{\r\n    uint public ETHUSD=580;\r\n    uint public BTCUSD=9000;\r\n    uint256 public exchangeRate;\r\n    bool public called;\r\n    \r\n    function getLatest(uint btcusd,uint ethusd) onlyOwner{\r\n        ETHUSD = ethusd;\r\n        BTCUSD = btcusd;\r\n    }\r\n\r\n\r\n    uint256 public bonuspercentageprivate = 50;\r\n    uint256 public bonuspercentagepresale = 25;\r\n    uint256 public bonuspercentagepublic  = 0;\r\n\r\n    function changeprivatebonus(uint256 _value) public onlyOwner{\r\n        bonuspercentageprivate = _value;\r\n    }\r\n\r\n    function changepublicbonus(uint256 _value) public onlyOwner{\r\n        bonuspercentagepresale = _value;\r\n    }\r\n\r\n    function changepresalebonus(uint256 _value) public onlyOwner{\r\n        bonuspercentagepublic = _value;\r\n    }\r\n\r\n    uint256 public mincontribprivatesale = 15000;\r\n    uint256 public mincontribpresale = 1000;\r\n    uint256 public mincontribpublicsale = 0;\r\n\r\n    function changeminprivatesale(uint256 _value) public onlyOwner{\r\n        mincontribprivatesale = _value;\r\n    }\r\n\r\n    function changeminpresale(uint256 _value) public onlyOwner{\r\n        mincontribpresale = _value;\r\n    }\r\n\r\n    function changeminpublicsale(uint256 _value) public onlyOwner{\r\n        mincontribpublicsale = _value;\r\n    }\r\n\r\n\r\n    ///log the value to get the value in usd\r\n    event logval(uint256 s);\r\n\r\n    function totalDiscount(Sales.ICOSaleState state,uint256 contribution,string types) returns (uint256,uint256){\r\n        uint256 valueInUSD;\r\n        if(keccak256(types)==keccak256(\"ethereum\")){\r\n            if(ETHUSD==0) throw;\r\n            valueInUSD = (ETHUSD*contribution)/1000000000000000000;\r\n            logval(valueInUSD);\r\n\r\n        }else if(keccak256(types)==keccak256(\"bitcoin\")){\r\n            if(BTCUSD==0) throw;\r\n            valueInUSD = (BTCUSD*contribution)/100000000;\r\n            logval(valueInUSD);\r\n\r\n        }\r\n        if(state==Sales.ICOSaleState.PrivateSale){\r\n            if(valueInUSD<mincontribprivatesale) throw;\r\n            return (bonuspercentageprivate,valueInUSD);\r\n        }else if(state==Sales.ICOSaleState.PreSale){\r\n            if(valueInUSD<mincontribpresale) throw;\r\n            return (bonuspercentagepresale,valueInUSD);\r\n        }else if(state==Sales.ICOSaleState.PublicSale){\r\n            if(valueInUSD>=mincontribpublicsale) throw;\r\n            return (bonuspercentagepublic,valueInUSD);\r\n        }\r\n        else{\r\n            return (0,0);\r\n        }\r\n    }\r\n    \r\n    function() payable{\r\n        \r\n    }\r\n}\r\n\r\n\r\n///////https://ethereum.stackexchange.com/questions/11383/oracle-oraclize-it-with-truffle-and-testrpc\r\n\r\n////https://ethereum.stackexchange.com/questions/17015/regarding-oraclize-call-in-smart-contract\r\n\r\n\r\n\r\ncontract NewTokenSale is Ownable,Pausable, Utils,Sales{\r\n\r\n    GACToken token;\r\n    bool fundssent;\r\n    uint256 public tokensPerUSD;\r\n    uint256 public currentSupply = 634585000000000000000000;\r\n    PricingStrategy pricingstrategy;\r\n    uint256 public tokenCreationMax = 275 * (10**6) * 10**18;\r\n\r\n    ///the address of owner to recieve the token\r\n    address public ownerAddr =0xB0583785f27B7f87535B4c574D3B30928aD3A7eb ; //to be filled\r\n\r\n    ///this is the address of the distributong account admin\r\n    address public distributorAddress = 0x5377209111cBe0cfeeaA54c4C28465cbf81D5601;\r\n\r\n    ////MAX Tokens for private sale\r\n    uint256 public maxPrivateSale = 150 * (10**6) * (10**18);\r\n    ///MAX tokens for presale \r\n    uint256 public maxPreSale = 100 * (10**6) * (10**18);\r\n\r\n    ///MAX tokens for the public sale\r\n    uint256 public maxPublicSale = 20* (10**6) * (10**18);\r\n\r\n    ///current sales\r\n    uint256 public endprivate = 1525219200; // 05/02/2018 @ 12:00am (UTC)\r\n    uint256 public endpresale = 1527724800;//05/31/2018 @ 12:00am (UTC)\r\n    // uint256 public endpublicsale;\r\n    uint256 public currentPrivateSale = 630585000000000000000000;\r\n    uint256 public currentPreSale = 4000000000000000000000;\r\n    uint256 public currentPublicSale ; \r\n\r\n\r\n    ///array of addresses for the ethereum relateed back funding  contract\r\n    uint256  public numberOfBackers;\r\n\r\n    mapping(uint256 => bool) transactionsClaimed;\r\n    uint256 public valueToBeSent;\r\n    uint public investorCount;\r\n\r\n    struct balanceStruct{\r\n        uint256 value;\r\n        bool tokenstransferred;\r\n    }\r\n\r\n    mapping(address => balanceStruct) public balances;\r\n    address[] public balancesArr;\r\n\r\n    ///the event log to log out the address of the multisig wallet\r\n    event logaddr(address addr);\r\n\r\n    ///the function to get the balance\r\n    function getBalance(address addr) public view returns(uint256) {\r\n        return balances[addr].value;\r\n    }\r\n\r\n    ///the function of adding to balances\r\n    function addToBalances(address addr, uint256 tokenValue) internal{\r\n        balances[addr].value = SafeMath.add(balances[addr].value,tokenValue);\r\n        bool found;\r\n        for(uint i=0;i<balancesArr.length;i++){\r\n            if(balancesArr[i]==addr){\r\n                found = true;\r\n            }\r\n        }\r\n        if(!found){\r\n            balancesArr.push(addr);\r\n        }\r\n    }\r\n\r\n    ///the function of adding to the balances\r\n    function alottMainSaleToken(address[] arr) public {\r\n        require(msg.sender == distributorAddress);\r\n        for(uint i=0;i<arr.length;i++){\r\n            if(checkExistsInArray(arr[i])){\r\n            if(!balances[arr[i]].tokenstransferred){\r\n                balances[arr[i]].tokenstransferred = true;\r\n                token.addToBalances(arr[i], balances[arr[i]].value);\r\n            }\r\n        }\r\n        }\r\n    }\r\n\r\n    function checkExistsInArray(address addr) internal returns (bool) {\r\n        for(uint i=0;i<balancesArr.length;i++){\r\n            if(balancesArr[i]==addr){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //the constructor function\r\n   function NewTokenSale(address tokenAddress,address strategy){\r\n        //require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input\r\n        token = GACToken(tokenAddress);\r\n        tokensPerUSD = 10 * 10 ** 18;\r\n        valueToBeSent = token.valueToBeSent();\r\n        pricingstrategy = PricingStrategy(strategy);\r\n    }\r\n\r\n    /**\r\n        Payable function to send the ether funds\r\n    **/\r\n    function() external payable stopInEmergency{\r\n        require(token.isValid());\r\n        require(msg.value>0);\r\n        ICOSaleState currentState = getStateFunding();\r\n        require(currentState!=ICOSaleState.Failed);\r\n        require(currentState!=ICOSaleState.Success);\r\n        var (discount,usd) = pricingstrategy.totalDiscount(currentState,msg.value,\"ethereum\");\r\n        uint256 tokens = usd*tokensPerUSD;\r\n        uint256 totalTokens = SafeMath.add(tokens,SafeMath.div(SafeMath.mul(tokens,discount),100));\r\n        if(currentState==ICOSaleState.PrivateSale){\r\n            require(SafeMath.add(currentPrivateSale,totalTokens)<=maxPrivateSale);\r\n            currentPrivateSale = SafeMath.add(currentPrivateSale,totalTokens);\r\n        }else if(currentState==ICOSaleState.PreSale){\r\n            require(SafeMath.add(currentPreSale,totalTokens)<=maxPreSale);\r\n            currentPreSale = SafeMath.add(currentPreSale,totalTokens);\r\n        }else if(currentState==ICOSaleState.PublicSale){\r\n            require(SafeMath.add(currentPublicSale,totalTokens)<=maxPublicSale);\r\n            currentPublicSale = SafeMath.add(currentPublicSale,totalTokens);\r\n        }\r\n        currentSupply = SafeMath.add(currentSupply,totalTokens);\r\n        require(currentSupply<=tokenCreationMax);\r\n        addToBalances(msg.sender,totalTokens);\r\n        token.increaseEthRaised(msg.value);\r\n        token.increaseUSDRaised(usd);\r\n        numberOfBackers++;\r\n        if(!ownerAddr.send(this.balance))throw;\r\n    }\r\n    \r\n    //Token distribution for the case of the ICO\r\n    ///function to run when the transaction has been veified\r\n    function processTransaction(bytes txn, uint256 txHash,address addr,bytes20 btcaddr)  onlyOwner returns (uint)\r\n    {   \r\n        bool  valueSent;\r\n        require(token.isValid());\r\n     ICOSaleState currentState = getStateFunding();\r\n\r\n        if(!transactionsClaimed[txHash]){\r\n            var (a,b) = BTC.checkValueSent(txn,btcaddr,valueToBeSent);\r\n            if(a){\r\n                valueSent = true;\r\n                transactionsClaimed[txHash] = true;\r\n                 ///since we are creating tokens we need to increase the total supply\r\n               allottTokensBTC(addr,b,currentState);\r\n                return 1;\r\n               }\r\n        }\r\n    }\r\n    \r\n    ///function to allot tokens to address\r\n    function allottTokensBTC(address addr,uint256 value,ICOSaleState state) internal{\r\n        ICOSaleState currentState = getStateFunding();\r\n        require(currentState!=ICOSaleState.Failed);\r\n        require(currentState!=ICOSaleState.Success);\r\n        var (discount,usd) = pricingstrategy.totalDiscount(state,value,\"bitcoin\");\r\n        uint256 tokens = usd*tokensPerUSD;\r\n        uint256 totalTokens = SafeMath.add(tokens,SafeMath.div(SafeMath.mul(tokens,discount),100));\r\n        if(currentState==ICOSaleState.PrivateSale){\r\n            require(SafeMath.add(currentPrivateSale,totalTokens)<=maxPrivateSale);\r\n            currentPrivateSale = SafeMath.add(currentPrivateSale,totalTokens);\r\n        }else if(currentState==ICOSaleState.PreSale){\r\n            require(SafeMath.add(currentPreSale,totalTokens)<=maxPreSale);\r\n            currentPreSale = SafeMath.add(currentPreSale,totalTokens);\r\n        }else if(currentState==ICOSaleState.PublicSale){\r\n            require(SafeMath.add(currentPublicSale,totalTokens)<=maxPublicSale);\r\n            currentPublicSale = SafeMath.add(currentPublicSale,totalTokens);\r\n        }\r\n       currentSupply = SafeMath.add(currentSupply,totalTokens);\r\n       require(currentSupply<=tokenCreationMax);\r\n       addToBalances(addr,totalTokens);\r\n       token.increaseBTCRaised(value);\r\n       token.increaseUSDRaised(usd);\r\n       numberOfBackers++;\r\n    }\r\n\r\n\r\n    ///function to alott tokens by the owner\r\n\r\n    function alottTokensExchange(address contributor,uint256 value) public onlyOwner{\r\n        token.addToBalances(contributor,value);\r\n        currentSupply = SafeMath.add(currentSupply,value);\r\n    }\r\n\r\n    function finalizeTokenSale() public onlyOwner{\r\n        ICOSaleState currentState = getStateFunding();\r\n        if(currentState!=ICOSaleState.Success) throw;\r\n        token.finalizeICO();\r\n    }\r\n\r\n    ////kill the contract\r\n    function killContract() public onlyOwner{\r\n        selfdestruct(ownerAddr);\r\n    }\r\n\r\n\r\n    ///change the end private sale\r\n    function changeEndPrivateSale(uint256 _newend) public onlyOwner{\r\n        endprivate = _newend;\r\n    }\r\n\r\n    function changeEndPreSale(uint256 _newend) public onlyOwner{\r\n        endpresale  = _newend;\r\n    }\r\n\r\n\r\n    function changeTokensPerUSD(uint256 _val) public onlyOwner{\r\n        tokensPerUSD = _val;\r\n    }\r\n\r\n    function getStateFunding() returns (ICOSaleState){\r\n       if(now>token.fundingStartBlock() && now<=endprivate) return ICOSaleState.PrivateSale;\r\n       if(now>endprivate && now<=endpresale) return ICOSaleState.PreSale;\r\n       if(now>endpresale && now<=token.fundingEndBlock()) return ICOSaleState.PublicSale;\r\n       if(now>token.fundingEndBlock() && token.usdraised()<token.minCapUSD()) return ICOSaleState.Failed;\r\n       if(now>token.fundingEndBlock() && token.usdraised()>=token.minCapUSD()) return ICOSaleState.Success;\r\n    }\r\n\r\n    \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"arr\",\"type\":\"address[]\"}],\"name\":\"alottMainSaleToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endprivate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"valueToBeSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endpresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"tokenstransferred\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"alottTokensExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPrivateSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeTokenSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"changeTokensPerUSD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newend\",\"type\":\"uint256\"}],\"name\":\"changeEndPreSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPublicSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPrivateSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getStateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balancesArr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newend\",\"type\":\"uint256\"}],\"name\":\"changeEndPrivateSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txn\",\"type\":\"bytes\"},{\"name\":\"txHash\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"btcaddr\",\"type\":\"bytes20\"}],\"name\":\"processTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPublicSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPreSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPreSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"strategy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"logaddr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NewTokenSale","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c4f1c3aa85b3267f23689c19b8470b5a81babb2d00000000000000000000000011caeea41e501d58e6ea7bc554b3014b3039fa44","Library":"BTC:3ae586ea11f3ff0b0118294cba8fd0fabb611dd3","SwarmSource":"bzzr://5fa8283ec3c9d9ab9d94fdef641bed4788aa8df2b13e34c3b3fcb65cdde59f94"}]}