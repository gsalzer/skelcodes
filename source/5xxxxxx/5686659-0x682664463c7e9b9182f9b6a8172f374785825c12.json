{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Copyright(C) 2018 by @phalexo (gitter) and Big Deeper Advisors, Inc. a Wyoming corporation.\r\n * All rights reserved.\r\n *\r\n * A non-exclusive, non-transferable, perpetual license to use is hereby granted to Expercoin, Inc.\r\n * For questions about the license contact: bigdeeperadvisors@gmail.com\r\n *\r\n * Expercoin, Inc. can be reached via support@expercoin.com and expercoin.com website.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract References {\r\n\r\n  mapping (bytes32 => address) internal references;\r\n\r\n}\r\n\r\ncontract AuthorizedList {\r\n\r\n    bytes32 constant PRESIDENT = keccak256(\"Republics President!\");\r\n    bytes32 constant STAFF_MEMBER = keccak256(\"Staff Member.\");\r\n    bytes32 constant AIR_DROP = keccak256(\"Airdrop Permission.\");\r\n    bytes32 constant INTERNAL = keccak256(\"Internal Authorization.\");\r\n    mapping (address => mapping(bytes32 => bool)) authorized;\r\n\r\n}\r\n\r\ncontract Authorized is AuthorizedList {\r\n\r\n    /// @dev Set the initial permission for the contract creator\r\n    /// The contract creator can then add permissions for others\r\n    function Authorized() public {\r\n\r\n       authorized[msg.sender][PRESIDENT] = true;\r\n\r\n    }\r\n\r\n\r\n    /// @dev Ensure that _address is authorized, modifier\r\n    /// @param _address Address to be checked, usually msg.sender\r\n    /// @param _authorization key for specific authorization\r\n    modifier ifAuthorized(address _address, bytes32 _authorization) {\r\n\r\n       require(authorized[_address][_authorization] || authorized[_address][PRESIDENT], \"Not authorized to access!\");\r\n       _;\r\n\r\n    }\r\n\r\n    /// @dev Check _address' authorization, boolean function\r\n    /// @param _address Boolean value, true if authorized, false otherwise\r\n    /// @param _authorization key for specific authorization\r\n    function isAuthorized(address _address, bytes32 _authorization) public view returns (bool) {\r\n\r\n       return authorized[_address][_authorization];\r\n\r\n    }\r\n\r\n    /// @dev Toggle boolean flag to allow or prevent access\r\n    /// @param _address Boolean value, true if authorized, false otherwise\r\n    /// @param _authorization key for specific authorization\r\n    function toggleAuthorization(address _address, bytes32 _authorization) public ifAuthorized(msg.sender, PRESIDENT) {\r\n\r\n       /// Prevent inadvertent self locking out, cannot change own authority\r\n       require(_address != msg.sender, \"Cannot change own permissions.\");\r\n\r\n       /// No need for lower level authorization to linger\r\n       if (_authorization == PRESIDENT && !authorized[_address][PRESIDENT])\r\n           authorized[_address][STAFF_MEMBER] = false;\r\n\r\n       authorized[_address][_authorization] = !authorized[_address][_authorization];\r\n\r\n    }\r\n\r\n}\r\n\r\ncontract main is References, AuthorizedList, Authorized {\r\n\r\n  event LogicUpgrade(address indexed _oldbiz, address indexed _newbiz);\r\n  event StorageUpgrade(address indexed _oldvars, address indexed _newvars);\r\n\r\n  function main(address _logic, address _storage) public Authorized() {\r\n\r\n     require(_logic != address(0), \"main: Unexpectedly logic address is 0x0.\");\r\n     require(_storage != address(0), \"main: Unexpectedly storage address is 0x0.\");\r\n     references[bytes32(0)] = _logic;\r\n     references[bytes32(1)] = _storage;\r\n\r\n  }\r\n\r\n  /// @dev Set an address at _key location\r\n  /// @param _address Address to set\r\n  /// @param _key bytes32 key location\r\n  function setReference(address _address, bytes32 _key) external ifAuthorized(msg.sender, PRESIDENT) {\r\n\r\n     require(_address != address(0), \"setReference: Unexpectedly _address is 0x0\");\r\n\r\n     if (_key == bytes32(0)) emit LogicUpgrade(references[bytes32(0)], _address);\r\n     else emit StorageUpgrade(references[_key], _address);\r\n\r\n     if (references[_key] != address(0))\r\n          delete references[_key];\r\n\r\n     references[_key] = _address;\r\n\r\n  }\r\n\r\n  /// @dev Retrieve contract address at _key location, mostly for convenience\r\n  /// @return Contract address or 0x0 if it does not exist\r\n  function getReference(bytes32 _key) external view ifAuthorized(msg.sender, PRESIDENT) returns(address) {\r\n\r\n      return references[_key];\r\n\r\n  }\r\n\r\n  function() external payable {\r\n\r\n      address _target = references[bytes32(0)];\r\n      assembly {\r\n          let _calldata := mload(0x40)\r\n          mstore(0x40, add(_calldata, calldatasize))\r\n          calldatacopy(_calldata, 0x0, calldatasize)\r\n          switch delegatecall(gas, _target, _calldata, calldatasize, 0, 0)\r\n            case 0 { revert(0, 0) }\r\n            default {\r\n              let _returndata := mload(0x40)\r\n              returndatacopy(_returndata, 0, returndatasize)\r\n              mstore(0x40, add(_returndata, returndatasize))\r\n              return(_returndata, returndatasize)\r\n            }\r\n       }\r\n   }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_authorization\",\"type\":\"bytes32\"}],\"name\":\"toggleAuthorization\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"setReference\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getReference\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_authorization\",\"type\":\"bytes32\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_logic\",\"type\":\"address\"},{\"name\":\"_storage\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldbiz\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newbiz\",\"type\":\"address\"}],\"name\":\"LogicUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldvars\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newvars\",\"type\":\"address\"}],\"name\":\"StorageUpgrade\",\"type\":\"event\"}]","ContractName":"main","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002","Library":"","SwarmSource":"bzzr://c94ce33f14b5a63f64820ca68e42c040d4a5f67459a6bc361370a5acf2d229f5"}]}