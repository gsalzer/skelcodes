{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\nlibrary BWUtility {\r\n    \r\n    // -------- UTILITY FUNCTIONS ----------\r\n\r\n\r\n    // Return next higher even _multiple for _amount parameter (e.g used to round up to even finneys).\r\n    function ceil(uint _amount, uint _multiple) pure public returns (uint) {\r\n        return ((_amount + _multiple - 1) / _multiple) * _multiple;\r\n    }\r\n\r\n    // Checks if two coordinates are adjacent:\r\n    // xxx\r\n    // xox\r\n    // xxx\r\n    // All x (_x2, _xy2) are adjacent to o (_x1, _y1) in this ascii image. \r\n    // Adjacency does not wrapp around map edges so if y2 = 255 and y1 = 0 then they are not ajacent\r\n    function isAdjacent(uint8 _x1, uint8 _y1, uint8 _x2, uint8 _y2) pure public returns (bool) {\r\n        return ((_x1 == _x2 &&      (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Same column\r\n               ((_y1 == _y2 &&      (_x2 - _x1 == 1 || _x1 - _x2 == 1))) ||      // Same row\r\n               ((_x2 - _x1 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Right upper or lower diagonal\r\n               ((_x1 - _x2 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1)));        // Left upper or lower diagonal\r\n    }\r\n\r\n    // Converts (x, y) to tileId xy\r\n    function toTileId(uint8 _x, uint8 _y) pure public returns (uint16) {\r\n        return uint16(_x) << 8 | uint16(_y);\r\n    }\r\n\r\n    // Converts _tileId to (x, y)\r\n    function fromTileId(uint16 _tileId) pure public returns (uint8, uint8) {\r\n        uint8 y = uint8(_tileId);\r\n        uint8 x = uint8(_tileId >> 8);\r\n        return (x, y);\r\n    }\r\n    \r\n    function getBoostFromTile(address _claimer, address _attacker, address _defender, uint _blockValue) pure public returns (uint, uint) {\r\n        if (_claimer == _attacker) {\r\n            return (_blockValue, 0);\r\n        } else if (_claimer == _defender) {\r\n            return (0, _blockValue);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BWData {\r\n    address public owner;\r\n    address private bwService;\r\n    address private bw;\r\n    address private bwMarket;\r\n\r\n    uint private blockValueBalance = 0;\r\n    uint private feeBalance = 0;\r\n    uint private BASE_TILE_PRICE_WEI = 1 finney; // 1 milli-ETH.\r\n    \r\n    mapping (address => User) private users; // user address -> user information\r\n    mapping (uint16 => Tile) private tiles; // tileId -> list of TileClaims for that particular tile\r\n    \r\n    // Info about the users = those who have purchased tiles.\r\n    struct User {\r\n        uint creationTime;\r\n        bool censored;\r\n        uint battleValue;\r\n    }\r\n\r\n    // Info about a tile ownership\r\n    struct Tile {\r\n        address claimer;\r\n        uint blockValue;\r\n        uint creationTime;\r\n        uint sellPrice;    // If 0 -> not on marketplace. If > 0 -> on marketplace.\r\n    }\r\n\r\n    struct Boost {\r\n        uint8 numAttackBoosts;\r\n        uint8 numDefendBoosts;\r\n        uint attackBoost;\r\n        uint defendBoost;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Can't send funds straight to this contract. Avoid people sending by mistake.\r\n    function () payable public {\r\n        revert();\r\n    }\r\n\r\n    function kill() public isOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    modifier isValidCaller {\r\n        if (msg.sender != bwService && msg.sender != bw && msg.sender != bwMarket) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n    \r\n    modifier isOwner {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n    \r\n    function setBwServiceValidCaller(address _bwService) public isOwner {\r\n        bwService = _bwService;\r\n    }\r\n\r\n    function setBwValidCaller(address _bw) public isOwner {\r\n        bw = _bw;\r\n    }\r\n\r\n    function setBwMarketValidCaller(address _bwMarket) public isOwner {\r\n        bwMarket = _bwMarket;\r\n    }    \r\n    \r\n    // ----------USER-RELATED GETTER FUNCTIONS------------\r\n    \r\n    //function getUser(address _user) view public returns (bytes32) {\r\n        //BWUtility.User memory user = users[_user];\r\n        //require(user.creationTime != 0);\r\n        //return (user.creationTime, user.imageUrl, user.tag, user.email, user.homeUrl, user.creationTime, user.censored, user.battleValue);\r\n    //}\r\n    \r\n    function addUser(address _msgSender) public isValidCaller {\r\n        User storage user = users[_msgSender];\r\n        require(user.creationTime == 0);\r\n        user.creationTime = block.timestamp;\r\n    }\r\n\r\n    function hasUser(address _user) view public isValidCaller returns (bool) {\r\n        return users[_user].creationTime != 0;\r\n    }\r\n    \r\n\r\n    // ----------TILE-RELATED GETTER FUNCTIONS------------\r\n\r\n    function getTile(uint16 _tileId) view public isValidCaller returns (address, uint, uint, uint) {\r\n        Tile storage currentTile = tiles[_tileId];\r\n        return (currentTile.claimer, currentTile.blockValue, currentTile.creationTime, currentTile.sellPrice);\r\n    }\r\n    \r\n    function getTileClaimerAndBlockValue(uint16 _tileId) view public isValidCaller returns (address, uint) {\r\n        Tile storage currentTile = tiles[_tileId];\r\n        return (currentTile.claimer, currentTile.blockValue);\r\n    }\r\n    \r\n    function isNewTile(uint16 _tileId) view public isValidCaller returns (bool) {\r\n        Tile storage currentTile = tiles[_tileId];\r\n        return currentTile.creationTime == 0;\r\n    }\r\n    \r\n    function storeClaim(uint16 _tileId, address _claimer, uint _blockValue) public isValidCaller {\r\n        tiles[_tileId] = Tile(_claimer, _blockValue, block.timestamp, 0);\r\n    }\r\n\r\n    function updateTileBlockValue(uint16 _tileId, uint _blockValue) public isValidCaller {\r\n        tiles[_tileId].blockValue = _blockValue;\r\n    }\r\n\r\n    function setClaimerForTile(uint16 _tileId, address _claimer) public isValidCaller {\r\n        tiles[_tileId].claimer = _claimer;\r\n    }\r\n\r\n    function updateTileTimeStamp(uint16 _tileId) public isValidCaller {\r\n        tiles[_tileId].creationTime = block.timestamp;\r\n    }\r\n    \r\n    function getCurrentClaimerForTile(uint16 _tileId) view public isValidCaller returns (address) {\r\n        Tile storage currentTile = tiles[_tileId];\r\n        if (currentTile.creationTime == 0) {\r\n            return 0;\r\n        }\r\n        return currentTile.claimer;\r\n    }\r\n\r\n    function getCurrentBlockValueAndSellPriceForTile(uint16 _tileId) view public isValidCaller returns (uint, uint) {\r\n        Tile storage currentTile = tiles[_tileId];\r\n        if (currentTile.creationTime == 0) {\r\n            return (0, 0);\r\n        }\r\n        return (currentTile.blockValue, currentTile.sellPrice);\r\n    }\r\n    \r\n    function getBlockValueBalance() view public isValidCaller returns (uint){\r\n        return blockValueBalance;\r\n    }\r\n\r\n    function setBlockValueBalance(uint _blockValueBalance) public isValidCaller {\r\n        blockValueBalance = _blockValueBalance;\r\n    }\r\n\r\n    function getFeeBalance() view public isValidCaller returns (uint) {\r\n        return feeBalance;\r\n    }\r\n\r\n    function setFeeBalance(uint _feeBalance) public isValidCaller {\r\n        feeBalance = _feeBalance;\r\n    }\r\n    \r\n    function getUserBattleValue(address _userId) view public isValidCaller returns (uint) {\r\n        return users[_userId].battleValue;\r\n    }\r\n    \r\n    function setUserBattleValue(address _userId, uint _battleValue) public  isValidCaller {\r\n        users[_userId].battleValue = _battleValue;\r\n    }\r\n    \r\n    function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {\r\n        User storage user = users[_msgSender];\r\n        require(user.creationTime != 0);\r\n\r\n        if (_useBattleValue) {\r\n            require(_msgValue == 0);\r\n            require(user.battleValue >= _amount);\r\n        } else {\r\n            require(_amount == _msgValue);\r\n        }\r\n    }\r\n    \r\n    function addBoostFromTile(Tile _tile, address _attacker, address _defender, Boost memory _boost) pure private {\r\n        if (_tile.claimer == _attacker) {\r\n            require(_boost.attackBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow\r\n            _boost.attackBoost += _tile.blockValue;\r\n            _boost.numAttackBoosts += 1;\r\n        } else if (_tile.claimer == _defender) {\r\n            require(_boost.defendBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow\r\n            _boost.defendBoost += _tile.blockValue;\r\n            _boost.numDefendBoosts += 1;\r\n        }\r\n    }\r\n\r\n    function calculateBattleBoost(uint16 _tileId, address _attacker, address _defender) view public isValidCaller returns (uint, uint) {\r\n        uint8 x;\r\n        uint8 y;\r\n\r\n        (x, y) = BWUtility.fromTileId(_tileId);\r\n\r\n        Boost memory boost = Boost(0, 0, 0, 0);\r\n        // We overflow x, y on purpose here if x or y is 0 or 255 - the map overflows and so should adjacency.\r\n        // Go through all adjacent tiles to (x, y).\r\n        if (y != 255) {\r\n            if (x != 255) {\r\n                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y+1)], _attacker, _defender, boost);\r\n            }\r\n            \r\n            addBoostFromTile(tiles[BWUtility.toTileId(x, y+1)], _attacker, _defender, boost);\r\n\r\n            if (x != 0) {\r\n                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y+1)], _attacker, _defender, boost);\r\n            }\r\n        }\r\n\r\n        if (x != 255) {\r\n            addBoostFromTile(tiles[BWUtility.toTileId(x+1, y)], _attacker, _defender, boost);\r\n        }\r\n\r\n        if (x != 0) {\r\n            addBoostFromTile(tiles[BWUtility.toTileId(x-1, y)], _attacker, _defender, boost);\r\n        }\r\n\r\n        if (y != 0) {\r\n            if(x != 255) {\r\n                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y-1)], _attacker, _defender, boost);\r\n            }\r\n\r\n            addBoostFromTile(tiles[BWUtility.toTileId(x, y-1)], _attacker, _defender, boost);\r\n\r\n            if(x != 0) {\r\n                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y-1)], _attacker, _defender, boost);\r\n            }\r\n        }\r\n        // The benefit of boosts is multiplicative (quadratic):\r\n        // - More boost tiles gives a higher total blockValue (the sum of the adjacent tiles)\r\n        // - More boost tiles give a higher multiple of that total blockValue that can be used (10% per adjacent tie)\r\n        // Example:\r\n        //   A) I boost attack with 1 single tile worth 10 finney\r\n        //      -> Total boost is 10 * 1 / 10 = 1 finney\r\n        //   B) I boost attack with 3 tiles worth 1 finney each\r\n        //      -> Total boost is (1+1+1) * 3 / 10 = 0.9 finney\r\n        //   C) I boost attack with 8 tiles worth 2 finney each\r\n        //      -> Total boost is (2+2+2+2+2+2+2+2) * 8 / 10 = 14.4 finney\r\n        //   D) I boost attack with 3 tiles of 1, 5 and 10 finney respectively\r\n        //      -> Total boost is (ss1+5+10) * 3 / 10 = 4.8 finney\r\n        // This division by 10 can't create fractions since our uint is wei, and we can't have overflow from the multiplication\r\n        // We do allow fractions of finney here since the boosted values aren't stored anywhere, only used for attack rolls and sent in events\r\n        boost.attackBoost = (boost.attackBoost / 10 * boost.numAttackBoosts);\r\n        boost.defendBoost = (boost.defendBoost / 10 * boost.numDefendBoosts);\r\n\r\n        return (boost.attackBoost, boost.defendBoost);\r\n    }\r\n    \r\n    function censorUser(address _userAddress, bool _censored) public isValidCaller {\r\n        User storage user = users[_userAddress];\r\n        require(user.creationTime != 0);\r\n        user.censored = _censored;\r\n    }\r\n    \r\n    function deleteTile(uint16 _tileId) public isValidCaller {\r\n        delete tiles[_tileId];\r\n    }\r\n    \r\n    function setSellPrice(uint16 _tileId, uint _sellPrice) public isValidCaller {\r\n        tiles[_tileId].sellPrice = _sellPrice;  //testrpc cannot estimate gas when delete is used.\r\n    }\r\n\r\n    function deleteOffer(uint16 _tileId) public isValidCaller {\r\n        tiles[_tileId].sellPrice = 0;  //testrpc cannot estimate gas when delete is used.\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ninterface ERC20I {\r\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n    function balanceOf(address _holder) external view returns (uint256);\r\n}\r\n\r\n\r\ncontract BWService {\r\n    using SafeMath for uint256;\r\n    address private owner;\r\n    address private bw;\r\n    address private bwMarket;\r\n    BWData private bwData;\r\n    uint private seed = 42;\r\n    uint private WITHDRAW_FEE = 5; // 5%\r\n    uint private ATTACK_FEE = 5; // 5%\r\n    uint private ATTACK_BOOST_CAP = 300; // 300%\r\n    uint private DEFEND_BOOST_CAP = 300; // 300%\r\n    uint private ATTACK_BOOST_MULTIPLIER = 100; // 100%\r\n    uint private DEFEND_BOOST_MULTIPLIER = 100; // 100%\r\n    mapping (uint16 => address) private localGames;\r\n    \r\n    modifier isOwner {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n        _;\r\n    }  \r\n\r\n    modifier isValidCaller {\r\n        if (msg.sender != bw && msg.sender != bwMarket) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    event TileClaimed(uint16 tileId, address newClaimer, uint priceInWei, uint creationTime);\r\n    event TileFortified(uint16 tileId, address claimer, uint addedValueInWei, uint priceInWei, uint fortifyTime); // Sent when a user fortifies an existing claim by bumping its value.\r\n    event TileAttackedSuccessfully(uint16 tileId, address attacker, uint attackAmount, uint totalAttackAmount, address defender, uint defendAmount, uint totalDefendAmount, uint attackRoll, uint attackTime); // Sent when a user successfully attacks a tile.    \r\n    event TileDefendedSuccessfully(uint16 tileId, address attacker, uint attackAmount, uint totalAttackAmount, address defender, uint defendAmount, uint totalDefendAmount, uint attackRoll, uint defendTime); // Sent when a user successfully defends a tile when attacked.    \r\n    event BlockValueMoved(uint16 sourceTileId, uint16 destTileId, address owner, uint movedBlockValue, uint postSourceValue, uint postDestValue, uint moveTime); // Sent when a user buys a tile from another user, by accepting a tile offer\r\n    event UserBattleValueUpdated(address userAddress, uint battleValue, bool isWithdraw);\r\n\r\n    // Constructor.\r\n    constructor(address _bwData) public {\r\n        bwData = BWData(_bwData);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Can't send funds straight to this contract. Avoid people sending by mistake.\r\n    function () payable public {\r\n        revert();\r\n    }\r\n\r\n    // OWNER-ONLY FUNCTIONS\r\n    function kill() public isOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function setValidBwCaller(address _bw) public isOwner {\r\n        bw = _bw;\r\n    }\r\n    \r\n    function setValidBwMarketCaller(address _bwMarket) public isOwner {\r\n        bwMarket = _bwMarket;\r\n    }\r\n\r\n    function setWithdrawFee(uint _feePercentage) public isOwner {\r\n        WITHDRAW_FEE = _feePercentage;\r\n    }\r\n\r\n    function setAttackFee(uint _feePercentage) public isOwner {\r\n        ATTACK_FEE = _feePercentage;\r\n    }\r\n\r\n    function setAttackBoostMultipler(uint _multiplierPercentage) public isOwner {\r\n        ATTACK_BOOST_MULTIPLIER = _multiplierPercentage;\r\n    }\r\n\r\n    function setDefendBoostMultiplier(uint _multiplierPercentage) public isOwner {\r\n        DEFEND_BOOST_MULTIPLIER = _multiplierPercentage;\r\n    }\r\n\r\n    function setAttackBoostCap(uint _capPercentage) public isOwner {\r\n        ATTACK_BOOST_CAP = _capPercentage;\r\n    }\r\n\r\n    function setDefendBoostCap(uint _capPercentage) public isOwner {\r\n        DEFEND_BOOST_CAP = _capPercentage;\r\n    }\r\n\r\n    // TILE-RELATED FUNCTIONS\r\n    // This function claims multiple previously unclaimed tiles in a single transaction.\r\n    // The value assigned to each tile is the msg.value divided by the number of tiles claimed.\r\n    // The msg.value is required to be an even multiple of the number of tiles claimed.\r\n    function storeInitialClaim(address _msgSender, uint16[] _claimedTileIds, uint _claimAmount, bool _useBattleValue) public isValidCaller {\r\n        uint tileCount = _claimedTileIds.length;\r\n        require(tileCount > 0);\r\n        require(_claimAmount >= 1 finney * tileCount); // ensure enough funds paid for all tiles\r\n        require(_claimAmount % tileCount == 0); // ensure payment is an even multiple of number of tiles claimed\r\n\r\n        uint valuePerBlockInWei = _claimAmount.div(tileCount); // Due to requires above this is guaranteed to be an even number\r\n        require(valuePerBlockInWei >= 5 finney);\r\n\r\n        if (_useBattleValue) {\r\n            subUserBattleValue(_msgSender, _claimAmount, false);  \r\n        }\r\n\r\n        addGlobalBlockValueBalance(_claimAmount);\r\n\r\n        uint16 tileId;\r\n        bool isNewTile;\r\n        for (uint16 i = 0; i < tileCount; i++) {\r\n            tileId = _claimedTileIds[i];\r\n            isNewTile = bwData.isNewTile(tileId); // Is length 0 if first time purchased\r\n            require(isNewTile); // Can only claim previously unclaimed tiles.\r\n\r\n            // Send claim event\r\n            emit TileClaimed(tileId, _msgSender, valuePerBlockInWei, block.timestamp);\r\n\r\n            // Update contract state with new tile ownership.\r\n            bwData.storeClaim(tileId, _msgSender, valuePerBlockInWei);\r\n        }\r\n    }\r\n\r\n    function fortifyClaims(address _msgSender, uint16[] _claimedTileIds, uint _fortifyAmount, bool _useBattleValue) public isValidCaller {\r\n        uint tileCount = _claimedTileIds.length;\r\n        require(tileCount > 0);\r\n\r\n        address(this).balance.add(_fortifyAmount); // prevent overflow with SafeMath\r\n        require(_fortifyAmount % tileCount == 0); // ensure payment is an even multiple of number of tiles fortified\r\n        uint addedValuePerTileInWei = _fortifyAmount.div(tileCount); // Due to requires above this is guaranteed to be an even number\r\n        require(_fortifyAmount >= 1 finney * tileCount); // ensure enough funds paid for all tiles\r\n\r\n        address claimer;\r\n        uint blockValue;\r\n        for (uint16 i = 0; i < tileCount; i++) {\r\n            (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_claimedTileIds[i]);\r\n            require(claimer != 0); // Can't do this on never-owned tiles\r\n            require(claimer == _msgSender); // Only current claimer can fortify claim\r\n\r\n            if (_useBattleValue) {\r\n                subUserBattleValue(_msgSender, addedValuePerTileInWei, false);\r\n            }\r\n            \r\n            fortifyClaim(_msgSender, _claimedTileIds[i], addedValuePerTileInWei);\r\n        }\r\n    }\r\n\r\n    function fortifyClaim(address _msgSender, uint16 _claimedTileId, uint _fortifyAmount) private {\r\n        uint blockValue;\r\n        uint sellPrice;\r\n        (blockValue, sellPrice) = bwData.getCurrentBlockValueAndSellPriceForTile(_claimedTileId);\r\n        uint updatedBlockValue = blockValue.add(_fortifyAmount);\r\n        // Send fortify event\r\n        emit TileFortified(_claimedTileId, _msgSender, _fortifyAmount, updatedBlockValue, block.timestamp);\r\n        \r\n        // Update tile value. The tile has been fortified by bumping up its value.\r\n        bwData.updateTileBlockValue(_claimedTileId, updatedBlockValue);\r\n\r\n        // Track addition to global block value\r\n        addGlobalBlockValueBalance(_fortifyAmount);\r\n    }\r\n\r\n    // Return a pseudo random number between lower and upper bounds\r\n    // given the number of previous blocks it should hash.\r\n    // Random function copied from https://github.com/axiomzen/eth-random/blob/master/contracts/Random.sol.\r\n    // Changed sha3 to keccak256, then modified.\r\n    // Changed random range from uint64 to uint (=uint256).\r\n    function random(uint _upper) private returns (uint)  {\r\n        seed = uint(keccak256(blockhash(block.number - 1), block.coinbase, block.timestamp, seed, address(0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE).balance));\r\n        return seed % _upper;\r\n    }\r\n\r\n    // A user tries to claim a tile that's already owned by another user. A battle ensues.\r\n    // A random roll is done with % based on attacking vs defending amounts.\r\n    function attackTile(address _msgSender, uint16 _tileId, uint _attackAmount, bool _useBattleValue) public isValidCaller {\r\n        require(_attackAmount >= 1 finney);         // Don't allow attacking with less than one base tile price.\r\n        require(_attackAmount % 1 finney == 0);\r\n\r\n        address claimer;\r\n        uint blockValue;\r\n        (claimer, blockValue) = bwData.getTileClaimerAndBlockValue(_tileId);\r\n        \r\n        require(claimer != 0); // Can't do this on never-owned tiles\r\n        require(claimer != _msgSender); // Can't attack one's own tiles\r\n        require(claimer != owner); // Can't attack owner's tiles because it is used for raffle.\r\n\r\n        // Calculate boosted amounts for attacker and defender\r\n        // The base attack amount is sent in the by the user.\r\n        // The base defend amount is the attacked tile's current blockValue.\r\n        uint attackBoost;\r\n        uint defendBoost;\r\n        (attackBoost, defendBoost) = bwData.calculateBattleBoost(_tileId, _msgSender, claimer);\r\n\r\n        // Adjust boost to optimize game strategy\r\n        attackBoost = attackBoost.mul(ATTACK_BOOST_MULTIPLIER).div(100);\r\n        defendBoost = defendBoost.mul(DEFEND_BOOST_MULTIPLIER).div(100);\r\n        \r\n        // Cap the boost to minimize its impact (prevents whales somehow)\r\n        if (attackBoost > _attackAmount.mul(ATTACK_BOOST_CAP).div(100)) {\r\n            attackBoost = _attackAmount.mul(ATTACK_BOOST_CAP).div(100);\r\n        }\r\n        if (defendBoost > blockValue.mul(DEFEND_BOOST_CAP).div(100)) {\r\n            defendBoost = blockValue.mul(DEFEND_BOOST_CAP).div(100);\r\n        }\r\n\r\n        uint totalAttackAmount = _attackAmount.add(attackBoost);\r\n        uint totalDefendAmount = blockValue.add(defendBoost);\r\n\r\n        // Verify that attack odds are within allowed range.\r\n        require(totalAttackAmount.div(10) <= totalDefendAmount); // Disallow attacks with more than 1000% of defendAmount\r\n        require(totalAttackAmount >= totalDefendAmount.div(10)); // Disallow attacks with less than 10% of defendAmount\r\n\r\n        uint attackFeeAmount = _attackAmount.mul(ATTACK_FEE).div(100);\r\n        uint attackAmountAfterFee = _attackAmount.sub(attackFeeAmount);\r\n        \r\n        updateFeeBalance(attackFeeAmount);\r\n\r\n        // The battle considers boosts.\r\n        uint attackRoll = random(totalAttackAmount.add(totalDefendAmount)); // This is where the excitement happens!\r\n\r\n        //gas cost of attack branch is higher than denfense branch solving MSB1\r\n        if (attackRoll > totalDefendAmount) {\r\n            // Change block owner but keep same block value (attacker got battlevalue instead)\r\n            bwData.setClaimerForTile(_tileId, _msgSender);\r\n\r\n            // Tile successfully attacked!\r\n            if (_useBattleValue) {\r\n                // Withdraw followed by deposit of same amount to prevent MSB1\r\n                addUserBattleValue(_msgSender, attackAmountAfterFee); // Don't include boost here!\r\n                subUserBattleValue(_msgSender, attackAmountAfterFee, false);\r\n            } else {\r\n                addUserBattleValue(_msgSender, attackAmountAfterFee); // Don't include boost here!\r\n            }\r\n            addUserBattleValue(claimer, 0);\r\n\r\n            bwData.updateTileTimeStamp(_tileId);\r\n            // Send update event\r\n            emit TileAttackedSuccessfully(_tileId, _msgSender, attackAmountAfterFee, totalAttackAmount, claimer, blockValue, totalDefendAmount, attackRoll, block.timestamp);\r\n        } else {\r\n            bwData.setClaimerForTile(_tileId, claimer); //should be old owner\r\n            // Tile successfully defended!\r\n            if (_useBattleValue) {\r\n                subUserBattleValue(_msgSender, attackAmountAfterFee, false); // Don't include boost here!\r\n            }\r\n            addUserBattleValue(claimer, attackAmountAfterFee); // Don't include boost here!\r\n            \r\n            // Send update event\r\n            emit TileDefendedSuccessfully(_tileId, _msgSender, attackAmountAfterFee, totalAttackAmount, claimer, blockValue, totalDefendAmount, attackRoll, block.timestamp);\r\n        }\r\n    }\r\n\r\n    function updateFeeBalance(uint attackFeeAmount) private {\r\n        uint feeBalance = bwData.getFeeBalance();\r\n        feeBalance = feeBalance.add(attackFeeAmount);\r\n        bwData.setFeeBalance(feeBalance);\r\n    }\r\n\r\n    function moveBlockValue(address _msgSender, uint8 _xSource, uint8 _ySource, uint8 _xDest, uint8 _yDest, uint _moveAmount) public isValidCaller {\r\n        uint16 sourceTileId = BWUtility.toTileId(_xSource, _ySource);\r\n        uint16 destTileId = BWUtility.toTileId(_xDest, _yDest);\r\n\r\n        address sourceTileClaimer;\r\n        address destTileClaimer;\r\n        uint sourceTileBlockValue;\r\n        uint destTileBlockValue;\r\n        (sourceTileClaimer, sourceTileBlockValue) = bwData.getTileClaimerAndBlockValue(sourceTileId);\r\n        (destTileClaimer, destTileBlockValue) = bwData.getTileClaimerAndBlockValue(destTileId);\r\n\r\n        uint newBlockValue = sourceTileBlockValue.sub(_moveAmount);\r\n        // Must transfer the entire block value or leave at least 5\r\n        require(newBlockValue == 0 || newBlockValue >= 5 finney);\r\n\r\n        require(sourceTileClaimer == _msgSender);\r\n        require(destTileClaimer == _msgSender);\r\n        require(_moveAmount >= 1 finney); // Can't be less\r\n        require(_moveAmount % 1 finney == 0); // Move amount must be in multiples of 1 finney\r\n        // require(sourceTile.blockValue - _moveAmount >= BASE_TILE_PRICE_WEI); // Must always leave some at source\r\n        \r\n        require(BWUtility.isAdjacent(_xSource, _ySource, _xDest, _yDest));\r\n\r\n        sourceTileBlockValue = sourceTileBlockValue.sub(_moveAmount);\r\n        destTileBlockValue = destTileBlockValue.add(_moveAmount);\r\n\r\n        // If ALL block value was moved away from the source tile, we lose our claim to it. It becomes ownerless.\r\n        if (sourceTileBlockValue == 0) {\r\n            bwData.deleteTile(sourceTileId);\r\n        } else {\r\n            bwData.updateTileBlockValue(sourceTileId, sourceTileBlockValue);\r\n            bwData.deleteOffer(sourceTileId); // Offer invalid since block value has changed\r\n        }\r\n\r\n        bwData.updateTileBlockValue(destTileId, destTileBlockValue);\r\n        bwData.deleteOffer(destTileId);   // Offer invalid since block value has changed\r\n        emit BlockValueMoved(sourceTileId, destTileId, _msgSender, _moveAmount, sourceTileBlockValue, destTileBlockValue, block.timestamp);        \r\n    }\r\n\r\n    function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {\r\n        if (_useBattleValue) {\r\n            require(_msgValue == 0);\r\n            require(bwData.getUserBattleValue(_msgSender) >= _amount);\r\n        } else {\r\n            require(_amount == _msgValue);\r\n        }\r\n    }\r\n\r\n    function setLocalGame(uint16 _tileId, address localGameAddress) public isOwner {\r\n        localGames[_tileId] = localGameAddress;\r\n    }\r\n\r\n    function getLocalGame(uint16 _tileId) view public isValidCaller returns (address) {\r\n        return localGames[_tileId];\r\n    }\r\n\r\n    // BATTLE VALUE FUNCTIONS\r\n    function withdrawBattleValue(address msgSender, uint _battleValueInWei) public isValidCaller returns (uint) {\r\n        //require(_battleValueInWei % 1 finney == 0); // Must be divisible by 1 finney\r\n        uint fee = _battleValueInWei.mul(WITHDRAW_FEE).div(100); // Since we divide by 20 we can never create infinite fractions, so we'll always count in whole wei amounts.\r\n        uint amountToWithdraw = _battleValueInWei.sub(fee);\r\n        uint feeBalance = bwData.getFeeBalance();\r\n        feeBalance = feeBalance.add(fee);\r\n        bwData.setFeeBalance(feeBalance);\r\n        subUserBattleValue(msgSender, _battleValueInWei, true);\r\n        return amountToWithdraw;\r\n    }\r\n\r\n    function addUserBattleValue(address _userId, uint _amount) public isValidCaller {\r\n        uint userBattleValue = bwData.getUserBattleValue(_userId);\r\n        uint newBattleValue = userBattleValue.add(_amount);\r\n        bwData.setUserBattleValue(_userId, newBattleValue); // Don't include boost here!\r\n        emit UserBattleValueUpdated(_userId, newBattleValue, false);\r\n    }\r\n    \r\n    function subUserBattleValue(address _userId, uint _amount, bool _isWithdraw) public isValidCaller {\r\n        uint userBattleValue = bwData.getUserBattleValue(_userId);\r\n        require(_amount <= userBattleValue); // Must be less than user's battle value - also implicitly checks that underflow isn't possible\r\n        uint newBattleValue = userBattleValue.sub(_amount);\r\n        bwData.setUserBattleValue(_userId, newBattleValue); // Don't include boost here!\r\n        emit UserBattleValueUpdated(_userId, newBattleValue, _isWithdraw);\r\n    }\r\n\r\n    function addGlobalBlockValueBalance(uint _amount) public isValidCaller {\r\n        // Track addition to global block value.\r\n        uint blockValueBalance = bwData.getBlockValueBalance();\r\n        bwData.setBlockValueBalance(blockValueBalance.add(_amount));\r\n    }\r\n\r\n    function subGlobalBlockValueBalance(uint _amount) public isValidCaller {\r\n        // Track addition to global block value.\r\n        uint blockValueBalance = bwData.getBlockValueBalance();\r\n        bwData.setBlockValueBalance(blockValueBalance.sub(_amount));\r\n    }\r\n\r\n    // Allow us to transfer out airdropped tokens if we ever receive any\r\n    function transferTokens(address _tokenAddress, address _recipient) public isOwner {\r\n        ERC20I token = ERC20I(_tokenAddress);\r\n        require(token.transfer(_recipient, token.balanceOf(this)));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_bw\",\"type\":\"address\"}],\"name\":\"setValidBwCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msgSender\",\"type\":\"address\"},{\"name\":\"_battleValueInWei\",\"type\":\"uint256\"}],\"name\":\"withdrawBattleValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userId\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_isWithdraw\",\"type\":\"bool\"}],\"name\":\"subUserBattleValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"}],\"name\":\"getLocalGame\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_msgSender\",\"type\":\"address\"},{\"name\":\"_msgValue\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_useBattleValue\",\"type\":\"bool\"}],\"name\":\"verifyAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userId\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addUserBattleValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"},{\"name\":\"localGameAddress\",\"type\":\"address\"}],\"name\":\"setLocalGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_capPercentage\",\"type\":\"uint256\"}],\"name\":\"setAttackBoostCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addGlobalBlockValueBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"transferTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_msgSender\",\"type\":\"address\"},{\"name\":\"_tileId\",\"type\":\"uint16\"},{\"name\":\"_attackAmount\",\"type\":\"uint256\"},{\"name\":\"_useBattleValue\",\"type\":\"bool\"}],\"name\":\"attackTile\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_multiplierPercentage\",\"type\":\"uint256\"}],\"name\":\"setDefendBoostMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_capPercentage\",\"type\":\"uint256\"}],\"name\":\"setDefendBoostCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"name\":\"setAttackFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"subGlobalBlockValueBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_multiplierPercentage\",\"type\":\"uint256\"}],\"name\":\"setAttackBoostMultipler\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bwMarket\",\"type\":\"address\"}],\"name\":\"setValidBwMarketCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"name\":\"setWithdrawFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_msgSender\",\"type\":\"address\"},{\"name\":\"_claimedTileIds\",\"type\":\"uint16[]\"},{\"name\":\"_fortifyAmount\",\"type\":\"uint256\"},{\"name\":\"_useBattleValue\",\"type\":\"bool\"}],\"name\":\"fortifyClaims\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_msgSender\",\"type\":\"address\"},{\"name\":\"_claimedTileIds\",\"type\":\"uint16[]\"},{\"name\":\"_claimAmount\",\"type\":\"uint256\"},{\"name\":\"_useBattleValue\",\"type\":\"bool\"}],\"name\":\"storeInitialClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_msgSender\",\"type\":\"address\"},{\"name\":\"_xSource\",\"type\":\"uint8\"},{\"name\":\"_ySource\",\"type\":\"uint8\"},{\"name\":\"_xDest\",\"type\":\"uint8\"},{\"name\":\"_yDest\",\"type\":\"uint8\"},{\"name\":\"_moveAmount\",\"type\":\"uint256\"}],\"name\":\"moveBlockValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bwData\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tileId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"newClaimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creationTime\",\"type\":\"uint256\"}],\"name\":\"TileClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tileId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"addedValueInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fortifyTime\",\"type\":\"uint256\"}],\"name\":\"TileFortified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tileId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"attacker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"attackAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalAttackAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"defender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"defendAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalDefendAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"attackRoll\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"attackTime\",\"type\":\"uint256\"}],\"name\":\"TileAttackedSuccessfully\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tileId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"attacker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"attackAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalAttackAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"defender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"defendAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalDefendAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"attackRoll\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"defendTime\",\"type\":\"uint256\"}],\"name\":\"TileDefendedSuccessfully\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sourceTileId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"destTileId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"movedBlockValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"postSourceValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"postDestValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"moveTime\",\"type\":\"uint256\"}],\"name\":\"BlockValueMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"battleValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isWithdraw\",\"type\":\"bool\"}],\"name\":\"UserBattleValueUpdated\",\"type\":\"event\"}]","ContractName":"BWService","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000053d34d53a692e6352565909acda5af9145f11bf6","Library":"BWUtility:c6ee4b2ae64b4d506362f25886b806809b8e5beb","SwarmSource":"bzzr://49fe96d13505ce42cc0276f0595a5da0aefecd214feff3e748e3e5ff0ca239d6"}]}