{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\ncontract ISmartCert {\r\n\t// state variables\r\n\tmapping (bytes32 => SignedData) hashes;\r\n\tmapping (address => AccessStruct) accessList;\r\n\tmapping (bytes32 => RevokeStruct) revoked;\r\n\tmapping (bytes32 => Lvl2Struct[]) idMap;\r\n\taddress owner;\r\n\r\n\t// constants\r\n\tstring constant CODE_ACCESS_DENIED = \"A001\";\r\n\tstring constant CODE_ACCESS_POSTER_NOT_AUTHORIZED = \"A002\";\r\n\tstring constant CODE_ACCESS_ISSUER_NOT_AUTHORIZED = \"A003\";\r\n\tstring constant CODE_ACCESS_VERIFY_NOT_AUTHORIZED = \"A004\";\r\n\tstring constant MSG_ISSUER_SIG_NOT_MATCHED = \"E001\"; //\"Issuer's address not matched with signed hash\";\r\n\tstring constant MSG_DOC_REGISTERED = \"E002\"; //\"Document already registered\"; \r\n\tstring constant MSG_REVOKED = \"E003\"; //\"Document already revoked\"; \t\r\n\tstring constant MSG_NOTREG = \"E004\"; //\"Document not registered\";\r\n\tstring constant MSG_INVALID = \"E005\";  //\"Document not valid\"; \r\n\tstring constant MSG_NOFOUND = \"E006\"; //\"No record found\";\r\n\tstring constant MSG_INVALID_CERT_MERKLE_NOT_MATCHED = \"E007\";\r\n\tstring constant MSG_INVALID_ACCESS_RIGHT = \"E008\";\r\n\tstring constant MSG_BATCH_REVOKED = \"E009\"; //\"Batch that the document belong to has already been revoked\";\r\n\tstring constant MSG_MERKLE_CANNOT_EMPTY = \"E010\";\r\n\tstring constant MSG_MERKLE_NOT_REGISTERED = \"E011\";\r\n\tstring constant STATUS_PASS = \"PASS\";\r\n\tstring constant STATUS_FAIL = \"FAIL\";\r\n\tbytes1 constant ACCESS_ISSUER = 0x04;\r\n\tbytes1 constant ACCESS_POSTER = 0x02;\r\n\tbytes1 constant ACCESS_VERIFIER = 0x01;\r\n\tbytes1 constant ACCESS_ALL = 0x07;\r\n\tbytes1 constant ACCESS_ISSUER_POSTER = 0x05;\r\n\tbytes1 constant ACCESS_NONE = 0x00;\r\n\r\n\tstruct SignedData {\r\n\t\t// string data;\r\n\t\tbytes sig;\r\n\t\tuint registerDate;\r\n\t\tbool exists; // empty entry to this struct initially set to false\r\n\t}\r\n\r\n\tstruct RecordStruct {\r\n\t\tbytes32 recordId; // ref id to hashstore\r\n\t\tbool exists; // empty entry to this struct initially set to false\r\n\t}\r\n\r\n\tstruct Lvl2Struct {\r\n\t\tbytes32 recordId;\r\n\t\tbytes32 certhash;\r\n\t\tbool exists;\r\n\t}\r\n\r\n\tstruct RevokeStruct {\r\n\t\tbool exists;\r\n\t\tbytes32 merkleHash;\r\n\t\tbool batchFlag;\r\n\t\tuint date;\r\n\t}\r\n\r\n\tstruct AccessStruct {\r\n\t\tbytes1 accessRight;\r\n\t\tuint date;\r\n\t\tbool isValue;\r\n\t}\r\n\r\n\tfunction ISmartCert() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tevent LogUserRight(string, string);\r\n\tfunction userRight(address userAddr, bytes1 accessRight, uint date) public {\r\n\t\tif (owner != msg.sender) {\r\n\t\t\tLogUserRight(STATUS_FAIL, CODE_ACCESS_DENIED);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (accessRight != ACCESS_ISSUER && accessRight != ACCESS_POSTER && accessRight != ACCESS_VERIFIER && accessRight != ACCESS_ALL && accessRight != ACCESS_ISSUER_POSTER && accessRight != ACCESS_NONE) {\r\n\t\t\tLogUserRight(STATUS_FAIL, MSG_INVALID_ACCESS_RIGHT);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\taccessList[userAddr].accessRight = accessRight;\r\n\t\taccessList[userAddr].date = date;\r\n\t\taccessList[userAddr].isValue = true;\r\n\t\tLogUserRight(STATUS_PASS, \"\");\r\n\t}\r\n\r\n\tfunction checkAccess(address user, bytes1 access) internal view returns (bool) {\r\n\t\tif (accessList[user].isValue) {\r\n\t\t\tif (accessList[user].accessRight & access == access) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction internalRegisterCert(bytes32 certHash, bytes sig, uint registrationDate) internal returns (string, string) {\r\n\t\taddress issuer;\r\n\r\n\t\tif (!checkAccess(msg.sender, ACCESS_POSTER)) {\r\n\t\t\treturn (STATUS_FAIL, CODE_ACCESS_POSTER_NOT_AUTHORIZED);\r\n\t\t}\r\n\t\t\r\n\t\tissuer =  recoverAddr(certHash, sig);\r\n\t\tif (!checkAccess(issuer, ACCESS_ISSUER)) {\r\n\t\t\treturn (STATUS_FAIL, CODE_ACCESS_ISSUER_NOT_AUTHORIZED);\r\n\t\t}\r\n\r\n\t\tif (hashes[certHash].exists) {\r\n\t\t\t// check if doc has already been revoked\r\n\t\t\tif (revoked[certHash].exists) {\r\n\t\t\t\treturn (STATUS_FAIL, MSG_REVOKED);\r\n\t\t\t} else {\r\n\t\t\t\treturn (STATUS_FAIL, MSG_DOC_REGISTERED);\r\n\t\t\t}\t\t\r\n\t\t}\t\r\n\r\n\t\t// signed data (in r, s, v)\r\n\t\thashes[certHash].sig = sig;\r\n\t\t// certificate registration date (YYYYmmdd)\r\n\t\thashes[certHash].registerDate = registrationDate;\r\n\t\t// indicate the record exists\r\n\t\thashes[certHash].exists = true;\r\n\t\treturn (STATUS_PASS, \"\");\r\n\t}\r\n\r\n\tfunction internalRegisterCertWithID(bytes32 certHash, bytes sig, bytes32 merkleHash, uint registrationDate, bytes32 id) internal returns (string, string) {\r\n\t\tstring memory status;\r\n\t\tstring memory message;\r\n\r\n\t\t// check if any record associated with id\r\n\t\tfor (uint i = 0; i < idMap[id].length; i++) {\r\n\t\t\tif (idMap[id][i].exists == true && idMap[id][i].certhash == certHash) {\r\n\t\t\t\treturn (STATUS_FAIL, MSG_DOC_REGISTERED);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// check if merkle root has already been revoked\r\n\t\tif (merkleHash != 0x00) {\r\n\t\t\tif (revoked[merkleHash].exists && revoked[merkleHash].batchFlag) {\r\n\t\t\t\treturn (STATUS_FAIL, MSG_BATCH_REVOKED);\r\n\t\t\t}\t\t\r\n\t\t}\r\n\r\n\t\t// check if merkle root is empty\r\n\t\tif (merkleHash == 0x00) {\r\n\t\t\treturn (STATUS_FAIL, MSG_MERKLE_CANNOT_EMPTY);\r\n\t\t}\r\n\r\n\t\t// check if merkle is exists\r\n\t\tif (!hashes[merkleHash].exists) {\r\n\t\t\treturn (STATUS_FAIL, MSG_MERKLE_NOT_REGISTERED);\r\n\t\t}\t\r\n\r\n\t\t// register certificate\r\n\t\t(status, message) = internalRegisterCert(certHash, sig, registrationDate);\r\n\t\tif (keccak256(status) != keccak256(STATUS_PASS)) {\r\n\t\t\treturn (status, message);\t\t\r\n\t\t}\r\n\r\n\t\t// store record id by ID\r\n\t\tidMap[id].push(Lvl2Struct({recordId:merkleHash, certhash:certHash, exists:true}));\r\n\r\n\t\treturn (STATUS_PASS, \"\");\r\n\t}\r\n\r\n\tfunction internalRevokeCert(bytes32 certHash, bytes sigCertHash, bytes32 merkleHash, bool batchFlag, uint revocationDate) internal returns (string, string) {\r\n\t\taddress issuer1;\r\n\t\taddress issuer2;\r\n\t\t// check poster access right\r\n\t\tif (!checkAccess(msg.sender, ACCESS_POSTER)) {\r\n\t\t\treturn (STATUS_FAIL, CODE_ACCESS_POSTER_NOT_AUTHORIZED);\r\n\t\t}\r\n\t\t// check issuer access right\r\n\t\tissuer1 = recoverAddr(certHash, sigCertHash);\r\n\t\tif (!checkAccess(issuer1, ACCESS_ISSUER)) {\r\n\t\t\treturn (STATUS_FAIL, CODE_ACCESS_ISSUER_NOT_AUTHORIZED);\r\n\t\t}\r\n\t\t// if batch, ensure both certHash and merkleHash are same\r\n\t\tif (batchFlag) {\r\n\t\t\tif (certHash != merkleHash) {\r\n\t\t\t\treturn (STATUS_FAIL, MSG_INVALID_CERT_MERKLE_NOT_MATCHED);\r\n\t\t\t}\r\n\t\t\tif (merkleHash == 0x00) {\r\n\t\t\t\treturn (STATUS_FAIL, MSG_MERKLE_CANNOT_EMPTY);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (merkleHash != 0x00) {\r\n\t\t\t// check if doc (merkle root) is registered\r\n\t\t\tif (hashes[merkleHash].exists == false) {\r\n\t\t\t\treturn (STATUS_FAIL, MSG_NOTREG);\r\n\t\t\t}\r\n\t\t\t// check if requested signature and stored signature is same by comparing two issuer addresses\r\n\t\t\tissuer2 = recoverAddr(merkleHash, hashes[merkleHash].sig);\r\n\t\t\tif (issuer1 != issuer2) {\r\n\t\t\t\treturn (STATUS_FAIL, MSG_ISSUER_SIG_NOT_MATCHED);\r\n\t\t\t}\r\n\t\t}\t\t\t\t\r\n\t\t// check if doc has already been revoked\r\n\t\tif (revoked[certHash].exists) {\r\n\t\t\treturn (STATUS_FAIL, MSG_REVOKED);\r\n\t\t}\r\n\t\t// store / update\r\n\t\tif (batchFlag) {\r\n\t\t\trevoked[certHash].batchFlag = true;\r\n\t\t} else {\t\t\t\r\n\t\t\trevoked[certHash].batchFlag = false;\r\n\t\t}\r\n\t\trevoked[certHash].exists = true;\r\n\t\trevoked[certHash].merkleHash = merkleHash;\r\n\t\trevoked[certHash].date = revocationDate;\r\n\r\n\t\treturn (STATUS_PASS, \"\");\r\n\t}\r\n\r\n\t// event as a form of return value, state mutating function cannot return value to external party\r\n\tevent LogRegisterCert(string, string);\r\n\tfunction registerCert(bytes32 certHash, bytes sig, uint registrationDate) public {\t\t\r\n\t\tstring memory status;\r\n\t\tstring memory message;\r\n\r\n\t\t(status, message) = internalRegisterCert(certHash, sig, registrationDate);\t\t\r\n\t\tLogRegisterCert(status, message);\r\n\t}\r\n\r\n\tevent LogRegisterCertWithID(string, string);\r\n\tfunction registerCertWithID(bytes32 certHash, bytes sig, bytes32 merkleHash, uint registrationDate, bytes32 id) public {\r\n\t\tstring memory status;\r\n\t\tstring memory message;\r\n\r\n\t\t// register certificate\r\n\t\t(status, message) = internalRegisterCertWithID(certHash, sig, merkleHash, registrationDate, id);\r\n\t\tLogRegisterCertWithID(status, message);\r\n\t}\r\n\r\n\t// for verification \r\n\tfunction internalVerifyCert(bytes32 certHash, bytes32 merkleHash, address issuer) internal view returns (string, string) {\r\n\t\tbytes32 tmpCertHash;\r\n\r\n\t\t// check if doc has already been revoked\r\n\t\tif (revoked[certHash].exists && !revoked[certHash].batchFlag) {\r\n\t\t\treturn (STATUS_FAIL, MSG_REVOKED);\r\n\t\t}\r\n\t\tif (merkleHash != 0x00) {\r\n\t\t\t// check if merkle root has already been revoked\r\n\t\t\tif (revoked[merkleHash].exists && revoked[merkleHash].batchFlag) {\r\n\t\t\t\treturn (STATUS_FAIL, MSG_REVOKED);\r\n\t\t\t}\r\n\t\t\ttmpCertHash = merkleHash;\r\n\t\t} else {\r\n\t\t\ttmpCertHash = certHash;\r\n\t\t}\t\t\r\n\t\t// check if doc in hash store\r\n\t\tif (hashes[tmpCertHash].exists) {\r\n\t\t\tif (recoverAddr(tmpCertHash, hashes[tmpCertHash].sig) != issuer) {\t\t\t\r\n\t\t\t\treturn (STATUS_FAIL, MSG_INVALID);\r\n\t\t\t}\r\n\t\t\treturn (STATUS_PASS, \"\");\r\n\t\t} else {\r\n\t\t\treturn (STATUS_FAIL, MSG_NOTREG);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction verifyCert(bytes32 certHash, bytes32 merkleHash, address issuer) public view returns (string, string) {\r\n\t\tstring memory status;\r\n\t\tstring memory message;\r\n\t\tbool isAuthorized;\r\n\r\n\t\t// check verify access\r\n\t\tisAuthorized = checkVerifyAccess();\r\n\t\tif (!isAuthorized) {\r\n\t\t\treturn (STATUS_FAIL, CODE_ACCESS_VERIFY_NOT_AUTHORIZED);\r\n\t\t}\r\n\r\n\t\t(status, message) = internalVerifyCert(certHash, merkleHash, issuer);\r\n\t\treturn (status, message);\r\n\t}\r\n\r\n\tfunction verifyCertWithID(bytes32 certHash, bytes32 merkleHash, bytes32 id, address issuer) public view returns (string, string) {\r\n\t\tstring memory status;\r\n\t\tstring memory message;\r\n\t\tbool isAuthorized;\r\n\r\n\t\t// check verify access\r\n\t\tisAuthorized = checkVerifyAccess();\r\n\t\tif (!isAuthorized) {\r\n\t\t\treturn (STATUS_FAIL, CODE_ACCESS_VERIFY_NOT_AUTHORIZED);\r\n\t\t}\r\n\r\n\t\t// check if any record associated with id\r\n\t\tfor (uint i = 0; i < idMap[id].length; i++) {\r\n\t\t\tif (idMap[id][i].exists == true && idMap[id][i].certhash == certHash) {\r\n\t\t\t\t(status, message) = internalVerifyCert(certHash, merkleHash, issuer);\r\n\t\t\t\treturn (status, message);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// no record found\r\n\t\treturn (STATUS_FAIL, MSG_NOFOUND);\r\n\t}\r\n\r\n\tfunction checkVerifyAccess() internal view returns (bool) {\r\n\t\t// check if sender is authorized for cert verification\r\n\t\treturn checkAccess(msg.sender, ACCESS_VERIFIER);\r\n\t}\r\n\r\n\t// event as a form of return value, state mutating function cannot return value to external party\r\n\tevent LogRevokeCert(string, string);\r\n\tfunction revokeCert(bytes32 certHash, bytes sigCertHash, bytes32 merkleHash, bool batchFlag, uint revocationDate) public {\r\n\t\tstring memory status;\r\n\t\tstring memory message;\r\n\r\n\t\t(status, message) = internalRevokeCert(certHash, sigCertHash, merkleHash, batchFlag, revocationDate);\r\n\t\tLogRevokeCert(status, message);\r\n\t}\r\n\r\n\t// event LogReissueCert(string, bytes32, string);\r\n\tevent LogReissueCert(string, string);\r\n\tfunction reissueCert(bytes32 revokeCertHash, bytes revokeSigCertHash, bytes32 revokeMerkleHash, uint revocationDate, bytes32 registerCertHash, bytes registerSig, uint registrationDate) public {\r\n\t\tstring memory status;\r\n\t\tstring memory message;\r\n\r\n\t\t// revoke certificate\r\n\t\t(status, message) = internalRevokeCert(revokeCertHash, revokeSigCertHash, revokeMerkleHash, false, revocationDate);\r\n\t\tif (keccak256(status) != keccak256(STATUS_PASS)) {\r\n\t\t\tLogReissueCert(status, message);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// register certificate\r\n\t\t(status, message) = internalRegisterCert(registerCertHash, registerSig, registrationDate);\r\n\t\tLogReissueCert(status, message);\r\n\t\tif (keccak256(status) != keccak256(STATUS_PASS)) {\r\n\t\t\trevert();\t\t\t\r\n\t\t}\r\n\r\n\t\tLogReissueCert(STATUS_PASS, \"\");\r\n\t}\r\n\r\n\tevent LogReissueCertWithID(string, string);\r\n\tfunction reissueCertWithID(bytes32 revokeCertHash, bytes revokeSigCertHash, bytes32 revokeMerkleHash, uint revocationDate, bytes32 registerCertHash, bytes registerSig, bytes32 registerMerkleHash, uint registrationDate, bytes32 id) public {\r\n\t\tstring memory status;\r\n\t\tstring memory message;\r\n\r\n\t\t// revoke certificate\r\n\t\t(status, message) = internalRevokeCert(revokeCertHash, revokeSigCertHash, revokeMerkleHash, false, revocationDate);\r\n\t\tif (keccak256(status) != keccak256(STATUS_PASS)) {\r\n\t\t\tLogReissueCertWithID(status, message);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// register certificate\r\n\t\t(status, message) = internalRegisterCertWithID(registerCertHash, registerSig, registerMerkleHash, registrationDate, id);\r\n\t\tLogReissueCertWithID(status, message);\r\n\t\tif (keccak256(status) != keccak256(STATUS_PASS)) {\r\n\t\t\trevert();\r\n\t\t}\r\n\r\n\t\tLogReissueCertWithID(STATUS_PASS, \"\");\r\n\t}\r\n\r\n\tfunction recoverAddr(bytes32 hash, bytes sig) internal pure returns (address) {\r\n\t\tbytes32 r;\r\n\t\tbytes32 s;\r\n\t\tuint8 v;\r\n\r\n\t\t//Check the signature length\r\n\t\tif (sig.length != 65) {\r\n\t\t\treturn (address(0));\r\n\t\t}\r\n\t\t\r\n\t\t// Divide the signature in r, s and v variables\r\n        assembly {\r\n          r := mload(add(sig, 33))\r\n          s := mload(add(sig, 65))\r\n          v := mload(add(sig, 1))\r\n        }\r\n        \r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n          v += 27;\r\n        }\r\n\r\n\t\t// If the version is correct return the signer address\r\n\t\tif (v != 27 && v != 28) {\r\n\t\t\treturn (address(1));\r\n\t\t} else {\r\n\t\t\treturn ecrecover(hash, v, r, s);\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"revokeCertHash\",\"type\":\"bytes32\"},{\"name\":\"revokeSigCertHash\",\"type\":\"bytes\"},{\"name\":\"revokeMerkleHash\",\"type\":\"bytes32\"},{\"name\":\"revocationDate\",\"type\":\"uint256\"},{\"name\":\"registerCertHash\",\"type\":\"bytes32\"},{\"name\":\"registerSig\",\"type\":\"bytes\"},{\"name\":\"registrationDate\",\"type\":\"uint256\"}],\"name\":\"reissueCert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"certHash\",\"type\":\"bytes32\"},{\"name\":\"merkleHash\",\"type\":\"bytes32\"},{\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"verifyCert\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certHash\",\"type\":\"bytes32\"},{\"name\":\"sigCertHash\",\"type\":\"bytes\"},{\"name\":\"merkleHash\",\"type\":\"bytes32\"},{\"name\":\"batchFlag\",\"type\":\"bool\"},{\"name\":\"revocationDate\",\"type\":\"uint256\"}],\"name\":\"revokeCert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userAddr\",\"type\":\"address\"},{\"name\":\"accessRight\",\"type\":\"bytes1\"},{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"userRight\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certHash\",\"type\":\"bytes32\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"registrationDate\",\"type\":\"uint256\"}],\"name\":\"registerCert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"certHash\",\"type\":\"bytes32\"},{\"name\":\"merkleHash\",\"type\":\"bytes32\"},{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"verifyCertWithID\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"revokeCertHash\",\"type\":\"bytes32\"},{\"name\":\"revokeSigCertHash\",\"type\":\"bytes\"},{\"name\":\"revokeMerkleHash\",\"type\":\"bytes32\"},{\"name\":\"revocationDate\",\"type\":\"uint256\"},{\"name\":\"registerCertHash\",\"type\":\"bytes32\"},{\"name\":\"registerSig\",\"type\":\"bytes\"},{\"name\":\"registerMerkleHash\",\"type\":\"bytes32\"},{\"name\":\"registrationDate\",\"type\":\"uint256\"},{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"reissueCertWithID\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certHash\",\"type\":\"bytes32\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"merkleHash\",\"type\":\"bytes32\"},{\"name\":\"registrationDate\",\"type\":\"uint256\"},{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"registerCertWithID\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"\",\"type\":\"string\"}],\"name\":\"LogUserRight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"\",\"type\":\"string\"}],\"name\":\"LogRegisterCert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"\",\"type\":\"string\"}],\"name\":\"LogRegisterCertWithID\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"\",\"type\":\"string\"}],\"name\":\"LogRevokeCert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"\",\"type\":\"string\"}],\"name\":\"LogReissueCert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"\",\"type\":\"string\"}],\"name\":\"LogReissueCertWithID\",\"type\":\"event\"}]","ContractName":"ISmartCert","CompilerVersion":"v0.4.21-nightly.2018.3.1+commit.cf6720ea","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://772cd7c33d4a840772fecc18ed9a184619d46ec3c6ca2797df3d200d8dbe2bef"}]}