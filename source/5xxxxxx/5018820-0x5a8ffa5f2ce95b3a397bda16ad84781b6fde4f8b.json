{"status":"1","message":"OK","result":[{"SourceCode":"// Datarius tokensale smart contract.\r\n// Developed by Phenom.Team <info@phenom.team>\r\npragma solidity ^0.4.15;\r\n\r\n/**\r\n *   @title SafeMath\r\n *   @dev Math operations with safety checks that throw on error\r\n */\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint a, uint b) internal constant returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal constant returns(uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal constant returns(uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal constant returns(uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n *   @title ERC20\r\n *   @dev Standart ERC20 token interface\r\n */\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply = 0;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping (address => uint)) allowed;\r\n\r\n    function balanceOf(address _owner) constant returns (uint);\r\n    function transfer(address _to, uint _value) returns (bool);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool);\r\n    function approve(address _spender, uint _value) returns (bool);\r\n    function allowance(address _owner, address _spender) constant returns (uint);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n} \r\n\r\n/**\r\n *   @title DatariusICO contract  - takes funds from users and issues tokens\r\n */\r\ncontract DatariusICO {\r\n    // DTRC - Datarius token contract\r\n    using SafeMath for uint;\r\n    DatariusToken public DTRC = new DatariusToken(this);\r\n    ERC20 public preSaleToken;\r\n\r\n    // Token price parameters\r\n    // These parametes can be changed only by manager of contract\r\n    uint public tokensPerDollar = 100;\r\n    uint public rateEth = 1176; // Rate USD per ETH\r\n    uint public tokenPrice = tokensPerDollar * rateEth; // DTRC per ETH\r\n    uint public DatToDtrcNumerator = 4589059589;\r\n    uint public DatToDtrcDenominator = 100000000;\r\n\r\n    //Crowdsale parameters\r\n    uint constant softCap = 1000000 * tokensPerDollar * 1e18; \r\n    uint constant hardCap = 51000000 * tokensPerDollar * 1e18;\r\n    uint constant bountyPart = 2; // 2% of TotalSupply for BountyFund\r\n    uint constant partnersPart = 5; // 5% of TotalSupply for ParnersFund\r\n    uint constant teamPart = 5; // 5% of TotalSupply for TeamFund\r\n    uint constant reservePart = 15; // 15% of TotalSupply for ResrveFund\r\n    uint constant publicIcoPart = 73; // 73% of TotalSupply for publicICO\r\n    uint public soldAmount = 0;\r\n    uint startTime = 0;\r\n    // Output ethereum addresses\r\n    address public Company;\r\n    address public BountyFund;\r\n    address public PartnersFund;\r\n    address public TeamFund;\r\n    address public ReserveFund;\r\n    address public Manager; // Manager controls contract\r\n    address public ReserveManager; // // Manager controls contract\r\n    address public Controller_Address1; // First address that is used to buy tokens for other cryptos\r\n    address public Controller_Address2; // Second address that is used to buy tokens for other cryptos\r\n    address public Controller_Address3; // Third address that is used to buy tokens for other cryptos\r\n    address public RefundManager; // Refund manager address\r\n    address public Oracle; // Oracle address\r\n\r\n    // Possible ICO statuses\r\n    enum StatusICO {\r\n        Created,\r\n        Started,\r\n        Paused,\r\n        Finished\r\n    }\r\n    StatusICO statusICO = StatusICO.Created;\r\n    \r\n    // Mappings\r\n    mapping(address => uint) public investmentsInEth; // Mapping for remembering ether of investors\r\n    mapping(address => uint) public tokensEth; // Mapping for remembering tokens of investors who invest in ETH\r\n    mapping(address => uint) public tokensOtherCrypto; // Mapping for remembering tokens of investors who invest in other crypto currencies\r\n    mapping(address => bool) public swaped;\r\n    // Events Log\r\n    event LogStartICO();\r\n    event LogPause();\r\n    event LogFinishICO();\r\n    event LogBuyForInvestor(address investor, uint DTRCValue, string txHash);\r\n    event LogSwapTokens(address investor, uint tokensAmount);\r\n    event LogReturnEth(address investor, uint eth);\r\n    event LogReturnOtherCrypto(address investor, string logString);\r\n\r\n    // Modifiers\r\n    // Allows execution by the managers only\r\n    modifier managersOnly { \r\n        require(\r\n            (msg.sender == Manager) ||\r\n            (msg.sender == ReserveManager)\r\n        );\r\n        _; \r\n     }\r\n    // Allows execution by the contract manager only\r\n    modifier refundManagersOnly { \r\n        require(msg.sender == RefundManager);\r\n        _; \r\n     }\r\n    // Allows execution by the oracle only\r\n    modifier oracleOnly { \r\n        require(msg.sender == Oracle);\r\n        _; \r\n     }\r\n    // Allows execution by the one of controllers only\r\n    modifier controllersOnly {\r\n        require(\r\n            (msg.sender == Controller_Address1)||\r\n            (msg.sender == Controller_Address2)||\r\n            (msg.sender == Controller_Address3)\r\n        );\r\n        _;\r\n    }\r\n\r\n   /**\r\n    *   @dev Contract constructor function\r\n    */\r\n    function DatariusICO(\r\n        address _preSaleToken,\r\n        address _Company,\r\n        address _BountyFund,\r\n        address _PartnersFund,\r\n        address _ReserveFund,\r\n        address _TeamFund,\r\n        address _Manager,\r\n        address _ReserveManager,\r\n        address _Controller_Address1,\r\n        address _Controller_Address2,\r\n        address _Controller_Address3,\r\n        address _RefundManager,\r\n        address _Oracle\r\n        ) public {\r\n        preSaleToken = ERC20(_preSaleToken);\r\n        Company = _Company;\r\n        BountyFund = _BountyFund;\r\n        PartnersFund = _PartnersFund;\r\n        ReserveFund = _ReserveFund;\r\n        TeamFund = _TeamFund;\r\n        Manager = _Manager;\r\n        ReserveManager = _ReserveManager;\r\n        Controller_Address1 = _Controller_Address1;\r\n        Controller_Address2 = _Controller_Address2;\r\n        Controller_Address3 = _Controller_Address3;\r\n        RefundManager = _RefundManager;\r\n        Oracle = _Oracle;\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to set rate of ETH and update token price\r\n    *   @param _rateEth       current ETH rate\r\n    */\r\n    function setRate(uint _rateEth) external oracleOnly {\r\n        rateEth = _rateEth;\r\n        tokenPrice = tokensPerDollar.mul(rateEth);\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to start ICO\r\n    *   Sets ICO status to Started, inits startTime\r\n    */\r\n    function startIco() external managersOnly {\r\n        require(statusICO == StatusICO.Created || statusICO == StatusICO.Paused);\r\n        if(statusICO == StatusICO.Created) {\r\n          startTime = now;\r\n        }\r\n        statusICO = StatusICO.Started;\r\n        LogStartICO();\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to pause ICO\r\n    *   Sets ICO status to Paused\r\n    */\r\n    function pauseIco() external managersOnly {\r\n       require(statusICO == StatusICO.Started);\r\n       statusICO = StatusICO.Paused;\r\n       LogPause();\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to finish ICO\r\n    *   Emits tokens for bounty company, partners and team\r\n    */\r\n    function finishIco() external managersOnly {\r\n        require(statusICO == StatusICO.Started || statusICO == StatusICO.Paused);\r\n        uint alreadyMinted = DTRC.totalSupply();\r\n        uint totalAmount = alreadyMinted.mul(100).div(publicIcoPart);\r\n        DTRC.mintTokens(BountyFund, bountyPart.mul(totalAmount).div(100));\r\n        DTRC.mintTokens(PartnersFund, partnersPart.mul(totalAmount).div(100));\r\n        DTRC.mintTokens(TeamFund, teamPart.mul(totalAmount).div(100));\r\n        DTRC.mintTokens(ReserveFund, reservePart.mul(totalAmount).div(100));\r\n        if (soldAmount >= softCap) {\r\n            DTRC.defrost();\r\n        }\r\n        statusICO = StatusICO.Finished;\r\n        LogFinishICO();\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to swap tokens from pre-sale\r\n    *   @param _investor     pre-sale tokens holder address\r\n    */\r\n    function swapTokens(address _investor) external managersOnly {\r\n         require(!swaped[_investor] && statusICO != StatusICO.Finished);\r\n         swaped[_investor] = true;\r\n         uint tokensToSwap = preSaleToken.balanceOf(_investor);\r\n         uint DTRCTokens = tokensToSwap.mul(DatToDtrcNumerator).div(DatToDtrcDenominator);\r\n         DTRC.mintTokens(_investor, DTRCTokens);\r\n         LogSwapTokens(_investor, tokensToSwap);\r\n    }\r\n   /**\r\n    *   @dev Fallback function calls buy(address _investor, uint _DTRCValue) function to issue tokens\r\n    *        when investor sends ETH to address of ICO contract and then stores investment amount \r\n    */\r\n    function() external payable {\r\n        buy(msg.sender, msg.value.mul(tokenPrice));\r\n        investmentsInEth[msg.sender] = investmentsInEth[msg.sender].add(msg.value); \r\n    }\r\n\r\n   /**\r\n    *   @dev Function to issues tokens for investors who made purchases in other cryptocurrencies\r\n    *   @param _investor     address the tokens will be issued to\r\n    *   @param _txHash       transaction hash of investor's payment\r\n    *   @param _DTRCValue    number of DTRC tokens\r\n    */\r\n\r\n    function buyForInvestor(\r\n        address _investor, \r\n        uint _DTRCValue, \r\n        string _txHash\r\n    ) \r\n        external \r\n        controllersOnly {\r\n        require(statusICO == StatusICO.Started);\r\n        require(soldAmount + _DTRCValue <= hardCap);\r\n        uint bonus = getBonus(_DTRCValue);\r\n        uint total = _DTRCValue.add(bonus);\r\n        DTRC.mintTokens(_investor, total);\r\n        soldAmount = soldAmount.add(_DTRCValue);\r\n        tokensOtherCrypto[_investor] = tokensOtherCrypto[_investor].add(total); \r\n        LogBuyForInvestor(_investor, total, _txHash);\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to issue tokens for investors who paid in ether\r\n    *   @param _investor     address which the tokens will be issued tokens\r\n    *   @param _DTRCValue    number of DTRC tokens\r\n    */\r\n    function buy(address _investor, uint _DTRCValue) internal {\r\n        require(statusICO == StatusICO.Started);\r\n        require(soldAmount + _DTRCValue <= hardCap);\r\n        uint bonus = getBonus(_DTRCValue);\r\n        uint total = _DTRCValue.add(bonus);\r\n        DTRC.mintTokens(_investor, total);\r\n        soldAmount = soldAmount.add(_DTRCValue);\r\n        tokensEth[msg.sender] = tokensEth[msg.sender].add(total); \r\n    }\r\n\r\n   /**\r\n    *   @dev Calculates bonus \r\n    *   @param _value        amount of tokens\r\n    *   @return              bonus value\r\n    */\r\n    function getBonus(uint _value) public constant returns (uint) {\r\n        uint bonus = 0;\r\n        if(now <= startTime + 6 hours) {\r\n            bonus = _value.mul(30).div(100);\r\n            return bonus;\r\n        }\r\n        if(now <= startTime + 12 hours) {\r\n            bonus = _value.mul(25).div(100);\r\n            return bonus;\r\n        }\r\n        if(now <= startTime + 24 hours) {\r\n            bonus = _value.mul(20).div(100);\r\n            return bonus;\r\n        }\r\n        if(now <= startTime + 48 hours) {\r\n            bonus = _value.mul(15).div(100);\r\n            return bonus;\r\n        }\r\n        if(now <= startTime + 15 days) {\r\n            bonus = _value.mul(10).div(100);\r\n            return bonus;\r\n        }\r\n    return bonus;\r\n    }\r\n\r\n   /**\r\n    *   @dev Allows investors to return their investment after the ICO is over\r\n    *   in the case when the SoftCap was not achieved\r\n    */\r\n    function refundEther() public {\r\n        require(\r\n            statusICO == StatusICO.Finished && \r\n            soldAmount < softCap && \r\n            investmentsInEth[msg.sender] > 0\r\n        );\r\n        uint ethToRefund = investmentsInEth[msg.sender];\r\n        investmentsInEth[msg.sender] = 0;\r\n        uint tokensToBurn = tokensEth[msg.sender];\r\n        tokensEth[msg.sender] = 0;\r\n        DTRC.burnTokens(msg.sender, tokensToBurn);\r\n        msg.sender.transfer(ethToRefund);\r\n        LogReturnEth(msg.sender, ethToRefund);\r\n    }\r\n\r\n   /**\r\n    *   @dev Burn tokens of investors who paid in other cryptocurrencies after the ICO is over\r\n    *   in the case when the SoftCap was not achieved\r\n    *   @param _investor     address which the tokens will be burnt\r\n    *   @param _logString    string which contain payment information\r\n    */\r\n    function refundOtherCrypto(\r\n        address _investor, \r\n        string _logString\r\n    ) \r\n        public\r\n        refundManagersOnly {\r\n        require(\r\n            statusICO == StatusICO.Finished && \r\n            soldAmount < softCap\r\n        );\r\n        uint tokensToBurn = tokensOtherCrypto[_investor];\r\n        tokensOtherCrypto[_investor] = 0;\r\n        DTRC.burnTokens(_investor, tokensToBurn);\r\n        LogReturnOtherCrypto(_investor, _logString);\r\n    }\r\n\r\n   /**\r\n    *   @dev Allows Company withdraw investments when ICO is over and soft cap achieved\r\n    */\r\n    function withdrawEther() external managersOnly {\r\n        require(statusICO == StatusICO.Finished && soldAmount >= softCap);\r\n        Company.transfer(this.balance);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *   @title DatariusToken\r\n *   @dev Datarius token contract\r\n */\r\ncontract DatariusToken is ERC20 {\r\n    using SafeMath for uint;\r\n    string public name = \"Datarius Credit\";\r\n    string public symbol = \"DTRC\";\r\n    uint public decimals = 18;\r\n\r\n    // Ico contract address\r\n    address public ico;\r\n    event Burn(address indexed from, uint value);\r\n    \r\n    // Tokens transfer ability status\r\n    bool public tokensAreFrozen = true;\r\n\r\n    // Allows execution by the owner only\r\n    modifier icoOnly { \r\n        require(msg.sender == ico); \r\n        _; \r\n    }\r\n\r\n   /**\r\n    *   @dev Contract constructor function sets Ico address\r\n    *   @param _ico          ico address\r\n    */\r\n    function DatariusToken(address _ico) public {\r\n       ico = _ico;\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to mint tokens\r\n    *   @param _holder       beneficiary address the tokens will be issued to\r\n    *   @param _value        number of tokens to issue\r\n    */\r\n    function mintTokens(address _holder, uint _value) external icoOnly {\r\n       require(_value > 0);\r\n       balances[_holder] = balances[_holder].add(_value);\r\n       totalSupply = totalSupply.add(_value);\r\n       Transfer(0x0, _holder, _value);\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Function to enable token transfers\r\n    */\r\n    function defrost() external icoOnly {\r\n       tokensAreFrozen = false;\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Burn Tokens\r\n    *   @param _holder       token holder address which the tokens will be burnt\r\n    *   @param _value        number of tokens to burn\r\n    */\r\n    function burnTokens(address _holder, uint _value) external icoOnly {\r\n        require(balances[_holder] > 0);\r\n        totalSupply = totalSupply.sub(_value);\r\n        balances[_holder] = balances[_holder].sub(_value);\r\n        Burn(_holder, _value);\r\n    }\r\n\r\n   /**\r\n    *   @dev Get balance of tokens holder\r\n    *   @param _holder        holder's address\r\n    *   @return               balance of investor\r\n    */\r\n    function balanceOf(address _holder) constant returns (uint) {\r\n         return balances[_holder];\r\n    }\r\n\r\n   /**\r\n    *   @dev Send coins\r\n    *   throws on any error rather then return a false flag to minimize\r\n    *   user errors\r\n    *   @param _to           target address\r\n    *   @param _amount       transfer amount\r\n    *\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transfer(address _to, uint _amount) public returns (bool) {\r\n        require(!tokensAreFrozen);\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev An account/contract attempts to get the coins\r\n    *   throws on any error rather then return a false flag to minimize user errors\r\n    *\r\n    *   @param _from         source address\r\n    *   @param _to           target address\r\n    *   @param _amount       transfer amount\r\n    *\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transferFrom(address _from, address _to, uint _amount) public returns (bool) {\r\n        require(!tokensAreFrozen);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(_from, _to, _amount);\r\n        return true;\r\n     }\r\n\r\n\r\n   /**\r\n    *   @dev Allows another account/contract to spend some tokens on its behalf\r\n    *   throws on any error rather then return a false flag to minimize user errors\r\n    *\r\n    *   also, to minimize the risk of the approve/transferFrom attack vector\r\n    *   approve has to be called twice in 2 separate transactions - once to\r\n    *   change the allowance to 0 and secondly to change it to the new allowance\r\n    *   value\r\n    *\r\n    *   @param _spender      approved address\r\n    *   @param _amount       allowance amount\r\n    *\r\n    *   @return true if the approval was successful\r\n    */\r\n    function approve(address _spender, uint _amount) public returns (bool) {\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    *   @param _owner        the address which owns the funds\r\n    *   @param _spender      the address which will spend the funds\r\n    *\r\n    *   @return              the amount of tokens still avaible for the spender\r\n    */\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_DTRCValue\",\"type\":\"uint256\"},{\"name\":\"_txHash\",\"type\":\"string\"}],\"name\":\"buyForInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"swaped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investmentsInEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"swapTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_logString\",\"type\":\"string\"}],\"name\":\"refundOtherCrypto\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Controller_Address1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rateEth\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Controller_Address3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PartnersFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RefundManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BountyFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TeamFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Company\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerDollar\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DatToDtrcDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DTRC\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensOtherCrypto\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DatToDtrcNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Controller_Address2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReserveFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReserveManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_preSaleToken\",\"type\":\"address\"},{\"name\":\"_Company\",\"type\":\"address\"},{\"name\":\"_BountyFund\",\"type\":\"address\"},{\"name\":\"_PartnersFund\",\"type\":\"address\"},{\"name\":\"_ReserveFund\",\"type\":\"address\"},{\"name\":\"_TeamFund\",\"type\":\"address\"},{\"name\":\"_Manager\",\"type\":\"address\"},{\"name\":\"_ReserveManager\",\"type\":\"address\"},{\"name\":\"_Controller_Address1\",\"type\":\"address\"},{\"name\":\"_Controller_Address2\",\"type\":\"address\"},{\"name\":\"_Controller_Address3\",\"type\":\"address\"},{\"name\":\"_RefundManager\",\"type\":\"address\"},{\"name\":\"_Oracle\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStartICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogFinishICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"DTRCValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"txHash\",\"type\":\"string\"}],\"name\":\"LogBuyForInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"LogSwapTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"LogReturnEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"logString\",\"type\":\"string\"}],\"name\":\"LogReturnOtherCrypto\",\"type\":\"event\"}]","ContractName":"DatariusICO","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000fddebe09dfa664a372d8d33a8402abc8c36a7022000000000000000000000000aba90731e25458947513ae9ca877d714be87b0eb0000000000000000000000007afee661277cb711d6018034332121e3f56fd4640000000000000000000000004617b7e80cd6f60a78f5614923e407f4aed33dc2000000000000000000000000efa6fc288a7607aa5169de4ee5f3ef9403701f8c0000000000000000000000008979e5e36bd46f00a5d6817cb31fc697a9a37bbf0000000000000000000000005712f80eb5e3c46804afcf67558990f2f70a2fa8000000000000000000000000f1a3624757d410d2dddf2eb0a8dcdd810d2f1a3b00000000000000000000000038dc197a6670db8be0e5f3df56386ad526d224d200000000000000000000000045429507995a8a8c5e7660c2e216c900959f100800000000000000000000000045429507995a8a8c5e7660c2e216c900959f1008000000000000000000000000a521ccebe70a51c318bc713fc18dbebc38ccaba8000000000000000000000000aa6edddff7359f6407b577ca5a0ea23e6245093e","Library":"","SwarmSource":"bzzr://857008d5c5c6ea1e8c4245ce7e5e64baf2e2ab3197c0bfa76f20d6663794ad92"}]}