{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\ncontract MintableToken {\r\n  event Mint(address indexed to, uint256 amount);\r\n  function leave() public;\r\n  function mint(address _to, uint256 _amount) public returns (bool);\r\n}\r\n\r\ncontract CryptoColors is Pausable {\r\n  using SafeMath for uint256;\r\n\r\n  // CONSTANT\r\n\r\n  string public constant name = \"Pixinch Color\";\r\n  string public constant symbol = \"PCLR\";\r\n  uint public constant totalSupply = 16777216;\r\n\r\n  // PUBLIC VARs\r\n  // the total number of colors bought\r\n  uint256 public totalBoughtColor;\r\n  // start and end timestamps where investments are allowed (both inclusive)\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n  \r\n  // address where funds are collected\r\n  address public wallet;\r\n  // price for a color\r\n  uint256 public colorPrice;\r\n  // nb token supply when a color is bought\r\n  uint public supplyPerColor;\r\n  // the part on the supply that is collected by Pixinch\r\n  uint8 public ownerPart;\r\n\r\n  uint8 public bonusStep;\r\n  uint public nextBonusStepLimit = 500000;\r\n\r\n  // MODIFIER\r\n  \r\n  /**\r\n  * @dev Guarantees msg.sender is owner of the given token\r\n  * @param _index uint256 Index of the token to validate its ownership belongs to msg.sender\r\n  */\r\n  modifier onlyOwnerOf(uint _index) {\r\n    require(tree[_index].owner == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Garantee index and token are valid value\r\n  */\r\n  modifier isValid(uint _tokenId, uint _index) {\r\n    require(_validToken(_tokenId) && _validIndex(_index));\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Guarantees all color have been sold\r\n  */\r\n  modifier whenActive() {\r\n    require(isCrowdSaleActive());\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Guarantees all color have been sold\r\n  */\r\n  modifier whenGameActive() {\r\n    require(isGameActivated());\r\n    _;\r\n  }\r\n\r\n  // EVENTS\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ColorPurchased(address indexed from, address indexed to, uint256 color, uint256 value);\r\n  event ColorReserved(address indexed to, uint256 qty);\r\n\r\n\r\n  // PRIVATE\r\n  // amount of raised money in wei and cap in wei\r\n  uint256 weiRaised;\r\n  uint256 cap;\r\n  // part of mint token for the wallet\r\n  uint8 walletPart;\r\n  // address of the mintable token\r\n  MintableToken token;\r\n  // starting color price\r\n  uint startPrice = 10 finney;\r\n\r\n  struct BlockRange {\r\n    uint start;\r\n    uint end;\r\n    uint next;\r\n    address owner;\r\n    uint price;\r\n  }\r\n\r\n  BlockRange[totalSupply+1] tree;\r\n  // minId available in the tree\r\n  uint minId = 1;\r\n  // min block index available in the tree;\r\n  uint lastBlockId = 0;\r\n  // mapping of owner and range index in the tree\r\n  mapping(address => uint256[]) ownerRangeIndex;\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) tokenApprovals;\r\n  // pending payments\r\n  mapping(address => uint) private payments;\r\n  // mapping owner balance\r\n  mapping(address => uint) private ownerBalance;\r\n  \r\n\r\n  // CONSTRUCTOR\r\n\r\n  function CryptoColors(uint256 _startTime, uint256 _endTime, address _token, address _wallet) public {\r\n    require(_token != address(0));\r\n    require(_wallet != address(0));\r\n    require(_startTime > 0);\r\n    require(_endTime > now);\r\n\r\n    owner = msg.sender;\r\n    \r\n    colorPrice = 0.001 ether;\r\n    supplyPerColor = 4;\r\n    ownerPart = 50;\r\n    walletPart = 50;\r\n\r\n    startTime = _startTime;\r\n    endTime = _endTime;\r\n    cap = 98000 ether;\r\n    \r\n    token = MintableToken(_token);\r\n    wallet = _wallet;\r\n    \r\n    // booked for airdrop and rewards\r\n    reserveRange(owner, 167770);\r\n  }\r\n\r\n  // fallback function can be used to buy tokens\r\n  function () external payable {\r\n    buy();\r\n  }\r\n\r\n  // VIEWS\r\n  \r\n  function myPendingPayment() public view returns (uint) {\r\n    return payments[msg.sender];\r\n  }\r\n\r\n  function isGameActivated() public view returns (bool) {\r\n    return totalSupply == totalBoughtColor || now > endTime;\r\n  }\r\n\r\n  function isCrowdSaleActive() public view returns (bool) {\r\n    return now < endTime && now >= startTime && weiRaised < cap;\r\n  }\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return ownerBalance[_owner];\r\n  }\r\n\r\n  function ownerOf(uint256 _tokenId) whenGameActive public view returns (address owner) {\r\n    require(_validToken(_tokenId));\r\n    uint index = lookupIndex(_tokenId);\r\n    return tree[index].owner;\r\n  }\r\n\r\n  // return tokens index own by address (including history)\r\n  function tokensIndexOf(address _owner, bool _withHistory) whenGameActive public view returns (uint[] result) {\r\n    require(_owner != address(0));\r\n    if (_withHistory) {\r\n      return ownerRangeIndex[_owner];\r\n    } else {\r\n      uint[] memory indexes = ownerRangeIndex[_owner];\r\n      result = new uint[](indexes.length);\r\n      uint i = 0;\r\n      for (uint index = 0; index < indexes.length; index++) {\r\n        BlockRange storage br = tree[indexes[index]];\r\n        if (br.owner == _owner) {\r\n          result[i] = indexes[index];\r\n          i++;\r\n        }\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  function approvedFor(uint256 _tokenId) whenGameActive public view returns (address) {\r\n    require(_validToken(_tokenId));\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the range store at the specified index.\r\n  * @param _index The index to query the tree of.\r\n  * @return An Array of value is this order: start, end, owner, next, price.\r\n  */\r\n  function getRange(uint _index) public view returns (uint, uint, address, uint, uint) {\r\n    BlockRange storage range = tree[_index];\r\n    require(range.owner != address(0));\r\n    return (range.start, range.end, range.owner, range.next, range.price);\r\n  }\r\n\r\n  function lookupIndex(uint _tokenId) public view returns (uint index) {\r\n    return lookupIndex(_tokenId, 1);\r\n  }\r\n\r\n  function lookupIndex(uint _tokenId, uint _start) public view returns (uint index) {\r\n    if (_tokenId > totalSupply || _tokenId > minId) {\r\n      return 0;\r\n    }\r\n    BlockRange storage startBlock = tree[_tokenId];\r\n    if (startBlock.owner != address(0)) {\r\n      return _tokenId;\r\n    }\r\n    index = _start;\r\n    startBlock = tree[index];\r\n    require(startBlock.owner != address(0));\r\n    while (startBlock.end < _tokenId && startBlock.next != 0 ) {\r\n      index = startBlock.next;\r\n      startBlock = tree[index];\r\n    }\r\n    return;\r\n  }\r\n\r\n  // PAYABLE\r\n\r\n  function buy() public payable whenActive whenNotPaused returns (string thanks) {\r\n    require(msg.sender != address(0));\r\n    require(msg.value.div(colorPrice) > 0);\r\n    uint _nbColors = 0;\r\n    uint value = msg.value;\r\n    if (totalSupply > totalBoughtColor) {\r\n      (_nbColors, value) = buyColors(msg.sender, value);\r\n    }\r\n    if (totalSupply == totalBoughtColor) {\r\n      // require(value >= colorPrice && weiRaised.add(value) <= cap);\r\n      if (weiRaised.add(value) > cap) {\r\n        value = cap.sub(weiRaised);\r\n      }\r\n      _nbColors = _nbColors.add(value.div(colorPrice));\r\n      mintPin(msg.sender, _nbColors);\r\n      if (weiRaised == cap ) {\r\n        endTime = now;\r\n        token.leave();\r\n      }\r\n    }\r\n    forwardFunds(value);\r\n    return \"thank you for your participation.\";\r\n  }\r\n\r\n  function purchase(uint _tokenId) public payable whenGameActive {\r\n    uint _index = lookupIndex(_tokenId);\r\n    return purchaseWithIndex(_tokenId, _index);\r\n  }\r\n  \r\n  function purchaseWithIndex(uint _tokenId, uint _index) public payable whenGameActive isValid(_tokenId, _index) {\r\n    require(msg.sender != address(0));\r\n\r\n    BlockRange storage bRange = tree[_index];\r\n    require(bRange.start <= _tokenId && _tokenId <= bRange.end);\r\n    if (bRange.start < bRange.end) {\r\n      // split and update index;\r\n      _index = splitRange(_index, _tokenId, _tokenId);\r\n      bRange = tree[_index];\r\n    }\r\n\r\n    uint price = bRange.price;\r\n    address prevOwner = bRange.owner;\r\n    require(msg.value >= price && prevOwner != msg.sender);\r\n    if (prevOwner != address(0)) {\r\n      payments[prevOwner] = payments[prevOwner].add(price);\r\n      ownerBalance[prevOwner]--;\r\n    }\r\n    // add is less expensive than mul\r\n    bRange.price = bRange.price.add(bRange.price);\r\n    bRange.owner = msg.sender;\r\n\r\n    // update ownedColors\r\n    ownerRangeIndex[msg.sender].push(_index);\r\n    ownerBalance[msg.sender]++;\r\n\r\n    ColorPurchased(prevOwner, msg.sender, _tokenId, price);\r\n    msg.sender.transfer(msg.value.sub(price));\r\n  }\r\n\r\n  // PUBLIC\r\n\r\n  function updateToken(address _token) onlyOwner public {\r\n    require(_token != address(0));\r\n    token = MintableToken(_token);\r\n  }\r\n\r\n  function updateWallet(address _wallet) onlyOwner public {\r\n    require(_wallet != address(0));\r\n    wallet = _wallet;\r\n  }\r\n\r\n  function withdrawPayment() public whenGameActive {\r\n    uint refund = payments[msg.sender];\r\n    payments[msg.sender] = 0;\r\n    msg.sender.transfer(refund);\r\n  }\r\n\r\n  function transfer(address _to, uint256 _tokenId) public {\r\n    uint _index = lookupIndex(_tokenId);\r\n    return transferWithIndex(_to, _tokenId, _index);\r\n  }\r\n  \r\n  function transferWithIndex(address _to, uint256 _tokenId, uint _index) public isValid(_tokenId, _index) onlyOwnerOf(_index) {\r\n    BlockRange storage bRange = tree[_index];\r\n    if (bRange.start > _tokenId || _tokenId > bRange.end) {\r\n      _index = lookupIndex(_tokenId, _index);\r\n      require(_index > 0);\r\n      bRange = tree[_index];\r\n    }\r\n    if (bRange.start < bRange.end) {\r\n      _index = splitRange(_index, _tokenId, _tokenId);\r\n      bRange = tree[_index];\r\n    }\r\n    require(_to != address(0) && bRange.owner != _to);\r\n    bRange.owner = _to;\r\n    ownerRangeIndex[msg.sender].push(_index);\r\n    Transfer(msg.sender, _to, _tokenId);\r\n    ownerBalance[_to]++;\r\n    ownerBalance[msg.sender]--;\r\n  }\r\n\r\n  function approve(address _to, uint256 _tokenId) public {\r\n    uint _index = lookupIndex(_tokenId);\r\n    return approveWithIndex(_to, _tokenId, _index);\r\n  }\r\n  \r\n  function approveWithIndex(address _to, uint256 _tokenId, uint _index) public isValid(_tokenId, _index) onlyOwnerOf(_index) {\r\n    require(_to != address(0));\r\n    BlockRange storage bRange = tree[_index];\r\n    if (bRange.start > _tokenId || _tokenId > bRange.end) {\r\n      _index = lookupIndex(_tokenId, _index);\r\n      require(_index > 0);\r\n      bRange = tree[_index];\r\n    }\r\n    require(_to != bRange.owner);\r\n    if (bRange.start < bRange.end) {\r\n      splitRange(_index, _tokenId, _tokenId);\r\n    }\r\n    tokenApprovals[_tokenId] = _to;\r\n    Approval(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  function takeOwnership(uint256 _tokenId) public {\r\n    uint index = lookupIndex(_tokenId);\r\n    return takeOwnershipWithIndex(_tokenId, index);\r\n  }\r\n\r\n  function takeOwnershipWithIndex(uint256 _tokenId, uint _index) public isValid(_tokenId, _index) {\r\n    require(tokenApprovals[_tokenId] == msg.sender);\r\n    BlockRange storage bRange = tree[_index];\r\n    require(bRange.start <= _tokenId && _tokenId <= bRange.end);\r\n    ownerBalance[bRange.owner]--;\r\n    bRange.owner = msg.sender;\r\n    ownerRangeIndex[msg.sender].push(_index); \r\n    ownerBalance[msg.sender]++;\r\n    Transfer(bRange.owner, msg.sender, _tokenId);\r\n    delete tokenApprovals[_tokenId];\r\n  }\r\n\r\n\r\n  // INTERNAL\r\n  function forwardFunds(uint256 value) private {\r\n    wallet.transfer(value);\r\n    weiRaised = weiRaised.add(value);\r\n    msg.sender.transfer(msg.value.sub(value));\r\n  }\r\n\r\n  function mintPin(address _to, uint _nbColors) private {\r\n    uint _supply = supplyPerColor.mul(_nbColors);\r\n    if (_supply == 0) {\r\n      return;\r\n    }\r\n    uint _ownerPart = _supply.mul(ownerPart)/100;\r\n    token.mint(_to, uint256(_ownerPart.mul(100000000)));\r\n    uint _walletPart = _supply.mul(walletPart)/100;\r\n    token.mint(wallet, uint256(_walletPart.mul(100000000)));\r\n  }\r\n\r\n  function buyColors(address _to, uint256 value) private returns (uint _nbColors, uint valueRest) {\r\n    _nbColors = value.div(colorPrice);\r\n    if (bonusStep < 3 && totalBoughtColor.add(_nbColors) > nextBonusStepLimit) {\r\n      uint max = nextBonusStepLimit.sub(totalBoughtColor);\r\n      uint val = max.mul(colorPrice);\r\n      if (max == 0 || val > value) {\r\n        return (0, value);\r\n      }\r\n      valueRest = value.sub(val);\r\n      reserveColors(_to, max);\r\n      uint _c;\r\n      uint _v;\r\n      (_c, _v) = buyColors(_to, valueRest);\r\n      return (_c.add(max), _v.add(val));\r\n    }\r\n    reserveColors(_to, _nbColors);\r\n    return (_nbColors, value);\r\n  }\r\n\r\n  function reserveColors(address _to, uint _nbColors) private returns (uint) {\r\n    if (_nbColors > totalSupply - totalBoughtColor) {\r\n      _nbColors = totalSupply - totalBoughtColor;\r\n    }\r\n    if (_nbColors == 0) {\r\n      return;\r\n    }\r\n    reserveRange(_to, _nbColors);\r\n    ColorReserved(_to, _nbColors);\r\n    mintPin(_to, _nbColors);\r\n    checkForSteps();\r\n    return _nbColors;\r\n  }\r\n\r\n  function checkForSteps() private {\r\n    if (bonusStep < 3 && totalBoughtColor >= nextBonusStepLimit) {\r\n      if ( bonusStep == 0) {\r\n        colorPrice = colorPrice + colorPrice;\r\n      } else {\r\n        colorPrice = colorPrice + colorPrice - (1 * 0.001 finney);\r\n      }\r\n      bonusStep = bonusStep + 1;\r\n      nextBonusStepLimit = nextBonusStepLimit + (50000 + (bonusStep+1) * 100000);\r\n    }\r\n    if (isGameActivated()) {\r\n      colorPrice = 1 finney;\r\n      ownerPart = 70;\r\n      walletPart = 30;\r\n      endTime = now.add(120 hours);\r\n    }\r\n  }\r\n\r\n  function _validIndex(uint _index) internal view returns (bool) {\r\n    return _index > 0 && _index < tree.length;\r\n  }\r\n\r\n  function _validToken(uint _tokenId) internal pure returns (bool) {\r\n    return _tokenId > 0 && _tokenId <= totalSupply;\r\n  }\r\n\r\n  function reserveRange(address _to, uint _nbTokens) internal {\r\n    require(_nbTokens <= totalSupply);\r\n    BlockRange storage rblock = tree[minId];\r\n    rblock.start = minId;\r\n    rblock.end = minId.add(_nbTokens).sub(1);\r\n    rblock.owner = _to;\r\n    rblock.price = startPrice;\r\n    \r\n    rblock = tree[lastBlockId];\r\n    rblock.next = minId;\r\n    \r\n    lastBlockId = minId;\r\n    ownerRangeIndex[_to].push(minId);\r\n    \r\n    ownerBalance[_to] = ownerBalance[_to].add(_nbTokens);\r\n    minId = minId.add(_nbTokens);\r\n    totalBoughtColor = totalBoughtColor.add(_nbTokens);\r\n  }\r\n\r\n  function splitRange(uint index, uint start, uint end) internal returns (uint) {\r\n    require(index > 0);\r\n    require(start <= end);\r\n    BlockRange storage startBlock = tree[index];\r\n    require(startBlock.start < startBlock.end && startBlock.start <= start && startBlock.end >= end);\r\n\r\n    BlockRange memory rblockUnique = tree[start];\r\n    rblockUnique.start = start;\r\n    rblockUnique.end = end;\r\n    rblockUnique.owner = startBlock.owner;\r\n    rblockUnique.price = startBlock.price;\r\n    \r\n    uint nextStart = end.add(1);\r\n    if (nextStart <= totalSupply) {\r\n      rblockUnique.next = nextStart;\r\n\r\n      BlockRange storage rblockEnd = tree[nextStart];\r\n      rblockEnd.start = nextStart;\r\n      rblockEnd.end = startBlock.end;\r\n      rblockEnd.owner = startBlock.owner;\r\n      rblockEnd.next = startBlock.next;\r\n      rblockEnd.price = startBlock.price;\r\n    }\r\n\r\n    if (startBlock.start < start) {\r\n      startBlock.end = start.sub(1);\r\n    } else {\r\n      startBlock.end = start;\r\n    }\r\n    startBlock.next = start;\r\n    tree[start] = rblockUnique;\r\n    // update own color\r\n    if (rblockUnique.next != startBlock.next) {\r\n      ownerRangeIndex[startBlock.owner].push(startBlock.next);\r\n    }\r\n    if (rblockUnique.next != 0) {\r\n      ownerRangeIndex[startBlock.owner].push(rblockUnique.next);\r\n    }\r\n    \r\n    return startBlock.next;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalBoughtColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_withHistory\",\"type\":\"bool\"}],\"name\":\"tokensIndexOf\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"lookupIndex\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myPendingPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"transferWithIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approvedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusStep\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerPart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"approveWithIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"updateToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"updateWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"lookupIndex\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isGameActivated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyPerColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"thanks\",\"type\":\"string\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"purchaseWithIndex\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCrowdSaleActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextBonusStepLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"takeOwnershipWithIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getRange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"colorPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"color\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ColorPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"qty\",\"type\":\"uint256\"}],\"name\":\"ColorReserved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CryptoColors","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005a949f80000000000000000000000000000000000000000000000000000000005acff30000000000000000000000000045bdc4529d181877800734628a835de61b9bac2f000000000000000000000000cd05b8d96e9ade81f9fd8e0d4e17ea9976a85aac","Library":"","SwarmSource":"bzzr://aaf1314f94d134da39c71b530c2447f5e706aaf6f5ce300cb4b38e0a297e17e4"}]}