{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/interfaces/IErc20.sol\r\n\r\n/**\r\n * @title IErc20\r\n * @author dYdX\r\n *\r\n * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\r\n * that we don't automatically revert when calling non-compliant tokens that have no return value for\r\n * transfer(), transferFrom(), or approve().\r\n */\r\ninterface IErc20 {\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function totalSupply(\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address who\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function name()\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function symbol()\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function decimals()\r\n        external\r\n        view\r\n        returns (uint8);\r\n}\r\n\r\n// File: contracts/protocol/lib/Monetary.sol\r\n\r\n/**\r\n * @title Monetary\r\n * @author dYdX\r\n *\r\n * Library for types involving money\r\n */\r\nlibrary Monetary {\r\n\r\n    /*\r\n     * The price of a base-unit of an asset.\r\n     */\r\n    struct Price {\r\n        uint256 value;\r\n    }\r\n\r\n    /*\r\n     * Total value of an some amount of an asset. Equal to (price * amount).\r\n     */\r\n    struct Value {\r\n        uint256 value;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/interfaces/IPriceOracle.sol\r\n\r\n/**\r\n * @title IPriceOracle\r\n * @author dYdX\r\n *\r\n * Interface that Price Oracles for Solo must implement in order to report prices.\r\n */\r\ncontract IPriceOracle {\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 public constant ONE_DOLLAR = 10 ** 36;\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Get the price of a token\r\n     *\r\n     * @param  token  The ERC20 token address of the market\r\n     * @return        The USD price of a base unit of the token, then multiplied by 10^36.\r\n     *                So a USD-stable coin with 18 decimal places would return 10^18.\r\n     *                This is the price of the base unit rather than the price of a \"human-readable\"\r\n     *                token amount. Every ERC20 may have a different number of decimals.\r\n     */\r\n    function getPrice(\r\n        address token\r\n    )\r\n        public\r\n        view\r\n        returns (Monetary.Price memory);\r\n}\r\n\r\n// File: contracts/protocol/lib/Require.sol\r\n\r\n/**\r\n * @title Require\r\n * @author dYdX\r\n *\r\n * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\r\n */\r\nlibrary Require {\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant ASCII_ZERO = 48; // '0'\r\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\r\n    uint256 constant ASCII_LOWER_EX = 120; // 'x'\r\n    bytes2 constant COLON = 0x3a20; // ': '\r\n    bytes2 constant COMMA = 0x2c20; // ', '\r\n    bytes2 constant LPAREN = 0x203c; // ' <'\r\n    byte constant RPAREN = 0x3e; // '>'\r\n    uint256 constant FOUR_BIT_MASK = 0xf;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function stringifyTruncated(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        // put the input bytes into the result\r\n        bytes memory result = abi.encodePacked(input);\r\n\r\n        // determine the length of the input by finding the location of the last non-zero byte\r\n        for (uint256 i = 32; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // find the last non-zero byte in order to determine the length\r\n            if (result[i] != 0) {\r\n                uint256 length = i + 1;\r\n\r\n                /* solium-disable-next-line security/no-inline-assembly */\r\n                assembly {\r\n                    mstore(result, length) // r.length = length;\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        // all bytes are zero\r\n        return new bytes(0);\r\n    }\r\n\r\n    function stringify(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (input == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        // get the final string length\r\n        uint256 j = input;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n\r\n        // allocate the string\r\n        bytes memory bstr = new bytes(length);\r\n\r\n        // populate the string starting with the least-significant character\r\n        j = input;\r\n        for (uint256 i = length; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // take last decimal digit\r\n            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\r\n\r\n            // remove the last decimal digit\r\n            j /= 10;\r\n        }\r\n\r\n        return bstr;\r\n    }\r\n\r\n    function stringify(\r\n        address input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // addresses are \"0x\" followed by 20 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(42);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[41 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[40 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function stringify(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // bytes32 are \"0x\" followed by 32 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(66);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[65 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[64 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function char(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (byte)\r\n    {\r\n        // return ASCII digit (0-9)\r\n        if (input < 10) {\r\n            return byte(uint8(input + ASCII_ZERO));\r\n        }\r\n\r\n        // return ASCII letter (a-f)\r\n        return byte(uint8(input + ASCII_RELATIVE_ZERO));\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @author dYdX\r\n *\r\n * Library for non-standard Math functions\r\n */\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Math\";\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /*\r\n     * Return target * (numerator / denominator), but rounded up.\r\n     */\r\n    function getPartialRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    function to128(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint128)\r\n    {\r\n        uint128 result = uint128(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint128\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to96(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint96)\r\n    {\r\n        uint96 result = uint96(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint96\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to32(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        uint32 result = uint32(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint32\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Time.sol\r\n\r\n/**\r\n * @title Time\r\n * @author dYdX\r\n *\r\n * Library for dealing with time, assuming timestamps fit within 32 bits (valid until year 2106)\r\n */\r\nlibrary Time {\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function currentTime()\r\n        internal\r\n        view\r\n        returns (uint32)\r\n    {\r\n        return Math.to32(block.timestamp);\r\n    }\r\n}\r\n\r\n// File: contracts/external/interfaces/ICurve.sol\r\n\r\n/*\r\n\r\n    Copyright 2020 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n/**\r\n * @title ICurve\r\n * @author dYdX\r\n *\r\n * Partial interface for a Curve contract.\r\n */\r\ninterface ICurve {\r\n\r\n    function fee()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function get_dy(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/external/interfaces/IUniswapV2Pair.sol\r\n\r\n/*\r\n\r\n    Copyright 2020 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n/**\r\n * @title IUniswapV2Pair\r\n * @author dYdX\r\n *\r\n * Partial interface for a Uniswap V2 pair.\r\n */\r\ninterface IUniswapV2Pair {\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112, uint112, uint32);\r\n}\r\n\r\n// File: contracts/external/oracles/DaiPriceOracle.sol\r\n\r\n/**\r\n * @title DaiPriceOracle\r\n * @author dYdX\r\n *\r\n * PriceOracle that gives the price of Dai in USDC.\r\n */\r\ncontract DaiPriceOracle is\r\n    Ownable,\r\n    IPriceOracle\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"DaiPriceOracle\";\r\n\r\n    // DAI decimals and expected price.\r\n    uint256 constant DECIMALS = 18;\r\n    uint256 constant EXPECTED_PRICE = ONE_DOLLAR / (10 ** DECIMALS);\r\n\r\n    // Parameters used when getting the DAI-USDC price from Curve.\r\n    int128 constant CURVE_DAI_ID = 0;\r\n    int128 constant CURVE_USDC_ID = 1;\r\n    uint256 constant CURVE_FEE_DENOMINATOR = 10 ** 10;\r\n    uint256 constant CURVE_DECIMALS_BASE = 10 ** 30;\r\n\r\n    // Parameters used when getting the DAI-USDC price from Uniswap.\r\n    uint256 constant UNISWAP_DECIMALS_BASE = 10 ** 30;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct PriceInfo {\r\n        uint128 price;\r\n        uint32 lastUpdate;\r\n    }\r\n\r\n    struct DeviationParams {\r\n        uint64 denominator;\r\n        uint64 maximumPerSecond;\r\n        uint64 maximumAbsolute;\r\n    }\r\n\r\n    // ============ Events ============\r\n\r\n    event PriceSet(\r\n        PriceInfo newPriceInfo\r\n    );\r\n\r\n    // ============ Storage ============\r\n\r\n    PriceInfo public g_priceInfo;\r\n\r\n    address public g_poker;\r\n\r\n    DeviationParams public DEVIATION_PARAMS;\r\n\r\n    IErc20 public WETH;\r\n\r\n    IErc20 public DAI;\r\n\r\n    ICurve public CURVE;\r\n\r\n    IUniswapV2Pair public UNISWAP_DAI_ETH;\r\n\r\n    IUniswapV2Pair public UNISWAP_USDC_ETH;\r\n\r\n    // ============ Constructor =============\r\n\r\n    constructor(\r\n        address poker,\r\n        address weth,\r\n        address dai,\r\n        address curve,\r\n        address uniswapDaiEth,\r\n        address uniswapUsdcEth,\r\n        DeviationParams memory deviationParams\r\n    )\r\n        public\r\n    {\r\n        g_poker = poker;\r\n        WETH = IErc20(weth);\r\n        DAI = IErc20(dai);\r\n        CURVE = ICurve(curve);\r\n        UNISWAP_DAI_ETH = IUniswapV2Pair(uniswapDaiEth);\r\n        UNISWAP_USDC_ETH = IUniswapV2Pair(uniswapUsdcEth);\r\n        DEVIATION_PARAMS = deviationParams;\r\n        g_priceInfo = PriceInfo({\r\n            lastUpdate: uint32(block.timestamp),\r\n            price: uint128(EXPECTED_PRICE)\r\n        });\r\n    }\r\n\r\n    // ============ Admin Functions ============\r\n\r\n    function ownerSetPokerAddress(\r\n        address newPoker\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        g_poker = newPoker;\r\n    }\r\n\r\n    // ============ Public Functions ============\r\n\r\n    function updatePrice(\r\n        Monetary.Price memory minimum,\r\n        Monetary.Price memory maximum\r\n    )\r\n        public\r\n        returns (PriceInfo memory)\r\n    {\r\n        Require.that(\r\n            msg.sender == g_poker,\r\n            FILE,\r\n            \"Only poker can call updatePrice\",\r\n            msg.sender\r\n        );\r\n\r\n        Monetary.Price memory newPrice = getBoundedTargetPrice();\r\n\r\n        Require.that(\r\n            newPrice.value >= minimum.value,\r\n            FILE,\r\n            \"newPrice below minimum\",\r\n            newPrice.value,\r\n            minimum.value\r\n        );\r\n\r\n        Require.that(\r\n            newPrice.value <= maximum.value,\r\n            FILE,\r\n            \"newPrice above maximum\",\r\n            newPrice.value,\r\n            maximum.value\r\n        );\r\n\r\n        g_priceInfo = PriceInfo({\r\n            price: Math.to128(newPrice.value),\r\n            lastUpdate: Time.currentTime()\r\n        });\r\n\r\n        emit PriceSet(g_priceInfo);\r\n        return g_priceInfo;\r\n    }\r\n\r\n    // ============ IPriceOracle Functions ============\r\n\r\n    function getPrice(\r\n        address /* token */\r\n    )\r\n        public\r\n        view\r\n        returns (Monetary.Price memory)\r\n    {\r\n        return Monetary.Price({\r\n            value: g_priceInfo.price\r\n        });\r\n    }\r\n\r\n    // ============ Price-Query Functions ============\r\n\r\n    /**\r\n     * Get the new price that would be stored if updated right now.\r\n     */\r\n    function getBoundedTargetPrice()\r\n        public\r\n        view\r\n        returns (Monetary.Price memory)\r\n    {\r\n        Monetary.Price memory targetPrice = getTargetPrice();\r\n\r\n        PriceInfo memory oldInfo = g_priceInfo;\r\n        uint256 timeDelta = uint256(Time.currentTime()).sub(oldInfo.lastUpdate);\r\n        (uint256 minPrice, uint256 maxPrice) = getPriceBounds(oldInfo.price, timeDelta);\r\n        uint256 boundedTargetPrice = boundValue(targetPrice.value, minPrice, maxPrice);\r\n\r\n        return Monetary.Price({\r\n            value: boundedTargetPrice\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the DAI-USDC price that this contract will move towards when updated. This price is\r\n     * not bounded by the variables governing the maximum deviation from the old price.\r\n     */\r\n    function getTargetPrice()\r\n        public\r\n        view\r\n        returns (Monetary.Price memory)\r\n    {\r\n        uint256 targetPrice = getMidValue(\r\n            EXPECTED_PRICE,\r\n            getCurvePrice(),\r\n            getUniswapPrice()\r\n        );\r\n\r\n        return Monetary.Price({\r\n            value: targetPrice\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the DAI-USDC price according to Curve.\r\n     *\r\n     * @return  The DAI-USDC price in natural units as a fixed-point number with 18 decimals.\r\n     */\r\n    function getCurvePrice()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        ICurve curve = CURVE;\r\n\r\n        // Get dy when dx = 1, i.e. the number of DAI base units we can buy for 1 USDC base unit.\r\n        //\r\n        // After accounting for the fee, this is a very good estimate of the spot price.\r\n        uint256 dyWithFee = curve.get_dy(CURVE_USDC_ID, CURVE_DAI_ID, 1);\r\n        uint256 fee = curve.fee();\r\n        uint256 dyWithoutFee = dyWithFee.mul(CURVE_FEE_DENOMINATOR).div(\r\n            CURVE_FEE_DENOMINATOR.sub(fee)\r\n        );\r\n\r\n        // Note that dy is on the order of 10^12 due to the difference in DAI and USDC base units.\r\n        // We divide 10^30 by dy to get the price of DAI in USDC with 18 decimals of precision.\r\n        return CURVE_DECIMALS_BASE.div(dyWithoutFee);\r\n    }\r\n\r\n    /**\r\n     * Get the DAI-USDC price according to Uniswap.\r\n     *\r\n     * @return  The DAI-USDC price in natural units as a fixed-point number with 18 decimals.\r\n     */\r\n    function getUniswapPrice()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Note: Depending on the pool used, ETH may be the first asset or the second asset.\r\n        (uint256 daiAmt, uint256 poolOneEthAmt, ) = UNISWAP_DAI_ETH.getReserves();\r\n        (uint256 usdcAmt, uint256 poolTwoEthAmt, ) = UNISWAP_USDC_ETH.getReserves();\r\n\r\n        // Get the price of DAI in USDC. Multiply by 10^30 to account for the difference in decimals\r\n        // between DAI and USDC, and get a result with 18 decimals of precision.\r\n        //\r\n        // Note: There is a risk for overflow depending on the assets used and size of the pools.\r\n        return UNISWAP_DECIMALS_BASE\r\n            .mul(usdcAmt)\r\n            .mul(poolOneEthAmt)\r\n            .div(poolTwoEthAmt)\r\n            .div(daiAmt);\r\n    }\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function getPriceBounds(\r\n        uint256 oldPrice,\r\n        uint256 timeDelta\r\n    )\r\n        private\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        DeviationParams memory deviation = DEVIATION_PARAMS;\r\n\r\n        uint256 maxDeviation = Math.getPartial(\r\n            oldPrice,\r\n            Math.min(deviation.maximumAbsolute, timeDelta.mul(deviation.maximumPerSecond)),\r\n            deviation.denominator\r\n        );\r\n\r\n        return (\r\n            oldPrice.sub(maxDeviation),\r\n            oldPrice.add(maxDeviation)\r\n        );\r\n    }\r\n\r\n    function getMidValue(\r\n        uint256 valueA,\r\n        uint256 valueB,\r\n        uint256 valueC\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 maximum = Math.max(valueA, Math.max(valueB, valueC));\r\n        if (maximum == valueA) {\r\n            return Math.max(valueB, valueC);\r\n        }\r\n        if (maximum == valueB) {\r\n            return Math.max(valueA, valueC);\r\n        }\r\n        return Math.max(valueA, valueB);\r\n    }\r\n\r\n    function boundValue(\r\n        uint256 value,\r\n        uint256 minimum,\r\n        uint256 maximum\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(minimum <= maximum);\r\n        return Math.max(minimum, Math.min(maximum, value));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newPoker\",\"type\":\"address\"}],\"name\":\"ownerSetPokerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBoundedTargetPrice\",\"outputs\":[{\"components\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEVIATION_PARAMS\",\"outputs\":[{\"name\":\"denominator\",\"type\":\"uint64\"},{\"name\":\"maximumPerSecond\",\"type\":\"uint64\"},{\"name\":\"maximumAbsolute\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNISWAP_USDC_ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNISWAP_DAI_ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniswapPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CURVE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"components\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_DOLLAR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurvePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"g_poker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"minimum\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"maximum\",\"type\":\"tuple\"}],\"name\":\"updatePrice\",\"outputs\":[{\"components\":[{\"name\":\"price\",\"type\":\"uint128\"},{\"name\":\"lastUpdate\",\"type\":\"uint32\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"g_priceInfo\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint128\"},{\"name\":\"lastUpdate\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTargetPrice\",\"outputs\":[{\"components\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"poker\",\"type\":\"address\"},{\"name\":\"weth\",\"type\":\"address\"},{\"name\":\"dai\",\"type\":\"address\"},{\"name\":\"curve\",\"type\":\"address\"},{\"name\":\"uniswapDaiEth\",\"type\":\"address\"},{\"name\":\"uniswapUsdcEth\",\"type\":\"address\"},{\"components\":[{\"name\":\"denominator\",\"type\":\"uint64\"},{\"name\":\"maximumPerSecond\",\"type\":\"uint64\"},{\"name\":\"maximumAbsolute\",\"type\":\"uint64\"}],\"name\":\"deviationParams\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"name\":\"price\",\"type\":\"uint128\"},{\"name\":\"lastUpdate\",\"type\":\"uint32\"}],\"indexed\":false,\"name\":\"newPriceInfo\",\"type\":\"tuple\"}],\"name\":\"PriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DaiPriceOracle","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000500dd93a74dbfa65a4eeda44da489adcef530cb9000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000a5407eae9ba41422680e2e00537571bcc53efbfd000000000000000000000000a478c2975ab1ea89e8196811f51a7b7ade33eb11000000000000000000000000b4e16d0168e52d35cacd2c6185b44281ec28c9dc0000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000005af3107a4000000000000000000000000000000000000000000000000000002386f26fc10000","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7bf6c64cf0f74ec018a46333d57ee84cbe711090efd4f53ff53e45ac83384cb2"}]}