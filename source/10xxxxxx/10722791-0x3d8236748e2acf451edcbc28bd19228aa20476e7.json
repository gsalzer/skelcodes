{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\n/**\\n * @title ERC20\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 {\\n  uint256 public totalSupply;\\n\\n  function balanceOf(address who) public view returns (uint256);\\n  function transfer(address to, uint256 value) public returns (bool);\\n  function allowance(address owner, address spender) public view returns (uint256);\\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\\n  function approve(address spender, uint256 value) public returns (bool);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"},\"TimeLockedWallet.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\ncontract TimeLockedWallet {\\n\\n    address public architect;\\n    address public owner;\\n    uint public unlockDate;\\n    uint public createdAt;\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function TimeLockedWallet(\\n        address _architect,\\n        address _owner,\\n        uint _unlockDate\\n    ) public {\\n        architect = _architect;\\n        owner = _owner;\\n        unlockDate = _unlockDate;\\n        createdAt = now;\\n    }\\n\\n    // keep all the Ether sent to this address\\n    function() payable public { \\n        Received(msg.sender, msg.value);\\n    }\\n\\n    function topup() payable public {\\n        Received(msg.sender, msg.value);    \\n    }\\n\\n    // callable by owner only, after specified time\\n    function withdraw() onlyOwner public {\\n       require(now \\u003e= unlockDate);\\n       //now send all the balance\\n       msg.sender.transfer(this.balance);\\n       Withdrew(msg.sender, this.balance);\\n    }\\n\\n    // callable by owner only, after specified time, ony for Tokens implementing ERC20\\n    function withdrawTokens(address _tokenContract) onlyOwner public {\\n       require(now \\u003e= unlockDate);\\n       ERC20 token = ERC20(_tokenContract);\\n       //now send all the token balance\\n       uint tokenBalance = token.balanceOf(this);\\n       token.transfer(owner, tokenBalance);\\n       WithdrewTokens(_tokenContract, msg.sender, tokenBalance);\\n    }\\n\\n    function info() public view returns(address, address, uint, uint, uint) {\\n        return (architect, owner, unlockDate, createdAt, this.balance);\\n    }\\n\\n    event Received(address from, uint amount);\\n    event Withdrew(address to, uint amount);\\n    event WithdrewTokens(address tokenContract, address to, uint amount);\\n}\\n\"},\"TimeLockedWalletFactory.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./TimeLockedWallet.sol\\\";\\n\\ncontract TimeLockedWalletFactory {\\n \\n    mapping(address =\\u003e address[]) wallets;\\n\\n    function getWallets(address _user) \\n        public\\n        view\\n        returns(address[])\\n    {\\n        return wallets[_user];\\n    }\\n\\n    function newTimeLockedWallet(address _owner, uint _unlockDate)\\n        payable\\n        public\\n        returns(address wallet)\\n    {\\n        // Create new wallet.\\n        wallet = new TimeLockedWallet(msg.sender, _owner, _unlockDate);\\n        \\n        // Add wallet to sender\\u0027s wallets.\\n        wallets[msg.sender].push(wallet);\\n\\n        // If owner is the same as sender then add wallet to sender\\u0027s wallets too.\\n        if(msg.sender != _owner){\\n            wallets[_owner].push(wallet);\\n        }\\n\\n        // Send ether from this transaction to the created contract.\\n        wallet.transfer(msg.value);\\n\\n        // Emit event.\\n        Created(wallet, msg.sender, _owner, now, _unlockDate, msg.value);\\n    }\\n\\n//TODO: add to blog\\n    // Prevents accidental sending of ether to the factory\\n    function () public {\\n        revert();\\n    }\\n\\n    event Created(address wallet, address from, address to, uint createdAt, uint unlockDate, uint amount);\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_unlockDate\",\"type\":\"uint256\"}],\"name\":\"newTimeLockedWallet\",\"outputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"createdAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"}]","ContractName":"TimeLockedWalletFactory","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f469457ceccd85e50ce23591cd2a701013b73918c8f36374bc8818a794b8cdc5"}]}