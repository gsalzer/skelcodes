{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(_owner);\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// Util functions imported in OnChainSDK for caller to use.\r\nlibrary utils {\r\n    uint constant UINT256MAX = ~uint(0);\r\n\r\n    // A decimal byte to uint. Return value of 10 indicating invalid input.\r\n    function byte2Uint(byte b) internal pure returns(uint8) {\r\n        if (b >= '0' && b <= '9') {\r\n            return uint8(b) - 48;  // '0'\r\n        }\r\n        // Indicating invalid input.\r\n        return 10;\r\n    }\r\n    // Return value of 16 indicating invalid input.\r\n    function hexByte2Uint(byte b) internal pure returns(uint8) {\r\n        if (b >= '0' && b <= '9') {\r\n            return uint8(b) - 48;  // '0'\r\n        } else if (b >= 'A' && b <= 'F') {\r\n            return uint8(b) - 55;\r\n        } else if (b >= 'a' && b <= 'f') {\r\n            return uint8(b) - 87;\r\n        }\r\n        // Indicating invalid input.\r\n        return 16;\r\n    }\r\n\r\n    /// StringToXXX helpers.\r\n\r\n    // A decimal string (charset c in [0-9]) to uint. Like atoi(),\r\n    // 1. processing stops once encountering character not in charset c.\r\n    // 2. returns UINT256MAX when overflow.\r\n    function str2Uint(string memory a) internal pure returns(uint) {\r\n        bytes memory b = bytes(a);\r\n        uint res = 0;\r\n        for (uint i = 0; i < b.length; i++) {\r\n            uint8 tmp = byte2Uint(b[i]);\r\n            if (tmp >= 10) {\r\n                return res;\r\n            } else {\r\n                // Overflow.\r\n                if (res >= UINT256MAX / 10) {\r\n                    return UINT256MAX;\r\n                }\r\n                res = res * 10 + tmp;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // Hex string (charset c in [0-9A-Za-z]) to uint. Like atoi(),\r\n    // 1. processing stops once encountering character not in charset c.\r\n    // 2. returns UINT256MAX when overflow.\r\n    function hexStr2Uint(string memory a) internal pure returns(uint) {\r\n        bytes memory b = bytes(a);\r\n        uint res = 0;\r\n        uint i = 0;\r\n        if (b.length >= 2 && b[0] == '0' && (b[1] == 'x' || b[1] == 'X')) {\r\n            i += 2;\r\n        }\r\n        for (; i < b.length; i++) {\r\n            uint tmp = hexByte2Uint(b[i]);\r\n            if (tmp >= 16) {\r\n                return res;\r\n            } else {\r\n                // Overflow.\r\n                if (res >= UINT256MAX / 16) {\r\n                    return UINT256MAX;\r\n                }\r\n                res = res * 16 + tmp;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // Input: 20-byte hex string without or with 0x/0X prefix (40 characters or 42 characters)\r\n    // Example: '0x0e7ad63d2a305a7b9f46541c386aafbd2af6b263' => address(0x0e7ad63d2a305a7b9f46541c386aafbd2af6b263)\r\n    // address is of uint160.\r\n    function str2Addr(string memory a) internal pure returns(address) {\r\n        bytes memory b = bytes(a);\r\n        require(b.length == 40 || b.length == 42, \"Invalid input, should be 20-byte hex string\");\r\n        uint i = 0;\r\n        if (b.length == 42) {\r\n            i += 2;\r\n        }\r\n\r\n        uint160 res = 0;\r\n        for (; i < b.length; i += 2) {\r\n            res *= 256;\r\n\r\n            uint160 b1 = uint160(hexByte2Uint(b[i]));\r\n            uint160 b2 = uint160(hexByte2Uint(b[i+1]));\r\n            require(b1 < 16 && b2 < 16, \"address string with invalid character\");\r\n\r\n            res += b1 * 16 + b2;\r\n        }\r\n        return address(res);\r\n    }\r\n\r\n    /// XXXToString() helpers.\r\n\r\n    // Example: 12 -> 'c' (without 0x/0X prefix).\r\n    function uint2HexStr(uint x) internal pure returns(string memory) {\r\n        if (x == 0) return '0';\r\n\r\n        uint j = x;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 16;\r\n        }\r\n\r\n        bytes memory b = new bytes(len);\r\n        uint k = len - 1;\r\n        while (x != 0) {\r\n            uint8 curr = uint8(x & 0xf);\r\n            b[k--] = curr > 9 ? byte(55 + curr) : byte(48 + curr);\r\n            x /= 16;\r\n        }\r\n        return string(b);\r\n    }\r\n\r\n    // Example: 12 -> \"12\"\r\n    function uint2Str(uint x) internal pure returns(string memory) {\r\n        if (x == 0) return '0';\r\n\r\n        uint j = x;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n\r\n        bytes memory b = new bytes(len);\r\n        uint k = len - 1;\r\n        while (x != 0) {\r\n            b[k--] = byte(uint8(48 + x % 10));\r\n            x /= 10;\r\n        }\r\n        return string(b);\r\n    }\r\n\r\n    // Example: address(0x0e7ad63d2a305a7b9f46541c386aafbd2af6b263) => '0x0e7ad63d2a305a7b9f46541c386aafbd2af6b263'\r\n    function addr2Str(address _addr) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory charset = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = charset[uint8(value[i + 12] >> 4)];\r\n            str[3+i*2] = charset[uint8(value[i + 12] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    /// bytes/string helpers.\r\n\r\n    function bytesConcat(bytes memory a, bytes memory b) internal pure returns(bytes memory) {\r\n        bytes memory concated = new bytes(a.length + b.length);\r\n        uint i = 0;\r\n        uint k = 0;\r\n        while (i < a.length) { concated[k++] = a[i++]; }\r\n        i = 0;\r\n        while(i < b.length) { concated[k++] = b[i++]; }\r\n        return concated;\r\n    }\r\n\r\n    function strConcat(string memory a, string memory b) internal pure returns(string memory) {\r\n        bytes memory aa = bytes(a);\r\n        bytes memory bb = bytes(b);\r\n        return string(bytesConcat(aa, bb));\r\n    }\r\n\r\n    function bytesCompare(bytes memory a, bytes memory b) internal pure returns(int) {\r\n        uint len = a.length < b.length ? a.length : b.length;\r\n        for (uint i = 0; i < len; i++) {\r\n            if (a[i] < b[i]) {\r\n                return -1;\r\n            } else if (a[i] > b[i]) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (a.length < b.length) {\r\n            return -1;\r\n        } else if (a.length > b.length) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // \"abd\" > \"abcde\"\r\n    function strCompare(string memory a, string memory b) internal pure returns(int) {\r\n        bytes memory aa = bytes(a);\r\n        bytes memory bb = bytes(b);\r\n        return bytesCompare(aa, bb);\r\n    }\r\n\r\n    function bytesEqual(bytes memory a, bytes memory b) internal pure returns(bool) {\r\n        return (a.length == b.length) && (bytesCompare(a, b) == 0);\r\n    }\r\n\r\n    function strEqual(string memory a, string memory b) internal pure returns(bool) {\r\n        bytes memory aa = bytes(a);\r\n        bytes memory bb = bytes(b);\r\n        return bytesEqual(aa, bb);\r\n    }\r\n\r\n    // Return the index of needle's first occurrance in haystack. Return value\r\n    // of -1 indicating no occurrance.\r\n    // Useful in case of parsing float string \"123.45\".\r\n    // Example:\r\n    //   indexOf('123', '') => 0\r\n    //   indexOf('', '45') => -1\r\n    //   indexOf('123', '1234') => -1\r\n    //   indexOf('123.45', '.') => 3\r\n    function indexOf(string memory haystack, string memory needle) internal pure returns(int) {\r\n        bytes memory b_haystack = bytes(haystack);\r\n        bytes memory b_needle = bytes(needle);\r\n        return indexOf(b_haystack, b_needle);\r\n    }\r\n\r\n    function indexOf(bytes memory haystack, bytes memory needle) internal pure returns(int) {\r\n        if (needle.length == 0) {\r\n            return 0;\r\n        } else if (haystack.length < needle.length) {\r\n            return -1;\r\n        }\r\n        // Instead of O(haystack.length x needle.length), saving gas using KMP:\r\n        // O(haystack.length + needle.length)\r\n        uint[] memory pi = new uint[](needle.length + 1);\r\n        pi[1] = 0;\r\n        uint k = 0;\r\n        uint q = 0;\r\n        // KMP pre-processing\r\n        for(q = 2; q <= needle.length; q++) {\r\n            while(k > 0 && needle[k] != needle[q-1]) {\r\n                k = pi[k];\r\n            }\r\n            if(needle[k] == needle[q-1]) {\r\n                k++;\r\n            }\r\n            pi[q] = k;\r\n        }\r\n        // KMP matching\r\n        q = 0;\r\n        for(uint i = 0; i < haystack.length; i++) {\r\n            while(q > 0 && needle[q] != haystack[i]) {\r\n                q = pi[q];\r\n            }\r\n            if(needle[q] == haystack[i]) {\r\n                q++;\r\n            }\r\n            // Match\r\n            if(q == needle.length) {\r\n                return int(i - q + 1);\r\n            }\r\n        }\r\n        // No match\r\n        return -1;\r\n    }\r\n\r\n    // subStr(\"1234567890\", 2, 5) => \"34567\"\r\n    // [start, start + len), index starting from 0.\r\n    function subStr(bytes memory a, uint start, uint len) internal pure returns(bytes memory) {\r\n        require(start < a.length && start + len > start && start + len <= a.length,\r\n                \"Invalid start index or length out of range\");\r\n        bytes memory res = new bytes(len);\r\n        for (uint i = 0; i < len; i++) {\r\n            res[i] = a[start + i];\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // string num = \"123.4567\";\r\n    // subStr(num, indexOf(num, '.') + 1) => \"4567\"\r\n    function subStr(bytes memory a, uint start) internal pure returns(bytes memory) {\r\n        require(start < a.length, \"Invalid start index out of range\");\r\n        return subStr(a, start, a.length - start);\r\n    }\r\n\r\n    function subStr(string memory a, uint start, uint len) internal pure returns(string memory) {\r\n        bytes memory aa = bytes(a);\r\n        return string(subStr(aa, start, len));\r\n    }\r\n\r\n    function subStr(string memory a, uint start) internal pure returns(string memory) {\r\n        bytes memory aa = bytes(a);\r\n        return string(subStr(aa, start));\r\n    }\r\n}\r\n\r\ncontract DOSProxyInterface {\r\n    function query(address, uint, string memory, string memory) public returns (uint);\r\n    function requestRandom(address, uint) public returns (uint);\r\n}\r\n\r\ncontract DOSPaymentInterface {\r\n    function setPaymentMethod(address payer, address tokenAddr) public;\r\n    function defaultTokenAddr() public returns(address);\r\n}\r\n\r\ncontract DOSAddressBridgeInterface {\r\n    function getProxyAddress() public view returns (address);\r\n    function getPaymentAddress() public view returns (address);\r\n}\r\n\r\ncontract ERC20I {\r\n    function balanceOf(address who) public view returns (uint);\r\n    function transfer(address to, uint value) public returns (bool);\r\n    function approve(address spender, uint value) public returns (bool);\r\n}\r\n\r\ncontract DOSOnChainSDK is Ownable {\r\n    // Comment out utils library if you don't need it to save gas. (L4 and L30)\r\n    // using utils for *;\r\n\r\n    DOSProxyInterface dosProxy;\r\n    DOSAddressBridgeInterface dosAddrBridge =\r\n        DOSAddressBridgeInterface(0x98A0E7026778840Aacd28B9c03137D32e06F5ff1);\r\n\r\n    modifier resolveAddress {\r\n        dosProxy = DOSProxyInterface(dosAddrBridge.getProxyAddress());\r\n        _;\r\n    }\r\n\r\n    modifier auth {\r\n        // Filter out malicious __callback__ caller.\r\n        require(msg.sender == dosAddrBridge.getProxyAddress(), \"Unauthenticated response\");\r\n        _;\r\n    }\r\n\r\n    // @dev: call setup function first and transfer DOS tokens into deployed contract as oracle fees.\r\n    function DOSSetup() public onlyOwner {\r\n        address paymentAddr = dosAddrBridge.getPaymentAddress();\r\n        address defaultToken = DOSPaymentInterface(dosAddrBridge.getPaymentAddress()).defaultTokenAddr();\r\n        ERC20I(defaultToken).approve(paymentAddr, uint(-1));\r\n        DOSPaymentInterface(dosAddrBridge.getPaymentAddress()).setPaymentMethod(address(this), defaultToken);\r\n    }\r\n\r\n    // @dev: refund all unused fees to caller.\r\n    function DOSRefund() public onlyOwner {\r\n        address token = DOSPaymentInterface(dosAddrBridge.getPaymentAddress()).defaultTokenAddr();\r\n        uint amount = ERC20I(token).balanceOf(address(this));\r\n        ERC20I(token).transfer(msg.sender, amount);\r\n    }\r\n\r\n    // @dev: Call this function to get a unique queryId to differentiate\r\n    //       parallel requests. A return value of 0x0 stands for error and a\r\n    //       related event would be emitted.\r\n    // @timeout: Estimated timeout in seconds specified by caller; e.g. 15.\r\n    //           Response is not guaranteed if processing time exceeds this.\r\n    // @dataSource: Data source destination specified by caller.\r\n    //              E.g.: 'https://api.coinbase.com/v2/prices/ETH-USD/spot'\r\n    // @selector: A selector expression provided by caller to filter out\r\n    //            specific data fields out of the raw response. The response\r\n    //            data format (json, xml/html, and more) is identified from\r\n    //            the selector expression.\r\n    //            E.g. Use \"$.data.amount\" to extract \"194.22\" out.\r\n    //             {\r\n    //                  \"data\":{\r\n    //                          \"base\":\"ETH\",\r\n    //                          \"currency\":\"USD\",\r\n    //                          \"amount\":\"194.22\"\r\n    //                  }\r\n    //             }\r\n    //            Check below documentation for details.\r\n    //            (https://dosnetwork.github.io/docs/#/contents/blockchains/ethereum?id=selector).\r\n    function DOSQuery(uint timeout, string memory dataSource, string memory selector)\r\n        internal\r\n        resolveAddress\r\n        returns (uint)\r\n    {\r\n        return dosProxy.query(address(this), timeout, dataSource, selector);\r\n    }\r\n\r\n    // @dev: Must override __callback__ to process a corresponding response. A\r\n    //       user-defined event could be added to notify the Dapp frontend that\r\n    //       the response is ready.\r\n    // @queryId: A unique queryId returned by DOSQuery() for callers to\r\n    //           differentiate parallel responses.\r\n    // @result: Response for the specified queryId.\r\n    function __callback__(uint queryId, bytes calldata result) external {\r\n        // To be overridden in the caller contract.\r\n    }\r\n\r\n    // @dev: Call this function to request either a fast but insecure random\r\n    //       number or a safe and secure random number delivered back\r\n    //       asynchronously through the __callback__ function.\r\n    //       Depending on the mode, the return value would be a random number\r\n    //       (for fast mode) or a requestId (for safe mode).\r\n    // @seed: Optional random seed provided by caller.\r\n    function DOSRandom(uint seed)\r\n        internal\r\n        resolveAddress\r\n        returns (uint)\r\n    {\r\n        return dosProxy.requestRandom(address(this), seed);\r\n    }\r\n\r\n    // @dev: Must override __callback__ to process a corresponding random\r\n    //       number. A user-defined event could be added to notify the Dapp\r\n    //       frontend that a new secure random number is generated.\r\n    // @requestId: A unique requestId returned by DOSRandom() for requester to\r\n    //             differentiate random numbers generated concurrently.\r\n    // @generatedRandom: Generated secure random number for the specific\r\n    //                   requestId.\r\n    function __callback__(uint requestId, uint generatedRandom) external auth {\r\n        // To be overridden in the caller contract.\r\n    }\r\n}\r\n\r\n\r\n// An example get latest ETH-USD price from Coinbase\r\ncontract CoinbaseEthPriceFeed is DOSOnChainSDK {\r\n    using utils for *;\r\n\r\n    // Struct to hold parsed floating string \"123.45\"\r\n    struct ethusd {\r\n        uint integral;\r\n        uint fractional;\r\n    }\r\n    uint queryId;\r\n    string public price_str;\r\n    ethusd public price;\r\n\r\n    event GetPrice(uint integral, uint fractional);\r\n\r\n    constructor() public {\r\n        // @dev: setup and then transfer DOS tokens into deployed contract\r\n        // as oracle fees.\r\n        // Unused fees can be reclaimed by calling DOSRefund() in the SDK.\r\n        super.DOSSetup();\r\n    }\r\n\r\n    function getEthUsdPrice() public {\r\n        queryId = DOSQuery(30, \"https://api.coinbase.com/v2/prices/ETH-USD/spot\", \"$.data.amount\");\r\n    }\r\n\r\n    function __callback__(uint id, bytes calldata result) external auth {\r\n        require(queryId == id, \"Unmatched response\");\r\n\r\n        price_str = string(result);\r\n        price.integral = price_str.subStr(1).str2Uint();\r\n        int delimit_idx = price_str.indexOf('.');\r\n        if (delimit_idx != -1) {\r\n            price.fractional = price_str.subStr(uint(delimit_idx + 1)).str2Uint();\r\n        }\r\n        emit GetPrice(price.integral, price.fractional);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"integral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fractional\",\"type\":\"uint256\"}],\"name\":\"GetPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"DOSRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"DOSSetup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generatedRandom\",\"type\":\"uint256\"}],\"name\":\"__callback__\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"__callback__\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getEthUsdPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"integral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fractional\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price_str\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CoinbaseEthPriceFeed","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f22a0d69483bd63e09877bba8f73de7c2259a0c2a7103df168d1efe3a0ac28c9"}]}