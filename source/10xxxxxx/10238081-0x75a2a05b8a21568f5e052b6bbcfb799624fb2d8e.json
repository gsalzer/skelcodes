{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n\r\n// This is the smart contract for FiatDex protocol version 2\r\n// Anyone can use this smart contract to exchange Fiat for DAI or vice-versa without trusting the counterparty\r\n// The goal of the FiatDex protocol is to remove the dependence on fiat to crypto gatekeepers for those who want to trade cryptocurrency\r\n// There are no arbitrators or third party custodians. Collateral is used as leverage on the traders.\r\n\r\n//Abstract ERC20 contract\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);  \r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n  function balanceOf(address who) public constant returns (uint);\r\n  function allowance(address owner, address spender) public constant returns (uint);\r\n\r\n  function transfer(address to, uint value) public returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n  function approve(address spender, uint value) public returns (bool ok);  \r\n}\r\n\r\ncontract FiatDex_protocol_v2 {\r\n\r\n  address public owner; // This is the address of the current owner of the contract, this address collects fees, nothing more, nothing less\r\n  address public daiAddress = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // This is the addresss for the MakerDAO contract\r\n  uint256 public version = 2; // This is the version of the protocol running\r\n\r\n  constructor() public {\r\n    owner = msg.sender; // Set the contract creator to the first owner\r\n  }\r\n\r\n  enum States {\r\n    NOTOPEN, // Default state\r\n    INITIALIZED, // daiTrader has put DAI into the contract\r\n    REFUNDED, // daiTrader has refunded before fiatTrader has put any amount into the swap\r\n    ACTIVE, // fiatTrader has put DAI collateral into the contract\r\n    CLOSED, // daiTrader has finalized the amounts, dai is transferred, collateral returned\r\n    FIATABORT, // fiatTrader has aborted the swap\r\n    DAIABORT // daiTrader has aborted the swap\r\n  }\r\n\r\n  struct Swap {\r\n    States swapState;\r\n    uint256 sendAmount;\r\n    address fiatTrader;\r\n    address daiTrader;\r\n    uint256 openTime;\r\n    uint256 daiTraderCollateral;\r\n    uint256 fiatTraderCollateral;\r\n    uint256 feeAmount;\r\n  }\r\n\r\n  mapping (bytes32 => Swap) private swaps; // Create the swaps map\r\n\r\n  event Open(bytes32 _tradeID, address _fiatTrader, uint256 _sendAmount); // Auxillary events\r\n  event Close(bytes32 _tradeID, uint256 _fee);\r\n  event Canceled(bytes32 _tradeID, uint256 _fee);\r\n  event ChangedOwnership(address _newOwner);\r\n\r\n  // daiTrader can only open swap positions from tradeIDs that haven't already been used\r\n  modifier onlyNotOpenSwaps(bytes32 _tradeID) {\r\n    require (swaps[_tradeID].swapState == States.NOTOPEN);\r\n    _;\r\n  }\r\n\r\n  // fiatTrader can only add collateral to swap positions that have just been opened\r\n  modifier onlyInitializedSwaps(bytes32 _tradeID) {\r\n    require (swaps[_tradeID].swapState == States.INITIALIZED);\r\n    _;\r\n  }\r\n\r\n  // daiTrader is trying to finalize/abort the swap position or fiatTrader is trying to abort, check this first\r\n  modifier onlyActiveSwaps(bytes32 _tradeID) {\r\n    require (swaps[_tradeID].swapState == States.ACTIVE);\r\n    _;\r\n  }\r\n\r\n  // View functions\r\n  function viewSwap(bytes32 _tradeID) public view returns (\r\n    States swapState, \r\n    uint256 sendAmount,\r\n    address daiTrader, \r\n    address fiatTrader, \r\n    uint256 openTime, \r\n    uint256 daiTraderCollateral, \r\n    uint256 fiatTraderCollateral,\r\n    uint256 feeAmount\r\n  ) {\r\n    Swap memory swap = swaps[_tradeID];\r\n    return (swap.swapState, swap.sendAmount, swap.daiTrader, swap.fiatTrader, swap.openTime, swap.daiTraderCollateral, swap.fiatTraderCollateral, swap.feeAmount);\r\n  }\r\n\r\n  function viewFiatDexSpecs() public view returns (\r\n    uint256 _version, \r\n    address _owner\r\n  ) {\r\n    return (version, owner);\r\n  }\r\n\r\n  // Action functions\r\n  function changeContractOwner(address _newOwner) public {\r\n    require (msg.sender == owner); // Only the current owner can change the ownership of the contract\r\n    \r\n    owner = _newOwner; // Update the owner\r\n\r\n     // Trigger ownership change event.\r\n    emit ChangedOwnership(_newOwner);\r\n  }\r\n\r\n  // daiTrader opens the swap position\r\n  function openSwap(bytes32 _tradeID, address _fiatTrader, uint256 _erc20Value) public onlyNotOpenSwaps(_tradeID) {\r\n    ERC20 daiContract = ERC20(daiAddress); // Load the DAI contract\r\n    require (_erc20Value > 0); // Cannot open a swap position with a zero amount of DAI\r\n    require(_erc20Value <= daiContract.allowance(msg.sender, address(this))); // We must transfer less than that we approve in the ERC20 token contract\r\n\r\n    // Calculate some values\r\n    uint256 _sendAmount = (_erc20Value * 2) / 5; // Essentially the same as dividing by 2.5 (or multiplying by 2/5)\r\n    require (_sendAmount > 0); // Fail if the amount is so small that the sendAmount will be non-existant\r\n    uint256 _daiTraderCollateral = _erc20Value - _sendAmount; // Collateral will be whatever is not being sent to fiatTrader\r\n\r\n    // Store the details of the swap.\r\n    Swap memory swap = Swap({\r\n      swapState: States.INITIALIZED,\r\n      sendAmount: _sendAmount,\r\n      daiTrader: msg.sender,\r\n      fiatTrader: _fiatTrader,\r\n      openTime: now,\r\n      daiTraderCollateral: _daiTraderCollateral,\r\n      fiatTraderCollateral: 0,\r\n      feeAmount: 0\r\n    });\r\n    swaps[_tradeID] = swap;\r\n\r\n    // Now transfer the tokens\r\n    require(daiContract.transferFrom(msg.sender, address(this), _erc20Value)); // Now take the tokens from the sending user and store in this contract\r\n\r\n    // Trigger open event.\r\n    emit Open(_tradeID, _fiatTrader, _sendAmount);\r\n  }\r\n\r\n  // fiatTrader adds collateral to the open swap\r\n  function addFiatTraderCollateral(bytes32 _tradeID, uint256 _erc20Value) public onlyInitializedSwaps(_tradeID) {\r\n    Swap storage swap = swaps[_tradeID]; // Get information about the swap position\r\n    require (_erc20Value >= swap.daiTraderCollateral); // Cannot send less than what the daiTrader has in collateral\r\n    require (msg.sender == swap.fiatTrader); // Only the fiatTrader can add to the swap position\r\n    // Check the allowance\r\n    ERC20 daiContract = ERC20(daiAddress); // Load the DAI contract\r\n    require(_erc20Value <= daiContract.allowance(msg.sender, address(this))); // We must transfer less than that we approve in the ERC20 token contract   \r\n    swap.fiatTraderCollateral = _erc20Value;\r\n    swap.swapState = States.ACTIVE; // Now fiatTrader needs to send fiat\r\n\r\n    // Now transfer the tokens\r\n    require(daiContract.transferFrom(msg.sender, address(this), _erc20Value)); // Now take the tokens from the sending user and store in this contract    \r\n  }\r\n\r\n  // daiTrader is refunding as fiatTrader never sent the collateral\r\n  function refundSwap(bytes32 _tradeID) public onlyInitializedSwaps(_tradeID) {\r\n    // Refund the swap.\r\n    Swap storage swap = swaps[_tradeID];\r\n    require (msg.sender == swap.daiTrader); // Only the daiTrader can call this function to refund\r\n    swap.swapState = States.REFUNDED; // Swap is now refunded, sending all DAI back\r\n\r\n    // Transfer the DAI value from this contract back to the DAI trader.\r\n    ERC20 daiContract = ERC20(daiAddress); // Load the DAI contract\r\n    require(daiContract.transfer(swap.daiTrader, swap.sendAmount + swap.daiTraderCollateral));\r\n\r\n     // Trigger cancel event.\r\n    emit Canceled(_tradeID, 0);\r\n  }\r\n\r\n  // daiTrader is aborting as fiatTrader failed to hold up its part of the swap\r\n  // Aborting refunds the sendAmount to daiTrader but returns part of the collateral based on the penalty\r\n  // Penalty must be between 75-100%\r\n  function diaTraderAbort(bytes32 _tradeID, uint256 penaltyPercent) public onlyActiveSwaps(_tradeID) {\r\n    // diaTrader aborted the swap.\r\n    require (penaltyPercent >= 75000 && penaltyPercent <= 100000); // Penalty must be between 75-100%\r\n\r\n    Swap storage swap = swaps[_tradeID];\r\n    require (msg.sender == swap.daiTrader); // Only the daiTrader can call this function to abort\r\n    swap.swapState = States.DAIABORT; // Swap is now aborted\r\n\r\n    // Calculate the penalty amounts\r\n    uint256 penaltyAmount = (swap.daiTraderCollateral * penaltyPercent) / 100000;\r\n    ERC20 daiContract = ERC20(daiAddress); // Load the DAI contract\r\n    if(penaltyAmount > 0){\r\n      swap.feeAmount = penaltyAmount;\r\n      require(daiContract.transfer(owner, penaltyAmount * 2));\r\n    }   \r\n\r\n    // Transfer the DAI send amount and collateral from this contract back to the DAI trader.\r\n    require(daiContract.transfer(swap.daiTrader, swap.sendAmount + swap.daiTraderCollateral - penaltyAmount));\r\n  \r\n    // Transfer the DAI collateral from this contract back to the fiat trader.\r\n    require(daiContract.transfer(swap.fiatTrader, swap.fiatTraderCollateral - penaltyAmount));\r\n\r\n     // Trigger cancel event.\r\n    emit Canceled(_tradeID, penaltyAmount);\r\n  }\r\n\r\n  // fiatTrader is aborting due to unexpected difficulties sending fiat\r\n  // Aborting refunds the sendAmount to daiTrader but returns part of the collateral based on the penalty\r\n  // Penalty must be between 2.5-100%\r\n  function fiatTraderAbort(bytes32 _tradeID, uint256 penaltyPercent) public onlyActiveSwaps(_tradeID) {\r\n    // fiatTrader aborted the swap.\r\n    require (penaltyPercent >= 2500 && penaltyPercent <= 100000); // Penalty must be between 2.5-100%\r\n\r\n    Swap storage swap = swaps[_tradeID];\r\n    require (msg.sender == swap.fiatTrader); // Only the fiatTrader can call this function to abort\r\n    swap.swapState = States.FIATABORT; // Swap is now aborted\r\n\r\n    // Calculate the penalty amounts\r\n    uint256 penaltyAmount = (swap.daiTraderCollateral * penaltyPercent) / 100000;\r\n    ERC20 daiContract = ERC20(daiAddress); // Load the DAI contract\r\n    if(penaltyAmount > 0){\r\n      swap.feeAmount = penaltyAmount;\r\n      require(daiContract.transfer(owner, penaltyAmount * 2));\r\n    }   \r\n\r\n    // Transfer the DAI send amount and collateral from this contract back to the DAI trader.\r\n    require(daiContract.transfer(swap.daiTrader, swap.sendAmount + swap.daiTraderCollateral - penaltyAmount));\r\n  \r\n    // Transfer the DAI collateral from this contract back to the fiat trader.\r\n    require(daiContract.transfer(swap.fiatTrader, swap.fiatTraderCollateral - penaltyAmount));\r\n\r\n     // Trigger cancel event.\r\n    emit Canceled(_tradeID, penaltyAmount);\r\n  }\r\n\r\n  // daiTrader is completing the swap position as fiatTrader has sent the fiat\r\n  function finalizeSwap(bytes32 _tradeID) public onlyActiveSwaps(_tradeID) {\r\n    // Complete the swap and charge the 1% fee on the sent amount\r\n    Swap storage swap = swaps[_tradeID];\r\n    require (msg.sender == swap.daiTrader); // Only the daiTrader can call this function to close\r\n    swap.swapState = States.CLOSED; // Swap is now closed, sending all ETH, prevent re-entry\r\n\r\n    // Calculate the fee which should be 1%\r\n    uint256 feeAmount = 0; // This is the amount of fee in DAI\r\n    uint256 feePercent = 1000; // For feePercent, 1 = 0.001%, 1000 = 1%\r\n    feeAmount = (swap.sendAmount * feePercent) / 100000;\r\n\r\n    // Transfer all the DAI to the appropriate parties, the owner will get some DAI as a fee\r\n    ERC20 daiContract = ERC20(daiAddress); // Load the DAI contract\r\n    if(feeAmount > 0){\r\n      swap.feeAmount = feeAmount;\r\n      require(daiContract.transfer(owner, swap.feeAmount));\r\n    }\r\n\r\n    // Transfer the DAI collateral from this contract back to the DAI trader.\r\n    require(daiContract.transfer(swap.daiTrader, swap.daiTraderCollateral));\r\n\r\n    // Transfer the DAI collateral back to fiatTrader and the sendAmount from daiTrader minus fee\r\n    require(daiContract.transfer(swap.fiatTrader, swap.sendAmount - feeAmount + swap.fiatTraderCollateral));\r\n\r\n     // Trigger close event showing the fee.\r\n    emit Close(_tradeID, feeAmount);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes32\"}],\"name\":\"finalizeSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes32\"}],\"name\":\"viewSwap\",\"outputs\":[{\"name\":\"swapState\",\"type\":\"uint8\"},{\"name\":\"sendAmount\",\"type\":\"uint256\"},{\"name\":\"daiTrader\",\"type\":\"address\"},{\"name\":\"fiatTrader\",\"type\":\"address\"},{\"name\":\"openTime\",\"type\":\"uint256\"},{\"name\":\"daiTraderCollateral\",\"type\":\"uint256\"},{\"name\":\"fiatTraderCollateral\",\"type\":\"uint256\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"name\":\"penaltyPercent\",\"type\":\"uint256\"}],\"name\":\"diaTraderAbort\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeContractOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"name\":\"_fiatTrader\",\"type\":\"address\"},{\"name\":\"_erc20Value\",\"type\":\"uint256\"}],\"name\":\"openSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"name\":\"penaltyPercent\",\"type\":\"uint256\"}],\"name\":\"fiatTraderAbort\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"name\":\"_erc20Value\",\"type\":\"uint256\"}],\"name\":\"addFiatTraderCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"viewFiatDexSpecs\",\"outputs\":[{\"name\":\"_version\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes32\"}],\"name\":\"refundSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_fiatTrader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_sendAmount\",\"type\":\"uint256\"}],\"name\":\"Open\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"Close\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"Canceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ChangedOwnership\",\"type\":\"event\"}]","ContractName":"FiatDex_protocol_v2","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b5e82394f386b95bd6cfd6e197e96c85fe85d10f86d79ea3418374503967e45d"}]}