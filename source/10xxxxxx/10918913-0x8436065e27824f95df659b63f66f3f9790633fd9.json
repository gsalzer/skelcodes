{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\ncontract MultiOwnable is\r\n    Initializable\r\n{\r\n\r\n    uint public constant GRACE_PERIOD = 14 days;\r\n    uint public constant MINIMUM_DELAY = 1 hours;\r\n    uint public constant MAXIMUM_DELAY = 30 days;\r\n\r\n    struct VoteInfo {\r\n        uint32 timelockFrom;\r\n        uint32 votesCounter;\r\n        uint64 curVote;\r\n        mapping(uint => mapping (address => bool)) isVoted; // [curVote][owner]\r\n    }\r\n    mapping(bytes => VoteInfo) public votes;\r\n\r\n    mapping(address => bool) public  multiOwners;\r\n\r\n    uint public multiOwnersCounter;\r\n\r\n    uint public minVotes = 2;           // initial value\r\n\r\n    uint public delay = MINIMUM_DELAY;  // initial value\r\n\r\n    event QueueVote(address indexed owner, bytes data);\r\n    event TxTimelockStart(bytes data, uint32 start);\r\n    event CancelVote(address indexed owner, bytes data);\r\n    event ExecuteVote(bytes data);\r\n    event NewMinVotes(uint newMinVotes);\r\n    event NewDelay(uint newDelay);\r\n    event MultiOwnerAdded(address indexed newMultiOwner);\r\n    event MultiOwnerRemoved(address indexed exMultiOwner);\r\n\r\n    modifier onlyMultiOwners {\r\n        // hook instead of using huge main modifier\r\n        if (_onlyMultiOwnersCall()) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier _onlyMultiOwnersHelper {\r\n        address account = msg.sender;\r\n        bytes memory data = msg.data;\r\n        require(multiOwners[account], \"Permission denied\");\r\n\r\n        uint curVote = votes[data].curVote;\r\n        uint32 curTimestamp = uint32(block.timestamp);\r\n\r\n        // vote for current call\r\n        if (!votes[data].isVoted[curVote][account]) {\r\n            votes[data].isVoted[curVote][account] = true;\r\n            votes[data].votesCounter++;\r\n            emit QueueVote(account, data);\r\n\r\n            if (votes[data].votesCounter == min(minVotes, multiOwnersCounter)) {\r\n                votes[data].timelockFrom = curTimestamp;\r\n                emit TxTimelockStart(data, curTimestamp);\r\n            }\r\n        }\r\n\r\n        // execute tx\r\n        if (votes[data].votesCounter >= min(minVotes, multiOwnersCounter) &&\r\n            votes[data].timelockFrom + delay <= curTimestamp &&\r\n            votes[data].timelockFrom + delay + GRACE_PERIOD >= curTimestamp\r\n        ){\r\n            // iterate to new vote for this msg.data\r\n            votes[data].votesCounter = 0;\r\n            votes[data].timelockFrom = 0;\r\n            votes[data].curVote++;\r\n            emit ExecuteVote(data);\r\n            _;  // tx execution\r\n        }\r\n    }\r\n\r\n    // ** INITIALIZERS **\r\n\r\n    function initialize() public initializer {\r\n        _addMultiOwner(msg.sender);\r\n    }\r\n\r\n    function initialize(address[] memory _newMultiOwners) public initializer {\r\n        require(_newMultiOwners.length > 0, \"Array lengths have to be greater than zero\");\r\n\r\n        for (uint i = 0; i < _newMultiOwners.length; i++) {\r\n            _addMultiOwner(_newMultiOwners[i]);\r\n        }\r\n    }\r\n\r\n    // ** ONLY_MULTI_OWNERS functions **\r\n\r\n    function addMultiOwner(address _newMultiOwner) public onlyMultiOwners {\r\n        _addMultiOwner(_newMultiOwner);\r\n    }\r\n\r\n    function addMultiOwners(address[] memory _newMultiOwners) public onlyMultiOwners {\r\n        require(_newMultiOwners.length > 0, \"Array lengths have to be greater than zero\");\r\n\r\n        for (uint i = 0; i < _newMultiOwners.length; i++) {\r\n            _addMultiOwner(_newMultiOwners[i]);\r\n        }\r\n    }\r\n\r\n    function removeMultiOwner(address _exMultiOwner) public onlyMultiOwners {\r\n        _removeMultiOwner(_exMultiOwner);\r\n    }\r\n\r\n    function removeMultiOwners(address[] memory _exMultiOwners) public onlyMultiOwners {\r\n        require(_exMultiOwners.length > 0, \"Array lengths have to be greater than zero\");\r\n\r\n        for (uint i = 0; i < _exMultiOwners.length; i++) {\r\n            _removeMultiOwner(_exMultiOwners[i]);\r\n        }\r\n    }\r\n\r\n    function setMinVotes(uint _minVotes) public onlyMultiOwners {\r\n        require(_minVotes > 0, \"MinVotes have to be greater than zero\");\r\n        minVotes = _minVotes;\r\n        emit NewMinVotes(_minVotes);\r\n    }\r\n\r\n    function setDelay(uint _delay) public onlyMultiOwners {\r\n        require(_delay >= MINIMUM_DELAY, \"Delay must exceed minimum delay.\");\r\n        require(_delay <= MAXIMUM_DELAY, \"Delay must not exceed maximum delay.\");\r\n        delay = _delay;\r\n\r\n        emit NewDelay(_delay);\r\n    }\r\n\r\n    function cancelVote(bytes memory _data) public {\r\n        address account = msg.sender;\r\n        require(multiOwners[account], \"Permission denied\");\r\n\r\n        // check vote data\r\n        uint curVote = votes[_data].curVote;\r\n        require(votes[_data].isVoted[curVote][account] && votes[_data].votesCounter > 0, \"Incorrect vote data\");\r\n\r\n        // cancel current vote\r\n        votes[_data].isVoted[curVote][account] = false;\r\n        votes[_data].votesCounter--;    // safe\r\n        emit CancelVote(account, _data);\r\n    }\r\n\r\n    // ** INTERNAL functions **\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function _onlyMultiOwnersCall() internal _onlyMultiOwnersHelper returns (bool success) {\r\n        success = true;\r\n    }\r\n\r\n    function _addMultiOwner(address _newMultiOwner) internal {\r\n        require(!multiOwners[_newMultiOwner], \"The owner has already been added\");\r\n\r\n        // UPD states\r\n        multiOwners[_newMultiOwner] = true;\r\n        multiOwnersCounter++;\r\n\r\n        emit MultiOwnerAdded(_newMultiOwner);\r\n    }\r\n\r\n    function _removeMultiOwner(address _exMultiOwner) internal {\r\n        require(multiOwners[_exMultiOwner], \"This address is not the owner\");\r\n        require(multiOwnersCounter > 1, \"At least one owner required\");\r\n\r\n        // UPD states\r\n        multiOwners[_exMultiOwner] = false;\r\n        multiOwnersCounter--;   // safe\r\n\r\n        emit MultiOwnerRemoved(_exMultiOwner);\r\n    }\r\n\r\n}\r\n\r\n// **INTERFACES**\r\n\r\ninterface IAdminUpgradeabilityProxy {\r\n    function changeAdmin(address newAdmin) external;\r\n    function upgradeTo(address newImplementation) external;\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;\r\n}\r\n\r\n/**\r\n * @title ProxyAdminMultisig\r\n * @dev This contract is the admin of a proxy, and is in charge\r\n * of upgrading it as well as transferring it to another admin.\r\n */\r\ncontract ProxyAdminMultisig is MultiOwnable {\r\n\r\n    constructor() public {\r\n        address[] memory newOwners = new address[](1);\r\n        newOwners[0] = 0xdAE0aca4B9B38199408ffaB32562Bf7B3B0495fE;\r\n        initialize(newOwners);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation of a proxy.\r\n     * This is needed because only the proxy admin can query it.\r\n     * @return The address of the current implementation of the proxy.\r\n     */\r\n    function getProxyImplementation(IAdminUpgradeabilityProxy proxy) public view returns (address) {\r\n        // We need to manually run the static call since the getter cannot be flagged as view\r\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\r\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\r\n        require(success);\r\n        return abi.decode(returndata, (address));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin of a proxy. Only the admin can query it.\r\n     * @return The address of the current admin of the proxy.\r\n     */\r\n    function getProxyAdmin(IAdminUpgradeabilityProxy proxy) public view returns (address) {\r\n        // We need to manually run the static call since the getter cannot be flagged as view\r\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\r\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\r\n        require(success);\r\n        return abi.decode(returndata, (address));\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of a proxy.\r\n     * @param proxy Proxy to change admin.\r\n     * @param newAdmin Address to transfer proxy administration to.\r\n     */\r\n    function changeProxyAdmin(IAdminUpgradeabilityProxy proxy, address newAdmin) public onlyMultiOwners {\r\n        proxy.changeAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades a proxy to the newest implementation of a contract.\r\n     * @param proxy Proxy to be upgraded.\r\n     * @param implementation the address of the Implementation.\r\n     */\r\n    function upgrade(IAdminUpgradeabilityProxy proxy, address implementation) public onlyMultiOwners {\r\n        proxy.upgradeTo(implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\r\n     * This is useful to initialize the proxied contract.\r\n     * @param proxy Proxy to be upgraded.\r\n     * @param implementation Address of the Implementation.\r\n     * @param data Data to send as msg.data in the low level call.\r\n     * It should include the signature and the parameters of the function to be called, as described in\r\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n     */\r\n    function upgradeAndCall(IAdminUpgradeabilityProxy proxy, address implementation, bytes memory data) public payable  onlyMultiOwners {\r\n        proxy.upgradeToAndCall.value(msg.value)(implementation, data);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"CancelVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ExecuteVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMultiOwner\",\"type\":\"address\"}],\"name\":\"MultiOwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exMultiOwner\",\"type\":\"address\"}],\"name\":\"MultiOwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDelay\",\"type\":\"uint256\"}],\"name\":\"NewDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinVotes\",\"type\":\"uint256\"}],\"name\":\"NewMinVotes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"QueueVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"}],\"name\":\"TxTimelockStart\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMultiOwner\",\"type\":\"address\"}],\"name\":\"addMultiOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newMultiOwners\",\"type\":\"address[]\"}],\"name\":\"addMultiOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"cancelVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAdminUpgradeabilityProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeProxyAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IAdminUpgradeabilityProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IAdminUpgradeabilityProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"getProxyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newMultiOwners\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"multiOwners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiOwnersCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exMultiOwner\",\"type\":\"address\"}],\"name\":\"removeMultiOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_exMultiOwners\",\"type\":\"address[]\"}],\"name\":\"removeMultiOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"setDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minVotes\",\"type\":\"uint256\"}],\"name\":\"setMinVotes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAdminUpgradeabilityProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAdminUpgradeabilityProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"votes\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"timelockFrom\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"votesCounter\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"curVote\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ProxyAdminMultisig","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2490f0e213a4bf6c51acce47d51859d8866a4df2bfa3169e86ed69fc633a68d3"}]}