{"status":"1","message":"OK","result":[{"SourceCode":"{\"rebaseContract.sol\":{\"content\":\"pragma solidity \\u003e=0.4.0 \\u003c0.7.0;\\n\\nimport \\\"./Truample.sol\\\";\\n\\ninterface IOracle {\\n\\n    function getData() external returns (uint256, bool);\\n    \\n}\\n\\n\\ncontract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private initializing;\\n\\n    /**\\n     * @dev Modifier to use in the initializer function of a contract.\\n     */\\n    modifier initializer() {\\n        require(\\n            initializing || isConstructor() || !initialized,\\n            \\\"Contract instance has already been initialized\\\"\\n        );\\n\\n        bool isTopLevelCall = !initializing;\\n        if (isTopLevelCall) {\\n            initializing = true;\\n            initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        address self = address(this);\\n        uint256 cs;\\n        assembly {\\n            cs := extcodesize(self)\\n        }\\n        return cs == 0;\\n    }\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract ContextUpgradeSafe is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {}\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n\\n    function __Ownable_init(address owner_) internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained(owner_);\\n    }\\n\\n    function __Ownable_init_unchained(address owner_) internal initializer {\\n        //address msgSender = _msgSender();\\n        _owner = owner_;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\\n/**\\n * @title Various utilities useful for uint256.\\n */\\nlibrary UInt256Lib {\\n    uint256 private constant MAX_INT256 = ~(uint256(1) \\u003c\\u003c 255);\\n\\n    /**\\n     * @dev Safely converts a uint256 to an int256.\\n     */\\n    function toInt256Safe(uint256 a) internal pure returns (int256) {\\n        require(a \\u003c= MAX_INT256);\\n        return int256(a);\\n    }\\n}\\n\\n\\ncontract rebaseContract is OwnableUpgradeSafe {\\n\\n    using SafeMath for uint256;\\n    using SafeMathInt for int256;\\n    using UInt256Lib for uint256;\\n\\n    uint256 DECIMALS = 18;\\n\\n    // More than this much time must pass between rebase operations.\\n    uint256 public minRebaseTimeIntervalSec;\\n\\n    // Block timestamp of last rebase operation\\n    uint256 public lastRebaseTimestampSec;\\n\\n    IOracle public marketOracle;\\n    Truample public tokenContractAddress;\\n    \\n    //oracle contracts will be disabled till token is listed on exchanges \\n    bool public oracleContractActivation; \\n\\n    uint256 private manualOracleData;\\n    uint256 public lastOracleCallTime;\\n    uint256 public oracelWindowValidUpto;\\n    bool public lastCallRebaseManual;\\n    \\n    struct RebaseLog {\\n        uint256 epoch;\\n        uint256 newOracleData;\\n        int256 oraclePriceDelta;\\n        int256 targetPriceDelta;\\n        uint256 newTargetPrice;\\n        int256 supplyDelta;\\n        uint256 newSupply;\\n        uint256 multiple;\\n    }\\n\\n    uint256 public epoch;\\n    uint256 public rebaseLag;\\n    mapping(uint256 =\\u003e RebaseLog) public rebaseLog;\\n\\n    /**\\n     * @notice Initializes the Contract.\\n     *\\n     * @param _owner is address of owner of contract.\\n     * @param _initialTargetPrice is initial target price of Token. It is of type uint256.\\n     * @param _initialSupply is initial supply of ERC20 toke.\\n     *\\n     * @dev All timing parameters are initialized here.\\n     *      minRebaseTimeIntervalSec = 1 day i.e minimum time between two rebases is atleast 1 day.\\n     *      lastRebaseTimestampSec = 0, Since Contract is initilized here, it is equal to zero. It stores timestamp of last rebase.\\n     *\\n     * @dev This function also initializes rebaseLog[epoch] at epoch = 0.\\n     *\\n     *\\n     */\\n    function initilize(\\n        address _owner,\\n        uint256 _initialTargetPrice,\\n        uint256 _initialSupply,\\n        Truample _tokenAddress\\n        \\n    ) public initializer {\\n        OwnableUpgradeSafe.__Ownable_init(_owner);\\n        epoch = 0;\\n        rebaseLag = 10;\\n        \\n        minRebaseTimeIntervalSec = 1 days;\\n        lastRebaseTimestampSec = 0;\\n        oracelWindowValidUpto = 15 minutes;\\n        tokenContractAddress = _tokenAddress;\\n        oracleContractActivation = false;\\n        lastOracleCallTime = 0;\\n        \\n        rebaseLog[epoch].newTargetPrice = _initialTargetPrice.mul(10**18);\\n        rebaseLog[epoch].newOracleData = _initialTargetPrice.mul(10**18);\\n        rebaseLog[epoch].newSupply = _initialSupply;\\n        rebaseLog[epoch].multiple = _initialTargetPrice;\\n    }\\n\\n    /**\\n     * @notice This is rebase function. Here all time constraints are checked and supplyDelta is computed.     *\\n     */\\n\\n    function rebase() public onlyOwner{\\n\\n        require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) \\u003c now, \\u0027to hurry to call rebase\\u0027);\\n\\n        uint256 _newOracledata;\\n        bool value;\\n\\n        if (oracleContractActivation) {\\n             \\n            (_newOracledata, value) = marketOracle.getData();\\n            require(value);\\n            lastCallRebaseManual = true;\\n\\n        }else {\\n\\n            require(now \\u003c lastOracleCallTime.add(oracelWindowValidUpto), \\u0027oracle window is valid upto 15 minutes after price feed\\u0027);                    \\n            require(manualOracleData != 0,\\u0027oracle data is zero\\u0027);\\n           _newOracledata = manualOracleData;\\n            lastCallRebaseManual = false;            \\n            \\n        }\\n\\n        int256 supplyDeltaToSend = computeSupplyDelta(epoch, _newOracledata);\\n        require(tokenContractAddress.rebase(epoch,supplyDeltaToSend));\\n        lastRebaseTimestampSec = now;\\n        epoch += 1;\\n\\n    }\\n\\n    /**\\n     * @notice This is the main function where supply delta is calculated.\\n     * \\n     * @dev This function should have internal visibility and should be called only from\\n     *      rebase(). \\n     *      The method for calculation of supply delta is as folllows :-\\n     * \\n     */\\n    function computeSupplyDelta(uint256 _epoch, uint256 _newOracleData)\\n        internal\\n        returns (int256)\\n    {\\n        int256 oraclePriceDelta = _newOracleData.toInt256Safe().sub(\\n            rebaseLog[_epoch].newOracleData.toInt256Safe()\\n        );\\n    \\n        int256 targetPriceDelta = (oraclePriceDelta).div(2);\\n        int256 newTargetPrice;\\n        int256 targetToBeAdded;\\n        \\n        int256 multipleDifference = (_newOracleData.toInt256Safe().div(10**18)).sub(rebaseLog[_epoch].multiple.toInt256Safe());\\n        \\n        targetToBeAdded = multipleDifference.mul(500000000000000000);\\n        newTargetPrice = rebaseLog[_epoch].newTargetPrice.toInt256Safe().add(targetToBeAdded);\\n        \\n\\n        int256 supplyDelta = (\\n            rebaseLog[_epoch].newSupply.toInt256Safe().mul(\\n                (_newOracleData.toInt256Safe().sub(newTargetPrice)).mul(100)\\n            )\\n        )\\n            .div(100);\\n\\n        supplyDelta = supplyDelta.div(\\n            (rebaseLag.mul(10**DECIMALS)).toInt256Safe()\\n        );\\n        \\n        int256 newSupply = rebaseLog[_epoch].newSupply.toInt256Safe().add(\\n            supplyDelta\\n        );\\n\\n        RebaseLog memory newLog;\\n        newLog.epoch = _epoch + 1;\\n        newLog.newOracleData = _newOracleData;\\n        newLog.oraclePriceDelta = oraclePriceDelta;\\n        newLog.targetPriceDelta = targetPriceDelta;\\n        newLog.newTargetPrice = uint256(newTargetPrice);\\n        newLog.supplyDelta = supplyDelta;\\n        newLog.newSupply = uint256(newSupply);\\n        newLog.multiple = _newOracleData.div(10**18);\\n\\n        rebaseLog[epoch + 1] = newLog;\\n        return (supplyDelta);\\n    }\\n\\n    /**\\n     * @notice This function is used to reset the timing parameters of contract\\n     */\\n\\n    function setRebaseTimingParameters(\\n        uint256 minRebaseTimeIntervalSec_,\\n        uint256 _oracelWindowValidUpto\\n\\n    ) external onlyOwner {\\n\\n        require(minRebaseTimeIntervalSec_ \\u003e 0);\\n        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\\n        oracelWindowValidUpto = _oracelWindowValidUpto;\\n\\n    }\\n\\n    function setOracleContractAddress (IOracle _address) external onlyOwner returns (bool) {\\n\\n        marketOracle = _address;\\n        return true;\\n        \\n    }\\n\\n    function setOracleContractActivation (bool _value) external onlyOwner returns (bool) {\\n\\n        oracleContractActivation = _value;\\n        return oracleContractActivation;\\n        \\n    }\\n\\n    function setRebasemanually (uint256 _oracleData) external onlyOwner returns (uint256) {\\n        \\n        manualOracleData = _oracleData;\\n        lastOracleCallTime = now;\\n    }\\n\\n}\"},\"Truample.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\n\\ncontract Owned {\\n\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipTransferred(address indexed from, address indexed _to);\\n\\n    constructor(address _owner) public {\\n        owner = _owner;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOwner) external onlyOwner {\\n        newOwner = _newOwner;\\n    }\\n    function acceptOwnership() external {\\n        require(msg.sender == newOwner);\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n        newOwner = address(0);\\n    }\\n}\\n\\ncontract Pausable is Owned {\\n    event Pause();\\n    event Unpause();\\n\\n    bool public paused = false;\\n\\n    modifier whenNotPaused() {\\n      require(!paused);\\n      _;\\n    }\\n\\n    modifier whenPaused() {\\n      require(paused);\\n      _;\\n    }\\n\\n    function pause() onlyOwner whenNotPaused external {\\n      paused = true;\\n      emit Pause();\\n    }\\n\\n    function unpause() onlyOwner whenPaused external {\\n      paused = false;\\n      emit Unpause();\\n    }\\n}\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n\\n}\\n\\n/**\\n * @title SafeMathInt\\n * @dev Math operations for int256 with overflow safety checks.\\n */\\nlibrary SafeMathInt {\\n    int256 private constant MIN_INT256 = int256(1) \\u003c\\u003c 255;\\n    int256 private constant MAX_INT256 = ~(int256(1) \\u003c\\u003c 255);\\n\\n    /**\\n     * @dev Multiplies two int256 variables and fails on overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a * b;\\n\\n        // Detect overflow when multiplying MIN_INT256 with -1\\n        require(c != MIN_INT256 || (a \\u0026 MIN_INT256) != (b \\u0026 MIN_INT256));\\n        require((b == 0) || (c / b == a));\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Division of two int256 variables and fails on overflow.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        // Prevent overflow when dividing MIN_INT256 by -1\\n        require(b != -1 || a != MIN_INT256);\\n\\n        // Solidity already throws when dividing by 0.\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Subtracts two int256 variables and fails on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a));\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two int256 variables and fails on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Converts to absolute value, and fails on overflow.\\n     */\\n    function abs(int256 a) internal pure returns (int256) {\\n        require(a != MIN_INT256);\\n        return a \\u003c 0 ? -a : a;\\n    }\\n}\\n\\n\\n\\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\\n\\n/**\\n * @dev Implementation of the `IERC20` interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\n * For a generic mechanism see `ERC20Mintable`.\\n *\\n * *For a detailed writeup see our guide [How to implement supply\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See `IERC20.approve`.\\n */\\ncontract ERC20 is IERC20, Pausable {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 internal _totalSupply;\\n\\n    /**\\n     * @dev See `IERC20.totalSupply`.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.balanceOf`.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n\\n    /**\\n     * @dev See `IERC20.allowance`.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.approve`.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to `transfer`, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a `Transfer` event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transferFrom`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `value`.\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function _transferFrom(address sender, address recipient, uint256 amount) internal whenNotPaused returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n}\\n\\n\\n\\ncontract Truample is ERC20 {\\n\\n    using SafeMath for uint256;\\n    using SafeMathInt for int256;\\n\\n    string public constant name = \\\"Truample\\\";\\n    string public constant symbol = \\\"TMPL\\\";\\n    uint8  public constant decimals = 9;\\n\\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\\n    event RebaseContractInitialized(address reBaseAdress);\\n\\n    address public reBaseContractAddress; \\n    modifier validRecipient(address to) {\\n\\n        require(to != address(0x0));\\n        require(to != address(this));\\n        _;\\n    }\\n\\n    uint256 private constant MAX_UINT256 = ~uint256(0);\\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 3000000*(10**uint256(decimals));\\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\\n    uint256 private constant MAX_SUPPLY = ~uint128(0); \\n\\n    uint256 private _totalSupply;\\n    uint256 private _gonsPerFragment;\\n    mapping(address =\\u003e uint256) private _gonBalances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowedFragments;\\n\\n    uint256 public otcTokenSent;\\n    uint256 public teamTokensSent;\\n    uint256 public uniSwapLiquiditySent;\\n    uint256 public futureDevelopment;\\n    uint256 public ecoSystemTokens;\\n\\n    mapping(address =\\u003e bool) public teamTokenHolder;\\n    mapping(address =\\u003e uint256) public teamTokensReleased;\\n    mapping(address =\\u003e uint256) public teamTokensInitially;\\n    mapping (address =\\u003e uint256) public lockingTime;\\n\\n    /**\\n    * @dev this function will send the tokens to given entities\\n    * @param _userAddress ,address of the token receiver.\\n    * @param _value , number of tokens to be sent.\\n    */\\n    function sendTokens(address _userAddress, uint256 _value, uint256 _typeOfUser) external whenNotPaused onlyOwner returns (bool) {\\n\\n     if(_typeOfUser == 1)\\n     {\\n         otcTokenSent = otcTokenSent.add(_value);\\n         Ttransfer(msg.sender,_userAddress,_value);\\n\\n     }else if (_typeOfUser == 2)\\n     {\\n         uniSwapLiquiditySent = uniSwapLiquiditySent.add(_value);\\n         Ttransfer(msg.sender,_userAddress,_value);\\n\\n     }else if (_typeOfUser == 3){\\n         \\n        futureDevelopment = futureDevelopment.add(_value);\\n         Ttransfer(msg.sender,_userAddress,_value);\\n        \\n     } else if (_typeOfUser == 4){\\n\\n        ecoSystemTokens = ecoSystemTokens.add(_value);\\n         Ttransfer(msg.sender,_userAddress,_value);\\n\\n     }else {\\n\\n         revert();\\n\\n     }\\n\\n   }\\n\\n    /**\\n    * @dev this function will send the Team tokens to given address\\n    * @param _userAddress ,address of the team receiver.\\n    * @param _value , number of tokens to be sent.\\n    */\\n    function sendteamTokens(address _userAddress, uint256 _value) external whenNotPaused onlyOwner returns (bool) {\\n\\n     teamTokenHolder[_userAddress] = true;\\n     teamTokensInitially[_userAddress] = teamTokensInitially[_userAddress].add(_value);\\n     lockingTime[_userAddress] = now;\\n     teamTokensSent = teamTokensSent.add(_value);\\n     Ttransfer(msg.sender,_userAddress,_value);\\n        return true;\\n\\n   }\\n\\n    function getCycle(address _userAddress) public view returns (uint256){\\n     \\n     require(teamTokenHolder[_userAddress]);\\n     uint256 cycle = now.sub(lockingTime[_userAddress]);\\n    \\n     if(cycle \\u003c= 1296000)\\n     {\\n         return 0;\\n     }\\n     else if (cycle \\u003e 1296000 \\u0026\\u0026 cycle \\u003c= 42768000)\\n     {     \\n    \\n      uint256 secondsToHours = cycle.div(1296000);\\n      return secondsToHours;\\n\\n     }\\n\\n    else if (cycle \\u003e 42768000)\\n    {\\n        return 34;\\n    }\\n    \\n    }\\n    \\n    function setRebaseContractAddress(address _reBaseAddress) public onlyOwner returns (address){\\n        \\n        reBaseContractAddress = _reBaseAddress;\\n        emit RebaseContractInitialized(reBaseContractAddress);\\n        return (reBaseContractAddress);\\n    } \\n\\n    function rebase(uint256 epoch, int256 supplyDelta)\\n        external\\n        returns (bool)\\n    {\\n        require(reBaseContractAddress != address(0x0), \\\"rebase address not set yet\\\");\\n        require (msg.sender == reBaseContractAddress,\\\"Not called by rebase contract\\\");\\n\\n        if (supplyDelta == 0) {\\n            emit LogRebase(epoch, _totalSupply);\\n            return true;\\n        }\\n\\n        if (supplyDelta \\u003c 0) {\\n            _totalSupply = _totalSupply.sub(uint256(supplyDelta.abs()));\\n        } else {\\n            _totalSupply = _totalSupply.add(uint256(supplyDelta));\\n        }\\n\\n        if (_totalSupply \\u003e MAX_SUPPLY) {\\n            _totalSupply = MAX_SUPPLY;\\n        }\\n\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\n\\n\\n        emit LogRebase(epoch, _totalSupply);\\n        return true;\\n    }\\n\\n    constructor(address owner_) public Owned(owner_) {\\n\\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\n        _gonBalances[owner_] = TOTAL_GONS;\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n\\n    function balanceOf(address who) public view returns (uint256) {\\n        return _gonBalances[who].div(_gonsPerFragment);\\n    }\\n\\n    function Ttransfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal validRecipient(to) returns (bool) {\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\n\\n        _gonBalances[from] = _gonBalances[from].sub(gonValue);\\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\\n        emit Transfer(from, to, value);\\n        return true;\\n    }\\n\\n\\n    function allowance(address owner_, address spender)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _allowedFragments[owner_][spender];\\n    }\\n\\n\\n    function TtransferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal validRecipient(to) returns (bool) {\\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg\\n            .sender]\\n            .sub(value);\\n\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\n        _gonBalances[from] = _gonBalances[from].sub(gonValue);\\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\\n        emit Transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _allowedFragments[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        returns (bool)\\n    {\\n        _allowedFragments[msg.sender][spender] = _allowedFragments[msg\\n            .sender][spender]\\n            .add(addedValue);\\n        emit Approval(\\n            msg.sender,\\n            spender,\\n            _allowedFragments[msg.sender][spender]\\n        );\\n        return true;\\n    }\\n\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        returns (bool)\\n    {\\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\\n        if (subtractedValue \\u003e= oldValue) {\\n            _allowedFragments[msg.sender][spender] = 0;\\n        } else {\\n            _allowedFragments[msg.sender][spender] = oldValue.sub(\\n                subtractedValue\\n            );\\n        }\\n        emit Approval(\\n            msg.sender,\\n            spender,\\n            _allowedFragments[msg.sender][spender]\\n        );\\n        return true;\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public\\n        whenNotPaused\\n        returns (bool)\\n    {\\n\\n        if(teamTokenHolder[msg.sender]){\\n\\n\\n           if(teamTokensReleased[msg.sender] == teamTokensInitially[msg.sender]){\\n               \\n            Ttransfer(msg.sender, recipient, amount);\\n            return true;\\n               \\n           } else {\\n\\n            require(now \\u003e= lockingTime[msg.sender].add(1296000),\\u0027Zero cycle is running\\u0027);\\n\\n            uint256 preSaleCycle = getCycle(msg.sender);\\n            uint256 threePercentOfInitialFund = (teamTokensInitially[msg.sender].mul(3)).div(100);\\n            \\n            require(teamTokensReleased[msg.sender] != teamTokensInitially[msg.sender], \\u0027all tokens released\\u0027);\\n            require(teamTokensReleased[msg.sender] != threePercentOfInitialFund.mul(preSaleCycle),\\u0027this cycle all tokens released\\u0027);            \\n            \\n            if(teamTokensReleased[msg.sender] \\u003c threePercentOfInitialFund.mul(preSaleCycle))\\n            {\\n            uint256 tokenToSend = amount;\\n            teamTokensReleased[msg.sender] = tokenToSend.add(teamTokensReleased[msg.sender]);\\n            require(teamTokensReleased[msg.sender] \\u003c= teamTokensInitially[msg.sender],\\u0027tokens released are greater then inital tokens\\u0027);\\n\\n            Ttransfer(msg.sender, recipient, amount);\\n            return true;\\n            }\\n           }\\n\\n            \\n            \\n        }else{\\n\\n            Ttransfer(msg.sender, recipient, amount);\\n            return true;\\n        } \\n\\n    }\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public whenNotPaused returns (bool) {\\n\\n\\n        if(teamTokenHolder[sender]){\\n\\n           if(teamTokensReleased[sender] == teamTokensInitially[sender]){\\n               \\n            TtransferFrom(sender, recipient, amount);\\n            return true;\\n               \\n           }else \\n{            require(now \\u003e= lockingTime[sender].add(1296000),\\\"zero cycle is running\\\");\\n\\n            uint256 preSaleCycle = getCycle(sender);\\n            uint256 threePercentOfInitialFund = (teamTokensInitially[sender].mul(3)).div(100);\\n            \\n            require(teamTokensReleased[sender] != teamTokensInitially[sender]);\\n            require(teamTokensReleased[sender] != threePercentOfInitialFund.mul(preSaleCycle));            \\n            \\n            if(teamTokensReleased[sender] \\u003c threePercentOfInitialFund.mul(preSaleCycle))\\n\\n            {\\n            \\n            uint256 tokenToSend = amount;\\n            teamTokensReleased[sender] = tokenToSend.add(teamTokensReleased[sender]);\\n            require(teamTokensReleased[sender] \\u003c= teamTokensInitially[sender]);\\n\\n            TtransferFrom(sender, recipient, amount);\\n            return true;\\n                    \\n            }\\n}            \\n            \\n        }else{\\n\\n            TtransferFrom(sender, recipient, amount);\\n            return true;\\n            \\n        } \\n\\n    }\\n\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialTargetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"contract Truample\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"initilize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCallRebaseManual\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastOracleCallTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRebaseTimestampSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketOracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minRebaseTimeIntervalSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracelWindowValidUpto\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleContractActivation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebaseLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rebaseLog\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newOracleData\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"oraclePriceDelta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"targetPriceDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"newTargetPrice\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiple\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setOracleContractActivation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setOracleContractAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minRebaseTimeIntervalSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_oracelWindowValidUpto\",\"type\":\"uint256\"}],\"name\":\"setRebaseTimingParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_oracleData\",\"type\":\"uint256\"}],\"name\":\"setRebasemanually\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContractAddress\",\"outputs\":[{\"internalType\":\"contract Truample\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"rebaseContract","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b15b1e080b61eb4d2858f9f8fe69a2746518c6cec00c107dc943c011b001e968"}]}