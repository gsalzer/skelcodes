{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/sol6/IKyberHistory.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IKyberHistory {\r\n    function saveContract(address _contract) external;\r\n    function getContracts() external view returns (address[] memory);\r\n}\r\n\r\n// File: contracts/sol6/IERC20.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function decimals() external view returns (uint8 digits);\r\n\r\n    function totalSupply() external view returns (uint256 supply);\r\n}\r\n\r\n\r\n// to support backward compatible contract name -- so function signature remains same\r\nabstract contract ERC20 is IERC20 {\r\n\r\n}\r\n\r\n// File: contracts/sol6/IKyberNetworkProxy.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberNetworkProxy {\r\n\r\n    event ExecuteTrade(\r\n        address indexed trader,\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        address destAddress,\r\n        uint256 actualSrcAmount,\r\n        uint256 actualDestAmount,\r\n        address platformWallet,\r\n        uint256 platformFeeBps\r\n    );\r\n\r\n    /// @notice backward compatible\r\n    function tradeWithHint(\r\n        ERC20 src,\r\n        uint256 srcAmount,\r\n        ERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable walletId,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256);\r\n\r\n    function tradeWithHintAndFee(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256 destAmount);\r\n\r\n    function trade(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet\r\n    ) external payable returns (uint256);\r\n\r\n    /// @notice backward compatible\r\n    /// @notice Rate units (10 ** 18) => destQty (twei) / srcQty (twei) * 10 ** 18\r\n    function getExpectedRate(\r\n        ERC20 src,\r\n        ERC20 dest,\r\n        uint256 srcQty\r\n    ) external view returns (uint256 expectedRate, uint256 worstRate);\r\n\r\n    function getExpectedRateAfterFee(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external view returns (uint256 expectedRate);\r\n}\r\n\r\n// File: contracts/sol6/IKyberReserve.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberReserve {\r\n    function trade(\r\n        IERC20 srcToken,\r\n        uint256 srcAmount,\r\n        IERC20 destToken,\r\n        address payable destAddress,\r\n        uint256 conversionRate,\r\n        bool validate\r\n    ) external payable returns (bool);\r\n\r\n    function getConversionRate(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 blockNumber\r\n    ) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/IKyberStorage.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\ninterface IKyberStorage {\r\n    enum ReserveType {NONE, FPR, APR, BRIDGE, UTILITY, CUSTOM, ORDERBOOK, LAST}\r\n\r\n    function addKyberProxy(address kyberProxy, uint256 maxApprovedProxies)\r\n        external;\r\n\r\n    function removeKyberProxy(address kyberProxy) external;\r\n\r\n    function setContracts(address _kyberFeeHandler, address _kyberMatchingEngine) external;\r\n\r\n    function setKyberDaoContract(address _kyberDao) external;\r\n\r\n    function getReserveId(address reserve) external view returns (bytes32 reserveId);\r\n\r\n    function getReserveIdsFromAddresses(address[] calldata reserveAddresses)\r\n        external\r\n        view\r\n        returns (bytes32[] memory reserveIds);\r\n\r\n    function getReserveAddressesFromIds(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (address[] memory reserveAddresses);\r\n\r\n    function getReserveIdsPerTokenSrc(IERC20 token)\r\n        external\r\n        view\r\n        returns (bytes32[] memory reserveIds);\r\n\r\n    function getReserveAddressesPerTokenSrc(IERC20 token, uint256 startIndex, uint256 endIndex)\r\n        external\r\n        view\r\n        returns (address[] memory reserveAddresses);\r\n\r\n    function getReserveIdsPerTokenDest(IERC20 token)\r\n        external\r\n        view\r\n        returns (bytes32[] memory reserveIds);\r\n\r\n    function getReserveAddressesByReserveId(bytes32 reserveId)\r\n        external\r\n        view\r\n        returns (address[] memory reserveAddresses);\r\n\r\n    function getRebateWalletsFromIds(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (address[] memory rebateWallets);\r\n\r\n    function getKyberProxies() external view returns (IKyberNetworkProxy[] memory);\r\n\r\n    function getReserveDetailsByAddress(address reserve)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 reserveId,\r\n            address rebateWallet,\r\n            ReserveType resType,\r\n            bool isFeeAccountedFlag,\r\n            bool isEntitledRebateFlag\r\n        );\r\n\r\n    function getReserveDetailsById(bytes32 reserveId)\r\n        external\r\n        view\r\n        returns (\r\n            address reserveAddress,\r\n            address rebateWallet,\r\n            ReserveType resType,\r\n            bool isFeeAccountedFlag,\r\n            bool isEntitledRebateFlag\r\n        );\r\n\r\n    function getFeeAccountedData(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (bool[] memory feeAccountedArr);\r\n\r\n    function getEntitledRebateData(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (bool[] memory entitledRebateArr);\r\n\r\n    function getReservesData(bytes32[] calldata reserveIds, IERC20 src, IERC20 dest)\r\n        external\r\n        view\r\n        returns (\r\n            bool areAllReservesListed,\r\n            bool[] memory feeAccountedArr,\r\n            bool[] memory entitledRebateArr,\r\n            IKyberReserve[] memory reserveAddresses);\r\n\r\n    function isKyberProxyAdded() external view returns (bool);\r\n}\r\n\r\n// File: contracts/sol6/IKyberNetwork.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberNetwork {\r\n    event KyberTrade(\r\n        IERC20 indexed src,\r\n        IERC20 indexed dest,\r\n        uint256 ethWeiValue,\r\n        uint256 networkFeeWei,\r\n        uint256 customPlatformFeeWei,\r\n        bytes32[] t2eIds,\r\n        bytes32[] e2tIds,\r\n        uint256[] t2eSrcAmounts,\r\n        uint256[] e2tSrcAmounts,\r\n        uint256[] t2eRates,\r\n        uint256[] e2tRates\r\n    );\r\n\r\n    function tradeWithHintAndFee(\r\n        address payable trader,\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256 destAmount);\r\n\r\n    function listTokenForReserve(\r\n        address reserve,\r\n        IERC20 token,\r\n        bool add\r\n    ) external;\r\n\r\n    function enabled() external view returns (bool);\r\n\r\n    function getExpectedRateWithHintAndFee(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 expectedRateAfterNetworkFee,\r\n            uint256 expectedRateAfterAllFees\r\n        );\r\n\r\n    function getNetworkData()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 negligibleDiffBps,\r\n            uint256 networkFeeBps,\r\n            uint256 expiryTimestamp\r\n        );\r\n\r\n    function maxGasPrice() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/utils/PermissionGroupsNoModifiers.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract PermissionGroupsNoModifiers {\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address => bool) internal operators;\r\n    mapping(address => bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint256 internal constant MAX_GROUP_SIZE = 50;\r\n\r\n    event AdminClaimed(address newAdmin, address previousAdmin);\r\n    event AlerterAdded(address newAlerter, bool isAdd);\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    constructor(address _admin) public {\r\n        require(_admin != address(0), \"admin 0\");\r\n        admin = _admin;\r\n    }\r\n\r\n    function getOperators() external view returns (address[] memory) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters() external view returns (address[] memory) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    function addAlerter(address newAlerter) public {\r\n        onlyAdmin();\r\n        require(!alerters[newAlerter], \"alerter exists\"); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE, \"max alerters\");\r\n\r\n        emit AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function addOperator(address newOperator) public {\r\n        onlyAdmin();\r\n        require(!operators[newOperator], \"operator exists\"); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE, \"max operators\");\r\n\r\n        emit OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    /// @dev Allows the pendingAdmin address to finalize the change admin process.\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender, \"not pending\");\r\n        emit AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    function removeAlerter(address alerter) public {\r\n        onlyAdmin();\r\n        require(alerters[alerter], \"not alerter\");\r\n        delete alerters[alerter];\r\n\r\n        for (uint256 i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.pop();\r\n                emit AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeOperator(address operator) public {\r\n        onlyAdmin();\r\n        require(operators[operator], \"not operator\");\r\n        delete operators[operator];\r\n\r\n        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.pop();\r\n                emit OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Allows the current admin to set the pendingAdmin address\r\n    /// @param newAdmin The address to transfer ownership to\r\n    function transferAdmin(address newAdmin) public {\r\n        onlyAdmin();\r\n        require(newAdmin != address(0), \"new admin 0\");\r\n        emit TransferAdminPending(newAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /// @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n    /// @param newAdmin The address to transfer ownership to.\r\n    function transferAdminQuickly(address newAdmin) public {\r\n        onlyAdmin();\r\n        require(newAdmin != address(0), \"admin 0\");\r\n        emit TransferAdminPending(newAdmin);\r\n        emit AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    function onlyAdmin() internal view {\r\n        require(msg.sender == admin, \"only admin\");\r\n    }\r\n\r\n    function onlyAlerter() internal view {\r\n        require(alerters[msg.sender], \"only alerter\");\r\n    }\r\n\r\n    function onlyOperator() internal view {\r\n        require(operators[msg.sender], \"only operator\");\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/utils/Utils5.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n/**\r\n * @title Kyber utility file\r\n * mostly shared constants and rate calculation helpers\r\n * inherited by most of kyber contracts.\r\n * previous utils implementations are for previous solidity versions.\r\n */\r\ncontract Utils5 {\r\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n    );\r\n    uint256 internal constant PRECISION = (10**18);\r\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\r\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\r\n    uint256 internal constant MAX_DECIMALS = 18;\r\n    uint256 internal constant ETH_DECIMALS = 18;\r\n    uint256 constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\r\n    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\r\n\r\n    mapping(IERC20 => uint256) internal decimals;\r\n\r\n    function getUpdateDecimals(IERC20 token) internal returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) {\r\n            tokenDecimals = token.decimals();\r\n            decimals[token] = tokenDecimals;\r\n        }\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function setDecimals(IERC20 token) internal {\r\n        if (decimals[token] != 0) return; //already set\r\n\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            decimals[token] = ETH_DECIMALS;\r\n        } else {\r\n            decimals[token] = token.decimals();\r\n        }\r\n    }\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(IERC20 token, address user) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            return user.balance;\r\n        } else {\r\n            return token.balanceOf(user);\r\n        }\r\n    }\r\n\r\n    function getDecimals(IERC20 token) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDestAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 destAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcDstQty(\r\n        uint256 srcQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(srcQty <= MAX_QTY, \"srcQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(\r\n        uint256 dstQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(dstQty <= MAX_QTY, \"dstQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint256 numerator;\r\n        uint256 denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcRateFromQty(\r\n        uint256 srcAmount,\r\n        uint256 destAmount,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals\r\n    ) internal pure returns (uint256) {\r\n        require(srcAmount <= MAX_QTY, \"srcAmount > MAX_QTY\");\r\n        require(destAmount <= MAX_QTY, \"destAmount > MAX_QTY\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\r\n        }\r\n    }\r\n\r\n    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/KyberStorage.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n *   @title kyberStorage contract\r\n *   The contract provides the following functions for kyberNetwork contract:\r\n *   - Stores reserve and token listing information by the kyberNetwork\r\n *   - Stores feeAccounted data for reserve types\r\n *   - Record contract changes for reserves and kyberProxies\r\n *   - Points to historical contracts that record contract changes for kyberNetwork,\r\n *        kyberFeeHandler, kyberDao and kyberMatchingEngine\r\n */\r\ncontract KyberStorage is IKyberStorage, PermissionGroupsNoModifiers, Utils5 {\r\n    // store current and previous contracts\r\n    IKyberHistory public kyberNetworkHistory;\r\n    IKyberHistory public kyberFeeHandlerHistory;\r\n    IKyberHistory public kyberDaoHistory;\r\n    IKyberHistory public kyberMatchingEngineHistory;\r\n\r\n    IKyberReserve[] internal reserves;\r\n    IKyberNetworkProxy[] internal kyberProxyArray;\r\n\r\n    mapping(bytes32 => address[]) internal reserveIdToAddresses;\r\n    mapping(bytes32 => address) internal reserveRebateWallet;\r\n    mapping(address => bytes32) internal reserveAddressToId;\r\n    mapping(IERC20 => bytes32[]) internal reservesPerTokenSrc; // reserves supporting token to eth\r\n    mapping(IERC20 => bytes32[]) internal reservesPerTokenDest; // reserves support eth to token\r\n    mapping(bytes32 => IERC20[]) internal srcTokensPerReserve;\r\n    mapping(bytes32 => IERC20[]) internal destTokensPerReserve;\r\n\r\n    mapping(IERC20 => mapping(bytes32 => bool)) internal isListedReserveWithTokenSrc;\r\n    mapping(IERC20 => mapping(bytes32 => bool)) internal isListedReserveWithTokenDest;\r\n\r\n    uint256 internal feeAccountedPerType = 0xffffffff;\r\n    uint256 internal entitledRebatePerType = 0xffffffff;\r\n    mapping(bytes32 => uint256) internal reserveType; // type from enum ReserveType\r\n    mapping(ReserveType => bytes32[]) internal reservesPerType;\r\n\r\n    IKyberNetwork public kyberNetwork;\r\n\r\n    constructor(\r\n        address _admin,\r\n        IKyberHistory _kyberNetworkHistory,\r\n        IKyberHistory _kyberFeeHandlerHistory,\r\n        IKyberHistory _kyberDaoHistory,\r\n        IKyberHistory _kyberMatchingEngineHistory\r\n    ) public PermissionGroupsNoModifiers(_admin) {\r\n        require(_kyberNetworkHistory != IKyberHistory(0), \"kyberNetworkHistory 0\");\r\n        require(_kyberFeeHandlerHistory != IKyberHistory(0), \"kyberFeeHandlerHistory 0\");\r\n        require(_kyberDaoHistory != IKyberHistory(0), \"kyberDaoHistory 0\");\r\n        require(_kyberMatchingEngineHistory != IKyberHistory(0), \"kyberMatchingEngineHistory 0\");\r\n\r\n        kyberNetworkHistory = _kyberNetworkHistory;\r\n        kyberFeeHandlerHistory = _kyberFeeHandlerHistory;\r\n        kyberDaoHistory = _kyberDaoHistory;\r\n        kyberMatchingEngineHistory = _kyberMatchingEngineHistory;\r\n    }\r\n\r\n    event KyberNetworkUpdated(IKyberNetwork newKyberNetwork);\r\n    event RemoveReserveFromStorage(address indexed reserve, bytes32 indexed reserveId);\r\n\r\n    event AddReserveToStorage(\r\n        address indexed reserve,\r\n        bytes32 indexed reserveId,\r\n        IKyberStorage.ReserveType reserveType,\r\n        address indexed rebateWallet\r\n    );\r\n\r\n    event ReserveRebateWalletSet(\r\n        bytes32 indexed reserveId,\r\n        address indexed rebateWallet\r\n    );\r\n\r\n    event ListReservePairs(\r\n        bytes32 indexed reserveId,\r\n        address reserve,\r\n        IERC20 indexed src,\r\n        IERC20 indexed dest,\r\n        bool add\r\n    );\r\n\r\n    function setNetworkContract(IKyberNetwork _kyberNetwork) external {\r\n        onlyAdmin();\r\n        require(_kyberNetwork != IKyberNetwork(0), \"kyberNetwork 0\");\r\n        emit KyberNetworkUpdated(_kyberNetwork);\r\n        kyberNetworkHistory.saveContract(address(_kyberNetwork));\r\n        kyberNetwork = _kyberNetwork;\r\n    }\r\n\r\n    function setRebateWallet(bytes32 reserveId, address rebateWallet) external {\r\n        onlyOperator();\r\n        require(rebateWallet != address(0), \"rebate wallet is 0\");\r\n        require(reserveId != bytes32(0), \"reserveId = 0\");\r\n        require(reserveIdToAddresses[reserveId].length > 0, \"reserveId not found\");\r\n        require(reserveIdToAddresses[reserveId][0] != address(0), \"no reserve associated\");\r\n\r\n        reserveRebateWallet[reserveId] = rebateWallet;\r\n        emit ReserveRebateWalletSet(reserveId, rebateWallet);\r\n    }\r\n\r\n    function setContracts(address _kyberFeeHandler, address _kyberMatchingEngine)\r\n        external\r\n        override\r\n    {\r\n        onlyNetwork();\r\n        require(_kyberFeeHandler != address(0), \"kyberFeeHandler 0\");\r\n        require(_kyberMatchingEngine != address(0), \"kyberMatchingEngine 0\");\r\n\r\n        kyberFeeHandlerHistory.saveContract(_kyberFeeHandler);\r\n        kyberMatchingEngineHistory.saveContract(_kyberMatchingEngine);\r\n    }\r\n\r\n    function setKyberDaoContract(address _kyberDao) external override {\r\n        onlyNetwork();\r\n\r\n        kyberDaoHistory.saveContract(_kyberDao);\r\n    }\r\n\r\n    /// @notice Can be called only by operator\r\n    /// @dev Adds a reserve to the storage\r\n    /// @param reserve The reserve address\r\n    /// @param reserveId The reserve ID in 32 bytes.\r\n    /// @param resType Type of the reserve out of enum ReserveType\r\n    /// @param rebateWallet Rebate wallet address for this reserve\r\n    function addReserve(\r\n        address reserve,\r\n        bytes32 reserveId,\r\n        ReserveType resType,\r\n        address payable rebateWallet\r\n    ) external {\r\n        onlyOperator();\r\n        require(reserveAddressToId[reserve] == bytes32(0), \"reserve has id\");\r\n        require(reserveId != bytes32(0), \"reserveId = 0\");\r\n        require(\r\n            (resType != ReserveType.NONE) && (uint256(resType) < uint256(ReserveType.LAST)),\r\n            \"bad reserve type\"\r\n        );\r\n        require(feeAccountedPerType != 0xffffffff, \"fee accounted data not set\");\r\n        require(entitledRebatePerType != 0xffffffff, \"entitled rebate data not set\");\r\n        require(rebateWallet != address(0), \"rebate wallet is 0\");\r\n\r\n        reserveRebateWallet[reserveId] = rebateWallet;\r\n\r\n        if (reserveIdToAddresses[reserveId].length == 0) {\r\n            reserveIdToAddresses[reserveId].push(reserve);\r\n        } else {\r\n            require(reserveIdToAddresses[reserveId][0] == address(0), \"reserveId taken\");\r\n            reserveIdToAddresses[reserveId][0] = reserve;\r\n        }\r\n\r\n        reserves.push(IKyberReserve(reserve));\r\n        reservesPerType[resType].push(reserveId);\r\n        reserveAddressToId[reserve] = reserveId;\r\n        reserveType[reserveId] = uint256(resType);\r\n\r\n        emit AddReserveToStorage(reserve, reserveId, resType, rebateWallet);\r\n        emit ReserveRebateWalletSet(reserveId, rebateWallet);\r\n    }\r\n\r\n    /// @notice Can be called only by operator\r\n    /// @dev Removes a reserve from the storage\r\n    /// @param reserveId The reserve id\r\n    /// @param startIndex Index to start searching from in reserve array\r\n    function removeReserve(bytes32 reserveId, uint256 startIndex)\r\n        external\r\n    {\r\n        onlyOperator();\r\n        require(reserveIdToAddresses[reserveId].length > 0, \"reserveId not found\");\r\n        address reserve = reserveIdToAddresses[reserveId][0];\r\n\r\n        // delist all token pairs for reserve\r\n        delistTokensOfReserve(reserveId);\r\n\r\n        uint256 reserveIndex = 2**255;\r\n        for (uint256 i = startIndex; i < reserves.length; i++) {\r\n            if (reserves[i] == IKyberReserve(reserve)) {\r\n                reserveIndex = i;\r\n                break;\r\n            }\r\n        }\r\n        require(reserveIndex != 2**255, \"reserve not found\");\r\n        reserves[reserveIndex] = reserves[reserves.length - 1];\r\n        reserves.pop();\r\n        // remove reserve from mapping to address\r\n        require(reserveAddressToId[reserve] != bytes32(0), \"reserve's existing reserveId is 0\");\r\n        reserveId = reserveAddressToId[reserve];\r\n\r\n        // update reserve mappings\r\n        reserveIdToAddresses[reserveId].push(reserveIdToAddresses[reserveId][0]);\r\n        reserveIdToAddresses[reserveId][0] = address(0);\r\n\r\n        // remove reserveId from reservesPerType\r\n        bytes32[] storage reservesOfType = reservesPerType[ReserveType(reserveType[reserveId])];\r\n        for (uint256 i = 0; i < reservesOfType.length; i++) {\r\n            if (reserveId == reservesOfType[i]) {\r\n                reservesOfType[i] = reservesOfType[reservesOfType.length - 1];\r\n                reservesOfType.pop();\r\n                break;\r\n            }\r\n        }\r\n\r\n        delete reserveAddressToId[reserve];\r\n        delete reserveType[reserveId];\r\n        delete reserveRebateWallet[reserveId];\r\n\r\n        emit RemoveReserveFromStorage(reserve, reserveId);\r\n    }\r\n\r\n    /// @notice Can be called only by operator\r\n    /// @dev Allow or prevent a specific reserve to trade a pair of tokens\r\n    /// @param reserveId The reserve id\r\n    /// @param token Token address\r\n    /// @param ethToToken Will it support ether to token trade\r\n    /// @param tokenToEth Will it support token to ether trade\r\n    /// @param add If true then list this pair, otherwise unlist it\r\n    function listPairForReserve(\r\n        bytes32 reserveId,\r\n        IERC20 token,\r\n        bool ethToToken,\r\n        bool tokenToEth,\r\n        bool add\r\n    ) public {\r\n        onlyOperator();\r\n\r\n        require(reserveIdToAddresses[reserveId].length > 0, \"reserveId not found\");\r\n        address reserve = reserveIdToAddresses[reserveId][0];\r\n        require(reserve != address(0), \"reserve = 0\");\r\n\r\n        if (ethToToken) {\r\n            listPairs(reserveId, token, false, add);\r\n            emit ListReservePairs(reserveId, reserve, ETH_TOKEN_ADDRESS, token, add);\r\n        }\r\n\r\n        if (tokenToEth) {\r\n            kyberNetwork.listTokenForReserve(reserve, token, add);\r\n            listPairs(reserveId, token, true, add);\r\n            emit ListReservePairs(reserveId, reserve, token, ETH_TOKEN_ADDRESS, add);\r\n        }\r\n    }\r\n\r\n    /// @dev No. of kyberProxies are capped\r\n    function addKyberProxy(address kyberProxy, uint256 maxApprovedProxies)\r\n        external\r\n        override\r\n    {\r\n        onlyNetwork();\r\n        require(kyberProxy != address(0), \"kyberProxy 0\");\r\n        require(kyberProxyArray.length < maxApprovedProxies, \"max kyberProxies limit reached\");\r\n\r\n        kyberProxyArray.push(IKyberNetworkProxy(kyberProxy));\r\n    }\r\n\r\n    function removeKyberProxy(address kyberProxy) external override {\r\n        onlyNetwork();\r\n        uint256 proxyIndex = 2**255;\r\n\r\n        for (uint256 i = 0; i < kyberProxyArray.length; i++) {\r\n            if (kyberProxyArray[i] == IKyberNetworkProxy(kyberProxy)) {\r\n                proxyIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(proxyIndex != 2**255, \"kyberProxy not found\");\r\n        kyberProxyArray[proxyIndex] = kyberProxyArray[kyberProxyArray.length - 1];\r\n        kyberProxyArray.pop();\r\n    }\r\n\r\n    function setFeeAccountedPerReserveType(\r\n        bool fpr,\r\n        bool apr,\r\n        bool bridge,\r\n        bool utility,\r\n        bool custom,\r\n        bool orderbook\r\n    ) external {\r\n        onlyAdmin();\r\n        uint256 feeAccountedData;\r\n\r\n        if (fpr) feeAccountedData |= 1 << uint256(ReserveType.FPR);\r\n        if (apr) feeAccountedData |= 1 << uint256(ReserveType.APR);\r\n        if (bridge) feeAccountedData |= 1 << uint256(ReserveType.BRIDGE);\r\n        if (utility) feeAccountedData |= 1 << uint256(ReserveType.UTILITY);\r\n        if (custom) feeAccountedData |= 1 << uint256(ReserveType.CUSTOM);\r\n        if (orderbook) feeAccountedData |= 1 << uint256(ReserveType.ORDERBOOK);\r\n\r\n        feeAccountedPerType = feeAccountedData;\r\n    }\r\n\r\n    function setEntitledRebatePerReserveType(\r\n        bool fpr,\r\n        bool apr,\r\n        bool bridge,\r\n        bool utility,\r\n        bool custom,\r\n        bool orderbook\r\n    ) external {\r\n        onlyAdmin();\r\n        require(feeAccountedPerType != 0xffffffff, \"fee accounted data not set\");\r\n        uint256 entitledRebateData;\r\n\r\n        if (fpr) {\r\n            require(feeAccountedPerType & (1 << uint256(ReserveType.FPR)) > 0, \"fpr not fee accounted\");\r\n            entitledRebateData |= 1 << uint256(ReserveType.FPR);\r\n        }\r\n\r\n        if (apr) {\r\n            require(feeAccountedPerType & (1 << uint256(ReserveType.APR)) > 0, \"apr not fee accounted\");\r\n            entitledRebateData |= 1 << uint256(ReserveType.APR);\r\n        }\r\n\r\n        if (bridge) {\r\n            require(feeAccountedPerType & (1 << uint256(ReserveType.BRIDGE)) > 0, \"bridge not fee accounted\");\r\n            entitledRebateData |= 1 << uint256(ReserveType.BRIDGE);\r\n        }\r\n\r\n        if (utility) {\r\n            require(feeAccountedPerType & (1 << uint256(ReserveType.UTILITY)) > 0, \"utility not fee accounted\");\r\n            entitledRebateData |= 1 << uint256(ReserveType.UTILITY);\r\n        }\r\n\r\n        if (custom) {\r\n            require(feeAccountedPerType & (1 << uint256(ReserveType.CUSTOM)) > 0, \"custom not fee accounted\");\r\n            entitledRebateData |= 1 << uint256(ReserveType.CUSTOM);\r\n        }\r\n\r\n        if (orderbook) {\r\n            require(feeAccountedPerType & (1 << uint256(ReserveType.ORDERBOOK)) > 0, \"orderbook not fee accounted\");\r\n            entitledRebateData |= 1 << uint256(ReserveType.ORDERBOOK);\r\n        }\r\n\r\n        entitledRebatePerType = entitledRebateData;\r\n    }\r\n\r\n    /// @notice Should be called off chain\r\n    /// @return An array of all reserves\r\n    function getReserves() external view returns (IKyberReserve[] memory) {\r\n        return reserves;\r\n    }\r\n\r\n    function getReservesPerType(ReserveType resType) external view returns (bytes32[] memory) {\r\n        return reservesPerType[resType];\r\n    }\r\n\r\n    function getReserveId(address reserve) external view override returns (bytes32) {\r\n        return reserveAddressToId[reserve];\r\n    }\r\n\r\n    function getReserveIdsFromAddresses(address[] calldata reserveAddresses)\r\n        external\r\n        override\r\n        view\r\n        returns (bytes32[] memory reserveIds)\r\n    {\r\n        reserveIds = new bytes32[](reserveAddresses.length);\r\n        for (uint256 i = 0; i < reserveAddresses.length; i++) {\r\n            reserveIds[i] = reserveAddressToId[reserveAddresses[i]];\r\n        }\r\n    }\r\n\r\n    function getReserveAddressesFromIds(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory reserveAddresses)\r\n    {\r\n        reserveAddresses = new address[](reserveIds.length);\r\n        for (uint256 i = 0; i < reserveIds.length; i++) {\r\n            reserveAddresses[i] = reserveIdToAddresses[reserveIds[i]][0];\r\n        }\r\n    }\r\n\r\n    function getRebateWalletsFromIds(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory rebateWallets)\r\n    {\r\n        rebateWallets = new address[](reserveIds.length);\r\n        for (uint256 i = 0; i < rebateWallets.length; i++) {\r\n            rebateWallets[i] = reserveRebateWallet[reserveIds[i]];\r\n        }\r\n    }\r\n\r\n    function getReserveIdsPerTokenSrc(IERC20 token)\r\n        external\r\n        view\r\n        override\r\n        returns (bytes32[] memory reserveIds)\r\n    {\r\n        reserveIds = reservesPerTokenSrc[token];\r\n    }\r\n\r\n    /// @dev kyberNetwork is calling this function to approve (allowance) for list of reserves for a token\r\n    ///      in case we have a long list of reserves, approving all of them could run out of gas\r\n    ///      using startIndex and endIndex to prevent above scenario\r\n    ///      also enable us to approve reserve one by one\r\n    function getReserveAddressesPerTokenSrc(IERC20 token, uint256 startIndex, uint256 endIndex)\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory reserveAddresses)\r\n    {\r\n        bytes32[] memory reserveIds = reservesPerTokenSrc[token];\r\n        if (reserveIds.length == 0) {\r\n            return reserveAddresses;\r\n        }\r\n        uint256 endId = (endIndex >= reserveIds.length) ? (reserveIds.length - 1) : endIndex;\r\n        if (endId < startIndex) {\r\n            return reserveAddresses;\r\n        }\r\n        reserveAddresses = new address[](endId - startIndex + 1);\r\n        for(uint256 i = startIndex; i <= endId; i++) {\r\n            reserveAddresses[i - startIndex] = reserveIdToAddresses[reserveIds[i]][0];\r\n        }\r\n    }\r\n\r\n    function getReserveIdsPerTokenDest(IERC20 token)\r\n        external\r\n        view\r\n        override\r\n        returns (bytes32[] memory reserveIds)\r\n    {\r\n        reserveIds = reservesPerTokenDest[token];\r\n    }\r\n\r\n    function getReserveAddressesByReserveId(bytes32 reserveId)\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory reserveAddresses)\r\n    {\r\n        reserveAddresses = reserveIdToAddresses[reserveId];\r\n    }\r\n\r\n    /// @notice Should be called off chain\r\n    /// @dev Returns list of kyberDao, kyberFeeHandler, kyberMatchingEngine and kyberNetwork contracts\r\n    /// @dev Index 0 is currently used contract address, indexes > 0 are older versions\r\n    function getContracts()\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory kyberDaoAddresses,\r\n            address[] memory kyberFeeHandlerAddresses,\r\n            address[] memory kyberMatchingEngineAddresses,\r\n            address[] memory kyberNetworkAddresses\r\n        )\r\n    {\r\n        kyberDaoAddresses = kyberDaoHistory.getContracts();\r\n        kyberFeeHandlerAddresses = kyberFeeHandlerHistory.getContracts();\r\n        kyberMatchingEngineAddresses = kyberMatchingEngineHistory.getContracts();\r\n        kyberNetworkAddresses = kyberNetworkHistory.getContracts();\r\n    }\r\n\r\n    /// @notice Should be called off chain\r\n    /// @return An array of KyberNetworkProxies\r\n    function getKyberProxies() external view override returns (IKyberNetworkProxy[] memory) {\r\n        return kyberProxyArray;\r\n    }\r\n\r\n    function isKyberProxyAdded() external view override returns (bool) {\r\n        return (kyberProxyArray.length > 0);\r\n    }\r\n\r\n    /// @notice Returns information about a reserve given its reserve ID\r\n    /// @return reserveAddress Address of the reserve\r\n    /// @return rebateWallet address of rebate wallet of this reserve\r\n    /// @return resType Reserve type from enum ReserveType\r\n    /// @return isFeeAccountedFlag Whether fees are to be charged for the trade for this reserve\r\n    /// @return isEntitledRebateFlag Whether reserve is entitled rebate from the trade fees\r\n    function getReserveDetailsById(bytes32 reserveId)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            address reserveAddress,\r\n            address rebateWallet,\r\n            ReserveType resType,\r\n            bool isFeeAccountedFlag,\r\n            bool isEntitledRebateFlag\r\n        )\r\n    {\r\n        address[] memory reserveAddresses = reserveIdToAddresses[reserveId];\r\n\r\n        if (reserveAddresses.length != 0) {\r\n            reserveAddress = reserveIdToAddresses[reserveId][0];\r\n            rebateWallet = reserveRebateWallet[reserveId];\r\n            uint256 resTypeUint = reserveType[reserveId];\r\n            resType = ReserveType(resTypeUint);\r\n            isFeeAccountedFlag = (feeAccountedPerType & (1 << resTypeUint)) > 0;\r\n            isEntitledRebateFlag = (entitledRebatePerType & (1 << resTypeUint)) > 0;\r\n        }\r\n    }\r\n\r\n    /// @notice Returns information about a reserve given its reserve ID\r\n    /// @return reserveId The reserve ID in 32 bytes.\r\n    /// @return rebateWallet address of rebate wallet of this reserve\r\n    /// @return resType Reserve type from enum ReserveType\r\n    /// @return isFeeAccountedFlag Whether fees are to be charged for the trade for this reserve\r\n    /// @return isEntitledRebateFlag Whether reserve is entitled rebate from the trade fees\r\n    function getReserveDetailsByAddress(address reserve)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            bytes32 reserveId,\r\n            address rebateWallet,\r\n            ReserveType resType,\r\n            bool isFeeAccountedFlag,\r\n            bool isEntitledRebateFlag\r\n        )\r\n    {\r\n        reserveId = reserveAddressToId[reserve];\r\n        rebateWallet = reserveRebateWallet[reserveId];\r\n        uint256 resTypeUint = reserveType[reserveId];\r\n        resType = ReserveType(resTypeUint);\r\n        isFeeAccountedFlag = (feeAccountedPerType & (1 << resTypeUint)) > 0;\r\n        isEntitledRebateFlag = (entitledRebatePerType & (1 << resTypeUint)) > 0;\r\n    }\r\n\r\n    function getListedTokensByReserveId(bytes32 reserveId)\r\n        external\r\n        view\r\n        returns (\r\n            IERC20[] memory srcTokens,\r\n            IERC20[] memory destTokens\r\n        )\r\n    {\r\n        srcTokens = srcTokensPerReserve[reserveId];\r\n        destTokens = destTokensPerReserve[reserveId];\r\n    }\r\n\r\n    function getFeeAccountedData(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        override\r\n        returns (bool[] memory feeAccountedArr)\r\n    {\r\n        feeAccountedArr = new bool[](reserveIds.length);\r\n\r\n        uint256 feeAccountedData = feeAccountedPerType;\r\n\r\n        for (uint256 i = 0; i < reserveIds.length; i++) {\r\n            feeAccountedArr[i] = (feeAccountedData & (1 << reserveType[reserveIds[i]]) > 0);\r\n        }\r\n    }\r\n\r\n    function getEntitledRebateData(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        override\r\n        returns (bool[] memory entitledRebateArr)\r\n    {\r\n        entitledRebateArr = new bool[](reserveIds.length);\r\n\r\n        uint256 entitledRebateData = entitledRebatePerType;\r\n\r\n        for (uint256 i = 0; i < reserveIds.length; i++) {\r\n            entitledRebateArr[i] = (entitledRebateData & (1 << reserveType[reserveIds[i]]) > 0);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns information about reserves given their reserve IDs\r\n    ///      Also check if these reserve IDs are listed for token\r\n    ///      Network calls this function to retrive information about fee, address and rebate information\r\n    function getReservesData(bytes32[] calldata reserveIds, IERC20 src, IERC20 dest)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            bool areAllReservesListed,\r\n            bool[] memory feeAccountedArr,\r\n            bool[] memory entitledRebateArr,\r\n            IKyberReserve[] memory reserveAddresses)\r\n    {\r\n        feeAccountedArr = new bool[](reserveIds.length);\r\n        entitledRebateArr = new bool[](reserveIds.length);\r\n        reserveAddresses = new IKyberReserve[](reserveIds.length);\r\n        areAllReservesListed = true;\r\n\r\n        uint256 entitledRebateData = entitledRebatePerType;\r\n        uint256 feeAccountedData = feeAccountedPerType;\r\n\r\n        mapping(bytes32 => bool) storage isListedReserveWithToken = (dest == ETH_TOKEN_ADDRESS) ?\r\n            isListedReserveWithTokenSrc[src]:\r\n            isListedReserveWithTokenDest[dest];\r\n\r\n        for (uint256 i = 0; i < reserveIds.length; i++) {\r\n            uint256 resType = reserveType[reserveIds[i]];\r\n            entitledRebateArr[i] = (entitledRebateData & (1 << resType) > 0);\r\n            feeAccountedArr[i] = (feeAccountedData & (1 << resType) > 0);\r\n            reserveAddresses[i] = IKyberReserve(reserveIdToAddresses[reserveIds[i]][0]);\r\n\r\n            if (!isListedReserveWithToken[reserveIds[i]]){\r\n                areAllReservesListed = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function delistTokensOfReserve(bytes32 reserveId) internal {\r\n        // token to ether\r\n        // memory declaration instead of storage because we are modifying the storage array\r\n        IERC20[] memory tokensArr = srcTokensPerReserve[reserveId];\r\n        for (uint256 i = 0; i < tokensArr.length; i++) {\r\n            listPairForReserve(reserveId, tokensArr[i], false, true, false);\r\n        }\r\n\r\n        // ether to token\r\n        tokensArr = destTokensPerReserve[reserveId];\r\n        for (uint256 i = 0; i < tokensArr.length; i++) {\r\n            listPairForReserve(reserveId, tokensArr[i], true, false, false);\r\n        }\r\n    }\r\n\r\n    function listPairs(\r\n        bytes32 reserveId,\r\n        IERC20 token,\r\n        bool isTokenToEth,\r\n        bool add\r\n    ) internal {\r\n        uint256 i;\r\n        bytes32[] storage reserveArr = reservesPerTokenDest[token];\r\n        IERC20[] storage tokensArr = destTokensPerReserve[reserveId];\r\n        mapping(bytes32 => bool) storage isListedReserveWithToken = isListedReserveWithTokenDest[token];\r\n\r\n        if (isTokenToEth) {\r\n            reserveArr = reservesPerTokenSrc[token];\r\n            tokensArr = srcTokensPerReserve[reserveId];\r\n            isListedReserveWithToken = isListedReserveWithTokenSrc[token];\r\n        }\r\n\r\n        for (i = 0; i < reserveArr.length; i++) {\r\n            if (reserveId == reserveArr[i]) {\r\n                if (add) {\r\n                    return; // reserve already added, no further action needed\r\n                } else {\r\n                    // remove reserve from reserveArr\r\n                    reserveArr[i] = reserveArr[reserveArr.length - 1];\r\n                    reserveArr.pop();\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (add) {\r\n            // add reserve and token to reserveArr and tokensArr respectively\r\n            reserveArr.push(reserveId);\r\n            tokensArr.push(token);\r\n            isListedReserveWithToken[reserveId] = true;\r\n        } else {\r\n            // remove token from tokenArr\r\n            for (i = 0; i < tokensArr.length; i++) {\r\n                if (token == tokensArr[i]) {\r\n                    tokensArr[i] = tokensArr[tokensArr.length - 1];\r\n                    tokensArr.pop();\r\n                    break;\r\n                }\r\n            }\r\n            delete isListedReserveWithToken[reserveId];\r\n        }\r\n    }\r\n\r\n    function onlyNetwork() internal view {\r\n        require(msg.sender == address(kyberNetwork), \"only kyberNetwork\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"contract IKyberHistory\",\"name\":\"_kyberNetworkHistory\",\"type\":\"address\"},{\"internalType\":\"contract IKyberHistory\",\"name\":\"_kyberFeeHandlerHistory\",\"type\":\"address\"},{\"internalType\":\"contract IKyberHistory\",\"name\":\"_kyberDaoHistory\",\"type\":\"address\"},{\"internalType\":\"contract IKyberHistory\",\"name\":\"_kyberMatchingEngineHistory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enum IKyberStorage.ReserveType\",\"name\":\"reserveType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rebateWallet\",\"type\":\"address\"}],\"name\":\"AddReserveToStorage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IKyberNetwork\",\"name\":\"newKyberNetwork\",\"type\":\"address\"}],\"name\":\"KyberNetworkUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"ListReservePairs\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"}],\"name\":\"RemoveReserveFromStorage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rebateWallet\",\"type\":\"address\"}],\"name\":\"ReserveRebateWalletSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"kyberProxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxApprovedProxies\",\"type\":\"uint256\"}],\"name\":\"addKyberProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"},{\"internalType\":\"enum IKyberStorage.ReserveType\",\"name\":\"resType\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"rebateWallet\",\"type\":\"address\"}],\"name\":\"addReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"kyberDaoAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"kyberFeeHandlerAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"kyberMatchingEngineAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"kyberNetworkAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserveIds\",\"type\":\"bytes32[]\"}],\"name\":\"getEntitledRebateData\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"entitledRebateArr\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserveIds\",\"type\":\"bytes32[]\"}],\"name\":\"getFeeAccountedData\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"feeAccountedArr\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKyberProxies\",\"outputs\":[{\"internalType\":\"contract IKyberNetworkProxy[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"}],\"name\":\"getListedTokensByReserveId\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"srcTokens\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"destTokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserveIds\",\"type\":\"bytes32[]\"}],\"name\":\"getRebateWalletsFromIds\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"rebateWallets\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"}],\"name\":\"getReserveAddressesByReserveId\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"reserveAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserveIds\",\"type\":\"bytes32[]\"}],\"name\":\"getReserveAddressesFromIds\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"reserveAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getReserveAddressesPerTokenSrc\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"reserveAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"}],\"name\":\"getReserveDetailsByAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"rebateWallet\",\"type\":\"address\"},{\"internalType\":\"enum IKyberStorage.ReserveType\",\"name\":\"resType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isFeeAccountedFlag\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEntitledRebateFlag\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"}],\"name\":\"getReserveDetailsById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"reserveAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rebateWallet\",\"type\":\"address\"},{\"internalType\":\"enum IKyberStorage.ReserveType\",\"name\":\"resType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isFeeAccountedFlag\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEntitledRebateFlag\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"}],\"name\":\"getReserveId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"reserveAddresses\",\"type\":\"address[]\"}],\"name\":\"getReserveIdsFromAddresses\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserveIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getReserveIdsPerTokenDest\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserveIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getReserveIdsPerTokenSrc\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserveIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"contract IKyberReserve[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserveIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"contract IERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"getReservesData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"areAllReservesListed\",\"type\":\"bool\"},{\"internalType\":\"bool[]\",\"name\":\"feeAccountedArr\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"entitledRebateArr\",\"type\":\"bool[]\"},{\"internalType\":\"contract IKyberReserve[]\",\"name\":\"reserveAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IKyberStorage.ReserveType\",\"name\":\"resType\",\"type\":\"uint8\"}],\"name\":\"getReservesPerType\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isKyberProxyAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberDaoHistory\",\"outputs\":[{\"internalType\":\"contract IKyberHistory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberFeeHandlerHistory\",\"outputs\":[{\"internalType\":\"contract IKyberHistory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberMatchingEngineHistory\",\"outputs\":[{\"internalType\":\"contract IKyberHistory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberNetwork\",\"outputs\":[{\"internalType\":\"contract IKyberNetwork\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberNetworkHistory\",\"outputs\":[{\"internalType\":\"contract IKyberHistory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"ethToToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"tokenToEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"listPairForReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"kyberProxy\",\"type\":\"address\"}],\"name\":\"removeKyberProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"}],\"name\":\"removeReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kyberFeeHandler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_kyberMatchingEngine\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"fpr\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"apr\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"bridge\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"utility\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"custom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"orderbook\",\"type\":\"bool\"}],\"name\":\"setEntitledRebatePerReserveType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"fpr\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"apr\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"bridge\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"utility\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"custom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"orderbook\",\"type\":\"bool\"}],\"name\":\"setFeeAccountedPerReserveType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kyberDao\",\"type\":\"address\"}],\"name\":\"setKyberDaoContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberNetwork\",\"name\":\"_kyberNetwork\",\"type\":\"address\"}],\"name\":\"setNetworkContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"rebateWallet\",\"type\":\"address\"}],\"name\":\"setRebateWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KyberStorage","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"430","ConstructorArguments":"000000000000000000000000bdd33f411da0b40018922a3bc69001b458227f5c0000000000000000000000009b53d7bb657f5f14a7f73c2d2b90cc084cae1fe4000000000000000000000000e938445b6a3e8c97c86f0a8777254172480b7ffe000000000000000000000000f2bcfcf8892c7279b2743e2fef1893ac622eb38a000000000000000000000000b222bc4e4ffcb39e392c93af9b480019b59f4cc2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://36bd786947542ff9069d9d5126bcf5d10c6c8a5165b7cd728cb7497f92f1a850"}]}