{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/AnchoredView/AnchoredView.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./SymbolConfiguration.sol\\\";\\nimport \\\"../OpenOraclePriceData.sol\\\";\\n\\ninterface AnchorOracle {\\n    function numBlocksPerPeriod() external view returns (uint); // approximately 1 hour: 60 seconds/minute * 60 minutes/hour * 1 block/15 seconds\\n\\n    function assetPrices(address asset) external view returns (uint);\\n\\n    struct Anchor {\\n        // floor(block.number / numBlocksPerPeriod) + 1\\n        uint period;\\n\\n        // Price in ETH, scaled by 10**18\\n        uint priceMantissa;\\n    }\\n    function anchors(address asset) external view returns (Anchor memory);\\n}\\n\\n\\n/**\\n * @notice Price feed conforming to Price Oracle Proxy interface.\\n * @dev Use a single open oracle reporter and anchored to and falling back to the Compound v2 oracle system.\\n * @dev The reporter must report at a minimum the USD/ETH price, so that anchor ETH/TOKEN prices can be converted to USD/TOKEN\\n * @author Compound Labs, Inc.\\n */\\ncontract AnchoredView is SymbolConfiguration {\\n    /// @notice The mapping of anchored reporter prices by symbol\\n    mapping(string => uint) public _prices;\\n\\n    /// @notice Circuit breaker for using anchor price oracle directly, ignoring reporter\\n    bool public reporterBreaker;\\n\\n    /// @notice Circuit breaker for using reporter price without anchor\\n    bool public anchorBreaker;\\n\\n    /// @notice the Open Oracle Reporter price reporter\\n    address public immutable reporter;\\n\\n    /// @notice The anchor oracle ( Compound Oracle V1 )\\n    AnchorOracle public immutable anchor;\\n\\n    /// @notice The Open Oracle Price Data contract\\n    OpenOraclePriceData public immutable priceData;\\n\\n    /// @notice The highest ratio of the new median price to the anchor price that will still trigger the median price to be updated\\n    uint immutable upperBoundAnchorRatio;\\n\\n    /// @notice The lowest ratio of the new median price to the anchor price that will still trigger the median price to be updated\\n    uint immutable lowerBoundAnchorRatio;\\n\\n    /// @notice Average blocks per day, for checking anchor staleness\\n    /// @dev 1 day / 15\\n    uint constant blocksInADay = 5760;\\n\\n    /// @notice The event emitted when the median price is updated\\n    event PriceUpdated(string symbol, uint price);\\n\\n    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\\n    event PriceGuarded(string symbol, uint reporter, uint anchor);\\n\\n    /// @notice The event emitted when reporter invalidates itself\\n    event ReporterInvalidated(address reporter);\\n\\n    /// @notice The event emitted when the anchor is cut for staleness\\n    event AnchorCut(address anchor);\\n\\n    /**\\n     * @param data_ Address of the Oracle Data contract\\n     * @param reporter_ The reporter address whose price will be used if it matches the anchor\\n     * @param anchor_ The PriceOracleProxy that will be used to verify reporter price, or serve prices not given by the reporter\\n     * @param anchorToleranceMantissa_ The tolerance allowed between the anchor and median. A tolerance of 10e16 means a new median that is 10% off from the anchor will still be saved\\n     * @param tokens_ The CTokens struct that contains addresses for CToken contracts\\n     */\\n    constructor(OpenOraclePriceData data_,\\n                address reporter_,\\n                AnchorOracle anchor_,\\n                uint anchorToleranceMantissa_,\\n                CTokens memory tokens_) SymbolConfiguration(tokens_) public {\\n        reporter = reporter_;\\n        anchor = anchor_;\\n        priceData = data_;\\n\\n        require(anchorToleranceMantissa_ < 100e16, \\\"Anchor Tolerance is too high\\\");\\n        upperBoundAnchorRatio = 100e16 + anchorToleranceMantissa_;\\n        lowerBoundAnchorRatio = 100e16 - anchorToleranceMantissa_;\\n    }\\n\\n    /**\\n     * @notice Post open oracle reporter prices, and recalculate stored price by comparing to anchor\\n     * @dev We let anyone pay to post anything, but only prices from configured reporter will be stored in the view\\n     * @param messages The messages to post to the oracle\\n     * @param signatures The signatures for the corresponding messages\\n     * @param symbols The symbols to compare to anchor for authoritative reading\\n     */\\n    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external {\\n        require(messages.length == signatures.length, \\\"messages and signatures must be 1:1\\\");\\n\\n        // Save the prices\\n        for (uint i = 0; i < messages.length; i++) {\\n            priceData.put(messages[i], signatures[i]);\\n        }\\n\\n        // load usdc for using in loop to convert anchor prices to dollars\\n        uint usdcPrice = readAnchor(cUsdcAddress);\\n\\n        // Try to update the view storage\\n        for (uint i = 0; i < symbols.length; i++) {\\n            CTokenMetadata memory tokenConfig = getCTokenConfig(symbols[i]);\\n            // symbol is not supported in the view, but allow writing to data\\n            if (tokenConfig.cTokenAddress == address(0)) continue;\\n\\n            uint reporterPrice = priceData.getPrice(reporter, tokenConfig.openOracleKey);\\n            uint anchorPrice = getAnchorInUsd(tokenConfig, usdcPrice);\\n            \\n            uint anchorRatio = mul(anchorPrice, 100e16) / reporterPrice;\\n            bool withinAnchor = anchorRatio <= upperBoundAnchorRatio && anchorRatio >= lowerBoundAnchorRatio;\\n\\n            if (withinAnchor || anchorBreaker) {\\n                // only update and emit event if value changes\\n                if (_prices[tokenConfig.openOracleKey] != reporterPrice) {\\n                    _prices[tokenConfig.openOracleKey] = reporterPrice;\\n                    emit PriceUpdated(tokenConfig.openOracleKey, reporterPrice);\\n                }\\n            } else {\\n                emit PriceGuarded(tokenConfig.openOracleKey, reporterPrice, anchorPrice);\\n            }\\n        }\\n    }\\n    /**\\n     * @notice Returns price denominated in USD, with 6 decimals\\n     * @dev If price was posted by reporter, return it. Otherwise, return anchor price converted through reporter ETH price.\\n     */\\n    function prices(string calldata symbol) external view returns (uint) {\\n        CTokenMetadata memory tokenConfig = getCTokenConfig(symbol);\\n\\n        if (tokenConfig.priceSource == PriceSource.REPORTER) return _prices[symbol];\\n        if (tokenConfig.priceSource == PriceSource.FIXED_USD) return tokenConfig.fixedReporterPrice;\\n        if (tokenConfig.priceSource == PriceSource.ANCHOR) {\\n            uint usdPerEth = _prices[\\\"ETH\\\"];\\n            require(usdPerEth > 0, \\\"eth price not set, cannot convert eth to dollars\\\");\\n\\n            uint ethPerToken = readAnchor(tokenConfig);\\n            return mul(usdPerEth, ethPerToken) / tokenConfig.baseUnit;\\n        }\\n    }\\n\\n    /**\\n     * @dev fetch price in eth from proxy and convert to usd price using anchor usdc price.\\n     * @dev Anchor price has 36 - underlying decimals, so scale back up to 36 decimals before dividing by by usdc price  (30 decimals), yielding 6 decimal usd price\\n     */\\n    function getAnchorInUsd(address cToken, uint ethPerUsdc) public view returns (uint) {\\n        CTokenMetadata memory tokenConfig = getCTokenConfig(cToken);\\n        return getAnchorInUsd(tokenConfig, ethPerUsdc);\\n    }\\n\\n    function getAnchorInUsd(CTokenMetadata memory tokenConfig, uint ethPerUsdc) internal view returns (uint) {\\n        if (tokenConfig.anchorSource == AnchorSource.FIXED_USD) {\\n            return tokenConfig.fixedAnchorPrice;\\n        }\\n\\n        uint ethPerToken = readAnchor(tokenConfig);\\n\\n        return mul(ethPerToken, tokenConfig.baseUnit) / ethPerUsdc;\\n    }\\n\\n    /**\\n     * @notice Implements the method of the PriceOracle interface of Compound v2 and returns returns the Eth price for an asset.\\n     * @dev converts from 1e6 decimals of Open Oracle to 1e(36 - underlyingDecimals) of PriceOracleProxy\\n     * @param cToken The cToken address for price retrieval\\n     * @return The price for the given cToken address\\n     */\\n    function getUnderlyingPrice(address cToken) public view returns (uint) {\\n        CTokenMetadata memory tokenConfig = getCTokenConfig(cToken);\\n        if (reporterBreaker == true) {\\n            return readAnchor(tokenConfig);\\n        }\\n\\n        if (tokenConfig.priceSource == PriceSource.FIXED_USD) {\\n            uint usdPerToken = tokenConfig.fixedReporterPrice;\\n            return mul(usdPerToken, 1e30) / tokenConfig.baseUnit;\\n        }\\n\\n        if (tokenConfig.priceSource == PriceSource.REPORTER) {\\n            uint usdPerToken = _prices[tokenConfig.openOracleKey];\\n            return mul(usdPerToken, 1e30) / tokenConfig.baseUnit;\\n        }\\n\\n        if (tokenConfig.priceSource == PriceSource.ANCHOR) {\\n            // convert anchor price to usd, via reporter eth price\\n            uint usdPerEth = _prices[\\\"ETH\\\"];\\n            require(usdPerEth != 0, \\\"no reporter price for usd/eth exists, cannot convert anchor price to usd terms\\\");\\n\\n            // factoring out extra 6 decimals from reporter eth price brings us back to decimals given by anchor\\n            uint ethPerToken = readAnchor(tokenConfig);\\n            return mul(usdPerEth, ethPerToken) / 1e6;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the underlying price of a listed cToken asset\\n     * @param cToken The cToken to get the underlying price of\\n     * @return The underlying asset price mantissa (scaled by 1e18)\\n     */\\n    function readAnchor(address cToken) public view returns (uint) {\\n        return readAnchor(getCTokenConfig(cToken));\\n    }\\n\\n    function readAnchor(CTokenMetadata memory tokenConfig) internal view returns (uint) {\\n        if (tokenConfig.anchorSource == AnchorSource.FIXED_ETH) return tokenConfig.fixedAnchorPrice;\\n\\n        return anchor.assetPrices(tokenConfig.anchorOracleKey);\\n    }\\n\\n    /// @notice invalidate the reporter, and fall back to using anchor directly in all cases\\n    function invalidate(bytes memory message, bytes memory signature) public {\\n        (string memory decoded_message, ) = abi.decode(message, (string, address));\\n        require(keccak256(abi.encodePacked(decoded_message)) == keccak256(abi.encodePacked(\\\"rotate\\\")), \\\"invalid message must be 'rotate'\\\");\\n        require(priceData.source(message, signature) == reporter, \\\"invalidation message must come from the reporter\\\");\\n\\n        reporterBreaker = true;\\n        emit ReporterInvalidated(reporter);\\n    }\\n\\n    /// @notice invalidate the anchor, and fall back to using reporter without anchor\\n\\n    /// @dev determine if anchor is stale by checking when usdc was last updated\\n    /// @dev all anchor prices are converted through usdc price, so if it is stale they are all stale\\n    function cutAnchor() external {\\n        AnchorOracle.Anchor memory latestUsdcAnchor = anchor.anchors(cUsdcAnchorKey);\\n\\n        uint usdcAnchorBlockNumber = mul(latestUsdcAnchor.period, anchor.numBlocksPerPeriod());\\n        uint blocksSinceUpdate = block.number - usdcAnchorBlockNumber;\\n\\n        // one day in 15 second blocks without an update\\n        if (blocksSinceUpdate > blocksInADay) {\\n            anchorBreaker = true;\\n            emit AnchorCut(address(anchor));\\n        }\\n    }\\n\\n\\n    // @notice overflow proof multiplication\\n    function mul(uint a, uint b) internal pure returns (uint) {\\n        if (a == 0) return 0;\\n\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0xbcbd4c8dbf1c719257e8dd7403dd43cac206938d2f5544ed6ea6514edcf2c0a8\"\r\n    },\r\n    \"contracts/AnchoredView/SymbolConfiguration.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface CErc20 {\\n    function underlying() external view returns (address);\\n}\\n\\ncontract SymbolConfiguration {\\n    /// special cased anchor oracle keys\\n    address public constant cUsdcAnchorKey = address(1);\\n    address public constant cUsdtAnchorKey = address(1);\\n    address public constant cDaiAnchorKey = address(2);\\n\\n    /// @notice standard amount for the Dollar\\n    uint constant oneDollar = 1e6;\\n\\n    // Address of the oracle key (underlying) for cTokens non special keyed tokens\\n    address public immutable cRepAnchorKey;\\n    address public immutable cWbtcAnchorKey;\\n    address public immutable cBatAnchorKey;\\n    address public immutable cZrxAnchorKey;\\n\\n    // Frozen prices for SAI and eth, so no oracle key\\n    uint public constant saiAnchorPrice = 5285551943761727;\\n    uint public constant ethAnchorPrice = 1e18;\\n\\n    /// @notice The CToken contracts addresses\\n    struct CTokens {\\n        address cEthAddress;\\n        address cUsdcAddress;\\n        address cDaiAddress;\\n        address cRepAddress;\\n        address cWbtcAddress;\\n        address cBatAddress;\\n        address cZrxAddress;\\n        address cSaiAddress;\\n        address cUsdtAddress;\\n    }\\n\\n    enum PriceSource {ANCHOR, FIXED_USD, REPORTER}\\n    enum AnchorSource {ANCHOR, FIXED_USD, FIXED_ETH}\\n\\n    /// @notice Immutable configuration for a cToken\\n    struct CTokenMetadata {\\n        address cTokenAddress;\\n        address anchorOracleKey;\\n        string openOracleKey;\\n        uint baseUnit;\\n        PriceSource priceSource;\\n        AnchorSource anchorSource;\\n        uint fixedAnchorPrice;\\n        uint fixedReporterPrice;\\n    }\\n\\n    // The binary representation for token symbols, used for string comparison\\n    bytes32 constant symbolEth = keccak256(abi.encodePacked(\\\"ETH\\\"));\\n    bytes32 constant symbolUsdc = keccak256(abi.encodePacked(\\\"USDC\\\"));\\n    bytes32 constant symbolDai = keccak256(abi.encodePacked(\\\"DAI\\\"));\\n    bytes32 constant symbolRep = keccak256(abi.encodePacked(\\\"REP\\\"));\\n    bytes32 constant symbolWbtc = keccak256(abi.encodePacked(\\\"BTC\\\"));\\n    bytes32 constant symbolBat = keccak256(abi.encodePacked(\\\"BAT\\\"));\\n    bytes32 constant symbolZrx = keccak256(abi.encodePacked(\\\"ZRX\\\"));\\n    bytes32 constant symbolSai = keccak256(abi.encodePacked(\\\"SAI\\\"));\\n    bytes32 constant symbolUsdt = keccak256(abi.encodePacked(\\\"USDT\\\"));\\n\\n    //  Address of the cToken contracts\\n    address public immutable cEthAddress;\\n    address public immutable cUsdcAddress;\\n    address public immutable cDaiAddress;\\n    address public immutable cRepAddress;\\n    address public immutable cWbtcAddress;\\n    address public immutable cBatAddress;\\n    address public immutable cZrxAddress;\\n    address public immutable cSaiAddress;\\n    address public immutable cUsdtAddress;\\n\\n    /// @param tokens_ The CTokens struct that contains addresses for CToken contracts\\n    constructor(CTokens memory tokens_) public {\\n        cEthAddress = tokens_.cEthAddress;\\n        cUsdcAddress = tokens_.cUsdcAddress;\\n        cDaiAddress = tokens_.cDaiAddress;\\n        cRepAddress = tokens_.cRepAddress;\\n        cWbtcAddress = tokens_.cWbtcAddress;\\n        cBatAddress = tokens_.cBatAddress;\\n        cZrxAddress = tokens_.cZrxAddress;\\n        cSaiAddress = tokens_.cSaiAddress;\\n        cUsdtAddress = tokens_.cUsdtAddress;\\n\\n        cRepAnchorKey = CErc20(tokens_.cRepAddress).underlying();\\n        cWbtcAnchorKey = CErc20(tokens_.cWbtcAddress).underlying();\\n        cBatAnchorKey = CErc20(tokens_.cBatAddress).underlying();\\n        cZrxAnchorKey = CErc20(tokens_.cZrxAddress).underlying();\\n    }\\n\\n    /**\\n     * @notice Returns the CTokenMetadata for a symbol\\n     * @param symbol The symbol to map to cTokenMetadata\\n     * @return The configuration metadata for the symbol\\n     */\\n    function getCTokenConfig(string memory symbol) public view returns (CTokenMetadata memory) {\\n        address cToken = getCTokenAddress(symbol);\\n        return getCTokenConfig(cToken);\\n    }\\n\\n    /**\\n     * @notice Returns the CTokenMetadata for an address\\n     * @param cToken The address to map to cTokenMetadata\\n     * @return The configuration metadata for the address\\n     */\\n    function getCTokenConfig(address cToken) public view returns(CTokenMetadata memory) {\\n        if (cToken == cEthAddress) {\\n            return CTokenMetadata({\\n                        openOracleKey: \\\"ETH\\\",\\n                        anchorOracleKey: address(0),\\n                        baseUnit: 1e18,\\n                        cTokenAddress: cEthAddress,\\n                        priceSource: PriceSource.REPORTER,\\n                        anchorSource: AnchorSource.FIXED_ETH,\\n                        fixedReporterPrice: 0,\\n                        fixedAnchorPrice: 1e18\\n                        });\\n        }\\n\\n        if (cToken == cUsdcAddress) {\\n            return CTokenMetadata({\\n                        openOracleKey: \\\"USDC\\\",\\n                        anchorOracleKey: cUsdcAnchorKey,\\n                        baseUnit: 1e6,\\n                        cTokenAddress: cUsdcAddress,\\n                        priceSource: PriceSource.FIXED_USD,\\n                        anchorSource: AnchorSource.FIXED_USD,\\n                        fixedReporterPrice: oneDollar,\\n                        fixedAnchorPrice: oneDollar\\n                        });\\n        }\\n\\n        if (cToken == cDaiAddress) {\\n            return CTokenMetadata({\\n                        openOracleKey: \\\"DAI\\\",\\n                        anchorOracleKey: cDaiAnchorKey,\\n                        baseUnit: 1e18,\\n                        cTokenAddress: cDaiAddress,\\n                        priceSource: PriceSource.REPORTER,\\n                        anchorSource: AnchorSource.ANCHOR,\\n                        fixedReporterPrice: 0,\\n                        fixedAnchorPrice: 0\\n                        });\\n        }\\n\\n        if (cToken == cRepAddress) {\\n            return CTokenMetadata({\\n                        openOracleKey: \\\"REP\\\",\\n                        anchorOracleKey: cRepAnchorKey,\\n                        baseUnit: 1e18,\\n                        cTokenAddress: cRepAddress,\\n                        priceSource: PriceSource.REPORTER,\\n                        anchorSource: AnchorSource.ANCHOR,\\n                        fixedReporterPrice: 0,\\n                        fixedAnchorPrice: 0\\n                        });\\n        }\\n\\n        if (cToken == cWbtcAddress) {\\n            return CTokenMetadata({\\n                        openOracleKey: \\\"BTC\\\",\\n                        anchorOracleKey: cWbtcAnchorKey,\\n                        baseUnit: 1e8,\\n                        cTokenAddress: cWbtcAddress,\\n                        priceSource: PriceSource.REPORTER,\\n                        anchorSource: AnchorSource.ANCHOR,\\n                        fixedReporterPrice: 0,\\n                        fixedAnchorPrice: 0\\n                        });\\n        }\\n\\n        if (cToken == cBatAddress) {\\n            return CTokenMetadata({\\n                        openOracleKey: \\\"BAT\\\",\\n                        anchorOracleKey: cBatAnchorKey,\\n                        baseUnit: 1e18,\\n                        cTokenAddress: cBatAddress,\\n                        priceSource: PriceSource.REPORTER,\\n                        anchorSource: AnchorSource.ANCHOR,\\n                        fixedReporterPrice: 0,\\n                        fixedAnchorPrice: 0\\n                        });\\n        }\\n\\n        if (cToken == cZrxAddress){\\n            return CTokenMetadata({\\n                        openOracleKey: \\\"ZRX\\\",\\n                        anchorOracleKey: cZrxAnchorKey,\\n                        baseUnit: 1e18,\\n                        cTokenAddress: cZrxAddress,\\n                        priceSource: PriceSource.REPORTER,\\n                        anchorSource: AnchorSource.ANCHOR,\\n                        fixedReporterPrice: 0,\\n                        fixedAnchorPrice: 0\\n                        });\\n        }\\n\\n        if (cToken == cSaiAddress){\\n            return CTokenMetadata({\\n                        openOracleKey: \\\"SAI\\\",\\n                        anchorOracleKey: address(0),\\n                        baseUnit: 1e18,\\n                        cTokenAddress: cSaiAddress,\\n                        priceSource: PriceSource.ANCHOR,\\n                        anchorSource: AnchorSource.FIXED_ETH,\\n                        fixedAnchorPrice: saiAnchorPrice,\\n                        fixedReporterPrice: 0\\n                        });\\n        }\\n\\n        if (cToken == cUsdtAddress){\\n            return CTokenMetadata({\\n                        openOracleKey: \\\"USDT\\\",\\n                        anchorOracleKey: cUsdtAnchorKey,\\n                        baseUnit: 1e6,\\n                        cTokenAddress: cUsdtAddress,\\n                        priceSource: PriceSource.FIXED_USD,\\n                        anchorSource: AnchorSource.FIXED_USD,\\n                        fixedReporterPrice: oneDollar,\\n                        fixedAnchorPrice: oneDollar\\n                        });\\n        }\\n\\n        return CTokenMetadata({\\n                    openOracleKey: \\\"UNCONFIGURED\\\",\\n                    anchorOracleKey: address(0),\\n                    baseUnit: 0,\\n                    cTokenAddress: address(0),\\n                    priceSource: PriceSource.FIXED_USD,\\n                    anchorSource: AnchorSource.FIXED_USD,\\n                    fixedReporterPrice: 0,\\n                    fixedAnchorPrice: 0\\n                    });\\n    }\\n\\n    /**\\n     * @notice Returns the cToken address for symbol\\n     * @param symbol The symbol to map to cToken address\\n     * @return The cToken address for the given symbol\\n     */\\n    function getCTokenAddress(string memory symbol) public view returns (address) {\\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\\n        if (symbolHash == symbolEth) return cEthAddress;\\n        if (symbolHash == symbolUsdc) return cUsdcAddress;\\n        if (symbolHash == symbolDai) return cDaiAddress;\\n        if (symbolHash == symbolRep) return cRepAddress;\\n        if (symbolHash == symbolWbtc) return cWbtcAddress;\\n        if (symbolHash == symbolBat) return cBatAddress;\\n        if (symbolHash == symbolZrx) return cZrxAddress;\\n        if (symbolHash == symbolSai) return cSaiAddress;\\n        if (symbolHash == symbolUsdt) return cUsdtAddress;\\n        return address(0);\\n    }\\n}\\n\\n\",\r\n      \"keccak256\": \"0x96bee5b2a10b8e42c5655e47ea5322edd3dbb267f6ac654891bbb0ce0aa9c172\"\r\n    },\r\n    \"contracts/OpenOracleData.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title The Open Oracle Data Base Contract\\n * @author Compound Labs, Inc.\\n */\\ncontract OpenOracleData {\\n    /**\\n     * @notice The event emitted when a source writes to its storage\\n     */\\n    //event Write(address indexed source, <Key> indexed key, string kind, uint64 timestamp, <Value> value);\\n\\n    /**\\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\\n     * @param message The payload containing the timestamp, and (key, value) pairs\\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\\n     * @return The keys that were written\\n     */\\n    //function put(bytes calldata message, bytes calldata signature) external returns (<Key> memory);\\n\\n    /**\\n     * @notice Read a single key with a pre-defined type signature from an authenticated source\\n     * @param source The verifiable author of the data\\n     * @param key The selector for the value to return\\n     * @return The claimed Unix timestamp for the data and the encoded value (defaults to (0, 0x))\\n     */\\n    //function get(address source, <Key> key) external view returns (uint, <Value>);\\n\\n    /**\\n     * @notice Recovers the source address which signed a message\\n     * @dev Comparing to a claimed address would add nothing,\\n     *  as the caller could simply perform the recover and claim that address.\\n     * @param message The data that was presumably signed\\n     * @param signature The fingerprint of the data + private key\\n     * @return The source address which signed the message, presumably\\n     */\\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\\n        bytes32 hash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(message)));\\n        return ecrecover(hash, v, r, s);\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0xa55b2aeabb1602765cbf02cad459390e448e696cde1300c231f428434f882c4a\"\r\n    },\r\n    \"contracts/OpenOraclePriceData.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\nimport \\\"./OpenOracleData.sol\\\";\\n\\n/**\\n * @title The Open Oracle Price Data Contract\\n * @notice Values stored in this contract should represent a USD price with 6 decimals precision\\n * @author Compound Labs, Inc.\\n */\\ncontract OpenOraclePriceData is OpenOracleData {\\n    ///@notice The event emitted when a source writes to its storage\\n    event Write(address indexed source, string key, uint64 timestamp, uint64 value);\\n    ///@notice The event emitted when the timestamp on a price is invalid and it is not written to storage\\n    event NotWritten(uint64 priorTimestamp, uint256 messageTimestamp, uint256 blockTimestamp);\\n\\n    ///@notice The fundamental unit of storage for a reporter source\\n    struct Datum {\\n        uint64 timestamp;\\n        uint64 value;\\n    }\\n\\n    /**\\n     * @notice The most recent authenticated data from all sources\\n     * @dev This is private because dynamic mapping keys preclude auto-generated getters.\\n     */\\n    mapping(address => mapping(string => Datum)) private data;\\n\\n    /**\\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\\n     * @param message The payload containing the timestamp, and (key, value) pairs\\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\\n     * @return The keys that were written\\n     */\\n    function put(bytes calldata message, bytes calldata signature) external returns (string memory) {\\n        // Recover the source address\\n        address source = source(message, signature);\\n\\n        // Decode the message and check the kind\\n        (string memory kind, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (string, uint64, string, uint64));\\n        require(keccak256(abi.encodePacked(kind)) == keccak256(abi.encodePacked(\\\"prices\\\")), \\\"Kind of data must be 'prices'\\\");\\n\\n        // Only update if newer than stored, according to source\\n        Datum storage prior = data[source][key];\\n        if (timestamp > prior.timestamp && timestamp < block.timestamp + 60 minutes) {\\n            data[source][key] = Datum(timestamp, value);\\n            emit Write(source, key, timestamp, value);\\n        } else {\\n            emit NotWritten(prior.timestamp, timestamp, block.timestamp);\\n        }\\n\\n        return key;\\n    }\\n\\n    /**\\n     * @notice Read a single key from an authenticated source\\n     * @param source The verifiable author of the data\\n     * @param key The selector for the value to return\\n     * @return The claimed Unix timestamp for the data and the price value (defaults to (0, 0))\\n     */\\n    function get(address source, string calldata key) external view returns (uint64, uint64) {\\n        Datum storage datum = data[source][key];\\n        return (datum.timestamp, datum.value);\\n    }\\n\\n    /**\\n     * @notice Read only the value for a single key from an authenticated source\\n     * @param source The verifiable author of the data\\n     * @param key The selector for the value to return\\n     * @return The price value (defaults to 0)\\n     */\\n    function getPrice(address source, string calldata key) external view returns (uint64) {\\n        return data[source][key].value;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x10642bfbde061228b3c51bc7c53d4c442d0fe57124b344d107ac8301ffdfb5a2\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract OpenOraclePriceData\",\"name\":\"data_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reporter_\",\"type\":\"address\"},{\"internalType\":\"contract AnchorOracle\",\"name\":\"anchor_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"anchorToleranceMantissa_\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"cEthAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cUsdcAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cDaiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cRepAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cWbtcAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cBatAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cZrxAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cSaiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cUsdtAddress\",\"type\":\"address\"}],\"internalType\":\"struct SymbolConfiguration.CTokens\",\"name\":\"tokens_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"anchor\",\"type\":\"address\"}],\"name\":\"AnchorCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reporter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anchor\",\"type\":\"uint256\"}],\"name\":\"PriceGuarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reporter\",\"type\":\"address\"}],\"name\":\"ReporterInvalidated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"_prices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"anchor\",\"outputs\":[{\"internalType\":\"contract AnchorOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"anchorBreaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cBatAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cBatAnchorKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cDaiAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cDaiAnchorKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cEthAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cRepAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cRepAnchorKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cSaiAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cUsdcAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cUsdcAnchorKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cUsdtAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cUsdtAnchorKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cWbtcAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cWbtcAnchorKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cZrxAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cZrxAnchorKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cutAnchor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethAnchorPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethPerUsdc\",\"type\":\"uint256\"}],\"name\":\"getAnchorInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getCTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getCTokenConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"anchorOracleKey\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"openOracleKey\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum SymbolConfiguration.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"enum SymbolConfiguration.AnchorSource\",\"name\":\"anchorSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedAnchorPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedReporterPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct SymbolConfiguration.CTokenMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getCTokenConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"anchorOracleKey\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"openOracleKey\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum SymbolConfiguration.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"enum SymbolConfiguration.AnchorSource\",\"name\":\"anchorSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedAnchorPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedReporterPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct SymbolConfiguration.CTokenMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"invalidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"messages\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"},{\"internalType\":\"string[]\",\"name\":\"symbols\",\"type\":\"string[]\"}],\"name\":\"postPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceData\",\"outputs\":[{\"internalType\":\"contract OpenOraclePriceData\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"readAnchor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reporter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reporterBreaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saiAnchorPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AnchoredView","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000541e90aadfbb653843ea9b5dec43fe2cceca0dd6000000000000000000000000fceadafab14d46e20144f48824d0c09b1a03f2bc00000000000000000000000002557a5e05defeffd4cae6d83ea3d173b272c904000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000004ddc2d193948926d02f9b1fe9e1daa0718270ed500000000000000000000000039aa39c021dfbae8fac545936693ac917d5e75630000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643000000000000000000000000158079ee67fce2f58472a96584a73c7ab9ac95c1000000000000000000000000c11b1268c1a384e55c48c2391d8d480264a3a7f40000000000000000000000006c8c6b02e7b2be14d4fa6022dfd6d75921d90e4e000000000000000000000000b3319f5d18bc0d84dd1b4825dcde5d5f7266d407000000000000000000000000f5dce57282a584d2746faf1593d3121fcac444dc000000000000000000000000f650c3d88d12db855b8bf7d11be6c55a4e07dcc9","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}