{"status":"1","message":"OK","result":[{"SourceCode":"{\"EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.9;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n\\n    struct AddressSet {\\n        // Storage of set values\\n        address[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (address =\\u003e uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        if (!contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\n\\n            address lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        require(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n}\\n\"},\"Escrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.9;\\r\\n\\r\\n// TODO: \\r\\n// replace https://github.com/jointerinc/jointer-token/blob/0c91e462b2efd61e1541b6f6c5de27d4e6ea53fc/contracts/Auction/Auction.sol#L911-L916\\r\\n// with approve Escrow contract to transfer and call depositFee(uint256 value) in Escrow contract.\\r\\n\\r\\n// After deploy and setup tokenContract and gatewayContract addresses need to change the Owner address to the GovernanceProxy (Escrowed) address.\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./EnumerableSet.sol\\\";\\r\\n\\r\\n// The GovernanceProxy contract address should be the Owner of other contracts which setting we will change.\\r\\ninterface IGovernanceProxy {\\r\\n    function governance() external returns(address);    // Voting contract address\\r\\n}\\r\\n\\r\\ninterface IGovernance {\\r\\n    function addPremintedWallet(address wallet) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface  IGateway {\\r\\n    function getChannelsNumber() external view returns(uint256);\\r\\n}\\r\\n\\r\\ninterface IERC20Token {\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n    function transfer(address _to, uint256 _value) external returns (bool);\\r\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\r\\n    function approve(address _spender, uint256 _value) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IAuctionLiquidity {\\r\\n    function redemptionFromEscrow(address[] calldata _path, uint256 _amount, address payable _sender) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface ISmartSwapP2P {\\r\\n    function sendTokenFormEscrow(address token, uint amount, address payable sender) external; \\r\\n}\\r\\n\\r\\ninterface IAuctionRegistery {\\r\\n    function getAddressOf(bytes32 _contractName) external view returns (address payable);\\r\\n}\\r\\n\\r\\ninterface ICurrencyPrices {\\r\\n    function getCurrencyPrice(address _which) external view returns (uint256);\\r\\n}\\r\\n\\r\\ncontract AuctionRegistery is Ownable {\\r\\n    bytes32 internal constant SMART_SWAP_P2P = \\\"SMART_SWAP_P2P\\\";\\r\\n    bytes32 internal constant LIQUIDITY = \\\"LIQUIDITY\\\";\\r\\n    bytes32 internal constant CURRENCY = \\\"CURRENCY\\\";\\r\\n    IAuctionRegistery public contractsRegistry;\\r\\n    IAuctionLiquidity public liquidityContract;\\r\\n    ISmartSwapP2P public smartswapContract;\\r\\n    ICurrencyPrices public currencyPricesContract;\\r\\n\\r\\n    function updateRegistery(address _address) external onlyOwner returns (bool)\\r\\n    {\\r\\n        require(_address != address(0),\\\"Zero address\\\");\\r\\n        contractsRegistry = IAuctionRegistery(_address);\\r\\n        _updateAddresses();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getAddressOf(bytes32 _contractName)\\r\\n        internal\\r\\n        view\\r\\n        returns (address payable)\\r\\n    {\\r\\n        return contractsRegistry.getAddressOf(_contractName);\\r\\n    }\\r\\n\\r\\n    /**@dev updates all the address from the registry contract\\r\\n    this decision was made to save gas that occurs from calling an external view function */\\r\\n\\r\\n    function _updateAddresses() internal {\\r\\n        liquidityContract = IAuctionLiquidity(getAddressOf(LIQUIDITY));\\r\\n        smartswapContract = ISmartSwapP2P(getAddressOf(SMART_SWAP_P2P));\\r\\n        currencyPricesContract = ICurrencyPrices(getAddressOf(CURRENCY));\\r\\n    }\\r\\n\\r\\n     function updateAddresses() external returns (bool) {\\r\\n        _updateAddresses();\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Escrow is AuctionRegistery {\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n\\r\\n    uint256 internal constant DECIMAL_NOMINATOR = 10**18;\\r\\n    uint256 internal constant BUYBACK = 1 \\u003c\\u003c 251;\\r\\n    uint256 internal constant SMARTSWAP_P2P = 1 \\u003c\\u003c 252;\\r\\n    IERC20Token public tokenContract;\\r\\n    address public governanceContract;  // public Governance contract address\\r\\n    address payable public companyWallet;\\r\\n    address payable public gatewayContract;\\r\\n\\r\\n    struct Order {\\r\\n        address payable seller;\\r\\n        address payable buyer;\\r\\n        uint256 sellValue;  // how many token sell\\r\\n        address wantToken;  // which token want to receive\\r\\n        uint256 wantValue;  // the value want to receive\\r\\n        uint256 status;     // 1 - created, 2 - completed; 3 - canceled; 4 -restricted\\r\\n        address confirmatory;   // the address third person who confirm transaction, if order is restricted.\\r\\n    }\\r\\n\\r\\n    Order[] orders;\\r\\n    \\r\\n    struct Unpaid {\\r\\n        uint256 soldValue;\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    struct Group {\\r\\n        uint256 rate;\\r\\n        EnumerableSet.AddressSet wallets;\\r\\n        uint256 restriction;    // bitmap, where 1 allows to use that channel (1 \\u003c\\u003c channel ID)\\r\\n        mapping(uint256 =\\u003e uint256) onSale; // total amount of tokens on sale in group by channel (Channel =\\u003e Value)\\r\\n        mapping(uint256 =\\u003e uint256) soldUnpaid; // total amount of sold tokens but still not spitted pro-rata in group by channel (Channel =\\u003e Value)\\r\\n        mapping(uint256 =\\u003e EnumerableSet.AddressSet) addressesOnChannel;   // list of address on the Liquidity channel\\r\\n        mapping(uint256 =\\u003e mapping(address =\\u003e Unpaid)) unpaid;  // ETH / ERC20 tokens ready to split pro-rata (ETH = address(0))\\r\\n    }\\r\\n\\r\\n    // Groups ID: 0 - Company, 1 - Investors with goal, 2 - Main group, 3 - Restricted\\r\\n    Group[] groups;\\r\\n    mapping(address =\\u003e uint256) public inGroup;   // Wallet to Group mapping. 0 - wallet not added, 1+ - group id (1-based)\\r\\n    // Liquidity Channel ID: 0 - Company 1 - SmartSwap P2C, 2 - Secondary Market (Crypto Exchanges)\\r\\n    mapping(uint256 =\\u003e uint256) public totalOnSale;     // total token amount on sale by channel\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public onSale;  // How many tokens the wallet want to sell (Wallet =\\u003e Channel =\\u003e Value)\\r\\n    mapping(address =\\u003e uint256) public goals;   // The amount in USD (decimals = 9), that investor should receive before splitting liquidity with others members\\r\\n\\r\\n    uint256 public totalSupply;\\r\\n    mapping(address =\\u003e uint256) balances;\\r\\n    mapping(address =\\u003e uint256) balancesETH;    // In case ETH sands failed, user can withdraw ETH using withdraw function\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event TransferGateway(address indexed to, uint256 indexed channelId, uint256 value);\\r\\n    event GroupRate(uint256 indexed groupId, uint256 rate);\\r\\n    event PutOnSale(address indexed from, uint256 value);\\r\\n    event RemoveFromSale(address indexed from, uint256 value);\\r\\n    event PaymentFromGateway(uint256 indexed channelId, address indexed token, uint256 value, uint256 soldValue);\\r\\n    event SellOrder(address indexed seller, address indexed buyer, uint256 value, address wantToken, uint256 wantValue, uint256 indexed orderId);\\r\\n    event RestrictedOrder(address indexed seller, address indexed buyer, uint256 value, address wantToken, uint256 wantValue, uint256 indexed orderId, address confirmatory);\\r\\n    event ReceivedETH(address indexed from, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the companyWallet.\\r\\n     */\\r\\n    modifier onlyCompany() {\\r\\n        require(companyWallet == msg.sender,\\\"Not Company\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the gatewayContract.\\r\\n     */\\r\\n    modifier onlyGateway() {\\r\\n        require(gatewayContract == msg.sender,\\\"Not Gateway\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address payable _companyWallet) public {\\r\\n        _nonZeroAddress(_companyWallet);\\r\\n        companyWallet = _companyWallet;\\r\\n        // Groups rete: Company = 100%, Investors = 0%, Main = 0%, Restricted = 0%\\r\\n        uint256[4] memory groupRate = [uint256(100),0,0,0];\\r\\n        for (uint i = 0; i \\u003c 4; i++) {\\r\\n            groups.push();\\r\\n            groups[i].rate = groupRate[i];\\r\\n        }\\r\\n        groups[0].restriction = 1; // allow company to use Gateway supply channel (0)\\r\\n        orders.push();  // order ID starts from 1. Zero order ID means - no order\\r\\n    }\\r\\n\\r\\n    // Safe Math subtract function\\r\\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    // Safe Math add function\\r\\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set token contract address.\\r\\n     * @param newAddress The address of token contract.\\r\\n     */\\r\\n    function setTokenContract(IERC20Token newAddress) external onlyOwner {\\r\\n        require(newAddress != IERC20Token(0) \\u0026\\u0026 tokenContract == IERC20Token(0),\\\"Change address not allowed\\\");\\r\\n        tokenContract = newAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set gateway contract address\\r\\n     * @param newAddress The address of gateway contract.\\r\\n     */\\r\\n    function setGatewayContract(address payable newAddress) external onlyOwner {\\r\\n        _nonZeroAddress(newAddress);\\r\\n        gatewayContract = newAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set governance (the main governance for public communities) contract address.\\r\\n     * Uses to add addresses of escrowed (pre-minted) wallets to the isInEscrow list in Governance contract.\\r\\n     * @param newAddress The address of governance contract.\\r\\n     */\\r\\n    function setGovernanceContract(address payable newAddress) external onlyOwner {\\r\\n        _nonZeroAddress(newAddress);\\r\\n        governanceContract = newAddress;\\r\\n    }\\r\\n\\r\\n    function updateCompanyAddress(address payable newAddress) external onlyCompany {\\r\\n        require(inGroup[newAddress] == 0, \\\"Wallet already added\\\");\\r\\n        _nonZeroAddress(newAddress);\\r\\n        balances[newAddress] = balances[companyWallet];\\r\\n        groups[0].wallets.remove(companyWallet);    // remove from company group\\r\\n        inGroup[companyWallet] = 0;\\r\\n        balances[companyWallet] = 0;\\r\\n        // request number of channels from Gateway\\r\\n        uint channels = _getChannelsNumber();\\r\\n        for (uint i = 0; i \\u003c channels; i++) {   // exclude channel 0. It allow company to wire tokens for Gateway supply\\r\\n            if (onSale[companyWallet][i] \\u003e 0) {\\r\\n                onSale[newAddress][i] = onSale[companyWallet][i];\\r\\n                onSale[companyWallet][i] = 0;\\r\\n                groups[0].addressesOnChannel[i].add(newAddress);\\r\\n                groups[0].addressesOnChannel[i].remove(companyWallet);\\r\\n            }\\r\\n        }\\r\\n        _addPremintedWallet(newAddress, 0); // add company wallet to the company group.\\r\\n        companyWallet = newAddress;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Add all pre-minted tokens to the company wallet.\\r\\n     */\\r\\n    function init() external onlyOwner {\\r\\n        require(inGroup[companyWallet] == 0, \\\"Already init\\\");\\r\\n        uint256 balance = tokenContract.balanceOf(address(this));\\r\\n        require(balance \\u003e 0, \\\"No pre-minted tokens\\\");\\r\\n        balances[companyWallet] = balance; //Transfer all pre-minted tokens to company wallet.\\r\\n        _addPremintedWallet(companyWallet, 0); // add company wallet to the company group.\\r\\n        totalSupply = safeAdd(totalSupply, balance);\\r\\n        emit Transfer(address(0), companyWallet, balance);\\r\\n    }\\r\\n\\r\\n    function setGroupRestriction(uint256 groupId, uint256 restriction) external onlyOwner {\\r\\n        groups[groupId].restriction = restriction;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Get details of selected group\\r\\n     * @param groupId The group ID.\\r\\n     * @return rate The rate of group.\\r\\n     * @return membersNumber The number of members in group.\\r\\n     * @return restriction The bitmap, where 1 allows to use that channel (1 \\u003c\\u003c channel ID)\\r\\n     */\\r\\n    function getGroupDetails(uint256 groupId) external view returns(uint256 rate, uint256 membersNumber, uint256 restriction) {\\r\\n        return (groups[groupId].rate, groups[groupId].wallets.length(), groups[groupId].restriction);\\r\\n    }\\r\\n\\r\\n    function getGroupsNumber() external view returns(uint256 number) {\\r\\n        return groups.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Get members of selected group\\r\\n     * @param groupId The group ID.\\r\\n     * @return wallets The list of addresses.\\r\\n     */\\r\\n    function getGroupMembers(uint256 groupId) external view returns(address[] memory wallets) {\\r\\n        return groups[groupId].wallets._values;\\r\\n    }\\r\\n    \\r\\n    // Move user from one group to another\\r\\n    function moveToGroup(address wallet, uint256 toGroup) external onlyOwner {\\r\\n        require(goals[wallet] == 0, \\\"Wallet with goal can\\u0027t be moved\\\");\\r\\n        _moveToGroup(wallet, toGroup, false);\\r\\n    }\\r\\n\\r\\n    function addGroup(uint256 rate) external onlyOwner {\\r\\n        uint256 groupId = groups.length;\\r\\n        groups.push();\\r\\n        groups[groupId].rate = rate;\\r\\n        emit GroupRate(groupId, rate);\\r\\n    }\\r\\n\\r\\n    function changeGroupRate(uint256 groupId, uint256 rate) external onlyOwner {\\r\\n        groups[groupId].rate = rate;\\r\\n        emit GroupRate(groupId, rate);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Get list of addresses in the group on the selected Liquidity Channel\\r\\n     * @param groupId The group ID.\\r\\n     * @param channelId Liquidity Channel ID.\\r\\n     * @return wallets The list of addresses.\\r\\n     */\\r\\n    function getAddressesOnChannel(uint256 groupId, uint256 channelId) external view returns(address[] memory wallets) {\\r\\n        return groups[groupId].addressesOnChannel[channelId]._values;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Create new wallet in Escrow contract\\r\\n     * @param newWallet The wallet address\\r\\n     * @param groupId The group ID. Wallet with goal can be added only in group 1\\r\\n     * @param value The amount of token transfer from company wallet to created wallet\\r\\n     * @param goal The amount in USD, that investor should receive before splitting liquidity with others members\\r\\n     * @return true when if wallet created.\\r\\n     */\\r\\n    function createWallet(address newWallet, uint256 groupId, uint256 value, uint256 goal) external onlyCompany returns(bool){\\r\\n        require(inGroup[newWallet] == 0, \\\"Wallet already added\\\");\\r\\n        if (goal != 0) {\\r\\n            require(groupId == 1, \\\"Wallet with goal disallowed\\\");\\r\\n            goals[newWallet] = goal;\\r\\n        }\\r\\n        _addPremintedWallet(newWallet, groupId);\\r\\n        return _transfer(newWallet, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deposit fee from Auction contract and add it to the Company wallet.\\r\\n     * @param value The fee value.\\r\\n     */\\r\\n    function depositFee(uint256 value) external {\\r\\n        require(tokenContract.transferFrom(msg.sender, address(this), value),\\\"Transfer failed\\\");\\r\\n        balances[companyWallet] = safeAdd(balances[companyWallet], value);\\r\\n        totalSupply = safeAdd(totalSupply, value);\\r\\n        emit Transfer(msg.sender, address(this), value);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev transfer token for a specified address into Escrow contract\\r\\n     * @param to The address to transfer to.\\r\\n     * @param value The amount to be transferred.\\r\\n     */\\r\\n    function transfer(address to, uint256 value) external returns (bool) {\\r\\n        require(inGroup[to] != 0, \\\"Wallet not added\\\");\\r\\n        uint256 groupId = _getGroupId(msg.sender);\\r\\n        require(groups[groupId].restriction != 0,\\\"Group is restricted\\\");\\r\\n        return _transfer(to, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev transfer token for a specified address into Escrow contract from restricted group\\r\\n     * @param to The address to transfer to.\\r\\n     * @param value The amount to be transferred.\\r\\n     * @param confirmatory The address of third party who have to confirm this transfer\\r\\n     */\\r\\n    function transferRestricted(address to, uint256 value, address confirmatory) external {\\r\\n        _nonZeroAddress(confirmatory);\\r\\n        require(inGroup[to] != 0, \\\"Wallet not added\\\");\\r\\n        require(msg.sender != confirmatory \\u0026\\u0026 to != confirmatory, \\\"Wrong confirmatory address\\\");\\r\\n        _restrictedOrder(value, address(0), 0, payable(to), confirmatory);   // Create restricted order where wantValue = 0.\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the balance of the specified address.\\r\\n     * @param _who The address to query the the balance of.\\r\\n     * @return balance An uint256 representing the amount owned by the passed address.\\r\\n     */\\r\\n    function balanceOf(address _who) public view returns (uint256 balance) {\\r\\n        return balances[_who];\\r\\n    }\\r\\n\\r\\n    // Redeem via BuyBack if allowed\\r\\n    function redemption(address[] calldata path, uint256 value) external {\\r\\n        require(balances[msg.sender] \\u003e= value, \\\"Not enough balance\\\");\\r\\n        uint256 groupId = _getGroupId(msg.sender);\\r\\n        require(groups[groupId].restriction \\u0026 BUYBACK \\u003e 0, \\\"BuyBack disallowed\\\");\\r\\n        balances[msg.sender] = safeSub(balances[msg.sender], value);\\r\\n        tokenContract.approve(address(liquidityContract), value);\\r\\n        totalSupply = safeSub(totalSupply, value);\\r\\n        require(liquidityContract.redemptionFromEscrow(path, value, msg.sender), \\\"Redemption failed\\\");\\r\\n    }\\r\\n\\r\\n    // Send token to SmartSwap P2P\\r\\n    function samartswapP2P(uint256 value) external {\\r\\n        require(balances[msg.sender] \\u003e= value, \\\"Not enough balance\\\");\\r\\n        uint256 groupId = _getGroupId(msg.sender);\\r\\n        require(groups[groupId].restriction \\u0026 SMARTSWAP_P2P \\u003e 0, \\\"SmartSwap P2P disallowed\\\");\\r\\n        balances[msg.sender] = safeSub(balances[msg.sender], value);\\r\\n        totalSupply = safeSub(totalSupply, value);\\r\\n        tokenContract.approve(address(smartswapContract), value);\\r\\n        smartswapContract.sendTokenFormEscrow(address(tokenContract), value, msg.sender);\\r\\n    }\\r\\n\\r\\n    // Receive token from SmartSwap P2P in case order canceled. Called from SmartSwap P2P contract\\r\\n    function canceledP2P(address user, uint256 value) external returns(bool) {\\r\\n        require(tokenContract.transferFrom(msg.sender, address(this), value),\\\"Cancel P2P failed\\\");\\r\\n        balances[user] = safeAdd(balances[user], value);\\r\\n        totalSupply = safeAdd(totalSupply, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Sell tokens to other user (inside Escrow contract).\\r\\n    function sellToken(uint256 sellValue, address wantToken, uint256 wantValue, address payable buyer) external {\\r\\n        require(sellValue \\u003e 0, \\\"Zero sell value\\\");\\r\\n        require(balances[msg.sender] \\u003e= sellValue, \\\"Not enough balance\\\");\\r\\n        require(inGroup[buyer] != 0, \\\"Wallet not added\\\");        \\r\\n        uint256 groupId = _getGroupId(msg.sender);\\r\\n        require(groups[groupId].restriction != 0,\\\"Group is restricted\\\");\\r\\n        balances[msg.sender] = safeSub(balances[msg.sender], sellValue);\\r\\n        uint256 orderId = orders.length;\\r\\n        orders.push(Order(msg.sender, buyer, sellValue, wantToken, wantValue, 1, address(0)));\\r\\n        emit SellOrder(msg.sender, buyer, sellValue, wantToken, wantValue, orderId);\\r\\n    }\\r\\n\\r\\n    // Sell tokens to other user (inside Escrow contract) from restricted group.\\r\\n    function sellTokenRestricted(uint256 sellValue, address wantToken, uint256 wantValue, address payable buyer, address confirmatory) external {\\r\\n        _nonZeroAddress(confirmatory);\\r\\n        require(inGroup[buyer] != 0, \\\"Wallet not added\\\");\\r\\n        require(balances[msg.sender] \\u003e= sellValue, \\\"Not enough balance\\\");\\r\\n        require(msg.sender != confirmatory \\u0026\\u0026 buyer != confirmatory, \\\"Wrong confirmatory address\\\");\\r\\n        _restrictedOrder(sellValue, wantToken, wantValue, buyer, confirmatory);\\r\\n    }\\r\\n\\r\\n\\r\\n    // confirm restricted order by third-party confirmatory address\\r\\n    function confirmOrder(uint256 orderId) external {\\r\\n        Order storage o = orders[orderId];\\r\\n        require(o.confirmatory == msg.sender, \\\"Not a confirmatory\\\");\\r\\n        if (o.wantValue == 0) { // if it\\u0027s simple transfer, complete it immediately.\\r\\n            balances[o.buyer] = safeAdd(balances[o.buyer], o.sellValue);\\r\\n            o.status = 2;   // complete\\r\\n        }\\r\\n        else {\\r\\n            o.status = 1;   // remove restriction\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // cancel sell order\\r\\n    function cancelOrder(uint256 orderId) external {\\r\\n        Order storage o = orders[orderId];\\r\\n        require(msg.sender == o.seller || msg.sender == o.buyer, \\\"You can\\u0027t cancel\\\");\\r\\n        require(o.status == 1 || o.status == 4, \\\"Wrong order\\\"); // user can cancel restricted order too.\\r\\n        balances[o.seller] = safeAdd(balances[o.seller], o.sellValue);\\r\\n        o.status = 3;   // cancel\\r\\n    }\\r\\n\\r\\n    // get order info. Status 1 - created, 2 - completed, 3 - canceled.\\r\\n    function getOrder(uint256 orderId) external view returns(\\r\\n        address seller,\\r\\n        address buyer,\\r\\n        uint256 sellValue,\\r\\n        address wantToken,\\r\\n        uint256 wantValue,\\r\\n        uint256 status,\\r\\n        address confirmatory)\\r\\n    {\\r\\n        Order storage o = orders[orderId];\\r\\n        return (o.seller, o.buyer, o.sellValue, o.wantToken, o.wantValue, o.status, o.confirmatory);\\r\\n    }\\r\\n\\r\\n    // get total number of orders\\r\\n    function getOrdersNumber() external view returns(uint256 number) {\\r\\n        return orders.length;\\r\\n    }\\r\\n\\r\\n    // get the last order ID where msg.sender is buyer or seller.\\r\\n    function getLastAvailableOrder() external view returns(uint256 orderId)\\r\\n    {\\r\\n        uint len = orders.length;\\r\\n        while(len \\u003e 0) {\\r\\n            len--;\\r\\n            Order storage o = orders[len];\\r\\n            if (o.status == 1 \\u0026\\u0026 (o.seller == msg.sender || o.buyer == msg.sender)) {\\r\\n                return len;\\r\\n            }\\r\\n        }\\r\\n        return 0; // No orders available\\r\\n    }\\r\\n\\r\\n    // get the last order ID where msg.sender is confirmatory address.\\r\\n    function getLastOrderToConfirm() external view returns(uint256 orderId) {\\r\\n        uint len = orders.length;\\r\\n        while(len \\u003e 0) {\\r\\n            len--;\\r\\n            Order storage o = orders[len];\\r\\n            if (o.status == 4 \\u0026\\u0026 o.confirmatory == msg.sender) {\\r\\n                return len;\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    // buy selected order (ID). If buy using ERC20 token, the amount should be approved for Escrow contract.\\r\\n    function buyOrder(uint256 orderId) external payable {\\r\\n        require(inGroup[msg.sender] != 0, \\\"Wallet not added\\\");\\r\\n        Order storage o = orders[orderId];\\r\\n        require(msg.sender == o.buyer, \\\"Wrong buyer\\\");\\r\\n        require(o.status == 1, \\\"Wrong order status\\\");\\r\\n        if (o.wantValue \\u003e 0) {\\r\\n            if (o.wantToken == address(0)) {\\r\\n                require(msg.value == o.wantValue, \\\"Wrong value\\\");\\r\\n                o.seller.transfer(msg.value);\\r\\n            }\\r\\n            else {\\r\\n                require(IERC20Token(o.wantToken).transferFrom(msg.sender, o.seller, o.wantValue), \\\"Not enough value\\\");\\r\\n            }\\r\\n        }\\r\\n        balances[msg.sender] = safeAdd(balances[msg.sender], o.sellValue);\\r\\n        o.status = 2;   // complete\\r\\n    }\\r\\n\\r\\n    // Put token on sale on selected channel\\r\\n    function putOnSale(uint256 value, uint256 channelId) external {\\r\\n        require(balances[msg.sender] \\u003e= value, \\\"Not enough balance\\\");\\r\\n        uint256 groupId = _getGroupId(msg.sender);\\r\\n        require(groups[groupId].restriction \\u0026 (1 \\u003c\\u003c channelId) \\u003e 0, \\\"Liquidity channel disallowed\\\");\\r\\n        require(groups[groupId].soldUnpaid[channelId] == 0, \\\"There is unpaid giveaways\\\");\\r\\n        balances[msg.sender] = safeSub(balances[msg.sender], value);\\r\\n        totalSupply = safeSub(totalSupply, value);\\r\\n        groups[groupId].addressesOnChannel[channelId].add(msg.sender);  // the case that wallet already in list, checks in add function\\r\\n        onSale[msg.sender][channelId] = safeAdd(onSale[msg.sender][channelId], value);\\r\\n        totalOnSale[channelId] = safeAdd(totalOnSale[channelId], value);\\r\\n        groups[groupId].onSale[channelId] = safeAdd(groups[groupId].onSale[channelId], value);\\r\\n        emit PutOnSale(msg.sender, value);\\r\\n    }\\r\\n\\r\\n    // Remove token form sale on selected channel if it was not transferred to the Gateway.\\r\\n    function removeFromSale(uint256 value, uint256 channelId) external {\\r\\n        //if amount on sale less then requested, then remove entire amount.\\r\\n        if (onSale[msg.sender][channelId] \\u003c value) {\\r\\n            value = onSale[msg.sender][channelId];\\r\\n        }\\r\\n        require(totalOnSale[channelId] \\u003e= value, \\\"Not enough on sale\\\");\\r\\n        uint groupId = _getGroupId(msg.sender);\\r\\n        require(groups[groupId].soldUnpaid[channelId] == 0, \\\"There is unpaid giveaways\\\");\\r\\n        onSale[msg.sender][channelId] = safeSub(onSale[msg.sender][channelId], value);\\r\\n        totalOnSale[channelId] = safeSub(totalOnSale[channelId], value);\\r\\n        balances[msg.sender] = safeAdd(balances[msg.sender], value);\\r\\n        totalSupply = safeAdd(totalSupply, value);\\r\\n        groups[groupId].onSale[channelId] = safeSub(groups[groupId].onSale[channelId], value);\\r\\n\\r\\n        if (onSale[msg.sender][channelId] == 0) {\\r\\n            groups[groupId].addressesOnChannel[channelId].remove(msg.sender);\\r\\n        }\\r\\n        emit RemoveFromSale(msg.sender, value);\\r\\n    }\\r\\n\\r\\n    // Transfer token to gateway from selected channel\\r\\n    function transferToGateway(uint256 value, uint256 channelId) external onlyGateway returns(uint256 send){\\r\\n        send = value;\\r\\n        if(totalOnSale[channelId] \\u003c value)\\r\\n            send = totalOnSale[channelId];\\r\\n        totalOnSale[channelId] = safeSub(totalOnSale[channelId], send);\\r\\n        tokenContract.approve(gatewayContract, send);\\r\\n        emit TransferGateway(gatewayContract, channelId, send);\\r\\n    }\\r\\n\\r\\n    // Gateway transfer token to Escrow and call this function\\r\\n    function transferFromGateway(uint256 value, uint256 channelId) external onlyGateway {\\r\\n        totalOnSale[channelId] = safeAdd(totalOnSale[channelId], value);\\r\\n        emit TransferGateway(address(this), channelId, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Receive ETH from Gateway\\r\\n     * @param channelId Liquidity channel ID which sold tokens.\\r\\n     * @param token The ERC20 token address which was sens by Gateway (in case ETH the token = address(0)).\\r\\n     * @param value Amount of sent tokens\\r\\n     * @param soldValue Amount of token that was sold\\r\\n     */\\r\\n    function paymentFromGateway(uint256 channelId, address token, uint256 value, uint256 soldValue) external payable onlyGateway {\\r\\n        uint256 len = groups.length;\\r\\n        uint256[] memory groupPart = new uint256[](len);\\r\\n        uint256[] memory groupOnSale = new uint256[](len);\\r\\n        bool[] memory groupHasOnSale = new bool[](len);\\r\\n        uint256[] memory groupRate = new uint256[](len);\\r\\n        uint256 totalRateNew;\\r\\n        uint256 restNew = soldValue;\\r\\n\\r\\n        for (uint i = 0; i \\u003c len; i++) {\\r\\n            groupOnSale[i] = safeSub(groups[i].onSale[channelId], groups[i].soldUnpaid[channelId]);\\r\\n            if (groupOnSale[i] \\u003e 0) {\\r\\n                groupHasOnSale[i] = true;\\r\\n                groupRate[i] = groups[i].rate;\\r\\n                totalRateNew += groupRate[i];\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        uint256 part;\\r\\n        // Split by groups\\r\\n        while (restNew \\u003e 0) {\\r\\n        //for (uint k = 0; k\\u003cn; k++) {\\r\\n            uint256 restValue = restNew;\\r\\n            uint256 totalRate = totalRateNew;\\r\\n            for (uint i = 0; i \\u003c len; i++) {\\r\\n                if (groupHasOnSale[i]) {\\r\\n                    if (restNew \\u003c len) part = restNew; // if rest value less then calculation error use it all\\r\\n                    else part = (restValue*groupRate[i]/totalRate);\\r\\n                    groupPart[i] += part;\\r\\n                    if (groupPart[i] \\u003e groupOnSale[i]) {\\r\\n                        part = part - (groupPart[i]-groupOnSale[i]);    // part that rest\\r\\n                        groupPart[i] = groupOnSale[i];\\r\\n                        groupHasOnSale[i] = false; // group on-sale fulfilled\\r\\n                        totalRateNew = totalRate - groupRate[i];\\r\\n                    }\\r\\n                    restNew -= part;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i \\u003c len; i++) {\\r\\n            if (groupOnSale[i] \\u003e 0) {\\r\\n                groups[i].soldUnpaid[channelId] += groupPart[i];    // total sold tokens and unpaid (unsplit) by channel\\r\\n                groups[i].unpaid[channelId][token].soldValue += groupPart[i]; // sold tokens by payment tokens and channel\\r\\n                groups[i].unpaid[channelId][token].value += (groupPart[i] * value / soldValue); //unpaid tokens by channel \\r\\n            }\\r\\n        }\\r\\n        emit PaymentFromGateway(channelId, token, value, soldValue);\\r\\n    }\\r\\n\\r\\n    // return list of groups with unpaid token amount\\r\\n    function getUnpaidGroups(uint256 channelId) external view returns (uint256[] memory unpaidSold){\\r\\n        uint256 len = groups.length;\\r\\n        unpaidSold = new uint256[](len);\\r\\n        for (uint i = 0; i\\u003clen; i++) {\\r\\n            unpaidSold[i] = groups[i].soldUnpaid[channelId];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Use this function to avoid OUT_OF_GAS. Gas per user about 60.000\\r\\n    function splitProrata(uint256 channelId, address token, uint256 groupId) external {\\r\\n        if (groupId == 1) _splitForGoals(channelId, token, groupId);    // split among Investors with goal \\r\\n        else _splitProrata(channelId, token, groupId);\\r\\n    }\\r\\n\\r\\n    // Split giveaways in each groups among participants pro-rata their orders amount.\\r\\n    // May throw with OUT_OF_GAS is there are too many participants.\\r\\n    function splitProrataAll(uint256 channelId, address token) external {\\r\\n        uint256 len = groups.length;\\r\\n        for (uint i = 0; i \\u003c len; i++) {\\r\\n            if (i == 1) _splitForGoals(channelId, token, i);    // split among Investors with goal \\r\\n            else _splitProrata(channelId, token, i);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // require to avoid \\u0027stack too deep\\u0027 compiler error\\r\\n    struct SplitValues {\\r\\n        uint256 soldValue;\\r\\n        uint256 value;\\r\\n        uint256 total;\\r\\n        uint256 soldRest;\\r\\n        uint256 valueRest;\\r\\n        uint256 userPart;\\r\\n        uint256 userValue;\\r\\n    }\\r\\n\\r\\n    // Gas per user about 60.000\\r\\n    function _splitProrata(uint256 channelId, address token, uint256 groupId) internal {\\r\\n        Group storage g = groups[groupId];\\r\\n        SplitValues memory v;\\r\\n        v.soldValue = g.unpaid[channelId][token].soldValue;\\r\\n        if (v.soldValue == 0) return; // no unpaid tokens\\r\\n        v.value = g.unpaid[channelId][token].value;\\r\\n        v.total = g.onSale[channelId];\\r\\n        if (v.total == 0) return; // no tokens onSale\\r\\n\\r\\n        g.onSale[channelId] = safeSub(v.total, v.soldValue);\\r\\n        g.soldUnpaid[channelId] = safeSub(g.soldUnpaid[channelId], v.soldValue);\\r\\n        delete g.unpaid[channelId][token].value;\\r\\n        delete g.unpaid[channelId][token].soldValue;\\r\\n\\r\\n        EnumerableSet.AddressSet storage sellers = g.addressesOnChannel[channelId];\\r\\n\\r\\n        v.soldRest = v.soldValue;\\r\\n        v.valueRest = v.value;\\r\\n        while (v.soldRest != 0 ) {\\r\\n            uint256 addrNum = sellers.length();\\r\\n            uint256 divider = v.total * addrNum * 2;\\r\\n            uint256 j = addrNum;\\r\\n            while (j != 0 \\u0026\\u0026 v.soldRest != 0) {\\r\\n                j--;\\r\\n                address payable user = payable(sellers.at(j));\\r\\n                uint256 amount = onSale[user][channelId];\\r\\n                if (v.soldRest \\u003c 10000) v.userPart = v.soldRest;    // very small value\\r\\n                else v.userPart = v.soldValue * (amount * addrNum + v.total) / divider;\\r\\n                if (v.userPart \\u003e= amount) {\\r\\n                    v.userPart = amount;\\r\\n                    sellers.remove(user);\\r\\n                }\\r\\n                v.soldRest = safeSub(v.soldRest, v.userPart);\\r\\n                onSale[user][channelId] = safeSub(amount, v.userPart);\\r\\n                // get return amount in target ETH / ERC20\\r\\n                if (v.soldRest != 0) v.userValue = v.userPart * v.value / v.soldValue;\\r\\n                else v.userValue = v.valueRest; // If all tokens split send the rest value\\r\\n                v.valueRest = safeSub(v.valueRest, v.userValue);\\r\\n                if (token == address(0)) {\\r\\n                    if (!user.send(v.userValue))\\r\\n                        balancesETH[user] = v.userValue;\\r\\n                }\\r\\n                else {\\r\\n                    IERC20Token(token).transfer(user, v.userValue);\\r\\n                }\\r\\n            }\\r\\n            v.total = v.total + v.soldRest - v.soldValue;\\r\\n            v.soldValue = v.soldRest;\\r\\n            v.value = v.valueRest;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _splitForGoals(uint256 channelId, address token, uint256 groupId) internal {\\r\\n        Group storage g = groups[groupId];\\r\\n        SplitValues memory v;\\r\\n        v.soldValue = g.unpaid[channelId][token].soldValue;\\r\\n        if (v.soldValue == 0) return; // no unpaid tokens\\r\\n        v.value = g.unpaid[channelId][token].value;\\r\\n        v.total = g.onSale[channelId];\\r\\n        if (v.total == 0) return; // no tokens onSale\\r\\n\\r\\n        EnumerableSet.AddressSet storage sellers = g.addressesOnChannel[channelId];\\r\\n        uint256 addrNum = sellers.length();\\r\\n        // split among members with the goals\\r\\n        uint256 price = currencyPricesContract.getCurrencyPrice(token);\\r\\n\\r\\n        v.soldRest = v.soldValue;\\r\\n        uint256 j = addrNum;\\r\\n        while (j != 0) {\\r\\n            j--;\\r\\n            address payable user = payable(sellers.at(j));\\r\\n            uint256 amount = onSale[user][channelId];\\r\\n\\r\\n            if (j == 0) v.userPart = v.soldRest;    // the last member get the rest\\r\\n            else v.userPart = v.soldValue * amount / v.total;\\r\\n            if (v.userPart \\u003e= amount) {\\r\\n                v.userPart = amount;\\r\\n            }\\r\\n            v.soldRest = safeSub(v.soldRest, v.userPart);\\r\\n            onSale[user][channelId] = safeSub(amount, v.userPart);\\r\\n\\r\\n            v.userValue = v.userPart * v.value / v.soldValue;\\r\\n            uint256 userValueUSD = v.userValue * price / DECIMAL_NOMINATOR;\\r\\n            if (userValueUSD \\u003e= goals[user]) {\\r\\n                goals[user] = 0;\\r\\n                _moveToGroup(user, 2, true);  // move user with fulfilled goal to the Main group (2).\\r\\n            }\\r\\n            else {\\r\\n                goals[user] = goals[user] - userValueUSD;\\r\\n            }\\r\\n            // transfer userValue to user\\r\\n            if (token == address(0)) {\\r\\n                if (!user.send(v.userValue))\\r\\n                    balancesETH[user] = v.userValue;\\r\\n            }\\r\\n            else {\\r\\n                IERC20Token(token).transfer(user, v.userValue);\\r\\n            }\\r\\n        }\\r\\n        g.onSale[channelId] = safeSub(v.total + v.soldRest, v.soldValue);\\r\\n        g.soldUnpaid[channelId] = safeSub(g.soldUnpaid[channelId], v.soldValue);\\r\\n        delete g.unpaid[channelId][token].value;\\r\\n        delete g.unpaid[channelId][token].soldValue;\\r\\n    }\\r\\n\\r\\n    // Withdraw ETH in case sending failed\\r\\n    function withdraw() external {\\r\\n        require(balancesETH[msg.sender] \\u003e 0, \\\"No ETH\\\");\\r\\n        msg.sender.transfer(balancesETH[msg.sender]);\\r\\n    }\\r\\n\\r\\n    // Move user from one group to another\\r\\n    function _moveToGroup(address wallet, uint256 toGroup, bool allowUnpaid) internal {\\r\\n        uint256 from = _getGroupId(wallet);\\r\\n        require(from != toGroup, \\\"Already in this group\\\");\\r\\n        inGroup[wallet] = toGroup + 1;  // change wallet\\u0027s group id (1-based)\\r\\n        // add to group wallets list\\r\\n        groups[toGroup].wallets.add(wallet);\\r\\n        // delete from previous group\\r\\n        groups[from].wallets.remove(wallet);\\r\\n        // recalculate groups OnSale\\r\\n        // request number of channels from Gateway\\r\\n        uint channels = _getChannelsNumber();\\r\\n        for (uint i = 1; i \\u003c channels; i++) {   // exclude channel 0. It allow company to wire tokens for Gateway supply\\r\\n            if (onSale[wallet][i] \\u003e 0) {\\r\\n                require(groups[from].soldUnpaid[i] == 0 || allowUnpaid, \\\"There is unpaid giveaways\\\");\\r\\n                groups[from].onSale[i] = safeSub(groups[from].onSale[i], onSale[wallet][i]);\\r\\n                groups[toGroup].onSale[i] = safeAdd(groups[toGroup].onSale[i], onSale[wallet][i]);\\r\\n                groups[from].addressesOnChannel[i].remove(wallet);\\r\\n                groups[toGroup].addressesOnChannel[i].add(wallet);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev transfer token for a specified address into Escrow contract\\r\\n     * @param to The address to transfer to.\\r\\n     * @param value The amount to be transferred.\\r\\n     */\\r\\n    function _transfer(address to, uint256 value) internal returns (bool) {\\r\\n        _nonZeroAddress(to);\\r\\n        require(balances[msg.sender] \\u003e= value, \\\"Not enough balance\\\");\\r\\n        balances[msg.sender] = safeSub(balances[msg.sender], value);\\r\\n        balances[to] = safeAdd(balances[to], value);\\r\\n        emit Transfer(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Create restricted order which require confirmation from third-party confirmatory address. For simple transfer the wantValue = 0.\\r\\n    function _restrictedOrder(uint256 sellValue, address wantToken, uint256 wantValue, address payable buyer, address confirmatory) internal {\\r\\n        require(sellValue \\u003e 0, \\\"Zero sell value\\\");\\r\\n        balances[msg.sender] = safeSub(balances[msg.sender], sellValue);\\r\\n        uint256 orderId = orders.length;\\r\\n        orders.push(Order(msg.sender, buyer, sellValue, wantToken, wantValue, 4, confirmatory));  //add restricted order\\r\\n        emit RestrictedOrder(msg.sender, buyer, sellValue, wantToken, wantValue, orderId, confirmatory);\\r\\n    }\\r\\n    function _getGroupId(address wallet) internal view returns(uint256 groupId) {\\r\\n        groupId = inGroup[wallet];\\r\\n        require(groupId \\u003e 0, \\\"Wallet not added\\\");\\r\\n        groupId--;  // from 1-based to 0-based index\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add wallet that received pre-minted tokens to the list in the Governance contract.\\r\\n     * The contract owner should be GovernanceProxy contract.\\r\\n     * This Escrow contract address should be added to Governance contract (setEscrowContract).\\r\\n     * @param wallet The address of wallet.\\r\\n     */\\r\\n    function _addPremintedWallet(address wallet, uint256 groupId) internal {\\r\\n        require(groupId \\u003c groups.length, \\\"Wrong group\\\");\\r\\n        IGovernance(governanceContract).addPremintedWallet(wallet);\\r\\n        inGroup[wallet] = groupId + 1;    // groupId + 1 (0 - mean that wallet not added)\\r\\n        groups[groupId].wallets.add(wallet);  // add to the group\\r\\n    }\\r\\n\\r\\n    function _getChannelsNumber() internal view returns (uint256 channelsNumber) {\\r\\n        return IGateway(gatewayContract).getChannelsNumber();\\r\\n    }\\r\\n\\r\\n    function _nonZeroAddress(address addr) internal pure {\\r\\n        require(addr != address(0), \\\"Zero address\\\");\\r\\n    }\\r\\n\\r\\n    // accept ETH\\r\\n    receive() external payable {\\r\\n        emit ReceivedETH(msg.sender, msg.value);\\r\\n    }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.9;\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n *\\r\\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\\r\\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\\r\\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\\r\\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\\r\\n */\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n     * account.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the address of the owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(),\\\"Not Owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return true if `msg.sender` is the owner of the contract.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to relinquish control of the contract.\\r\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\r\\n     * It will not be possible to call the functions with the `onlyOwner`\\r\\n     * modifier anymore.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0),\\\"Zero address not allowed\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_companyWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"GroupRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soldValue\",\"type\":\"uint256\"}],\"name\":\"PaymentFromGateway\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PutOnSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RemoveFromSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wantValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"confirmatory\",\"type\":\"address\"}],\"name\":\"RestrictedOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wantValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"SellOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferGateway\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"addGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"buyOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"canceledP2P\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"changeGroupRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"confirmOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractsRegistry\",\"outputs\":[{\"internalType\":\"contract IAuctionRegistery\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"goal\",\"type\":\"uint256\"}],\"name\":\"createWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currencyPricesContract\",\"outputs\":[{\"internalType\":\"contract ICurrencyPrices\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"depositFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gatewayContract\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"getAddressesOnChannel\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"}],\"name\":\"getGroupDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"membersNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restriction\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"}],\"name\":\"getGroupMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGroupsNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastAvailableOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastOrderToConfirm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getOrder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"confirmatory\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOrdersNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"getUnpaidGroups\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"unpaidSold\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"goals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inGroup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityContract\",\"outputs\":[{\"internalType\":\"contract IAuctionLiquidity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toGroup\",\"type\":\"uint256\"}],\"name\":\"moveToGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"onSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"soldValue\",\"type\":\"uint256\"}],\"name\":\"paymentFromGateway\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"putOnSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"redemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"removeFromSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"samartswapP2P\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantValue\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"sellToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantValue\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"confirmatory\",\"type\":\"address\"}],\"name\":\"sellTokenRestricted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setGatewayContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setGovernanceContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restriction\",\"type\":\"uint256\"}],\"name\":\"setGroupRestriction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartswapContract\",\"outputs\":[{\"internalType\":\"contract ISmartSwapP2P\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"}],\"name\":\"splitProrata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"splitProrataAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalOnSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"transferFromGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"confirmatory\",\"type\":\"address\"}],\"name\":\"transferRestricted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"transferToGateway\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"send\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateCompanyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateRegistery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Escrow","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c326df3bec90f94887d2756e03b51a222f2b0de4","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d3660e4fffc0d4b553822bbb22168d2ca1c10fb11280ff46703c888339a2799c"}]}