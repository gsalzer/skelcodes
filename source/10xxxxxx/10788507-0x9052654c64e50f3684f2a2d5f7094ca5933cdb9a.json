{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\nlibrary SafeMath {\r\n  \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n  \r\n        return a / b;\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n        uint256 c = add(a,m);\r\n        uint256 d = sub(c,1);\r\n        return mul(div(d,m),m);\r\n  }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n   constructor() public {\r\n      owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n      require(msg.sender == owner, \"Must be an owner\");\r\n      _;\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      require(newOwner != address(0), \"New owner must be a non-zero address\");\r\n      emit OwnershipTransferred(owner, newOwner);\r\n      owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n    mapping(address => uint256) balances;\r\n    mapping(address => uint256) ethBalances;\r\n    \r\n    uint256 totalSupply_;\r\n    \r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function checkInvestedETH(address who) public view returns (uint256) {\r\n        return ethBalances[who];\r\n    }\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    uint256 public basePercent = 100;\r\n\r\n    function findOnePercent(uint256 value) public view returns (uint256)  {\r\n     uint256 roundValue = value.ceil(basePercent);\r\n     uint256 onePercent = roundValue.mul(basePercent).div(10000);\r\n     return onePercent;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        require(value <= balances[msg.sender], \"Not enough tokens to transfer\");\r\n        require(to != address(0), \"Receiver must be a non-zero address\");\r\n\r\n        uint256 tokensToBurn = findOnePercent(value);\r\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\n        balances[to] = balances[to].add(tokensToTransfer);\r\n\r\n        totalSupply_ = totalSupply_.sub(tokensToBurn);\r\n\r\n        emit Transfer(msg.sender, to, tokensToTransfer);\r\n        emit Transfer(msg.sender, address(0), tokensToBurn);\r\n        return true;\r\n    }\r\n\r\n    function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n        transfer(receivers[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        require(value <= balances[from], \"Must have sufficient balance\");\r\n        require(value <= allowed[from][msg.sender], \"Spender has sufficient spending balance\");\r\n        require(to != address(0), \"Sender must be a non-zero address\");\r\n\r\n        balances[from] = balances[from].sub(value);\r\n\r\n        uint256 tokensToBurn = findOnePercent(value);\r\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\r\n\r\n        balances[to] = balances[to].add(tokensToTransfer);\r\n        totalSupply_ = totalSupply_.sub(tokensToBurn);\r\n\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\r\n\r\n        emit Transfer(from, to, tokensToTransfer);\r\n        emit Transfer(from, address(0), tokensToBurn);\r\n\r\n        return true;\r\n    } \r\n\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0), \"Cannot approve to a zero address\");\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0), \"Must be a non zero address\");\r\n        allowed[msg.sender][spender] = (allowed[msg.sender][spender].add(addedValue));\r\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][spender];\r\n        if (subtractedValue > oldValue) {\r\n            allowed[msg.sender][spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][spender] = oldValue.sub(subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract Configurable {\r\n    uint256 public constant cap = 9000*10**18; \r\n    uint256 public constant basePrice = 180*10**18; \r\n    uint256 public tokensSold = 0;\r\n    \r\n    uint256 public constant tokenReserve = 15000*10**18;\r\n    uint256 public remainingTokens = 0;\r\n}\r\n\r\ncontract CrowdsaleToken is StandardToken, Configurable, Ownable {\r\n  \r\n     enum Stages {\r\n        none,\r\n        icoStart, \r\n        icoEnd\r\n    }\r\n    \r\n    Stages currentStage;\r\n\r\n    constructor() public {\r\n        currentStage = Stages.none;\r\n        balances[owner] = balances[owner].add(tokenReserve);\r\n        totalSupply_ = totalSupply_.add(tokenReserve);\r\n        remainingTokens = cap;\r\n        emit Transfer(address(this), owner, tokenReserve);\r\n    }\r\n\r\n    function () public payable {\r\n        require(currentStage == Stages.icoStart, \"The coin offering has not started yet\");\r\n        require(msg.value > 0 && msg.value <= 1e18, \"You cannot send 0 Ether or more than 1 Ether\");\r\n        require(remainingTokens > 0, \"Must be some tokens remaining\");\r\n       \r\n        address caller = msg.sender;\r\n        uint256 weiAmount = msg.value;\r\n        uint256 tokens = weiAmount.mul(basePrice).div(1 ether);\r\n        uint256 returnWei = 0;\r\n        \r\n        ethBalances[caller] = ethBalances[caller].add(weiAmount);\r\n        ethBalances[address(this)] = ethBalances[address(this)].add(weiAmount);\r\n       \r\n        require(ethBalances[caller] <= 1e18);\r\n        require(ethBalances[address(this)] <= 50e18);\r\n\r\n        if(tokensSold.add(tokens) > cap){\r\n            uint256 newTokens = cap.sub(tokensSold);\r\n            uint256 newWei = newTokens.div(basePrice).mul(1 ether);\r\n            returnWei = weiAmount.sub(newWei);\r\n            weiAmount = newWei;\r\n            tokens = newTokens;\r\n        }\r\n        \r\n        tokensSold = tokensSold.add(tokens); \r\n        remainingTokens = cap.sub(tokensSold);\r\n        if(returnWei > 0){\r\n            msg.sender.transfer(returnWei);\r\n            emit Transfer(address(this), msg.sender, returnWei);\r\n        }\r\n        \r\n        balances[msg.sender] = balances[msg.sender].add(tokens);\r\n        emit Transfer(address(this), msg.sender, tokens);\r\n        totalSupply_ = totalSupply_.add(tokens);\r\n        owner.transfer(weiAmount);\r\n    }\r\n\r\n    function startIco() public onlyOwner {\r\n        require(currentStage != Stages.icoEnd, \"The coin offering has ended\");\r\n        currentStage = Stages.icoStart;\r\n    }\r\n\r\n    function endIco() internal {\r\n        currentStage = Stages.icoEnd;\r\n        if(remainingTokens > 0)\r\n            balances[owner] = balances[owner].add(remainingTokens);\r\n        owner.transfer(address(this).balance); \r\n    }\r\n\r\n    function finalizeIco() public onlyOwner {\r\n        require(currentStage != Stages.icoEnd, \"The coin offering has ended\");\r\n        endIco();\r\n    }\r\n    \r\n}\r\n\r\ncontract LETSFKNGO is CrowdsaleToken {\r\n    string public constant name = \"LETSFKNGO\";\r\n    string public constant symbol = \"LFG\";\r\n    uint32 public constant decimals = 18;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receivers\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"checkInvestedETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"findOnePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"LETSFKNGO","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9df688ac8bd44a926265e13cf838c9e377b6ed201b5badfda917bacadbdc8aaa"}]}