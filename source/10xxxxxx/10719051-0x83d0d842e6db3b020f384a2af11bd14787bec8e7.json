{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) \r\n            return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"permission denied\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"invalid address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function burn(address from, uint256 amount) external;\r\n}\r\n\r\ncontract ERC20NonStandard {\r\n    function transfer(address to, uint256 value) public;\r\n}\r\n\r\ncontract Burner {\r\n    using SafeMath for uint256;\r\n\r\n    address constant etherAddr = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    ERC20 constant hakka = ERC20(0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd);\r\n\r\n    GuildBank constant bank = GuildBank(0x83D0D842e6DB3B020f384a2af11bD14787BEC8E7);\r\n\r\n    bool private lock;\r\n\r\n    function ragequit(address[] calldata tokens, uint256 share) external returns (uint256[] memory amounts) {\r\n        require(!lock);\r\n        lock = true;\r\n\r\n        uint256 totalShare = hakka.totalSupply();\r\n\r\n        hakka.burn(msg.sender, share);\r\n\r\n        amounts = new uint256[](tokens.length);\r\n\r\n        for(uint256 i = 0; i < tokens.length; i++) {\r\n            if(i > 0) require(uint256(tokens[i-1]) < uint256(tokens[i]), \"bad order\");\r\n\r\n            uint256 tokenInBank;\r\n\r\n            if(tokens[i] == etherAddr) {\r\n                address payable _bank = address(bank);\r\n                tokenInBank = _bank.balance;\r\n            }\r\n            else {\r\n                tokenInBank = ERC20(tokens[i]).balanceOf(address(bank));\r\n            }\r\n\r\n            uint256 amount = share.mul(tokenInBank).div(totalShare);\r\n            amounts[i] = amount;\r\n            require(bank.withdraw(tokens[i], msg.sender, amount), \"fail to withdraw\");\r\n        }\r\n        lock = false;\r\n    }\r\n}\r\n\r\ncontract GuildBank is Ownable {\r\n\r\n    address constant etherAddr = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    address constant burner = 0xde02313f8BF17f31380c63e41CDECeE98Bc2b16d;\r\n\r\n    event Withdrawal(address indexed token, address indexed receiver, uint256 amount);\r\n\r\n    constructor() public {\r\n        new Burner();\r\n    }\r\n\r\n    function withdraw(address token, address receiver, uint256 amount) external returns (bool result) {\r\n        require(msg.sender == owner || msg.sender == burner, \"permission denied\");\r\n\r\n        if(token == etherAddr) {\r\n            (result,) = receiver.call.value(amount)(\"\");\r\n        }\r\n        else {\r\n            result = doTransferOut(token, receiver, amount);\r\n        }\r\n\r\n        if(result) emit Withdrawal(token, receiver, amount);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    function doTransferOut(address tokenAddr, address to, uint amount) internal returns (bool result) {\r\n        ERC20NonStandard token = ERC20NonStandard(tokenAddr);\r\n        token.transfer(to, amount);\r\n\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                      // This is a non-standard ERC-20\r\n                    result := not(0)          // set result to true\r\n                }\r\n                case 32 {                     // This is a complaint ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)        // Set `result = returndata` of external call\r\n                }\r\n                default {                     // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GuildBank","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0b2c0d3855c44008c86a97247e26f32190cafa73e38dfef1a2da17b4427415d5"}]}