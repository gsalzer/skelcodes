{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.10;\r\n\r\nabstract contract ERC1820Registry {\r\n    function setInterfaceImplementer(\r\n        address _addr,\r\n        bytes32 _interfaceHash,\r\n        address _implementer\r\n    ) external virtual;\r\n\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash)\r\n        external\r\n        virtual\r\n        view\r\n        returns (address);\r\n\r\n    function setManager(address _addr, address _newManager) external virtual;\r\n\r\n    function getManager(address _addr) public virtual view returns (address);\r\n}\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC1820Client {\r\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(\r\n        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\r\n    );\r\n\r\n    function setInterfaceImplementation(\r\n        string memory _interfaceLabel,\r\n        address _implementation\r\n    ) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(\r\n            address(this),\r\n            interfaceHash,\r\n            _implementation\r\n        );\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC1820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\ncontract ERC1820Implementer {\r\n    /**\r\n     * @dev ERC1820 well defined magic value indicating the contract has\r\n     * registered with the ERC1820Registry that it can implement an interface.\r\n     */\r\n    bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(\r\n        abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")\r\n    );\r\n\r\n    /**\r\n     * @dev Mapping of interface name keccak256 hashes for which this contract\r\n     * implements the interface.\r\n     * @dev Only settable internally.\r\n     */\r\n    mapping(bytes32 => bool) internal _interfaceHashes;\r\n\r\n    /**\r\n     * @notice Indicates whether the contract implements the interface `_interfaceHash`\r\n     * for the address `_addr`.\r\n     * @param _interfaceHash keccak256 hash of the name of the interface.\r\n     * @return ERC1820_ACCEPT_MAGIC only if the contract implements `Ã¬nterfaceHash`\r\n     * for the address `_addr`.\r\n     * @dev In this implementation, the `_addr` (the address for which the\r\n     * contract will implement the interface) is always `address(this)`.\r\n     */\r\n    function canImplementInterfaceForAddress(\r\n        bytes32 _interfaceHash,\r\n        address // Comments to avoid compilation warnings for unused variables. /*addr*/\r\n    ) external view returns (bytes32) {\r\n        if (_interfaceHashes[_interfaceHash]) {\r\n            return ERC1820_ACCEPT_MAGIC;\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internally set the fact this contract implements the interface\r\n     * identified by `_interfaceLabel`\r\n     * @param _interfaceLabel String representation of the interface.\r\n     */\r\n    function _setInterface(string memory _interfaceLabel) internal {\r\n        _interfaceHashes[keccak256(abi.encodePacked(_interfaceLabel))] = true;\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Partition strategy validator hooks for Amp\r\n */\r\ninterface IAmpPartitionStrategyValidator {\r\n    function tokensFromPartitionToValidate(\r\n        bytes4 _functionSig,\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external;\r\n\r\n    function tokensToPartitionToValidate(\r\n        bytes4 _functionSig,\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external;\r\n\r\n    function isOperatorForPartitionScope(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _tokenHolder\r\n    ) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title PartitionUtils\r\n * @notice Partition related helper functions.\r\n */\r\n\r\nlibrary PartitionUtils {\r\n    bytes32 public constant CHANGE_PARTITION_FLAG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @notice Retrieve the destination partition from the 'data' field.\r\n     * A partition change is requested ONLY when 'data' starts with the flag:\r\n     *\r\n     *   0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n     *\r\n     * When the flag is detected, the destination partition is extracted from the\r\n     * 32 bytes following the flag.\r\n     * @param _data Information attached to the transfer. Will contain the\r\n     * destination partition if a change is requested.\r\n     * @param _fallbackPartition Partition value to return if a partition change\r\n     * is not requested in the `_data`.\r\n     * @return toPartition Destination partition. If the `_data` does not contain\r\n     * the prefix and bytes32 partition in the first 64 bytes, the method will\r\n     * return the provided `_fromPartition`.\r\n     */\r\n    function _getDestinationPartition(bytes memory _data, bytes32 _fallbackPartition)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        if (_data.length < 64) {\r\n            return _fallbackPartition;\r\n        }\r\n\r\n        (bytes32 flag, bytes32 toPartition) = abi.decode(_data, (bytes32, bytes32));\r\n        if (flag == CHANGE_PARTITION_FLAG) {\r\n            return toPartition;\r\n        }\r\n\r\n        return _fallbackPartition;\r\n    }\r\n\r\n    /**\r\n     * @notice Helper to get the strategy identifying prefix from the `_partition`.\r\n     * @param _partition Partition to get the prefix for.\r\n     * @return 4 byte partition strategy prefix.\r\n     */\r\n    function _getPartitionPrefix(bytes32 _partition) internal pure returns (bytes4) {\r\n        return bytes4(_partition);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper method to split the partition into the prefix, sub partition\r\n     * and partition owner components.\r\n     * @param _partition The partition to split into parts.\r\n     * @return The 4 byte partition prefix, 8 byte sub partition, and final 20\r\n     * bytes representing an address.\r\n     */\r\n    function _splitPartition(bytes32 _partition)\r\n        internal\r\n        pure\r\n        returns (\r\n            bytes4,\r\n            bytes8,\r\n            address\r\n        )\r\n    {\r\n        bytes4 prefix = bytes4(_partition);\r\n        bytes8 subPartition = bytes8(_partition << 32);\r\n        address addressPart = address(uint160(uint256(_partition)));\r\n        return (prefix, subPartition, addressPart);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper method to get a partition strategy ERC1820 interface name\r\n     * based on partition prefix.\r\n     * @param _prefix 4 byte partition prefix.\r\n     * @dev Each 4 byte prefix has a unique interface name so that an individual\r\n     * hook implementation can be set for each prefix.\r\n     */\r\n    function _getPartitionStrategyValidatorIName(bytes4 _prefix)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string(abi.encodePacked(\"AmpPartitionStrategyValidator\", _prefix));\r\n    }\r\n}\r\n\r\n/**\r\n * @title Base contract that satisfies the IAmpPartitionStrategyValidator\r\n * interface\r\n */\r\ncontract AmpPartitionStrategyValidatorBase is\r\n    IAmpPartitionStrategyValidator,\r\n    ERC1820Client,\r\n    ERC1820Implementer\r\n{\r\n    /**\r\n     * @notice Partition prefix the hooks are valid for.\r\n     * @dev Must to be set by the parent contract.\r\n     */\r\n    bytes4 public partitionPrefix;\r\n\r\n    /**\r\n     * @notice Amp contract address.\r\n     */\r\n    address public amp;\r\n\r\n    /**\r\n     * @notice Initialize the partition prefix and register the implementation\r\n     * with the ERC1820 registry for the dynamic interface name.\r\n     * @param _prefix Partition prefix the hooks are valid for.\r\n     * @param _amp The address of the Amp contract.\r\n     */\r\n    constructor(bytes4 _prefix, address _amp) public {\r\n        partitionPrefix = _prefix;\r\n\r\n        string memory iname = PartitionUtils._getPartitionStrategyValidatorIName(\r\n            partitionPrefix\r\n        );\r\n        ERC1820Implementer._setInterface(iname);\r\n\r\n        amp = _amp;\r\n    }\r\n\r\n    /**\r\n     * @dev Placeholder to satisfy IAmpPartitionSpaceValidator interface that\r\n     * can be overridden by parent.\r\n     */\r\n    function tokensFromPartitionToValidate(\r\n        bytes4, /* functionSig */\r\n        bytes32, /* fromPartition */\r\n        address, /* operator */\r\n        address, /* from */\r\n        address, /* to */\r\n        uint256, /* value */\r\n        bytes calldata, /* data */\r\n        bytes calldata /* operatorData */\r\n    ) external virtual override {}\r\n\r\n    /**\r\n     * @dev Placeholder to satisfy IAmpPartitionSpaceValidator interface that\r\n     * can be overridden by parent.\r\n     */\r\n    function tokensToPartitionToValidate(\r\n        bytes4, /* functionSig */\r\n        bytes32, /* fromPartition */\r\n        address, /* operator */\r\n        address, /* from */\r\n        address, /* to */\r\n        uint256, /* value */\r\n        bytes calldata, /* data */\r\n        bytes calldata /* operatorData */\r\n    ) external virtual override {}\r\n\r\n    /**\r\n     * @notice Report if address is an operator for a partition based on the\r\n     * partition's strategy.\r\n     * @dev Placeholder that can be overridden by parent.\r\n     */\r\n    function isOperatorForPartitionScope(\r\n        bytes32, /* partition */\r\n        address, /* operator */\r\n        address /* tokenHolder */\r\n    ) external virtual override view returns (bool) {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\ninterface IAmp {\r\n    function isCollateralManager(address) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title CollateralPoolPartitionValidator\r\n */\r\ncontract CollateralPoolPartitionValidator is AmpPartitionStrategyValidatorBase {\r\n    bytes4 constant PARTITION_PREFIX = 0xCCCCCCCC;\r\n\r\n    constructor(address _amp)\r\n        public\r\n        AmpPartitionStrategyValidatorBase(PARTITION_PREFIX, _amp)\r\n    {}\r\n\r\n    /**\r\n     * @notice Reports if the token holder is an operator for the partition.\r\n     * @dev The `_operator` address param is unused. For this strategy, this will\r\n     * be being called on behalf of suppliers, as they have sent their tokens\r\n     * to the collateral manager address, and are now trying to execute a\r\n     * transfer from the pool. This implies that the pool sender hook\r\n     * MUST be implemented in such a way as to restrict any unauthorized\r\n     * transfers, as the partitions affected by this strategy will allow\r\n     * all callers to make an attempt to transfer from the collateral\r\n     * managers partition.\r\n     * @param _partition The partition to check.\r\n     * @param _tokenHolder The collateral manager holding the pool of tokens.\r\n     * @return The operator check for this strategy returns true if the partition\r\n     * owner (identified by the final 20 bytes of the partition) is the\r\n     * same as the token holder address, as in this case the token holder\r\n     * is the collateral manager address.\r\n     */\r\n    function isOperatorForPartitionScope(\r\n        bytes32 _partition,\r\n        address, /* operator */\r\n        address _tokenHolder\r\n    ) external override view returns (bool) {\r\n        require(msg.sender == address(amp), \"Hook must be called by amp\");\r\n\r\n        (, , address partitionOwner) = PartitionUtils._splitPartition(_partition);\r\n        if (!IAmp(amp).isCollateralManager(partitionOwner)) {\r\n            return false;\r\n        }\r\n\r\n        return _tokenHolder == partitionOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Validate the rules of the strategy when tokens are being sent to\r\n     * a partition under the purview of the strategy.\r\n     * @dev The `_toPartition` must be formatted with the PARTITION_PREFIX as the\r\n     * first 4 bytes, the `_to` value as the final 20 bytes. The 8 bytes in the\r\n     * middle can be used by the manager to create sub partitions within their\r\n     * impelemntation.\r\n     * @param _toPartition The partition the tokens are transferred to.\r\n     * @param _to The address of the collateral manager.\r\n     */\r\n    function tokensToPartitionToValidate(\r\n        bytes4, /* functionSig */\r\n        bytes32 _toPartition,\r\n        address, /* operator */\r\n        address, /* from */\r\n        address _to,\r\n        uint256, /* value */\r\n        bytes calldata, /* _data */\r\n        bytes calldata /* operatorData */\r\n    ) external override {\r\n        require(msg.sender == address(amp), \"Hook must be called by amp\");\r\n\r\n        (, , address toPartitionOwner) = PartitionUtils._splitPartition(_toPartition);\r\n\r\n        require(\r\n            _to == toPartitionOwner,\r\n            \"Transfers to this partition must be to the partitionOwner\"\r\n        );\r\n        require(\r\n            IAmp(amp).isCollateralManager(toPartitionOwner),\r\n            \"Partition owner is not a registered collateral manager\"\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_amp\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"amp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_interfaceHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorForPartitionScope\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partitionPrefix\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensFromPartitionToValidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"_toPartition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensToPartitionToValidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CollateralPoolPartitionValidator","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ff20817765cb7f73d4bde2e66e067e58d11095c2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e81c00e17ae5d4a7870b1b5d199fabbea10a06217f3c0b890d29af812cb54e8d"}]}