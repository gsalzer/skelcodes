{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Ether5.net on 2020-09-07\r\n*/\r\n\r\n/**\r\n  *\r\n  * Designed by Team Brave\r\n  * Developed by Advanced Smart Contract Concepts                                                                                                                                                       \r\n  * Tested and verified by Drexyl, X99, and blockgh0st \r\n  * Translated into 10+ languages by Josh Barton\r\n  * \r\n  * A big thank you to the entire development team for making this possible!\r\n  * \r\n  * Divvy Club is a simple and straightforward crowsdharing smart contract designed around:\r\n  * 1. Daily 5% divident payouts to each participant\r\n  * 2. Direct referral comissions for every referral\r\n  * 3. International participation and platform accessibility\r\n  * 4. FUll transparency and zero dev interaction once launched\r\n  *\r\n  *\r\n  * Enjoy!\r\n  *\r\n  * \r\n  * Website: www.ether5.net\r\n*** Official Telegram Channel: https://t.me/Ether5_Daily\r\n*** Made with YC by Team Brave\r\n  *\r\n  */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary DataStructs {\r\n\r\n        struct DailyRound {\r\n            uint256 startTime;\r\n            uint256 endTime;\r\n            bool ended; //has daily round ended\r\n            uint256 pool; //amount in the pool;\r\n        }\r\n\r\n        struct Player {\r\n            uint256 totalInvestment;\r\n            uint256 totalVolumeEth;\r\n            uint256 eventVariable;\r\n            uint256 directReferralIncome;\r\n            uint256 roiReferralIncome;\r\n            uint256 currentInvestedAmount;\r\n            uint256 dailyIncome;            \r\n            uint256 lastSettledTime;\r\n            uint256 incomeLimitLeft;\r\n            uint256 investorPoolIncome;\r\n            uint256 sponsorPoolIncome;\r\n            uint256 superIncome;\r\n            uint256 referralCount;\r\n            address referrer;\r\n        }\r\n\r\n        struct PlayerDailyRounds {\r\n            uint256 selfInvestment; \r\n            uint256 ethVolume; \r\n        }\r\n}\r\n\r\ncontract Ether5 {\r\n    using SafeMath for *;\r\n\r\n    address public  owner;\r\n    address public  roundStarter;\r\n    uint256 private houseFee = 18;\r\n    uint256 private poolTime = 24 hours;\r\n    uint256 private payoutPeriod = 24 hours;\r\n    uint256 private dailyWinPool = 10;\r\n    uint256 private incomeTimes  = 30;\r\n    uint256 private incomeDivide = 10;\r\n    uint256 public  roundID;\r\n    uint256 public  r1 = 0;\r\n    uint256 public  r2 = 0;\r\n    uint256 public  r3 = 0;\r\n    uint256[3] private awardPercentage;\r\n\r\n    mapping (uint => uint) public CYCLE_PRICE;\r\n    mapping (address => bool) public playerExist;\r\n    mapping (uint256 => DataStructs.DailyRound) public round;\r\n    mapping (address => DataStructs.Player) public player;\r\n    mapping (address => mapping (uint256 => DataStructs.PlayerDailyRounds)) public plyrRnds_; \r\n\r\n    /****************************  EVENTS   *****************************************/\r\n\r\n    event registerUserEvent(address indexed _playerAddress, address indexed _referrer);\r\n    event investmentEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event referralCommissionEvent(address indexed _playerAddress, address indexed _referrer, uint256 indexed amount, uint256 timeStamp);\r\n    event dailyPayoutEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event withdrawEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event ownershipTransferred(address indexed owner, address indexed newOwner);\r\n\r\n    constructor (address _roundStarter) public {\r\n         owner = msg.sender;\r\n         roundStarter = _roundStarter;\r\n         roundID = 1;\r\n         round[1].startTime = now;\r\n         round[1].endTime = now + poolTime;\r\n         awardPercentage[0] = 50;\r\n         awardPercentage[1] = 30;\r\n         awardPercentage[2] = 20;\r\n    }\r\n    \r\n    /****************************  MODIFIERS    *****************************************/\r\n    \r\n    \r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 100000000000000000, \"Minimum contribution amount is 0.1 ETH\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets permissible values for incoming tx\r\n     */\r\n    modifier isallowedValue(uint256 _eth) {\r\n        require(_eth % 100000000000000000 == 0, \"Amount should be in multiple of 0.1 ETH please\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev allows only the user to run the function\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only Owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    /****************************  CORE LOGIC    *****************************************/\r\n\r\n\r\n    //if someone accidently sends eth to contract address\r\n    function () external payable {\r\n        playGame(address(0x0));\r\n    }\r\n\r\n\r\n\r\n   \r\n    function playGame(address _referrer) \r\n    public\r\n    isWithinLimits(msg.value)\r\n    isallowedValue(msg.value)\r\n    payable {\r\n\r\n        uint256 amount = msg.value;\r\n        if (playerExist[msg.sender] == false) { \r\n\r\n            player[msg.sender].lastSettledTime = now;\r\n            player[msg.sender].currentInvestedAmount = amount;\r\n            player[msg.sender].incomeLimitLeft = amount.mul(incomeTimes).div(incomeDivide);\r\n            player[msg.sender].totalInvestment = amount;\r\n            player[msg.sender].eventVariable = 100 ether;\r\n            playerExist[msg.sender] = true;\r\n            \r\n            //update player's investment in current round\r\n            plyrRnds_[msg.sender][roundID].selfInvestment = plyrRnds_[msg.sender][roundID].selfInvestment.add(amount);\r\n\r\n            if(\r\n                // is this a referred purchase?\r\n                _referrer != address(0x0) && \r\n                \r\n                //self referrer not allowed\r\n                _referrer != msg.sender &&\r\n                \r\n                //referrer exists?\r\n                playerExist[_referrer] == true\r\n              ) {\r\n                    player[msg.sender].referrer = _referrer;\r\n                    player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                    player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\r\n                    plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n                    \r\n                    referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n                }\r\n              else {\r\n                  r1 = r1.add(amount.mul(20).div(100));\r\n                  _referrer = address(0x0);\r\n                }\r\n              emit registerUserEvent(msg.sender, _referrer);\r\n            }\r\n            \r\n            //if the player has already joined earlier\r\n            else {\r\n                \r\n                require(player[msg.sender].incomeLimitLeft == 0, \"Oops your limit is still remaining\");\r\n                require(amount >= player[msg.sender].currentInvestedAmount, \"Cannot invest lesser amount\");\r\n                \r\n                    \r\n                player[msg.sender].lastSettledTime = now;\r\n                player[msg.sender].currentInvestedAmount = amount;\r\n                player[msg.sender].incomeLimitLeft = amount.mul(incomeTimes).div(incomeDivide);\r\n                player[msg.sender].totalInvestment = player[msg.sender].totalInvestment.add(amount);\r\n                    \r\n                //update player's investment in current round\r\n                plyrRnds_[msg.sender][roundID].selfInvestment = plyrRnds_[msg.sender][roundID].selfInvestment.add(amount);\r\n\r\n                if(\r\n                    // is this a referred purchase?\r\n                    _referrer != address(0x0) && \r\n                    // self referrer not allowed\r\n                    _referrer != msg.sender &&\r\n                    //does the referrer exist?\r\n                    playerExist[_referrer] == true\r\n                    )\r\n                    {\r\n                        //if the user has already been referred by someone previously, can't be referred by someone else\r\n                        if(player[msg.sender].referrer != address(0x0))\r\n                            _referrer = player[msg.sender].referrer;\r\n                        else {\r\n                            player[msg.sender].referrer = _referrer;\r\n                            player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                       }\r\n                            \r\n                        player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\r\n                        plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n\r\n                        //assign the referral commission to all.\r\n                        referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n                    }\r\n                    //might be possible that the referrer is 0x0 but previously someone has referred the user                    \r\n                    else if(\r\n                        //0x0 coming from the UI\r\n                        _referrer == address(0x0) &&\r\n                        //check if the someone has previously referred the user\r\n                        player[msg.sender].referrer != address(0x0)\r\n                        ) {\r\n                            _referrer = player[msg.sender].referrer;                             \r\n                            plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n                            player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\r\n\r\n                            //assign the referral commission to all.\r\n                            referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n                          }\r\n                    else {\r\n                          //no referrer, neither was previously used, nor has used now.\r\n                          r1 = r1.add(amount.mul(20).div(100));\r\n                        }\r\n            }\r\n            \r\n            round[roundID].pool = round[roundID].pool.add(amount.mul(dailyWinPool).div(100));\r\n            player[owner].dailyIncome = player[owner].dailyIncome.add(amount.mul(houseFee).div(100));\r\n            r3 = r3.add(amount.mul(5).div(100));\r\n            emit investmentEvent (msg.sender, amount);\r\n            \r\n    }\r\n    \r\n    function referralBonusTransferDirect(address _playerAddress, uint256 amount)\r\n    private\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint256 _amountLeft = amount.mul(60).div(100);\r\n        uint i;\r\n\r\n        for(i=0; i < 10; i++) {\r\n            \r\n            if (_nextReferrer != address(0x0)) {\r\n                //referral commission to level 1\r\n                if(i == 0) {\r\n                    if (player[_nextReferrer].incomeLimitLeft >= amount.div(2)) {\r\n                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(2));\r\n                        player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount.div(2));\r\n                        //This event will be used to get the total referral commission of a person, no need for extra variable\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(2), now);                        \r\n                    }\r\n                    else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                        player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                        r1 = r1.add(amount.div(2).sub(player[_nextReferrer].incomeLimitLeft));\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                        player[_nextReferrer].incomeLimitLeft = 0;\r\n                    }\r\n                    else  {\r\n                        r1 = r1.add(amount.div(2)); \r\n                    }\r\n                    _amountLeft = _amountLeft.sub(amount.div(2));\r\n                }\r\n                \r\n                else if(i == 1 ) {\r\n                    if(player[_nextReferrer].referralCount >= 2) {\r\n                        if (player[_nextReferrer].incomeLimitLeft >= amount.div(10)) {\r\n                            player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(10));\r\n                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount.div(10));\r\n                            \r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(10), now);                        \r\n                        }\r\n                        else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                            r1 = r1.add(amount.div(10).sub(player[_nextReferrer].incomeLimitLeft));\r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                            player[_nextReferrer].incomeLimitLeft = 0;\r\n                        }\r\n                        else  {\r\n                            r1 = r1.add(amount.div(10)); \r\n                        }\r\n                    }\r\n                    else{\r\n                        r1 = r1.add(amount.div(10)); \r\n                    }\r\n                    _amountLeft = _amountLeft.sub(amount.div(10));\r\n                }\r\n                //referral commission from level 3-10\r\n                else {\r\n                    if(player[_nextReferrer].referralCount >= i+1) {\r\n                        if (player[_nextReferrer].incomeLimitLeft >= amount.div(20)) {\r\n                            player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(20));\r\n                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount.div(20));\r\n                            \r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(20), now);\r\n                    \r\n                        }\r\n                        else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                            r1 = r1.add(amount.div(20).sub(player[_nextReferrer].incomeLimitLeft));\r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                            player[_nextReferrer].incomeLimitLeft = 0;                    \r\n                        }\r\n                        else  {\r\n                            r1 = r1.add(amount.div(20)); \r\n                        }\r\n                    }\r\n                    else {\r\n                        r1 = r1.add(amount.div(20)); \r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                r1 = r1.add((uint(10).sub(i)).mul(amount.div(20)).add(_amountLeft)); \r\n                break;\r\n            }\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n    \r\n\r\n    \r\n    function referralBonusTransferDailyROI(address _playerAddress, uint256 amount)\r\n    private\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint256 _amountLeft = amount.div(2);\r\n        uint i;\r\n\r\n        for(i=0; i < 20; i++) {\r\n            \r\n            if (_nextReferrer != address(0x0)) {\r\n                if(i == 0) {\r\n                    if (player[_nextReferrer].incomeLimitLeft >= amount.div(2)) {\r\n                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(2));\r\n                        player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(amount.div(2));\r\n                        \r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(2), now);\r\n                        \r\n                    } else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                        player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                        r2 = r2.add(amount.div(2).sub(player[_nextReferrer].incomeLimitLeft));\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                        player[_nextReferrer].incomeLimitLeft = 0;\r\n                        \r\n                    }\r\n                    else {\r\n                        r2 = r2.add(amount.div(2)); \r\n                    }\r\n                    _amountLeft = _amountLeft.sub(amount.div(2));                \r\n                }\r\n                else { // for users 2-20\r\n                    if(player[_nextReferrer].referralCount >= i+1) {\r\n                        if (player[_nextReferrer].incomeLimitLeft >= amount.div(20)) {\r\n                            player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(20));\r\n                            player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(amount.div(20));\r\n                            \r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(20), now);\r\n                        \r\n                        }else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                            player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                            r2 = r2.add(amount.div(20).sub(player[_nextReferrer].incomeLimitLeft));\r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                            player[_nextReferrer].incomeLimitLeft = 0;                        \r\n                        }\r\n                        else {\r\n                            r2 = r2.add(amount.div(20)); \r\n                        }\r\n                    }\r\n                    else {\r\n                         r2 = r2.add(amount.div(20)); //make a note of the missed commission;\r\n                    }\r\n                }\r\n            }   \r\n            else {\r\n                if(i==0){\r\n                    r2 = r2.add(amount.mul(145).div(100));\r\n                    break;\r\n                }\r\n                else {\r\n                    r2 = r2.add((uint(20).sub(i)).mul(amount.div(20)).add(_amountLeft)); \r\n                    break;\r\n                }\r\n                \r\n            }\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n    \r\n\r\n    //method to settle and withdraw the daily ROI\r\n    function settleIncome(address _playerAddress)\r\n    private {\r\n        \r\n            \r\n        uint256 remainingTimeForPayout;\r\n        uint256 currInvestedAmount;\r\n            \r\n        if(now > player[_playerAddress].lastSettledTime + payoutPeriod) {\r\n            \r\n            //calculate how much time has passed since last settlement\r\n            uint256 extraTime = now.sub(player[_playerAddress].lastSettledTime);\r\n            uint256 _dailyIncome;\r\n            //calculate how many number of days, payout is remaining\r\n            remainingTimeForPayout = (extraTime.sub((extraTime % payoutPeriod))).div(payoutPeriod);\r\n            \r\n            currInvestedAmount = player[_playerAddress].currentInvestedAmount;\r\n            //*YC*calculate 5%=div(20) of his invested amount, 2%=div(50), 10%=div(10)\r\n            _dailyIncome = currInvestedAmount.div(20);\r\n            //check his income limit remaining\r\n            if (player[_playerAddress].incomeLimitLeft >= _dailyIncome.mul(remainingTimeForPayout)) {\r\n                player[_playerAddress].incomeLimitLeft = player[_playerAddress].incomeLimitLeft.sub(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].lastSettledTime = player[_playerAddress].lastSettledTime.add((extraTime.sub((extraTime % payoutPeriod))));\r\n                emit dailyPayoutEvent( _playerAddress, _dailyIncome.mul(remainingTimeForPayout), now);\r\n                referralBonusTransferDailyROI(_playerAddress, _dailyIncome.mul(remainingTimeForPayout));\r\n            }\r\n            //if person income limit lesser than the daily ROI\r\n            else if(player[_playerAddress].incomeLimitLeft !=0) {\r\n                uint256 temp;\r\n                temp = player[_playerAddress].incomeLimitLeft;                 \r\n                player[_playerAddress].incomeLimitLeft = 0;\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(temp);\r\n                player[_playerAddress].lastSettledTime = now;\r\n                emit dailyPayoutEvent( _playerAddress, temp, now);\r\n                referralBonusTransferDailyROI(_playerAddress, temp);\r\n            }         \r\n        }\r\n        \r\n    }\r\n    \r\n\r\n    //function to allow users to withdraw their earnings\r\n    function withdrawIncome() \r\n    public {\r\n        \r\n        address _playerAddress = msg.sender;\r\n        \r\n        //settle the daily dividend\r\n        settleIncome(_playerAddress);\r\n        \r\n        uint256 _earnings =\r\n                    player[_playerAddress].dailyIncome +\r\n                    player[_playerAddress].directReferralIncome +\r\n                    player[_playerAddress].roiReferralIncome;// +\r\n//                  player[_playerAddress].investorPoolIncome +\r\n//                  player[_playerAddress].sponsorPoolIncome +\r\n//                  player[_playerAddress].superIncome;\r\n\r\n        //can only withdraw if they have some earnings.         \r\n        if(_earnings > 0) {\r\n            require(address(this).balance >= _earnings, \"Contract doesn't have sufficient amount to give you\");\r\n\r\n            player[_playerAddress].dailyIncome = 0;\r\n            player[_playerAddress].directReferralIncome = 0;\r\n            player[_playerAddress].roiReferralIncome = 0;\r\n            player[_playerAddress].investorPoolIncome = 0;\r\n            player[_playerAddress].sponsorPoolIncome = 0;\r\n            player[_playerAddress].superIncome = 0;\r\n            \r\n            address(uint160(_playerAddress)).transfer(_earnings);\r\n            emit withdrawEvent(_playerAddress, _earnings, now);\r\n        }\r\n    }\r\n    \r\n    \r\n    //To start the new round for daily pool\r\n    function startNewRound()\r\n    public\r\n     {\r\n        require(msg.sender == roundStarter,\"Oops you can't start the next round\");\r\n    \r\n        uint256 _roundID = roundID;\r\n       \r\n        uint256 _poolAmount = round[roundID].pool;\r\n        if (now > round[_roundID].endTime && round[_roundID].ended == false) {\r\n            \r\n            round[_roundID].ended = true;\r\n            round[_roundID].pool = _poolAmount;\r\n\r\n                _roundID++;\r\n                roundID++;\r\n                round[_roundID].startTime = now;\r\n                round[_roundID].endTime = now.add(poolTime);\r\n        }\r\n    }\r\n\r\n\r\n    //function to fetch the remaining time for the next daily ROI payout\r\n    function getPlayerInfo(address _playerAddress) \r\n    public \r\n    view\r\n    returns(uint256) {\r\n            \r\n            uint256 remainingTimeForPayout;\r\n            if(playerExist[_playerAddress] == true) {\r\n            \r\n                if(player[_playerAddress].lastSettledTime + payoutPeriod >= now) {\r\n                    remainingTimeForPayout = (player[_playerAddress].lastSettledTime + payoutPeriod).sub(now);\r\n                }\r\n                else {\r\n                    uint256 temp = now.sub(player[_playerAddress].lastSettledTime);\r\n                    remainingTimeForPayout = payoutPeriod.sub((temp % payoutPeriod));\r\n                }\r\n                return remainingTimeForPayout;\r\n            }\r\n    }\r\n\r\n\r\n    function withdrawFees(uint256 _amount, address _receiver, uint256 _numberUI) public onlyOwner {\r\n\r\n        if(_numberUI == 1 && r1 >= _amount) {\r\n            if(_amount > 0) {\r\n                if(address(this).balance >= _amount) {\r\n                    r1 = r1.sub(_amount);\r\n                    address(uint160(_receiver)).transfer(_amount);\r\n                }\r\n            }\r\n        }\r\n        else if(_numberUI == 2 && r2 >= _amount) {\r\n            if(_amount > 0) {\r\n                if(address(this).balance >= _amount) {\r\n                    r2 = r2.sub(_amount);\r\n                    address(uint160(_receiver)).transfer(_amount);\r\n                }\r\n            }\r\n        }\r\n        else if(_numberUI == 3) {\r\n            player[_receiver].superIncome = player[_receiver].superIncome.add(_amount);\r\n            r3 = r3.sub(_amount);\r\n//            emit superBonusAwardEvent(_receiver, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n     /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) private {\r\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\r\n        emit ownershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_roundStarter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"dailyPayoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"investmentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"referralCommissionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"registerUserEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"withdrawEvent\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CYCLE_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"playGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"player\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVolumeEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eventVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directReferralIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiReferralIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentInvestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSettledTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeLimitLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investorPoolIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sponsorPoolIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"selfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethVolume\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ended\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundStarter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNewRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_numberUI\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Ether5","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000349651883deca36b566bbf2637c41bff5ffb177b","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}