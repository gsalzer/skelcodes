{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4 .25;\r\n\r\n/**\r\n *      /$$$$$                       /$$           /$$                   /$$     /$$                                  \r\n *     |__  $$                      | $$          | $$                  | $$    | $$                                  \r\n *        | $$ /$$   /$$  /$$$$$$$ /$$$$$$        | $$        /$$$$$$  /$$$$$$ /$$$$$$    /$$$$$$   /$$$$$$  /$$   /$$\r\n *        | $$| $$  | $$ /$$_____/|_  $$_/        | $$       /$$__  $$|_  $$_/|_  $$_/   /$$__  $$ /$$__  $$| $$  | $$\r\n *   /$$  | $$| $$  | $$|  $$$$$$   | $$          | $$      | $$  \\ $$  | $$    | $$    | $$$$$$$$| $$  \\__/| $$  | $$\r\n *  | $$  | $$| $$  | $$ \\____  $$  | $$ /$$      | $$      | $$  | $$  | $$ /$$| $$ /$$| $$_____/| $$      | $$  | $$\r\n *  |  $$$$$$/|  $$$$$$/ /$$$$$$$/  |  $$$$/      | $$$$$$$$|  $$$$$$/  |  $$$$/|  $$$$/|  $$$$$$$| $$      |  $$$$$$$\r\n *   \\______/  \\______/ |_______/    \\___/        |________/ \\______/    \\___/   \\___/   \\_______/|__/       \\____  $$\r\n *                                                                                                          /$$  | $$\r\n *                                                                                                         |  $$$$$$/\r\n *                                                                                                           \\______/\r\n * This product is protected under license.  Any unauthorized copy, modification, or use without \r\n * express written consent from the creators is prohibited.\r\n * Get touch with us justrunio2020@gmail.com\r\n * WARNING:  THIS PRODUCT IS HIGHLY ADDICTIVE.  IF YOU HAVE AN ADDICTIVE NATURE.  DO NOT PLAY.\r\n */\r\npragma solidity ^ 0.4 .24;\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, throws on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b)\r\n  internal\r\n  pure\r\n  returns(uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    require(c / a == b, \"SafeMath mul failed\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b)\r\n  internal\r\n  pure\r\n  returns(uint256) {\r\n    require(b <= a, \"SafeMath sub failed\");\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, throws on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b)\r\n  internal\r\n  pure\r\n  returns(uint256 c) {\r\n    c = a + b;\r\n    require(c >= a, \"SafeMath add failed\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev gives square root of given x.\r\n   */\r\n  function sqrt(uint256 x)\r\n  internal\r\n  pure\r\n  returns(uint256 y) {\r\n    uint256 z = ((add(x, 1)) / 2);\r\n    y = x;\r\n    while (z < y) {\r\n      y = z;\r\n      z = ((add((x / z), z)) / 2);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev gives square. multiplies x by x\r\n   */\r\n  function sq(uint256 x)\r\n  internal\r\n  pure\r\n  returns(uint256) {\r\n    return (mul(x, x));\r\n  }\r\n\r\n  /**\r\n   * @dev x to the power of y \r\n   */\r\n  function pwr(uint256 x, uint256 y)\r\n  internal\r\n  pure\r\n  returns(uint256) {\r\n    if (x == 0)\r\n      return (0);\r\n    else if (y == 0)\r\n      return (1);\r\n    else {\r\n      uint256 z = x;\r\n      for (uint256 i = 1; i < y; i++)\r\n        z = mul(z, x);\r\n      return (z);\r\n    }\r\n  }\r\n}\r\n\r\npragma solidity 0.4 .25;\r\n\r\nlibrary Data {\r\n\r\n  struct Player {\r\n\r\n    uint signInTime;\r\n\r\n    uint signInDay;\r\n\r\n    uint consume;\r\n\r\n    uint dynamicIncome;\r\n\r\n    uint totalEth;\r\n\r\n    uint sellIncome;\r\n\r\n    bool isNew;\r\n\r\n    bool isExist;\r\n\r\n    address superiorAddr;\r\n\r\n    address[] subordinateAddr;\r\n  }\r\n\r\n  struct PlayerData {\r\n\r\n    uint wallet;\r\n\r\n    uint runIncome;\r\n\r\n    uint withdrawnIncome;\r\n\r\n    uint totalPerformance;\r\n\r\n    uint settledLotteryIncome;\r\n  }\r\n\r\n  struct Run {\r\n\r\n    uint runPool;\r\n\r\n    uint endTime;\r\n\r\n    uint totalConsume;\r\n\r\n    uint record;\r\n\r\n    uint count;\r\n\r\n    uint num;\r\n\r\n    uint count2;\r\n\r\n    uint totalEth;\r\n\r\n    uint[] recordArr;\r\n\r\n    address lastAddr;\r\n\r\n    address[] lastAddrs;\r\n\r\n    mapping(address => uint) plyrMask;\r\n\r\n    mapping(address => uint) consumeMap;\r\n\r\n    mapping(address => uint) personalEth;\r\n  }\r\n\r\n  struct Scratch {\r\n\r\n    uint prizeNumber;\r\n\r\n    mapping(address => mapping(uint => uint)) roundIncome;\r\n\r\n    mapping(address => mapping(uint => uint[])) numberMap;\r\n\r\n    mapping(address => mapping(uint => uint[])) ethMap;\r\n\r\n    mapping(address => mapping(uint => uint[])) winMap;\r\n  }\r\n\r\n  struct Lottery {\r\n\r\n    uint lotteryPool;\r\n\r\n    uint unopenedBonus;\r\n\r\n    uint number;\r\n\r\n    uint time;\r\n\r\n    uint tokenNumber;\r\n\r\n    mapping(uint => uint[]) winNumber;\r\n\r\n    mapping(address => uint[]) lotteryMap;\r\n\r\n    mapping(uint => uint) awardAmount;\r\n  }\r\n\r\n  struct SaleQueue {\r\n\r\n    address addr;\r\n\r\n    uint tokenNumber;\r\n\r\n    uint remainingAmount;\r\n\r\n  }\r\n\r\n  struct PersonalSaleInfo {\r\n\r\n    uint tokenNumber;\r\n\r\n    uint saleNumber;\r\n  }\r\n\r\n  function rand(uint256 _length, uint256 num, uint256 salt) internal view returns(uint256) {\r\n    uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, num, salt)));\r\n    return random % _length;\r\n  }\r\n\r\n  function returnArray(uint len, uint range, uint number, uint salt) internal view returns(uint[]) {\r\n    uint[] memory numberArray = new uint[](len);\r\n    uint i = 0;\r\n    while (true) {\r\n      number = number + 9;\r\n      uint temp = rand(range, number, salt);\r\n      if (temp == 0) {\r\n        continue;\r\n      }\r\n      numberArray[i] = temp;\r\n      i++;\r\n      if (i == len) {\r\n        break;\r\n      }\r\n    }\r\n    return numberArray;\r\n  }\r\n\r\n  function generatePrizeNumber(uint256 seed, uint256 salt) internal view returns(uint) {\r\n    uint number = 0;\r\n    while (number < 10000) {\r\n      seed++;\r\n      number = rand(100000, seed, salt);\r\n    }\r\n    return number;\r\n  }\r\n}\r\n\r\ncontract LotteryRun {\r\n\r\n  address owner;\r\n  address runAddr;\r\n  address exAddr;\r\n  address[] winEthAddr = new address[](10);\r\n  uint[] winEth = new uint[](10);\r\n  uint winEthIndex = 0;\r\n  address[] winTokenAddr = new address[](10);\r\n  uint[] winToken = new uint[](10);\r\n  uint winTokenIndex = 0;\r\n  uint public rid = 1;\r\n  uint public scratchRoundID = 1;\r\n  uint public scratchRecord = 1;\r\n  // uint timeInterval = 4 * 60 * 60;\r\n  uint timeInterval = 60;\r\n  uint seed;\r\n  uint salt;\r\n  bool active = false;\r\n\r\n  mapping(address => uint) recordMap;\r\n\r\n  TokenRun token;\r\n  ExRun ex;\r\n  JustRun run;\r\n\r\n  mapping(uint => Data.Lottery) public lotteryGame;\r\n  mapping(uint => Data.Scratch) public scratchGame;\r\n  mapping(address => mapping(uint => uint)) public scratchIncome;\r\n\r\n  constructor(\r\n    address _ownerAddr,\r\n    address _tokenAddr,\r\n    address _exAddr\r\n  ) public {\r\n    owner = _ownerAddr;\r\n    token = TokenRun(_tokenAddr);\r\n    ex = ExRun(_exAddr);\r\n    exAddr = _exAddr;\r\n  }\r\n  /** Send ETH to join TICKET RUN\r\n   */\r\n  function() public payable {\r\n    uint _eth = msg.value;\r\n    bool flag = isContract(msg.sender);\r\n    if (!flag) {\r\n      if (_eth > 0) {\r\n        ethParticipateCore(msg.sender, address(0x0), _eth);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Active Contract with runAddr */\r\n  function activation(\r\n    address _runAddr,\r\n    uint _seed,\r\n    uint _salt\r\n  ) external {\r\n    require(active == false, \"activated\");\r\n    require(owner == msg.sender, \"Insufficient permissions\");\r\n    lotteryGame[rid] = Data.Lottery({\r\n      lotteryPool: 0,\r\n      unopenedBonus: 0,\r\n      number: 1,\r\n      time: now + timeInterval,\r\n      tokenNumber: 0\r\n    });\r\n    runAddr = _runAddr;\r\n    run = JustRun(_runAddr);\r\n    seed = _seed;\r\n    salt = _salt;\r\n    scratchGame[scratchRoundID] = Data.Scratch({\r\n      prizeNumber: Data.generatePrizeNumber(seed, salt)\r\n    });\r\n    seed = SafeMath.sub(seed, Data.rand(seed, seed, salt));\r\n    active = true;\r\n\r\n  }\r\n\r\n  /** Verify that the address is a contract address */\r\n  function isContract(address _addr) private view returns(bool) {\r\n    uint size;\r\n    assembly {\r\n      size: = extcodesize(_addr)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  /** get one round lottery income*/\r\n  function getLotteryIncome(address addr, uint roundId) private view returns(uint) {\r\n    Data.Lottery storage lottery = lotteryGame[roundId];\r\n    uint income = 0;\r\n    for (uint i = 0; i < 4; i++) {\r\n      if (lottery.awardAmount[i] != 0) {\r\n        income = SafeMath.add(income, calcWinIncome(lottery.lotteryMap[addr], lottery.winNumber[i], lottery.awardAmount[\r\n          i]));\r\n      }\r\n    }\r\n    return income;\r\n  }\r\n\r\n  /** Calc Lottery Income */\r\n  function calcWinIncome(uint[] lottoArr, uint[] arr, uint amount) private pure returns(uint) {\r\n    uint income = 0;\r\n    for (uint i = 0; i < arr.length; i++) {\r\n      uint j = 0;\r\n      while (j < lottoArr.length) {\r\n        if (arr[i] >= lottoArr[j] && arr[i] <= lottoArr[j + 1]) {\r\n          income = SafeMath.add(income, amount);\r\n        }\r\n        j = j + 3;\r\n      }\r\n    }\r\n    return income;\r\n  }\r\n\r\n  /** Buy Lottery Logic */\r\n  function buyLotto(address addr, uint value, uint tokenValue) private {\r\n    Data.Lottery storage lottery = lotteryGame[rid];\r\n    lottery.lotteryMap[addr].push(lottery.number);\r\n    lottery.lotteryMap[addr].push(SafeMath.add(lottery.number, value - 1));\r\n    lottery.number = SafeMath.add(lottery.number, value);\r\n    lottery.lotteryMap[addr].push(0);\r\n    lottery.tokenNumber = SafeMath.add(lottery.tokenNumber, tokenValue);\r\n  }\r\n\r\n  function prizeDistribution(uint[] winningNumber, uint divide, uint num, bool flag) private returns(uint) {\r\n    Data.Lottery storage lottery = lotteryGame[rid];\r\n    uint number = 0;\r\n    uint prize = 0;\r\n    if (num != 0) {\r\n      prize = SafeMath.div(SafeMath.mul(lottery.lotteryPool, divide), 10);\r\n    }\r\n    if (flag) {\r\n      uint personal = 0;\r\n      if (num == 0) {\r\n        personal = SafeMath.div(SafeMath.mul(lottery.unopenedBonus, 50), 100);\r\n        number = personal;\r\n      } else if (num == 1) {\r\n        personal = SafeMath.div(lottery.unopenedBonus, 10);\r\n        number = personal;\r\n        personal = SafeMath.add(personal, prize);\r\n        personal = SafeMath.div(personal, winningNumber.length);\r\n      } else if (num == 2) {\r\n        personal = SafeMath.div(lottery.unopenedBonus, 100);\r\n        number = personal;\r\n        personal = SafeMath.add(personal, prize);\r\n        personal = SafeMath.div(personal, winningNumber.length);\r\n      } else {\r\n        personal = SafeMath.div(prize, winningNumber.length);\r\n      }\r\n      lottery.awardAmount[num] = personal;\r\n    } else {\r\n      lottery.unopenedBonus = SafeMath.add(lottery.unopenedBonus, prize);\r\n    }\r\n    return number;\r\n  }\r\n\r\n  /** ETH Buy TICKET Logic */\r\n  function ethParticipateCore(address addr, address superiorAddr, uint _eth) private {\r\n    require(_eth >= 10 ** 16, \"Participate in scratch at least 0.01 eth\");\r\n    ex.externalRegister(addr, superiorAddr);\r\n    runAddr.transfer(_eth);\r\n    run.updateRunPool(addr, _eth, false);\r\n    uint runPool = run.getRunPool();\r\n    uint income = scratchCore(addr, 1, _eth, runPool);\r\n    if (income != 0) {\r\n      scratchIncome[addr][1] = SafeMath.add(scratchIncome[addr][1], income);\r\n      winEthAddr[winEthIndex] = addr;\r\n      winEth[winEthIndex] = income;\r\n      winEthIndex++;\r\n      if (winEthIndex > 9) {\r\n        winEthIndex = 0;\r\n      }\r\n      run.updateRunPool(addr, income, true);\r\n    }\r\n  }\r\n\r\n  function scratchCore(address addr, uint way, uint num, uint pool) private returns(uint) {\r\n    uint prizeNumber = scratchGame[scratchRoundID].prizeNumber;\r\n\r\n    uint number = Data.rand(100000, seed, salt);\r\n    seed = SafeMath.add(seed, Data.rand(100, seed, salt));\r\n\r\n    scratchGame[scratchRoundID].numberMap[addr][way].push(number);\r\n    scratchGame[scratchRoundID].ethMap[addr][way].push(num);\r\n    uint multiple = scratchNumber(prizeNumber, number);\r\n    uint income = 0;\r\n    if (multiple != 0) {\r\n      income = SafeMath.mul(num, multiple);\r\n      if (way == 1) {\r\n        uint amount = SafeMath.div(SafeMath.mul(pool, 60), 100);\r\n        if (income > amount) {\r\n          income = amount;\r\n        }\r\n      } else {\r\n        if (income > pool) {\r\n          income = pool;\r\n        }\r\n      }\r\n    }\r\n    scratchGame[scratchRoundID].winMap[addr][way].push(income);\r\n    if (scratchRecord % 100 == 0) {\r\n      scratchRoundID++;\r\n      seed = SafeMath.sub(seed, Data.rand(seed, seed, salt));\r\n      scratchGame[scratchRoundID].prizeNumber = Data.generatePrizeNumber(seed, salt);\r\n      seed = SafeMath.add(seed, Data.rand(100, seed, salt));\r\n    }\r\n    scratchRecord++;\r\n    return income;\r\n  }\r\n\r\n  function scratchNumber(uint prizeNumber, uint number) private pure returns(uint) {\r\n    if (number >= 10000) {\r\n      return getMultiple(prizeNumber, number, 5);\r\n    } else if (number >= 1000) {\r\n      return getMultiple(prizeNumber, number, 4);\r\n    } else if (number >= 100) {\r\n      return getMultiple(prizeNumber, number, 3);\r\n    } else if (number >= 10) {\r\n      return getMultiple(prizeNumber, number, 2);\r\n    } else {\r\n      return getMultiple(prizeNumber, number, 1);\r\n    }\r\n  }\r\n\r\n  function getMultiple(uint prizeNumber, uint number, uint count) private pure returns(uint) {\r\n    for (uint i = count; i > 0; i--) {\r\n      if (prizeNumber % (10 ** i) == number % (10 ** i)) {\r\n        if (i == 5) {\r\n          return 10000;\r\n        } else if (i == 4) {\r\n          return 1000;\r\n        } else if (i == 3) {\r\n          return 100;\r\n        } else if (i == 2) {\r\n          return 10;\r\n        } else {\r\n          return 5;\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  function winAmount() external view returns(address[], uint[], address[], uint[]) {\r\n    return (winEthAddr, winEth, winTokenAddr, winToken);\r\n  }\r\n\r\n  function getScratchNumber(uint roundID) external view returns(uint[], uint[], uint[], uint[], uint[], uint[]) {\r\n    return (\r\n      scratchGame[roundID].numberMap[msg.sender][1],\r\n      scratchGame[roundID].ethMap[msg.sender][1],\r\n      scratchGame[roundID].winMap[msg.sender][1],\r\n      scratchGame[roundID].numberMap[msg.sender][2],\r\n      scratchGame[roundID].ethMap[msg.sender][2],\r\n      scratchGame[roundID].winMap[msg.sender][2]\r\n    );\r\n  }\r\n\r\n  function tokenParticipateInScratch(address superiorAddr, uint value) external {\r\n    uint price = token.sellingPrice();\r\n    uint surplusSupply = token.surplusSupply();\r\n    require(token.balanceOf(msg.sender) >= value, \"not enough token\");\r\n    require(SafeMath.mul(price, value) >= 10 ** 16, \"Each sale of at least 0.01eth token\");\r\n    require(surplusSupply >= SafeMath.mul(value, 10), \"Can pay for insufficient tokens\");\r\n    ex.externalRegister(msg.sender, superiorAddr);\r\n\r\n    token.burn(msg.sender, value);\r\n    uint income = scratchCore(msg.sender, 2, value, surplusSupply);\r\n    if (income != 0) {\r\n      scratchIncome[msg.sender][2] = SafeMath.add(scratchIncome[msg.sender][2], income);\r\n      winTokenAddr[winTokenIndex] = msg.sender;\r\n      winToken[winTokenIndex] = income;\r\n      winTokenIndex++;\r\n      if (winTokenIndex > 9) {\r\n        winTokenIndex = 0;\r\n      }\r\n      token.getToken(income);\r\n      token.transfer(msg.sender, income);\r\n    }\r\n  }\r\n\r\n  function ethParticipateInScratch(address superiorAddr) external payable {\r\n    uint _eth = msg.value;\r\n    ethParticipateCore(msg.sender, superiorAddr, _eth);\r\n  }\r\n\r\n  function lotteryInfo(uint roundId) external view returns(uint[], uint[], uint[], uint[], uint[], uint[], uint) {\r\n    Data.Lottery storage lottery = lotteryGame[roundId];\r\n    uint[] memory award = new uint[](4);\r\n    for (uint i = 0; i < 4; i++) {\r\n      award[i] = lottery.awardAmount[i];\r\n    }\r\n    uint income = getLotteryIncome(msg.sender, roundId);\r\n    return (lottery.winNumber[0], lottery.winNumber[1], lottery.winNumber[2], lottery.winNumber[3], award, lottery.lotteryMap[\r\n      msg.sender], income);\r\n  }\r\n\r\n  /** End lotto and start the next lotto */\r\n  function atomicOperationLottery() external {\r\n    require(owner == msg.sender, \"Insufficient permissions\");\r\n    Data.Lottery storage lottery = lotteryGame[rid];\r\n    require(now >= lottery.time, \"The current time cannot be drawn\");\r\n    uint lotteryNumber = lottery.number;\r\n    if (lottery.lotteryPool > 0 && lotteryNumber > 1) {\r\n      bool flag = false;\r\n      uint multiple = 30;\r\n      uint number = 1;\r\n      uint totalNumber = 0;\r\n      uint num = 2;\r\n      for (uint i = 0; i < 4; i++) {\r\n        if (i == 1) {\r\n          multiple = 10;\r\n          number = 2;\r\n        } else if (i == 2) {\r\n          multiple = 3;\r\n          number = 5;\r\n          num = 5;\r\n        } else if (i == 3) {\r\n          number = 10;\r\n          num = 3;\r\n        }\r\n        flag = lottery.tokenNumber >= SafeMath.mul(token.calcTokenReceived(lottery.lotteryPool), multiple);\r\n        if (i == 3) {\r\n          flag = true;\r\n        }\r\n        uint[] memory numberArr;\r\n        if (flag) {\r\n          numberArr = Data.returnArray(number, lotteryNumber, seed, salt);\r\n          seed++;\r\n          lottery.winNumber[i] = numberArr;\r\n        }\r\n        totalNumber = SafeMath.add(prizeDistribution(numberArr, num, i, flag), totalNumber);\r\n      }\r\n      lottery.unopenedBonus = SafeMath.sub(lottery.unopenedBonus, totalNumber);\r\n    } else {\r\n      lottery.unopenedBonus = SafeMath.add(lottery.unopenedBonus, lottery.lotteryPool);\r\n    }\r\n    rid++;\r\n    lotteryGame[rid] = Data.Lottery({\r\n      lotteryPool: 0,\r\n      unopenedBonus: lotteryGame[rid - 1].unopenedBonus,\r\n      number: 1,\r\n      time: now + timeInterval,\r\n      tokenNumber: 0\r\n    });\r\n  }\r\n\r\n  /** Join the lotto game */\r\n  function participateInLottery(address superiorAddr, uint value) external {\r\n    require(value >= 1, \"Purchase at least one lotto code\");\r\n    uint _eth = 5 * 10 ** 15;\r\n    uint tokenNumber = token.calcTokenReceived(SafeMath.mul(value, _eth));\r\n    require(token.balanceOf(msg.sender) >= tokenNumber, \"not enough token\");\r\n    ex.externalRegister(msg.sender, superiorAddr);\r\n    token.burn(msg.sender, tokenNumber);\r\n    buyLotto(msg.sender, value, tokenNumber);\r\n  }\r\n\r\n  /** get all lottery income */\r\n  function getAllLotteryIncome(address addr, bool flag) external view returns(uint) {\r\n    require(runAddr == msg.sender || owner == msg.sender || addr == msg.sender, \"Insufficient permissions\");\r\n    uint income = 0;\r\n    uint index = 1;\r\n    if (flag) {\r\n      index = recordMap[addr];\r\n    }\r\n    for (uint i = index; i < rid; i++) {\r\n      income = SafeMath.add(income, getLotteryIncome(addr, i));\r\n    }\r\n    return income;\r\n  }\r\n\r\n  function updateLotteryPool(uint value) external {\r\n    require(runAddr == msg.sender, \"Insufficient permissions\");\r\n    lotteryGame[rid].lotteryPool = SafeMath.add(lotteryGame[rid].lotteryPool, value);\r\n  }\r\n\r\n  function deductionFee(address addr, uint _eth) external returns(uint) {\r\n    require(runAddr == msg.sender, \"Insufficient permissions\");\r\n    recordMap[addr] = rid;\r\n    uint handlingFee = SafeMath.div(_eth, 100);\r\n    lotteryGame[rid].lotteryPool = SafeMath.add(lotteryGame[rid].lotteryPool, handlingFee);\r\n    uint value = SafeMath.div(handlingFee, 5 * 10 ** 15);\r\n    if (value > 0) {\r\n      uint tokenCount = token.calcTokenReceived(handlingFee);\r\n      buyLotto(addr, value, tokenCount);\r\n    }\r\n    return handlingFee;\r\n  }\r\n\r\n  function aaa(uint256 a, uint256 b) external pure returns (uint256) {\r\n      return a + b;\r\n  }\r\n\r\n  function bbb(uint256 a, uint256 b) external pure returns (uint256) {\r\n      return a - b;\r\n  }\r\n\r\n}\r\n\r\ncontract TokenRun {\r\n  function calcTokenReceived(uint _eth) external view returns(uint);\r\n\r\n  function burn(address addr, uint value) public;\r\n\r\n  function surplusSupply() public view returns(uint);\r\n\r\n  function getToken(uint value) external;\r\n\r\n  function sellingPrice() public view returns(uint);\r\n\r\n  function transfer(address to, uint value) public;\r\n\r\n  function balanceOf(address addr) public view returns(uint);\r\n}\r\n\r\ncontract JustRun {\r\n  function getRunPool() external view returns(uint);\r\n\r\n  function updateRunPool(address addr, uint _eth, bool flag) external;\r\n}\r\n\r\ncontract ExRun {\r\n  function externalRegister(address addr, address superiorAddr) external;\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"superiorAddr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"participateInLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"scratchGame\",\"outputs\":[{\"name\":\"prizeNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_runAddr\",\"type\":\"address\"},{\"name\":\"_seed\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"activation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"getScratchNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"aaa\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scratchRecord\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateLotteryPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"atomicOperationLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"getAllLotteryIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superiorAddr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"tokenParticipateInScratch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lotteryGame\",\"outputs\":[{\"name\":\"lotteryPool\",\"type\":\"uint256\"},{\"name\":\"unopenedBonus\",\"type\":\"uint256\"},{\"name\":\"number\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"tokenNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"deductionFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"name\":\"ethParticipateInScratch\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"bbb\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"lotteryInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scratchRoundID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"scratchIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ownerAddr\",\"type\":\"address\"},{\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"name\":\"_exAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"LotteryRun","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000119eb8e686423e56b7cfc6f211c8cd4a9f71e3cc00000000000000000000000079dd747cb3d8f9c45805813d4b52e398b258c7d0000000000000000000000000d936fa73e41b8ff0d075b28e60b943271fd3d096","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b1c9a58e5105a4076b7950c1f5af35762ed6e035a649ad174b9c666cd2835c58"}]}