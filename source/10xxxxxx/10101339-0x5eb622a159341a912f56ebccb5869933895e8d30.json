{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/upgradable/OwnableUpgradable.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n// import \"../openzeppelin/upgrades/contracts/Initializable.sol\";\r\n\r\ncontract OwnableUpgradable is Initializable {\r\n    address payable public owner;\r\n    address payable internal newOwnerCandidate;\r\n\r\n    // Initializer – Constructor for Upgradable contracts\r\n    function initialize() public initializer {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Permission denied\");\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address payable newOwner) public onlyOwner {\r\n        newOwnerCandidate = newOwner;\r\n    }\r\n\r\n    function acceptOwner() public {\r\n        require(msg.sender == newOwnerCandidate, \"Permission denied\");\r\n        owner = newOwnerCandidate;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/upgradable/AdminableUpgradable.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n// import \"../openzeppelin/upgrades/contracts/Initializable.sol\";\r\n\r\n\r\n\r\ncontract AdminableUpgradable is Initializable, OwnableUpgradable {\r\n    mapping(address => bool) public admins;\r\n\r\n\r\n    modifier onlyOwnerOrAdmin {\r\n        require(msg.sender == owner ||\r\n                admins[msg.sender], \"Permission denied\");\r\n        _;\r\n    }\r\n\r\n\r\n    // Initializer – Constructor for Upgradable contracts\r\n    function initialize() public initializer {\r\n        OwnableUpgradable.initialize();  // Initialize Parent Contract\r\n    }\r\n\r\n\r\n    function setAdminPermission(address _admin, bool _status) public onlyOwner {\r\n        admins[_admin] = _status;\r\n    }\r\n\r\n    function setAdminPermission(address[] memory _admins, bool _status) public onlyOwner {\r\n        for (uint i = 0; i < _admins.length; i++) {\r\n            admins[_admins[i]] = _status;\r\n        }\r\n    }\r\n\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/utils/DSMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y, uint base) internal pure returns (uint z) {\r\n        z = add(mul(x, y), base / 2) / base;\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    /*function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }*/\r\n}\r\n\r\n// File: contracts/affiliateProgram/AffiliateProgram.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n\r\n\r\n\r\ncontract AffiliateProgram is Initializable, DSMath, AdminableUpgradable {\r\n\r\n    struct LevelProgram {\r\n        uint8 percent;\r\n        uint80 ethAmount;\r\n    }\r\n\r\n    struct Partner {\r\n        // first bytes32 (== uint256) slot\r\n        address partnerAddr;        //  address of the partner\r\n        uint8 level;                //  Aff Program level\r\n\r\n        // second bytes32 (== uint256) slot\r\n        uint80 profit;              //  partner's current profit\r\n        uint80 referralsCount;      //  partner's referrals count\r\n        uint80 referralsEthValue;   //  eth invested by partner's referrals\r\n    }\r\n\r\n\r\n    uint256 public constant LEVEL_COUNTER = 3;\r\n\r\n\r\n    mapping(uint8 => LevelProgram) public levels;\r\n\r\n    mapping(bytes32 => Partner) public codeToPartner;\r\n    mapping(address => bytes32) public partnerToCode;\r\n\r\n    mapping(address => bool) public permissionAddresses;\r\n\r\n    mapping(address => address) internal referralToReferrer;\r\n\r\n\r\n    // ** EVENTS **\r\n\r\n    event PartnerAdded(address indexed partner, uint8 level, bytes32 code);\r\n\r\n    event ReferralAdded(address indexed referral, bytes32 code);\r\n\r\n    event ProfitDistributed(bytes32 indexed code, uint256 profit);\r\n\r\n    event ProfitWithdrawn(address indexed partner, uint256 profit);\r\n\r\n\r\n    // ** MODIFIERS **\r\n\r\n    modifier needPermission {\r\n        require(permissionAddresses[msg.sender], \"Permission denied\");\r\n        _;\r\n    }\r\n\r\n    modifier RegDataValidation(address partner, bytes32 code) {\r\n        require(partner != address(0), \"Address must not be zero\");\r\n        require(code != bytes32(0), \"Promocode must not be zero\");\r\n        require(codeToPartner[code].partnerAddr == address(0), \"Promo code is already registered\");\r\n        require(partnerToCode[partner] == bytes32(0), \"User is already registered\");\r\n        _;\r\n    }\r\n\r\n\r\n    // ** INITIALIZER – Constructor for Upgradable contracts **\r\n\r\n    function initialize() public initializer {\r\n        AdminableUpgradable.initialize();  // Initialize Parent Contract\r\n\r\n        levels[0] = LevelProgram(20, 0 ether);      // 20% and 0 ETH from referrals\r\n        levels[1] = LevelProgram(35, 1000 ether);   // 35% and more 1000 ETH from referrals\r\n        levels[2] = LevelProgram(50, 3000 ether);   // 50% and more 3000 ETH from referrals\r\n    }\r\n\r\n\r\n    // ** PUBLIC VIEW functions **\r\n\r\n    function getPartnerByCode(bytes32 code) public view returns (address, uint8, uint256, uint256, uint256) {\r\n        Partner memory curPartner = codeToPartner[code];\r\n\r\n        return (\r\n            curPartner.partnerAddr,\r\n            curPartner.level,\r\n            curPartner.referralsCount,\r\n            curPartner.referralsEthValue,\r\n            curPartner.profit\r\n        );\r\n    }\r\n\r\n    function getPartnerByReferral(address referral) public view returns (address, uint8, uint256, uint256, uint256) {\r\n        Partner memory curPartner = codeToPartner[partnerToCode[referralToReferrer[referral]]];\r\n\r\n        return (\r\n            curPartner.partnerAddr,\r\n            curPartner.level,\r\n            curPartner.referralsCount,\r\n            curPartner.referralsEthValue,\r\n            curPartner.profit\r\n        );\r\n    }\r\n\r\n    function getProfitPercentByReferral(address referral) public view returns (uint8) {\r\n        Partner memory curPartner = codeToPartner[partnerToCode[referralToReferrer[referral]]];\r\n\r\n        return levels[curPartner.level].percent;\r\n    }\r\n\r\n    function isUserInPartnership(bytes32 code, address referral) public view returns (bool) {\r\n        return (referralToReferrer[referral] == codeToPartner[code].partnerAddr);\r\n    }\r\n\r\n\r\n    // ** ONLY_OWNER_OR_ADMIN functions **\r\n\r\n    function setPermissionAddress(address addr, bool status)\r\n        public\r\n        onlyOwnerOrAdmin\r\n    {\r\n        permissionAddresses[addr] = status;\r\n    }\r\n\r\n    function setPermissionAddresses(address[] memory addrs, bool status)\r\n        public\r\n        onlyOwnerOrAdmin\r\n    {\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            permissionAddresses[addrs[i]] = status;\r\n        }\r\n    }\r\n\r\n    function updateLevel(uint8 level, uint8 percent, uint80 ethAmount)\r\n        public\r\n        onlyOwnerOrAdmin\r\n    {\r\n        require(level < LEVEL_COUNTER, \"Level is incorrect\");\r\n        require(percent <= 100, \"Percent is incorrect\");\r\n\r\n        levels[level].percent = percent;\r\n        levels[level].ethAmount = ethAmount;\r\n    }\r\n\r\n    function addPartnerByAdmin(address partner, uint8 level, bytes32 code)\r\n        public\r\n        onlyOwnerOrAdmin\r\n        RegDataValidation(partner, code)\r\n    {\r\n        require(level < LEVEL_COUNTER, \"Level is incorrect\");\r\n\r\n        _addPartnerHelper(partner, level, code);\r\n    }\r\n\r\n\r\n    // ** PUBLIC functions **\r\n\r\n    function register(bytes32 code)\r\n        public\r\n        RegDataValidation(msg.sender, code)\r\n    {\r\n        _addPartnerHelper(msg.sender, 0, code);\r\n    }\r\n\r\n    function withdrawProfit() public {\r\n        address payable partner = msg.sender;\r\n        uint ethToWithdraw = codeToPartner[partnerToCode[partner]].profit;\r\n        require(ethToWithdraw > 0, \"No profit\");\r\n\r\n        // UPD partner's profit state and transfer eth\r\n        codeToPartner[partnerToCode[partner]].profit = 0;\r\n        partner.transfer(ethToWithdraw);\r\n\r\n        emit ProfitWithdrawn(partner, ethToWithdraw);\r\n    }\r\n\r\n\r\n    // ** PUBLIC PAYABLE NEED_PERMISSION functions - distribute profit **\r\n\r\n    function distributeProfit(address partner)\r\n        public\r\n        payable\r\n        needPermission\r\n    {\r\n        _distributeProfitHelper(partnerToCode[partner]);\r\n    }\r\n\r\n    function distributeProfit(bytes32 code)\r\n        public\r\n        payable\r\n        needPermission\r\n    {\r\n        _distributeProfitHelper(code);\r\n    }\r\n\r\n    function distributeProfitByReferral(address referral)\r\n        public\r\n        payable\r\n        needPermission\r\n    {\r\n        _distributeProfitHelper(partnerToCode[referralToReferrer[referral]]);\r\n    }\r\n\r\n\r\n    // ** PUBLIC NEED_PERMISSION functions - add referral **\r\n\r\n    function addReferral(address referral, bytes32 code, uint256 ethValue)\r\n        public\r\n        needPermission\r\n        returns(uint256)    // 0 == deposit added to a new referrer\r\n                            // 1 == deposit added to an exists referrer\r\n                            // 2 == deposit did not add, referrer does not exist\r\n    {\r\n        return _addReferralHelper(referral, code, ethValue);\r\n    }\r\n\r\n    function addReferral(address referral, address partner, uint256 ethValue)\r\n        public\r\n        needPermission\r\n        returns(uint256)    // 0 == deposit added to a new referrer\r\n                            // 1 == deposit added to an exists referrer\r\n                            // 2 == deposit did not add, referrer does not exist\r\n    {\r\n        return _addReferralHelper(referral, partnerToCode[partner], ethValue);\r\n    }\r\n\r\n\r\n    // ** INTERNAL functions **\r\n\r\n    function _addPartnerHelper(address partner, uint8 level, bytes32 code)\r\n        internal\r\n    {\r\n        // Set New Partner\r\n        partnerToCode[partner] = code;\r\n        codeToPartner[code] = Partner(partner, level, 0, 0, 0);\r\n\r\n        emit PartnerAdded(partner, level, code);\r\n    }\r\n\r\n    function _distributeProfitHelper(bytes32 code)\r\n        internal\r\n    {\r\n        Partner memory curPartner = codeToPartner[code];\r\n        require(curPartner.partnerAddr != address(0), \"Promocode is not exists\");\r\n\r\n        // UPD partner's profit state\r\n        uint curProfit = msg.value;\r\n        codeToPartner[code].profit = uint80(add(curPartner.profit, curProfit));\r\n\r\n        emit ProfitDistributed(code, curProfit);\r\n    }\r\n\r\n    function _addReferralHelper(address referral, bytes32 code, uint256 ethValue)\r\n        internal\r\n        returns(uint256)    // 0 == deposit added to a new referrer\r\n                            // 1 == deposit added to an exists referrer\r\n                            // 2 == deposit did not add, referrer does not exist\r\n    {\r\n        Partner memory curPartner = codeToPartner[code];\r\n\r\n        // Referrer does not exist\r\n        // require(codeToPartner[code].partnerAddr != address(0), \"Referrer does not exist\");\r\n        if (curPartner.partnerAddr == address(0)) {\r\n            return 2;\r\n        }\r\n\r\n        // UPD referralsEthValue state\r\n        uint80 referralsEthValue;\r\n        codeToPartner[code].referralsEthValue = referralsEthValue = uint80(add(curPartner.referralsEthValue, ethValue));\r\n\r\n        // UPD level state\r\n        uint level = (referralsEthValue < levels[1].ethAmount) ? 0 : ((referralsEthValue < levels[2].ethAmount) ? 1 : 2);\r\n        if (level > curPartner.level) {\r\n            codeToPartner[code].level = uint8(level);\r\n        }\r\n\r\n        // Referral is already added\r\n        // require(referralToReferrer[referral] == address(0), \"Referral is already added\");\r\n        if (referralToReferrer[referral] != address(0)) {\r\n            return 1;\r\n        }\r\n\r\n        // UPD referralsCount and referralToReferrer states\r\n        codeToPartner[code].referralsCount += 1;\r\n        referralToReferrer[referral] = curPartner.partnerAddr;\r\n\r\n        emit ReferralAdded(referral, code);\r\n        return 0;\r\n    }\r\n\r\n\r\n    uint256[50] private ______gap;\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"PartnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"ProfitDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"ProfitWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"ReferralAdded\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"LEVEL_COUNTER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"addPartnerByAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"}],\"name\":\"addReferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"}],\"name\":\"addReferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"codeToPartner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"partnerAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint80\",\"name\":\"profit\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"referralsCount\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"referralsEthValue\",\"type\":\"uint80\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"distributeProfit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"distributeProfit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"distributeProfitByReferral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"getPartnerByCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"getPartnerByReferral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"getProfitPercentByReferral\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"isUserInPartnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"},{\"internalType\":\"uint80\",\"name\":\"ethAmount\",\"type\":\"uint80\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partnerToCode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permissionAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdminPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_admins\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdminPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setPermissionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setPermissionAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"},{\"internalType\":\"uint80\",\"name\":\"ethAmount\",\"type\":\"uint80\"}],\"name\":\"updateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AffiliateProgram","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://51bbef441bf6afa7f0254e0d569988595613566f03f6b01ea7c5b0eb561264d0"}]}