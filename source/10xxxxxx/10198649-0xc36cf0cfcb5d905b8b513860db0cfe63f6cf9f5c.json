{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n}\\n\"},\"Common.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\ncontract CommonConstants {\\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\\n}\\n\"},\"ERC165.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\ninterface ERC165 {\\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool);\\n}\\n\"},\"Gala.sol\":{\"content\":\"import \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./Common.sol\\\";\\nimport \\\"./IERC1155TokenReceiver.sol\\\";\\nimport \\\"./IERC1155.sol\\\";\\n\\npragma solidity ^0.5.0;\\n\\n\\ncontract Gala is IERC1155, ERC165, CommonConstants {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    uint256 constant TYPE_MASK = uint256(uint128(~0)) \\u003c\\u003c 128;\\n    uint256 constant NF_INDEX_MASK = uint128(~0);\\n    uint256 constant TYPE_NF_BIT = 1 \\u003c\\u003c 255;\\n    uint256 nonce;\\n\\n    address public owner;\\n\\n    mapping(uint256 =\\u003e mapping(address =\\u003e uint256)) internal balances; // id =\\u003e (owner =\\u003e balance)\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) internal operatorApproval; // owner =\\u003e (operator =\\u003e approved)\\n    mapping(uint256 =\\u003e address) nfOwners;\\n    mapping(uint256 =\\u003e uint256) public maxIndex;\\n    mapping(address =\\u003e mapping(address =\\u003e mapping(uint256 =\\u003e uint256))) allowances;\\n    mapping(uint256 =\\u003e uint256) public tokenSupply;\\n    mapping(uint256 =\\u003e uint256) public tokenSupplyLimit;\\n    mapping(address =\\u003e bool) internal creators;\\n\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _spender,\\n        uint256 indexed _id,\\n        uint256 _oldValue,\\n        uint256 _value\\n    );\\n    event SupplyLimit(uint256 indexed _id, uint256 _supplyLimit);\\n\\n    event TransferSingle(\\n        address indexed _operator,\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 _id,\\n        uint256 _value\\n    );\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n    event URI(string _value, uint256 indexed _id);\\n    event TransferBatch(\\n        address indexed _operator,\\n        address indexed _from,\\n        address indexed _to,\\n        uint256[] _ids,\\n        uint256[] _values\\n    );\\n\\n    event Creator(address _creator);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        creators[msg.sender] = true;\\n    }\\n\\n    modifier creatorOnly() {\\n        require(creators[msg.sender], \\\"Creator permission required\\\");\\n        _;\\n    }\\n\\n    modifier ownerOnly() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function create(string calldata _uri, bool _isNF) external creatorOnly returns (uint256 _type) {\\n        _type = (++nonce \\u003c\\u003c 128);\\n\\n        if (_isNF) _type = _type | TYPE_NF_BIT;\\n\\n        emit TransferSingle(msg.sender, address(0x0), address(0x0), _type, 0);\\n\\n        if (bytes(_uri).length \\u003e 0) emit URI(_uri, _type);\\n        return _type;\\n    }\\n\\n    function mintNonFungible(\\n        uint256 _type,\\n        address[] calldata _to,\\n        bytes calldata _data\\n    ) external creatorOnly {\\n        require(isNonFungible(_type));\\n        uint256 index = maxIndex[_type] + 1;\\n        maxIndex[_type] = _to.length.add(maxIndex[_type]);\\n        for (uint256 i = 0; i \\u003c _to.length; ++i) {\\n            address distributeTo = _to[i];\\n            uint256 id = _type | (index + i);\\n            require(\\n                tokenSupplyLimit[_type] == 0 ||\\n                    tokenSupply[_type].add(1) \\u003c= tokenSupplyLimit[_type],\\n                \\\"Token supply limit exceeded\\\"\\n            );\\n            nfOwners[id] = distributeTo;\\n            tokenSupply[_type] = tokenSupply[_type].add(1);\\n            balances[_type][distributeTo] = balances[_type][distributeTo].add(1);\\n\\n            emit TransferSingle(msg.sender, address(0x0), distributeTo, id, 1);\\n\\n            if (distributeTo.isContract()) {\\n                _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, distributeTo, id, 1, _data);\\n            }\\n        }\\n    }\\n\\n    function mintFungible(\\n        uint256 _id,\\n        address[] calldata _to,\\n        uint256[] calldata _quantities,\\n        bytes calldata _data\\n    ) external creatorOnly {\\n        require(isFungible(_id), \\\"ID must be a non-fungible ID\\\");\\n        for (uint256 i = 0; i \\u003c _to.length; ++i) {\\n            require(\\n                tokenSupplyLimit[_id] == 0 ||\\n                    tokenSupply[_id].add(_quantities[i]) \\u003c= tokenSupplyLimit[_id],\\n                \\\"Token supply limit exceeded\\\"\\n            );\\n            balances[_id][_to[i]] = _quantities[i].add(balances[_id][_to[i]]);\\n            tokenSupply[_id] = tokenSupply[_id].add(_quantities[i]);\\n\\n            emit TransferSingle(msg.sender, address(0x0), _to[i], _id, _quantities[i]);\\n\\n            if (_to[i].isContract()) {\\n                _doSafeTransferAcceptanceCheck(\\n                    msg.sender,\\n                    msg.sender,\\n                    _to[i],\\n                    _id,\\n                    _quantities[i],\\n                    _data\\n                );\\n            }\\n        }\\n    }\\n\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external {\\n        require(_to != address(0x0), \\\"cannot send to zero address\\\");\\n        require(\\n            _from == msg.sender || operatorApproval[_from][msg.sender] == true,\\n            \\\"Need operator approval for 3rd party transfers.\\\"\\n        );\\n\\n        if (isNonFungible(_id)) {\\n            require(nfOwners[_id] == _from);\\n            nfOwners[_id] = _to;\\n            // You could keep balance of NF type in base type id like so:\\n            uint256 baseType = getNonFungibleBaseType(_id);\\n            balances[baseType][_from] = balances[baseType][_from].sub(_value);\\n            balances[baseType][_to] = balances[baseType][_to].add(_value);\\n        } else {\\n            balances[_id][_from] = balances[_id][_from].sub(_value);\\n            balances[_id][_to] = balances[_id][_to].add(_value);\\n        }\\n\\n        emit TransferSingle(msg.sender, _from, _to, _id, _value);\\n\\n        if (_to.isContract()) {\\n            _doSafeTransferAcceptanceCheck(msg.sender, _from, _to, _id, _value, _data);\\n        }\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values,\\n        bytes calldata _data\\n    ) external {\\n        require(_to != address(0x0), \\\"cannot send to zero address\\\");\\n        require(_ids.length == _values.length, \\\"Array length must match\\\");\\n        require(\\n            _from == msg.sender || operatorApproval[_from][msg.sender] == true,\\n            \\\"Need operator approval for 3rd party transfers.\\\"\\n        );\\n\\n        for (uint256 i = 0; i \\u003c _ids.length; ++i) {\\n            if (isNonFungible(_ids[i])) {\\n                require(nfOwners[_ids[i]] == _from);\\n                nfOwners[_ids[i]] = _to;\\n                balances[getNonFungibleBaseType(_ids[i])][_from] = balances[getNonFungibleBaseType(\\n                    _ids[i]\\n                )][_from]\\n                    .sub(_values[i]);\\n                balances[getNonFungibleBaseType(_ids[i])][_to] = balances[getNonFungibleBaseType(\\n                    _ids[i]\\n                )][_to]\\n                    .add(_values[i]);\\n            } else {\\n                balances[_ids[i]][_from] = balances[_ids[i]][_from].sub(_values[i]);\\n                balances[_ids[i]][_to] = _values[i].add(balances[_ids[i]][_to]);\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, _from, _to, _ids, _values);\\n\\n        if (_to.isContract()) {\\n            _doSafeBatchTransferAcceptanceCheck(msg.sender, _from, _to, _ids, _values, _data);\\n        }\\n    }\\n\\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\\n        if (isNonFungibleItem(_id)) return nfOwners[_id] == _owner ? 1 : 0;\\n        return balances[_id][_owner];\\n    }\\n\\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        require(_owners.length == _ids.length);\\n        uint256[] memory balances_ = new uint256[](_owners.length);\\n        for (uint256 i = 0; i \\u003c _owners.length; ++i) {\\n            uint256 id = _ids[i];\\n            if (isNonFungibleItem(id)) {\\n                balances_[i] = nfOwners[id] == _owners[i] ? 1 : 0;\\n            } else {\\n                balances_[i] = balances[id][_owners[i]];\\n            }\\n        }\\n\\n        return balances_;\\n    }\\n\\n    function setApprovalForAll(address _operator, bool _approved) external {\\n        operatorApproval[msg.sender][_operator] = _approved;\\n        emit ApprovalForAll(msg.sender, _operator, _approved);\\n    }\\n\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\\n        return operatorApproval[_owner][_operator];\\n    }\\n\\n    function setSupplyLimit(uint256 _typeOrId, uint256 _supplyLimit) external creatorOnly {\\n        require(_supplyLimit \\u003e 0);\\n        if (isNonFungibleItem(_typeOrId)) {\\n            uint256 typeId = getNonFungibleBaseType(_typeOrId);\\n            require(tokenSupplyLimit[typeId] == 0);\\n            tokenSupplyLimit[typeId] = _supplyLimit;\\n            emit SupplyLimit(typeId, _supplyLimit);\\n        } else {\\n            require(tokenSupplyLimit[_typeOrId] == 0);\\n            tokenSupplyLimit[_typeOrId] = _supplyLimit;\\n            emit SupplyLimit(_typeOrId, _supplyLimit);\\n        }\\n    }\\n\\n    function approveBatch(\\n        address _spender,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _currentValues,\\n        uint256[] calldata _values\\n    ) external {\\n        require(_ids.length == _currentValues.length, \\\"Arrays must be same length\\\");\\n        require(_currentValues.length == _values.length, \\\"Arrays must be same length\\\");\\n        for (uint256 i = 0; i \\u003c _values.length; i++) {\\n            uint256 id = _ids[i];\\n            uint256 currentValue = _currentValues[i];\\n            uint256 value = _values[i];\\n            require(allowances[msg.sender][_spender][id] == currentValue);\\n            allowances[msg.sender][_spender][id] = value;\\n            emit Approval(msg.sender, _spender, id, currentValue, value);\\n        }\\n    }\\n\\n    function isNonFungible(uint256 _id) public pure returns (bool) {\\n        return _id \\u0026 TYPE_NF_BIT == TYPE_NF_BIT;\\n    }\\n\\n    function isFungible(uint256 _id) public pure returns (bool) {\\n        return _id \\u0026 TYPE_NF_BIT == 0;\\n    }\\n\\n    function getNonFungibleIndex(uint256 _id) public pure returns (uint256) {\\n        return _id \\u0026 NF_INDEX_MASK;\\n    }\\n\\n    function getNonFungibleBaseType(uint256 _id) public pure returns (uint256) {\\n        return _id \\u0026 TYPE_MASK;\\n    }\\n\\n    function isNonFungibleBaseType(uint256 _id) public pure returns (bool) {\\n        // A base type has the NF bit but does not have an index.\\n        return (_id \\u0026 TYPE_NF_BIT == TYPE_NF_BIT) \\u0026\\u0026 (_id \\u0026 NF_INDEX_MASK == 0);\\n    }\\n\\n    function isNonFungibleItem(uint256 _id) public pure returns (bool) {\\n        // A base type has the NF bit but does has an index.\\n        return (_id \\u0026 TYPE_NF_BIT == TYPE_NF_BIT) \\u0026\\u0026 (_id \\u0026 NF_INDEX_MASK != 0);\\n    }\\n\\n    function ownerOf(uint256 _id) public view returns (address) {\\n        return nfOwners[_id];\\n    }\\n\\n    /////////////////////////////////////////// ERC165 //////////////////////////////////////////////\\n\\n    bytes4 private constant INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\\n    bytes4 private constant INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\\n\\n    function supportsInterface(bytes4 _interfaceId) public view returns (bool) {\\n        if (\\n            _interfaceId == INTERFACE_SIGNATURE_ERC165 ||\\n            _interfaceId == INTERFACE_SIGNATURE_ERC1155\\n        ) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /////////////////////////////////////////// Internal //////////////////////////////////////////////\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address _operator,\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes memory _data\\n    ) internal {\\n        require(\\n            ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) ==\\n                ERC1155_ACCEPTED,\\n            \\\"contract returned an unknown value from onERC1155Received\\\"\\n        );\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address _operator,\\n        address _from,\\n        address _to,\\n        uint256[] memory _ids,\\n        uint256[] memory _values,\\n        bytes memory _data\\n    ) internal {\\n        require(\\n            ERC1155TokenReceiver(_to).onERC1155BatchReceived(\\n                _operator,\\n                _from,\\n                _ids,\\n                _values,\\n                _data\\n            ) == ERC1155_BATCH_ACCEPTED,\\n            \\\"contract returned an unknown value from onERC1155BatchReceived\\\"\\n        );\\n    }\\n\\n    /////////////////////////////////////////// ERC1155 //////////////////////////////////////////////\\n\\n    function batchAuthorizeCreators(address[] calldata _addresses) external ownerOnly {\\n        for (uint256 i = 0; i \\u003c _addresses.length; ++i) {\\n            emit Creator(_addresses[i]);\\n            creators[_addresses[i]] = true;\\n        }\\n    }\\n\\n    function batchDeauthorizeCreators(address[] calldata _addresses) external ownerOnly {\\n        for (uint256 i = 0; i \\u003c _addresses.length; ++i) {\\n            delete creators[_addresses[i]];\\n        }\\n    }\\n\\n    function allowance(\\n        address _owner,\\n        address _spender,\\n        uint256 _id\\n    ) external view returns (uint256) {\\n        return allowances[_owner][_spender][_id];\\n    }\\n\\n    function burn(\\n        address _from,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values\\n    ) external {\\n        require(\\n            _from == msg.sender || operatorApproval[_from][msg.sender] == true,\\n            \\\"Need operator approval for 3rd party burn.\\\"\\n        );\\n        require(_ids.length \\u003e 0 \\u0026\\u0026 _ids.length == _values.length);\\n        for (uint256 i = 0; i \\u003c _ids.length; i++) {\\n            if (isFungible(_ids[i])) {\\n                require(balances[_ids[i]][_from] \\u003e= _values[i]);\\n                balances[_ids[i]][_from] = balances[_ids[i]][_from].sub(_values[i]);\\n            } else {\\n                require(isNonFungible(_ids[i]));\\n                require(_values[i] == 1);\\n                uint256 baseType = getNonFungibleBaseType(_ids[i]);\\n                // --totalSupply?\\n                balances[baseType][_from] = balances[baseType][_from].sub(1);\\n                delete nfOwners[_ids[i]];\\n            }\\n            emit TransferSingle(msg.sender, _from, address(0x0), _ids[i], _values[i]);\\n        }\\n    }\\n\\n    function setNewUri(string calldata _uri, uint256 _id) external creatorOnly {\\n        require(bytes(_uri).length \\u003e 0);\\n        emit URI(_uri, _id);\\n    }\\n}\\n\"},\"IERC1155.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC165.sol\\\";\\n\\n\\n/* is ERC165 */\\ninterface IERC1155 {\\n    event TransferSingle(\\n        address indexed _operator,\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 _id,\\n        uint256 _value\\n    );\\n    event TransferBatch(\\n        address indexed _operator,\\n        address indexed _from,\\n        address indexed _to,\\n        uint256[] _ids,\\n        uint256[] _values\\n    );\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n    event URI(string _value, uint256 indexed _id);\\n\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values,\\n        bytes calldata _data\\n    ) external;\\n\\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\n\\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\"},\"IERC1155TokenReceiver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\ninterface ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address _operator,\\n        address _from,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external returns (bytes4);\\n\\n    function onERC1155BatchReceived(\\n        address _operator,\\n        address _from,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values,\\n        bytes calldata _data\\n    ) external returns (bytes4);\\n}\\n\"},\"Migrations.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.7.0;\\n\\n\\ncontract Migrations {\\n    address public owner;\\n    uint256 public last_completed_migration;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    modifier restricted() {\\n        if (msg.sender == owner) _;\\n    }\\n\\n    function setCompleted(uint256 completed) public restricted {\\n        last_completed_migration = completed;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n}\\n\"},\"SignatureVerifier.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\ncontract SignatureVerifier {\\n    function validateNodeSignature(\\n        string memory nodeHardwareLicenseId,\\n        uint256 sigNonce,\\n        bytes memory signature\\n    ) internal view returns (address signer) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        (v, r, s) = splitSignature(signature);\\n        bytes32 hash = keccak256(abi.encodePacked(nodeHardwareLicenseId, sigNonce, this));\\n        bytes32 hashWithHeader = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n        );\\n\\n        return ecrecover(hashWithHeader, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory signature)\\n        internal\\n        pure\\n        returns (\\n            uint8,\\n            bytes32,\\n            bytes32\\n        )\\n    {\\n        require(signature.length == 65);\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(signature, 32))\\n            // second 32 bytes\\n            s := mload(add(signature, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(signature, 96)))\\n        }\\n\\n        return (v, r, s);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"Creator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_supplyLimit\",\"type\":\"uint256\"}],\"name\":\"SupplyLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_currentValues\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"approveBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"batchAuthorizeCreators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"batchDeauthorizeCreators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_isNF\",\"type\":\"bool\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getNonFungibleBaseType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getNonFungibleIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isFungible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isNonFungible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isNonFungibleBaseType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isNonFungibleItem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_quantities\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"mintFungible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"mintNonFungible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"setNewUri\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_typeOrId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supplyLimit\",\"type\":\"uint256\"}],\"name\":\"setSupplyLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSupplyLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Gala","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e8a61d55a194b2f42d83bad5cb50743bb2cae21f6bc9f7b12d8f0056879d500e"}]}