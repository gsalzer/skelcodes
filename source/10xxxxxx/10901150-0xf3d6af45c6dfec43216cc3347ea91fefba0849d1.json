{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Dubi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Purpose.sol\\\";\\n\\ncontract Dubi is ERC20 {\\n    Purpose private immutable _prps;\\n\\n    constructor(\\n        uint256 initialSupply,\\n        address optIn,\\n        address purpose,\\n        address hodl,\\n        address externalAddress1,\\n        address externalAddress2,\\n        address externalAddress3\\n    )\\n        public\\n        ERC20(\\n            \\\"Decentralized Universal Basic Income\\\",\\n            \\\"DUBI\\\",\\n            optIn,\\n            hodl,\\n            externalAddress1,\\n            externalAddress2,\\n            externalAddress3\\n        )\\n    {\\n        _mintInitialSupply(msg.sender, initialSupply);\\n\\n        _prps = Purpose(purpose);\\n    }\\n\\n    function hodlMint(address to, uint256 amount) public {\\n        require(msg.sender == _hodlAddress, \\\"DUBI-2\\\");\\n        _mint(to, amount);\\n    }\\n\\n    function purposeMint(address to, uint256 amount) public {\\n        require(msg.sender == address(_prps), \\\"DUBI-3\\\");\\n        _mint(to, amount);\\n    }\\n\\n    function _callerIsDeployTimeKnownContract()\\n        internal\\n        override\\n        view\\n        returns (bool)\\n    {\\n        if (msg.sender == address(_prps)) {\\n            return true;\\n        }\\n\\n        return super._callerIsDeployTimeKnownContract();\\n    }\\n\\n    //---------------------------------------------------------------\\n    // Fuel\\n    //---------------------------------------------------------------\\n\\n    /**\\n     * @dev Burns `fuel` from `from`. Can only be called by one of the deploy-time known contracts.\\n     */\\n    function burnFuel(address from, TokenFuel memory fuel) public override {\\n        require(_callerIsDeployTimeKnownContract(), \\\"DUBI-1\\\");\\n        _burnFuel(from, fuel);\\n    }\\n\\n    function _burnFuel(address from, TokenFuel memory fuel) private {\\n        require(fuel.amount <= MAX_BOOSTER_FUEL, \\\"DUBI-5\\\");\\n        require(from != address(0) && from != msg.sender, \\\"DUBI-6\\\");\\n\\n        if (fuel.tokenAlias == TOKEN_FUEL_ALIAS_DUBI) {\\n            // Burn fuel from DUBI\\n            UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\\n            require(unpacked.balance >= fuel.amount, \\\"DUBI-7\\\");\\n            unpacked.balance -= fuel.amount;\\n            _packedData[from] = _packUnpackedData(unpacked);\\n            return;\\n        }\\n\\n        revert(\\\"DUBI-8\\\");\\n    }\\n\\n    /**\\n     *@dev Burn the fuel of a `boostedSend`\\n     */\\n    function _burnBoostedSendFuel(\\n        address from,\\n        BoosterFuel memory fuel,\\n        UnpackedData memory unpacked\\n    ) internal override returns (FuelBurn memory) {\\n        FuelBurn memory fuelBurn;\\n\\n        if (fuel.dubi > 0) {\\n            require(fuel.dubi <= MAX_BOOSTER_FUEL, \\\"DUBI-5\\\");\\n\\n            // From uses his own DUBI to fuel the boost\\n            require(unpacked.balance >= fuelBurn.amount, \\\"DUBI-7\\\");\\n            unpacked.balance -= fuel.dubi;\\n\\n            fuelBurn.amount = fuel.dubi;\\n            fuelBurn.fuelType = FuelType.DUBI;\\n\\n            return fuelBurn;\\n        }\\n\\n        // If the fuel is PRPS, then we have to reach out to the PRPS contract.\\n        if (fuel.unlockedPrps > 0) {\\n            // Reverts if the requested amount cannot be burned\\n            _prps.burnFuel(\\n                from,\\n                TokenFuel({\\n                    tokenAlias: TOKEN_FUEL_ALIAS_UNLOCKED_PRPS,\\n                    amount: fuel.unlockedPrps\\n                })\\n            );\\n\\n            fuelBurn.amount = fuel.unlockedPrps;\\n            fuelBurn.fuelType = FuelType.UNLOCKED_PRPS;\\n            return fuelBurn;\\n        }\\n\\n        if (fuel.lockedPrps > 0) {\\n            // Reverts if the requested amount cannot be burned\\n            _prps.burnFuel(\\n                from,\\n                TokenFuel({\\n                    tokenAlias: TOKEN_FUEL_ALIAS_LOCKED_PRPS,\\n                    amount: fuel.lockedPrps\\n                })\\n            );\\n\\n            fuelBurn.amount = fuel.lockedPrps;\\n            fuelBurn.fuelType = FuelType.LOCKED_PRPS;\\n            return fuelBurn;\\n        }\\n\\n        // No fuel at all\\n        return fuelBurn;\\n    }\\n\\n    /**\\n     *@dev Burn the fuel of a `boostedBurn`\\n     */\\n    function _burnBoostedBurnFuel(\\n        address from,\\n        BoosterFuel memory fuel,\\n        UnpackedData memory unpacked\\n    ) internal override returns (FuelBurn memory) {\\n        FuelBurn memory fuelBurn;\\n\\n        // If the fuel is DUBI, then we can remove it directly\\n        if (fuel.dubi > 0) {\\n            require(fuel.dubi <= MAX_BOOSTER_FUEL, \\\"DUBI-5\\\");\\n\\n            require(unpacked.balance >= fuel.dubi, \\\"DUBI-7\\\");\\n            unpacked.balance -= fuel.dubi;\\n\\n            fuelBurn.amount = fuel.dubi;\\n            fuelBurn.fuelType = FuelType.DUBI;\\n\\n            return fuelBurn;\\n        }\\n\\n        // If the fuel is PRPS, then we have to reach out to the PRPS contract.\\n        if (fuel.unlockedPrps > 0) {\\n            // Reverts if the requested amount cannot be burned\\n            _prps.burnFuel(\\n                from,\\n                TokenFuel({\\n                    tokenAlias: TOKEN_FUEL_ALIAS_UNLOCKED_PRPS,\\n                    amount: fuel.unlockedPrps\\n                })\\n            );\\n\\n            fuelBurn.amount = fuel.unlockedPrps;\\n            fuelBurn.fuelType = FuelType.UNLOCKED_PRPS;\\n\\n            return fuelBurn;\\n        }\\n\\n        if (fuel.lockedPrps > 0) {\\n            // Reverts if the requested amount cannot be burned\\n            _prps.burnFuel(\\n                from,\\n                TokenFuel({\\n                    tokenAlias: TOKEN_FUEL_ALIAS_LOCKED_PRPS,\\n                    amount: fuel.lockedPrps\\n                })\\n            );\\n\\n            // No direct fuel, but we still return a indirect fuel so that it can be added\\n            // to the burn event.\\n            fuelBurn.amount = fuel.lockedPrps;\\n            fuelBurn.fuelType = FuelType.LOCKED_PRPS;\\n            return fuelBurn;\\n        }\\n\\n        // DUBI has no intrinsic fuel\\n        if (fuel.intrinsicFuel > 0) {\\n            revert(\\\"DUBI-8\\\");\\n        }\\n\\n        // No fuel at all\\n        return fuelBurn;\\n    }\\n\\n    //---------------------------------------------------------------\\n    // Pending ops\\n    //---------------------------------------------------------------\\n    function _getHasherContracts()\\n        internal\\n        override\\n        returns (address[] memory)\\n    {\\n        address[] memory hashers = new address[](5);\\n        hashers[0] = address(this);\\n        hashers[1] = address(_prps);\\n        hashers[2] = _hodlAddress;\\n        hashers[3] = _externalAddress1;\\n        hashers[4] = _externalAddress2;\\n\\n        return hashers;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/IERC1820Registry.sol\\\";\\nimport \\\"./IBoostableERC20.sol\\\";\\nimport \\\"./BoostableERC20.sol\\\";\\n\\n/**\\n * @dev This is a heavily modified fork of @openzeppelin/contracts/token/ERC20/ERC20.sol (3.1.0)\\n */\\nabstract contract ERC20 is IERC20, IBoostableERC20, BoostableERC20, Ownable {\\n    using SafeMath for uint256;\\n\\n    // NOTE: In contrary to the Transfer event, the Burned event always\\n    // emits the amount including the burned fuel if any.\\n    // The amount is stored in the lower 96 bits of `amountAndFuel`,\\n    // followed by 3 bits to encode the type of fuel used and finally\\n    // another 96 bits for the fuel amount.\\n    //\\n    // 0         96        99                 195             256\\n    //   amount    fuelType      fuelAmount         padding\\n    //\\n    event Burned(uint256 amountAndFuel, bytes data);\\n\\n    enum FuelType {NONE, UNLOCKED_PRPS, LOCKED_PRPS, DUBI, AUTO_MINTED_DUBI}\\n\\n    struct FuelBurn {\\n        FuelType fuelType;\\n        uint96 amount;\\n    }\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    address internal immutable _hodlAddress;\\n\\n    address internal immutable _externalAddress1;\\n    address internal immutable _externalAddress2;\\n    address internal immutable _externalAddress3;\\n\\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(\\n        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\\n    );\\n\\n    // Mapping of address to packed data.\\n    // For efficiency reasons the token balance is a packed uint96 alongside\\n    // other data. The packed data has the following layout:\\n    //\\n    //   MSB                      uint256                      LSB\\n    //      uint64 nonce | uint96 hodlBalance | uint96 balance\\n    //\\n    // balance: the balance of a token holder that can be transferred freely\\n    // hodlBalance: the balance of a token holder that is hodled\\n    // nonce: a sequential number used for booster replay protection\\n    //\\n    // Only PRPS utilizes `hodlBalance`. For DUBI it is always 0.\\n    //\\n    mapping(address => uint256) internal _packedData;\\n\\n    struct UnpackedData {\\n        uint96 balance;\\n        uint96 hodlBalance;\\n        uint64 nonce;\\n    }\\n\\n    function _unpackPackedData(uint256 packedData)\\n        internal\\n        pure\\n        returns (UnpackedData memory)\\n    {\\n        UnpackedData memory unpacked;\\n\\n        // 1) Read balance from the first 96 bits\\n        unpacked.balance = uint96(packedData);\\n\\n        // 2) Read hodlBalance from the next 96 bits\\n        unpacked.hodlBalance = uint96(packedData >> 96);\\n\\n        // 3) Read nonce from the next 64 bits\\n        unpacked.nonce = uint64(packedData >> (96 + 96));\\n\\n        return unpacked;\\n    }\\n\\n    function _packUnpackedData(UnpackedData memory unpacked)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 packedData;\\n\\n        // 1) Write balance to the first 96 bits\\n        packedData |= unpacked.balance;\\n\\n        // 2) Write hodlBalance to the the next 96 bits\\n        packedData |= uint256(unpacked.hodlBalance) << 96;\\n\\n        // 3) Write nonce to the next 64 bits\\n        packedData |= uint256(unpacked.nonce) << (96 + 96);\\n\\n        return packedData;\\n    }\\n\\n    // ERC20-allowances\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    //---------------------------------------------------------------\\n    // Pending state for non-boosted operations while opted-in\\n    //---------------------------------------------------------------\\n    uint8 internal constant OP_TYPE_SEND = BOOST_TAG_SEND;\\n    uint8 internal constant OP_TYPE_BURN = BOOST_TAG_BURN;\\n\\n    struct PendingTransfer {\\n        // NOTE: For efficiency reasons balances are stored in a uint96 which is sufficient\\n        // since we only use 18 decimals.\\n        //\\n        // Two amounts are associated with a pending transfer, to allow deriving contracts\\n        // to store extra information.\\n        //\\n        // E.g. PRPS makes use of this by encoding the pending locked PRPS in the\\n        // `occupiedAmount` field.\\n        //\\n        address spender;\\n        uint96 transferAmount;\\n        address to;\\n        uint96 occupiedAmount;\\n        bytes data;\\n    }\\n\\n    // A mapping of hash(user, opId) to pending transfers. Pending burns are also considered regular transfers.\\n    mapping(bytes32 => PendingTransfer) private _pendingTransfers;\\n\\n    //---------------------------------------------------------------\\n\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        address optIn,\\n        address hodl,\\n        address externalAddress1,\\n        address externalAddress2,\\n        address externalAddress3\\n    ) public Ownable() BoostableERC20(optIn) {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        _hodlAddress = hodl;\\n        _externalAddress1 = externalAddress1;\\n        _externalAddress2 = externalAddress2;\\n        _externalAddress3 = externalAddress3;\\n\\n        // register interfaces\\n        _ERC1820_REGISTRY.setInterfaceImplementer(\\n            address(this),\\n            keccak256(\\\"BoostableERC20Token\\\"),\\n            address(this)\\n        );\\n        _ERC1820_REGISTRY.setInterfaceImplementer(\\n            address(this),\\n            keccak256(\\\"ERC20Token\\\"),\\n            address(this)\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals.\\n     */\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev Returns the current nonce of `account`\\n     */\\n    function getNonce(address account) external override view returns (uint64) {\\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[account]);\\n        return unpacked.nonce;\\n    }\\n\\n    /**\\n     * @dev Returns the total supply\\n     */\\n    function totalSupply()\\n        external\\n        override(IBoostableERC20, IERC20)\\n        view\\n        returns (uint256)\\n    {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\\n     */\\n    function balanceOf(address tokenHolder)\\n        public\\n        override(IBoostableERC20, IERC20)\\n        view\\n        returns (uint256)\\n    {\\n        // Return the balance of the holder that is not hodled (i.e. first 96 bits of the packeData)\\n        return uint96(_packedData[tokenHolder]);\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked data struct of `tokenHolder`\\n     */\\n    function unpackedDataOf(address tokenHolder)\\n        public\\n        view\\n        returns (UnpackedData memory)\\n    {\\n        return _unpackPackedData(_packedData[tokenHolder]);\\n    }\\n\\n    /**\\n     * @dev Mints `amount` new tokens for `to`.\\n     *\\n     * To make things more efficient, the total supply is optionally packed into the passed\\n     * amount where the first 96 bits are used for the actual amount and the following 96 bits\\n     * for the total supply.\\n     *\\n     */\\n    function mint(address to, uint256 amount) public onlyOwner {\\n        _mint(to, amount);\\n    }\\n\\n    function _mintInitialSupply(address to, uint256 amount) internal {\\n        // _mint does not update the totalSupply by default, unless the second 96 bits\\n        // passed are non-zero - in which case the non-zero value becomes the new total supply.\\n        // So in order to get the correct initial supply, we have to mirror the lower 96 bits\\n        // to the following 96 bits.\\n        amount = amount | (amount << 96);\\n        _mint(to, amount);\\n    }\\n\\n    function _mint(address to, uint256 amount) internal {\\n        require(to != address(0), \\\"ERC20-1\\\");\\n\\n        // The actual amount to mint (=lower 96 bits)\\n        uint96 amountToMint = uint96(amount);\\n\\n        // The new total supply, which may be 0 in which case no update is performed.\\n        uint96 updatedTotalSupply = uint96(amount >> 96);\\n\\n        // Update state variables\\n        if (updatedTotalSupply > 0) {\\n            _totalSupply = updatedTotalSupply;\\n        }\\n\\n        // Update packed data and check for uint96 overflow\\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[to]);\\n        uint96 updatedBalance = unpacked.balance + amountToMint;\\n\\n        // The overflow check also takes the hodlBalance into account\\n        require(\\n            updatedBalance + unpacked.hodlBalance >= unpacked.balance,\\n            \\\"ERC20-2\\\"\\n        );\\n\\n        unpacked.balance = updatedBalance;\\n        _packedData[to] = _packUnpackedData(unpacked);\\n\\n        emit Transfer(address(0), to, amountToMint);\\n    }\\n\\n    /**\\n     * @dev Transfer `amount` from msg.sender to `recipient`\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        override(IBoostableERC20, IERC20)\\n        returns (bool)\\n    {\\n        _assertSenderRecipient(msg.sender, recipient);\\n\\n        // Never create a pending transfer if msg.sender is a deploy-time known contract\\n        if (!_callerIsDeployTimeKnownContract()) {\\n            // Create pending transfer if sender is opted-in and the permaboost is active\\n            address from = msg.sender;\\n            IOptIn.OptInStatus memory optInStatus = getOptInStatus(from);\\n            if (optInStatus.isOptedIn && optInStatus.permaBoostActive) {\\n                _createPendingTransfer({\\n                    opType: OP_TYPE_SEND,\\n                    spender: msg.sender,\\n                    from: msg.sender,\\n                    to: recipient,\\n                    amount: amount,\\n                    data: \\\"\\\",\\n                    optInStatus: optInStatus\\n                });\\n\\n                return true;\\n            }\\n        }\\n\\n        _move({from: msg.sender, to: recipient, amount: amount});\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Burns `amount` of msg.sender.\\n     *\\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\\n     */\\n    function burn(uint256 amount, bytes memory data) public {\\n        // Create pending burn if sender is opted-in and the permaboost is active\\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(msg.sender);\\n        if (optInStatus.isOptedIn && optInStatus.permaBoostActive) {\\n            _createPendingTransfer({\\n                opType: OP_TYPE_BURN,\\n                spender: msg.sender,\\n                from: msg.sender,\\n                to: address(0),\\n                amount: amount,\\n                data: data,\\n                optInStatus: optInStatus\\n            });\\n\\n            return;\\n        }\\n\\n        _burn({\\n            from: msg.sender,\\n            amount: amount,\\n            data: data,\\n            incrementNonce: false\\n        });\\n    }\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`.\\n     *\\n     * Can only be used by deploy-time known contracts.\\n     *\\n     * IBoostableERC20 extension\\n     */\\n    function boostedTransferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public override returns (bool) {\\n        _assertSenderRecipient(sender, recipient);\\n\\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(sender);\\n\\n        // Only transfer if `sender` is a deploy-time known contract, otherwise\\n        // revert.\\n        require(\\n            _isDeployTimeKnownContractAndCanTransfer(\\n                sender,\\n                recipient,\\n                amount,\\n                optInStatus,\\n                data\\n            ),\\n            \\\"ERC20-17\\\"\\n        );\\n\\n        _move({from: sender, to: recipient, amount: amount});\\n        return true;\\n    }\\n\\n    function _isDeployTimeKnownContractAndCanTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        IOptIn.OptInStatus memory optInStatus,\\n        bytes memory data\\n    ) private view returns (bool) {\\n        // If the caller not a deploy-time known contract, the transfer is not allowed\\n        if (!_callerIsDeployTimeKnownContract()) {\\n            return false;\\n        }\\n\\n        if (msg.sender != _externalAddress3) {\\n            return true;\\n        }\\n\\n        // _externalAddress3 passes a flag via `data` that indicates whether it is a boosted transaction\\n        // or not.\\n        uint8 isBoostedBits;\\n        assembly {\\n            // Load flag using a 1-byte offset, because `mload` always reads\\n            // 32-bytes at once and the first 32 bytes of `data` contain it's length.\\n            isBoostedBits := mload(add(data, 0x01))\\n        }\\n\\n        // Reading into a 'bool' directly doesn't work for some reason\\n        if (isBoostedBits & 1 == 1) {\\n            return true;\\n        }\\n\\n        //  If the latter, then _externalAddress3 can only transfer the funds if either:\\n        // - the permaboost is not active\\n        // - `sender` is not opted-in to begin with\\n        //\\n        // If `sender` is opted-in and the permaboost is active, _externalAddress3 cannot\\n        // take funds, except when boosted. Here the booster trusts _externalAddress3, since it already\\n        // verifies that `sender` provided a valid signature.\\n        //\\n        // This is special to _externalAddress3, other deploy-time known contracts do not make use of `data`.\\n        if (optInStatus.permaBoostActive && optInStatus.isOptedIn) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Verify the booster payload against the nonce that is stored in the packed data of an account.\\n     * The increment happens outside of this function, when the balance is updated.\\n     */\\n    function _verifyNonce(BoosterPayload memory payload, uint64 currentNonce)\\n        internal\\n        pure\\n    {\\n        require(currentNonce == payload.nonce - 1, \\\"ERC20-5\\\");\\n    }\\n\\n    //---------------------------------------------------------------\\n    // Boosted functions\\n    //---------------------------------------------------------------\\n\\n    /**\\n     * @dev Perform multiple `boostedSend` calls in a single transaction.\\n     *\\n     * NOTE: Booster extension\\n     */\\n    function boostedSendBatch(\\n        BoostedSend[] memory sends,\\n        Signature[] memory signatures\\n    ) external {\\n        require(\\n            sends.length > 0 && sends.length == signatures.length,\\n            \\\"ERC20-6\\\"\\n        );\\n\\n        for (uint256 i = 0; i < sends.length; i++) {\\n            boostedSend(sends[i], signatures[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform multiple `boostedBurn` calls in a single transaction.\\n     *\\n     * NOTE: Booster extension\\n     */\\n    function boostedBurnBatch(\\n        BoostedBurn[] memory burns,\\n        Signature[] memory signatures\\n    ) external {\\n        require(\\n            burns.length > 0 && burns.length == signatures.length,\\n            \\\"ERC20-6\\\"\\n        );\\n\\n        for (uint256 i = 0; i < burns.length; i++) {\\n            boostedBurn(burns[i], signatures[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Send `amount` tokens from `sender` to recipient`.\\n     * The `sender` must be opted-in and the `msg.sender` must be a trusted booster.\\n     *\\n     * NOTE: Booster extension\\n     */\\n    function boostedSend(BoostedSend memory send, Signature memory signature)\\n        public\\n    {\\n        address from = send.sender;\\n        address to = send.recipient;\\n\\n        UnpackedData memory unpackedFrom = _unpackPackedData(_packedData[from]);\\n        UnpackedData memory unpackedTo = _unpackPackedData(_packedData[to]);\\n\\n        // We verify the nonce separately, since it's stored next to the balance\\n        _verifyNonce(send.boosterPayload, unpackedFrom.nonce);\\n\\n        _verifyBoostWithoutNonce(\\n            send.sender,\\n            hashBoostedSend(send, msg.sender),\\n            send.boosterPayload,\\n            signature\\n        );\\n\\n        FuelBurn memory fuelBurn = _burnBoostedSendFuel(\\n            from,\\n            send.fuel,\\n            unpackedFrom\\n        );\\n\\n        _moveUnpacked({\\n            from: send.sender,\\n            unpackedFrom: unpackedFrom,\\n            to: send.recipient,\\n            unpackedTo: unpackedTo,\\n            amount: send.amount,\\n            fuelBurn: fuelBurn,\\n            incrementNonce: true\\n        });\\n    }\\n\\n    /**\\n     * @dev Burn the fuel of a `boostedSend`. Returns a `FuelBurn` struct containing information about the burn.\\n     */\\n    function _burnBoostedSendFuel(\\n        address from,\\n        BoosterFuel memory fuel,\\n        UnpackedData memory unpacked\\n    ) internal virtual returns (FuelBurn memory);\\n\\n    /**\\n     * @dev Burn `amount` tokens from `account`.\\n     * The `account` must be opted-in and the `msg.sender` must be a trusted booster.\\n     *\\n     * NOTE: Booster extension\\n     */\\n    function boostedBurn(\\n        BoostedBurn memory message,\\n        // A signature, that is compared against the function payload and only accepted if signed by 'sender'\\n        Signature memory signature\\n    ) public {\\n        address from = message.account;\\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\\n\\n        // We verify the nonce separately, since it's stored next to the balance\\n        _verifyNonce(message.boosterPayload, unpacked.nonce);\\n\\n        _verifyBoostWithoutNonce(\\n            message.account,\\n            hashBoostedBurn(message, msg.sender),\\n            message.boosterPayload,\\n            signature\\n        );\\n\\n        FuelBurn memory fuelBurn = _burnBoostedBurnFuel(\\n            from,\\n            message.fuel,\\n            unpacked\\n        );\\n\\n        _burnUnpacked({\\n            from: message.account,\\n            unpacked: unpacked,\\n            amount: message.amount,\\n            data: message.data,\\n            incrementNonce: true,\\n            fuelBurn: fuelBurn\\n        });\\n    }\\n\\n    /**\\n     * @dev Burn the fuel of a `boostedSend`. Returns a `FuelBurn` struct containing information about the burn.\\n     */\\n    function _burnBoostedBurnFuel(\\n        address from,\\n        BoosterFuel memory fuel,\\n        UnpackedData memory unpacked\\n    ) internal virtual returns (FuelBurn memory);\\n\\n    function burnFuel(address from, TokenFuel memory fuel)\\n        external\\n        virtual\\n        override\\n    {}\\n\\n    //---------------------------------------------------------------\\n\\n    /**\\n     * @dev Get the allowance of `spender` for `holder`\\n     */\\n    function allowance(address holder, address spender)\\n        public\\n        override(IBoostableERC20, IERC20)\\n        view\\n        returns (uint256)\\n    {\\n        return _allowances[holder][spender];\\n    }\\n\\n    /**\\n     * @dev Increase the allowance of `spender` by `value` for msg.sender\\n     */\\n    function approve(address spender, uint256 value)\\n        public\\n        override(IBoostableERC20, IERC20)\\n        returns (bool)\\n    {\\n        address holder = msg.sender;\\n        _assertSenderRecipient(holder, spender);\\n        _approve(holder, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _assertSenderRecipient(msg.sender, spender);\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender].add(addedValue)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _assertSenderRecipient(msg.sender, spender);\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender].sub(subtractedValue, \\\"ERC20-18\\\")\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer `amount` from `holder` to `recipient`.\\n     *\\n     * `msg.sender` requires an allowance >= `amount` of `holder`.\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) public override(IBoostableERC20, IERC20) returns (bool) {\\n        _assertSenderRecipient(holder, recipient);\\n\\n        address spender = msg.sender;\\n\\n        // Create pending transfer if the token holder is opted-in and the permaboost is active\\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(holder);\\n        if (optInStatus.isOptedIn && optInStatus.permaBoostActive) {\\n            // Ignore allowances if holder is opted-in\\n            require(holder == spender, \\\"ERC20-7\\\");\\n\\n            _createPendingTransfer({\\n                opType: OP_TYPE_SEND,\\n                spender: spender,\\n                from: holder,\\n                to: recipient,\\n                amount: amount,\\n                data: \\\"\\\",\\n                optInStatus: optInStatus\\n            });\\n\\n            return true;\\n        }\\n\\n        // Not opted-in, but we still need to check approval of the given spender\\n\\n        _approve(\\n            holder,\\n            spender,\\n            _allowances[holder][spender].sub(amount, \\\"ERC20-4\\\")\\n        );\\n\\n        _move({from: holder, to: recipient, amount: amount});\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Burn tokens\\n     * @param from address token holder address\\n     * @param amount uint256 amount of tokens to burn\\n     * @param data bytes extra information provided by the token holder\\n     * @param incrementNonce whether to increment the nonce or not - only true for boosted burns\\n     */\\n    function _burn(\\n        address from,\\n        uint256 amount,\\n        bytes memory data,\\n        bool incrementNonce\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20-8\\\");\\n\\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\\n\\n        // Empty fuel burn\\n        FuelBurn memory fuelBurn;\\n\\n        _burnUnpacked({\\n            from: from,\\n            unpacked: unpacked,\\n            amount: amount,\\n            data: data,\\n            incrementNonce: incrementNonce,\\n            fuelBurn: fuelBurn\\n        });\\n    }\\n\\n    function _burnUnpacked(\\n        address from,\\n        UnpackedData memory unpacked,\\n        uint256 amount,\\n        bytes memory data,\\n        bool incrementNonce,\\n        FuelBurn memory fuelBurn\\n    ) internal {\\n        // _beforeBurn allows deriving contracts to run additional logic and affect the amount\\n        // that is actually getting burned. E.g. when burning PRPS, a portion of it might be taken\\n        // from the `hodlBalance`. Thus the returned `burnAmount` overrides `amount` and will be\\n        // subtracted from the actual `balance`.\\n\\n        uint96 actualBurnAmount = _beforeBurn({\\n            from: from,\\n            unpacked: unpacked,\\n            transferAmount: uint96(amount),\\n            occupiedAmount: 0,\\n            createdAt: uint32(block.timestamp),\\n            fuelBurn: fuelBurn,\\n            finalizing: false\\n        });\\n\\n        // Update to new balance\\n\\n        if (incrementNonce) {\\n            // The nonce uses 64 bits, so a overflow is pretty much impossible\\n            // via increments of 1.\\n            unpacked.nonce++;\\n        }\\n\\n        if (actualBurnAmount > 0) {\\n            require(unpacked.balance >= actualBurnAmount, \\\"ERC20-9\\\");\\n            unpacked.balance -= actualBurnAmount;\\n        }\\n\\n        // Update packed data by writing to storage\\n        _packedData[from] = _packUnpackedData(unpacked);\\n\\n        // Total supply can be updated in batches elsewhere, shaving off another >5k gas.\\n        // _totalSupply = _totalSupply.sub(amount);\\n\\n        // The `Burned` event is emitted with the total amount that got burned.\\n        // Furthermore, the fuel used is encoded in the upper bits.\\n        uint256 amountAndFuel;\\n\\n        // Set first 96 bits to amount\\n        amountAndFuel |= uint96(amount);\\n\\n        // Set next 3 bits to fuel type\\n        uint8 fuelType = uint8(fuelBurn.fuelType);\\n        amountAndFuel |= uint256(fuelType) << 96;\\n\\n        // Set next 96 bits to fuel amount\\n        amountAndFuel |= uint256(fuelBurn.amount) << (96 + 3);\\n\\n        emit Burned(amountAndFuel, data);\\n\\n        // We emit a transfer event with the actual burn amount excluding burned `hodlBalance`.\\n        emit Transfer(from, address(0), actualBurnAmount);\\n    }\\n\\n    /**\\n     * @dev Allow deriving contracts to prepare a burn. By default it behaves like an identity function\\n     * and just returns the amount passed in.\\n     */\\n    function _beforeBurn(\\n        address from,\\n        UnpackedData memory unpacked,\\n        uint96 transferAmount,\\n        uint96 occupiedAmount,\\n        uint32 createdAt,\\n        FuelBurn memory fuelBurn,\\n        bool finalizing\\n    ) internal virtual returns (uint96) {\\n        return transferAmount;\\n    }\\n\\n    function _move(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        UnpackedData memory unpackedFrom = _unpackPackedData(_packedData[from]);\\n        UnpackedData memory unpackedTo = _unpackPackedData(_packedData[to]);\\n\\n        // Empty fuel burn\\n        FuelBurn memory fuelBurn;\\n\\n        _moveUnpacked({\\n            from: from,\\n            unpackedFrom: unpackedFrom,\\n            to: to,\\n            unpackedTo: unpackedTo,\\n            amount: amount,\\n            incrementNonce: false,\\n            fuelBurn: fuelBurn\\n        });\\n    }\\n\\n    function _moveUnpacked(\\n        address from,\\n        UnpackedData memory unpackedFrom,\\n        address to,\\n        UnpackedData memory unpackedTo,\\n        uint256 amount,\\n        bool incrementNonce,\\n        FuelBurn memory fuelBurn\\n    ) internal {\\n        require(from != to, \\\"ERC20-19\\\");\\n\\n        // Increment nonce of sender if it's a boosted send\\n        if (incrementNonce) {\\n            // The nonce uses 64 bits, so a overflow is pretty much impossible\\n            // via increments of 1.\\n            unpackedFrom.nonce++;\\n        }\\n\\n        // Check if sender has enough tokens\\n        uint96 transferAmount = uint96(amount);\\n        require(unpackedFrom.balance >= transferAmount, \\\"ERC20-10\\\");\\n\\n        // Subtract transfer amount from sender balance\\n        unpackedFrom.balance -= transferAmount;\\n\\n        // Check that recipient balance doesn't overflow\\n        uint96 updatedRecipientBalance = unpackedTo.balance + transferAmount;\\n        require(updatedRecipientBalance >= unpackedTo.balance, \\\"ERC20-12\\\");\\n        unpackedTo.balance = updatedRecipientBalance;\\n\\n        _packedData[from] = _packUnpackedData(unpackedFrom);\\n        _packedData[to] = _packUnpackedData(unpackedTo);\\n\\n        // The transfer amount does not include any used fuel\\n        emit Transfer(from, to, transferAmount);\\n    }\\n\\n    /**\\n     * @dev See {ERC20-_approve}.\\n     */\\n    function _approve(\\n        address holder,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        _allowances[holder][spender] = value;\\n        emit Approval(holder, spender, value);\\n    }\\n\\n    function _assertSenderRecipient(address sender, address recipient)\\n        private\\n        pure\\n    {\\n        require(sender != address(0) && recipient != address(0), \\\"ERC20-13\\\");\\n    }\\n\\n    /**\\n     * @dev Checks whether msg.sender is a deploy-time known contract or not.\\n     */\\n    function _callerIsDeployTimeKnownContract()\\n        internal\\n        virtual\\n        view\\n        returns (bool)\\n    {\\n        if (msg.sender == _hodlAddress) {\\n            return true;\\n        }\\n\\n        if (msg.sender == _externalAddress1) {\\n            return true;\\n        }\\n\\n        if (msg.sender == _externalAddress2) {\\n            return true;\\n        }\\n\\n        if (msg.sender == _externalAddress3) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    //---------------------------------------------------------------\\n    // Pending ops\\n    //---------------------------------------------------------------\\n\\n    /**\\n     * @dev Create a pending transfer\\n     */\\n    function _createPendingTransfer(\\n        uint8 opType,\\n        address spender,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory data,\\n        IOptIn.OptInStatus memory optInStatus\\n    ) private {\\n        OpHandle memory opHandle = _createNewOpHandle(\\n            optInStatus,\\n            from,\\n            opType\\n        );\\n\\n        PendingTransfer memory pendingTransfer = _createPendingTransferInternal(\\n            opHandle,\\n            spender,\\n            from,\\n            to,\\n            amount,\\n            data\\n        );\\n\\n        _pendingTransfers[_getOpKey(from, opHandle.opId)] = pendingTransfer;\\n\\n        // Emit PendingOp event\\n        emit PendingOp(from, opHandle.opId, opHandle.opType);\\n    }\\n\\n    /**\\n     * @dev Create a pending transfer by moving the funds of `spender` to this contract.\\n     * Deriving contracts may override this function.\\n     */\\n    function _createPendingTransferInternal(\\n        OpHandle memory opHandle,\\n        address spender,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual returns (PendingTransfer memory) {\\n        // Move funds into this contract\\n\\n        // Reverts if `from` has less than `amount` tokens.\\n        _move({from: from, to: address(this), amount: amount});\\n\\n        // Create op\\n        PendingTransfer memory pendingTransfer = PendingTransfer({\\n            transferAmount: uint96(amount),\\n            spender: spender,\\n            occupiedAmount: 0,\\n            to: to,\\n            data: data\\n        });\\n\\n        return pendingTransfer;\\n    }\\n\\n    /**\\n     * @dev Finalize a pending op\\n     */\\n    function finalizePendingOp(address user, OpHandle memory opHandle) public {\\n        uint8 opType = opHandle.opType;\\n\\n        // Assert that the caller (msg.sender) is allowed to finalize the given op\\n        uint32 createdAt = uint32(_assertCanFinalize(user, opHandle));\\n\\n        // Reverts if opId doesn't exist\\n        PendingTransfer storage pendingTransfer = _safeGetPendingTransfer(\\n            user,\\n            opHandle.opId\\n        );\\n\\n        // Cleanup\\n        // NOTE: We do not delete the pending transfer struct, because it only makes it\\n        // more expensive since we already hit the gas refund limit.\\n        //\\n        // delete _pendingTransfers[_getOpKey(user, opHandle.opId)];\\n        //\\n        // The difference is ~13k gas.\\n        //\\n        // Deleting the op handle is enough to invalidate an opId forever:\\n        _deleteOpHandle(user, opHandle);\\n\\n        // Call op type specific finalize\\n        if (opType == OP_TYPE_SEND) {\\n            _finalizeTransferOp(pendingTransfer, user, createdAt);\\n        } else if (opType == OP_TYPE_BURN) {\\n            _finalizePendingBurn(pendingTransfer, user, createdAt);\\n        } else {\\n            revert(\\\"ERC20-15\\\");\\n        }\\n\\n        // Emit event\\n        emit FinalizedOp(user, opHandle.opId, opType);\\n    }\\n\\n    /**\\n     * @dev Finalize a pending transfer\\n     */\\n    function _finalizeTransferOp(\\n        PendingTransfer storage pendingTransfer,\\n        address from,\\n        uint32 createdAt\\n    ) private {\\n        address to = pendingTransfer.to;\\n\\n        uint96 transferAmount = pendingTransfer.transferAmount;\\n\\n        address _this = address(this);\\n        UnpackedData memory unpackedThis = _unpackPackedData(\\n            _packedData[_this]\\n        );\\n        UnpackedData memory unpackedTo = _unpackPackedData(_packedData[to]);\\n\\n        // Check that sender balance does not overflow\\n        require(unpackedThis.balance >= transferAmount, \\\"ERC20-2\\\");\\n        unpackedThis.balance -= transferAmount;\\n\\n        // Check that recipient doesn't overflow\\n        uint96 updatedBalanceRecipient = unpackedTo.balance + transferAmount;\\n        require(updatedBalanceRecipient >= unpackedTo.balance, \\\"ERC20-2\\\");\\n\\n        unpackedTo.balance = updatedBalanceRecipient;\\n\\n        _packedData[_this] = _packUnpackedData(unpackedThis);\\n        _packedData[to] = _packUnpackedData(unpackedTo);\\n\\n        // Transfer event is emitted with original sender\\n        emit Transfer(from, to, transferAmount);\\n    }\\n\\n    /**\\n     * @dev Finalize a pending burn\\n     */\\n    function _finalizePendingBurn(\\n        PendingTransfer storage pendingTransfer,\\n        address from,\\n        uint32 createdAt\\n    ) private {\\n        uint96 transferAmount = pendingTransfer.transferAmount;\\n\\n        // We pass the packedData of `from` to `_beforeBurn`, because it PRPS needs to update\\n        // the `hodlBalance` which is NOT on the contract's own packedData.\\n        UnpackedData memory unpackedFrom = _unpackPackedData(_packedData[from]);\\n\\n        // Empty fuel burn\\n        FuelBurn memory fuelBurn;\\n\\n        uint96 burnAmountExcludingLockedPrps = _beforeBurn({\\n            from: from,\\n            unpacked: unpackedFrom,\\n            transferAmount: transferAmount,\\n            occupiedAmount: pendingTransfer.occupiedAmount,\\n            createdAt: createdAt,\\n            fuelBurn: fuelBurn,\\n            finalizing: true\\n        });\\n\\n        // Update to new balance\\n        // NOTE: We change the balance of this contract, because that's where\\n        // the pending PRPS went to.\\n        address _this = address(this);\\n        UnpackedData memory unpackedOfContract = _unpackPackedData(\\n            _packedData[_this]\\n        );\\n        require(\\n            unpackedOfContract.balance >= burnAmountExcludingLockedPrps,\\n            \\\"ERC20-2\\\"\\n        );\\n\\n        unpackedOfContract.balance -= burnAmountExcludingLockedPrps;\\n        _packedData[_this] = _packUnpackedData(unpackedOfContract);\\n        _packedData[from] = _packUnpackedData(unpackedFrom);\\n\\n        // Furthermore, total supply can be updated elsewhere, shaving off another >5k gas.\\n        // _totalSupply = _totalSupply.sub(amount);\\n\\n        // Emit events using the same `transferAmount` instead of what `_beforeBurn`\\n        // returned which is only used for updating the balance correctly.\\n        emit Burned(transferAmount, pendingTransfer.data);\\n        emit Transfer(from, address(0), transferAmount);\\n    }\\n\\n    /**\\n     * @dev Revert a pending operation.\\n     *\\n     * Only the opted-in booster can revert a transaction if it provides a signed and still valid booster message\\n     * from the original sender.\\n     */\\n    function revertPendingOp(\\n        address user,\\n        OpHandle memory opHandle,\\n        bytes memory boosterMessage,\\n        Signature memory signature\\n    ) public {\\n        // Prepare revert, including permission check and prevents reentrancy for same opHandle.\\n        _prepareOpRevert({\\n            user: user,\\n            opHandle: opHandle,\\n            boosterMessage: boosterMessage,\\n            signature: signature\\n        });\\n\\n        // Now perform the actual revert of the pending op\\n        _revertPendingOp(user, opHandle.opType, opHandle.opId);\\n    }\\n\\n    /**\\n     * @dev Revert a pending transfer\\n     */\\n    function _revertPendingOp(\\n        address user,\\n        uint8 opType,\\n        uint64 opId\\n    ) private {\\n        PendingTransfer storage pendingTransfer = _safeGetPendingTransfer(\\n            user,\\n            opId\\n        );\\n\\n        uint96 transferAmount = pendingTransfer.transferAmount;\\n        uint96 occupiedAmount = pendingTransfer.occupiedAmount;\\n\\n        // Move funds from this contract back to the original sender. Transfers and burns\\n        // are reverted the same way. We only transfer back the `transferAmount` - that is the amount\\n        // that actually got moved into this contract. The occupied amount is released during `onRevertPendingOp`\\n        // by the deriving contract.\\n        _move({from: address(this), to: user, amount: transferAmount});\\n\\n        // Call hook to allow deriving contracts to perform additional cleanup\\n        _onRevertPendingOp(user, opType, opId, transferAmount, occupiedAmount);\\n\\n        // NOTE: we do not clean up the ops mapping, because we already hit the\\n        // gas refund limit.\\n        // delete _pendingTransfers[_getOpKey(user, opHandle.opId)];\\n\\n        // Emit event\\n        emit RevertedOp(user, opId, opType);\\n    }\\n\\n    /**\\n     * @dev Hook that is called during revert of a pending transfer.\\n     * Allows deriving contracts to perform additional cleanup.\\n     */\\n    function _onRevertPendingOp(\\n        address user,\\n        uint8 opType,\\n        uint64 opId,\\n        uint96 transferAmount,\\n        uint96 occupiedAmount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Safely get a pending transfer. Reverts if it doesn't exist.\\n     */\\n    function _safeGetPendingTransfer(address user, uint64 opId)\\n        private\\n        view\\n        returns (PendingTransfer storage)\\n    {\\n        PendingTransfer storage pendingTransfer = _pendingTransfers[_getOpKey(\\n            user,\\n            opId\\n        )];\\n\\n        require(pendingTransfer.spender != address(0), \\\"ERC20-16\\\");\\n\\n        return pendingTransfer;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Purpose.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Dubi.sol\\\";\\nimport \\\"./IHodl.sol\\\";\\nimport \\\"./MintMath.sol\\\";\\n\\ncontract Purpose is ERC20 {\\n    // The DUBI contract, required for auto-minting DUBI on burn.\\n    Dubi private immutable _dubi;\\n\\n    // The HODL contract, required for burning locked PRPS.\\n    IHodl private immutable _hodl;\\n\\n    modifier onlyHodl() {\\n        require(msg.sender == _hodlAddress, \\\"PRPS-1\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        uint256 initialSupply,\\n        address optIn,\\n        address dubi,\\n        address hodl,\\n        address externalAddress1,\\n        address externalAddress2,\\n        address externalAddress3\\n    )\\n        public\\n        ERC20(\\n            \\\"Purpose\\\",\\n            \\\"PRPS\\\",\\n            optIn,\\n            hodl,\\n            externalAddress1,\\n            externalAddress2,\\n            externalAddress3\\n        )\\n    {\\n        _dubi = Dubi(dubi);\\n        _hodl = IHodl(hodl);\\n\\n        _mintInitialSupply(msg.sender, initialSupply);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the {HODL} contract used for burning locked PRPS.\\n     */\\n    function hodl() external view returns (address) {\\n        return address(_hodl);\\n    }\\n\\n    /**\\n     * @dev Returns the hodl balance of the given `tokenHolder`\\n     */\\n    function hodlBalanceOf(address tokenHolder) public view returns (uint256) {\\n        // The hodl balance follows after the first 96 bits in the packed data.\\n        return uint96(_packedData[tokenHolder] >> 96);\\n    }\\n\\n    /**\\n     * @dev Transfer `amount` PRPS from `from` to the Hodl contract.\\n     *\\n     * This can only be called by the Hodl contract.\\n     */\\n    function hodlTransfer(address from, uint96 amount) external onlyHodl {\\n        _move(from, address(_hodl), amount);\\n    }\\n\\n    /**\\n     * @dev Increase the hodl balance of `account` by `hodlAmount`. This is\\n     * only used as part of the migration.\\n     */\\n    function migrateHodlBalance(address account, uint96 hodlAmount)\\n        external\\n        onlyHodl\\n    {\\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[account]);\\n\\n        unpacked.hodlBalance += hodlAmount;\\n        _packedData[account] = _packUnpackedData(unpacked);\\n    }\\n\\n    /**\\n     * @dev Increase the hodl balance of `to` by moving `amount` PRPS from `from`'s balance.\\n     *\\n     * This can only be called by the Hodl contract.\\n     */\\n    function increaseHodlBalance(\\n        address from,\\n        address to,\\n        uint96 amount\\n    ) external onlyHodl {\\n        UnpackedData memory unpackedDataFrom = _unpackPackedData(\\n            _packedData[from]\\n        );\\n        UnpackedData memory unpackedDataTo;\\n\\n        // We only need to unpack twice if from != to\\n        if (from != to) {\\n            unpackedDataTo = _unpackPackedData(_packedData[to]);\\n        } else {\\n            unpackedDataTo = unpackedDataFrom;\\n        }\\n\\n        // `from` must have enough balance\\n        require(unpackedDataFrom.balance >= amount, \\\"PRPS-3\\\");\\n\\n        // Subtract balance from `from`\\n        unpackedDataFrom.balance -= amount;\\n        // Add to `hodlBalance` from `to`\\n        unpackedDataTo.hodlBalance += amount;\\n\\n        // We only need to pack twice if from != to\\n        if (from != to) {\\n            _packedData[to] = _packUnpackedData(unpackedDataTo);\\n        }\\n\\n        _packedData[from] = _packUnpackedData(unpackedDataFrom);\\n    }\\n\\n    /**\\n     * @dev Decrease the hodl balance of `from` by `hodlAmount` and increase\\n     * the regular balance by `refundAmount.\\n     *\\n     * `refundAmount` might be less than `hodlAmount`.\\n     *\\n     * E.g. when burning fuel in locked PRPS\\n     *\\n     * This can only be called by the Hodl contract.\\n     */\\n    function decreaseHodlBalance(\\n        address from,\\n        uint96 hodlAmount,\\n        uint96 refundAmount\\n    ) external onlyHodl {\\n        require(hodlAmount >= refundAmount, \\\"PRPS-4\\\");\\n\\n        UnpackedData memory unpackedDataFrom = _unpackPackedData(\\n            _packedData[from]\\n        );\\n\\n        // `from` must have enough balance\\n        require(unpackedDataFrom.hodlBalance >= hodlAmount, \\\"PRPS-5\\\");\\n\\n        // Subtract amount from hodl balance\\n        unpackedDataFrom.hodlBalance -= hodlAmount;\\n\\n        if (refundAmount > 0) {\\n            // Add amount to balance\\n            unpackedDataFrom.balance += refundAmount;\\n        }\\n\\n        // Write to storage\\n        _packedData[from] = _packUnpackedData(unpackedDataFrom);\\n    }\\n\\n    /**\\n     * @dev Revert the hodl balance change caused by `from` on `to`.\\n     *\\n     * E.g. when reverting a pending hodl.\\n     *\\n     * This can only be called by the Hodl contract.\\n     */\\n    function revertHodlBalance(\\n        address from,\\n        address to,\\n        uint96 amount\\n    ) external onlyHodl {\\n        UnpackedData memory unpackedDataFrom = _unpackPackedData(\\n            _packedData[from]\\n        );\\n        UnpackedData memory unpackedDataTo;\\n\\n        // We only need to unpack twice if from != to\\n        if (from != to) {\\n            unpackedDataTo = _unpackPackedData(_packedData[to]);\\n        } else {\\n            unpackedDataTo = unpackedDataFrom;\\n        }\\n\\n        // `to` must have enough hodl balance\\n        require(unpackedDataTo.hodlBalance >= amount, \\\"PRPS-5\\\");\\n\\n        // Subtract hodl balance from `to`\\n        unpackedDataTo.hodlBalance -= amount;\\n        // Add to `balance` from `from`\\n        unpackedDataFrom.balance += amount;\\n\\n        // We only need to pack twice if from != to\\n        if (from != to) {\\n            _packedData[to] = _packUnpackedData(unpackedDataTo);\\n        }\\n\\n        _packedData[from] = _packUnpackedData(unpackedDataFrom);\\n    }\\n\\n    /**\\n     * @dev Mint DUBI when burning PRPS\\n     * @param from address token holder address\\n     * @param transferAmount amount of tokens to burn\\n     * @param occupiedAmount amount of tokens that are occupied\\n     * @param createdAt equal to block.timestamp if not finalizing a pending op, otherwise\\n     * it corresponds to op.createdAt\\n     * @param finalizing boolean indicating whether this is a finalizing transaction or not. Changes\\n     * how the `amount` is interpreted.\\n     *\\n     * When burning PRPS, we first try to burn unlocked PRPS.\\n     * If burning an amount that exceeds the unlocked PRPS of `from`, we attempt to burn the\\n     * difference from locked PRPS.\\n     *\\n     * If the desired `amount` cannot be filled by taking locked and unlocked PRPS into account,\\n     * this function reverts.\\n     *\\n     * Burning locked PRPS means reducing the `hodlBalance` while burning unlocked PRPS means reducing\\n     * the regular `balance`.\\n     *\\n     * This function returns the actual unlocked PRPS that needs to be removed from `balance`.\\n     *\\n     */\\n    function _beforeBurn(\\n        address from,\\n        UnpackedData memory unpacked,\\n        uint96 transferAmount,\\n        uint96 occupiedAmount,\\n        uint32 createdAt,\\n        FuelBurn memory fuelBurn,\\n        bool finalizing\\n    ) internal override returns (uint96) {\\n        uint96 totalDubiToMint;\\n        uint96 lockedPrpsToBurn;\\n        uint96 burnableUnlockedPrps;\\n\\n        // Depending on whether this is a finalizing burn or not,\\n        // the amount of locked/unlocked PRPS is determined differently.\\n        if (finalizing) {\\n            // For a finalizing burn, we use the occupied amount, since we already know how much\\n            // locked PRPS we are going to burn. This amount represents the `pendingLockedPrps`\\n            // on the hodl items.\\n            lockedPrpsToBurn = occupiedAmount;\\n\\n            // Since `transferAmount` is the total amount of PRPS getting burned, we need to subtract\\n            // the `occupiedAmount` to get the actual amount of unlocked PRPS.\\n\\n            // Sanity check\\n            assert(transferAmount >= occupiedAmount);\\n            transferAmount -= occupiedAmount;\\n\\n            // Set the unlocked PRPS to burn to the updated `transferAmount`\\n            burnableUnlockedPrps = transferAmount;\\n        } else {\\n            // For a direct burn, we start off with the full amounts, since we don't know the exact\\n            // amounts initially.\\n\\n            lockedPrpsToBurn = transferAmount;\\n            burnableUnlockedPrps = unpacked.balance;\\n        }\\n\\n        // 1) Try to burn unlocked PRPS\\n        if (burnableUnlockedPrps > 0) {\\n            // Nice, we can burn unlocked PRPS\\n\\n            // Catch underflow i.e. don't burn more than we need to\\n            if (burnableUnlockedPrps > transferAmount) {\\n                burnableUnlockedPrps = transferAmount;\\n            }\\n\\n            // Calculate DUBI to mint based on unlocked PRPS we can burn\\n            totalDubiToMint = MintMath.calculateDubiToMintMax(\\n                burnableUnlockedPrps\\n            );\\n\\n            // Subtract the amount of burned unlocked PRPS from the locked PRPS we\\n            // need to burn if this is NOT a finalizing burn, because in that case we\\n            // already have the exact amount locked PRPS we want to burn.\\n            if (!finalizing) {\\n                lockedPrpsToBurn -= burnableUnlockedPrps;\\n            }\\n        }\\n\\n        // 2) Burn locked PRPS if there's not enough unlocked PRPS\\n\\n        // Burn an additional amount of locked PRPS equal to the fuel if any\\n        if (fuelBurn.fuelType == FuelType.LOCKED_PRPS) {\\n            // The `burnFromLockedPrps` call will fail, if not enough PRPS can be burned.\\n            lockedPrpsToBurn += fuelBurn.amount;\\n        }\\n\\n        if (lockedPrpsToBurn > 0) {\\n            uint96 dubiToMintFromLockedPrps = _burnFromLockedPrps({\\n                from: from,\\n                unpacked: unpacked,\\n                lockedPrpsToBurn: lockedPrpsToBurn,\\n                createdAt: createdAt,\\n                finalizing: finalizing\\n            });\\n\\n            // We check 'greater than or equal' because it's possible to mint 0 new DUBI\\n            // e.g. when called right after a hodl where not enough time passed to generate new DUBI.\\n            uint96 dubiToMint = totalDubiToMint + dubiToMintFromLockedPrps;\\n            require(dubiToMint >= totalDubiToMint, \\\"PRPS-6\\\");\\n\\n            totalDubiToMint = dubiToMint;\\n        } else {\\n            // Sanity check for finalizes that don't touch locked PRPS\\n            assert(occupiedAmount == 0);\\n        }\\n\\n        // Burn minted DUBI equal to the fuel if any\\n        if (fuelBurn.fuelType == FuelType.AUTO_MINTED_DUBI) {\\n            require(totalDubiToMint >= fuelBurn.amount, \\\"PRPS-7\\\");\\n            totalDubiToMint -= fuelBurn.amount;\\n        }\\n\\n        // Mint DUBI taking differences between burned locked/unlocked into account\\n        if (totalDubiToMint > 0) {\\n            _dubi.purposeMint(from, totalDubiToMint);\\n        }\\n\\n        return burnableUnlockedPrps;\\n    }\\n\\n    function _burnFromLockedPrps(\\n        address from,\\n        UnpackedData memory unpacked,\\n        uint96 lockedPrpsToBurn,\\n        uint32 createdAt,\\n        bool finalizing\\n    ) private returns (uint96) {\\n        // Reverts if the exact amount needed cannot be burned\\n        uint96 dubiToMintFromLockedPrps = _hodl.burnLockedPrps({\\n            from: from,\\n            amount: lockedPrpsToBurn,\\n            dubiMintTimestamp: createdAt,\\n            burnPendingLockedPrps: finalizing\\n        });\\n\\n        require(unpacked.hodlBalance >= lockedPrpsToBurn, \\\"PRPS-8\\\");\\n\\n        unpacked.hodlBalance -= lockedPrpsToBurn;\\n\\n        return dubiToMintFromLockedPrps;\\n    }\\n\\n    function _callerIsDeployTimeKnownContract()\\n        internal\\n        override\\n        view\\n        returns (bool)\\n    {\\n        if (msg.sender == address(_dubi)) {\\n            return true;\\n        }\\n\\n        return super._callerIsDeployTimeKnownContract();\\n    }\\n\\n    //---------------------------------------------------------------\\n    // Fuel\\n    //---------------------------------------------------------------\\n\\n    /**\\n     * @dev Burns `fuel` from `from`. Can only be called by one of the deploy-time known contracts.\\n     */\\n    function burnFuel(address from, TokenFuel memory fuel) public override {\\n        require(_callerIsDeployTimeKnownContract(), \\\"PRPS-2\\\");\\n        _burnFuel(from, fuel);\\n    }\\n\\n    function _burnFuel(address from, TokenFuel memory fuel) private {\\n        require(fuel.amount <= MAX_BOOSTER_FUEL, \\\"PRPS-10\\\");\\n        require(from != address(0) && from != msg.sender, \\\"PRPS-11\\\");\\n\\n        if (fuel.tokenAlias == TOKEN_FUEL_ALIAS_UNLOCKED_PRPS) {\\n            // Burn fuel from unlocked PRPS\\n            UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\\n            require(unpacked.balance >= fuel.amount, \\\"PRPS-7\\\");\\n            unpacked.balance -= fuel.amount;\\n            _packedData[from] = _packUnpackedData(unpacked);\\n            return;\\n        }\\n\\n        if (fuel.tokenAlias == TOKEN_FUEL_ALIAS_LOCKED_PRPS) {\\n            // Burn fuel from locked PRPS\\n            UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\\n            require(unpacked.hodlBalance >= fuel.amount, \\\"PRPS-7\\\");\\n            unpacked.hodlBalance -= fuel.amount;\\n\\n            // We pass a mint timestamp, but that doesn't mean that DUBI is minted.\\n            // The returned DUBI that should be minted is ignored.\\n            // Reverts if not enough locked PRPS can be burned.\\n            _hodl.burnLockedPrps({\\n                from: from,\\n                amount: fuel.amount,\\n                dubiMintTimestamp: uint32(block.timestamp),\\n                burnPendingLockedPrps: false\\n            });\\n\\n            _packedData[from] = _packUnpackedData(unpacked);\\n            return;\\n        }\\n\\n        revert(\\\"PRPS-12\\\");\\n    }\\n\\n    /**\\n     *@dev Burn the fuel of a `boostedSend`\\n     */\\n    function _burnBoostedSendFuel(\\n        address from,\\n        BoosterFuel memory fuel,\\n        UnpackedData memory unpacked\\n    ) internal override returns (FuelBurn memory) {\\n        FuelBurn memory fuelBurn;\\n\\n        if (fuel.unlockedPrps > 0) {\\n            require(fuel.unlockedPrps <= MAX_BOOSTER_FUEL, \\\"PRPS-10\\\");\\n\\n            require(unpacked.balance >= fuel.unlockedPrps, \\\"PRPS-7\\\");\\n            unpacked.balance -= fuel.unlockedPrps;\\n\\n            fuelBurn.amount = fuel.unlockedPrps;\\n            fuelBurn.fuelType = FuelType.UNLOCKED_PRPS;\\n            return fuelBurn;\\n        }\\n\\n        if (fuel.lockedPrps > 0) {\\n            require(fuel.lockedPrps <= MAX_BOOSTER_FUEL, \\\"PRPS-10\\\");\\n\\n            // We pass a mint timestamp, but that doesn't mean that DUBI is minted.\\n            // The returned DUBI that should be minted is ignored.\\n            // Reverts if not enough locked PRPS can be burned.\\n            _hodl.burnLockedPrps({\\n                from: from,\\n                amount: fuel.lockedPrps,\\n                dubiMintTimestamp: uint32(block.timestamp),\\n                burnPendingLockedPrps: false\\n            });\\n\\n            require(unpacked.hodlBalance >= fuel.lockedPrps, \\\"PRPS-7\\\");\\n            unpacked.hodlBalance -= fuel.lockedPrps;\\n\\n            fuelBurn.amount = fuel.lockedPrps;\\n            fuelBurn.fuelType = FuelType.LOCKED_PRPS;\\n            return fuelBurn;\\n        }\\n\\n        // If the fuel is DUBI, then we have to reach out to the DUBI contract.\\n        if (fuel.dubi > 0) {\\n            // Reverts if the requested amount cannot be burned\\n            _dubi.burnFuel(\\n                from,\\n                TokenFuel({\\n                    tokenAlias: TOKEN_FUEL_ALIAS_DUBI,\\n                    amount: fuel.dubi\\n                })\\n            );\\n\\n            fuelBurn.amount = fuel.dubi;\\n            fuelBurn.fuelType = FuelType.DUBI;\\n            return fuelBurn;\\n        }\\n\\n        return fuelBurn;\\n    }\\n\\n    /**\\n     *@dev Burn the fuel of a `boostedBurn`\\n     */\\n    function _burnBoostedBurnFuel(\\n        address from,\\n        BoosterFuel memory fuel,\\n        UnpackedData memory unpacked\\n    ) internal override returns (FuelBurn memory) {\\n        FuelBurn memory fuelBurn;\\n\\n        if (fuel.unlockedPrps > 0) {\\n            require(fuel.unlockedPrps <= MAX_BOOSTER_FUEL, \\\"PRPS-10\\\");\\n\\n            require(unpacked.balance >= fuel.unlockedPrps, \\\"PRPS-7\\\");\\n            unpacked.balance -= fuel.unlockedPrps;\\n\\n            fuelBurn.amount = fuel.unlockedPrps;\\n            fuelBurn.fuelType = FuelType.UNLOCKED_PRPS;\\n            return fuelBurn;\\n        }\\n\\n        if (fuel.lockedPrps > 0) {\\n            require(fuel.lockedPrps <= MAX_BOOSTER_FUEL, \\\"PRPS-10\\\");\\n\\n            require(unpacked.hodlBalance >= fuel.lockedPrps, \\\"PRPS-7\\\");\\n            // Fuel is taken from hodl balance in _beforeBurn\\n            // unpacked.hodlBalance -= fuel.lockedPrps;\\n\\n            fuelBurn.amount = fuel.lockedPrps;\\n            fuelBurn.fuelType = FuelType.LOCKED_PRPS;\\n\\n            return fuelBurn;\\n        }\\n\\n        if (fuel.intrinsicFuel > 0) {\\n            require(fuel.intrinsicFuel <= MAX_BOOSTER_FUEL, \\\"PRPS-10\\\");\\n\\n            fuelBurn.amount = fuel.intrinsicFuel;\\n            fuelBurn.fuelType = FuelType.AUTO_MINTED_DUBI;\\n\\n            return fuelBurn;\\n        }\\n\\n        // If the fuel is DUBI, then we have to reach out to the DUBI contract.\\n        if (fuel.dubi > 0) {\\n            // Reverts if the requested amount cannot be burned\\n            _dubi.burnFuel(\\n                from,\\n                TokenFuel({\\n                    tokenAlias: TOKEN_FUEL_ALIAS_DUBI,\\n                    amount: fuel.dubi\\n                })\\n            );\\n\\n            fuelBurn.amount = fuel.dubi;\\n            fuelBurn.fuelType = FuelType.DUBI;\\n            return fuelBurn;\\n        }\\n\\n        // No fuel at all\\n        return fuelBurn;\\n    }\\n\\n    //---------------------------------------------------------------\\n    // Pending ops\\n    //---------------------------------------------------------------\\n\\n    function _getHasherContracts()\\n        internal\\n        override\\n        returns (address[] memory)\\n    {\\n        address[] memory hashers = new address[](5);\\n        hashers[0] = address(this);\\n        hashers[1] = address(_dubi);\\n        hashers[2] = _hodlAddress;\\n        hashers[3] = _externalAddress1;\\n        hashers[4] = _externalAddress2;\\n\\n        return hashers;\\n    }\\n\\n    /**\\n     * @dev Create a pending transfer by moving the funds of `spender` to this contract.\\n     * Special behavior applies to pending burns to account for locked PRPS.\\n     */\\n    function _createPendingTransferInternal(\\n        OpHandle memory opHandle,\\n        address spender,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal override returns (PendingTransfer memory) {\\n        if (opHandle.opType != OP_TYPE_BURN) {\\n            return\\n                // Nothing special to do for non-burns so just call parent implementation\\n                super._createPendingTransferInternal(\\n                    opHandle,\\n                    spender,\\n                    from,\\n                    to,\\n                    amount,\\n                    data\\n                );\\n        }\\n\\n        // When burning, we first use unlocked PRPS and match the remaining amount with locked PRPS from the Hodl contract.\\n\\n        // Sanity check\\n        assert(amount < 2**96);\\n        uint96 transferAmount = uint96(amount);\\n        uint96 lockedPrpsAmount = transferAmount;\\n\\n        UnpackedData memory unpacked = _unpackPackedData(_packedData[from]);\\n        // First try to move as much unlocked PRPS as possible to the PRPS address\\n        uint96 unlockedPrpsToMove = transferAmount;\\n        if (unlockedPrpsToMove > unpacked.balance) {\\n            unlockedPrpsToMove = unpacked.balance;\\n        }\\n\\n        // Update the locked PRPS we have to use\\n        lockedPrpsAmount -= unlockedPrpsToMove;\\n\\n        if (unlockedPrpsToMove > 0) {\\n            _move({from: from, to: address(this), amount: unlockedPrpsToMove});\\n        }\\n\\n        // If we still need locked PRPS, call into the Hodl contract.\\n        // This will also take pending hodls into account, if `from` has\\n        // some.\\n        if (lockedPrpsAmount > 0) {\\n            // Reverts if not the exact amount can be set to pending\\n            _hodl.setLockedPrpsToPending(from, lockedPrpsAmount);\\n        }\\n\\n        // Create pending transfer\\n        return\\n            PendingTransfer({\\n                spender: spender,\\n                transferAmount: transferAmount,\\n                to: to,\\n                occupiedAmount: lockedPrpsAmount,\\n                data: data\\n            });\\n    }\\n\\n    /**\\n     * @dev Hook that is called during revert of a pending op.\\n     * Reverts any changes to locked PRPS when 'opType' is burn.\\n     */\\n    function _onRevertPendingOp(\\n        address user,\\n        uint8 opType,\\n        uint64 opId,\\n        uint96 transferAmount,\\n        uint96 occupiedAmount\\n    ) internal override {\\n        if (opType != OP_TYPE_BURN) {\\n            return;\\n        }\\n\\n        // Extract the pending locked PRPS from the amount.\\n        if (occupiedAmount > 0) {\\n            _hodl.revertLockedPrpsSetToPending(user, occupiedAmount);\\n        }\\n    }\\n\\n    //---------------------------------------------------------------\\n    // Shared pending ops for Hodl\\n    //---------------------------------------------------------------\\n\\n    /**\\n     * @dev Creates a new opHandle with the given type for `user`. Hodl and Prps share the same\\n     * opCounter to enforce a consistent order in which pending ops are finalized/reverted\\n     * across contracts. This function can only be called by Hodl.\\n     */\\n    function createNewOpHandleShared(\\n        IOptIn.OptInStatus memory optInStatus,\\n        address user,\\n        uint8 opType\\n    ) public onlyHodl returns (OpHandle memory) {\\n        return _createNewOpHandle(optInStatus, user, opType);\\n    }\\n\\n    /**\\n     * @dev Delete the op handle with the given `opId` from `user`. Hodl and Prps share the same\\n     * opCounter to enforce a consistent order in which pending ops are finalized/reverted\\n     * across contracts. This function can only be called by Hodl.\\n     */\\n    function deleteOpHandleShared(address user, OpHandle memory opHandle)\\n        public\\n        onlyHodl\\n        returns (bool)\\n    {\\n        _deleteOpHandle(user, opHandle);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Get the next op id for `user`. Hodl and Prps share the same\\n     * opCounter to enforce a consistent order in which pending ops are finalized/reverted\\n     * across contracts. This function can only be called by Hodl.\\n     */\\n    function assertFinalizeFIFOShared(address user, uint64 opId)\\n        public\\n        onlyHodl\\n        returns (bool)\\n    {\\n        _assertFinalizeFIFO(user, opId);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Get the next op id for `user`. Hodl and Prps share the same\\n     * opCounter to enforce a consistent order in which pending ops are finalized/reverted\\n     * across contracts. This function can only be called by Hodl.\\n     */\\n    function assertRevertLIFOShared(address user, uint64 opId)\\n        public\\n        onlyHodl\\n        returns (bool)\\n    {\\n        _assertRevertLIFO(user, opId);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the global ERC1820 Registry, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\\n * implementers for interfaces in this registry, as well as query support.\\n *\\n * Implementers may be shared by multiple accounts, and can also implement more\\n * than a single interface for each account. Contracts can implement interfaces\\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\\n * contract.\\n *\\n * {IERC165} interfaces can also be queried via the registry.\\n *\\n * For an in-depth explanation and source code analysis, see the EIP text.\\n */\\ninterface IERC1820Registry {\\n    /**\\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\\n     * account is able to set interface implementers for it.\\n     *\\n     * By default, each account is its own manager. Passing a value of `0x0` in\\n     * `newManager` will reset the manager to this initial state.\\n     *\\n     * Emits a {ManagerChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     */\\n    function setManager(address account, address newManager) external;\\n\\n    /**\\n     * @dev Returns the manager for `account`.\\n     *\\n     * See {setManager}.\\n     */\\n    function getManager(address account) external view returns (address);\\n\\n    /**\\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\\n     * `interfaceHash`.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     * The zero address can also be used in `implementer` to remove an old one.\\n     *\\n     * See {interfaceHash} to learn how these are created.\\n     *\\n     * Emits an {InterfaceImplementerSet} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\\n     * end in 28 zeroes).\\n     * - `implementer` must implement {IERC1820Implementer} and return true when\\n     * queried for support, unless `implementer` is the caller. See\\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\\n     */\\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\\n\\n    /**\\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\\n     * implementer is registered, returns the zero address.\\n     *\\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\\n     * zeroes), `account` will be queried for support of it.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     */\\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\\n\\n    /**\\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\\n     * corresponding\\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\\n     */\\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\\n\\n    /**\\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\\n     *  @param account Address of the contract for which to update the cache.\\n     *  @param interfaceId ERC165 interface for which to update the cache.\\n     */\\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\\n\\n    /**\\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\\n     *  If the result is not cached a direct lookup on the contract address is performed.\\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\\n     *  {updateERC165Cache} with the contract address.\\n     *  @param account Address of the contract to check.\\n     *  @param interfaceId ERC165 interface to check.\\n     *  @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    /**\\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\\n     *  @param account Address of the contract to check.\\n     *  @param interfaceId ERC165 interface to check.\\n     *  @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\\n\\n    event ManagerChanged(address indexed account, address indexed newManager);\\n}\\n\"\r\n    },\r\n    \"contracts/IBoostableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n// Token agnostic fuel struct that is passed around when the fuel is burned by a different (token) contract.\\n// The contract has to explicitely support the desired token that should be burned.\\nstruct TokenFuel {\\n    // A token alias that must be understood by the target contract\\n    uint8 tokenAlias;\\n    uint96 amount;\\n}\\n\\n/**\\n * @dev Extends the interface of the ERC20 standard as defined in the EIP with\\n * `boostedTransferFrom` to perform transfers without having to rely on an allowance.\\n */\\ninterface IBoostableERC20 {\\n    // ERC20\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    // Extension\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`.\\n     *\\n     * If the caller is known by the callee, then the implementation should skip approval checks.\\n     * Also accepts a data payload, similar to ERC721's `safeTransferFrom` to pass arbitrary data.\\n     *\\n     */\\n    function boostedTransferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Burns `fuel` from `from`.\\n     */\\n    function burnFuel(address from, TokenFuel memory fuel) external;\\n}\\n\"\r\n    },\r\n    \"contracts/BoostableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Boostable.sol\\\";\\nimport \\\"./BoostableLib.sol\\\";\\n\\n/**\\n * @dev EIP712 boostable primitives related to ERC20 for the Purpose domain\\n */\\nabstract contract BoostableERC20 is Boostable {\\n    /**\\n     * @dev A struct representing the payload of the ERC20 `boostedSend` function.\\n     */\\n    struct BoostedSend {\\n        uint8 tag;\\n        address sender;\\n        address recipient;\\n        uint256 amount;\\n        bytes data;\\n        BoosterFuel fuel;\\n        BoosterPayload boosterPayload;\\n    }\\n\\n    /**\\n     * @dev A struct representing the payload of the ERC20 `boostedBurn` function.\\n     */\\n    struct BoostedBurn {\\n        uint8 tag;\\n        address account;\\n        uint256 amount;\\n        bytes data;\\n        BoosterFuel fuel;\\n        BoosterPayload boosterPayload;\\n    }\\n\\n    uint8 internal constant BOOST_TAG_SEND = 0;\\n    uint8 internal constant BOOST_TAG_BURN = 1;\\n\\n    bytes32 internal constant BOOSTED_SEND_TYPEHASH = keccak256(\\n        \\\"BoostedSend(uint8 tag,address sender,address recipient,uint256 amount,bytes data,BoosterFuel fuel,BoosterPayload boosterPayload)BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)\\\"\\n    );\\n\\n    bytes32 internal constant BOOSTED_BURN_TYPEHASH = keccak256(\\n        \\\"BoostedBurn(uint8 tag,address account,uint256 amount,bytes data,BoosterFuel fuel,BoosterPayload boosterPayload)BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)\\\"\\n    );\\n\\n    constructor(address optIn) public Boostable(optIn) {}\\n\\n    /**\\n     * @dev Returns the hash of `boostedSend`.\\n     */\\n    function hashBoostedSend(BoostedSend memory send, address booster)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            BoostableLib.hashWithDomainSeparator(\\n                _DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        BOOSTED_SEND_TYPEHASH,\\n                        BOOST_TAG_SEND,\\n                        send.sender,\\n                        send.recipient,\\n                        send.amount,\\n                        keccak256(send.data),\\n                        BoostableLib.hashBoosterFuel(send.fuel),\\n                        BoostableLib.hashBoosterPayload(\\n                            send.boosterPayload,\\n                            booster\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns the hash of `boostedBurn`.\\n     */\\n    function hashBoostedBurn(BoostedBurn memory burn, address booster)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            BoostableLib.hashWithDomainSeparator(\\n                _DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        BOOSTED_BURN_TYPEHASH,\\n                        BOOST_TAG_BURN,\\n                        burn.account,\\n                        burn.amount,\\n                        keccak256(burn.data),\\n                        BoostableLib.hashBoosterFuel(burn.fuel),\\n                        BoostableLib.hashBoosterPayload(\\n                            burn.boosterPayload,\\n                            booster\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Tries to interpret the given boosterMessage and\\n     * return it's hash plus creation timestamp.\\n     */\\n    function decodeAndHashBoosterMessage(\\n        address targetBooster,\\n        bytes memory boosterMessage\\n    ) external override view returns (bytes32, uint64) {\\n        require(boosterMessage.length > 0, \\\"PB-7\\\");\\n\\n        uint8 tag = _readBoosterTag(boosterMessage);\\n        if (tag == BOOST_TAG_SEND) {\\n            BoostedSend memory send = abi.decode(boosterMessage, (BoostedSend));\\n            return (\\n                hashBoostedSend(send, targetBooster),\\n                send.boosterPayload.timestamp\\n            );\\n        }\\n\\n        if (tag == BOOST_TAG_BURN) {\\n            BoostedBurn memory burn = abi.decode(boosterMessage, (BoostedBurn));\\n            return (\\n                hashBoostedBurn(burn, targetBooster),\\n                burn.boosterPayload.timestamp\\n            );\\n        }\\n\\n        // Unknown tag, so just return an empty result\\n        return (\\\"\\\", 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Boostable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ProtectedBoostable.sol\\\";\\n\\n/**\\n * @dev Purpose Boostable primitives using the EIP712 standard\\n */\\nabstract contract Boostable is ProtectedBoostable {\\n    // \\\"Purpose\\\", \\\"Dubi\\\" and \\\"Hodl\\\" are all under the \\\"Purpose\\\" umbrella\\n    constructor(address optIn)\\n        public\\n        ProtectedBoostable(\\n            optIn,\\n            keccak256(\\n                abi.encode(\\n                    EIP712_DOMAIN_TYPEHASH,\\n                    keccak256(\\\"Purpose\\\"),\\n                    keccak256(\\\"1\\\"),\\n                    _getChainId(),\\n                    address(this)\\n                )\\n            )\\n        )\\n    {}\\n\\n    // Fuel alias constants - used when fuel is burned from external contract calls\\n    uint8 internal constant TOKEN_FUEL_ALIAS_UNLOCKED_PRPS = 0;\\n    uint8 internal constant TOKEN_FUEL_ALIAS_LOCKED_PRPS = 1;\\n    uint8 internal constant TOKEN_FUEL_ALIAS_DUBI = 2;\\n}\\n\"\r\n    },\r\n    \"contracts/BoostableLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nstruct BoosterFuel {\\n    uint96 dubi;\\n    uint96 unlockedPrps;\\n    uint96 lockedPrps;\\n    uint96 intrinsicFuel;\\n}\\n\\nstruct BoosterPayload {\\n    address booster;\\n    uint64 timestamp;\\n    uint64 nonce;\\n    // Fallback for 'personal_sign' when e.g. using hardware wallets that don't support\\n    // EIP712 signing (yet).\\n    bool isLegacySignature;\\n}\\n\\n// Library for Boostable hash functions that are completely inlined.\\nlibrary BoostableLib {\\n    bytes32 private constant BOOSTER_PAYLOAD_TYPEHASH = keccak256(\\n        \\\"BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)\\\"\\n    );\\n\\n    bytes32 internal constant BOOSTER_FUEL_TYPEHASH = keccak256(\\n        \\\"BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)\\\"\\n    );\\n\\n    /**\\n     * @dev Returns the hash of the packed DOMAIN_SEPARATOR and `messageHash` and is used for verifying\\n     * a signature.\\n     */\\n    function hashWithDomainSeparator(\\n        bytes32 domainSeparator,\\n        bytes32 messageHash\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, messageHash)\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns the hash of `payload` using the provided booster (i.e. `msg.sender`).\\n     */\\n    function hashBoosterPayload(BoosterPayload memory payload, address booster)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    BOOSTER_PAYLOAD_TYPEHASH,\\n                    booster,\\n                    payload.timestamp,\\n                    payload.nonce,\\n                    payload.isLegacySignature\\n                )\\n            );\\n    }\\n\\n    function hashBoosterFuel(BoosterFuel memory fuel)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    BOOSTER_FUEL_TYPEHASH,\\n                    fuel.dubi,\\n                    fuel.unlockedPrps,\\n                    fuel.lockedPrps,\\n                    fuel.intrinsicFuel\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns the tag found in the given `boosterMessage`.\\n     */\\n    function _readBoosterTag(bytes memory boosterMessage)\\n        internal\\n        pure\\n        returns (uint8)\\n    {\\n        // The tag is either the 32th byte or the 64th byte depending on whether\\n        // the booster message contains dynamic bytes or not.\\n        //\\n        // If it contains a dynamic byte array, then the first word points to the first\\n        // data location.\\n        //\\n        // Therefore, we read the 32th byte and check if it's >= 32 and if so,\\n        // simply read the (32 + first word)th byte to get the tag.\\n        //\\n        // This imposes a limit on the number of tags we can support (<32), but\\n        // given that it is very unlikely for so many tags to exist it is fine.\\n        //\\n        // Read the 32th byte to get the tag, because it is a uint8 padded to 32 bytes.\\n        // i.e.\\n        // -----------------------------------------------------------------v\\n        // 0x0000000000000000000000000000000000000000000000000000000000000001\\n        //   ...\\n        //\\n        uint8 tag = uint8(boosterMessage[31]);\\n        if (tag >= 32) {\\n            // Read the (32 + tag) byte. E.g. if tag is 32, then we read the 64th:\\n            // --------------------------------------------------------------------\\n            // 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            //   0000000000000000000000000000000000000000000000000000000000000001 <\\n            //   ...\\n            //\\n            tag = uint8(boosterMessage[31 + tag]);\\n        }\\n\\n        return tag;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ProtectedBoostable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./EIP712Boostable.sol\\\";\\nimport \\\"./IOptIn.sol\\\";\\nimport \\\"./ProtectedBoostableLib.sol\\\";\\n\\nabstract contract ProtectedBoostable is EIP712Boostable {\\n    //---------------------------------------------------------------\\n    // State for non-boosted operations while opted-in and the OPT_IN permaboost is active\\n    //---------------------------------------------------------------\\n\\n    uint256 private constant MAX_PENDING_OPS = 25;\\n\\n    // A mapping of account to an opCounter.\\n    mapping(address => OpCounter) internal _opCounters;\\n\\n    // A mapping of account to an array containing all it's pending ops.\\n    mapping(address => OpHandle[]) internal _pendingOpsByAddress;\\n\\n    // A mapping of keccak256(address,opId) to a struct holding metadata like the associated user account and creation timestamp.\\n    mapping(bytes32 => OpMetadata) internal _opMetadata;\\n\\n    // Event that is emitted whenever a pending op is created\\n    // NOTE: returning an OpHandle in the event flattens it into an array for some reason\\n    // i.e. emit PendingOp(0x123.., OpHandle(1, 0)) => { from: 0x123, opHandle: ['1', '0']}\\n    event PendingOp(address from, uint64 opId, uint8 opType);\\n    // Event that is emitted whenever a pending op is finalized\\n    event FinalizedOp(address from, uint64 opId, uint8 opType);\\n    // Event that is emitted whenever a pending op is reverted\\n    event RevertedOp(address from, uint64 opId, uint8 opType);\\n\\n    constructor(address optIn, bytes32 domainSeparator)\\n        public\\n        EIP712Boostable(optIn, domainSeparator)\\n    {}\\n\\n    //---------------------------------------------------------------\\n    // Pending ops\\n    //---------------------------------------------------------------\\n\\n    /**\\n     * @dev Returns the metadata of an op. Returns a zero struct if it doesn't exist.\\n     */\\n    function getOpMetadata(address user, uint64 opId)\\n        public\\n        virtual\\n        view\\n        returns (OpMetadata memory)\\n    {\\n        return _opMetadata[_getOpKey(user, opId)];\\n    }\\n\\n    /**\\n     * @dev Returns the metadata of an op. Returns a zero struct if it doesn't exist.\\n     */\\n    function getOpCounter(address user)\\n        public\\n        virtual\\n        view\\n        returns (OpCounter memory)\\n    {\\n        return _opCounters[user];\\n    }\\n\\n    /**\\n     * @dev Returns the metadata of an op. Reverts if it doesn't exist or\\n     * the opType mismatches.\\n     */\\n    function safeGetOpMetadata(address user, OpHandle memory opHandle)\\n        public\\n        virtual\\n        view\\n        returns (OpMetadata memory)\\n    {\\n        OpMetadata storage metadata = _opMetadata[_getOpKey(\\n            user,\\n            opHandle.opId\\n        )];\\n\\n        // If 'createdAt' is zero, then it's non-existent for us\\n        require(metadata.createdAt > 0, \\\"PB-1\\\");\\n        require(metadata.opType == opHandle.opType, \\\"PB-2\\\");\\n\\n        return metadata;\\n    }\\n\\n    /**\\n     * @dev Get the next op id for `user`\\n     */\\n    function _getNextOpId(address user) internal returns (uint64) {\\n        OpCounter storage counter = _opCounters[user];\\n        // NOTE: we always increase by 1, so it cannot overflow as long as this\\n        // is the only place increasing the counter.\\n        uint64 nextOpId = counter.value + 1;\\n\\n        // This also updates the nextFinalize/Revert values\\n        if (counter.nextFinalize == 0) {\\n            // Only gets updated if currently pointing to \\\"nothing\\\", because FIFO\\n            counter.nextFinalize = nextOpId;\\n        }\\n\\n        // nextRevert is always updated to the new opId, because LIFO\\n        counter.nextRevert = nextOpId;\\n        counter.value = nextOpId;\\n\\n        // NOTE: It is safe to downcast to uint64 since it's practically impossible to overflow.\\n        return nextOpId;\\n    }\\n\\n    /**\\n     * @dev Creates a new opHandle with the given type for `user`.\\n     */\\n    function _createNewOpHandle(\\n        IOptIn.OptInStatus memory optInStatus,\\n        address user,\\n        uint8 opType\\n    ) internal virtual returns (OpHandle memory) {\\n        uint64 nextOpId = _getNextOpId(user);\\n        OpHandle memory opHandle = OpHandle({opId: nextOpId, opType: opType});\\n\\n        // NOTE: we have a hard limit of 25 pending OPs and revert if that\\n        // limit is exceeded.\\n        require(_pendingOpsByAddress[user].length < MAX_PENDING_OPS, \\\"PB-3\\\");\\n\\n        address booster = optInStatus.optedInTo;\\n\\n        _pendingOpsByAddress[user].push(opHandle);\\n        _opMetadata[_getOpKey(user, nextOpId)] = OpMetadata({\\n            createdAt: uint64(block.timestamp),\\n            booster: booster,\\n            opType: opType\\n        });\\n\\n        return opHandle;\\n    }\\n\\n    /**\\n     * @dev Delete the given `opHandle` from `user`.\\n     */\\n    function _deleteOpHandle(address user, OpHandle memory opHandle)\\n        internal\\n        virtual\\n    {\\n        OpHandle[] storage _opHandles = _pendingOpsByAddress[user];\\n        OpCounter storage opCounter = _opCounters[user];\\n\\n        ProtectedBoostableLib.deleteOpHandle(\\n            user,\\n            opHandle,\\n            _opHandles,\\n            opCounter,\\n            _opMetadata\\n        );\\n    }\\n\\n    /**\\n     * @dev Assert that the caller is allowed to finalize a pending op.\\n     *\\n     * Returns the user and createdAt timestamp of the op on success in order to\\n     * save some gas by minimizing redundant look-ups.\\n     */\\n    function _assertCanFinalize(address user, OpHandle memory opHandle)\\n        internal\\n        returns (uint64)\\n    {\\n        OpMetadata memory metadata = safeGetOpMetadata(user, opHandle);\\n\\n        uint64 createdAt = metadata.createdAt;\\n\\n        // First check if the user is still opted-in. If not, then anyone\\n        // can finalize since it is no longer associated with the original booster.\\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(user);\\n        if (!optInStatus.isOptedIn) {\\n            return createdAt;\\n        }\\n\\n        // Revert if not FIFO order\\n        _assertFinalizeFIFO(user, opHandle.opId);\\n\\n        return ProtectedBoostableLib.assertCanFinalize(metadata, optInStatus);\\n    }\\n\\n    /**\\n     * @dev Asserts that the caller (msg.sender) is allowed to revert a pending operation.\\n     * The caller must be opted-in by user and provide a valid signature from the user\\n     * that hasn't expired yet.\\n     */\\n    function _assertCanRevert(\\n        address user,\\n        OpHandle memory opHandle,\\n        uint64 opTimestamp,\\n        bytes memory boosterMessage,\\n        Signature memory signature\\n    ) internal {\\n        // Revert if not LIFO order\\n        _assertRevertLIFO(user, opHandle.opId);\\n\\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(user);\\n\\n        require(\\n            optInStatus.isOptedIn && msg.sender == optInStatus.optedInTo,\\n            \\\"PB-6\\\"\\n        );\\n\\n        // In order to verify the boosterMessage, we need the hash and timestamp of when it\\n        // was signed. To interpret the boosterMessage, consult all available hasher contracts and\\n        // take the first non-zero result.\\n        address[] memory hasherContracts = _getHasherContracts();\\n\\n        // Call external library function, which performs the actual assertion. The reason\\n        // why it is not inlined, is that the need to reduce bytecode size.\\n        ProtectedBoostableLib.verifySignatureForRevert(\\n            user,\\n            opTimestamp,\\n            optInStatus,\\n            boosterMessage,\\n            hasherContracts,\\n            signature\\n        );\\n    }\\n\\n    function _getHasherContracts() internal virtual returns (address[] memory);\\n\\n    /**\\n     * @dev Asserts that the given opId is the next to be finalized for `user`.\\n     */\\n    function _assertFinalizeFIFO(address user, uint64 opId) internal virtual {\\n        OpCounter storage counter = _opCounters[user];\\n        require(counter.nextFinalize == opId, \\\"PB-9\\\");\\n    }\\n\\n    /**\\n     * @dev Asserts that the given opId is the next to be reverted for `user`.\\n     */\\n    function _assertRevertLIFO(address user, uint64 opId) internal virtual {\\n        OpCounter storage counter = _opCounters[user];\\n        require(counter.nextRevert == opId, \\\"PB-10\\\");\\n    }\\n\\n    /**\\n     * @dev Prepare an op revert.\\n     * - Asserts that the caller is allowed to revert the given op\\n     * - Deletes the op handle to minimize risks of reentrancy\\n     */\\n    function _prepareOpRevert(\\n        address user,\\n        OpHandle memory opHandle,\\n        bytes memory boosterMessage,\\n        Signature memory signature\\n    ) internal {\\n        OpMetadata memory metadata = safeGetOpMetadata(user, opHandle);\\n\\n        _assertCanRevert(\\n            user,\\n            opHandle,\\n            metadata.createdAt,\\n            boosterMessage,\\n            signature\\n        );\\n\\n        // Delete opHandle, which prevents reentrancy since `safeGetOpMetadata`\\n        // will fail afterwards.\\n        _deleteOpHandle(user, opHandle);\\n    }\\n\\n    /**\\n     * @dev Returns the hash of (user, opId) which is used as a look-up\\n     * key in the `_opMetadata` mapping.\\n     */\\n    function _getOpKey(address user, uint64 opId)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(user, opId));\\n    }\\n\\n    /**\\n     * @dev Deriving contracts can override this function to accept a boosterMessage for a given booster and\\n     * interpret it into a hash and timestamp.\\n     */\\n    function decodeAndHashBoosterMessage(\\n        address targetBooster,\\n        bytes memory boosterMessage\\n    ) external virtual view returns (bytes32, uint64) {}\\n\\n    /**\\n     * @dev Returns the tag found in the given `boosterMesasge`.\\n     */\\n    function _readBoosterTag(bytes memory boosterMessage)\\n        internal\\n        pure\\n        returns (uint8)\\n    {\\n        // The tag is either the 32th byte or the 64th byte depending on whether\\n        // the booster message contains dynamic bytes or not.\\n        //\\n        // If it contains a dynamic byte array, then the first word points to the first\\n        // data location.\\n        //\\n        // Therefore, we read the 32th byte and check if it's >= 32 and if so,\\n        // simply read the (32 + first word)th byte to get the tag.\\n        //\\n        // This imposes a limit on the number of tags we can support (<32), but\\n        // given that it is very unlikely for so many tags to exist it is fine.\\n        //\\n        // Read the 32th byte to get the tag, because it is a uint8 padded to 32 bytes.\\n        // i.e.\\n        // -----------------------------------------------------------------v\\n        // 0x0000000000000000000000000000000000000000000000000000000000000001\\n        //   ...\\n        //\\n        uint8 tag = uint8(boosterMessage[31]);\\n        if (tag >= 32) {\\n            // Read the (32 + tag) byte. E.g. if tag is 32, then we read the 64th:\\n            // --------------------------------------------------------------------\\n            // 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            //   0000000000000000000000000000000000000000000000000000000000000001 <\\n            //   ...\\n            //\\n            tag = uint8(boosterMessage[31 + tag]);\\n        }\\n\\n        return tag;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EIP712Boostable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./IOptIn.sol\\\";\\nimport \\\"./BoostableLib.sol\\\";\\nimport \\\"./IBoostableERC20.sol\\\";\\n\\n/**\\n * @dev Boostable base contract\\n *\\n * All deriving contracts are expected to implement EIP712 for the message signing.\\n *\\n */\\nabstract contract EIP712Boostable {\\n    using ECDSA for bytes32;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    IOptIn internal immutable _OPT_IN;\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\\n\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\\n        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n    );\\n\\n    bytes32 private constant BOOSTER_PAYLOAD_TYPEHASH = keccak256(\\n        \\\"BoosterPayload(address booster,uint64 timestamp,uint64 nonce,bool isLegacySignature)\\\"\\n    );\\n\\n    bytes32 internal constant BOOSTER_FUEL_TYPEHASH = keccak256(\\n        \\\"BoosterFuel(uint96 dubi,uint96 unlockedPrps,uint96 lockedPrps,uint96 intrinsicFuel)\\\"\\n    );\\n\\n    // The boost fuel is capped to 10 of the respective token that will be used for payment.\\n    uint96 internal constant MAX_BOOSTER_FUEL = 10 ether;\\n\\n    // A magic booster permission prefix\\n    bytes6 private constant MAGIC_BOOSTER_PERMISSION_PREFIX = \\\"BOOST-\\\";\\n\\n    constructor(address optIn, bytes32 domainSeparator) public {\\n        _OPT_IN = IOptIn(optIn);\\n        _DOMAIN_SEPARATOR = domainSeparator;\\n    }\\n\\n    // A mapping of mappings to keep track of used nonces by address to\\n    // protect against replays. Each 'Boostable' contract maintains it's own\\n    // state for nonces.\\n    mapping(address => uint64) private _nonces;\\n\\n    //---------------------------------------------------------------\\n\\n    function getNonce(address account) external virtual view returns (uint64) {\\n        return _nonces[account];\\n    }\\n\\n    function getOptInStatus(address account)\\n        internal\\n        view\\n        returns (IOptIn.OptInStatus memory)\\n    {\\n        return _OPT_IN.getOptInStatus(account);\\n    }\\n\\n    /**\\n     * @dev Called by every 'boosted'-function to ensure that `msg.sender` (i.e. a booster) is\\n     * allowed to perform the call for `from` (the origin) by verifying that `messageHash`\\n     * has been signed by `from`. Additionally, `from` provides a nonce to prevent\\n     * replays. Boosts cannot be verified out of order.\\n     *\\n     * @param from the address that the boost is made for\\n     * @param messageHash the reconstructed message hash based on the function input\\n     * @param payload the booster payload\\n     * @param signature the signature of `from`\\n     */\\n    function verifyBoost(\\n        address from,\\n        bytes32 messageHash,\\n        BoosterPayload memory payload,\\n        Signature memory signature\\n    ) internal {\\n        uint64 currentNonce = _nonces[from];\\n        require(currentNonce == payload.nonce - 1, \\\"AB-1\\\");\\n\\n        _nonces[from] = currentNonce + 1;\\n\\n        _verifyBoostWithoutNonce(from, messageHash, payload, signature);\\n    }\\n\\n    /**\\n     * @dev Verify a boost without verifying the nonce.\\n     */\\n    function _verifyBoostWithoutNonce(\\n        address from,\\n        bytes32 messageHash,\\n        BoosterPayload memory payload,\\n        Signature memory signature\\n    ) internal view {\\n        // The sender must be the booster specified in the payload\\n        require(msg.sender == payload.booster, \\\"AB-2\\\");\\n\\n        (bool isOptedInToSender, uint256 optOutPeriod) = _OPT_IN.isOptedInBy(\\n            msg.sender,\\n            from\\n        );\\n\\n        // `from` must be opted-in to booster\\n        require(isOptedInToSender, \\\"AB-3\\\");\\n\\n        // The given timestamp must not be greater than `block.timestamp + 1 hour`\\n        // and at most `optOutPeriod(booster)` seconds old.\\n        uint64 _now = uint64(block.timestamp);\\n        uint64 _optOutPeriod = uint64(optOutPeriod);\\n\\n        bool notTooFarInFuture = payload.timestamp <= _now + 1 hours;\\n        bool belowMaxAge = true;\\n\\n        // Calculate the absolute difference. Because of the small tolerance, `payload.timestamp`\\n        // may be greater than `_now`:\\n        if (payload.timestamp <= _now) {\\n            belowMaxAge = _now - payload.timestamp <= _optOutPeriod;\\n        }\\n\\n        // Signature must not be expired\\n        require(notTooFarInFuture && belowMaxAge, \\\"AB-4\\\");\\n\\n        // NOTE: Currently, hardware wallets (e.g. Ledger, Trezor) do not support EIP712 signing (specifically `signTypedData_v4`).\\n        // However, a user can still sign the EIP712 hash with the caveat that it's signed using `personal_sign` which prepends\\n        // the prefix '\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)'.\\n        //\\n        // To still support that, we add the prefix to the hash if `isLegacySignature` is true.\\n        if (payload.isLegacySignature) {\\n            messageHash = messageHash.toEthSignedMessageHash();\\n        }\\n\\n        // Valid, if the recovered address from `messageHash` with the given `signature` matches `from`.\\n\\n        address signer = ecrecover(\\n            messageHash,\\n            signature.v,\\n            signature.r,\\n            signature.s\\n        );\\n\\n        if (!payload.isLegacySignature && signer != from) {\\n            // As a last resort we try anyway, in case the caller simply forgot the `isLegacySignature` flag.\\n            signer = ecrecover(\\n                messageHash.toEthSignedMessageHash(),\\n                signature.v,\\n                signature.r,\\n                signature.s\\n            );\\n        }\\n\\n        require(from == signer, \\\"AB-5\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the hash of `payload` using the provided booster (i.e. `msg.sender`).\\n     */\\n    function hashBoosterPayload(BoosterPayload memory payload, address booster)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    BOOSTER_PAYLOAD_TYPEHASH,\\n                    booster,\\n                    payload.timestamp,\\n                    payload.nonce\\n                )\\n            );\\n    }\\n\\n    function _getChainId() internal pure returns (uint256) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return chainId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IOptIn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nstruct Signature {\\n    bytes32 r;\\n    bytes32 s;\\n    uint8 v;\\n}\\n\\ninterface IOptIn {\\n    struct OptInStatus {\\n        bool isOptedIn;\\n        bool permaBoostActive;\\n        address optedInTo;\\n        uint32 optOutPeriod;\\n    }\\n\\n    function getOptInStatusPair(address accountA, address accountB)\\n        external\\n        view\\n        returns (OptInStatus memory, OptInStatus memory);\\n\\n    function getOptInStatus(address account)\\n        external\\n        view\\n        returns (OptInStatus memory);\\n\\n    function isOptedInBy(address _sender, address _account)\\n        external\\n        view\\n        returns (bool, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/ProtectedBoostableLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./IOptIn.sol\\\";\\n\\nstruct OpHandle {\\n    uint8 opType;\\n    uint64 opId;\\n}\\n\\nstruct OpMetadata {\\n    uint8 opType; // the operation type\\n    uint64 createdAt; // the creation timestamp of an op\\n    address booster; // the booster at the time of when the op has been created\\n}\\n\\nstruct OpCounter {\\n    // The current value of the counter\\n    uint64 value;\\n    // Contains the opId that is to be finalized next - i.e. FIFO order\\n    uint64 nextFinalize;\\n    // Contains the opId that is to be reverted next - i.e. LIFO order\\n    uint64 nextRevert;\\n}\\n\\n// Library containing public functions for pending ops - those will never be inlined\\n// to reduce the bytecode size of individual contracts.\\nlibrary ProtectedBoostableLib {\\n    using ECDSA for bytes32;\\n\\n    function deleteOpHandle(\\n        address user,\\n        OpHandle memory opHandle,\\n        OpHandle[] storage opHandles,\\n        OpCounter storage opCounter,\\n        mapping(bytes32 => OpMetadata) storage opMetadata\\n    ) public {\\n        uint256 length = opHandles.length;\\n        assert(length > 0);\\n\\n        uint64 minOpId; // becomes next LIFO\\n        uint64 maxOpId; // becomes next FIFO\\n\\n        // Pending ops are capped to MAX_PENDING_OPS. We always perform\\n        // MIN(length, MAX_PENDING_OPS) look-ups to do a \\\"swap-and-pop\\\" and\\n        // for updating the opCounter LIFO/FIFO pointers.\\n        for (uint256 i = 0; i < length; i++) {\\n            uint64 currOpId = opHandles[i].opId;\\n            if (currOpId == opHandle.opId) {\\n                // Overwrite item at i with last\\n                opHandles[i] = opHandles[length - 1];\\n\\n                // Continue, to ignore this opId when updating\\n                // minOpId and maxOpId.\\n                continue;\\n            }\\n\\n            // Update minOpId\\n            if (minOpId == 0 || currOpId < minOpId) {\\n                minOpId = currOpId;\\n            }\\n\\n            // Update maxOpId\\n            if (currOpId > maxOpId) {\\n                maxOpId = currOpId;\\n            }\\n        }\\n\\n        // Might be 0 when everything got finalized/reverted\\n        opCounter.nextFinalize = minOpId;\\n        // Might be 0 when everything got finalized/reverted\\n        opCounter.nextRevert = maxOpId;\\n\\n        // Remove the last item\\n        opHandles.pop();\\n\\n        // Remove metadata\\n        delete opMetadata[_getOpKey(user, opHandle.opId)];\\n    }\\n\\n    function assertCanFinalize(\\n        OpMetadata memory metadata,\\n        IOptIn.OptInStatus memory optInStatus\\n    ) public view returns (uint64) {\\n        // Now there are three valid scenarios remaining:\\n        //\\n        // - msg.sender is the original booster\\n        // - op is expired\\n        // - getBoosterAddress returns a different booster than the original booster\\n        //\\n        // In the second and third case, anyone can call finalize.\\n        address originalBooster = metadata.booster;\\n\\n        if (originalBooster == msg.sender) {\\n            return metadata.createdAt; // First case\\n        }\\n\\n        address currentBooster = optInStatus.optedInTo;\\n        uint256 optOutPeriod = optInStatus.optOutPeriod;\\n\\n        bool isExpired = block.timestamp >= metadata.createdAt + optOutPeriod;\\n        if (isExpired) {\\n            return metadata.createdAt; // Second case\\n        }\\n\\n        if (currentBooster != originalBooster) {\\n            return metadata.createdAt; // Third case\\n        }\\n\\n        revert(\\\"PB-4\\\");\\n    }\\n\\n    function verifySignatureForRevert(\\n        address user,\\n        uint64 opTimestamp,\\n        IOptIn.OptInStatus memory optInStatus,\\n        bytes memory boosterMessage,\\n        address[] memory hasherContracts,\\n        Signature memory signature\\n    ) public {\\n        require(hasherContracts.length > 0, \\\"PB-12\\\");\\n\\n        // Result of hasher contract call\\n        uint64 signedAt;\\n        bytes32 boosterHash;\\n        bool signatureVerified;\\n\\n        for (uint256 i = 0; i < hasherContracts.length; i++) {\\n            // Call into the hasher contract and take the first non-zero result.\\n            // The contract must implement the following function:\\n            //\\n            // decodeAndHashBoosterMessage(\\n            //     address targetBooster,\\n            //     bytes memory boosterMessage\\n            // )\\n            //\\n            // If it doesn't, then the call will fail (success=false) and we try the next one.\\n            // If it succeeds (success = true), then we try to decode the result.\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, bytes memory result) = address(hasherContracts[i])\\n                .call(\\n                // keccak256(\\\"decodeAndHashBoosterMessage(address,bytes)\\\")\\n                abi.encodeWithSelector(\\n                    0xaf6eec54,\\n                    msg.sender, /* msg.sender becomes the target booster */\\n                    boosterMessage\\n                )\\n            );\\n\\n            if (!success) {\\n                continue;\\n            }\\n\\n            // The result is exactly 2 words long = 512 bits = 64 bytes\\n            // 32 bytes for the expected message hash\\n            // 8 bytes (padded to 32 bytes) for the expected timestamp\\n            if (result.length != 64) {\\n                continue;\\n            }\\n\\n            // NOTE: A contract with malintent could return any hash that we would\\n            // try to recover against. But there is no harm done in doing so since\\n            // the user must have signed it.\\n            //\\n            // However, it might return an unrelated timestamp, that the user hasn't\\n            // signed - so it could prolong the expiry of a signature which is a valid\\n            // concern whose risk we minimize by using also the op timestamp which guarantees\\n            // that a signature eventually expires.\\n\\n            // Decode and recover signer\\n            (boosterHash, signedAt) = abi.decode(result, (bytes32, uint64));\\n            address signer = ecrecover(\\n                boosterHash,\\n                signature.v,\\n                signature.r,\\n                signature.s\\n            );\\n\\n            if (user != signer) {\\n                // NOTE: Currently, hardware wallets (e.g. Ledger, Trezor) do not support EIP712 signing (specifically `signTypedData_v4`).\\n                // However, a user can still sign the EIP712 hash with the caveat that it's signed using `personal_sign` which prepends\\n                // the prefix '\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)'.\\n                //\\n                // To still support that, we also add the prefix and try to use the recovered address instead:\\n                signer = ecrecover(\\n                    boosterHash.toEthSignedMessageHash(),\\n                    signature.v,\\n                    signature.r,\\n                    signature.s\\n                );\\n            }\\n\\n            // If we recovered `user` from the signature, then we have a valid signature.\\n            if (user == signer) {\\n                signatureVerified = true;\\n                break;\\n            }\\n\\n            // Keep trying\\n        }\\n\\n        // Revert if signature couldn't be verified with any of the returned hashes\\n        require(signatureVerified, \\\"PB-8\\\");\\n\\n        // Lastly, the current time must not be older than:\\n        // MIN(opTimestamp, signedAt) + optOutPeriod * 3\\n        uint64 _now = uint64(block.timestamp);\\n        // The maximum age is equal to whichever is lowest:\\n        //      opTimestamp + optOutPeriod * 3\\n        //      signedAt + optOutPeriod * 3\\n        uint64 maximumAge;\\n        if (opTimestamp > signedAt) {\\n            maximumAge = signedAt + uint64(optInStatus.optOutPeriod * 3);\\n        } else {\\n            maximumAge = opTimestamp + uint64(optInStatus.optOutPeriod * 3);\\n        }\\n\\n        require(_now <= maximumAge, \\\"PB-11\\\");\\n    }\\n\\n    function _getOpKey(address user, uint64 opId)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(user, opId));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IHodl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IHodl {\\n    /**\\n     * @dev Lock the given amount of PRPS for the specified period (or infinitely)\\n     * for DUBI.\\n     */\\n    function hodl(\\n        uint24 id,\\n        uint96 amountPrps,\\n        uint16 duration,\\n        address dubiBeneficiary,\\n        address prpsBeneficiary\\n    ) external;\\n\\n    /**\\n     * @dev Release a hodl of `prpsBeneficiary` with the given `creator` and `id`.\\n     */\\n    function release(\\n        uint24 id,\\n        address prpsBeneficiary,\\n        address creator\\n    ) external;\\n\\n    /**\\n     * @dev Withdraw can be used to withdraw DUBI from infinitely locked PRPS.\\n     * The amount of DUBI withdrawn depends on the time passed since the last withdrawal.\\n     */\\n    function withdraw(\\n        uint24 id,\\n        address prpsBeneficiary,\\n        address creator\\n    ) external;\\n\\n    /**\\n     * @dev Burn `amount` of `from`'s locked and/or pending PRPS.\\n     *\\n     * This function is supposed to be only called by the PRPS contract.\\n     *\\n     * Returns the amount of DUBI that needs to be minted.\\n     */\\n    function burnLockedPrps(\\n        address from,\\n        uint96 amount,\\n        uint32 dubiMintTimestamp,\\n        bool burnPendingLockedPrps\\n    ) external returns (uint96);\\n\\n    /**\\n     * @dev Set `amount` of `from`'s locked PRPS to pending.\\n     *\\n     * This function is supposed to be only called by the PRPS contract.\\n     *\\n     * Returns the amount of locked PRPS that could be set to pending.\\n     */\\n    function setLockedPrpsToPending(address from, uint96 amount) external;\\n\\n    /**\\n     * @dev Revert `amount` of `from`'s pending locked PRPS to not pending.\\n     *\\n     * This function is supposed to be only called by the PRPS contract and returns\\n     */\\n    function revertLockedPrpsSetToPending(address account, uint96 amount)\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/MintMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n// NOTE: we ignore leap-seconds etc.\\nlibrary MintMath {\\n    // The maximum number of seconds per month (365 * 24 * 60 * 60 / 12)\\n    uint32 public constant SECONDS_PER_MONTH = 2628000;\\n    // The maximum number of days PRPS can be finitely locked for\\n    uint16 public constant MAX_FINITE_LOCK_DURATION_DAYS = 365;\\n    // The maximum number of seconds PRPS can be finitely locked for\\n    uint32 public constant MAX_FINITE_LOCK_DURATION_SECONDS = uint32(\\n        MAX_FINITE_LOCK_DURATION_DAYS\\n    ) *\\n        24 *\\n        60 *\\n        60;\\n\\n    /**\\n     * @dev Calculates the DUBI to mint based on the given amount of PRPS and duration in days.\\n     * NOTE: We trust the caller to ensure that the duration between 1 and 365.\\n     */\\n    function calculateDubiToMintByDays(\\n        uint256 amountPrps,\\n        uint16 durationInDays\\n    ) internal pure returns (uint96) {\\n        uint32 durationInSeconds = uint32(durationInDays) * 24 * 60 * 60;\\n        return calculateDubiToMintBySeconds(amountPrps, durationInSeconds);\\n    }\\n\\n    /**\\n     * @dev Calculates the DUBI to mint based on the given amount of PRPS and duration in seconds.\\n     */\\n    function calculateDubiToMintBySeconds(\\n        uint256 amountPrps,\\n        uint32 durationInSeconds\\n    ) internal pure returns (uint96) {\\n        // NOTE: We do not use safe math for efficiency reasons\\n\\n        uint256 _percentage = percentage(\\n            durationInSeconds,\\n            MAX_FINITE_LOCK_DURATION_SECONDS,\\n            18 // precision in WEI, 10^18\\n        ) * 4; // A full lock grants 4%, so multiply by 4.\\n\\n        // Multiply PRPS by the percentage and then divide by the precision (=10^8)\\n        // from the previous step\\n        uint256 _dubiToMint = (amountPrps * _percentage) / (1 ether * 100); // multiply by 100, because we deal with percentages\\n\\n        // Assert that the calculated DUBI never overflows uint96\\n        assert(_dubiToMint < 2**96);\\n\\n        return uint96(_dubiToMint);\\n    }\\n\\n    function calculateDubiToMintMax(uint96 amount)\\n        internal\\n        pure\\n        returns (uint96)\\n    {\\n        return\\n            calculateDubiToMintBySeconds(\\n                amount,\\n                MAX_FINITE_LOCK_DURATION_SECONDS\\n            );\\n    }\\n\\n    function calculateMintDuration(uint32 _now, uint32 lastWithdrawal)\\n        internal\\n        pure\\n        returns (uint32)\\n    {\\n        require(lastWithdrawal > 0 && lastWithdrawal <= _now, \\\"MINT-1\\\");\\n\\n        // NOTE: we don't use any safe math here for efficiency reasons. The assert above\\n        // is already a pretty good guarantee that nothing goes wrong. Also, all numbers involved\\n        // are very well smaller than uint256 in the first place.\\n        uint256 _elapsedTotal = _now - lastWithdrawal;\\n        uint256 _proRatedYears = _elapsedTotal / SECONDS_PER_MONTH / 12;\\n        uint256 _elapsedInYear = _elapsedTotal %\\n            MAX_FINITE_LOCK_DURATION_SECONDS;\\n\\n        //\\n        // Examples (using months instead of seconds):\\n        // calculation formula: (monthsSinceWithdrawal % 12) + (_proRatedYears * 12)\\n\\n        // 1) Burn after 11 months since last withdrawal (number of years = 11 / 12 + 1 = 1)\\n        // => (11 % 12) + (years * 12) => 23 months worth of DUBI\\n        // => 23 months\\n\\n        // 1) Burn after 4 months since last withdrawal (number of years = 4 / 12 + 1 = 1)\\n        // => (4 % 12) + (years * 12) => 16 months worth of DUBI\\n        // => 16 months\\n\\n        // 2) Burn 0 months after withdrawal after 4 months (number of years = 0 / 12 + 1 = 1):\\n        // => (0 % 12) + (years * 12) => 12 months worth of DUBI (+ 4 months worth of withdrawn DUBI)\\n        // => 16 months\\n\\n        // 3) Burn after 36 months since last withdrawal (number of years = 36 / 12 + 1 = 4)\\n        // => (36 % 12) + (years * 12) => 48 months worth of DUBI\\n        // => 48 months\\n\\n        // 4) Burn 1 month after withdrawal after 35 months (number of years = 1 / 12 + 1 = 1):\\n        // => (1 % 12) + (years * 12) => 12 month worth of DUBI (+ 35 months worth of withdrawn DUBI)\\n        // => 47 months\\n        uint32 _mintDuration = uint32(\\n            _elapsedInYear + _proRatedYears * MAX_FINITE_LOCK_DURATION_SECONDS\\n        );\\n\\n        return _mintDuration;\\n    }\\n\\n    function percentage(\\n        uint256 numerator,\\n        uint256 denominator,\\n        uint256 precision\\n    ) internal pure returns (uint256) {\\n        return\\n            ((numerator * (uint256(10)**(precision + 1))) / denominator + 5) /\\n            uint256(10);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/ProtectedBoostableLib.sol\": {\r\n        \"ProtectedBoostableLib\": \"0x85ae45a05971170b70744292e2f051c0c49cf909\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"optIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"purpose\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"hodl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"externalAddress1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"externalAddress2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"externalAddress3\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAndFuel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"opId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"opType\",\"type\":\"uint8\"}],\"name\":\"FinalizedOp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"opId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"opType\",\"type\":\"uint8\"}],\"name\":\"PendingOp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"opId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"opType\",\"type\":\"uint8\"}],\"name\":\"RevertedOp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"tag\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint96\",\"name\":\"dubi\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"unlockedPrps\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"lockedPrps\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"intrinsicFuel\",\"type\":\"uint96\"}],\"internalType\":\"struct BoosterFuel\",\"name\":\"fuel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"booster\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isLegacySignature\",\"type\":\"bool\"}],\"internalType\":\"struct BoosterPayload\",\"name\":\"boosterPayload\",\"type\":\"tuple\"}],\"internalType\":\"struct BoostableERC20.BoostedBurn\",\"name\":\"message\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"boostedBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"tag\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint96\",\"name\":\"dubi\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"unlockedPrps\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"lockedPrps\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"intrinsicFuel\",\"type\":\"uint96\"}],\"internalType\":\"struct BoosterFuel\",\"name\":\"fuel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"booster\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isLegacySignature\",\"type\":\"bool\"}],\"internalType\":\"struct BoosterPayload\",\"name\":\"boosterPayload\",\"type\":\"tuple\"}],\"internalType\":\"struct BoostableERC20.BoostedBurn[]\",\"name\":\"burns\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Signature[]\",\"name\":\"signatures\",\"type\":\"tuple[]\"}],\"name\":\"boostedBurnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"tag\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint96\",\"name\":\"dubi\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"unlockedPrps\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"lockedPrps\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"intrinsicFuel\",\"type\":\"uint96\"}],\"internalType\":\"struct BoosterFuel\",\"name\":\"fuel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"booster\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isLegacySignature\",\"type\":\"bool\"}],\"internalType\":\"struct BoosterPayload\",\"name\":\"boosterPayload\",\"type\":\"tuple\"}],\"internalType\":\"struct BoostableERC20.BoostedSend\",\"name\":\"send\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"boostedSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"tag\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint96\",\"name\":\"dubi\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"unlockedPrps\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"lockedPrps\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"intrinsicFuel\",\"type\":\"uint96\"}],\"internalType\":\"struct BoosterFuel\",\"name\":\"fuel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"booster\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isLegacySignature\",\"type\":\"bool\"}],\"internalType\":\"struct BoosterPayload\",\"name\":\"boosterPayload\",\"type\":\"tuple\"}],\"internalType\":\"struct BoostableERC20.BoostedSend[]\",\"name\":\"sends\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Signature[]\",\"name\":\"signatures\",\"type\":\"tuple[]\"}],\"name\":\"boostedSendBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"boostedTransferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"tokenAlias\",\"type\":\"uint8\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"internalType\":\"struct TokenFuel\",\"name\":\"fuel\",\"type\":\"tuple\"}],\"name\":\"burnFuel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetBooster\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"boosterMessage\",\"type\":\"bytes\"}],\"name\":\"decodeAndHashBoosterMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"opType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"opId\",\"type\":\"uint64\"}],\"internalType\":\"struct OpHandle\",\"name\":\"opHandle\",\"type\":\"tuple\"}],\"name\":\"finalizePendingOp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getOpCounter\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"value\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nextFinalize\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nextRevert\",\"type\":\"uint64\"}],\"internalType\":\"struct OpCounter\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"opId\",\"type\":\"uint64\"}],\"name\":\"getOpMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"opType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"createdAt\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"booster\",\"type\":\"address\"}],\"internalType\":\"struct OpMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"hodlMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purposeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"opType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"opId\",\"type\":\"uint64\"}],\"internalType\":\"struct OpHandle\",\"name\":\"opHandle\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"boosterMessage\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"revertPendingOp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"opType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"opId\",\"type\":\"uint64\"}],\"internalType\":\"struct OpHandle\",\"name\":\"opHandle\",\"type\":\"tuple\"}],\"name\":\"safeGetOpMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"opType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"createdAt\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"booster\",\"type\":\"address\"}],\"internalType\":\"struct OpMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"unpackedDataOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"hodlBalance\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct ERC20.UnpackedData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Dubi","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a916bc21d2429645585abede4ae00742a16dd1c6000000000000000000000000b628bc994e39ce264eca6f6ee1620909816a9f12000000000000000000000000ac0122e9258a85ba5479db764dc8ef91cab08db00000000000000000000000003b4da358199060bcc5a527ab60099fb6a908aae9000000000000000000000000025dbd03ed18b4b8425af51b4d05f5b00e78208a000000000000000000000000e7cd2797ac6f08b5721c7e7fcc991251df5e3884","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}