{"status":"1","message":"OK","result":[{"SourceCode":"{\"company_token.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./token.sol\\\";\\n\\ncontract CompanyToken is Token {\\n  using SafeMath for uint256;\\n\\n  /**\\n   * Company name.\\n   */\\n  string internal companyName;\\n\\n  /**\\n   * Company country.\\n   */\\n  string internal companyCountry;\\n\\n  /**\\n   * Company legal form.\\n   */\\n  string internal companyLegalForm;\\n  \\n  /**\\n   * @dev Returns the Company Name.\\n   */\\n  function CompanyName() external view returns (string _name) { _name = companyName; }\\n\\n  /**\\n   * @dev Returns the Company Country.\\n   */\\n  function CompanyCountry() external view returns (string _country) { _country = companyCountry; }\\n\\n  /**\\n   * @dev Returns the Company legal form.\\n   */\\n  function LegalForm() external view returns (string _legal_form) { _legal_form = companyLegalForm; }\\n\\n}\\n\\ncontract NeroHoldingSharesToken is CompanyToken {\\n  constructor() public {\\n    /* Token informations */\\n    tokenName = \\\"Nero Holding GbR - Company Shares\\\";\\n    tokenSymbol = \\\"NHGCS\\\";\\n    tokenDecimals = 0;\\n    /* Holder transactions */\\n    balances[address(0xB867B21547F3D7FC551AA49c4B3d5A0aa1163991)] = 1000;\\n    balances[address(0xD75ae9308DF8734A8EF8AaDDa9b9aD395c1Eb3f4)] = 1000;\\n    balances[address(0x56d5Cf926f59086921e2A818FEf5d62f4647220e)] = 1000;\\n    tokenTotalSupply = 3000;\\n    /* Company informations */\\n    companyName = \\\"Nero Holding\\\";\\n    companyCountry = \\\"Germany\\\";\\n    companyLegalForm = \\\"GbR\\\";\\n  }\\n}\"},\"erc20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title A standard interface for tokens.\\n */\\ninterface ERC20 {\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name()\\n    external\\n    view\\n    returns (string _name);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol()\\n    external\\n    view\\n    returns (string _symbol);\\n\\n  /**\\n   * @dev Returns the number of decimals the token uses.\\n   */\\n  function decimals()\\n    external\\n    view\\n    returns (uint8 _decimals);\\n\\n  /**\\n   * @dev Returns the total token supply.\\n   */\\n  function totalSupply()\\n    external\\n    view\\n    returns (uint256 _totalSupply);\\n\\n  /**\\n   * @dev Returns the account balance of another account with address _owner.\\n   * @param _owner The address from which the balance will be retrieved.\\n   */\\n  function balanceOf(\\n    address _owner\\n  )\\n    external\\n    view\\n    returns (uint256 _balance);\\n\\n  /**\\n   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\\n   * @param _to The address of the recipient.\\n   * @param _value The amount of token to be transferred.\\n   */\\n  function transfer(\\n    address _to,\\n    uint256 _value\\n  )\\n    external\\n    returns (bool _success);\\n\\n  /**\\n   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\\n   * Transfer event.\\n   * @param _from The address of the sender.\\n   * @param _to The address of the recipient.\\n   * @param _value The amount of token to be transferred.\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  )\\n    external\\n    returns (bool _success);\\n\\n  /**\\n   * @dev Allows _spender to withdraw from your account multiple times, up to\\n   * the _value amount. If this function is called again it overwrites the current\\n   * allowance with _value.\\n   * @param _spender The address of the account able to transfer the tokens.\\n   * @param _value The amount of tokens to be approved for transfer.\\n   */\\n  function approve(\\n    address _spender,\\n    uint256 _value\\n  )\\n    external\\n    returns (bool _success);\\n\\n  /**\\n   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\\n   * @param _owner The address of the account owning tokens.\\n   * @param _spender The address of the account able to transfer the tokens.\\n   */\\n  function allowance(\\n    address _owner,\\n    address _spender\\n  )\\n    external\\n    view\\n    returns (uint256 _remaining);\\n\\n  /**\\n   * @dev Triggers when tokens are transferred, including zero value transfers.\\n   */\\n  event Transfer(\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 _value\\n  );\\n\\n  /**\\n   * @dev Triggers on any successful call to approve(address _spender, uint256 _value).\\n   */\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _spender,\\n    uint256 _value\\n  );\\n\\n}\\n\"},\"safemath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"},\"token.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./safemath.sol\\\";\\nimport \\\"./erc20.sol\\\";\\n\\n/**\\n * @title ERC20 standard token implementation.\\n * @dev Standard ERC20 token. This contract follows the implementation at https://goo.gl/mLbAPJ.\\n */\\ncontract Token is ERC20 {\\n  using SafeMath for uint256;\\n\\n  /**\\n   * Token name.\\n   */\\n  string internal tokenName;\\n\\n  /**\\n   * Token symbol.\\n   */\\n  string internal tokenSymbol;\\n\\n  /**\\n   * Number of decimals.\\n   */\\n  uint8 internal tokenDecimals;\\n\\n  /**\\n   * Total supply of tokens.\\n   */\\n  uint256 internal tokenTotalSupply;\\n\\n  /**\\n   * Balance information map.\\n   */\\n  mapping (address =\\u003e uint256) internal balances;\\n\\n  /**\\n   * Token allowance mapping.\\n   */\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\n\\n  /**\\n   * @dev Trigger when tokens are transferred, including zero value transfers.\\n   */\\n  event Transfer(address indexed _from,address indexed _to,uint256 _value);\\n\\n  /**\\n   * @dev Trigger on any successful call to approve(address _spender, uint256 _value).\\n   */\\n  event Approval(address indexed _owner,address indexed _spender,uint256 _value);\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string _name) {\\n    _name = tokenName;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string _symbol) {\\n    _symbol = tokenSymbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals the token uses.\\n   */\\n  function decimals() external view returns (uint8 _decimals) {\\n    _decimals = tokenDecimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total token supply.\\n   */\\n  function totalSupply() external view returns (uint256 _totalSupply) {\\n    _totalSupply = tokenTotalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the account balance of another account with address _owner.\\n   * @param _owner The address from which the balance will be retrieved.\\n   */\\n  function balanceOf( address _owner )external view returns (uint256 _balance) {\\n    _balance = balances[_owner];\\n  }\\n\\n  /**\\n   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\\n   * @param _to The address of the recipient.\\n   * @param _value The amount of token to be transferred.\\n   */\\n  function transfer( address _to, uint256 _value ) public returns (bool _success) {\\n    require(_to != address(0x000000000000000000000000000000000000dEaD));\\n    require(_value \\u003e= 1);\\n    require(_value \\u003c= balances[msg.sender]);\\n\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n\\n    emit Transfer(msg.sender, _to, _value);\\n    _success = true;\\n  }\\n\\n  /**\\n   * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. If\\n   * this function is called again it overwrites the current allowance with _value.\\n   * @param _spender The address of the account able to transfer the tokens.\\n   * @param _value The amount of tokens to be approved for transfer.\\n   */\\n  function approve( address _spender, uint256 _value ) public returns (bool _success) {\\n    require(_spender != address(0x000000000000000000000000000000000000dEaD));\\n    require(_value \\u003e= 1);\\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\\n\\n    allowed[msg.sender][_spender] = _value;\\n\\n    emit Approval(msg.sender, _spender, _value);\\n    _success = true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\\n   * @param _owner The address of the account owning tokens.\\n   * @param _spender The address of the account able to transfer the tokens.\\n   */\\n  function allowance(address _owner,address _spender) external view  returns (uint256 _remaining) {\\n    _remaining = allowed[_owner][_spender];\\n  }\\n\\n  /**\\n   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\\n   * Transfer event.\\n   * @param _from The address of the sender.\\n   * @param _to The address of the recipient.\\n   * @param _value The amount of token to be transferred.\\n   */\\n  function transferFrom( address _from, address _to, uint256 _value ) public returns (bool _success) {\\n    require(_to != address(0x000000000000000000000000000000000000dEaD));\\n    require(_value \\u003e= 1);\\n    require(_value \\u003c= balances[_from]);\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n    balances[_from] = balances[_from].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n\\n    emit Transfer(_from, _to, _value);\\n    _success = true;\\n  }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CompanyName\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LegalForm\",\"outputs\":[{\"name\":\"_legal_form\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CompanyCountry\",\"outputs\":[{\"name\":\"_country\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"_remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"NeroHoldingSharesToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://62bf7c88704dcbf547d0ed3bc155c7fc1f3970a25d0a6fefe5566ff39a4bd820"}]}