{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.1;\r\n\r\ncontract NIOX {\r\n    uint256 public peopleCount = 0;\r\n    \r\n    mapping(address => Person ) public people;\r\n    \r\n    uint256 constant stage11 = 1584016200; // ---- Thursday, March 12, 2020 6:00:00 PM GMT+05:30\r\n    uint256 constant stage12 = 1591964999; // ---- Friday, June 12, 2020 5:59:59 PM GMT+05:30\r\n    uint256 constant stage21 = 1591965000; // ---- Friday, June 12, 2020 6:00:00 PM GMT+05:30\r\n    uint256 constant stage22 = 1597235399; // ---- Wednesday, August 12, 2020 5:59:59 PM GMT+05:30\r\n    uint256 constant stage31 = 1597235400; // ---- Wednesday, August 12, 2020 6:00:00 PM GMT+05:30\r\n    uint256 constant stage32 = 1599913799; // ---- Saturday, September 12, 2020 5:59:59 PM GMT+05:30\r\n    \r\n    uint256 constant oneyear = 31556926; // 31556926 secs = 1 YEAR\r\n    \r\n    \r\n    uint256 constant sixmonth = 15778458; // 6 month\r\n   uint256 constant addAddressLastDate = 1609404905;// DEc 31, 2020 5:59:59 PM GMT+05:30\r\n   uint256 constant minStakeAmt = 3000000000;\r\n\r\n    \r\n    // Status of user's address that he has withdrew NIOX or staked or haven't decided yet\r\n    enum userState {Withdraw, Staked, NotDecided}\r\n    \r\n    // Status of user's address after claiming their tokens\r\n    enum withdrawState {NotWithdraw, PartiallyWithdraw, FullyWithdraw}\r\n    \r\n    //users remaining claimed tokens\r\n    enum remainToken {stage0, stage1, stage2, stage3, stage4}\r\n    \r\n    // Token name\r\n    string public constant name = \"AutonioK\";\r\n\r\n    // Token symbol\r\n    string public constant symbol = \"NIOXK\";\r\n\r\n\t// Token decimals\r\n    uint8 public constant decimals = 4;\r\n    \r\n    // Contract owner will be your Link account\r\n    address public owner;\r\n\r\n    address public treasury;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    mapping (address => uint256) private balances;\r\n\r\n    event Approval(address indexed tokenholder, address indexed spender, uint256 value);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event AddedNewUser(address indexed, uint _value);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }   \r\n\r\n    modifier checkUser() {\r\n        require(msg.sender == people[msg.sender]._address);\r\n        _;\r\n    }\r\n\r\n    struct Person {\r\n        uint _id;\r\n        address _address;\r\n        uint256 _value;\r\n        uint256 _txHashAddress;\r\n        userState _userState;\r\n        withdrawState _withdrawState;\r\n        remainToken _remainToken;\r\n        uint256 _blocktimestamp;\r\n        uint256 _userStateBlocktimestamp;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n\r\n        // Add your wallet address here which will contain your total token supply\r\n        treasury = owner;\r\n\r\n        // Set your total token supply (default 1000)\r\n        totalSupply = 3000000000000;\r\n\r\n        balances[treasury] = totalSupply;\r\n        emit Transfer(address(0), treasury, totalSupply);\r\n    }\r\n\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    function allowance(address _tokenholder, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_tokenholder][_spender];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(_spender != address(0));\r\n        require(_spender != msg.sender);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _tokenholder) public view returns (uint256 balance) {\r\n        return balances[_tokenholder];\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\r\n        require(_spender != address(0));\r\n        require(_spender != msg.sender);\r\n\r\n        if (allowed[msg.sender][_spender] <= _subtractedValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = allowed[msg.sender][_spender] - _subtractedValue;\r\n        }\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\r\n        require(_spender != address(0));\r\n        require(_spender != msg.sender);\r\n        require(allowed[msg.sender][_spender] <= allowed[msg.sender][_spender] + _addedValue);\r\n\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != msg.sender);\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(balances[msg.sender] - _value <= balances[msg.sender]);\r\n        require(balances[_to] <= balances[_to] + _value);\r\n        require(_value <= transferableTokens(msg.sender));\r\n\r\n        balances[msg.sender] = balances[msg.sender] - _value;\r\n        balances[_to] = balances[_to] + _value;\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_from != address(0));\r\n        require(_from != address(this));\r\n        require(_to != _from);\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_value <= transferableTokens(_from));\r\n        require(allowed[_from][msg.sender] - _value <= allowed[_from][msg.sender]);\r\n        require(balances[_from] - _value <= balances[_from]);\r\n        require(balances[_to] <= balances[_to] + _value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\r\n        balances[_from] = balances[_from] - _value;\r\n        balances[_to] = balances[_to] + _value;\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public {\r\n        require(msg.sender == owner);\r\n        require(_newOwner != address(0));\r\n        require(_newOwner != address(this));\r\n        require(_newOwner != owner);\r\n\r\n        address previousOwner = owner;\r\n        owner = _newOwner;\r\n\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function transferableTokens(address holder) public view returns (uint256) {\r\n        return balanceOf(holder);\r\n    }\r\n    \r\n    function addAddress(address _useraddress, uint256 _value, uint256 _txHashAddress, userState _userState, withdrawState _withdrawState, remainToken _remainToken) public onlyOwner {\r\n        \r\n        require(people[_useraddress]._address != _useraddress);\r\n        require(block.timestamp <= addAddressLastDate);\r\n        \r\n        incrementCount();\r\n        people[_useraddress] = Person(peopleCount, _useraddress, _value, _txHashAddress, _userState, _withdrawState, _remainToken, block.timestamp, 0);\r\n    }\r\n    \r\n    function incrementCount() internal {\r\n        peopleCount += 1;\r\n    }\r\n    \r\n    function getRemainTokenCount(address  _address) public view returns (uint256 tokens) {\r\n        \r\n        require(_address == people[_address]._address);\r\n        \r\n        if(people[_address]._remainToken == remainToken.stage0) {\r\n            \r\n            return people[_address]._value;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage1) {\r\n            \r\n            return people[_address]._value / 100 * 50;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage2) {\r\n            \r\n            return people[_address]._value / 100 * 30;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage3) {\r\n            \r\n            return people[_address]._value / 100 * 20;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage4) {\r\n            \r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    function getWithdrawTokenCount(address  _address) public view returns (uint256 tokens) {\r\n        \r\n        require(_address == people[_address]._address);\r\n        \r\n        if(people[_address]._remainToken == remainToken.stage0) {\r\n            \r\n            return 0;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage1) {\r\n            \r\n            return people[_address]._value / 100 * 50;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage2) {\r\n            \r\n            return people[_address]._value / 100 * 70;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage3) {\r\n            \r\n            return people[_address]._value / 100 * 80;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage4) {\r\n            \r\n            return people[_address]._value;\r\n        }\r\n    }\r\n    \r\n    function getUserState(address _address) public view returns (userState){\r\n        \r\n        require(_address == people[_address]._address);\r\n        \r\n        return people[_address]._userState;\r\n    }\r\n    \r\n    function withdrawOrStake(userState _userStates) public returns (bool) {\r\n        \r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(people[msg.sender]._userState == userState.NotDecided);\r\n        require(people[msg.sender]._userStateBlocktimestamp == 0);\r\n        \r\n        if(people[msg.sender]._userState == userState.NotDecided && _userStates == userState.Withdraw){\r\n            people[msg.sender]._userState = userState.Withdraw;\r\n            people[msg.sender]._userStateBlocktimestamp = block.timestamp;\r\n            return true;\r\n        }\r\n        else if(people[msg.sender]._userState == userState.NotDecided && _userStates == userState.Staked && people[msg.sender]._value >= minStakeAmt ){\r\n            people[msg.sender]._userState = userState.Staked;\r\n            people[msg.sender]._userStateBlocktimestamp = block.timestamp;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n        \r\n    }\r\n    \r\n    function changeStakeToWithdraw() public checkUser returns (bool) {\r\n        \r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(people[msg.sender]._userState == userState.Staked);\r\n        require(people[msg.sender]._userStateBlocktimestamp != 0);\r\n        require(block.timestamp >= (people[msg.sender]._userStateBlocktimestamp + sixmonth));\r\n        \r\n        if(people[msg.sender]._userState == userState.Staked){\r\n            people[msg.sender]._userState = userState.Withdraw;\r\n            // people[msg.sender]._blocktimestamp = block.timestamp;\r\n            return true;\r\n        }\r\n        \r\n    }\r\n    \r\n    function withdrawToken() public checkUser returns (bool){\r\n        \r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(people[msg.sender]._userState == userState.Withdraw);\r\n        require(people[msg.sender]._userStateBlocktimestamp != 0);\r\n        require(people[msg.sender]._withdrawState == withdrawState.NotWithdraw);\r\n        require(people[msg.sender]._remainToken == remainToken.stage0);\r\n        \r\n        if (block.timestamp >= stage11 && block.timestamp <= stage12 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 50; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage1;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > stage21 && block.timestamp <= stage22 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 70; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage2;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > stage31 && block.timestamp <= stage32 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 80; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage3;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > stage32){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function withdrawRemainPenaltyToken() public checkUser returns (bool){\r\n        \r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(people[msg.sender]._userState == userState.Withdraw);\r\n        require(people[msg.sender]._withdrawState == withdrawState.PartiallyWithdraw);\r\n        require(block.timestamp >= people[msg.sender]._blocktimestamp + oneyear);\r\n        \r\n        if (people[msg.sender]._remainToken == remainToken.stage1){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 50; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            \r\n            return true;\r\n        }\r\n        else if (people[msg.sender]._remainToken == remainToken.stage2){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 30; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            \r\n            return true;\r\n        }\r\n        else if (people[msg.sender]._remainToken == remainToken.stage3){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 20; \r\n             require(owner != msg.sender);\r\n             require(balances[owner] - clamimTkn <= balances[owner]);\r\n             require(balances[msg.sender] <= balances[msg.sender] + clamimTkn);\r\n             require(clamimTkn <= transferableTokens(owner));\r\n        \r\n            balances[owner] = balances[owner] - clamimTkn;\r\n            balances[msg.sender] = balances[msg.sender] + clamimTkn;\r\n    \r\n            emit Transfer(owner, msg.sender, clamimTkn);\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            \r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function remainPenaltyClaimDate(address  _address) public view returns (uint256 date) {\r\n        \r\n         require(_address == people[_address]._address);\r\n         require(people[_address]._withdrawState == withdrawState.PartiallyWithdraw);\r\n         require(people[_address]._userState == userState.Withdraw);\r\n         \r\n         return people[_address]._blocktimestamp + oneyear;\r\n        \r\n    }\r\n}\r\ncontract Token {\r\n    function totalSupply() external view returns (uint256 _totalSupply){}\r\n    function balanceOf(address _owner) external view returns (uint256 _balance){}\r\n    function transfer(address _to, uint256 _value) external returns (bool _success){}\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool _success){}\r\n    function approve(address _spender, uint256 _value) external returns (bool _success){}\r\n    function allowance(address _owner, address _spender) external view returns (uint256 _remaining){}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Staking {\r\n    \r\n    uint256 public peopleCount = 0;\r\n    \r\n    mapping(address => Person ) public people;\r\n    \r\n    mapping(address => BlockUser ) public blockpeople;\r\n    \r\n    // for new users\r\n    uint256 constant stage11 = 1597708801; // ---- Tuesday, August 18, 2020 12:00:01 AM\r\n    uint256 constant stage12 = 1605657600; // ---- Wednesday, November 18, 2020 12:00:00 AM\r\n    uint256 constant stage21 = 1605657601; // ---- Wednesday, November 18, 2020 12:00:01 AM\r\n    uint256 constant stage22 = 1610928000; // ---- Monday, January 18, 2021 12:00:00 AM\r\n    uint256 constant stage31 = 1610928001; // ---- Monday, January 18, 2021 12:00:01 AM\r\n    uint256 constant stage32 = 1613606400; // ---- Thursday, February 18, 2021 12:00:00 AM\r\n    \r\n    \r\n    //for old users\r\n    uint256 constant ostage11 = 1584016200; // ---- Thursday, March 12, 2020 6:00:00 PM GMT+05:30\r\n    uint256 constant ostage12 = 1591964999; // ---- Friday, June 12, 2020 5:59:59 PM GMT+05:30\r\n    uint256 constant ostage21 = 1591965000; // ---- Friday, June 12, 2020 6:00:00 PM GMT+05:30\r\n    uint256 constant ostage22 = 1597235399; // ---- Wednesday, August 12, 2020 5:59:59 PM GMT+05:30\r\n    uint256 constant ostage31 = 1597235400; // ---- Wednesday, August 12, 2020 6:00:00 PM GMT+05:30\r\n    uint256 constant ostage32 = 1599913799; // ---- Saturday, September 12, 2020 5:59:59 PM GMT+05:30\r\n    \r\n    uint256 constant oneyear = 31556926; // 31556926 secs = 1 YEAR\r\n    \r\n    \r\n    uint256 constant sixmonth = 15778458; // 6 month\r\n    uint256 constant day21 = 1814400; // 21 days /3 weeks;\r\n    \r\n    uint256 constant minStakeAmt = 3000000000;\r\n\r\n    \r\n    // Status of user's address that he has withdrew NIOX or staked or haven't decided yet\r\n    enum userState {Withdraw, Staked, NotDecided}\r\n    userState UserState;\r\n    \r\n    // Status of user's address after claiming their tokens\r\n    enum withdrawState {NotWithdraw, PartiallyWithdraw, FullyWithdraw}\r\n    \r\n    //users remaining claimed tokens\r\n    enum remainToken {stage0, stage1, stage2, stage3, stage4}\r\n    \r\n\r\n    NIOX token;\r\n    \r\n    NIOX Ntoken;\r\n    \r\n    address public owner;\r\n\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    mapping (address => uint256) private balances;\r\n\r\n    event Approval(address indexed tokenholder, address indexed spender, uint256 value);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event AddedNewUser(address indexed, uint _value);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner,\"You are not Authorize to call this function\");\r\n        _;\r\n    }   \r\n\r\n    modifier checkUser() {\r\n        require(msg.sender == people[msg.sender]._address);\r\n        _;\r\n    }\r\n\r\n    struct stakeData{\r\n        uint256 id;\r\n        uint256 amt; \r\n        uint256 _stakeTimeStamp;\r\n        uint256 _withdrawTimestamp;\r\n        uint256 _withdrawOrNotyet;\r\n    }\r\n\r\n    struct Person {\r\n        uint _id;\r\n        address _address;\r\n        uint256 _value;\r\n        uint256 _txHashAddress;\r\n        userState _userState;\r\n        withdrawState _withdrawState;\r\n        remainToken _remainToken;\r\n        uint256 _blocktimestamp;\r\n        uint256 _userStateBlocktimestamp;\r\n        uint256 _stakeCounter; \r\n        uint256 _withdrawTimestamp;\r\n        mapping(uint256 => stakeData) stakeStruct; \r\n    }\r\n    \r\n    struct BlockUser {\r\n        address _address;\r\n    }\r\n\r\n   \r\n    constructor() public {\r\n        owner = msg.sender;\r\n    \r\n        token = NIOX(0x9cEc335cf6922eeb5A563C871D1F09f2cf264230); // old niox token\r\n        \r\n        Ntoken = NIOX(0xc813EA5e3b48BEbeedb796ab42A30C5599b01740); // new niox token\r\n    }\r\n\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    function addAddressExisting() public {\r\n        \r\n        require(people[msg.sender]._address != msg.sender,\"You are already added\");\r\n        require(getPeopleAddress(msg.sender) == msg.sender,\"You are not addded to previous contract\");\r\n        \r\n        incrementCount();\r\n        \r\n        (,address addres,uint256 value,uint256 txhash,,,,uint256 bts,uint256 usbts) = token.people(msg.sender);\r\n        userState us = getUserStateData(msg.sender);\r\n        withdrawState ws = getWithdrawStateData(msg.sender);\r\n        remainToken rt = getRemainTokenData(msg.sender);\r\n       \r\n        people[msg.sender] = Person(peopleCount, addres, value, txhash,us,ws,rt,bts,usbts,0,0);\r\n        \r\n        if(us == Staking.userState.Staked){\r\n            Person storage t =  people[msg.sender];\r\n            people[msg.sender]._stakeCounter += 1;\r\n            t.stakeStruct[people[msg.sender]._stakeCounter] = stakeData(people[msg.sender]._stakeCounter ,value,usbts,0,0);\r\n            \r\n        }\r\n    }\r\n    \r\n    function addAddressNew(address _useraddress, uint256 _value, uint256 _txHashAddress, userState _userState, withdrawState _withdrawState, remainToken _remainToken) public onlyOwner {\r\n        \r\n        require(people[_useraddress]._address != _useraddress, \"You are already added\");\r\n        require(getPeopleAddress(_useraddress) != _useraddress, \"You are in previous contract try to add from addAddressExisting method\");\r\n        \r\n        incrementCount();\r\n        people[_useraddress] = Person(peopleCount, _useraddress, _value, _txHashAddress, _userState, _withdrawState, _remainToken, block.timestamp, 0,0,0);\r\n\r\n    }\r\n    \r\n    function blockuser(address _useraddress) public onlyOwner {\r\n        \r\n        require(blockpeople[_useraddress]._address != _useraddress, \"Already Blocked\");\r\n        \r\n        blockpeople[_useraddress] = BlockUser(_useraddress);\r\n        \r\n    }\r\n\r\n    function unblockuser(address _useraddress) public onlyOwner {\r\n        \r\n        require(blockpeople[_useraddress]._address == _useraddress, \"Already Blocked\");\r\n        \r\n        // blockpeople[_useraddress] = BlockUser();\r\n        delete blockpeople[_useraddress];\r\n        \r\n    }\r\n    \r\n    function chkUserInPreviousContract(address _useraddress) public view returns(bool){\r\n        \r\n        if(getPeopleAddress(_useraddress) == _useraddress){\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function stake(uint256 _amt) public {\r\n         \r\n         require(people[msg.sender]._address == msg.sender, \"You are not added\");\r\n         \r\n         Person storage t =  people[msg.sender]; \r\n        \r\n         if (people[msg.sender]._stakeCounter == 0 ){\r\n             \r\n             if(_amt >= minStakeAmt){\r\n                 // call approve manually\r\n                require(Ntoken.transferFrom((msg.sender),address(this), _amt));\r\n         \r\n                \r\n                 people[msg.sender]._stakeCounter += 1;\r\n                 t.stakeStruct[people[msg.sender]._stakeCounter] = stakeData(people[msg.sender]._stakeCounter, _amt, block.timestamp,0,0);\r\n                 people[msg.sender]._userState = userState.Staked;\r\n                 \r\n             }\r\n             else {\r\n                 revert();\r\n             }\r\n        \r\n         }\r\n         else if (people[msg.sender]._stakeCounter > 0 ){  // if not first then chk last unstake\r\n             \r\n             if(t.stakeStruct[people[msg.sender]._stakeCounter]._withdrawTimestamp == 0){\r\n                 // call approve manually\r\n                  require(Ntoken.transferFrom((msg.sender),address(this), _amt));\r\n                 \r\n                 people[msg.sender]._stakeCounter += 1;\r\n                 t.stakeStruct[people[msg.sender]._stakeCounter] = stakeData(people[msg.sender]._stakeCounter, _amt, block.timestamp,0,0);\r\n             \r\n             }\r\n             else if (t.stakeStruct[people[msg.sender]._stakeCounter]._withdrawTimestamp > 0){\r\n                 \r\n                 if(_amt >= minStakeAmt){\r\n                     // call approve manually\r\n                  require(Ntoken.transferFrom((msg.sender),address(this), _amt));\r\n         \r\n                \r\n                 people[msg.sender]._stakeCounter += 1;\r\n                 t.stakeStruct[people[msg.sender]._stakeCounter] = stakeData(people[msg.sender]._stakeCounter, _amt, block.timestamp,0,0);\r\n                 people[msg.sender]._userState = userState.Staked;\r\n                 \r\n                 }\r\n                 else {\r\n                     revert();\r\n                 }\r\n                 \r\n             }\r\n             \r\n         }\r\n         \r\n    }\r\n    \r\n    function stakeForOther(uint256 _amt, address _useraddress) public onlyOwner {\r\n         \r\n         require(people[_useraddress]._address == _useraddress, \"adress are not added\");\r\n         \r\n         Person storage t =  people[_useraddress]; \r\n        \r\n                 // call approve manually\r\n                 require(Ntoken.transferFrom(msg.sender,address(this), _amt));\r\n         \r\n                \r\n                 people[_useraddress]._stakeCounter += 1;\r\n                 t.stakeStruct[people[_useraddress]._stakeCounter] = stakeData(people[_useraddress]._stakeCounter, _amt, block.timestamp,0,0);\r\n                 people[_useraddress]._userState = userState.Staked;\r\n         \r\n    }\r\n\r\n    function totalStaked(address _useraddress) public view returns(uint256 _totalStakes) {\r\n           _totalStakes = 0;\r\n           Person storage t =  people[_useraddress];\r\n           for (uint256 s = 1; s <= people[_useraddress]._stakeCounter; s += 1){\r\n               if(t.stakeStruct[s]._withdrawTimestamp == 0){\r\n                   _totalStakes += t.stakeStruct[s].amt;\r\n               }\r\n               \r\n           }\r\n      \r\n      return _totalStakes;\r\n   }\r\n  \r\n    function getStakeTokenById(uint256 _tokenId, address _useraddress) public view returns(address, uint256, uint256,uint256, uint256) {\r\n      Person storage t =  people[_useraddress];\r\n      return (t._address, t.stakeStruct[_tokenId].amt,t.stakeStruct[_tokenId]._stakeTimeStamp ,t.stakeStruct[_tokenId]._withdrawTimestamp, t.stakeStruct[_tokenId]._withdrawOrNotyet);\r\n    }\r\n    \r\n    function getUserStateData(address _useraddress) internal view returns(userState){\r\n        (,,,,NIOX.userState us,,,,) = token.people(_useraddress);\r\n        if(us == NIOX.userState.NotDecided){\r\n        return Staking.userState.NotDecided;\r\n         }\r\n        else if(us == NIOX.userState.Withdraw){\r\n            return Staking.userState.Withdraw;\r\n        }\r\n        else if(us == NIOX.userState.Staked){\r\n            return Staking.userState.Staked;\r\n        }\r\n    }\r\n    \r\n    function getWithdrawStateData(address _useraddress) internal view returns(withdrawState){\r\n        (,,,,,NIOX.withdrawState ws,,,) = token.people(_useraddress);\r\n        if(ws == NIOX.withdrawState.NotWithdraw){\r\n        return Staking.withdrawState.NotWithdraw;\r\n         }\r\n        else if(ws == NIOX.withdrawState.PartiallyWithdraw){\r\n            return Staking.withdrawState.PartiallyWithdraw;\r\n        }\r\n        else if(ws == NIOX.withdrawState.FullyWithdraw){\r\n            return Staking.withdrawState.FullyWithdraw;\r\n        }\r\n    }\r\n    \r\n    function getRemainTokenData(address _useraddress) internal view returns(remainToken){\r\n        (,,,,,,NIOX.remainToken rt,,) = token.people(_useraddress);\r\n        if(rt == NIOX.remainToken.stage0){\r\n        return Staking.remainToken.stage0;\r\n         }\r\n        else if(rt == NIOX.remainToken.stage1){\r\n            return Staking.remainToken.stage1;\r\n        }\r\n        else if(rt == NIOX.remainToken.stage2){\r\n            return Staking.remainToken.stage2;\r\n        }\r\n        else if(rt == NIOX.remainToken.stage3){\r\n            return Staking.remainToken.stage3;\r\n        }\r\n        else if(rt == NIOX.remainToken.stage4){\r\n            return Staking.remainToken.stage4;\r\n        }\r\n    }\r\n    \r\n    function getUsbtsData(address _useraddress) internal view returns(uint256 usbts){\r\n        (,,,,,,,,uint256 _usbts) = token.people(_useraddress);\r\n        return _usbts;\r\n    }\r\n    \r\n    function getPeopleAddress(address _addr)  internal view returns (address _addres){\r\n            (,address _address,,,,,,,) = token.people(_addr);\r\n            return _address;\r\n    }\r\n    \r\n    function incrementCount() internal {\r\n        peopleCount += 1;\r\n    }\r\n    \r\n    function getRemainTokenCount(address  _address) public view returns (uint256 tokens) {\r\n        \r\n        require(_address == people[_address]._address);\r\n        \r\n        if(people[_address]._remainToken == remainToken.stage0) {\r\n            \r\n            return people[_address]._value;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage1) {\r\n            \r\n            return people[_address]._value / 100 * 50;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage2) {\r\n            \r\n            return people[_address]._value / 100 * 30;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage3) {\r\n            \r\n            return people[_address]._value / 100 * 20;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage4) {\r\n            \r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    function getWithdrawTokenCount(address  _address) public view returns (uint256 tokens) {\r\n        \r\n        require(_address == people[_address]._address);\r\n        \r\n        if(people[_address]._remainToken == remainToken.stage0) {\r\n            \r\n            return 0;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage1) {\r\n            \r\n            return people[_address]._value / 100 * 50;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage2) {\r\n            \r\n            return people[_address]._value / 100 * 70;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage3) {\r\n            \r\n            return people[_address]._value / 100 * 80;\r\n        }\r\n        \r\n        else if(people[_address]._remainToken == remainToken.stage4) {\r\n            \r\n            return people[_address]._value;\r\n        }\r\n    }\r\n    \r\n    function getUserState(address _address) public view returns (userState){\r\n        \r\n        require(_address == people[_address]._address);\r\n        \r\n        return people[_address]._userState;\r\n    }\r\n    \r\n    function withdrawOrStake(userState _userStates) public returns (bool) {\r\n        \r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(people[msg.sender]._userState == userState.NotDecided);\r\n        require(people[msg.sender]._userStateBlocktimestamp == 0);\r\n        \r\n        if(people[msg.sender]._userState == userState.NotDecided && _userStates == userState.Withdraw){\r\n            people[msg.sender]._userState = userState.Withdraw;\r\n            people[msg.sender]._userStateBlocktimestamp = block.timestamp;\r\n            return true;\r\n        }\r\n        else if(people[msg.sender]._userState == userState.NotDecided && _userStates == userState.Staked && people[msg.sender]._value >= minStakeAmt ){\r\n            people[msg.sender]._userState = userState.Staked;\r\n            people[msg.sender]._userStateBlocktimestamp = block.timestamp;\r\n            \r\n            Person storage t =  people[msg.sender];\r\n            people[msg.sender]._stakeCounter += 1;\r\n            t.stakeStruct[people[msg.sender]._stakeCounter] = stakeData(people[msg.sender]._stakeCounter ,people[msg.sender]._value,block.timestamp,0,0);\r\n            \r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n        \r\n    }\r\n    \r\n    function getFirstStakeDate(address _useraddress) public view returns(uint256) {\r\n         require(_useraddress == people[_useraddress]._address);\r\n         require(_useraddress != blockpeople[_useraddress]._address);\r\n         Person storage t =  people[_useraddress];\r\n         \r\n         for (uint256 s0 = 1; s0 <= people[_useraddress]._stakeCounter; s0 += 1){\r\n               if(t.stakeStruct[s0]._withdrawTimestamp == 0){\r\n                   uint256 _firstStakeTimestamp = t.stakeStruct[s0]._stakeTimeStamp;\r\n                   return _firstStakeTimestamp;\r\n               }\r\n           }\r\n    }\r\n    \r\n    function unstakeRequest() public {\r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(msg.sender != blockpeople[msg.sender]._address);\r\n        require(getFirstStakeDate(msg.sender) != 0 );\r\n        require(block.timestamp >= getFirstStakeDate(msg.sender) + sixmonth);\r\n        Person storage t =  people[msg.sender];\r\n        require(t.stakeStruct[people[msg.sender]._stakeCounter]._withdrawTimestamp == 0);\r\n         \r\n        for (uint256 s = 1; s <= people[msg.sender]._stakeCounter; s += 1){\r\n                       if(t.stakeStruct[s]._withdrawTimestamp == 0){ //chk that previos withdraws\r\n                           t.stakeStruct[s]._withdrawTimestamp = block.timestamp;\r\n                           t.stakeStruct[s]._withdrawOrNotyet = 1;\r\n                       }\r\n                    \r\n        }\r\n         \r\n        people[msg.sender]._withdrawTimestamp = block.timestamp;\r\n         \r\n    }\r\n    \r\n    function withdrawToken() public returns (bool){\r\n        \r\n        require(msg.sender == people[msg.sender]._address,\"You are not authorized\"); // chk user is aithorized\r\n        require(people[msg.sender]._userState == userState.Withdraw,\"userState Issue\"); //user into withdraw state\r\n        // require(people[msg.sender]._userStateBlocktimestamp != 0,\"usbts issue\"); // must has choosen withdraw or stake \r\n        require(people[msg.sender]._withdrawState == withdrawState.NotWithdraw,\"withdrawState issue\"); // not withdraw any tkns\r\n        require(people[msg.sender]._remainToken == remainToken.stage0,\"remainToken issue\"); // not withdraw any tkns\r\n        require(msg.sender != blockpeople[msg.sender]._address); //not blocked\r\n        require(people[msg.sender]._withdrawTimestamp == 0);  // is not staker\r\n\r\n        \r\n        if (getPeopleAddress(msg.sender) !=  msg.sender){\r\n            if (block.timestamp >= stage11 && block.timestamp <= stage12 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 50; \r\n            \r\n             require(Ntoken.transfer(msg.sender, clamimTkn));\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage1;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > stage21 && block.timestamp <= stage22 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 70; \r\n            \r\n             require(Ntoken.transfer(msg.sender, clamimTkn));\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage2;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > stage31 && block.timestamp <= stage32 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 80; \r\n            \r\n             require(Ntoken.transfer(msg.sender, clamimTkn));\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage3;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > stage32 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value; \r\n            \r\n             require(Ntoken.transfer(msg.sender, clamimTkn));\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        } else {\r\n            if (block.timestamp >= ostage11 && block.timestamp <= ostage12 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 50; \r\n            \r\n             require(Ntoken.transfer(msg.sender, clamimTkn));\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage1;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > ostage21 && block.timestamp <= ostage22 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 70; \r\n            \r\n             require(Ntoken.transfer(msg.sender, clamimTkn));\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage2;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > ostage31 && block.timestamp <= ostage32 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 80; \r\n            \r\n             require(Ntoken.transfer(msg.sender, clamimTkn));\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.PartiallyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage3;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        else if (block.timestamp > ostage32 ){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value; \r\n            \r\n            require(Ntoken.transfer(msg.sender, clamimTkn));\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            people[msg.sender]._blocktimestamp = block.timestamp;\r\n            \r\n            return true;\r\n        }\r\n        }\r\n        \r\n    }\r\n    \r\n    function unstake() public returns(bool){\r\n        \r\n        require(msg.sender == people[msg.sender]._address,\"You are not in previous contract\");\r\n        require(msg.sender != blockpeople[msg.sender]._address); // not blocked\r\n        require(people[msg.sender]._withdrawTimestamp != 0 ); // chk that user has done unstakeme\r\n        Person storage t =  people[msg.sender];\r\n        require(block.timestamp >= people[msg.sender]._withdrawTimestamp + day21);\r\n        uint256 clamimTkn = 0;\r\n        for (uint256 s = 1; s <= people[msg.sender]._stakeCounter; s += 1){\r\n            \r\n                       if(t.stakeStruct[s]._withdrawOrNotyet == 1){ //chk that previos withdraws\r\n                           clamimTkn += t.stakeStruct[s].amt;\r\n                           t.stakeStruct[s]._withdrawOrNotyet = 0;\r\n                       }\r\n                    \r\n         }\r\n                \r\n                    \r\n                    require(Ntoken.transfer(msg.sender, clamimTkn));\r\n                    \r\n                    people[msg.sender]._withdrawTimestamp = 0;\r\n                    \r\n                    return true;\r\n\r\n    \r\n    }\r\n    \r\n    function withdrawRemainPenaltyToken() public checkUser returns (bool){\r\n        \r\n        require(msg.sender == people[msg.sender]._address);\r\n        require(people[msg.sender]._userState == userState.Withdraw);\r\n        require(people[msg.sender]._withdrawState == withdrawState.PartiallyWithdraw);\r\n        require(block.timestamp >= people[msg.sender]._blocktimestamp + oneyear);\r\n        require(msg.sender != blockpeople[msg.sender]._address);\r\n        \r\n        if (people[msg.sender]._remainToken == remainToken.stage1){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 50; \r\n           \r\n            require(Ntoken.transfer(msg.sender, clamimTkn));\r\n          \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            \r\n            return true;\r\n        }\r\n        else if (people[msg.sender]._remainToken == remainToken.stage2){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 30; \r\n            \r\n            require(Ntoken.transfer(msg.sender, clamimTkn));\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            \r\n            return true;\r\n        }\r\n        else if (people[msg.sender]._remainToken == remainToken.stage3){\r\n            \r\n            uint256 clamimTkn = people[msg.sender]._value / 100 * 20; \r\n            \r\n            require(Ntoken.transfer(msg.sender, clamimTkn));\r\n            \r\n            people[msg.sender]._withdrawState = withdrawState.FullyWithdraw;\r\n            people[msg.sender]._remainToken = remainToken.stage4;\r\n            \r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function remainPenaltyClaimDate(address  _address) public view returns (uint256 date) {\r\n        \r\n         require(_address == people[_address]._address);\r\n         require(people[_address]._withdrawState == withdrawState.PartiallyWithdraw);\r\n         require(people[_address]._userState == userState.Withdraw);\r\n         \r\n         return people[_address]._blocktimestamp + oneyear;\r\n        \r\n    }\r\n    \r\n    // withdraw owner tokens\r\n    \r\n    function withdrawOwnerNioxToken(uint256 _tkns) public  onlyOwner returns (bool) {\r\n             require(token.transfer(msg.sender, _tkns));\r\n             return true;\r\n        }\r\n        \r\n    function withdrawOtherTokens(address tokenContract, uint256 count) external onlyOwner returns (bool)  {\r\n     Token tc = Token(tokenContract);\r\n     require(tc.transfer(owner, count));\r\n     return true;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"AddedNewUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenholder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"addAddressExisting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_txHashAddress\",\"type\":\"uint256\"},{\"internalType\":\"enum Staking.userState\",\"name\":\"_userState\",\"type\":\"uint8\"},{\"internalType\":\"enum Staking.withdrawState\",\"name\":\"_withdrawState\",\"type\":\"uint8\"},{\"internalType\":\"enum Staking.remainToken\",\"name\":\"_remainToken\",\"type\":\"uint8\"}],\"name\":\"addAddressNew\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blockpeople\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"blockuser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"chkUserInPreviousContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"getFirstStakeDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRemainTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"getStakeTokenById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserState\",\"outputs\":[{\"internalType\":\"enum Staking.userState\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getWithdrawTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"people\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_txHashAddress\",\"type\":\"uint256\"},{\"internalType\":\"enum Staking.userState\",\"name\":\"_userState\",\"type\":\"uint8\"},{\"internalType\":\"enum Staking.withdrawState\",\"name\":\"_withdrawState\",\"type\":\"uint8\"},{\"internalType\":\"enum Staking.remainToken\",\"name\":\"_remainToken\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_blocktimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userStateBlocktimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeCounter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"peopleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"remainPenaltyClaimDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"stakeForOther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalStakes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"unblockuser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstakeRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum Staking.userState\",\"name\":\"_userStates\",\"type\":\"uint8\"}],\"name\":\"withdrawOrStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"withdrawOtherTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tkns\",\"type\":\"uint256\"}],\"name\":\"withdrawOwnerNioxToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainPenaltyToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6e9788bd6354cb351de831b546e69c4122314de8c3fef1dd99fd0e966e69405b"}]}