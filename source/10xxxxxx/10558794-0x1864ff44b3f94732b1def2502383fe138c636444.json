{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\ncontract ImplementationResolver {\r\n\r\n    address public owner;\r\n    address public implementation;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, 'Only owner is allowed to send this transaction');\r\n        _;\r\n    }\r\n\r\n    constructor(address initialImplementation, address initialOwner) public {\r\n        owner = initialOwner;\r\n        implementation = initialImplementation;\r\n    }\r\n\r\n    function getImplementation() view public returns (address) {\r\n        return implementation;\r\n    }\r\n\r\n    function changeOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0), \"New owner cannot be address 0\");\r\n        owner = newOwner;\r\n        emit NewOwner(newOwner);\r\n    }\r\n\r\n    function upgrade(address newImplementation) onlyOwner public {\r\n        implementation = newImplementation;\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    event NewOwner(address newOwner);\r\n    event Upgraded(address newImplementation);\r\n\r\n}\r\n\r\ncontract Proxy {\r\n\r\n    // https://eips.ethereum.org/EIPS/eip-1967\r\n    bytes32 private constant implementationResolverSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    constructor(address resolverAddress) public {\r\n        bytes32 slot = implementationResolverSlot;\r\n        assembly {\r\n            sstore(slot, resolverAddress)\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        bytes32 slot = implementationResolverSlot;\r\n        address resolverAddress;\r\n        assembly {\r\n            resolverAddress := sload(slot)\r\n        }\r\n        ImplementationResolver resolver = ImplementationResolver(resolverAddress);\r\n        address impl = resolver.getImplementation();\r\n        assembly {\r\n          let ptr := mload(0x40)\r\n\r\n          // (1) copy incoming call data\r\n          calldatacopy(ptr, 0, calldatasize)\r\n\r\n          // (2) forward call to logic contract\r\n          let result := delegatecall(gas, impl, ptr, calldatasize, 0, 0)\r\n          let size := returndatasize\r\n\r\n          // (3) retrieve return data\r\n          returndatacopy(ptr, 0, size)\r\n\r\n          // (4) forward return data back to caller\r\n          switch result\r\n          case 0 { revert(ptr, size) }\r\n          default { return(ptr, size) }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"resolverAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Proxy","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002206aa8ec85270ace5597539e3c287e021d41843","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://98614c363a6d91d577265d825bfba6aa7e094397e035d084eceacb97a5ccaa35"}]}