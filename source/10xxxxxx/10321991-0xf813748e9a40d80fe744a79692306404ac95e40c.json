{"status":"1","message":"OK","result":[{"SourceCode":"// File: localhost/contracts/handlers/compound/IComptroller.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IComptroller {\r\n    function claimComp(address holder) external;\r\n}\r\n\r\n// File: localhost/contracts/Config.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract Config {\r\n    // function signature of \"postProcess()\"\r\n    bytes4 constant POSTPROCESS_SIG = 0xc2722916;\r\n\r\n    // Handler post-process type. Others should not happen now.\r\n    enum HandlerType {Token, Custom, Others}\r\n}\r\n\r\n// File: localhost/contracts/lib/LibCache.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary LibCache {\r\n    function setAddress(bytes32[] storage _cache, address _input) internal {\r\n        _cache.push(bytes32(uint256(uint160(_input))));\r\n    }\r\n\r\n    function set(bytes32[] storage _cache, bytes32 _input) internal {\r\n        _cache.push(_input);\r\n    }\r\n\r\n    function setHandlerType(bytes32[] storage _cache, uint256 _input) internal {\r\n        require(_input < uint96(-1), \"Invalid Handler Type\");\r\n        _cache.push(bytes12(uint96(_input)));\r\n    }\r\n\r\n    function setSender(bytes32[] storage _cache, address _input) internal {\r\n        require(_cache.length == 0, \"cache not empty\");\r\n        setAddress(_cache, _input);\r\n    }\r\n\r\n    function getAddress(bytes32[] storage _cache)\r\n        internal\r\n        returns (address ret)\r\n    {\r\n        ret = address(uint160(uint256(peek(_cache))));\r\n        _cache.pop();\r\n    }\r\n\r\n    function getSig(bytes32[] storage _cache) internal returns (bytes4 ret) {\r\n        ret = bytes4(peek(_cache));\r\n        _cache.pop();\r\n    }\r\n\r\n    function get(bytes32[] storage _cache) internal returns (bytes32 ret) {\r\n        ret = peek(_cache);\r\n        _cache.pop();\r\n    }\r\n\r\n    function peek(bytes32[] storage _cache)\r\n        internal\r\n        view\r\n        returns (bytes32 ret)\r\n    {\r\n        require(_cache.length > 0, \"cache empty\");\r\n        ret = _cache[_cache.length - 1];\r\n    }\r\n\r\n    function getSender(bytes32[] storage _cache)\r\n        internal\r\n        returns (address ret)\r\n    {\r\n        require(_cache.length > 0, \"cache empty\");\r\n        ret = address(uint160(uint256(_cache[0])));\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/Cache.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/// @notice A cache structure composed by a bytes32 array\r\ncontract Cache {\r\n    using LibCache for bytes32[];\r\n\r\n    bytes32[] cache;\r\n\r\n    modifier isCacheEmpty() {\r\n        require(cache.length == 0, \"Cache not empty\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/handlers/HandlerBase.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract HandlerBase is Cache, Config {\r\n    function postProcess() external payable {\r\n        revert(\"Invalid post process\");\r\n        /* Implementation template\r\n        bytes4 sig = cache.getSig();\r\n        if (sig == bytes4(keccak256(bytes(\"handlerFunction_1()\")))) {\r\n            // Do something\r\n        } else if (sig == bytes4(keccak256(bytes(\"handlerFunction_2()\")))) {\r\n            bytes32 temp = cache.get();\r\n            // Do something\r\n        } else revert(\"Invalid post process\");\r\n        */\r\n    }\r\n\r\n    function _updateToken(address token) internal {\r\n        cache.setAddress(token);\r\n        // Ignore token type to fit old handlers\r\n        // cache.setHandlerType(uint256(HandlerType.Token));\r\n    }\r\n\r\n    function _updatePostProcess(bytes32[] memory params) internal {\r\n        for (uint256 i = params.length; i > 0; i--) {\r\n            cache.set(params[i - 1]);\r\n        }\r\n        cache.set(msg.sig);\r\n        cache.setHandlerType(uint256(HandlerType.Custom));\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/handlers/compound/HComptroller.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract HComptroller is HandlerBase {\r\n    address constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n\r\n    function claimComp() external payable {\r\n        IComptroller comptroller = IComptroller(COMPTROLLER);\r\n        comptroller.claimComp(cache.getSender());\r\n    }\r\n\r\n    function claimComp(address holder) external payable {\r\n        IComptroller comptroller = IComptroller(COMPTROLLER);\r\n        comptroller.claimComp(holder);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"claimComp\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"claimComp\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"postProcess\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"HComptroller","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ec5d6c9f432e7b1a1aecb20e14478ba16e5628b722fd9bdddb821727f1f80086"}]}