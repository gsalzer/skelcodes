{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not authorized operation\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Address shouldn't be zero\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is ERC20, Ownable {\r\n  using Address for address;\r\n  using SafeMath for uint256;\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n  uint256 public totalSupply;\r\n  address public tokenOwner;\r\n  address private crowdsale;\r\n\r\n  mapping(address => uint256) balances;\r\n  mapping(address => mapping(address => uint256)) internal allowed;\r\n\r\n  event SetCrowdsale(address indexed _crowdsale);\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n  event UnlockToken();\r\n  event LockToken();\r\n  event Burn();\r\n\r\n  bool public mintingFinished = false;\r\n  bool public locked = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier canTransfer() {\r\n    require(!locked || msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCrowdsale() {\r\n    require(msg.sender == crowdsale);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAuthorized() {\r\n    require(msg.sender == owner || msg.sender == crowdsale);\r\n    _;\r\n  }\r\n\r\n  constructor(string memory _name, string memory _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n    totalSupply = 0;\r\n    balances[msg.sender] = totalSupply;\r\n    emit Transfer(address(0), msg.sender, totalSupply);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) public onlyAuthorized canMint returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner public canMint returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n\r\n  function burn(uint256 _value) public onlyAuthorized returns (bool) {\r\n    totalSupply = totalSupply.sub(_value);\r\n    balances[address(this)] = balances[address(this)].sub(_value);\r\n    emit Burn();\r\n    emit Transfer(address(this), address(0), _value);\r\n    return true;\r\n  }\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n\r\n  function transfer(address _to, uint256 _value) public canTransfer returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFromContract(address _to, uint256 _value) public onlyOwner returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[address(this)]);\r\n\r\n    balances[address(this)] = balances[address(this)].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(address(this), _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public canTransfer returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function unlockToken() public onlyCrowdsale returns (bool) {\r\n    locked = false;\r\n    emit UnlockToken();\r\n    return true;\r\n  }\r\n\r\n  function lockToken() public onlyCrowdsale returns (bool) {\r\n    locked = true;\r\n    emit LockToken();\r\n    return true;\r\n  }\r\n\r\n  function setCrowdsale(address _crowdsale) public onlyOwner returns (bool) {\r\n    require(_crowdsale.isContract());\r\n    crowdsale = _crowdsale;\r\n\r\n    emit SetCrowdsale(_crowdsale);\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract ERC20Extended is ERC20 {\r\n    function decimals() public view returns (uint);\r\n}\r\n\r\n/**\r\n * @title Belivers Reward Offering\r\n * @author Tozex\r\n */\r\ncontract BRO is Ownable {\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n\r\n    struct Believer {\r\n        address stableCoin;\r\n        uint fundDate;\r\n        uint loanStartDate;\r\n        uint loanEndDate;\r\n        uint loanAmount;\r\n        uint8 tier;\r\n        uint8 lastQuarter;\r\n        bool claimedStakingBonus;\r\n        bool finishedPayout;\r\n    }\r\n\r\n    struct LoanConfig {\r\n        uint16 min;\r\n        uint24 max;\r\n        uint8 quarterCount;\r\n        uint8 interestRate;\r\n        uint8 duration;\r\n    }\r\n\r\n    struct RewardPlan {\r\n        uint repaymentUsdAmount;\r\n        uint qRepaymentTozAmount;\r\n        uint qInterestAmount;\r\n        mapping (uint8 => uint) stakingBonuses;\r\n    }\r\n\r\n    enum BroState {PREPARE, RUNNING, PAUSED, FINISHED, REFUNDING}\r\n\r\n    // define constants for DAI/TUSD stable coins\r\n    address public TUSD_ADDRESS;\r\n    address public DAI_ADDRESS;\r\n    address public USDT_ADDRESS;\r\n\r\n    // define constants fro day/quarter days\r\n    uint public constant QUARTER_DAYS = 90 days;\r\n    uint public constant ONE_DAY = 1 days;\r\n\r\n    // define DAI/TUSD/USDT token contract instances\r\n    ERC20Extended public tusdToken;\r\n    ERC20Extended public daiToken;\r\n    ERC20Extended public usdtToken;\r\n    MintableToken public tozToken;\r\n\r\n    // Timestamps for BRO campaign\r\n    uint broStartTimestamp;\r\n    uint broDuration;\r\n\r\n    // BRO state variables\r\n    BroState broState = BroState.PREPARE;\r\n\r\n    // define master wallet address\r\n    address payable private masterWallet;\r\n    address payable[] private believersArray;\r\n\r\n    // mapping for believers database\r\n    mapping (uint8 => LoanConfig) public loanConfigs;\r\n    mapping (address => Believer) public believers;\r\n    mapping (address => RewardPlan) public rewardPlans;\r\n    mapping (address => bool) private whitelist;\r\n    mapping (address => uint) private bonusTozBalances;\r\n\r\n    // BRO events definition\r\n    event StartBRO();\r\n    event PauseBRO();\r\n    event FinishBRO();\r\n    event TransferEnabled();\r\n    event PaybackStableCoin(address indexed _token, address indexed _to, uint indexed _amount);\r\n    event PaybackToz(address indexed _to, uint indexed _amount);\r\n    event AddWhitelist(address indexed _address);\r\n    event RemoveFromWhitelist(address indexed _address);\r\n    event UpdateMaserWallet(address payable _masterWallet);\r\n    event UpdateStableCoins();\r\n    event DepositLoan(address indexed _lender, uint _amount, address _coin);\r\n    event ClaimStakingBonus(address indexed _lender, uint _amount);\r\n    event Withdraw(uint _tusdAmount, uint _daiAmount, uint _usdtAmount);\r\n\r\n    /**\r\n     * @dev check only supported stablecoins\r\n     */\r\n    modifier isAcceptableTokens(address _token) {\r\n        require(_token == TUSD_ADDRESS || _token == DAI_ADDRESS || _token == USDT_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev check only whitelisted lenders\r\n     */\r\n    modifier isWhitelisted(address _address) {\r\n        require(whitelist[_address]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @param _tozToken address Contract address of TOZ token\r\n     * @param _masterWallet address Address of masterWallet\r\n     * @param _broDuration uint Duration of BRO campaign in days\r\n     * @param _tusdToken address Address of TUSD token\r\n     * @param _daiToken address Address of DAI stablecoin\r\n     * @param _usdtToken address Address of USDT stablecoin\r\n     */\r\n    constructor(address _tozToken, address payable _masterWallet, uint _broDuration, address _tusdToken, address _daiToken, address _usdtToken) public {\r\n        require(_masterWallet != address(0));\r\n        masterWallet = _masterWallet;\r\n        broDuration = _broDuration * ONE_DAY;\r\n\r\n        // initialize TOZ token instance\r\n        tozToken = MintableToken(_tozToken);\r\n        daiToken = ERC20Extended(_daiToken);\r\n        tusdToken = ERC20Extended(_tusdToken);\r\n        usdtToken = ERC20Extended(_usdtToken);\r\n\r\n        // set token addresses\r\n        TUSD_ADDRESS = _tusdToken;\r\n        DAI_ADDRESS = _daiToken;\r\n        USDT_ADDRESS = _usdtToken;\r\n\r\n        // initialize configuration\r\n        initLoanConfig();\r\n    }\r\n\r\n    /**\r\n     * Rejecting direct ETH payment to the contract\r\n     */\r\n    function() external {\r\n        revert();\r\n    }\r\n\r\n    /**\r\n     * @dev Function to deposit stable coin. This will be called from loan investors directly\r\n     *\r\n     * @param _token address Contract address of stable coin\r\n     * @param _amount uint Amount of deposit\r\n     *\r\n     * @notice Investor should call approve() function of token contract before calling this function\r\n     */\r\n    function depositLoan(address _token, uint _amount) public isAcceptableTokens(_token) returns (bool) {\r\n        require(broState == BroState.RUNNING, \"BRO is not active\");\r\n\r\n        // only accept only once\r\n        require(believers[msg.sender].loanAmount == 0, \"Deposit is allowed only once\");\r\n\r\n        // validate _amount between min/max\r\n        require(_amount >= 10 && _amount <=100000);\r\n\r\n        // move half of stable coin to masterWallet\r\n        ERC20Extended token = ERC20Extended(_token);\r\n\r\n        uint decimals = token.decimals();\r\n\r\n        // send half amount to master wallet\r\n        require(token.transferFrom(msg.sender, masterWallet, _amount.mul(10**decimals).div(2)));\r\n        // send half amount to BRO contract for repayment\r\n        require(token.transferFrom(msg.sender, address(this), _amount.mul(10**decimals).div(2)));\r\n\r\n        // register the loan amount\r\n        uint8 tier = getLoanTire(_amount);\r\n        uint8 quarterCount = loanConfigs[tier].quarterCount;\r\n\r\n        believers[msg.sender] = Believer(\r\n            _token,\r\n            now,\r\n            now + broDuration,\r\n            now + broDuration + loanConfigs[tier].duration * 30 * ONE_DAY,\r\n            _amount,\r\n            tier,\r\n            0,\r\n            false,\r\n            false\r\n        );\r\n\r\n        believersArray.push(msg.sender);\r\n\r\n        // calculating reward plan\r\n        uint interestRate = loanConfigs[tier].interestRate;\r\n        uint quarterCapitalReimbursed = _amount.div(2 * quarterCount);\r\n        uint quarterInterests = _amount.mul(interestRate).div(100).div(quarterCount);\r\n\r\n        RewardPlan storage rewardPlan = rewardPlans[msg.sender];\r\n        rewardPlan.repaymentUsdAmount = _amount.div(2);\r\n        rewardPlan.qRepaymentTozAmount = quarterCapitalReimbursed;\r\n        rewardPlan.qInterestAmount = quarterInterests;\r\n\r\n        // calculate staking bonus for each quarter (Maximum iteration is 6)\r\n        uint sum = 0;\r\n        uint8 q = 1;\r\n        uint bonus = 0;\r\n        while(q <= quarterCount) {\r\n            rewardPlan.stakingBonuses[q] = bonus;\r\n            sum += quarterCapitalReimbursed.add(quarterInterests).add(bonus);\r\n            bonus = sum.div(10);\r\n            q++;\r\n        }\r\n\r\n        emit DepositLoan(msg.sender, _amount, address(token));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to pay back and distribute rewards quarterly\r\n     *\r\n     * @notice this function should be called periodically, quarterly basis to distribute\r\n     * reimbursements, interest of loan, excluding bonus for long term staking\r\n     */\r\n    function payout() public isWhitelisted(msg.sender) {\r\n        // check if the BRO is finished\r\n        require(broState == BroState.FINISHED);\r\n\r\n        // iterate all believers\r\n        for (uint8 i = 0; i < believersArray.length; i++) {\r\n            Believer memory lender = believers[believersArray[i]];\r\n            RewardPlan memory rewardPlan = rewardPlans[believersArray[i]];\r\n\r\n            // exclude if payout is finished for each lender\r\n            if (lender.finishedPayout) continue;\r\n\r\n            // escape if one quarter is not elapsed from last quarter\r\n            uint expectedQuarterlyDate = lender.loanStartDate + (lender.lastQuarter + 1) * QUARTER_DAYS;\r\n            if (now < expectedQuarterlyDate) continue;\r\n\r\n            // reimburse as USD for first quarter only\r\n            if (lender.lastQuarter == 0 && rewardPlan.repaymentUsdAmount > 0) {\r\n                // reset the repayment for USD\r\n                rewardPlans[believersArray[i]].repaymentUsdAmount = 0;\r\n\r\n                // send DAI/TUSD\r\n                sendStableCoin(lender.stableCoin, believersArray[i], rewardPlan.repaymentUsdAmount);\r\n            }\r\n\r\n            if (rewardPlan.qRepaymentTozAmount == 0) continue;\r\n\r\n            // summarize\r\n            believers[believersArray[i]].lastQuarter = believers[believersArray[i]].lastQuarter + 1;\r\n\r\n            // mint TOZ reimburseAmount (reimburseAmount + interestTozAmount) excluding staking bonus\r\n            mintToz(believersArray[i], rewardPlan.qRepaymentTozAmount.add(rewardPlan.qInterestAmount));\r\n\r\n            if (believers[believersArray[i]].lastQuarter == loanConfigs[lender.tier].quarterCount) {\r\n                believers[believersArray[i]].finishedPayout = true;\r\n                // reset TOZ repayment amount\r\n                rewardPlans[believersArray[i]].qRepaymentTozAmount = 0;\r\n                rewardPlans[believersArray[i]].qInterestAmount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw believers staking bonus\r\n     */\r\n    function claimStakingBonus() public isWhitelisted(msg.sender) returns (uint) {\r\n        // check if the BRO is finished\r\n        require(broState == BroState.FINISHED);\r\n        // should not claim bonus before\r\n        require(believers[msg.sender].claimedStakingBonus == false);\r\n\r\n        Believer memory lender = believers[msg.sender];\r\n        RewardPlan storage rewardPlan = rewardPlans[msg.sender];\r\n\r\n        uint totalBonus = 0;\r\n        uint remainingBonus = 0;\r\n        uint8 quarterCount = loanConfigs[lender.tier].quarterCount;\r\n        uint lastQuarter = now.sub(lender.loanStartDate).div(QUARTER_DAYS);\r\n\r\n        for (uint8 q = 1; q <= lastQuarter; q++) {\r\n            totalBonus = totalBonus.add(rewardPlan.stakingBonuses[q]);\r\n            // empty staking bonus amount\r\n            rewardPlans[msg.sender].stakingBonuses[q] = 0;\r\n        }\r\n\r\n        for (uint8 q = quarterCount; q > lastQuarter; q--) {\r\n            remainingBonus = remainingBonus.add(rewardPlan.stakingBonuses[q]);\r\n            // empty staking bonus amount\r\n            rewardPlans[msg.sender].stakingBonuses[q] = 0;\r\n        }\r\n\r\n        // claimedStakingBonus true (reentrancy prevent)\r\n        believers[msg.sender].claimedStakingBonus = true;\r\n\r\n        // mint token\r\n        mintToz(msg.sender, totalBonus);\r\n\r\n        // mint remaining bonus to master wwallet\r\n        mintToz(masterWallet, remainingBonus);\r\n\r\n        emit ClaimStakingBonus(msg.sender, totalBonus);\r\n        return totalBonus;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to get lenders count\r\n     */\r\n    function getLendersCount() public view returns (uint) {\r\n        return believersArray.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to read loan information\r\n     */\r\n    function getLoanData(address _lender) public view returns (address, uint, uint, uint8, uint8, bool, bool) {\r\n        return (believers[_lender].stableCoin, believers[_lender].loanAmount, believers[_lender].loanStartDate, believers[_lender].tier, believers[_lender].lastQuarter, believers[_lender].claimedStakingBonus, believers[_lender].finishedPayout);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to read reward plan\r\n     */\r\n    function getRewardPlan(address _lender) public view returns (uint, uint, uint) {\r\n        return (rewardPlans[_lender].repaymentUsdAmount, rewardPlans[_lender].qRepaymentTozAmount, rewardPlans[_lender].qInterestAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to get staking bonus for a specific quarter\r\n     */\r\n    function getRewardPlan(address _lender, uint8 _quarter) public view returns (uint) {\r\n        return rewardPlans[_lender].stakingBonuses[_quarter];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to get lenders count\r\n     */\r\n    function getLoanConfig(uint8 _quarter) public view returns (uint8, uint8, uint8) {\r\n        return (loanConfigs[_quarter].quarterCount, loanConfigs[_quarter].interestRate, loanConfigs[_quarter].duration);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to add whitelist\r\n     */\r\n    function addToWhitelist(address[] memory _addresses) public onlyOwner {\r\n        // validate if whitelisting is eligible\r\n        require(broState == BroState.PREPARE);\r\n\r\n        for (uint256 i = 0; i < _addresses.length; i++) {\r\n            if (whitelist[_addresses[i]]) continue;\r\n            whitelist[_addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function to remove from whitelist\r\n     */\r\n    function removeFromWhitelist(address[] memory _addresses) public onlyOwner {\r\n        require(broState == BroState.PREPARE);\r\n\r\n        for (uint256 i = 0; i < _addresses.length; i++) {\r\n            if (!whitelist[_addresses[i]]) continue;\r\n            whitelist[_addresses[i]] = false;\r\n        }\r\n    }\r\n\r\n    // -------------- Administrative functions -------------- //\r\n    /**\r\n     * @dev Function to start BRO campaign\r\n     */\r\n    function startBRO() public onlyOwner returns (bool) {\r\n        broState = BroState.RUNNING;\r\n\r\n        broStartTimestamp = now;\r\n\r\n        emit StartBRO();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to pause BRO campaign\r\n     */\r\n    function pauseBRO() public onlyOwner returns (bool) {\r\n        broState = BroState.PAUSED;\r\n\r\n        emit PauseBRO();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to finish BRO campaign\r\n     */\r\n    function finishBRO() public onlyOwner returns (bool) {\r\n        broState = BroState.FINISHED;\r\n\r\n        emit FinishBRO();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to replace TOZEX multisig wallet address\r\n     */\r\n    function updateMasterWallet(address payable _masterWallet) public onlyOwner {\r\n        require(_masterWallet != address(0));\r\n        masterWallet = _masterWallet;\r\n\r\n        emit UpdateMaserWallet(_masterWallet);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to update Stablecoin addresses for TUSD/DAI\r\n     */\r\n    function updateStableCoins(address _tusdToken, address _daiToken, address _usdtToken) public onlyOwner {\r\n        require(_tusdToken.isContract());\r\n        require(_daiToken.isContract());\r\n        require(_usdtToken.isContract());\r\n\r\n        daiToken = ERC20Extended(_daiToken);\r\n        tusdToken = ERC20Extended(_tusdToken);\r\n        usdtToken = ERC20Extended(_usdtToken);\r\n\r\n        // set token addresses\r\n        TUSD_ADDRESS = _tusdToken;\r\n        DAI_ADDRESS = _daiToken;\r\n        USDT_ADDRESS = _usdtToken;\r\n\r\n        emit UpdateStableCoins();\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw TUSD/DAI/USDT to master wallet for security\r\n     */\r\n    function withdraw() public onlyOwner {\r\n        require(broState == BroState.FINISHED);\r\n\r\n        uint tusdBalance = tusdToken.balanceOf(address(this));\r\n        uint daiBalance = daiToken.balanceOf(address(this));\r\n        uint usdtBalance = usdtToken.balanceOf(address(this));\r\n\r\n        if (tusdBalance > 0) sendStableCoin(TUSD_ADDRESS, masterWallet, tusdBalance);\r\n        if (daiBalance > 0) sendStableCoin(DAI_ADDRESS, masterWallet, daiBalance);\r\n        if (usdtBalance > 0) sendStableCoin(USDT_ADDRESS, masterWallet, usdtBalance);\r\n\r\n        emit Withdraw(tusdBalance, daiBalance, usdtBalance);\r\n    }\r\n\r\n    // -------------- Internal functions -------------- //\r\n\r\n    /**\r\n     * @dev Send TUSD/DAI/USDT to lender for reimbursement\r\n     * @notice this should be discussed\r\n     */\r\n    function sendStableCoin(address _token, address payable _receiver, uint _amount) internal isAcceptableTokens(_token) returns (uint) {\r\n        ERC20Extended token = ERC20Extended(_token);\r\n\r\n        uint decimals = token.decimals();\r\n        uint weiAmount = _amount.mul(10**decimals);\r\n\r\n        require(token.transfer(_receiver, weiAmount));\r\n\r\n        emit PaybackStableCoin(_token, _receiver, weiAmount);\r\n        return _amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Mint TOZ to lender for reimbursement and reward\r\n     */\r\n    function mintToz(address _receiver, uint _amount) internal returns (uint) {\r\n        uint decimals = tozToken.decimals();\r\n        uint weiAmount = _amount.mul(10**decimals);\r\n\r\n        // send TOZ token\r\n        require(tozToken.mint(_receiver, weiAmount));\r\n\r\n        emit PaybackToz(_receiver, _amount);\r\n        return _amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Get proper tier for the loan amount\r\n     */\r\n    function getLoanTire(uint _amount) internal pure returns (uint8 tier) {\r\n        if (_amount >= 10 && _amount <= 10000) {\r\n            tier = 1;\r\n        } else if (_amount > 10000 && _amount <= 50000) {\r\n            tier = 2;\r\n        } else if (_amount > 50000 && _amount <= 100000) {\r\n            tier = 3;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize loan configuration for each tier 1, 2, 3\r\n     */\r\n    function initLoanConfig() internal {\r\n        loanConfigs[1] = LoanConfig(10, 10000, 4, 10, 12);\r\n        loanConfigs[2] = LoanConfig(10001, 50000, 5, 12, 15);\r\n        loanConfigs[3] = LoanConfig(50001, 100000, 6, 15, 18);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"believers\",\"outputs\":[{\"name\":\"stableCoin\",\"type\":\"address\"},{\"name\":\"fundDate\",\"type\":\"uint256\"},{\"name\":\"loanStartDate\",\"type\":\"uint256\"},{\"name\":\"loanEndDate\",\"type\":\"uint256\"},{\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"name\":\"tier\",\"type\":\"uint8\"},{\"name\":\"lastQuarter\",\"type\":\"uint8\"},{\"name\":\"claimedStakingBonus\",\"type\":\"bool\"},{\"name\":\"finishedPayout\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lender\",\"type\":\"address\"}],\"name\":\"getLoanData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimStakingBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_masterWallet\",\"type\":\"address\"}],\"name\":\"updateMasterWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositLoan\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startBRO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lender\",\"type\":\"address\"},{\"name\":\"_quarter\",\"type\":\"uint8\"}],\"name\":\"getRewardPlan\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseBRO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_DAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TUSD_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lender\",\"type\":\"address\"}],\"name\":\"getRewardPlan\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishBRO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tusdToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLendersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USDT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_quarter\",\"type\":\"uint8\"}],\"name\":\"getLoanConfig\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardPlans\",\"outputs\":[{\"name\":\"repaymentUsdAmount\",\"type\":\"uint256\"},{\"name\":\"qRepaymentTozAmount\",\"type\":\"uint256\"},{\"name\":\"qInterestAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUARTER_DAYS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tozToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tusdToken\",\"type\":\"address\"},{\"name\":\"_daiToken\",\"type\":\"address\"},{\"name\":\"_usdtToken\",\"type\":\"address\"}],\"name\":\"updateStableCoins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"loanConfigs\",\"outputs\":[{\"name\":\"min\",\"type\":\"uint16\"},{\"name\":\"max\",\"type\":\"uint24\"},{\"name\":\"quarterCount\",\"type\":\"uint8\"},{\"name\":\"interestRate\",\"type\":\"uint8\"},{\"name\":\"duration\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tozToken\",\"type\":\"address\"},{\"name\":\"_masterWallet\",\"type\":\"address\"},{\"name\":\"_broDuration\",\"type\":\"uint256\"},{\"name\":\"_tusdToken\",\"type\":\"address\"},{\"name\":\"_daiToken\",\"type\":\"address\"},{\"name\":\"_usdtToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StartBRO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseBRO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FinishBRO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TransferEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"PaybackStableCoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"PaybackToz\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RemoveFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_masterWallet\",\"type\":\"address\"}],\"name\":\"UpdateMaserWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UpdateStableCoins\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_lender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_coin\",\"type\":\"address\"}],\"name\":\"DepositLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_lender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimStakingBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tusdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_usdtAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BRO","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d7a24d22cb1e94a4cf71e2e8338849382a7877bb0000000000000000000000006088c7773feffee11a20910088dd03b4916c7b7a000000000000000000000000000000000000000000000000000000000000005c0000000000000000000000000000000000085d4780b73119b644ae5ecd22b3760000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0dbed6d9f19e18c5a80b1984aace9dfb17be80c2daaa52721c47f283beab887a"}]}