{"status":"1","message":"OK","result":[{"SourceCode":"{\"OpusOperations.sol\":{\"content\":\"pragma solidity ^0.4.25;\\r\\n\\r\\n/// @title OPUS Operations Contract\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n//import \\\"./math/SafeMath.sol\\\";\\r\\nimport \\\"./OpusToken.sol\\\";\\r\\n\\r\\n\\r\\n/*contract ContractReceiver{\\r\\n    function tokenFallback(address _from, uint256 _value, bytes  _data) external;\\r\\n}*/\\r\\n\\r\\ncontract OpusOperations is ContractReceiver, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    bool public apiAccessDisabled;  // api access control\\r\\n    bool public contractEnabled;    // is smart contract enabled for operations\\r\\n\\r\\n    OpusToken public opt;\\r\\n    \\t\\r\\n    /*struct PlayStatData { // royalties and fees\\r\\n        uint256 period; // yyyymm\\r\\n        string hash; // hash of table of data\\r\\n        string voterAnswer;\\r\\n    }\\r\\n    mapping(uint256 =\\u003e PlayStatData) public PlayStats;*/\\r\\n    mapping(uint256 =\\u003e string) public PlayStats; // yyyymm -\\u003e hash\\r\\n\\r\\n    event LogPlayStatAdded(uint256 period, string hash);\\r\\n\\r\\n    modifier onlyContractEnabled() {\\r\\n        require(contractEnabled, \\\"Smart contract must be enabled.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() public {\\r\\n        contractEnabled = true;\\r\\n        //opt = OpusToken(0xD158F87740074f4b4433a2F82Eb352aE06d10974); //TODO to jest rinkeby\\r\\n        opt = OpusToken(0x4355fC160f74328f9b383dF2EC589bB3dFd82Ba0); //TODO to jest mainnet\\r\\n    }\\r\\n\\r\\n    // receive ETH\\r\\n    function () public payable {\\r\\n        require(contractEnabled, \\\"Smart contract must be enabled.\\\");\\r\\n    }\\r\\n    // send ETH from the contract to a given address\\r\\n    function sendEth(address _receiver, uint _amount) public onlyOwner onlyContractEnabled {\\r\\n        _receiver.transfer(_amount);\\r\\n    }\\r\\n\\t\\r\\n\\r\\n    // receive OPT\\r\\n    function tokenFallback(address _from, uint256 _value, bytes _data) external {\\r\\n        require(contractEnabled, \\\"Smart Contract must be enabled.\\\");\\r\\n        if (msg.sender == address(opt)) { // accept only OPT\\r\\n        } else {\\r\\n            revert(\\\"This smart contract accepts only OPUS OPT tokens.\\\");\\r\\n        }\\r\\n    }\\r\\n    // send OPT from the contract to a given address\\r\\n    function sendOpt(address _receiver, uint _amount) public onlyOwnerOrApi onlyContractEnabled {\\r\\n        if(ApiAddr[msg.sender] == true \\u0026\\u0026 apiAccessDisabled) revert(\\\"API access is disabled.\\\");\\r\\n        opt.transfer(_receiver, _amount);\\r\\n    }\\r\\n\\r\\n    // transfer OPT from other holder, up to amount allowed through opt.approve() function\\r\\n    function getOptFromApproved(address _from, uint _amount) public onlyOwnerOrApi onlyContractEnabled {\\r\\n        if(ApiAddr[msg.sender] == true \\u0026\\u0026 apiAccessDisabled) revert(\\\"API access is disabled.\\\");\\r\\n        opt.transferFrom(_from, address(this), _amount);\\r\\n    }\\r\\n\\r\\n\\r\\n    // add a play statistics\\r\\n    function addPlayStat(uint256 _period, string _hash) public onlyOwnerOrApi onlyContractEnabled {\\r\\n\\t\\tPlayStats[_period] = _hash; \\r\\n\\t\\temit LogPlayStatAdded(_period, _hash);\\r\\n    }\\r\\n\\t\\r\\n    // disable/enable contract access from API\\r\\n    function disableApiAccess(bool _disabled) public onlyOwner {\\r\\n        apiAccessDisabled = _disabled;\\r\\n    }\\r\\n\\r\\n     /* change owner address for allowing execution for the new owner */\\r\\n    function setOwnerAddr(address _address) public onlySuperOwner {\\r\\n        ownerAddr = _address;\\r\\n    }\\r\\n\\r\\n    /* add API address for allowing execution from the API */\\r\\n    function addApiAddr(address _address) public onlyOwner {\\r\\n        ApiAddr[_address] = true;\\r\\n    }\\r\\n    /* remove API address from allowing execution from the API */\\r\\n    function removeApiAddr(address _address) public onlyOwner {\\r\\n        ApiAddr[_address] = false;\\r\\n    }\\r\\n\\r\\n    /* add a contract address for allowing execution from the contract */\\r\\n    function addContractAddr(address _address) public onlyOwner {\\r\\n        ContractAddr[_address] = true;\\r\\n    }\\r\\n    /* remove a contract address from allowing execution from the contract */\\r\\n    function removeContractAddr(address _address) public onlyOwner {\\r\\n        ContractAddr[_address] = false;\\r\\n    }\\r\\n\\r\\n    // enable/disable the contract\\r\\n    function setContractEnabled(bool _enabled) public onlyOwner {\\r\\n        contractEnabled = _enabled;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"},\"OpusToken.sol\":{\"content\":\"/**\\n *Submitted for verification at Etherscan.io on 2017-07-14\\n*/\\n\\npragma solidity ^0.4.8;\\n\\n\\n/**\\n * Math operations with safety checks\\n * By OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/contracts/SafeMath.sol\\n */\\nlibrary SafeMath {\\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\\n    uint256 c = a * b;\\n    if(!(a == 0 || c / a == b)) throw;\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\\n    if(!(b \\u003c= a)) throw;\\n    return a - b;\\n  }\\n\\n  function add(uint256 a, uint256 b) internal returns (uint256) {\\n    uint256 c = a + b;\\n    if(!(c \\u003e= a)) throw;\\n    return c;\\n  }\\n\\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\\n    return a \\u003e= b ? a : b;\\n  }\\n\\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\\n    return a \\u003c b ? a : b;\\n  }\\n\\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\\n    return a \\u003e= b ? a : b;\\n  }\\n\\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\\n    return a \\u003c b ? a : b;\\n  }\\n\\n}\\n\\ncontract ContractReceiver{\\n    function tokenFallback(address _from, uint256 _value, bytes  _data) external;\\n}\\n\\n\\n//Basic ERC23 token, backward compatible with ERC20 transfer function.\\n//Based in part on code by open-zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\\ncontract ERC23BasicToken {\\n    using SafeMath for uint256;\\n    uint256 public totalSupply;\\n    mapping(address =\\u003e uint256) balances;\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    \\n    function tokenFallback(address _from, uint256 _value, bytes  _data) external {\\n        throw;\\n    }\\n\\n    function transfer(address _to, uint256 _value, bytes _data) returns (bool success) {\\n\\n        //Standard ERC23 transfer function\\n\\n        if(isContract(_to)) {\\n            transferToContract(_to, _value, _data);\\n        }\\n        else {\\n            transferToAddress(_to, _value, _data);\\n        }\\n        return true;\\n    }\\n\\n    function transfer(address _to, uint256 _value) {\\n\\n        //standard function transfer similar to ERC20 transfer with no _data\\n        //added due to backwards compatibility reasons\\n\\n        bytes memory empty;\\n        if(isContract(_to)) {\\n            transferToContract(_to, _value, empty);\\n        }\\n        else {\\n            transferToAddress(_to, _value, empty);\\n        }\\n    }\\n\\n    function transferToAddress(address _to, uint256 _value, bytes _data) internal {\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        Transfer(msg.sender, _to, _value);\\n     }\\n\\n    function transferToContract(address _to, uint256 _value, bytes _data) internal {\\n        balances[msg.sender] = balances[msg.sender].sub( _value);\\n        balances[_to] = balances[_to].add( _value);\\n        ContractReceiver receiver = ContractReceiver(_to);\\n        receiver.tokenFallback(msg.sender, _value, _data);\\n        Transfer(msg.sender, _to, _value);    }\\n\\n    function balanceOf(address _owner) constant returns (uint256 balance) {\\n        return balances[_owner];\\n    }\\n\\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\\n    function isContract(address _addr) returns (bool is_contract) {\\n          uint256 length;\\n          assembly {\\n              //retrieve the size of the code on target address, this needs assembly\\n              length := extcodesize(_addr)\\n          }\\n          if(length\\u003e0) {\\n              return true;\\n          }\\n          else {\\n              return false;\\n          }\\n    }\\n}\\n\\ncontract ERC23StandardToken is ERC23BasicToken {\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\n    event Approval (address indexed owner, address indexed spender, uint256 value);\\n\\n    function transferFrom(address _from, address _to, uint256 _value) {\\n        var _allowance = allowed[_from][msg.sender];\\n\\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\\n        // if (_value \\u003e _allowance) throw;\\n\\n        balances[_to] = balances[_to].add(_value);\\n        balances[_from] = balances[_from].sub(_value);\\n        allowed[_from][msg.sender] = _allowance.sub(_value);\\n        Transfer(_from, _to, _value);\\n    }\\n\\n    function approve(address _spender, uint256 _value) {\\n\\n        // To change the approve amount you first have to reduce the addresses`\\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\\n        //  already 0 to mitigate the race condition described here:\\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n        if ((_value != 0) \\u0026\\u0026 (allowed[msg.sender][_spender] != 0)) throw;\\n\\n        allowed[msg.sender][_spender] = _value;\\n        Approval(msg.sender, _spender, _value);\\n    }\\n\\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\\n        return allowed[_owner][_spender];\\n    }\\n\\n}\\n\\n\\n\\n\\n// Based in part on code by Open-Zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\\n// Based in part on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\ncontract OpusToken is ERC23StandardToken {\\n    string public constant name = \\\"Opus Token\\\";\\n    string public constant symbol = \\\"OPT\\\";\\n    uint256 public constant decimals = 18;\\n    address public multisig=address(0x1426c1f91b923043F7C5FbabC6e369e7cBaef3f0); //multisig wallet, to which all contributions will be sent\\n    address public foundation; //owner address\\n    address public candidate; //owner candidate in 2-phase ownership transfer\\n\\n    mapping (address =\\u003e uint256) contributions; //keeps track of ether contributions in Wei of each contributor address\\n    uint256 public startBlock = 4023333; //pre-crowdsale start block (30min ealier than estimate) \\n    uint256 public preEndBlock = 4057233; //pre-crowdsale end block(1h after estimated time)\\n    uint256 public phase1StartBlock = 4066633; //Crowdsale start block (1h earlier)\\n    uint256 public phase1EndBlock = 4100233; //Week 1 end block (estimate)\\n    uint256 public phase2EndBlock = 4133833; //Week 2 end block (estimate)\\n    uint256 public phase3EndBlock = 4201433; //Week 4 end block (2h later)\\n    uint256 public endBlock = 4201433; //whole crowdsale end block\\n    uint256 public crowdsaleTokenSupply = 900000000 * (10**18); //Amount of tokens for sale during crowdsale\\n    uint256 public ecosystemTokenSupply = 100000000 * (10**18); //Tokens for supporting the Opus eco-system, e.g. purchasing music licenses, artist bounties, etc.\\n    uint256 public foundationTokenSupply = 600000000 * (10**18); //Tokens distributed to the Opus foundation, developers and angel investors\\n    uint256 public crowdsaleTokenSold = 0; //Keeps track of the amount of tokens sold during the crowdsale\\n    uint256 public presaleEtherRaised = 0; //Keeps track of the Ether raised during the crowdsale\\n    uint256 public transferLockup = 9600;\\n    bool public halted = false; //Halt crowdsale in emergency\\n    event Halt(); //Halt event\\n    event Unhalt(); //Unhalt event\\n\\n    modifier onlyFoundation() {\\n        //only do if call is from owner modifier\\n        if (msg.sender != foundation) throw;\\n        _;\\n    }\\n\\n    modifier crowdsaleTransferLock() {\\n        // lockup during and after 48h of end of crowdsale\\n        if (block.number \\u003c= endBlock.add(transferLockup)) throw;\\n        _;\\n    }\\n\\n    modifier whenNotHalted() {\\n        // only do when not halted modifier\\n        if (halted) throw;\\n        _;\\n    }\\n\\n    //Constructor: set multisig crowdsale recipient wallet address and fund the foundation\\n    //Initialize total supply and allocate ecosystem \\u0026 foundation tokens\\n  \\tfunction OpusToken() {\\n        foundation = msg.sender;\\n        totalSupply = ecosystemTokenSupply.add(foundationTokenSupply);\\n        balances[foundation] = totalSupply;\\n  \\t}\\n\\n    //Fallback function when receiving Ether.\\n    function() payable {\\n        buy();\\n    }\\n\\n\\n    //Halt ICO in case of emergency.\\n    function halt() onlyFoundation {\\n        halted = true;\\n        Halt();\\n    }\\n\\n    function unhalt() onlyFoundation {\\n        halted = false;\\n        Unhalt();\\n    }\\n\\n    function buy() payable {\\n        buyRecipient(msg.sender);\\n    }\\n\\n    //Allow addresses to buy token for another account\\n    function buyRecipient(address recipient) public payable whenNotHalted {\\n        if(msg.value == 0) throw;\\n        if(!(preCrowdsaleOn()||crowdsaleOn())) throw;//only allows during presale/crowdsale\\n        if(contributions[recipient].add(msg.value)\\u003eperAddressCap()) throw;//per address cap\\n        uint256 tokens = msg.value.mul(returnRate()); //decimals=18, so no need to adjust for unit\\n        if(crowdsaleTokenSold.add(tokens)\\u003ecrowdsaleTokenSupply) throw;//max supply limit\\n\\n        balances[recipient] = balances[recipient].add(tokens);\\n        totalSupply = totalSupply.add(tokens);\\n        presaleEtherRaised = presaleEtherRaised.add(msg.value);\\n        contributions[recipient] = contributions[recipient].add(msg.value);\\n        crowdsaleTokenSold = crowdsaleTokenSold.add(tokens);\\n        if(crowdsaleTokenSold == crowdsaleTokenSupply){\\n        //If crowdsale token sold out, end crowdsale\\n            if(block.number \\u003c preEndBlock) {\\n                preEndBlock = block.number;\\n            }\\n            endBlock = block.number;\\n        }\\n        if (!multisig.send(msg.value)) throw; //immediately send Ether to multisig address\\n        Transfer(this, recipient, tokens);\\n    }\\n\\n    //Burns the specified amount of tokens from the foundation\\n    //Used to burn unspent funds in foundation DAO\\n    function burn(uint256 _value) external onlyFoundation returns (bool) {\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        totalSupply = totalSupply.sub(_value);\\n        Transfer(msg.sender, address(0), _value);\\n        return true;\\n    }\\n\\n    //2-phase ownership transfer;\\n    //prevent transferring ownership to non-existent addresses by accident.\\n    function proposeFoundationTransfer(address newFoundation) external onlyFoundation {\\n        //propose new owner\\n        candidate = newFoundation;\\n    }\\n\\n    function cancelFoundationTransfer() external onlyFoundation {\\n        candidate = address(0);\\n    }\\n\\n    function acceptFoundationTransfer() external {\\n        //new owner accept transfer to complete transfer\\n        if(msg.sender != candidate) throw;\\n        foundation = candidate;\\n        candidate = address(0);\\n    }\\n\\n    //Allow to change the recipient multisig address\\n    function setMultisig(address addr) external onlyFoundation {\\n      \\tif (addr == address(0)) throw;\\n      \\tmultisig = addr;\\n    }\\n\\n    function transfer(address _to, uint256 _value, bytes _data) public crowdsaleTransferLock returns (bool success) {\\n        return super.transfer(_to, _value, _data);\\n    }\\n\\n\\t  function transfer(address _to, uint256 _value) public crowdsaleTransferLock {\\n        super.transfer(_to, _value);\\n\\t  }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) public crowdsaleTransferLock {\\n        super.transferFrom(_from, _to, _value);\\n    }\\n\\n    //Return rate of token against ether.\\n    function returnRate() public constant returns(uint256) {\\n        if (block.number\\u003e=startBlock \\u0026\\u0026 block.number\\u003c=preEndBlock) return 8888; //Pre-crowdsale\\n        if (block.number\\u003e=phase1StartBlock \\u0026\\u0026 block.number\\u003c=phase1EndBlock) return 8000; //Crowdsale phase1\\n        if (block.number\\u003ephase1EndBlock \\u0026\\u0026 block.number\\u003c=phase2EndBlock) return 7500; //Phase2\\n        if (block.number\\u003ephase2EndBlock \\u0026\\u0026 block.number\\u003c=phase3EndBlock) return 7000; //Phase3\\n    }\\n\\n    //per address cap in Wei: 1000 ether + 1% of ether received at the given time.\\n    function perAddressCap() public constant returns(uint256) {\\n        uint256 baseline = 1000 * (10**18);\\n        return baseline.add(presaleEtherRaised.div(100));\\n    }\\n\\n    function preCrowdsaleOn() public constant returns (bool) {\\n        //return whether presale is on according to block number\\n        return (block.number\\u003e=startBlock \\u0026\\u0026 block.number\\u003c=preEndBlock);\\n    }\\n\\n    function crowdsaleOn() public constant returns (bool) {\\n        //return whether crowdsale is on according to block number\\n        return (block.number\\u003e=phase1StartBlock \\u0026\\u0026 block.number\\u003c=endBlock);\\n    }\\n\\n\\n    function getEtherRaised() external constant returns (uint256) {\\n        //getter function for etherRaised\\n        return presaleEtherRaised;\\n    }\\n\\n    function getTokenSold() external constant returns (uint256) {\\n        //getter function for crowdsaleTokenSold\\n        return crowdsaleTokenSold;\\n    }\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.25;\\r\\n\\r\\n/*\\r\\n * Ownable\\r\\n *\\r\\n * Base contract with an owner.\\r\\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\\r\\n * Provides onlyOwnerOrApi modifier, which prevents function from running if it is called by other than above OR from one API code.\\r\\n * Provides onlyOwnerOrApiOrContract modifier, which prevents function from running if it is called by other than above OR one smart contract code.\\r\\n */\\r\\ncontract Ownable {\\r\\n    address public superOwnerAddr;\\r\\n    address public ownerAddr;\\r\\n    mapping(address =\\u003e bool) public ApiAddr; // list of allowed api\\u0027s\\r\\n    mapping(address =\\u003e bool) public ContractAddr; // list of allowed contracts\\r\\n\\r\\n    constructor() public {\\r\\n        superOwnerAddr = 0x74503e1f191292F70622Fb1293E1cEBf771Beacb;\\r\\n        ownerAddr = msg.sender;\\r\\n        ApiAddr[0xCa5aBb22955f99c4D851Cae0FF0c2d8988b4AFcf] = true;\\r\\n    }\\r\\n\\r\\n    modifier onlySuperOwner() {\\r\\n        require(msg.sender == superOwnerAddr, \\\"Access denied for this address. It has to be a superOwner.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == ownerAddr, \\\"Access denied for this address. It has to be an owner.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwnerOrApi() {\\r\\n        require(msg.sender == ownerAddr || ApiAddr[msg.sender] == true, \\\"Access denied for this address. It has to be an owner or api.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwnerOrApiOrContract() {\\r\\n        require(msg.sender == ownerAddr || ApiAddr[msg.sender] == true || ContractAddr[msg.sender] == true, \\\"Access denied for this address. It has to be an owner or api or allowed contract.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_period\",\"type\":\"uint256\"},{\"name\":\"_hash\",\"type\":\"string\"}],\"name\":\"addPlayStat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disabled\",\"type\":\"bool\"}],\"name\":\"disableApiAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ApiAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setContractEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superOwnerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ContractAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addContractAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeContractAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addApiAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeApiAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PlayStats\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"opt\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendOpt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setOwnerAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getOptFromApproved\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"apiAccessDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"string\"}],\"name\":\"LogPlayStatAdded\",\"type\":\"event\"}]","ContractName":"OpusOperations","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d7fa63fa700d5b8309b273cbd816ad3acbee553126dbcc1f61d1cf9d1b7559cd"}]}