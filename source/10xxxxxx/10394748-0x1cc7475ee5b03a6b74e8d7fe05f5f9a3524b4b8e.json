{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n// ============================================================================\r\n// External functions/types used by this contract\r\n// ============================================================================\r\n\r\ninterface ERC20 {\r\n  function balanceOf(address account) external returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount)\r\n    external returns (bool);\r\n}\r\n\r\ninterface ERC721 {\r\n  function transferFrom( address _from, address _to, uint256 _tokenId )\r\n    external payable;\r\n}\r\n\r\n// ============================================================================\r\n// Admin:\r\n//  - cannot interfere with, change or stop any listing\r\n//  - adds known ERC20s to an 'approved tokens' list\r\n//  - sets and adjusts fees\r\n//  - receives excess ether (fees) and accidental transfers of ETH or tokens\r\n//  - cannot help victims of fraud or accidental misuse of this contract\r\n// ============================================================================\r\n\r\ncontract HasAdmin {\r\n  address payable public admin_;\r\n\r\n  modifier isAdmin {\r\n    if (msg.sender != admin_) { revert(\"must be admin\"); }\r\n    _;\r\n  }\r\n\r\n  constructor() public { admin_ = msg.sender; }\r\n\r\n  function setAdmin( address payable newadmin ) public isAdmin {\r\n    admin_ = newadmin;\r\n  }\r\n}\r\n\r\n// ****************************************************************************\r\n// Simple Ethereum Xchange roBot (S*E*X*Bot)\r\n//\r\n// Notes:\r\n// 1. DO NOT do a simple Ether transfer to this contract - use the functions\r\n// 2. Same for tokens: DO NOT transfer() tokens directly to this contract\r\n// 3. There is no rate feed/oracle - clients must manage listings carefully.\r\n// 4. All software has bugs and smart contracts are difficult to get right.\r\n//    No warranties, use at own risk.\r\n// 5. Scams happen. Buyer is solely responsible to verify listing details.\r\n//\r\n// ****************************************************************************\r\n\r\ncontract SEXBot is HasAdmin {\r\n\r\n  event Made( bytes32 indexed id, address indexed seller );\r\n  event Taken( bytes32 indexed id, address indexed buyer );\r\n  event Canceled( bytes32 indexed id );\r\n  event Updated( bytes32 indexed id );\r\n\r\n  // list of well-known ERC20s tokens this contract accepts\r\n  address[] public tokenSCAs;\r\n  mapping( address => bool ) public safelist;\r\n\r\n  // NOTE: a token value of address(0) indicates Ether\r\n  struct Listing {\r\n    address payable seller;\r\n    uint256 sellunits;\r\n    address selltoken;\r\n    uint256 askunits;\r\n    address asktoken;\r\n  }\r\n\r\n  mapping( bytes32 => Listing ) public listings;\r\n\r\n  uint256 public makerfee;\r\n  uint256 public updatefee;\r\n  uint256 public cancelfee;\r\n  uint256 public takerfee;\r\n  uint256 public counter;\r\n\r\n  string public clientIPFSHash;\r\n\r\n  bytes4 magic; // required return value from onERC721Received() function\r\n\r\n  function make( uint256 _sellunits,\r\n                 address _selltok,\r\n                 uint256 _askunits,\r\n                 address _asktok ) public payable returns (bytes32) {\r\n\r\n    require( safelist[_selltok], \"unrecognized sell token\" );\r\n    require( safelist[_asktok], \"unrecognized ask token\" );\r\n\r\n    if (_selltok == address(0)) { // ETH\r\n      require( _sellunits + makerfee >= _sellunits, \"safemath: bad arg\" );\r\n      require( msg.value >= _sellunits + makerfee, \"insufficient fee\" );\r\n      admin_.transfer( msg.value - _sellunits );\r\n    }\r\n    else {\r\n      ERC20 tok = ERC20(_selltok);\r\n      require( tok.transferFrom(msg.sender, address(this), _sellunits),\r\n               \"failed transferFrom()\" );\r\n      admin_.transfer( msg.value );\r\n    }\r\n\r\n    bytes32 id = keccak256( abi.encodePacked(\r\n      counter++, now, msg.sender, _sellunits, _selltok, _askunits, _asktok) );\r\n\r\n    listings[id] =\r\n      Listing( msg.sender, _sellunits, _selltok, _askunits, _asktok );\r\n\r\n    emit Made( id, msg.sender );\r\n    return id;\r\n  }\r\n\r\n  function take( bytes32 _id ) public payable {\r\n\r\n    require( listings[_id].seller != address(0), \"listing unavailable\" );\r\n\r\n    // receive payment:\r\n    //   asktoken => this\r\n    //   takerfee => admin\r\n\r\n    if (listings[_id].asktoken == address(0)) { // ETH\r\n      require( msg.value >= listings[_id].askunits + takerfee, \"low value\" );\r\n      admin_.transfer( msg.value - listings[_id].askunits );\r\n    }\r\n    else {\r\n      require( ERC20( listings[_id].asktoken )\r\n               .transferFrom(msg.sender, address(this), listings[_id].askunits),\r\n               \"transferFrom() failed\" );\r\n      admin_.transfer( msg.value );\r\n    }\r\n\r\n    // delivery:\r\n    //   selltoken => msg.sender\r\n    //   asktoken => seller\r\n\r\n    if (listings[_id].selltoken == address(0)) { // ETH\r\n      msg.sender.transfer( listings[_id].sellunits );\r\n    }\r\n    else {\r\n      ERC20( listings[_id].selltoken )\r\n      .transfer( msg.sender, listings[_id].sellunits );\r\n    }\r\n\r\n    if (listings[_id].asktoken == address(0)) { // ETH\r\n      listings[_id].seller.transfer( listings[_id].askunits );\r\n    }\r\n    else {\r\n      ERC20( listings[_id].asktoken )\r\n      .transfer( listings[_id].seller, listings[_id].askunits );\r\n    }\r\n\r\n    listings[_id].seller = address(0);\r\n    emit Taken( _id, msg.sender );\r\n  }\r\n\r\n  function update( bytes32 _id, uint256 _askunits, address _asktok )\r\n  public payable {\r\n    require( msg.sender == listings[_id].seller, \"must be seller\" );\r\n    require( msg.value >= updatefee, \"insufficient fee to update\" );\r\n    require( safelist[_asktok], \"unrecognized ask token\" );\r\n\r\n    listings[_id].askunits = _askunits;\r\n    listings[_id].asktoken = _asktok;\r\n\r\n    admin_.transfer( msg.value );\r\n    emit Updated( _id );\r\n  }\r\n\r\n  function cancel( bytes32 _id ) public payable {\r\n    require( msg.sender == listings[_id].seller, \"must be seller\" );\r\n    require( msg.value >= cancelfee, \"insufficient fee to cancel\" );\r\n\r\n    if (listings[_id].selltoken == address(0)) {\r\n      listings[_id].seller.transfer( listings[_id].sellunits );\r\n    }\r\n    else {\r\n      ERC20 tok = ERC20( listings[_id].selltoken );\r\n      tok.transfer( msg.sender, listings[_id].sellunits );\r\n    }\r\n\r\n    listings[_id].seller = address(0); // mark as canceled\r\n    admin_.transfer( msg.value );\r\n    emit Canceled( _id );\r\n  }\r\n\r\n  // =========================================================================\r\n  // Admin and internal functions\r\n  // =========================================================================\r\n\r\n  constructor( uint256 _mf, uint256 _uf, uint256 _cf, uint256 _tf ) public {\r\n    tokenSCAs.push( address(0) );\r\n    safelist[address(0)] = true;\r\n\r\n    makerfee = _mf;\r\n    updatefee = _uf;\r\n    cancelfee = _cf;\r\n    takerfee = _tf;\r\n\r\n    magic = bytes4( keccak256(\r\n      abi.encodePacked(\"onERC721Received(address,address,uint256,bytes)\")) );\r\n  }\r\n\r\n  function setFee( uint8 _which, uint256 _amtwei ) public isAdmin {\r\n    if (_which == uint8(0)) makerfee = _amtwei;\r\n    else if (_which == uint8(1)) updatefee = _amtwei;\r\n    else if (_which == uint8(2)) cancelfee = _amtwei;\r\n    else if (_which == uint8(3)) takerfee = _amtwei;\r\n    else revert( \"invalid fee specified\" );\r\n  }\r\n\r\n  function tokenCount() public view returns (uint256) {\r\n    return tokenSCAs.length;\r\n  }\r\n\r\n  function listToken( address _toksca, bool _stat ) public isAdmin {\r\n    tokenSCAs.push( _toksca );\r\n    safelist[_toksca] = _stat;\r\n  }\r\n\r\n  function setClient( string memory _client ) public isAdmin {\r\n    clientIPFSHash = _client;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Remaining logic attempts to capture accidental donations of ether or\r\n  // certain token types\r\n  // =========================================================================\r\n\r\n  // if caller sends ether and leaves calldata blank\r\n  receive() external payable {\r\n    admin_.transfer( msg.value );\r\n  }\r\n\r\n  // called if calldata has a value that does not match a function\r\n  fallback() external payable {\r\n    admin_.transfer( msg.value );\r\n  }\r\n\r\n  // ERC721 (NFT) transfer callback\r\n  function onERC721Received( address _operator,\r\n                             address _from,\r\n                             uint256 _tokenId,\r\n                             bytes calldata _data) external returns(bytes4) {\r\n    if (   _operator == address(0x0)\r\n        || _from == address(0x0)\r\n        || _data.length > 0 ) {} // suppress warnings unused params\r\n\r\n    ERC721(msg.sender).transferFrom( address(this), admin_, _tokenId );\r\n    return magic;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mf\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_uf\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cf\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tf\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Canceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"Made\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"Taken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Updated\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin_\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clientIPFSHash\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"counter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toksca\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_stat\",\"type\":\"bool\"}],\"name\":\"listToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"listings\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellunits\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"selltoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"askunits\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"asktoken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sellunits\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_selltok\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_askunits\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_asktok\",\"type\":\"address\"}],\"name\":\"make\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makerfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"safelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newadmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_client\",\"type\":\"string\"}],\"name\":\"setClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_which\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_amtwei\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"take\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takerfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSCAs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_askunits\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_asktok\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatefee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SEXBot","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000001c6bf5263400000000000000000000000000000000000000000000000000000005af3107a400000000000000000000000000000000000000000000000000000005af3107a40000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e5e9972ed08a4569d2c54e8ce4652dfb3f27255819aac795b8bcae8637b4b8b5"}]}