{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\ninterface IERC20 {\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n}\r\n\r\ninterface IKyberReserve {\r\n    function trade(\r\n        IERC20 srcToken,\r\n        uint256 srcAmount,\r\n        IERC20 destToken,\r\n        address payable destAddress,\r\n        uint256 conversionRate,\r\n        bool validate\r\n    ) external payable returns (bool);\r\n\r\n    function getConversionRate(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 blockNumber\r\n    ) external view returns (uint256);\r\n}\r\n\r\ncontract PermissionGroups2 {\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address => bool) internal operators;\r\n    address[] internal operatorsGroup;\r\n\r\n    constructor(address _admin) public {\r\n        require(_admin != address(0), \"Admin 0\");\r\n        admin = _admin;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Only admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender], \"Only operator\");\r\n        _;\r\n    }\r\n\r\n    function getOperators() external view returns (address[] memory) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0), \"New admin 0\");\r\n        emit TransferAdminPending(newAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0), \"Admin 0\");\r\n        emit TransferAdminPending(newAdmin);\r\n        emit AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed(address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender, \"not pending\");\r\n        emit AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator], \"Operator exists\"); // prevent duplicates.\r\n\r\n        emit OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator(address operator) public onlyAdmin {\r\n        require(operators[operator], \"Not operator\");\r\n        operators[operator] = false;\r\n\r\n        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.pop();\r\n                emit OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Withdrawable2 is PermissionGroups2 {\r\n    constructor(address _admin) public PermissionGroups2(_admin) {}\r\n\r\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all IERC20 compatible tokens\r\n     * @param token IERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address sendTo\r\n    ) external onlyAdmin {\r\n        token.transfer(sendTo, amount);\r\n        emit TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint256 amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint256 amount, address payable sendTo)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        (bool success, ) = sendTo.call.value(amount)(\"\");\r\n        require(success);\r\n        emit EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n\r\ncontract RateHelper is Withdrawable2 {\r\n\r\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n    );\r\n\r\n    IKyberReserve public uniswapReserve;\r\n    IKyberReserve public oasisReserve;\r\n    // support token -> ETH trade\r\n    mapping(address => IKyberReserve[]) public srcTokenReserves;\r\n    // support ETH -> token trade\r\n    mapping(address => IKyberReserve[]) public destTokenReserves;\r\n\r\n    constructor(address uniswap, address oasis) public Withdrawable2(msg.sender) {\r\n        addOperator(msg.sender);\r\n        uniswapReserve = IKyberReserve(uniswap);\r\n        oasisReserve = IKyberReserve(oasis);\r\n    }\r\n\r\n    function setSrcTokenReserves(address token, IKyberReserve[] memory reserves) public onlyOperator {\r\n        srcTokenReserves[token] = reserves;\r\n    }\r\n\r\n    function setDestTokenReserves(address token, IKyberReserve[] memory reserves) public onlyOperator {\r\n        destTokenReserves[token] = reserves;\r\n    }\r\n\r\n    function setBridgeReserves(address _uniswap, address _oasis) public onlyOperator {\r\n        uniswapReserve = IKyberReserve(_uniswap);\r\n        oasisReserve = IKyberReserve(_oasis);\r\n    }\r\n\r\n    /// @dev return expected rates (ETH -> token) given list of amounts\r\n    ///      exclude uniswap or oasis reserves if needed\r\n    ///      if isBuy, amount is in ETH, otherwise amount is in token\r\n    function getExpectedRates(IERC20 token, uint[] memory amounts, bool isExcludeUni, bool isExcludeOasis, uint blockNumber, bool isBuy)\r\n        public view returns(uint[] memory rates)\r\n    {\r\n        rates = new uint[](amounts.length);\r\n        IERC20 src = isBuy ? ETH_TOKEN_ADDRESS : token;\r\n        IERC20 dest = isBuy ? token : ETH_TOKEN_ADDRESS;\r\n        IKyberReserve[] memory reserves = isBuy ? destTokenReserves[address(token)] : srcTokenReserves[address(token)];\r\n        for(uint i = 0; i < amounts.length; i++) {\r\n            rates[i] = 0;\r\n            for(uint j = 0; j < reserves.length; j++) {\r\n                if (isExcludeUni && reserves[j] == uniswapReserve) { continue; }\r\n                if (isExcludeOasis && reserves[j] == oasisReserve) { continue; }\r\n                uint expectedRate = reserves[j].getConversionRate(src, dest, amounts[i], blockNumber);\r\n                // get max rate\r\n                if (rates[i] < expectedRate) { rates[i] = expectedRate; }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev isUniswap = true: get rate from uniswap bridge, otherwise get rate from oasis reserve\r\n    function getBridgeReserveRates(IERC20 token, uint[] memory amounts, uint blockNumber, bool isBuy, bool isUniswap)\r\n        public view returns(uint[] memory rates)\r\n    {\r\n        rates = new uint[](amounts.length);\r\n        IERC20 src = isBuy ? ETH_TOKEN_ADDRESS : token;\r\n        IERC20 dest = isBuy ? token : ETH_TOKEN_ADDRESS;\r\n        IKyberReserve reserve = isUniswap ? uniswapReserve : oasisReserve;\r\n        for(uint i = 0; i < rates.length; i++) {\r\n            rates[i] = reserve.getConversionRate(src, dest, amounts[i], blockNumber);\r\n        }\r\n    }\r\n\r\n    // return Kyber's rate excludes uniswap + oasis\r\n    // return uniswap rates\r\n    // return oasis rates\r\n    function getCombinedRates(IERC20 token, uint[] memory amounts, uint blockNumber, bool isBuy)\r\n        public view returns(uint[] memory rates, uint[] memory uniswapRates, uint[] memory oasisRates)\r\n    {\r\n        rates = new uint[](amounts.length);\r\n        uniswapRates = new uint[](amounts.length);\r\n        oasisRates = new uint[](amounts.length);\r\n        IERC20 src = isBuy ? ETH_TOKEN_ADDRESS : token;\r\n        IERC20 dest = isBuy ? token : ETH_TOKEN_ADDRESS;\r\n        IKyberReserve[] memory reserves = isBuy ? destTokenReserves[address(token)] : srcTokenReserves[address(token)];\r\n        for(uint i = 0; i < amounts.length; i++) {\r\n            rates[i] = 0;\r\n            uniswapRates[i] = 0;\r\n            oasisRates[i] = 0;\r\n            for(uint j = 0; j < reserves.length; j++) {\r\n                uint expectedRate = reserves[j].getConversionRate(src, dest, amounts[i], blockNumber);\r\n                if (reserves[j] == uniswapReserve) {\r\n                    uniswapRates[i] = expectedRate;\r\n                } else if (reserves[j] == oasisReserve) {\r\n                    oasisRates[i] = expectedRate;\r\n                } else {\r\n                    if (rates[i] < expectedRate) { rates[i] = expectedRate; }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"srcTokenReserves\",\"outputs\":[{\"internalType\":\"contract IKyberReserve\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract IKyberReserve[]\",\"name\":\"reserves\",\"type\":\"address[]\"}],\"name\":\"setSrcTokenReserves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract IKyberReserve[]\",\"name\":\"reserves\",\"type\":\"address[]\"}],\"name\":\"setDestTokenReserves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"destTokenReserves\",\"outputs\":[{\"internalType\":\"contract IKyberReserve\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"isExcludeUni\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isExcludeOasis\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"}],\"name\":\"getExpectedRates\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswap\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oasis\",\"type\":\"address\"}],\"name\":\"setBridgeReserves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isUniswap\",\"type\":\"bool\"}],\"name\":\"getBridgeReserveRates\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"}],\"name\":\"getCombinedRates\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"uniswapRates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"oasisRates\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oasisReserve\",\"outputs\":[{\"internalType\":\"contract IKyberReserve\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapReserve\",\"outputs\":[{\"internalType\":\"contract IKyberReserve\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswap\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oasis\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]","ContractName":"RateHelper","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000031e085afd48a1d6e51cc193153d625e8f0514c7f0000000000000000000000001e158c0e93c30d24e918ef83d1e0be23595c3c0f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4dc8010e742d9fbfe8cb01c1cf31fec6ebbd2da9a1675330db4fc62e86c88c9b"}]}