{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nabstract contract StaticV2 {\r\n\r\n    enum Method { Boost, Repay }\r\n\r\n    struct CdpHolder {\r\n        uint128 minRatio;\r\n        uint128 maxRatio;\r\n        uint128 optimalRatioBoost;\r\n        uint128 optimalRatioRepay;\r\n        address owner;\r\n        uint cdpId;\r\n        bool boostEnabled;\r\n        bool nextPriceEnabled;\r\n    }\r\n\r\n    struct SubPosition {\r\n        uint arrPos;\r\n        bool subscribed;\r\n    }\r\n}\r\n\r\nabstract contract ISubscriptionsV2 is StaticV2 {\r\n\r\n    function getOwner(uint _cdpId) external view virtual returns(address);\r\n    function getSubscribedInfo(uint _cdpId) public view virtual returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt);\r\n    function getCdpHolder(uint _cdpId) public view virtual returns (bool subscribed, CdpHolder memory);\r\n} \r\n\r\nabstract contract DSProxyInterface {\r\n    function execute(address _target, bytes memory _data) public virtual payable returns (bytes32);\r\n    function owner() public virtual returns (address);\r\n} \r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function decimals() external view returns (uint256 digits);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n} \r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     */\r\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function _callOptionalReturn(ERC20 token, bytes memory data) private {\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n} \r\n\r\n\r\ncontract AdminAuth {\r\n\r\n    using SafeERC20 for ERC20;\r\n\r\n    address public owner;\r\n    address public admin;\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @notice Admin is set by owner first time, after that admin is super role and has permission to change owner\r\n    /// @param _admin Address of multisig that becomes admin\r\n    function setAdminByOwner(address _admin) public {\r\n        require(msg.sender == owner);\r\n        require(admin == address(0));\r\n\r\n        admin = _admin;\r\n    }\r\n\r\n    /// @notice Admin is able to set new admin\r\n    /// @param _admin Address of multisig that becomes new admin\r\n    function setAdminByAdmin(address _admin) public {\r\n        require(msg.sender == admin);\r\n\r\n        admin = _admin;\r\n    }\r\n\r\n    /// @notice Admin is able to change owner\r\n    /// @param _owner Address of new owner\r\n    function setOwnerByAdmin(address _owner) public {\r\n        require(msg.sender == admin);\r\n\r\n        owner = _owner;\r\n    }\r\n\r\n    /// @notice Destroy the contract\r\n    function kill() public onlyOwner {\r\n        selfdestruct(payable(owner));\r\n    }\r\n\r\n    /// @notice  withdraw stuck funds\r\n    function withdrawStuckFunds(address _token, uint _amount) public onlyOwner {\r\n        if (_token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\r\n            payable(owner).transfer(_amount);\r\n        } else {\r\n            ERC20(_token).safeTransfer(owner, _amount);\r\n        }\r\n    }\r\n} \r\n\r\ncontract MCDMonitorProxyV2 {\r\n    function callExecute(address _owner, address _saverProxy, bytes memory _data) public payable {}\r\n} \r\n\r\ncontract ConstantAddressesMainnet {\r\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\r\n    address public constant AUTOMATIC_LOGGER_ADDRESS = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;\r\n\r\n    // new MCD contracts\r\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\r\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\r\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\r\n}\r\n\r\n\r\ncontract ConstantAddresses is ConstantAddressesMainnet {} \r\n\r\n\r\nabstract contract GasTokenInterface is ERC20 {\r\n    function free(uint256 value) public virtual returns (bool success);\r\n} \r\n\r\ncontract DSMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n\r\n    uint256 constant WAD = 10**18;\r\n    uint256 constant RAY = 10**27;\r\n\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n} \r\n\r\nabstract contract Manager {\r\n    function last(address) virtual public returns (uint);\r\n    function cdpCan(address, uint, address) virtual public view returns (uint);\r\n    function ilks(uint) virtual public view returns (bytes32);\r\n    function owns(uint) virtual public view returns (address);\r\n    function urns(uint) virtual public view returns (address);\r\n    function vat() virtual public view returns (address);\r\n    function open(bytes32, address) virtual public returns (uint);\r\n    function give(uint, address) virtual public;\r\n    function cdpAllow(uint, address, uint) virtual public;\r\n    function urnAllow(address, uint) virtual public;\r\n    function frob(uint, int, int) virtual public;\r\n    function flux(uint, address, uint) virtual public;\r\n    function move(uint, address, uint) virtual public;\r\n    function exit(address, uint, address, uint) virtual public;\r\n    function quit(uint, address) virtual public;\r\n    function enter(address, uint) virtual public;\r\n    function shift(uint, uint) virtual public;\r\n} \r\n\r\nabstract contract Vat {\r\n\r\n    struct Urn {\r\n        uint256 ink;   // Locked Collateral  [wad]\r\n        uint256 art;   // Normalised Debt    [wad]\r\n    }\r\n\r\n    struct Ilk {\r\n        uint256 Art;   // Total Normalised Debt     [wad]\r\n        uint256 rate;  // Accumulated Rates         [ray]\r\n        uint256 spot;  // Price with Safety Margin  [ray]\r\n        uint256 line;  // Debt Ceiling              [rad]\r\n        uint256 dust;  // Urn Debt Floor            [rad]\r\n    }\r\n\r\n    mapping (bytes32 => mapping (address => Urn )) public urns;\r\n    mapping (bytes32 => Ilk)                       public ilks;\r\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\r\n\r\n    function can(address, address) virtual public view returns (uint);\r\n    function dai(address) virtual public view returns (uint);\r\n    function frob(bytes32, address, address, address, int, int) virtual public;\r\n    function hope(address) virtual public;\r\n    function move(address, address, uint) virtual public;\r\n    function fork(bytes32, address, address, int, int) virtual public;\r\n} \r\n\r\nabstract contract PipInterface {\r\n    function read() public virtual returns (bytes32);\r\n} \r\n\r\nabstract contract Spotter {\r\n    struct Ilk {\r\n        PipInterface pip;\r\n        uint256 mat;\r\n    }\r\n\r\n    mapping (bytes32 => Ilk) public ilks;\r\n\r\n    uint256 public par;\r\n\r\n} \r\n\r\ncontract AutomaticLogger {\r\n    event CdpRepay(uint indexed cdpId, address indexed caller, uint amount, uint beforeRatio, uint afterRatio, address logger);\r\n    event CdpBoost(uint indexed cdpId, address indexed caller, uint amount, uint beforeRatio, uint afterRatio, address logger);\r\n\r\n    function logRepay(uint cdpId, address caller, uint amount, uint beforeRatio, uint afterRatio) public {\r\n        emit CdpRepay(cdpId, caller, amount, beforeRatio, afterRatio, msg.sender);\r\n    }\r\n\r\n    function logBoost(uint cdpId, address caller, uint amount, uint beforeRatio, uint afterRatio) public {\r\n        emit CdpBoost(cdpId, caller, amount, beforeRatio, afterRatio, msg.sender);\r\n    }\r\n}\r\n\r\n\r\n/// @title Implements logic that allows bots to call Boost and Repay\r\ncontract MCDMonitorV2 is AdminAuth, ConstantAddresses, DSMath, StaticV2 {\r\n\r\n    uint public REPAY_GAS_TOKEN = 25;\r\n    uint public BOOST_GAS_TOKEN = 25;\r\n\r\n    uint public MAX_GAS_PRICE = 200000000000; // 200 gwei\r\n\r\n    uint public REPAY_GAS_COST = 2000000;\r\n    uint public BOOST_GAS_COST = 2000000;\r\n\r\n    MCDMonitorProxyV2 public monitorProxyContract;\r\n    ISubscriptionsV2 public subscriptionsContract;\r\n    GasTokenInterface gasToken = GasTokenInterface(GAS_TOKEN_INTERFACE_ADDRESS);\r\n    address public automaticSaverProxyAddress;\r\n\r\n    Manager public manager = Manager(MANAGER_ADDRESS);\r\n    Vat public vat = Vat(VAT_ADDRESS);\r\n    Spotter public spotter = Spotter(SPOTTER_ADDRESS);\r\n    AutomaticLogger public logger = AutomaticLogger(AUTOMATIC_LOGGER_ADDRESS);\r\n\r\n    /// @dev Addresses that are able to call methods for repay and boost\r\n    mapping(address => bool) public approvedCallers;\r\n\r\n    modifier onlyApproved() {\r\n        require(approvedCallers[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    constructor(address _monitorProxy, address _subscriptions, address _automaticSaverProxyAddress) public {\r\n        approvedCallers[msg.sender] = true;\r\n        approvedCallers[0xAED662abcC4FA3314985E67Ea993CAD064a7F5cF] = true;\r\n        approvedCallers[0xa5d330F6619d6bF892A5B87D80272e1607b3e34D] = true;\r\n        approvedCallers[0x5feB4DeE5150B589a7f567EA7CADa2759794A90A] = true;\r\n        approvedCallers[0x7ca06417c1d6f480d3bB195B80692F95A6B66158] = true;\r\n\r\n        monitorProxyContract = MCDMonitorProxyV2(_monitorProxy);\r\n        subscriptionsContract = ISubscriptionsV2(_subscriptions);\r\n        automaticSaverProxyAddress = _automaticSaverProxyAddress;\r\n    }\r\n\r\n    /// @notice Bots call this method to repay for user when conditions are met\r\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\r\n    /// @param _data Array of uints representing [cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice]\r\n    /// @param _nextPrice Next price in Maker protocol\r\n    /// @param _joinAddr Address of collateral join for specific CDP\r\n    /// @param _exchangeAddress Address to call 0x exchange\r\n    /// @param _callData Bytes representing call data for 0x exchange\r\n    function repayFor(\r\n        uint[6] memory _data, // cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice\r\n        uint256 _nextPrice,\r\n        address _joinAddr,\r\n        address _exchangeAddress,\r\n        bytes memory _callData\r\n    ) public payable onlyApproved {\r\n        if (gasToken.balanceOf(address(this)) >= REPAY_GAS_TOKEN) {\r\n            gasToken.free(REPAY_GAS_TOKEN);\r\n        }\r\n\r\n        uint ratioBefore;\r\n        bool isAllowed;\r\n        (isAllowed, ratioBefore) = canCall(Method.Repay, _data[0], _nextPrice);\r\n        require(isAllowed);\r\n\r\n        uint gasCost = calcGasCost(REPAY_GAS_COST);\r\n        _data[4] = gasCost;\r\n\r\n        monitorProxyContract.callExecute{value: msg.value}(subscriptionsContract.getOwner(_data[0]), automaticSaverProxyAddress, abi.encodeWithSignature(\"automaticRepay(uint256[6],address,address,bytes)\", _data, _joinAddr, _exchangeAddress, _callData));\r\n\r\n        uint ratioAfter;\r\n        bool isGoodRatio;\r\n        (isGoodRatio, ratioAfter) = ratioGoodAfter(Method.Repay, _data[0], _nextPrice);\r\n        // doesn't allow user to repay too much\r\n        require(isGoodRatio);\r\n\r\n        returnEth();\r\n\r\n        logger.logRepay(_data[0], msg.sender, _data[1], ratioBefore, ratioAfter);\r\n    }\r\n\r\n    /// @notice Bots call this method to boost for user when conditions are met\r\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\r\n    /// @param _data Array of uints representing [cdpId, collateralAmount, minPrice, exchangeType, gasCost, 0xPrice]\r\n    /// @param _nextPrice Next price in Maker protocol\r\n    /// @param _joinAddr Address of collateral join for specific CDP\r\n    /// @param _exchangeAddress Address to call 0x exchange\r\n    /// @param _callData Bytes representing call data for 0x exchange\r\n    function boostFor(\r\n        uint[6] memory _data, // cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice\r\n        uint256 _nextPrice,\r\n        address _joinAddr,\r\n        address _exchangeAddress,\r\n        bytes memory _callData\r\n    ) public payable onlyApproved {\r\n        if (gasToken.balanceOf(address(this)) >= BOOST_GAS_TOKEN) {\r\n            gasToken.free(BOOST_GAS_TOKEN);\r\n        }\r\n\r\n        uint ratioBefore;\r\n        bool isAllowed;\r\n        (isAllowed, ratioBefore) = canCall(Method.Boost, _data[0], _nextPrice);\r\n        require(isAllowed);\r\n\r\n        uint gasCost = calcGasCost(BOOST_GAS_COST);\r\n        _data[4] = gasCost;\r\n\r\n        monitorProxyContract.callExecute{value: msg.value}(subscriptionsContract.getOwner(_data[0]), automaticSaverProxyAddress, abi.encodeWithSignature(\"automaticBoost(uint256[6],address,address,bytes)\", _data, _joinAddr, _exchangeAddress, _callData));\r\n\r\n        uint ratioAfter;\r\n        bool isGoodRatio;\r\n        (isGoodRatio, ratioAfter) = ratioGoodAfter(Method.Boost, _data[0], _nextPrice);\r\n        // doesn't allow user to boost too much\r\n        require(isGoodRatio);\r\n\r\n        returnEth();\r\n\r\n        logger.logBoost(_data[0], msg.sender, _data[1], ratioBefore, ratioAfter);\r\n    }\r\n\r\n/******************* INTERNAL METHODS ********************************/\r\n    function returnEth() internal {\r\n        // return if some eth left\r\n        if (address(this).balance > 0) {\r\n            msg.sender.transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n/******************* STATIC METHODS ********************************/\r\n\r\n    /// @notice Returns an address that owns the CDP\r\n    /// @param _cdpId Id of the CDP\r\n    function getOwner(uint _cdpId) public view returns(address) {\r\n        return manager.owns(_cdpId);\r\n    }\r\n\r\n    /// @notice Gets CDP info (collateral, debt)\r\n    /// @param _cdpId Id of the CDP\r\n    /// @param _ilk Ilk of the CDP\r\n    function getCdpInfo(uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\r\n        address urn = manager.urns(_cdpId);\r\n\r\n        (uint collateral, uint debt) = vat.urns(_ilk, urn);\r\n        (,uint rate,,,) = vat.ilks(_ilk);\r\n\r\n        return (collateral, rmul(debt, rate));\r\n    }\r\n\r\n    /// @notice Gets a price of the asset\r\n    /// @param _ilk Ilk of the CDP\r\n    function getPrice(bytes32 _ilk) public view returns (uint) {\r\n        (, uint mat) = spotter.ilks(_ilk);\r\n        (,,uint spot,,) = vat.ilks(_ilk);\r\n\r\n        return rmul(rmul(spot, spotter.par()), mat);\r\n    }\r\n\r\n    /// @notice Gets CDP ratio\r\n    /// @param _cdpId Id of the CDP\r\n    /// @param _nextPrice Next price for user\r\n    function getRatio(uint _cdpId, uint _nextPrice) public view returns (uint) {\r\n        bytes32 ilk = manager.ilks(_cdpId);\r\n        uint price = (_nextPrice == 0) ? getPrice(ilk) : _nextPrice;\r\n\r\n        (uint collateral, uint debt) = getCdpInfo(_cdpId, ilk);\r\n\r\n        if (debt == 0) return 0;\r\n\r\n        return rdiv(wmul(collateral, price), debt) / (10 ** 18);\r\n    }\r\n\r\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\r\n    /// @dev Called by MCDMonitor to enforce the min/max check\r\n    function canCall(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\r\n        bool subscribed;\r\n        CdpHolder memory holder;\r\n        (subscribed, holder) = subscriptionsContract.getCdpHolder(_cdpId);\r\n\r\n        // check if cdp is subscribed\r\n        if (!subscribed) return (false, 0);\r\n\r\n        // check if using next price is allowed\r\n        if (_nextPrice > 0 && !holder.nextPriceEnabled) return (false, 0);\r\n\r\n        // check if boost and boost allowed\r\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\r\n\r\n        // check if owner is still owner\r\n        if (getOwner(_cdpId) != holder.owner) return (false, 0);\r\n\r\n        uint currRatio = getRatio(_cdpId, _nextPrice);\r\n\r\n        if (_method == Method.Repay) {\r\n            return (currRatio < holder.minRatio, currRatio);\r\n        } else if (_method == Method.Boost) {\r\n            return (currRatio > holder.maxRatio, currRatio);\r\n        }\r\n    }\r\n\r\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\r\n    function ratioGoodAfter(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\r\n        CdpHolder memory holder;\r\n\r\n        (, holder) = subscriptionsContract.getCdpHolder(_cdpId);\r\n\r\n        uint currRatio = getRatio(_cdpId, _nextPrice);\r\n\r\n        if (_method == Method.Repay) {\r\n            return (currRatio < holder.maxRatio, currRatio);\r\n        } else if (_method == Method.Boost) {\r\n            return (currRatio > holder.minRatio, currRatio);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates gas cost (in Eth) of tx\r\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\r\n    /// @param _gasAmount Amount of gas used for the tx\r\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\r\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\r\n\r\n        return mul(gasPrice, _gasAmount);\r\n    }\r\n\r\n/******************* OWNER ONLY OPERATIONS ********************************/\r\n\r\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\r\n    /// @param _gasCost New gas cost for boost method\r\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\r\n        require(_gasCost < 3000000);\r\n\r\n        BOOST_GAS_COST = _gasCost;\r\n    }\r\n\r\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\r\n    /// @param _gasCost New gas cost for repay method\r\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\r\n        require(_gasCost < 3000000);\r\n\r\n        REPAY_GAS_COST = _gasCost;\r\n    }\r\n\r\n    /// @notice Allows owner to change max gas price\r\n    /// @param _maxGasPrice New max gas price\r\n    function changeMaxGasPrice(uint _maxGasPrice) public onlyOwner {\r\n        require(_maxGasPrice < 500000000000);\r\n\r\n        MAX_GAS_PRICE = _maxGasPrice;\r\n    }\r\n\r\n    /// @notice Allows owner to change the amount of gas token burned per function call\r\n    /// @param _gasAmount Amount of gas token\r\n    /// @param _isRepay Flag to know for which function we are setting the gas token amount\r\n    function changeGasTokenAmount(uint _gasAmount, bool _isRepay) public onlyOwner {\r\n        if (_isRepay) {\r\n            REPAY_GAS_TOKEN = _gasAmount;\r\n        } else {\r\n            BOOST_GAS_TOKEN = _gasAmount;\r\n        }\r\n    }\r\n\r\n    /// @notice Adds a new bot address which will be able to call repay/boost\r\n    /// @param _caller Bot address\r\n    function addCaller(address _caller) public onlyOwner {\r\n        approvedCallers[_caller] = true;\r\n    }\r\n\r\n    /// @notice Removes a bot address so it can't call repay/boost\r\n    /// @param _caller Bot address\r\n    function removeCaller(address _caller) public onlyOwner {\r\n        approvedCallers[_caller] = false;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_monitorProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_subscriptions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_automaticSaverProxyAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AUTOMATIC_LOGGER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOST_GAS_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOST_GAS_TOKEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_TOKEN_INTERFACE_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_GAS_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REPAY_GAS_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REPAY_GAS_TOKEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SPOTTER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAT_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"addCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedCallers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automaticSaverProxyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[6]\",\"name\":\"_data\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256\",\"name\":\"_nextPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_joinAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_callData\",\"type\":\"bytes\"}],\"name\":\"boostFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasAmount\",\"type\":\"uint256\"}],\"name\":\"calcGasCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StaticV2.Method\",\"name\":\"_method\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"name\":\"canCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasCost\",\"type\":\"uint256\"}],\"name\":\"changeBoostGasCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isRepay\",\"type\":\"bool\"}],\"name\":\"changeGasTokenAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxGasPrice\",\"type\":\"uint256\"}],\"name\":\"changeMaxGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasCost\",\"type\":\"uint256\"}],\"name\":\"changeRepayGasCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_ilk\",\"type\":\"bytes32\"}],\"name\":\"getCdpInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ilk\",\"type\":\"bytes32\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logger\",\"outputs\":[{\"internalType\":\"contract AutomaticLogger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract Manager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monitorProxyContract\",\"outputs\":[{\"internalType\":\"contract MCDMonitorProxyV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StaticV2.Method\",\"name\":\"_method\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"name\":\"ratioGoodAfter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"removeCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[6]\",\"name\":\"_data\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256\",\"name\":\"_nextPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_joinAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_callData\",\"type\":\"bytes\"}],\"name\":\"repayFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdminByAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdminByOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwnerByAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spotter\",\"outputs\":[{\"internalType\":\"contract Spotter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionsContract\",\"outputs\":[{\"internalType\":\"contract ISubscriptionsV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract Vat\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStuckFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MCDMonitorV2","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000047d9f61badec4378842d809077a5e87b9c996898000000000000000000000000c45d4f6b6bf41b6edaa58b01c4298b8d9078269a0000000000000000000000006971900a81ac9d02f9b9902cc2626542d56caf2d","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://704e6462557ad77ec41ef1b035358bec64ddf41b13b4ccab8cd2330d9a556ff4"}]}