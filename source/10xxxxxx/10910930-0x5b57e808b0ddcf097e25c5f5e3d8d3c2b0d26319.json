{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\ncontract Governable {\r\n    // Storage position of the owner and pendingOwner of the contract\r\n    bytes32\r\n        private constant governorPosition = 0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\r\n    //keccak256(\"OUSD.governor\");\r\n\r\n    bytes32\r\n        private constant pendingGovernorPosition = 0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\r\n    //keccak256(\"OUSD.pending.governor\");\r\n\r\n    event PendingGovernorshipTransfer(\r\n        address indexed previousGovernor,\r\n        address indexed newGovernor\r\n    );\r\n\r\n    event GovernorshipTransferred(\r\n        address indexed previousGovernor,\r\n        address indexed newGovernor\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial Governor.\r\n     */\r\n    constructor() internal {\r\n        _setGovernor(msg.sender);\r\n        emit GovernorshipTransferred(address(0), _governor());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current Governor.\r\n     */\r\n    function governor() public view returns (address) {\r\n        return _governor();\r\n    }\r\n\r\n    function _governor() internal view returns (address governorOut) {\r\n        bytes32 position = governorPosition;\r\n        assembly {\r\n            governorOut := sload(position)\r\n        }\r\n    }\r\n\r\n    function _pendingGovernor()\r\n        internal\r\n        view\r\n        returns (address pendingGovernor)\r\n    {\r\n        bytes32 position = pendingGovernorPosition;\r\n        assembly {\r\n            pendingGovernor := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the Governor.\r\n     */\r\n    modifier onlyGovernor() {\r\n        require(isGovernor(), \"Caller is not the Governor\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current Governor.\r\n     */\r\n    function isGovernor() public view returns (bool) {\r\n        return msg.sender == _governor();\r\n    }\r\n\r\n    function _setGovernor(address newGovernor) internal {\r\n        bytes32 position = governorPosition;\r\n        assembly {\r\n            sstore(position, newGovernor)\r\n        }\r\n    }\r\n\r\n    function _setPendingGovernor(address newGovernor) internal {\r\n        bytes32 position = pendingGovernorPosition;\r\n        assembly {\r\n            sstore(position, newGovernor)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers Governance of the contract to a new account (`newGovernor`).\r\n     * Can only be called by the current Governor. Must be claimed for this to complete\r\n     * @param _newGovernor Address of the new Governor\r\n     */\r\n    function transferGovernance(address _newGovernor) external onlyGovernor {\r\n        _setPendingGovernor(_newGovernor);\r\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim Governance of the contract to a new account (`newGovernor`).\r\n     * Can only be called by the new Governor.\r\n     */\r\n    function claimGovernance() external {\r\n        require(\r\n            msg.sender == _pendingGovernor(),\r\n            \"Only the pending Governor can complete the claim\"\r\n        );\r\n        _changeGovernor(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\r\n     * @param _newGovernor Address of the new Governor\r\n     */\r\n    function _changeGovernor(address _newGovernor) internal {\r\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\r\n        emit GovernorshipTransferred(_governor(), _newGovernor);\r\n        _setGovernor(_newGovernor);\r\n    }\r\n}\r\n\r\ncontract InitializableGovernable is Governable, Initializable {\r\n    function _initialize(address _governor) internal {\r\n        _changeGovernor(_governor);\r\n    }\r\n}\r\n\r\ninterface IStrategy {\r\n    /**\r\n     * @dev Deposit the given asset to Lending platform.\r\n     * @param _asset asset address\r\n     * @param _amount Amount to deposit\r\n     */\r\n    function deposit(address _asset, uint256 _amount)\r\n        external\r\n        returns (uint256 amountDeposited);\r\n\r\n    /**\r\n     * @dev Withdraw given asset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _recipient,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external returns (uint256 amountWithdrawn);\r\n\r\n    /**\r\n     * @dev Returns the current balance of the given asset.\r\n     */\r\n    function checkBalance(address _asset)\r\n        external\r\n        view\r\n        returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns bool indicating whether strategy supports asset.\r\n     */\r\n    function supportsAsset(address _asset) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Liquidate all assets in strategy and return them to Vault.\r\n     */\r\n    function liquidate() external;\r\n\r\n    /**\r\n     * @dev Get the APR for the Strategy.\r\n     */\r\n    function getAPR() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Collect reward tokens from the Strategy.\r\n     */\r\n    function collectRewardToken() external;\r\n}\r\n\r\ninterface ICERC20 {\r\n    /**\r\n     * @notice The mint function transfers an asset into the protocol, which begins accumulating\r\n     * interest based on the current Supply Rate for the asset. The user receives a quantity of\r\n     * cTokens equal to the underlying tokens supplied, divided by the current Exchange Rate.\r\n     * @param mintAmount The amount of the asset to be supplied, in units of the underlying asset.\r\n     * @return 0 on success, otherwise an Error codes\r\n     */\r\n    function mint(uint256 mintAmount) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of cTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise an error code.\r\n     */\r\n    function redeem(uint256 redeemTokens) external returns (uint256);\r\n\r\n    /**\r\n     * @notice The redeem underlying function converts cTokens into a specified quantity of the underlying\r\n     * asset, and returns them to the user. The amount of cTokens redeemed is equal to the quantity of\r\n     * underlying tokens received, divided by the current Exchange Rate. The amount redeemed must be less\r\n     * than the user's Account Liquidity and the market's available liquidity.\r\n     * @param redeemAmount The amount of underlying to be redeemed.\r\n     * @return 0 on success, otherwise an error code.\r\n     */\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n    /**\r\n     * @notice The user's underlying balance, representing their assets in the protocol, is equal to\r\n     * the user's cToken balance multiplied by the Exchange Rate.\r\n     * @param owner The account to get the underlying balance of.\r\n     * @return The amount of underlying currently owned by the account.\r\n     */\r\n    function balanceOfUnderlying(address owner) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the CToken\r\n     * @dev This function does not accrue interest before calculating the exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Get the token balance of the `owner`\r\n     * @param owner The address of the account to query\r\n     * @return The number of tokens owned by `owner`\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Get the supply rate per block for supplying the token to Compound.\r\n     */\r\n    function supplyRatePerBlock() external view returns (uint256);\r\n}\r\n\r\ncontract InitializableAbstractStrategy is IStrategy, Initializable, Governable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    event PTokenAdded(address indexed _asset, address _pToken);\r\n    event Deposit(address indexed _asset, address _pToken, uint256 _amount);\r\n    event Withdrawal(address indexed _asset, address _pToken, uint256 _amount);\r\n\r\n    // Core address for the given platform\r\n    address public platformAddress;\r\n\r\n    address public vaultAddress;\r\n\r\n    // asset => pToken (Platform Specific Token Address)\r\n    mapping(address => address) public assetToPToken;\r\n\r\n    // Full list of all assets supported here\r\n    address[] internal assetsMapped;\r\n\r\n    // Reward token address\r\n    address public rewardTokenAddress;\r\n\r\n    /**\r\n     * @dev Internal initialize function, to set up initial internal state\r\n     * @param _platformAddress jGeneric platform address\r\n     * @param _vaultAddress Address of the Vault\r\n     * @param _rewardTokenAddress Address of reward token for platform\r\n     * @param _assets Addresses of initial supported assets\r\n     * @param _pTokens Platform Token corresponding addresses\r\n     */\r\n    function initialize(\r\n        address _platformAddress,\r\n        address _vaultAddress,\r\n        address _rewardTokenAddress,\r\n        address[] calldata _assets,\r\n        address[] calldata _pTokens\r\n    ) external onlyGovernor initializer {\r\n        InitializableAbstractStrategy._initialize(\r\n            _platformAddress,\r\n            _vaultAddress,\r\n            _rewardTokenAddress,\r\n            _assets,\r\n            _pTokens\r\n        );\r\n    }\r\n\r\n    function _initialize(\r\n        address _platformAddress,\r\n        address _vaultAddress,\r\n        address _rewardTokenAddress,\r\n        address[] memory _assets,\r\n        address[] memory _pTokens\r\n    ) internal {\r\n        platformAddress = _platformAddress;\r\n        vaultAddress = _vaultAddress;\r\n        rewardTokenAddress = _rewardTokenAddress;\r\n        uint256 assetCount = _assets.length;\r\n        require(assetCount == _pTokens.length, \"Invalid input arrays\");\r\n        for (uint256 i = 0; i < assetCount; i++) {\r\n            _setPTokenAddress(_assets[i], _pTokens[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the caller is the Vault.\r\n     */\r\n    modifier onlyVault() {\r\n        require(msg.sender == vaultAddress, \"Caller is not the Vault\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the caller is the Vault or Governor.\r\n     */\r\n    modifier onlyVaultOrGovernor() {\r\n        require(\r\n            msg.sender == vaultAddress || msg.sender == governor(),\r\n            \"Caller is not the Vault or Governor\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the reward token address.\r\n     * @param _rewardTokenAddress Address of the reward token\r\n     */\r\n    function setRewardTokenAddress(address _rewardTokenAddress)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        rewardTokenAddress = _rewardTokenAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Provide support for asset by passing its pToken address.\r\n     *      This method can only be called by the system Governor\r\n     * @param _asset    Address for the asset\r\n     * @param _pToken   Address for the corresponding platform token\r\n     */\r\n    function setPTokenAddress(address _asset, address _pToken)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        _setPTokenAddress(_asset, _pToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Provide support for asset by passing its pToken address.\r\n     *      Add to internal mappings and execute the platform specific,\r\n     * abstract method `_abstractSetPToken`\r\n     * @param _asset    Address for the asset\r\n     * @param _pToken   Address for the corresponding platform token\r\n     */\r\n    function _setPTokenAddress(address _asset, address _pToken) internal {\r\n        require(assetToPToken[_asset] == address(0), \"pToken already set\");\r\n        require(\r\n            _asset != address(0) && _pToken != address(0),\r\n            \"Invalid addresses\"\r\n        );\r\n\r\n        assetToPToken[_asset] = _pToken;\r\n        assetsMapped.push(_asset);\r\n\r\n        emit PTokenAdded(_asset, _pToken);\r\n\r\n        _abstractSetPToken(_asset, _pToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\r\n     *      strategy contracts, i.e. mistaken sends.\r\n     * @param _asset Address for the asset\r\n     * @param _amount Amount of the asset to transfer\r\n     */\r\n    function transferToken(address _asset, uint256 _amount)\r\n        public\r\n        onlyGovernor\r\n    {\r\n        IERC20(_asset).transfer(governor(), _amount);\r\n    }\r\n\r\n    /***************************************\r\n                 Abstract\r\n    ****************************************/\r\n\r\n    function _abstractSetPToken(address _asset, address _pToken) internal;\r\n\r\n    function safeApproveAllTokens() external;\r\n\r\n    /**\r\n     * @dev Deposit a amount of asset into the platform\r\n     * @param _asset               Address for the asset\r\n     * @param _amount              Units of asset to deposit\r\n     * @return amountDeposited     Quantity of asset that was deposited\r\n     */\r\n    function deposit(address _asset, uint256 _amount)\r\n        external\r\n        returns (uint256 amountDeposited);\r\n\r\n    /**\r\n     * @dev Withdraw an amount of asset from the platform.\r\n     * @param _recipient         Address to which the asset should be sent\r\n     * @param _asset             Address of the asset\r\n     * @param _amount            Units of asset to withdraw\r\n     * @return amountWithdrawn   Quantity of asset that was withdrawn\r\n     */\r\n    function withdraw(\r\n        address _recipient,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external returns (uint256 amountWithdrawn);\r\n\r\n    /**\r\n     * @dev Liquidate entire contents of strategy sending assets to Vault.\r\n     */\r\n    function liquidate() external;\r\n\r\n    /**\r\n     * @dev Get the total asset value held in the platform.\r\n     *      This includes any interest that was generated since depositing.\r\n     * @param _asset      Address of the asset\r\n     * @return balance    Total value of the asset in the platform\r\n     */\r\n    function checkBalance(address _asset)\r\n        external\r\n        view\r\n        returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Check if an asset is supported.\r\n     * @param _asset    Address of the asset\r\n     * @return bool     Whether asset is supported\r\n     */\r\n    function supportsAsset(address _asset) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Get the weighted APR for all assets.\r\n     * @return uint256 APR for Strategy\r\n     */\r\n    function getAPR() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Get the APR for a single asset.\r\n     * @param _asset    Address of the asset\r\n     * @return uint256 APR for single asset in Strategy\r\n     */\r\n    function getAssetAPR(address _asset) external view returns (uint256);\r\n}\r\n\r\ncontract CompoundStrategy is InitializableAbstractStrategy {\r\n    event RewardTokenCollected(address recipient, uint256 amount);\r\n    event SkippedWithdrawal(address asset, uint256 amount);\r\n\r\n    /**\r\n     * @dev Collect accumulated reward token (COMP) and send to Vault.\r\n     */\r\n    function collectRewardToken() external onlyVault {\r\n        IERC20 compToken = IERC20(rewardTokenAddress);\r\n        uint256 balance = compToken.balanceOf(address(this));\r\n        require(\r\n            compToken.transfer(vaultAddress, balance),\r\n            \"Reward token transfer failed\"\r\n        );\r\n\r\n        emit RewardTokenCollected(vaultAddress, balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit asset into Compound\r\n     * @param _asset Address of asset to deposit\r\n     * @param _amount Amount of asset to deposit\r\n     * @return amountDeposited Amount of asset that was deposited\r\n     */\r\n    function deposit(address _asset, uint256 _amount)\r\n        external\r\n        onlyVault\r\n        returns (uint256 amountDeposited)\r\n    {\r\n        require(_amount > 0, \"Must deposit something\");\r\n\r\n        ICERC20 cToken = _getCTokenFor(_asset);\r\n        require(cToken.mint(_amount) == 0, \"cToken mint failed\");\r\n\r\n        amountDeposited = _amount;\r\n\r\n        emit Deposit(_asset, address(cToken), amountDeposited);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw asset from Compound\r\n     * @param _recipient Address to receive withdrawn asset\r\n     * @param _asset Address of asset to withdraw\r\n     * @param _amount Amount of asset to withdraw\r\n     * @return amountWithdrawn Amount of asset that was withdrawn\r\n     */\r\n    function withdraw(\r\n        address _recipient,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external onlyVault returns (uint256 amountWithdrawn) {\r\n        require(_amount > 0, \"Must withdraw something\");\r\n        require(_recipient != address(0), \"Must specify recipient\");\r\n\r\n        ICERC20 cToken = _getCTokenFor(_asset);\r\n        // If redeeming 0 cTokens, just skip, else COMP will revert\r\n        uint256 cTokensToRedeem = _convertUnderlyingToCToken(cToken, _amount);\r\n        if (cTokensToRedeem == 0) {\r\n            emit SkippedWithdrawal(_asset, _amount);\r\n            return 0;\r\n        }\r\n\r\n        amountWithdrawn = _amount;\r\n\r\n        require(cToken.redeemUnderlying(_amount) == 0, \"Redeem failed\");\r\n\r\n        IERC20(_asset).safeTransfer(_recipient, amountWithdrawn);\r\n\r\n        emit Withdrawal(_asset, address(cToken), amountWithdrawn);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove all assets from platform and send them to Vault contract.\r\n     */\r\n    function liquidate() external onlyVaultOrGovernor {\r\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\r\n            // Redeem entire balance of cToken\r\n            ICERC20 cToken = _getCTokenFor(assetsMapped[i]);\r\n            if (cToken.balanceOf(address(this)) > 0) {\r\n                cToken.redeem(cToken.balanceOf(address(this)));\r\n                // Transfer entire balance to Vault\r\n                IERC20 asset = IERC20(assetsMapped[i]);\r\n                asset.safeTransfer(\r\n                    vaultAddress,\r\n                    asset.balanceOf(address(this))\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the total asset value held in the platform\r\n     *      This includes any interest that was generated since depositing\r\n     *      Compound exchange rate between the cToken and asset gradually increases,\r\n     *      causing the cToken to be worth more corresponding asset.\r\n     * @param _asset      Address of the asset\r\n     * @return balance    Total value of the asset in the platform\r\n     */\r\n    function checkBalance(address _asset)\r\n        external\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        // Balance is always with token cToken decimals\r\n        ICERC20 cToken = _getCTokenFor(_asset);\r\n        balance = _checkBalance(cToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the total asset value held in the platform\r\n     *      underlying = (cTokenAmt * exchangeRate) / 1e18\r\n     * @param _cToken     cToken for which to check balance\r\n     * @return balance    Total value of the asset in the platform\r\n     */\r\n    function _checkBalance(ICERC20 _cToken)\r\n        internal\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        uint256 cTokenBalance = _cToken.balanceOf(address(this));\r\n        uint256 exchangeRate = _cToken.exchangeRateStored();\r\n        // e.g. 50e8*205316390724364402565641705 / 1e18 = 1.0265..e18\r\n        balance = cTokenBalance.mul(exchangeRate).div(1e18);\r\n    }\r\n\r\n    /**\r\n     * @dev Retuns bool indicating whether asset is supported by strategy\r\n     * @param _asset Address of the asset\r\n     */\r\n    function supportsAsset(address _asset) external view returns (bool) {\r\n        return assetToPToken[_asset] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the spending of all assets by their corresponding cToken,\r\n     *      if for some reason is it necessary. Only callable through Governance.\r\n     */\r\n    function safeApproveAllTokens() external {\r\n        uint256 assetCount = assetsMapped.length;\r\n        for (uint256 i = 0; i < assetCount; i++) {\r\n            address asset = assetsMapped[i];\r\n            address cToken = assetToPToken[asset];\r\n            // Safe approval\r\n            IERC20(asset).safeApprove(cToken, 0);\r\n            IERC20(asset).safeApprove(cToken, uint256(-1));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the weighted APR for all assets in strategy.\r\n     * @return APR in 1e18\r\n     */\r\n    function getAPR() external view returns (uint256) {\r\n        uint256 totalValue = 0;\r\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\r\n            ICERC20 cToken = _getCTokenFor(assetsMapped[i]);\r\n            totalValue += _checkBalance(cToken);\r\n        }\r\n\r\n        if (totalValue == 0) return 0;\r\n\r\n        uint256 totalAPR = 0;\r\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\r\n            ICERC20 cToken = _getCTokenFor(assetsMapped[i]);\r\n            totalAPR += _checkBalance(cToken)\r\n                .mul(_getAssetAPR(assetsMapped[i]))\r\n                .div(totalValue);\r\n        }\r\n\r\n        return totalAPR;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the APR for a single asset.\r\n     * @param _asset Address of the asset\r\n     * @return APR in 1e18\r\n     */\r\n    function getAssetAPR(address _asset) external view returns (uint256) {\r\n        return _getAssetAPR(_asset);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal method to get the APR for a single asset.\r\n     * @param _asset Address of the asset\r\n     * @return APR in 1e18\r\n     */\r\n    function _getAssetAPR(address _asset) internal view returns (uint256) {\r\n        ICERC20 cToken = _getCTokenFor(_asset);\r\n        // Extrapolate to a year assuming 6,500 blocks per day times 365.\r\n        return cToken.supplyRatePerBlock().mul(2372500);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal method to respond to the addition of new asset / cTokens\r\n     *      We need to approve the cToken and give it permission to spend the asset\r\n     * @param _asset Address of the asset to approve\r\n     * @param _cToken This cToken has the approval approval\r\n     */\r\n    function _abstractSetPToken(address _asset, address _cToken) internal {\r\n        // Safe approval\r\n        IERC20(_asset).safeApprove(_cToken, 0);\r\n        IERC20(_asset).safeApprove(_cToken, uint256(-1));\r\n    }\r\n\r\n    /**\r\n     * @dev Get the cToken wrapped in the ICERC20 interface for this asset.\r\n     *      Fails if the pToken doesn't exist in our mappings.\r\n     * @param _asset Address of the asset\r\n     * @return Corresponding cToken to this asset\r\n     */\r\n    function _getCTokenFor(address _asset) internal view returns (ICERC20) {\r\n        address cToken = assetToPToken[_asset];\r\n        require(cToken != address(0), \"cToken does not exist\");\r\n        return ICERC20(cToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an underlying amount into cToken amount\r\n     *      cTokenAmt = (underlying * 1e18) / exchangeRate\r\n     * @param _cToken     cToken for which to change\r\n     * @param _underlying Amount of underlying to convert\r\n     * @return amount     Equivalent amount of cTokens\r\n     */\r\n    function _convertUnderlyingToCToken(ICERC20 _cToken, uint256 _underlying)\r\n        internal\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        uint256 exchangeRate = _cToken.exchangeRateStored();\r\n        // e.g. 1e18*1e18 / 205316390724364402565641705 = 50e8\r\n        // e.g. 1e8*1e18 / 205316390724364402565641705 = 0.45 or 0\r\n        amount = _underlying.mul(1e18).div(exchangeRate);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"collectRewardToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pToken\",\"type\":\"address\"}],\"name\":\"setPTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetToPToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"liquidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountDeposited\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"checkBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getAssetAPR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_platformAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_pTokens\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardTokenAddress\",\"type\":\"address\"}],\"name\":\"setRewardTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"supportsAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safeApproveAllTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAPR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"transferGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardTokenCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SkippedWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pToken\",\"type\":\"address\"}],\"name\":\"PTokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"PendingGovernorshipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorshipTransferred\",\"type\":\"event\"}]","ContractName":"CompoundStrategy","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f7fd4763ffcb6f6a035bef575f4ff2e294cb2f17db2181309b5c38b057d79502"}]}