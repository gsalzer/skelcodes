{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/ERC20Interface.sol\r\n\r\npragma solidity ^0.5.15;\r\n\r\n// ----------------------------------------------------------------------------------------------\r\n// Sample fixed supply token contract\r\n// Enjoy. (c) BokkyPooBah 2017. The MIT Licence.\r\n// ----------------------------------------------------------------------------------------------\r\n\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Interface {\r\n    // Get the total token supply\r\n    function totalSupply() public view returns (uint256 totalsupply);\r\n\r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        returns (bool success);\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public returns (bool success);\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    // this function is required for some DEX functionality\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        returns (bool success);\r\n\r\n    // Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256 remaining);\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n}\r\n\r\n// File: contracts/CustomToken.sol\r\n\r\npragma solidity ^0.5.15;\r\n\r\n// ----------------------------------------------------------------------------------------------\r\n\r\ncontract CustomToken is ERC20Interface {\r\n    string public constant symbol = \"ZEN\";\r\n    string public constant name = \"ZenGo Token\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 _initialSupply = 1000000 * 1 ether;\r\n    uint256 _totalSupply;\r\n\r\n    uint256 _revertAmount = 0.001 * 1 ether;\r\n    uint256 _falseAmount = 0.002 * 1 ether;\r\n    uint256 _noTransferAmount = 0.003 * 1 ether;\r\n\r\n    uint256 multiplier = 10000000000;\r\n\r\n    event Amount(uint256 amount);\r\n\r\n    // Owner of this contract\r\n    address public owner;\r\n\r\n    // Balances for each account\r\n    mapping(address => uint256) balances;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    // Functions with this modifier can only be executed by the owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Action can only be performed by owner\");\r\n        _;\r\n    }\r\n\r\n    // constructor\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        _totalSupply = _initialSupply;\r\n        balances[owner] = _initialSupply;\r\n    }\r\n\r\n    function() external payable {\r\n        emit Amount(msg.value);\r\n        if (\r\n            !(msg.value == 10000000000 ||\r\n                msg.value == 20000000000 ||\r\n                msg.value == 30000000000)\r\n        ) {\r\n            revert(\"Illegal mint sum\");\r\n        }\r\n        if (msg.value == 10000000000) {\r\n            _totalSupply += 100 * 1 ether;\r\n            balances[msg.sender] += 100 * 1 ether;\r\n        }\r\n        if (msg.value == 20000000000) {\r\n            _totalSupply += 10000 * 1 ether;\r\n            balances[msg.sender] += 10000 * 1 ether;\r\n        }\r\n        if (msg.value == 30000000000) {\r\n            _totalSupply += 1000000 * 1 ether;\r\n            balances[msg.sender] += 1000000 * 1 ether;\r\n        }\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    // What is the balance of a particular account?\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    // Transfer the balance from owner's account to another account\r\n    function transfer(address _to, uint256 _amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(\r\n            msg.sender != address(0),\r\n            \"ERC20: transfer from the zero address\"\r\n        );\r\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\r\n        // For testing of revert\r\n        require(_amount != _revertAmount, \"Trasfer of illegal amount\");\r\n        // For testing of a send returning false\r\n        if (_amount == _falseAmount) {\r\n            return false;\r\n        }\r\n        if (_amount == _noTransferAmount) {\r\n            // Here, we do not emit a transfer event, and the tx succeeds, but no funds are moved\r\n            return true;\r\n        }\r\n        if (\r\n            balances[msg.sender] >= _amount &&\r\n            _amount > 0 &&\r\n            balances[_to] + _amount > balances[_to]\r\n        ) {\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            emit Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n    // fees in sub-currencies; the command should fail unless the _from account has\r\n    // deliberately authorized the sender of the message via some mechanism; we propose\r\n    // these standardized APIs for approval:\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) public returns (bool success) {\r\n        if (\r\n            balances[_from] >= _amount &&\r\n            allowed[_from][msg.sender] >= _amount &&\r\n            _amount > 0 &&\r\n            balances[_to] + _amount > balances[_to]\r\n        ) {\r\n            balances[_from] -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            emit Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256 remaining)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // Adds another 100 tokens to the sender\r\n    function mint(uint256 _amount) public {\r\n        _totalSupply += _amount;\r\n        balances[msg.sender] += _amount;\r\n        emit Transfer(address(0), msg.sender, _amount);\r\n    }\r\n\r\n    // Adds another 100 tokens to the specifed address\r\n    function mint(uint256 _amount, address reciever) public {\r\n        _totalSupply += _amount;\r\n        balances[reciever] += _amount;\r\n        emit Transfer(address(0), reciever, _amount);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Amount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"reciever\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CustomToken","CompilerVersion":"v0.5.15+commit.6a57276f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2d4c6c2d75819b81bc3ca6fe7dbf55f0375ef74a902a31f14eae3ceab5ebbc5a"}]}