{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = byte(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n/**\r\n * @title ERC 20 Token Standard Interface\r\n *  https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface EIP20Interface {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address dst, uint256 amount) external returns (bool success);\r\n\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n /*\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\ncontract CallOption {\r\n  using SafeMath for uint256;\r\n  using Strings for uint256;\r\n  using Address for address;\r\n\r\n  struct PremiumInfo {\r\n    address premiumToken;\r\n    uint premiumAmt;\r\n    bool premiumRedeemed;\r\n    uint premiumPlatformFee;\r\n    uint sellerPremium;\r\n  }\r\n\r\n  struct UnderlyingInfo {\r\n    address underlyingCurrency;\r\n    uint underlyingAmt;\r\n    bool redeemed;\r\n    bool isCall;\r\n  }\r\n\r\n  struct Option {\r\n    // Proposal high level\r\n    uint proposalExpiresAt;\r\n    address seller;\r\n    address buyer;\r\n    \r\n    // Proposal premium\r\n    PremiumInfo premiumInfo;\r\n    \r\n    // Underlying\r\n    UnderlyingInfo underlyingInfo;\r\n\r\n    // Strike price\r\n    address strikeCurrency;\r\n    uint strikeAmt;\r\n  \r\n    // Acceptance state\r\n    bool sellerAccepted;\r\n    bool buyerAccepted;\r\n\r\n    // Option \r\n    uint optionExpiresAt;\r\n    bool cancelled;\r\n    bool executed;\r\n  }\r\n\r\n  event UnderlyingDeposited(uint indexed optionUID, address seller, address token, uint amount);  \r\n  event PremiumDeposited(uint indexed optionUID, address buyer, address token, uint amount);  \r\n  event SellerAccepted(uint indexed optionUID, address seller);\r\n  event BuyerAccepted(uint indexed optionUID, address buyer);\r\n  event BuyerCancelled(uint indexed optionUID, address buyer);\r\n  event SellerCancelled(uint indexed optionUID, address seller);\r\n  event BuyerPremiumRefunded(uint indexed optionUID, address buyer);\r\n  event SellerUnderlyingRedeemed(uint indexed optionUID, address seller);\r\n  event SellerRedeemedPremium(uint indexed optionUID, address seller);\r\n  event TransferSeller(uint indexed optionUID, address oldSeller, address newSeller);\r\n  \r\n  event OptionExecuted(uint indexed optionUID);\r\n\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  // Maps user to the IDS of their associated options\r\n  mapping(address => uint[]) public userOptions;\r\n  \r\n  // Stores the state of all the options\r\n  Option[] public options;\r\n\r\n  // Fee taken out of the premiums collected\r\n  uint public platformFee = 5; // 0.005 \r\n \r\n  // Address which collected fees are directed to\r\n  address public feeBeneficiaryAddress;\r\n\r\n  // Fees that are withdrawable\r\n  mapping(address => uint) public platformFeeBalances;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) private _tokenApprovals;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n  string public constant symbol = \"OPTION-SWAP\";\r\n  string public constant name = \"ERC-20 Option (OptionSwap.finance)\";\r\n\r\n  address public admin;\r\n\r\n  constructor() public {\r\n    admin = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Propose a new option with the following criteria \r\n   */\r\n  function propose(address seller, address buyer, uint proposalExpiresAt, uint optionExpiresAt, \r\n                        address premiumToken, uint premiumAmt, \r\n                        address underlyingCurrency, uint underlyingAmt, \r\n                        address strikeCurrency, uint strikeAmt, bool isCall) public {\r\n    \r\n    require((seller == msg.sender) || (buyer == msg.sender), \"Must be either the seller or buyer\");\r\n\r\n    require(proposalExpiresAt <= optionExpiresAt, \"Option cannot expire before proposal\");\r\n\r\n    // Compute the seller premium to be earned and associated platform fee from the premium\r\n    (uint sellerPremium, uint platformFeePremium) = _computePremiumSplit(premiumAmt, EIP20Interface(premiumToken).decimals());\r\n    \r\n    // Add the option to list of options\r\n    options.push(Option(\r\n      { \r\n          seller: seller, \r\n          buyer: buyer, \r\n          proposalExpiresAt: proposalExpiresAt, \r\n          premiumInfo: PremiumInfo({ \r\n            premiumToken: premiumToken, \r\n            premiumAmt: premiumAmt, \r\n            premiumRedeemed: false,\r\n            premiumPlatformFee: platformFeePremium,\r\n            sellerPremium: sellerPremium}),\r\n          underlyingInfo: UnderlyingInfo({ \r\n            underlyingCurrency: underlyingCurrency, \r\n            underlyingAmt: underlyingAmt, \r\n            isCall: isCall,\r\n            redeemed: false }),\r\n          strikeCurrency: strikeCurrency,\r\n          strikeAmt: strikeAmt,\r\n          optionExpiresAt: optionExpiresAt,\r\n          cancelled: false,\r\n          executed: false,\r\n          sellerAccepted: false,\r\n          buyerAccepted: false\r\n      }));\r\n    \r\n    // If sender is the seller, transfer underlying and update tracking state\r\n    if (msg.sender == seller) {\r\n      _acceptSeller(options.length - 1);\r\n    }\r\n    \r\n    // If sender is the buyer, transfer premium and update tracking state \r\n    if (msg.sender == buyer) {\r\n      _acceptBuyer(options.length - 1);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * @notice Compute how much of the premium goes to the seller and how much to the platform \r\n   */\r\n  function _computePremiumSplit(uint premium, uint decimals) public view returns(uint, uint) {\r\n    require(decimals <= 78, \"_computePremiumSplit(): too many decimals will overflow\"); \r\n    require(decimals >= 3, \"_computePremiumSplit(): too few decimals will underflow\"); \r\n    uint platformFeeDoubleScaled = premium.mul(platformFee * (10 ** (decimals - 3)));\r\n    \r\n    uint platformFeeCollected = platformFeeDoubleScaled.div(10 ** (decimals));\r\n\r\n    uint redeemable = premium.sub(platformFeeCollected);\r\n    return (redeemable, platformFeeCollected);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows Seller to redeem their premium after the option has been accepted by the buyer \r\n   */\r\n  function redeemPremium(uint optionUID) public {\r\n    Option storage option = options[optionUID];\r\n    \r\n    // Can only redeem premium once\r\n    require(!option.premiumInfo.premiumRedeemed, \"redeemPremium(): premium already redeemed\");\r\n    \r\n    if(option.cancelled || proposalExpired(optionUID)){\r\n      bool isBuyer = option.buyer == msg.sender; \r\n      require(isBuyer, \"redeemPremium(): only buyer can redeem when proposal expired\");\r\n     \r\n      // Track premium redeemed \r\n      option.premiumInfo.premiumRedeemed = true; \r\n    \r\n      // Transfer buyer's premium back to themself \r\n      EIP20Interface token = EIP20Interface(option.premiumInfo.premiumToken);\r\n      bool success = token.transfer(option.buyer, option.premiumInfo.premiumAmt);\r\n      require(success, \"redeemPremium(): premium transfer failed\"); \r\n     \r\n      emit BuyerPremiumRefunded(optionUID, msg.sender);\r\n      return;\r\n    }\r\n    \r\n    // Only the seller may redeem the premium \r\n    bool isSeller = option.seller == msg.sender; \r\n    \r\n    require(isSeller, \"redeemPremium(): only option seller can redeem\");\r\n    \r\n    // Cannot redeem an option that hasn't been accepted  \r\n    require(option.buyerAccepted && option.sellerAccepted, \"redeemPremium(): option hasn't been accepted\");\r\n    \r\n    // Track premium redeemed \r\n    option.premiumInfo.premiumRedeemed = true; \r\n    \r\n    // Update platform fee balances to include their split of the premium \r\n    platformFeeBalances[option.premiumInfo.premiumToken] = platformFeeBalances[option.premiumInfo.premiumToken].add(option.premiumInfo.premiumPlatformFee);\r\n    \r\n    // Transfer seller's premium earned to themself \r\n    EIP20Interface token = EIP20Interface(option.premiumInfo.premiumToken);\r\n    bool success = token.transfer(option.seller, option.premiumInfo.sellerPremium);\r\n    require(success, \"redeemPremium(): premium transfer failed\"); \r\n  \r\n    emit SellerRedeemedPremium(optionUID, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Status for whether time has expired for the option to be executed \r\n   */\r\n  function optionExpired(uint optionUID) public view returns(bool) {\r\n    Option memory option = options[optionUID];\r\n    if (option.optionExpiresAt > now) \r\n      return false;\r\n    else\r\n      return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Status for whether time has expired for the option proposal to be accepted \r\n   */\r\n  function proposalExpired(uint optionUID) public view returns (bool) {\r\n    Option memory option = options[optionUID];\r\n    if (option.sellerAccepted && option.buyerAccepted)\r\n      return false;\r\n    if (option.proposalExpiresAt > now) \r\n      return false;\r\n    else\r\n      return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Allow the seller to redeem their underlying if option goes unused (cancelled, proposal expired, option expired)\r\n   */\r\n  function redeemUnderlying(uint optionUID) public {\r\n    Option storage option = options[optionUID];\r\n    \r\n    // Must be seller to redeem underlying\r\n    bool isSeller = option.seller == msg.sender; \r\n    require(isSeller, \"redeemUnderlying(): only seller may redeem\");\r\n    \r\n    require(!option.underlyingInfo.redeemed, \"redeemUnderlying(): redeemed, nothing remaining to redeem\");\r\n    require(!option.executed, \"redeemUnderlying(): executed, nothing to redeem\");\r\n    require(option.cancelled || optionExpired(optionUID) || proposalExpired(optionUID), \"redeemUnderlying(): must be cancelled or expired to redeem\");\r\n\r\n    // Mark as redeemed to ensure only gets redeemed once \r\n    option.underlyingInfo.redeemed = true;\r\n   \r\n    emit SellerUnderlyingRedeemed(optionUID, msg.sender);\r\n\r\n    // Transfer underlying back to the seller\r\n    EIP20Interface token = EIP20Interface(option.underlyingInfo.underlyingCurrency);\r\n    bool success = token.transfer(option.seller, option.underlyingInfo.underlyingAmt);\r\n    require(success, \"redeemUnderlying(): premium transfer failed\"); \r\n  }\r\n\r\n  /**\r\n   * @notice Allows buyer to transfer ownership of option to another user \r\n   */\r\n  function transferSeller(uint optionUID, address newSeller) public {\r\n    Option storage option = options[optionUID];\r\n    \r\n    // Only the seller may transfer an option\r\n    bool isSeller = option.seller == msg.sender; \r\n    require(isSeller, \"transferSeller(): must be seller\");\r\n    \r\n    // Update option buyer \r\n    option.seller = newSeller; \r\n    userOptions[newSeller].push(optionUID);\r\n    \r\n    emit TransferSeller(optionUID, msg.sender, newSeller);\r\n  }\r\n\r\n  /**\r\n   * @notice Buyer supplies strike amount from strike currency to receive underlying \r\n   */\r\n  function execute(uint optionUID) public {\r\n    Option storage option = options[optionUID];\r\n    \r\n    // Only the buyer may execute the option\r\n    bool isBuyer = option.buyer == msg.sender; \r\n    require(isBuyer, \"execute(): Must be option owner\");\r\n    \r\n    // Nothing to execute w/o both accepting the option\r\n    require(option.buyerAccepted && option.sellerAccepted, \"execute(): must be a fully accepted option\");\r\n    \r\n    // Cannot execute once expired\r\n    require(!optionExpired(optionUID), \"execute(): option expired\");\r\n    \r\n    // Cannot execute more than once\r\n    require(!option.executed, \"execute(): already executed\");\r\n\r\n    // Mark as executed\r\n    option.executed = true;\r\n     \r\n    // 1st Transfer the strike amount from the option buyer\r\n    EIP20Interface token = EIP20Interface(option.strikeCurrency);\r\n    bool success = token.transferFrom(option.buyer, address(this), option.strikeAmt);\r\n    require(success, \"execute(): strike transfer failed\"); \r\n    \r\n    // 2nd Transfer the strike amount to the option seller \r\n    success = token.transfer(option.seller, option.strikeAmt);\r\n    require(success, \"execute(): strike transfer failed\"); \r\n    \r\n    // 3rd Transfer the underlying to the option buyer\r\n    EIP20Interface tokenUnderlying = EIP20Interface(option.underlyingInfo.underlyingCurrency);\r\n    success = tokenUnderlying.transfer(option.buyer, option.underlyingInfo.underlyingAmt);\r\n    \r\n    emit OptionExecuted(optionUID);\r\n\r\n    require(success, \"execute(): underlying transfer failed\"); \r\n  }\r\n\r\n  /**\r\n   * @notice If buyer or seller sets status fields and transfers either the premium or underlying  \r\n   */\r\n  function accept(uint optionUID) public {\r\n    Option memory option = options[optionUID];\r\n    bool isSeller = option.seller == msg.sender || option.seller == address(0);\r\n    bool isBuyer = option.buyer == msg.sender || option.buyer == address(0);\r\n    require(isSeller || isBuyer, \"accept(): Must either buyer or seller\");\r\n\r\n    if (isBuyer){ \r\n      _acceptBuyer(optionUID);\r\n    }\r\n    else if (isSeller) {\r\n      _acceptSeller(optionUID);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice If buyer or seller sets status fields and transfers either the premium or underlying  \r\n   */\r\n  function cancel(uint optionUID) public {\r\n    Option memory option = options[optionUID];\r\n    bool isSeller = option.seller == msg.sender; \r\n    bool isBuyer = option.buyer == msg.sender; \r\n    require(isSeller || isBuyer, \"cancel(): only sellers and buyers can cancel\"); \r\n    \r\n    if (isSeller) {\r\n      _cancelSeller(optionUID);\r\n    }\r\n    else if (isBuyer) {\r\n      _cancelBuyer(optionUID);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Seller calls cancel before buyer accepts, returns underlying \r\n   */\r\n  function _cancelSeller(uint optionUID) internal {\r\n    Option memory option = options[optionUID];\r\n    require(option.sellerAccepted, \"_cancelSeller(): cannot cancel before accepting\");\r\n    require(!option.buyerAccepted, \"_cancelSeller(): already accepted\");\r\n    require(!option.cancelled, \"_cancelSeller(): already cancelled\");\r\n    // Cancel the option\r\n    options[optionUID].cancelled = true;\r\n  \r\n    emit SellerCancelled(optionUID, msg.sender);\r\n    \r\n    // Redeem the underlying\r\n    redeemUnderlying(optionUID);\r\n  }\r\n\r\n  /**\r\n   * @notice Buyer calls cancel before buyer accepts, returns full premium no fees deducted \r\n   */\r\n  function _cancelBuyer(uint optionUID) internal {\r\n    Option memory option = options[optionUID];\r\n    require(option.buyerAccepted, \"_cancelBuyer(): cannot cancel before accepting\");\r\n    require(!option.sellerAccepted, \"_cancelBuyer(): already accepted\");\r\n    require(!option.cancelled, \"already cancelled\");\r\n    \r\n    // Cancel the option\r\n    options[optionUID].cancelled = true;\r\n    \r\n    emit BuyerCancelled(optionUID, msg.sender);\r\n    \r\n    // Return the buyers premium  \r\n    redeemPremium(optionUID);\r\n  }\r\n\r\n  /**\r\n   * @notice Seller accepts option, transfers underlying amount, if buyer paid premium redeem it \r\n   */\r\n  function _acceptSeller(uint optionUID) internal {\r\n    Option storage option = options[optionUID];\r\n    require(!option.sellerAccepted, \"seller already accepted\");\r\n    \r\n    // Mark as seller accepted\r\n    option.sellerAccepted = true;\r\n    \r\n    // transfer specified tokens\r\n    EIP20Interface token = EIP20Interface(option.underlyingInfo.underlyingCurrency);\r\n    bool success = token.transferFrom(msg.sender, address(this), option.underlyingInfo.underlyingAmt);\r\n    require(success, \"_acceptSeller(): Failed to transfer underlying\");\r\n\r\n    // Emit event\r\n    emit UnderlyingDeposited(optionUID, msg.sender, option.underlyingInfo.underlyingCurrency, option.underlyingInfo.underlyingAmt);\r\n\r\n    // If option seller was universal, set it to the sender\r\n    if (option.seller == address(0)) {\r\n      options[optionUID].seller = msg.sender;\r\n    }\r\n    userOptions[msg.sender].push(optionUID);\r\n\r\n    // If buyer already accepted, redeem premium\r\n    if (option.buyerAccepted) {\r\n      redeemPremium(optionUID);\r\n    }\r\n\r\n    emit SellerAccepted(optionUID, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Buyer accepts option, transfers premium \r\n   */\r\n  function _acceptBuyer(uint optionUID) internal {\r\n    Option storage option = options[optionUID];\r\n    require(!option.buyerAccepted, \"buyer already accepted\");\r\n    \r\n    // Mark as buyer accepted\r\n    option.buyerAccepted = true;\r\n   \r\n    // transfer specified premium \r\n    EIP20Interface token = EIP20Interface(option.premiumInfo.premiumToken);\r\n    bool success = token.transferFrom(msg.sender, address(this), option.premiumInfo.premiumAmt);\r\n    require(success, \"Failed to transfer premium\");\r\n    \r\n    // If option buyer was universal, set it to the sender\r\n    if (option.buyer == address(0)) {\r\n      options[optionUID].buyer = msg.sender;\r\n    }\r\n      \r\n    userOptions[msg.sender].push(optionUID);\r\n    \r\n    emit PremiumDeposited(optionUID, msg.sender, option.premiumInfo.premiumToken, option.premiumInfo.premiumAmt);\r\n    emit BuyerAccepted(optionUID, msg.sender);\r\n  }\r\n  \r\n  //------------------------\r\n  //  Status functions\r\n  //------------------------\r\n  \r\n  function canAccept(uint optionUID) public view returns(bool) {\r\n    Option memory option = options[optionUID];\r\n    return (!option.buyerAccepted || !option.sellerAccepted) && !proposalExpired(optionUID); \r\n  }\r\n\r\n  function canCancel(uint optionUID) public view returns(bool) {\r\n    Option memory option = options[optionUID];\r\n    return (!option.buyerAccepted || !option.sellerAccepted) && !proposalExpired(optionUID); \r\n  }\r\n\r\n  function canExecute(uint optionUID) public view returns(bool) {\r\n    Option memory option = options[optionUID];\r\n    return !option.executed && (option.buyerAccepted && option.sellerAccepted) && !optionExpired(optionUID); \r\n  }\r\n  \r\n  function canRedeemPremium(uint optionUID) public view returns(bool) {\r\n    Option memory option = options[optionUID];\r\n    return (option.buyerAccepted && option.sellerAccepted) && !option.premiumInfo.premiumRedeemed; \r\n  }\r\n  \r\n  function canRedeemUnderlying(uint optionUID) public view returns(bool) {\r\n    Option memory option = options[optionUID];\r\n    if (option.cancelled || optionExpired(optionUID) || proposalExpired(optionUID))\r\n      return !option.underlyingInfo.redeemed && !option.executed;\r\n    else\r\n      return false;\r\n  }\r\n  \r\n  //------------------------\r\n  // NFT Functions\r\n  //------------------------\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n      uint count = 0;\r\n      for(uint i; i< options.length; i++) {\r\n        if(options[i].seller == _owner || options[i].buyer == _owner) {\r\n          if(options[i].sellerAccepted && options[i].buyerAccepted) {\r\n            count += 1;\r\n          }\r\n        }\r\n      }\r\n      return count;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n      uint count = 0;\r\n      for(uint i; i< options.length; i++) {\r\n        if(options[i].sellerAccepted && options[i].buyerAccepted) {\r\n          count += 1;\r\n        }\r\n      }\r\n      return count;\r\n    }\r\n\r\n    function baseTokenURI() public view returns (string memory) {\r\n      return \"https://metadata.optionswap.finance/\";\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\r\n        return string(abi.encodePacked(baseTokenURI(), tokenId.toString()));\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n      Option memory option = options[_tokenId];\r\n      return option.buyer;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public {\r\n        require(operator != msg.sender, \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        return options[tokenId].buyer != address(0); \r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n  \r\n     /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        Option storage option = options[tokenId];\r\n        option.buyer = to;\r\n        userOptions[to].push(tokenId);\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n     /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        private returns (bool)\r\n    {\r\n        bytes4 _ERC721_RECEIVED = 0x150b7a02;\r\n        if (to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\r\n            IERC721Receiver(to).onERC721Received.selector,\r\n            msg.sender,\r\n            from,\r\n            tokenId,\r\n            _data\r\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n        bytes4 retval = abi.decode(returndata, (bytes4));\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) private {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}\r\n\r\n  //------------------------\r\n  //  Lens functions\r\n  //------------------------\r\n \r\n  // Returns the options data for a given account\r\n  function optionsForAccount(address account) public view returns(uint[] memory) {\r\n    if (userOptions[account].length == 0) {\r\n      uint[] memory blank;\r\n      return blank;\r\n    }\r\n    return userOptions[account];\r\n  }\r\n  \r\n  // Returns all the options \r\n  function getOptions() public view returns(Option[] memory) {\r\n    return options;\r\n  }\r\n\r\n\r\n  //------------------------\r\n  //  Admin functions\r\n  //------------------------\r\n  \r\n  // Updates the platform fee, only affects new options created\r\n  function __updateFee(uint newPlatformFee) public {\r\n    require(msg.sender == admin, \"__updateFee(): must be admin\");\r\n    platformFee = newPlatformFee;\r\n  }\r\n\r\n  function __redeemPlatformFee(uint amount, address tokenAddress) public {\r\n    require(msg.sender == admin, \"__redeemPlatformFee(): must be admin\");\r\n    require(platformFeeBalances[tokenAddress] >= amount, \"__redeemPlatformFee(): requested redemption too large\");\r\n\r\n    // Update total balance\r\n    platformFeeBalances[tokenAddress] = platformFeeBalances[tokenAddress].sub(amount);\r\n    \r\n    // Perform transfer\r\n    EIP20Interface token = EIP20Interface(tokenAddress);\r\n    bool success = token.transfer(msg.sender, amount);\r\n    require(success, \"Failed to transfer premium\");\r\n  }\r\n\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"BuyerAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"BuyerCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"BuyerPremiumRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"OptionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PremiumDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"SellerAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"SellerCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"SellerRedeemedPremium\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"SellerUnderlyingRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldSeller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSeller\",\"type\":\"address\"}],\"name\":\"TransferSeller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnderlyingDeposited\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"__redeemPlatformFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPlatformFee\",\"type\":\"uint256\"}],\"name\":\"__updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"_computePremiumSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"accept\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"canAccept\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"canCancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"canExecute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"canRedeemPremium\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"canRedeemUnderlying\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBeneficiaryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOptions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"proposalExpiresAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"premiumToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"premiumAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"premiumRedeemed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"premiumPlatformFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerPremium\",\"type\":\"uint256\"}],\"internalType\":\"struct CallOption.PremiumInfo\",\"name\":\"premiumInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"underlyingCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"redeemed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"}],\"internalType\":\"struct CallOption.UnderlyingInfo\",\"name\":\"underlyingInfo\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"strikeCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikeAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sellerAccepted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyerAccepted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"optionExpiresAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"internalType\":\"struct CallOption.Option[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"optionExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"options\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalExpiresAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"premiumToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"premiumAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"premiumRedeemed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"premiumPlatformFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerPremium\",\"type\":\"uint256\"}],\"internalType\":\"struct CallOption.PremiumInfo\",\"name\":\"premiumInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"underlyingCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"redeemed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"}],\"internalType\":\"struct CallOption.UnderlyingInfo\",\"name\":\"underlyingInfo\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"strikeCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikeAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sellerAccepted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyerAccepted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"optionExpiresAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"optionsForAccount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"platformFeeBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"proposalExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalExpiresAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionExpiresAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"premiumToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"premiumAmt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"strikeCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikeAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"}],\"name\":\"propose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"redeemPremium\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionUID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newSeller\",\"type\":\"address\"}],\"name\":\"transferSeller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userOptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CallOption","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5a1f5af0bc908ecb5f6e1da670952b8ef8d7eb63575f00f58a2a6cb6a4c070c8"}]}