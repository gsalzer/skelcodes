{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping(address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage _role, address _account) internal {\n        require(!has(_role, _account), \"Roles: account already has role\");\n        _role.bearer[_account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage _role, address _account) internal {\n        require(has(_role, _account), \"Roles: account does not have role\");\n        _role.bearer[_account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage _role, address _account) internal view returns (bool) {\n        require(_account != address(0), \"Roles: account is the zero address\");\n        return _role.bearer[_account];\n    }\n}\n\ncontract Operator is Ownable {\n    using Roles for Roles.Role;\n\n    Roles.Role private _operators;\n\n    event OperatorAdded(address indexed account);\n    event OperatorRemoved(address indexed account);\n\n    function isOperator(address _account) public view returns (bool) {\n        return _operators.has(_account);\n    }\n\n    function addOperator(address _account) external onlyOwner {\n        _addOperator(_account);\n    }\n\n    function removeOperator(address _account) external onlyOwner {\n        _removeOperator(_account);\n    }\n\n    function renounceOperator() external {\n        _removeOperator(msg.sender);\n    }\n\n    function _addOperator(address _account) internal {\n        _operators.add(_account);\n        emit OperatorAdded(_account);\n    }\n\n    function _removeOperator(address _account) internal {\n        _operators.remove(_account);\n        emit OperatorRemoved(_account);\n    }\n}\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Ownable {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor() internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() external onlyOwner whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() external onlyOwner whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public;\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public;\n\n    function approve(address to, uint256 tokenId) public;\n\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public;\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) public returns (bytes4);\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor() internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping(uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping(address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor() public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"ERC721: approve caller is not owner nor approved for all\");\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender, \"ERC721: approve to caller\");\n\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = to.call(\n            abi.encodeWithSelector(IERC721Receiver(to).onERC721Received.selector, msg.sender, from, tokenId, _data)\n        );\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n            }\n        } else {\n            bytes4 retval = abi.decode(returndata, (bytes4));\n            return (retval == _ERC721_RECEIVED);\n        }\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Constructor function.\n     */\n    constructor() public {\n        // register the supported interface to conform to ERC721Enumerable via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract.\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {ERC721-_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Base URI\n    string private _baseURI;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /**\n     * @dev Constructor function\n     */\n    constructor(string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the URI for a given token ID. May return an empty string.\n     *\n     * If the token's URI is non-empty and a base URI was set (via\n     * {_setBaseURI}), it will be added to the token ID's URI as a prefix.\n     *\n     * Reverts if the token ID does not exist.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        // Even if there is a base URI, it is only appended to non-empty token-specific URIs\n        if (bytes(_tokenURI).length == 0) {\n            return \"\";\n        } else {\n            // abi.encodePacked is being used to concatenate strings\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     *\n     * Reverts if the token ID does not exist.\n     *\n     * TIP: if all token IDs share a prefix (e.g. if your URIs look like\n     * `http://api.myproject.com/token/<id>`), use {_setBaseURI} to store\n     * it and save gas.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI}.\n     *\n     * _Available since v2.5.0._\n     */\n    function _setBaseURI(string memory baseURI) internal {\n        _baseURI = baseURI;\n    }\n\n    /**\n     * @dev Returns the base URI set via {_setBaseURI}. This will be\n     * automatically added as a preffix in {tokenURI} to each token's URI, when\n     * they are non-empty.\n     *\n     * _Available since v2.5.0._\n     */\n    function baseURI() external view returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n/**\n * @title ERC721 Non-Fungible Pausable token\n * @dev ERC721 modified with pausable transfers.\n */\ncontract ERC721Pausable is ERC721, Pausable {\n    function approve(address to, uint256 tokenId) public whenNotPaused {\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address to, bool approved) public whenNotPaused {\n        super.setApprovalForAll(to, approved);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal whenNotPaused {\n        super._transferFrom(from, to, tokenId);\n    }\n}\n\ncontract Whitelist is Ownable {\n    using Roles for Roles.Role;\n\n    Roles.Role private _whitelists;\n\n    event WhitelistAdded(address indexed account);\n    event WhitelistRemoved(address indexed account);\n\n    function isWhitelist(address _account) public view returns (bool) {\n        return _whitelists.has(_account);\n    }\n\n    function addWhitelist(address _account) external onlyOwner {\n        _addWhitelist(_account);\n    }\n\n    function removeWhitelist(address _account) external onlyOwner {\n        _removeWhitelist(_account);\n    }\n\n    function renounceWhitelist() external {\n        _removeWhitelist(msg.sender);\n    }\n\n    function _addWhitelist(address _account) internal {\n        _whitelists.add(_account);\n        emit WhitelistAdded(_account);\n    }\n\n    function _removeWhitelist(address _account) internal {\n        _whitelists.remove(_account);\n        emit WhitelistRemoved(_account);\n    }\n}\n\ncontract ERC721Whitelist is ERC721, Whitelist {\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        require(isWhitelist(from) || isWhitelist(to), \"ERC721Whitelist: sender or recipient is not whitelist\");\n        super._transferFrom(from, to, tokenId);\n    }\n}\n\n/**\n * @title Full ERC721 Token\n * @dev This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology.\n *\n * See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Full is ERC721Enumerable, ERC721Metadata, ERC721Pausable, ERC721Whitelist {\n    constructor(string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        // TODO: implement later\n        // require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract GenesisKingdomToken is Operator, ERC721Full {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant SYSTEM_FEE_COEFF = 10000; // 10x percent, 10000 = 100%\n\n    struct Order {\n        // Order ID - in uuid format\n        uint128 id;\n        // List of land IDs will be exchanged in this order\n        uint128[] landIds;\n        // The order maker (in this app it's always seller)\n        address maker;\n        // The order taker (in this app it's always buyer)\n        address taker;\n        // The seller's desired currencies. This is actually ERC20 contract address\n        // For Ethereum as currency, will use special address 0x0\n        address[] offeredCurrencies;\n        // The seller's desired amount for each currency respestively\n        uint256[] offeredAmounts;\n        // The currency that buyer uses to fulfill the order\n        address fulfilledCurrency;\n        // The amount that buyer uses to fulfill the order\n        uint256 fulfilledAmount;\n        // The type of order\n        OrderType otype;\n        // The selling method\n        OrderSellingMethod sellingMethod;\n        // The status of order\n        OrderStatus status;\n    }\n\n    struct SystemFee {\n        uint128 id;\n        // % genesis fee per transaction\n        uint256 genesisFee;\n        // % inviter reward per transaction\n        uint256 inviterReward;\n        // % buyer reward per transaction\n        uint256 buyerReward;\n    }\n\n    enum OrderType { OrderIndividual, OrderBundle }\n\n    enum OrderSellingMethod { Acreage, Freely }\n\n    enum OrderStatus { OPEN, HOLDING, FULFILLED, CANCELLED }\n\n    // storage land name\n    mapping(uint128 => bytes32) private _nameOfLands;\n    // storage land bundle id\n    mapping(uint128 => uint128) private _bundleOfLands;\n    // storage orders\n    mapping(uint128 => Order) private _orders;\n    // storage land id or land bundle id in order\n    mapping(uint128 => uint128) private _goodIdOfOrders;\n    // storage the order holder\n    mapping(uint128 => address) private _orderHolders;\n    // storage the processed txid\n    mapping(string => bool) private _processedTxids;\n    // storage the system fees\n    mapping(uint128 => SystemFee) private _systemFees;\n    // storage the order system fee\n    mapping(uint128 => uint128) private _orderFees;\n\n    // fire when receive token\n    event Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);\n    // fire when a new order is created\n    event OrderCreate(address operator, uint128 indexed orderId);\n    // fire when seller want to update order price, selling method, fee\n    event OrderUpdate(address operator, uint128 indexed orderId);\n    // fire when seller cancel order\n    event OrderCancelled(address operator, uint128 indexed orderId);\n    // fire when buyer want to buy order by ether\n    event OrderHolding(address holder, uint128 indexed orderId);\n    // fire when the operator compelte order\n    event OrderFulfilled(address operator, uint128 indexed orderId);\n    // fire when a new system fee is created\n    event SystemFeeCreate(address operator, uint128 feeId);\n    // fire when the owner want to withdrawal ETH or ERC20\n    event Withdrawal(address operator, address recepient, address currency, uint256 amount);\n    // fire when the operator want to refund ETH or ERC20 to buyer\n    event Refund(address receiver, uint128 orderId, address currency, uint256 amount);\n\n    constructor(string memory _name, string memory _symbol) public ERC721Full(_name, _symbol) {\n        _addWhitelist(address(this));\n    }\n\n    /**\n     * ========================================================================================\n     * [GET] Land\n     */\n    /**\n     * @dev returns the land detail\n     * @param id the land id\n     * @return land detail\n     */\n    function getLandDetail(uint128 id)\n        external\n        view\n        returns (\n            uint128 landId,\n            uint128 landBundleId,\n            bytes32 lname,\n            address owner\n        )\n    {\n        landId = id;\n        lname = _nameOfLands[landId];\n        landBundleId = _bundleOfLands[landId];\n        owner = ownerOf(landId);\n    }\n\n    /**\n     * @dev check the token id has already exists\n     * @param id the token id\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function hasExistentToken(uint128 id) external view returns (bool) {\n        return _exists(id);\n    }\n\n    /**\n     * ========================================================================================\n     * [SET] Land\n     */\n    /**\n     * @dev the internal method to issue new land\n     * @param _owner the owner of the land\n     * @param _id the land id\n     * @param _name the land name\n     * @param _bundleId the land bundle id\n     */\n    function _issueNewLand(\n        address _owner,\n        uint128 _id,\n        bytes32 _name,\n        uint128 _bundleId\n    ) internal {\n        require(_bundleId != 0, \"GK: invalid bundleId\");\n        require(_name.length != 0, \"GK: invalid landName\");\n\n        _nameOfLands[_id] = _name;\n        _bundleOfLands[_id] = _bundleId;\n\n        _mint(_owner, _id);\n    }\n\n    /**\n     * @dev issue all lands of the specific bundle\n     * @param _owner the owner of the land\n     * @param _ids the array of land id\n     * @param _names the array of land name\n     * @param _bundleId the land bundle id\n     */\n    function issueNewLandBundle(\n        address _owner,\n        uint128[] calldata _ids,\n        bytes32[] calldata _names,\n        uint128 _bundleId\n    ) external onlyOwner whenNotPaused {\n        require(_ids.length == _names.length, \"GK: invalid array length\");\n        for (uint256 i = 0; i != _ids.length; i++) {\n            _issueNewLand(_owner, _ids[i], _names[i], _bundleId);\n        }\n    }\n\n    /**\n     * ========================================================================================\n     * [GET] Order\n     */\n    /**\n     * @dev returns the order detail\n     * @param _orderId the order id\n     * @return the land detail\n     */\n    function getOrderDetails(uint128 _orderId)\n        external\n        view\n        returns (\n            uint128 id,\n            uint128[] memory landIds,\n            address maker,\n            address taker,\n            address[] memory offeredCurrencies,\n            uint256[] memory offeredAmounts,\n            address fulfilledCurrency,\n            uint256 fulfilledAmount,\n            OrderType otype,\n            OrderSellingMethod sellingMethod,\n            OrderStatus status\n        )\n    {\n        Order memory order = _orders[_orderId];\n        id = order.id;\n        landIds = order.landIds;\n        maker = order.maker;\n        taker = order.taker;\n        offeredCurrencies = order.offeredCurrencies;\n        offeredAmounts = order.offeredAmounts;\n        fulfilledCurrency = order.fulfilledCurrency;\n        fulfilledAmount = order.fulfilledAmount;\n        otype = order.otype;\n        sellingMethod = order.sellingMethod;\n        status = order.status;\n    }\n\n    /**\n     * @dev returns the land id or bundle id in the order\n     * @param _orderId the order id\n     * @return can be the land id or bundle id\n     */\n    function getOrderGoodId(uint128 _orderId) external view returns (uint128) {\n        return _goodIdOfOrders[_orderId];\n    }\n\n    /**\n     * @dev returns the system fee in the order\n     * @param _orderId the order id\n     * @return the system fee id\n     */\n    function getOrderGenesisFeeId(uint128 _orderId) external view returns (uint128 feeId) {\n        return _orderFees[_orderId];\n    }\n\n    /**\n     * @dev check order id has already exists\n     * @param _orderId the order id\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function hasExistentOrder(uint128 _orderId) external view returns (bool) {\n        return _orders[_orderId].id != 0;\n    }\n\n    /**\n     * ========================================================================================\n     * [SET] Order\n     */\n    function _preValidateOrder(\n        uint128 _orderId,\n        uint128 _goodId,\n        address[] memory _offeredCurrencies,\n        uint256[] memory _offeredAmounts,\n        uint128 _feeId\n    ) internal view {\n        require(_orderId != 0, \"GK: invalid orderId\");\n        require(_orders[_orderId].id == 0, \"GK: order has already exists\");\n        require(_goodId != 0, \"GK: invalid goodId\");\n        require(_offeredCurrencies.length == _offeredAmounts.length, \"GK: invalid array length\");\n        require(_systemFees[_feeId].id != 0, \"GK: invalid system fee\");\n    }\n\n    /**\n     * @dev the internal method to create new order\n     * @param _orderId the order id\n     * @param _goodId the land id or bundle id\n     * @param _landIds the array of the land id\n     * @param _offeredCurrencies the array of the offered currency\n     * @param _offeredAmounts the array of the offered amount\n     * @param _type the order type\n     * @param _sellingMethod the order selling method\n     * @param _feeId the system fee id\n     */\n    function _createOrder(\n        uint128 _orderId,\n        uint128 _goodId,\n        uint128[] memory _landIds,\n        address[] memory _offeredCurrencies,\n        uint256[] memory _offeredAmounts,\n        OrderType _type,\n        OrderSellingMethod _sellingMethod,\n        uint128 _feeId\n    ) internal {\n        _orders[_orderId] = Order(\n            _orderId,\n            _landIds,\n            msg.sender,\n            address(0),\n            _offeredCurrencies,\n            _offeredAmounts,\n            address(0),\n            0,\n            _type,\n            _sellingMethod,\n            OrderStatus.OPEN\n        );\n        _orderFees[_orderId] = _feeId;\n        _goodIdOfOrders[_orderId] = _goodId;\n\n        emit OrderCreate(msg.sender, _orderId);\n    }\n\n    /**\n     * @dev using for issue and create land bundle order\n     * @param _orderId the order id\n     * @param _bundleId the land bundle id\n     * @param _ids the array of the land id\n     * @param _names the array of the land name\n     * @param _offeredCurrencies the array of the offered currency\n     * @param _offeredAmounts the array of the offered amount\n     * @param _sellingMethod the order selling method\n     * @param _feeId the system fee id\n     */\n    function issueAndCreateLandBundleOrder(\n        uint128 _orderId,\n        uint128 _bundleId,\n        uint128[] calldata _ids,\n        bytes32[] calldata _names,\n        address[] calldata _offeredCurrencies,\n        uint256[] calldata _offeredAmounts,\n        OrderSellingMethod _sellingMethod,\n        uint128 _feeId\n    ) external onlyOwner whenNotPaused {\n        for (uint256 i = 0; i != _ids.length; i++) {\n            _issueNewLand(address(this), _ids[i], _names[i], _bundleId);\n        }\n\n        _preValidateOrder(_orderId, _bundleId, _offeredCurrencies, _offeredAmounts, _feeId);\n\n        _createOrder(_orderId, _bundleId, _ids, _offeredCurrencies, _offeredAmounts, OrderType.OrderBundle, _sellingMethod, _feeId);\n    }\n\n    /**\n     * @dev using for create a new order to sell single land\n     * @param _orderId the order id\n     * @param _landId the land id\n     * @param _offeredCurrencies the array of the offered currency\n     * @param _offeredAmounts the array of the offered amount\n     * @param _sellingMethod the order selling method\n     * @param _feeId the system fee id\n     */\n    function createSingleLandOrder(\n        uint128 _orderId,\n        uint128 _landId,\n        address[] calldata _offeredCurrencies,\n        uint256[] calldata _offeredAmounts,\n        OrderSellingMethod _sellingMethod,\n        uint128 _feeId\n    ) external whenNotPaused {\n        uint128[] memory _landIds = new uint128[](1);\n        _landIds[0] = _landId;\n\n        _preValidateOrder(_orderId, _landId, _offeredCurrencies, _offeredAmounts, _feeId);\n\n        transferFrom(msg.sender, address(this), _landId);\n\n        _createOrder(_orderId, _landId, _landIds, _offeredCurrencies, _offeredAmounts, OrderType.OrderIndividual, _sellingMethod, _feeId);\n    }\n\n    /**\n     * @dev using for create a new order to sell land bundle\n     * @param _orderId the order id\n     * @param _bundleId the land bundle id\n     * @param _offeredCurrencies the array of the offered currency\n     * @param _offeredAmounts the array of the offered amount\n     * @param _sellingMethod the order selling method\n     * @param _feeId the system fee id\n     */\n    function createLandBundleOrder(\n        uint128 _orderId,\n        uint128 _bundleId,\n        uint128[] calldata _landIds,\n        address[] calldata _offeredCurrencies,\n        uint256[] calldata _offeredAmounts,\n        OrderSellingMethod _sellingMethod,\n        uint128 _feeId\n    ) external whenNotPaused {\n        _preValidateOrder(_orderId, _bundleId, _offeredCurrencies, _offeredAmounts, _feeId);\n\n        _batchSafeTransferFrom(address(0), msg.sender, address(this), _landIds);\n\n        _createOrder(_orderId, _bundleId, _landIds, _offeredCurrencies, _offeredAmounts, OrderType.OrderBundle, _sellingMethod, _feeId);\n    }\n\n    /**\n     * @dev using for update order price, selling method, fee\n     * @param _orderId the order id\n     * @param _offeredCurrencies the array of the offered currency\n     * @param _offeredAmounts the array of the offered amount\n     * @param _sellingMethod the order selling method\n     * @param _feeId the system fee id\n     */\n    function updateOrder(\n        uint128 _orderId,\n        address[] calldata _offeredCurrencies,\n        uint256[] calldata _offeredAmounts,\n        OrderSellingMethod _sellingMethod,\n        uint128 _feeId\n    ) external whenNotPaused {\n        Order storage order = _orders[_orderId];\n        require(order.id != 0, \"GK: caller query nonexistent order\");\n        require(msg.sender == order.maker, \"GK: only maker can update order\");\n        require(order.status == OrderStatus.OPEN, \"GK: order not allow to update\");\n        require(_systemFees[_feeId].id != 0, \"GK: invalid system fee\");\n        require(_offeredCurrencies.length == _offeredAmounts.length, \"GK: invalid array length\");\n\n        order.offeredCurrencies = _offeredCurrencies;\n        order.offeredAmounts = _offeredAmounts;\n        order.sellingMethod = _sellingMethod;\n        _orderFees[_orderId] = _feeId;\n\n        emit OrderUpdate(msg.sender, order.id);\n    }\n\n    /**\n     * @dev using for cancel order\n     * @param _orderId the order id\n     */\n    function cancelOrder(uint128 _orderId) external whenNotPaused {\n        Order storage order = _orders[_orderId];\n        require(order.id != 0, \"GK: caller query nonexistent order\");\n        require(msg.sender == order.maker, \"GK: only maker can cancel order\");\n        require(order.status == OrderStatus.OPEN, \"GK: order not allow to cancel\");\n\n        if (order.otype == OrderType.OrderIndividual) {\n            IERC721(address(this)).safeTransferFrom(address(this), order.maker, order.landIds[0]);\n        } else if (order.otype == OrderType.OrderBundle) {\n            _batchSafeTransferFrom(address(this), address(this), order.maker, order.landIds);\n        }\n        order.status = OrderStatus.CANCELLED;\n\n        emit OrderCancelled(msg.sender, order.id);\n    }\n\n    /**\n     * @dev buyer can take order by staking ether\n     * @param _orderId the order id\n     */\n    function takeOrderByEther(uint128 _orderId) external payable whenNotPaused {\n        Order storage order = _orders[_orderId];\n        require(order.id != 0, \"GK: caller query nonexistent order\");\n        require(order.maker != msg.sender, \"GK: you are owner\");\n        if (order.status == OrderStatus.OPEN) {\n            uint256 _amount = 0;\n            for (uint256 i = 0; i != order.offeredCurrencies.length; i++) {\n                if (order.offeredCurrencies[i] == address(0)) {\n                    _amount = order.offeredAmounts[i];\n                    break;\n                }\n            }\n            require(_amount != 0 && msg.value == _amount, \"GK: invalid amount\");\n\n            order.status = OrderStatus.HOLDING;\n            _orderHolders[_orderId] = msg.sender;\n\n            emit OrderHolding(msg.sender, order.id);\n        } else {\n            // refund ether to buyer\n            msg.sender.transfer(msg.value);\n            emit Refund(msg.sender, _orderId, address(0), msg.value);\n        }\n    }\n\n    /**\n     * @dev using for complete the order by the system operator\n     * @param _orderId the order id\n     * @param _taker the buyer address\n     * @param _currency the payable currency\n     * @param _amount the payable amount\n     * @param _txid the taken txid\n     */\n    function completeOrder(\n        uint128 _orderId,\n        address _taker,\n        address _currency,\n        uint256 _amount,\n        string calldata _txid\n    ) external whenNotPaused {\n        require(isOperator(msg.sender), \"GK: caller is not operator\");\n        require(_taker != address(0), \"GK: invalid address\");\n        if (_orderHolders[_orderId] != address(0)) {\n            require(_taker == _orderHolders[_orderId], \"GK: invalid taker\");\n        }\n        Order storage order = _orders[_orderId];\n        require(order.id != 0, \"GK: caller query nonexistent order\");\n        require(order.maker != _taker, \"GK: you are owner\");\n        require(order.status == OrderStatus.OPEN || order.status == OrderStatus.HOLDING, \"GK: cannot complete this order\");\n        require(!_processedTxids[_txid], \"GK: txid has processed\");\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i != order.offeredCurrencies.length; i++) {\n            if (_currency == order.offeredCurrencies[i]) {\n                amount = order.offeredAmounts[i];\n                break;\n            }\n        }\n        require(amount != 0 && amount == _amount, \"GK: invalid amount\");\n\n        uint256 fee = 0;\n        if (order.maker != owner()) {\n            SystemFee memory sFee = _systemFees[_orderFees[_orderId]];\n            fee = _amount.mul(sFee.genesisFee).div(SYSTEM_FEE_COEFF);\n        }\n\n        // The transfer amount equals the offer amount sub the genesis fee\n        if (_currency == address(0)) {\n            // Transfer ether to the seller\n            order.maker.toPayable().transfer(amount.sub(fee));\n        } else {\n            // Transfer erc20 token to the seller\n            IERC20(_currency).safeTransfer(order.maker, amount.sub(fee));\n        }\n\n        // Transfer the land to buyer\n        if (order.otype == OrderType.OrderIndividual) {\n            IERC721(address(this)).safeTransferFrom(address(this), _taker, order.landIds[0]);\n        } else if (order.otype == OrderType.OrderBundle) {\n            _batchSafeTransferFrom(address(this), address(this), _taker, order.landIds);\n        }\n\n        order.taker = _taker;\n        order.fulfilledCurrency = _currency;\n        order.fulfilledAmount = amount;\n        order.status = OrderStatus.FULFILLED;\n\n        _orderHolders[_orderId] = _taker;\n        _processedTxids[_txid] = true;\n\n        emit OrderFulfilled(msg.sender, order.id);\n    }\n\n    /**\n     * ========================================================================================\n     * [GET] System Fee\n     */\n    /**\n     * @dev returns the system fee\n     * @param _feeId the system fee id\n     * @return the system fee detail\n     */\n    function getSystemFee(uint128 _feeId)\n        external\n        view\n        returns (\n            uint128 feeId,\n            uint256 genesisFee,\n            uint256 inviterReward,\n            uint256 buyerReward\n        )\n    {\n        feeId = _systemFees[_feeId].id;\n        genesisFee = _systemFees[_feeId].genesisFee;\n        inviterReward = _systemFees[_feeId].inviterReward;\n        buyerReward = _systemFees[_feeId].buyerReward;\n    }\n\n    /**\n     * ========================================================================================\n     * [SET] System Fee\n     */\n    /**\n     * @dev using for set a new system fee\n     * @param _feeId the system fee id\n     * @param _genesisFee the genesis fee percentage\n     * @param _inviterReward the inviter reward percentage\n     * @param _buyerReward the buyer reward percentage\n     */\n    function setNewSystemFee(\n        uint128 _feeId,\n        uint256 _genesisFee,\n        uint256 _inviterReward,\n        uint256 _buyerReward\n    ) external onlyOwner whenNotPaused {\n        require(_feeId != 0, \"GK: invalid feeId\");\n        require(_systemFees[_feeId].id == 0, \"GK: fee has already exists\");\n\n        _systemFees[_feeId] = SystemFee(_feeId, _genesisFee, _inviterReward, _buyerReward);\n        emit SystemFeeCreate(msg.sender, _feeId);\n    }\n\n    /**\n     * ========================================================================================\n     * [SET] Withdrawal & Refund\n     */\n    /**\n     * @dev the internal method used to withdrawal ETH or ERC20\n     * @param _recepient the receiver address\n     * @param _currency the withdrawal currency (can be ETH or ERC20)\n     * @param _amount the withdrawl amount\n     */\n    function _withdrawal(\n        address _recepient,\n        address _currency,\n        uint256 _amount\n    ) internal {\n        require(_recepient != address(0), \"GK: invalid address\");\n        require(_amount != 0, \"GK: invalid amount\");\n        if (_currency == address(0)) {\n            require(address(this).balance >= _amount, \"GK: balance not enough\");\n            _recepient.toPayable().transfer(_amount);\n        } else {\n            uint256 balance = IERC20(_currency).balanceOf(address(this));\n            require(balance >= _amount, \"GK: balance not enough\");\n            IERC20(_currency).safeTransfer(_recepient, _amount);\n        }\n    }\n\n    /**\n     * @dev the owner can use to withdrawal ETH or ERC20\n     * @param _recepient the receiver address\n     * @param _currency the withdrawal currency (can be ETH or ERC20)\n     * @param _amount the withdrawal amount\n     */\n    function withdrawal(\n        address _recepient,\n        address _currency,\n        uint256 _amount\n    ) external onlyOwner {\n        _withdrawal(_recepient, _currency, _amount);\n        emit Withdrawal(msg.sender, _recepient, _currency, _amount);\n    }\n\n    /**\n     * @dev the operator can use to refund ETH or ERC20 to buyer\n     * @param _orderId the refund order id\n     * @param _recepient the receiver address\n     * @param _currency the refund currency (can be ETH or ERC20)\n     * @param _amount the refund amount\n     */\n    function refund(\n        uint128 _orderId,\n        address _recepient,\n        address _currency,\n        uint256 _amount\n    ) external whenNotPaused {\n        require(isOperator(msg.sender), \"GK: caller is not operator\");\n        require(_orders[_orderId].id != 0, \"GK: caller query nonexistent order\");\n        _withdrawal(_recepient, _currency, _amount);\n        emit Refund(_recepient, _orderId, _currency, _amount);\n    }\n\n    /**\n     * ========================================================================================\n     * [SET] Override ERC721Metadata\n     */\n    function setTokenURI(uint256 tokenId, string calldata _tokenURI) external onlyOwner {\n        super._setTokenURI(tokenId, _tokenURI);\n    }\n\n    function setBaseURI(string calldata baseURI) external onlyOwner {\n        super._setBaseURI(baseURI);\n    }\n\n    /**\n     * ========================================================================================\n     * [SET] Others\n     */\n    /**\n     * @dev the internal method to transfer multiple tokens\n     * @param _token the ERC721 token address\n     * @param _from the token holder address\n     * @param _recepient the receiver address\n     * @param _tokenIds the array of the token\n     */\n    function _batchSafeTransferFrom(\n        address _token,\n        address _from,\n        address _recepient,\n        uint128[] memory _tokenIds\n    ) internal {\n        for (uint256 i = 0; i != _tokenIds.length; i++) {\n            if (_token != address(0)) {\n                IERC721(_token).safeTransferFrom(_from, _recepient, _tokenIds[i]);\n            } else {\n                safeTransferFrom(_from, _recepient, _tokenIds[i]);\n            }\n        }\n    }\n\n    /**\n     * ========================================================================================\n     * [GET] Callback\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) public returns (bytes4) {\n        emit Received(operator, from, tokenId, data, gasleft());\n        return 0x150b7a02;\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"orderId\",\"type\":\"uint128\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"orderId\",\"type\":\"uint128\"}],\"name\":\"OrderCreate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"orderId\",\"type\":\"uint128\"}],\"name\":\"OrderFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"orderId\",\"type\":\"uint128\"}],\"name\":\"OrderHolding\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"orderId\",\"type\":\"uint128\"}],\"name\":\"OrderUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"orderId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"feeId\",\"type\":\"uint128\"}],\"name\":\"SystemFeeCreate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recepient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYSTEM_FEE_COEFF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_taker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_txid\",\"type\":\"string\"}],\"name\":\"completeOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_bundleId\",\"type\":\"uint128\"},{\"internalType\":\"uint128[]\",\"name\":\"_landIds\",\"type\":\"uint128[]\"},{\"internalType\":\"address[]\",\"name\":\"_offeredCurrencies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_offeredAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"enum GenesisKingdomToken.OrderSellingMethod\",\"name\":\"_sellingMethod\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"_feeId\",\"type\":\"uint128\"}],\"name\":\"createLandBundleOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_landId\",\"type\":\"uint128\"},{\"internalType\":\"address[]\",\"name\":\"_offeredCurrencies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_offeredAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"enum GenesisKingdomToken.OrderSellingMethod\",\"name\":\"_sellingMethod\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"_feeId\",\"type\":\"uint128\"}],\"name\":\"createSingleLandOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"id\",\"type\":\"uint128\"}],\"name\":\"getLandDetail\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"landId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"landBundleId\",\"type\":\"uint128\"},{\"internalType\":\"bytes32\",\"name\":\"lname\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"}],\"name\":\"getOrderDetails\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"id\",\"type\":\"uint128\"},{\"internalType\":\"uint128[]\",\"name\":\"landIds\",\"type\":\"uint128[]\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"offeredCurrencies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"offeredAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"fulfilledCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fulfilledAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum GenesisKingdomToken.OrderType\",\"name\":\"otype\",\"type\":\"uint8\"},{\"internalType\":\"enum GenesisKingdomToken.OrderSellingMethod\",\"name\":\"sellingMethod\",\"type\":\"uint8\"},{\"internalType\":\"enum GenesisKingdomToken.OrderStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"}],\"name\":\"getOrderGenesisFeeId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"feeId\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"}],\"name\":\"getOrderGoodId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_feeId\",\"type\":\"uint128\"}],\"name\":\"getSystemFee\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"feeId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"genesisFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviterReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyerReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"}],\"name\":\"hasExistentOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"id\",\"type\":\"uint128\"}],\"name\":\"hasExistentToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_bundleId\",\"type\":\"uint128\"},{\"internalType\":\"uint128[]\",\"name\":\"_ids\",\"type\":\"uint128[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_names\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_offeredCurrencies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_offeredAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"enum GenesisKingdomToken.OrderSellingMethod\",\"name\":\"_sellingMethod\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"_feeId\",\"type\":\"uint128\"}],\"name\":\"issueAndCreateLandBundleOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint128[]\",\"name\":\"_ids\",\"type\":\"uint128[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_names\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint128\",\"name\":\"_bundleId\",\"type\":\"uint128\"}],\"name\":\"issueNewLandBundle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_recepient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_feeId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"_genesisFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inviterReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyerReward\",\"type\":\"uint256\"}],\"name\":\"setNewSystemFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"}],\"name\":\"takeOrderByEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderId\",\"type\":\"uint128\"},{\"internalType\":\"address[]\",\"name\":\"_offeredCurrencies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_offeredAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"enum GenesisKingdomToken.OrderSellingMethod\",\"name\":\"_sellingMethod\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"_feeId\",\"type\":\"uint128\"}],\"name\":\"updateOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recepient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GenesisKingdomToken","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000f47656e65736973204b696e67646f6d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002474b000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}