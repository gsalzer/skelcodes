{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPLv3\r\n\r\n/**\r\n  Note that this is contract is not under the MIT license. While this is still open source code,\r\n  there are still limitations when using this contract.\r\n */\r\n\r\npragma solidity 0.6.11;\r\n\r\n// This contract defines the staking functionality for use within Triatic with the Triatic native token (TRA)\r\n// You are not authorized to use this contract with proper attribution.\r\n// If you see this comment in another project, it means that that project has yet to request permission to use this contract.\r\n\r\n// 2020 Triatic. All Rights Reserved.\r\n\r\n\r\n// Interface defines the TRA token\r\ninterface TRA {\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Staking {\r\n  // THIS STAKING CONTRACT IS PART OF TRIATIC SOURCE CODE.\r\n  // DO NOT COPY WITHOUT PROPER ATTRIBUTION.\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) public _StakeAmounts;\r\n  mapping (address => uint256) public _AccoutNonce;\r\n  mapping (address => bytes32[]) public _Hashes;\r\n  mapping (address => mapping(bytes32 => uint256)) public _HashToTime;\r\n  mapping (address => mapping(bytes32 => uint256)) public _HashToAmount;\r\n  // 15P/A\r\n  uint256 public _interestRate = 15;\r\n  address public _owner;\r\n  address public _TRAAddress;\r\n\r\n  TRA public _TRAContract;\r\n\r\n  // Constructor sets the address of the token\r\n  constructor() public {\r\n    _owner = msg.sender;\r\n    _TRAAddress = address(0);\r\n    _TRAContract = TRA(_TRAAddress);\r\n\r\n  }\r\n  event log(address owner,uint256 amount);\r\n  // Changes the token contract, and sets the interface to that token contract\r\n  function SetTRAAddress(address TRAAddress) public {\r\n    require(msg.sender == _owner,\"Only owners can change the TRA address\");\r\n    _TRAAddress = TRAAddress;\r\n    _TRAContract = TRA(_TRAAddress);\r\n  }\r\n\r\n  // Stake: Transfers x amount TRA to this contract.\r\n  // The user needs to approve this contract\r\n  function Stake(uint256 amount) public returns(bytes32) {\r\n    _StakeAmounts[msg.sender] = _StakeAmounts[msg.sender].add(amount);\r\n    // Get the nonce.\r\n    uint256 nonce = _AccoutNonce[msg.sender];\r\n    // Generate a staking hash for the user.\r\n    bytes32 stakingHash = keccak256(abi.encode(msg.sender,nonce,amount));\r\n    // Store the hashes in a list and amount for easy retrieval\r\n    bytes32[] storage hashList = _Hashes[msg.sender];\r\n    hashList.push(stakingHash);\r\n    \r\n    // Store all amounts for calculations.\r\n    _HashToTime[msg.sender][stakingHash] = block.timestamp;\r\n    _HashToAmount[msg.sender][stakingHash] = amount;\r\n    _AccoutNonce[msg.sender] = _AccoutNonce[msg.sender].add(1);\r\n    _TRAContract.transferFrom(msg.sender,address(this),amount);\r\n    return stakingHash;\r\n  }\r\n\r\n  // GetStakes: Return all staking transactions\r\n  function GetStakes(address account) public view returns (bytes32[] memory) {\r\n    bytes32[] memory hashList = _Hashes[account];\r\n    return hashList;\r\n  }\r\n\r\n  // Unstake: Unstake x amount TRA from this contract\r\n  // Sends back to the user\r\n  function UnstakeAll() public {\r\n    uint256 _totalStaked = _StakeAmounts[msg.sender];\r\n    _StakeAmounts[msg.sender] = 0;\r\n    uint256 interest = CalculateInterest(msg.sender);\r\n    \r\n    // Empty the array\r\n    delete _Hashes[msg.sender];\r\n\r\n    // Interest is deducted from the staking pool's balance\r\n    _TRAContract.transfer(msg.sender,_totalStaked.add(interest));\r\n  }\r\n\r\n  function GetStakingBalance(address owner) public view returns (uint256) {\r\n    return _StakeAmounts[owner];\r\n  }\r\n\r\n  function CalculateInterestForStake(address owner,bytes32 stakeHash) public view returns(uint256) {\r\n    mapping(bytes32 => uint256) storage times = _HashToTime[owner];\r\n    mapping(bytes32 => uint256) storage amounts = _HashToAmount[owner];\r\n    \r\n    uint256 timeStaked = times[stakeHash];\r\n    uint256 amountStaked = amounts[stakeHash];\r\n    uint256 timeElapsed = block.timestamp.sub(timeStaked);\r\n    uint256 numerator = amountStaked.mul(_interestRate).mul(timeElapsed);\r\n    uint256 denominator = 100 * 31556952;\r\n    uint256 interestEarned = numerator / denominator;\r\n    return interestEarned;\r\n  }\r\n\r\n  function CalculateInterest(address owner) public view returns(uint256) {\r\n    // First lets get the list of staking hashes of for the owner\r\n    bytes32[] storage hashList = _Hashes[owner];\r\n    mapping(bytes32 => uint256) storage times = _HashToTime[owner];\r\n    mapping(bytes32 => uint256) storage amounts = _HashToAmount[owner];\r\n    uint256 interest = 0;\r\n    for(uint256 i = 0;i<hashList.length;i++) {\r\n      // Get the time elapsed from the hash and amount associated with that transaction hash\r\n      uint256 timeStaked = times[hashList[i]];\r\n      uint256 amountStaked = amounts[hashList[i]];\r\n      uint256 timeElapsed = block.timestamp.sub(timeStaked);\r\n      uint256 numerator = amountStaked.mul(_interestRate).mul(timeElapsed);\r\n      uint256 denominator = 100 * 31556952;\r\n      uint256 interestEarned = numerator / denominator;\r\n      interest = interest.add(interestEarned);\r\n    }\r\n    return interest;\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"log\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"CalculateInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"stakeHash\",\"type\":\"bytes32\"}],\"name\":\"CalculateInterestForStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GetStakes\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"GetStakingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TRAAddress\",\"type\":\"address\"}],\"name\":\"SetTRAAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UnstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_AccoutNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_HashToAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_HashToTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_Hashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_StakeAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TRAAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TRAContract\",\"outputs\":[{\"internalType\":\"contract TRA\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_interestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b374ac70fa5fdb4c596c0e32c375bc8255ac643121a3abce58918cc31e868592"}]}