{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\nabstract contract IERC721 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    //function name() public view returns (string memory name);\r\n    //function symbol() public view returns (string memory symbol);\r\n    //function totalSupply() public view returns (uint256 totalSupply);\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) external virtual view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) external virtual view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either `approve` or `setApproveForAll`.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external virtual;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either `approve` or `setApproveForAll`.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external virtual;\r\n    function approve(address to, uint256 tokenId) external virtual;\r\n    function getApproved(uint256 tokenId) external virtual view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public virtual;\r\n    function isApprovedForAll(address owner, address operator) public virtual view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\nabstract contract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public virtual returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract OasisTok is IERC721\r\n {\r\n    using SafeMath for uint256;\r\n    event tokenMinted(uint256 tokenId, address owner);\r\n    event tokenBurned(uint256 tokenId);\r\n    event TokenTransferred(address from, address to, uint256 tokenId);\r\n    event ApprovalForAll(address from, address to, bool approved);\r\n \r\n    // Mapping ontology id to Hash(properties)\r\n  \r\n    struct Multihash\r\n    {\r\n      uint8 hashFunction;\r\n      uint8 size;\r\n      bytes32 digest;\r\n    } \r\n     \r\n    struct OSC\r\n    {\r\n     Multihash ontology;\r\n     Multihash query;\r\n     uint256 prev;\r\n    }\r\n    \r\n    mapping(bytes32 => uint) ontoHashToId;\r\n    mapping (uint => address) ontologyOwner;\r\n    mapping (uint => bool)  ontologyActive;\r\n    mapping (address => uint) public ownerOntoCount;\r\n      // Mapping from token ID to approved address\r\n    mapping (uint => address) ontologyApprovals;\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) operatorApprovals;\r\n\r\n    address _contOwner;\r\n    string _name;\r\n    string _symbol;\r\n     \r\n    OSC[] private ontologies;\r\n    \r\n    constructor(string memory name, string memory symbol)\r\n        public\r\n    {\r\n        _contOwner = msg.sender;\r\n        _name = name;\r\n        _symbol = symbol;\r\n        //burn token 0\r\n        bytes32 hash = keccak256(abi.encodePacked(uint8(0), uint8(0), bytes32(0), uint8(0), uint8(0), bytes32(0), uint256(0))); \r\n        OSC memory osc= OSC(Multihash(uint8(0), uint8(0), bytes32(0)), Multihash(uint8(0),uint8(0), bytes32(0)), uint256(0));    \r\n        ontologies.push(osc);         \r\n        ontoHashToId[hash] = 0;\r\n        ontologyOwner[0] = address(0); \r\n        ontologyActive[0] = false;\r\n\r\n    }\r\n    \r\n       \r\n   function mint (uint8 hashO, uint8 sizeO, bytes32 digestO, uint8 hashQ, uint8 sizeQ, bytes32 digestQ, uint256 prev) public \r\n      {\r\n         if(tokenExists(hashO, sizeO, digestO, hashQ, sizeQ, digestQ, prev)) \r\n         {\r\n            revert(\"This token already exist!\");\r\n         }\r\n         if (prev != 0 && !tokenIDExists(prev))\r\n         {\r\n           revert(\"Previous token does not exists or different from 0!\");\r\n         }\r\n         bytes32 hash = keccak256(abi.encodePacked(hashO, sizeO, digestO, hashQ, sizeQ, digestQ, prev)); \r\n         OSC memory osc= OSC(Multihash(hashO, sizeO, digestO), Multihash(hashQ, sizeQ, digestQ), prev);    \r\n         ontologies.push(osc);\r\n         uint256 id = ontologies.length;\r\n         id--;\r\n         ontoHashToId[hash] = id;\r\n         ontologyOwner[id] = msg.sender; \r\n         ontologyActive[id] = true;        \r\n         ownerOntoCount[msg.sender] = SafeMath.add(ownerOntoCount[msg.sender], 1);         \r\n\r\n         emit tokenMinted (id, msg.sender);        \r\n     }\r\n     \r\n     function burn (uint256 id) external\r\n     {\r\n         require(msg.sender == ontologyOwner[id]);\r\n         require(tokenIDExists(id));\r\n         ontologyActive[id]= false;        \r\n         ownerOntoCount[msg.sender] = SafeMath.sub(ownerOntoCount[msg.sender], 1);\r\n         //ontologyOwner[id]=address(0);\r\n         emit tokenBurned(id);\r\n     }\r\n     \r\n     function  transferFrom(address from, address to, uint256 id) public override\r\n     {\r\n         require(from != address(0) && to != address(0));\r\n         require(_isApprovedOrOwner(msg.sender, id));\r\n         require(tokenIDExists(id));\r\n         ontologyOwner[id] = to;\r\n          _clearApproval(to, id);\r\n         ownerOntoCount[to] = SafeMath.add(ownerOntoCount[to], 1);\r\n         ownerOntoCount[from] = SafeMath.sub(ownerOntoCount[from], 1);\r\n         emit TokenTransferred(from, to,id);\r\n         \r\n     }\r\n\r\n     \r\n     function tokenExists(uint8 hashO, uint8 sizeO, bytes32 digestO, uint8 hashQ, uint8 sizeQ, bytes32 digestQ, uint256 prev) public view returns (bool)\r\n     {        \r\n        bytes32 hash = keccak256(abi.encodePacked(hashO, sizeO, digestO, hashQ, sizeQ, digestQ, prev));\r\n        if (ontoHashToId[hash] == 0)\r\n        {\r\n           return false;\r\n        }\r\n        return true;\r\n     }\r\n     \r\n     function tokenIDExists(uint256 id) public view returns (bool)\r\n     {\r\n         return ontologyActive[id];\r\n     }\r\n     \r\n     function getTokenInfo(uint256 id) public view returns (uint8 hashO, uint8 sizeO, bytes32 digestO, uint8 hashQ, uint8 sizeQ, bytes32 digestQ, uint256 prev)\r\n     {\r\n         return (ontologies[id].ontology.hashFunction,\r\n                 ontologies[id].ontology.size,\r\n                 ontologies[id].ontology.digest,\r\n                 ontologies[id].query.hashFunction,\r\n                 ontologies[id].query.size,\r\n                 ontologies[id].query.digest,\r\n                 ontologies[id].prev);\r\n\r\n     }\r\n     \r\n  \r\n     function balanceOf(address _tokenOwner)  \r\n        public\r\n        view override\r\n        returns(uint256 _balance)\r\n    {\r\n        return ownerOntoCount[_tokenOwner];\r\n    }\r\n\r\n\r\n\r\n     \r\n     // Approve other wallet to transfer ownership of token\r\n    function approve(address _to, uint256 id) public override\r\n    {\r\n        require(msg.sender == ontologyOwner[id]);\r\n        ontologyApprovals[id] = _to;\r\n        emit Approval(msg.sender, _to, id);\r\n    }\r\n\r\n    // Return approved address for specific token\r\n    function getApproved(uint256 id)  public view override returns(address operator)\r\n    {\r\n        require(tokenIDExists(id));\r\n        return ontologyApprovals[id];\r\n    }\r\n\r\n    /**\r\n     * Private function to clear current approval of a given token ID\r\n     * Reverts if the given address is not indeed the owner of the token\r\n     */\r\n    function _clearApproval(address owner, uint256 id) private\r\n    {\r\n        require(ontologyOwner[id] == owner);\r\n        require(tokenIDExists(id));\r\n        if (ontologyApprovals[id] != address(0)) {\r\n            ontologyApprovals[id] = address(0);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     */\r\n     function setApprovalForAll(address to, bool approved)  public override\r\n    {\r\n        require(to != msg.sender);\r\n        operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    // Tells whether an operator is approved by a given owner\r\n    function isApprovedForAll(address Owner, address operator)  public  view override returns(bool)\r\n    {\r\n        return operatorApprovals[Owner][operator];\r\n    }\r\n\r\n    // Take ownership of token - only for approved users\r\n    function takeOwnership(uint256 id)  public\r\n    {\r\n        require(_isApprovedOrOwner(msg.sender, id));\r\n        address Owner = ownerOf(id);\r\n        transferFrom(Owner, msg.sender, id);\r\n    }\r\n\r\n     function _isApprovedOrOwner(address spender, uint256 id) internal   view   returns(bool)\r\n    {\r\n        address Owner = ontologyOwner[id];\r\n        return (spender == Owner || getApproved(id) == spender || isApprovedForAll(Owner, spender));\r\n    }\r\n\r\n     function ownerOf(uint256 id)  public  view  override returns(address _owner)\r\n    {\r\n        return  ontologyOwner[id];\r\n    }\r\n\r\n\r\n     \r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n     \r\n    // Return the owner address\r\n    function owner()\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return _contOwner;\r\n    }\r\n\r\n    // Returns true if the caller is the current owner.\r\n    function isOwner()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return msg.sender == _contOwner;\r\n    }\r\n\t\r\n\t// Destroy this smart contract and withdraw balance to owner\r\n\tfunction shutdown() public\r\n\t\tonlyOwner\r\n\t{\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n     \r\n      // Throws if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n     \r\n     \r\n      /**\r\n     * Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n    */\r\n    function safeTransferFrom(address from, address to, uint256 id)  external override\r\n    {\r\n        // solium-disable-next-line arg-overflow\r\n        safeTransferFrom(from, to, id, \"\");\r\n    }\r\n\r\n    /**\r\n     * Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory _data) public override\r\n    {\r\n        transferFrom(from, to, id);\r\n        // solium-disable-next-line arg-overflow\r\n        require(_checkOnERC721Received(from, to, id, _data));\r\n    }\r\n\r\n    // Returns whether the target address is a contract\r\n    function isContract(address account)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    \r\n     /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!isContract(to)) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n\r\n    // Allows the owener to capture the balance available to the contract.\r\n    function withdrawBalance()\r\n        external\r\n        onlyOwner\r\n    {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n     \r\n }","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokenMinted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"hashO\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sizeO\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"digestO\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashQ\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sizeQ\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"digestQ\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"prev\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"hashO\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sizeO\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"digestO\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashQ\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sizeQ\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"digestQ\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"prev\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerOntoCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"hashO\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sizeO\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"digestO\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"hashQ\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sizeQ\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"digestQ\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"prev\",\"type\":\"uint256\"}],\"name\":\"tokenExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenIDExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OasisTok","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000d4f415349534f5343546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044f53435400000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cd62244249e1240d500c8037f8bf6beb77ef1946e211144692beb3908ba802f7"}]}