{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\ninterface RegistryInterface {\r\n    function proxies(address) external view returns (address);\r\n}\r\n\r\ninterface UserWalletInterface {\r\n    function owner() external view returns (address);\r\n}\r\n\r\ninterface MemoryInterface {\r\n    function getUint(uint _id) external returns (uint _num);\r\n    function setUint(uint _id, uint _val) external;\r\n}\r\n\r\ninterface EventInterface {\r\n    function emitEvent(uint connectorType, uint connectorID, bytes32 eventCode, bytes calldata eventData) external;\r\n}\r\n\r\ninterface TokenInterface {\r\n    function balanceOf(address) external view returns (uint);\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface CTokenInterface {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); // For ERC20\r\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n}\r\n\r\ninterface InstaMapping {\r\n    function cTokenMapping(address) external view returns (address);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cTokenAddress) external returns (uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n}\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\ncontract Helpers is DSMath {\r\n\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getAddressETH() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaEvent Address.\r\n     */\r\n    function getEventAddr() internal pure returns (address) {\r\n        return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Memory Variable Address\r\n     */\r\n    function getMemoryAddr() internal pure returns (address) {\r\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\r\n    }\r\n\r\n    /**\r\n     * @dev Get Uint value from InstaMemory Contract.\r\n    */\r\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\r\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set Uint value in InstaMemory Contract.\r\n    */\r\n    function setUint(uint setId, uint val) internal {\r\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\r\n    }\r\n\r\n    /**\r\n     * @dev emit event on event contract\r\n     */\r\n    function emitEvent(bytes32 eventCode, bytes memory eventData) internal {\r\n        (uint model, uint id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(model, id, eventCode, eventData);\r\n    }\r\n\r\n    /**\r\n     * @dev Connector Details.\r\n     */\r\n    function connectorID() public pure returns(uint model, uint id) {\r\n        (model, id) = (1, 21);\r\n    }\r\n}\r\n\r\ncontract MigrateHelper is Helpers {\r\n    /**\r\n     * @dev get InstaDApp v1 Registry Address\r\n     */\r\n    function getOldRegistryAddress() internal pure returns (address) {\r\n        return 0x498b3BfaBE9F73db90D252bCD4Fa9548Cd0Fd981;\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaDApp Mapping Address\r\n     */\r\n    function getMappingAddr() internal pure returns (address) {\r\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return CETH Address\r\n     */\r\n    function getCETHAddr() internal pure returns (address) {\r\n        return 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n    }\r\n\r\n    /**\r\n     * @dev Return Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() internal pure returns (address) {\r\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n   /**\r\n     * @dev enter compound market\r\n     */\r\n    function enterMarket(address[] memory cErc20) internal {\r\n        ComptrollerInterface(getComptrollerAddress()).enterMarkets(cErc20);\r\n    }\r\n\r\n    modifier isUserWallet(address _wallet) {\r\n        if (_wallet == msg.sender) {\r\n            address userAdd = UserWalletInterface(_wallet).owner();\r\n            address walletAdd = RegistryInterface(getOldRegistryAddress()).proxies(userAdd);\r\n            require(walletAdd != address(0), \"not-user-wallet\");\r\n            require(_wallet == walletAdd, \"different-wallet-owner\");\r\n        } else {\r\n            address walletAdd = RegistryInterface(getOldRegistryAddress()).proxies(msg.sender);\r\n            require(walletAdd != address(0), \"not-user-wallet\");\r\n            address userAdd = UserWalletInterface(walletAdd).owner();\r\n            require(userAdd == msg.sender, \"not-wallet-owner\");\r\n            require(_wallet == walletAdd, \"different-wallet-owner\");\r\n        }\r\n        _;\r\n    }\r\n}\r\n\r\ncontract MigrateResolver is MigrateHelper {\r\n    event LogMigrate(\r\n        address wallet,\r\n        address[] cTokens,\r\n        uint times\r\n    );\r\n\r\n    event LogMigratePayback(\r\n        address wallet,\r\n        address token,\r\n        uint amt,\r\n        uint getId,\r\n        uint setId\r\n    );\r\n\r\n    function ctokenImport(address wallet, CTokenInterface[] memory ctokenContracts, uint[] memory amts) private {\r\n        for (uint i = 0; i < ctokenContracts.length; i++) {\r\n            if (amts[i] > 0){\r\n                require(ctokenContracts[i].transferFrom(wallet, address(this), amts[i]), \"allowance?\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function ctokenBorrowPaybackBehalf(address wallet, CTokenInterface[] memory ctokenContracts, uint[] memory amts) private {\r\n        for (uint i = 0; i < ctokenContracts.length; i++) {\r\n            if (amts[i] > 0) {\r\n                require(CTokenInterface(ctokenContracts[i]).borrow(amts[i]) == 0, \"enough-supply?\");\r\n                getCETHAddr() != address(ctokenContracts[i]) ?\r\n                    require(CTokenInterface(ctokenContracts[i]).repayBorrowBehalf(wallet, amts[i]) == 0, \"borrowed?-balance?\") :\r\n                    CETHInterface(address(ctokenContracts[i])).repayBorrowBehalf.value(amts[i])(wallet);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _migrate(\r\n        address wallet,\r\n        CTokenInterface[] memory ctokenContracts,\r\n        uint[] memory splitBorrowAmts,\r\n        uint[] memory splitCtokensBal,\r\n        uint[] memory borrowAmts,\r\n        uint[] memory ctokensBal,\r\n        uint _length,\r\n        uint _times\r\n    ) internal {\r\n        for (uint i = 0; i < _times; i++) {\r\n            if (i < _times - 1) {\r\n                ctokenBorrowPaybackBehalf(wallet, ctokenContracts, splitBorrowAmts);\r\n                ctokenImport(wallet, ctokenContracts, splitCtokensBal);\r\n            } else {\r\n                uint[] memory _borrowAmts = new uint[](_length);\r\n                uint[] memory _ctokensBal = new uint[](_length);\r\n                for (uint j = 0; j < _length; j++) {\r\n                    _borrowAmts[j] = borrowAmts[j] > 0 ?\r\n                        ctokenContracts[j].borrowBalanceCurrent(wallet) : 0;\r\n                    _ctokensBal[j] = ctokensBal[j] > 0 ?\r\n                        ctokenContracts[j].balanceOf(wallet): 0;\r\n                }\r\n                ctokenBorrowPaybackBehalf(wallet, ctokenContracts, _borrowAmts);\r\n                ctokenImport(wallet, ctokenContracts, _ctokensBal);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Migrate Compound Position\r\n    */\r\n    function migrateCompound(address wallet, address[] calldata tokens, uint times)\r\n    external\r\n    payable\r\n    isUserWallet(wallet)\r\n    {\r\n        uint _length = tokens.length;\r\n        require(times > 0 && _length > 0, \"times-0-or-length-0\");\r\n        address[] memory ctokens = new address[](_length);\r\n        uint[] memory borrowAmts = new uint[](_length);\r\n        uint[] memory splitBorrowAmts = new uint[](_length);\r\n        uint[] memory ctokensBal = new uint[](_length);\r\n        uint[] memory splitCtokensBal = new uint[](_length);\r\n\r\n        CTokenInterface[] memory ctokenContracts = new CTokenInterface[](_length);\r\n        InstaMapping instaMap = InstaMapping(getMappingAddr());\r\n        for (uint i = 0; i < _length; i++) {\r\n            ctokens[i] = instaMap.cTokenMapping(tokens[i]);\r\n            require(ctokens[i] != address(0), \"adderss-0\");\r\n            ctokenContracts[i] = CTokenInterface(ctokens[i]);\r\n            ctokensBal[i] = ctokenContracts[i].balanceOf(wallet);\r\n            splitCtokensBal[i] = ctokensBal[i] / times;\r\n            if (times != 1) {\r\n                borrowAmts[i] = ctokenContracts[i].borrowBalanceCurrent(wallet);\r\n                if (ctokens[i] != getCETHAddr()) TokenInterface(tokens[i]).approve(ctokens[i], borrowAmts[i]);\r\n                splitBorrowAmts[i] = borrowAmts[i] / (times - 1);\r\n            }\r\n        }\r\n\r\n        enterMarket(ctokens);\r\n        times == 1 ? ctokenImport(wallet, ctokenContracts, ctokensBal) : ctokenImport(wallet, ctokenContracts, splitCtokensBal);\r\n\r\n        uint _times = times - 1;\r\n        _migrate(\r\n            wallet,\r\n            ctokenContracts,\r\n            splitBorrowAmts,\r\n            splitCtokensBal,\r\n            borrowAmts,\r\n            ctokensBal,\r\n            _length,\r\n            _times\r\n        );\r\n\r\n        emit LogMigrate(wallet, tokens, times);\r\n        bytes32 _eventCode = keccak256(\"LogMigrate(address,address[],uint256)\");\r\n        bytes memory _eventParam = abi.encode(wallet, tokens, times);\r\n        emitEvent(_eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Payback Smart Wallet Compound Debt\r\n    */\r\n    function migratePaybackBehalf(\r\n        address wallet,\r\n        address token,\r\n        uint amt,\r\n        uint getId,\r\n        uint setId\r\n    ) external isUserWallet(wallet) payable {\r\n        uint _amt = getUint(getId, amt);\r\n        if (amt > 0) {\r\n            InstaMapping instaMap = InstaMapping(getMappingAddr());\r\n            address cToken = instaMap.cTokenMapping(token);\r\n            CTokenInterface ctokenContract = CTokenInterface(cToken);\r\n            require(cToken != address(0), \"adderss-0\");\r\n            _amt = amt == uint(-1) ?\r\n                ctokenContract.borrowBalanceCurrent(wallet) : amt;\r\n            if (cToken != getCETHAddr()) {\r\n                TokenInterface(token).approve(cToken, _amt);\r\n                require(ctokenContract.repayBorrowBehalf(wallet, _amt) == 0, \"borrowed?-balance?\");\r\n            } else {\r\n                CETHInterface(cToken).repayBorrowBehalf.value(_amt)(wallet);\r\n            }\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogMigratePayback(wallet, token, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogMigratePayback(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(wallet, token, _amt, getId, setId);\r\n        emitEvent(_eventCode, _eventParam);\r\n    }\r\n}\r\n\r\ncontract ConnectMigrate is MigrateResolver {\r\n    string public name = \"Migration-v1\";\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"LogMigrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogMigratePayback\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"connectorID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"model\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"migrateCompound\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"migratePaybackBehalf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConnectMigrate","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b053c2543414812cdc6abf48f6358ff48616c8a027f25f6aa33f4d0f2851feb5"}]}