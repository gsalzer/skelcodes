{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.12 <0.7.0;\r\n\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract Matrix {\r\n  using SafeMath for uint256;\r\n\r\n  struct User {\r\n    address wallet;\r\n    uint referrerCount;\r\n    address parent;\r\n    uint256 earnedFromPool;\r\n    uint256 earnedFromRef;\r\n    uint256 earnedFromPoolRef;\r\n    address[] referrals;\r\n  }\r\n\r\n  struct PoolMember{\r\n    address userAddress;\r\n    uint8 paymentsCount;\r\n    bool done;\r\n  }\r\n\r\n  struct Pool{\r\n    uint256 number;\r\n    uint256 cost;\r\n    uint256 membersCount;\r\n    uint256 pendingIndex;\r\n  }\r\n\r\n  struct PendingSlot{\r\n    uint8 pool;\r\n    address addr;\r\n    uint256 entryTime;\r\n  }\r\n\r\n  PendingSlot[] public pendingSlots;\r\n  uint256 public pendingSlotIndex = 0;\r\n\r\n  mapping(uint8 => Pool) public pools;\r\n  mapping(uint8 => PoolMember[]) public PoolMembers;\r\n\r\n\r\n  // 27 june 3 PM GM\r\n  uint256 public startTime = 1593270000;\r\n\r\n\r\n  event Register(address indexed _addr, address indexed _parent, uint256 _time);\r\n  event PoolRegister(address indexed _addr, uint8 _pool, uint256 _time);\r\n  event PoolReward(address indexed _addr, uint8 _pool, uint256 _amount, uint256 _time);\r\n\r\n  event RefReward(address indexed _addr, address indexed _sender, uint8 _pool, uint8 _level, uint256 _amount, uint256 _time);\r\n\r\n  event Reinvest(address indexed _addr, uint8 _pool, uint256 _time);\r\n\r\n  event AddPendingSolt(address indexed _addr, uint8 _pool, uint256 _time);\r\n\r\n  uint256[] public poolCosts = [\r\n    0.05 ether,\r\n    0.1 ether,\r\n    0.25 ether,\r\n    0.5 ether,\r\n    1 ether,\r\n    2 ether\r\n  ];\r\n  \r\n  address payable public admin;\r\n  address payable public operator;\r\n\r\n  mapping (address => address payable) public parents;\r\n  mapping (address => User) public users;\r\n\r\n  mapping(uint8 => uint256) registerRewards;\r\n\r\n\r\n  modifier isAdmin(){\r\n    require(msg.sender == admin);\r\n    _;\r\n  }\r\n\r\n  modifier isOperator(){\r\n    require(msg.sender == admin || msg.sender==operator);\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    admin = 0x3314F3918573a408e331c7fbCa2a9E697d1B87f6;\r\n    operator = 0x1551DDaAb0cf575D1a252554a8615C49FD521241;\r\n\r\n    registerRewards[1] = 0.015 ether;\r\n    registerRewards[2] = 0.005 ether;\r\n    registerRewards[3] = 0.0025 ether;\r\n    registerRewards[4] = 0.0025 ether;\r\n    registerRewards[5] = 0.0025 ether;\r\n    registerRewards[6] = 0.0025 ether;\r\n    registerRewards[7] = 0.0025 ether;\r\n    registerRewards[8] = 0.0025 ether;\r\n    registerRewards[9] = 0.0025 ether;\r\n    registerRewards[10] = 0.0025 ether;\r\n\r\n    for(uint8 i = 0; i < poolCosts.length; i++){\r\n      pools[i+1] = Pool({\r\n        number: i+1,\r\n        cost: poolCosts[i],\r\n        membersCount: 1,\r\n        pendingIndex: 0\r\n      });\r\n      \r\n      PoolMembers[i+1].push(PoolMember({\r\n         userAddress: msg.sender,\r\n         paymentsCount: 2,\r\n         done: false\r\n      }));\r\n    }\r\n  }\r\n  \r\n  function register(address _parent, address _forAddress) public payable {\r\n    address forAddress = _forAddress==address(0) ? msg.sender : _forAddress;\r\n\r\n    require(msg.value == 0.05 ether, \"the fee is 0.05\");\r\n\r\n    users[forAddress] = User({\r\n      wallet: forAddress,\r\n      referrerCount: 0,\r\n      parent: _parent,\r\n      earnedFromPool: 0,\r\n      earnedFromRef: 0,\r\n      earnedFromPoolRef: 0,\r\n      referrals: new address[](0)\r\n    });\r\n    \r\n    if(_parent != address(0) && users[_parent].wallet != address(0)){\r\n      users[_parent].referrals.push(forAddress);\r\n      users[_parent].referrerCount+=1;\r\n\r\n      parents[forAddress] = payable(_parent);\r\n    }\r\n    \r\n    // distribute funds\r\n    uint256 operatorAmount = 0.01 ether;\r\n\r\n    address refer = forAddress;\r\n\r\n\r\n    for(uint8 i=1; i <=10; i++){\r\n      if(refer != address(0) && parents[refer] != address(0)){\r\n\r\n        parents[refer].transfer(registerRewards[i]);\r\n\r\n        emit RefReward(parents[refer], forAddress, 0, i, registerRewards[i], now);\r\n\r\n        users[parents[refer]].earnedFromRef += registerRewards[i];\r\n        refer = parents[refer];\r\n      }else{\r\n        refer = address(0);\r\n        operatorAmount = operatorAmount.add(registerRewards[i]);\r\n      }\r\n    }\r\n    operator.transfer(operatorAmount);\r\n\r\n    emit Register(forAddress, _parent, now);\r\n  }\r\n\r\n  function participatePool(uint8 _pool, address _forAddress) public payable {\r\n    require(now > startTime, \"Not started yet.\");\r\n    address forAddress = (_forAddress==address(0)) ? msg.sender : _forAddress;\r\n\r\n    require(users[forAddress].wallet != address(0), \"Not registered\");\r\n    require(_pool > 0 && _pool <= poolCosts.length);\r\n    require(poolCosts[_pool-1].mul(4).add(0.01 ether) == msg.value, \"Cost mismatch\");\r\n\r\n    operator.transfer(0.01 ether);\r\n\r\n    PoolRegister(forAddress, _pool, now);\r\n    _addToPool(_pool, forAddress);\r\n\r\n    enterPendingSlots();\r\n\r\n    uint256 t = now;\r\n    pendingSlots.push(PendingSlot({\r\n      pool: _pool,\r\n      addr: forAddress,\r\n      entryTime: t.add(24*3600)\r\n    }));\r\n\r\n    AddPendingSolt(forAddress, _pool, t.add(24*3600));\r\n\r\n    pendingSlots.push(PendingSlot({\r\n      pool: _pool,\r\n      addr: forAddress,\r\n      entryTime: t.add(2*24*3600)\r\n    }));\r\n\r\n    AddPendingSolt(forAddress, _pool, t.add(2*24*3600));\r\n\r\n    pendingSlots.push(PendingSlot({\r\n      pool: _pool,\r\n      addr: forAddress,\r\n      entryTime: t.add(3*24*3600)\r\n    }));\r\n\r\n    AddPendingSolt(forAddress, _pool, t.add(3*24*3600));\r\n  }\r\n\r\n  function _addToPool(uint8 _pool, address _addr) internal{\r\n    PoolMembers[_pool].push(PoolMember({\r\n      userAddress: _addr,\r\n      paymentsCount: 0,\r\n      done: false\r\n    }));\r\n    pools[_pool].membersCount += 1;\r\n    _poolPay(_pool);\r\n  }\r\n\r\n  function _poolPay(uint8 _pool) internal{\r\n    uint256 indx = pools[_pool].pendingIndex;\r\n    PoolMembers[_pool][indx].paymentsCount += 1;\r\n    \r\n    if(PoolMembers[_pool][indx].paymentsCount >= 3){\r\n      PoolMembers[_pool][indx].done = true;\r\n\r\n      payable(PoolMembers[_pool][indx].userAddress).transfer(\r\n        poolCosts[_pool-1]\r\n      );\r\n      emit PoolReward(\r\n        PoolMembers[_pool][indx].userAddress, \r\n        _pool, poolCosts[_pool-1], \r\n        now);\r\n\r\n      users[PoolMembers[_pool][indx].userAddress].earnedFromPool += poolCosts[_pool-1];\r\n      if(parents[PoolMembers[_pool][indx].userAddress] == address(0)){\r\n        payable(parents[PoolMembers[_pool][indx].userAddress]).transfer(\r\n          poolCosts[_pool-1]\r\n        );\r\n        users[parents[PoolMembers[_pool][indx].userAddress]].earnedFromPoolRef += poolCosts[_pool-1];\r\n\r\n        emit RefReward(\r\n          parents[PoolMembers[_pool][indx].userAddress],\r\n          PoolMembers[_pool][indx].userAddress,\r\n          _pool,\r\n          0,\r\n          poolCosts[_pool-1],\r\n          now\r\n        );\r\n\r\n      }else{\r\n        operator.transfer(\r\n          poolCosts[_pool-1]\r\n        );\r\n      }\r\n      pools[_pool].pendingIndex += 1;\r\n\r\n      // re-invest\r\n      _addToPool(_pool, PoolMembers[_pool][indx].userAddress);\r\n      Reinvest(PoolMembers[_pool][indx].userAddress, _pool, now);\r\n    }\r\n  }\r\n\r\n  function enterPendingSlots() public{\r\n    for(uint256 i = pendingSlotIndex; i < pendingSlots.length; i++){\r\n      if(pendingSlots[i].entryTime <= now){\r\n        _addToPool(pendingSlots[i].pool, pendingSlots[i].addr);\r\n        pendingSlotIndex += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  function pendingSlotsCount() view public returns(uint256){\r\n    uint256 ret = 0;\r\n    for(uint256 i = pendingSlotIndex; i < pendingSlots.length; i++){\r\n      if(pendingSlots[i].entryTime <= now){\r\n        ret += 1;\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  function adminWithdraw(uint256 _amount) isAdmin public{\r\n    msg.sender.transfer(_amount);\r\n  }\r\n\r\n  function adminUpdateStartTime(uint256 _time) isAdmin public{\r\n    startTime = _time;\r\n  }\r\n\r\n  receive() payable external isAdmin{\r\n    // admin can send ETH to contract\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_pool\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"AddPendingSolt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_pool\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"PoolRegister\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_pool\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"PoolReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_pool\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"RefReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_pool\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PoolMembers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"paymentsCount\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"done\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"adminUpdateStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enterPendingSlots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"parents\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pool\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_forAddress\",\"type\":\"address\"}],\"name\":\"participatePool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingSlotIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingSlots\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"pool\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"entryTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingSlotsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolCosts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"membersCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_forAddress\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrerCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earnedFromPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnedFromRef\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnedFromPoolRef\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Matrix","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6515e9211e9a2541df59a568b9cb9e76b051c7d3da2599d102464dfb1b9a96cc"}]}