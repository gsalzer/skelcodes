{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20Interface.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: UNLICENSED \\\"\\npragma solidity ^0.5.0;\\n// ----------------------------------------------------------------------------\\n// ERC Token Standard #20 Interface\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n// ----------------------------------------------------------------------------\\n contract ERC20Interface {\\n    function totalSupply() public  view returns (uint);\\n    function balanceOf(address tokenOwner) public  view returns (uint256 balance);\\n    function allowance(address tokenOwner, address spender) public  view returns (uint256 remaining);\\n    function transfer(address to, uint256 tokens) public  returns (bool success);\\n    function approve(address spender, uint256 tokens) public  returns (bool success);\\n    function transferFrom(address from, address to, uint256 tokens) public  returns (bool success);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\\n}\"},\"SafeMath.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: UNLICENSED \\\"\\npragma solidity ^0.5.0;\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n *\\n*/\\n \\nlibrary SafeMath {\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n  \\n  function ceil(uint a, uint m) internal pure returns (uint r) {\\n    return (a + m - 1) / m * m;\\n  }\\n}\"},\"TokenTimeLock.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\u0027./ERC20Interface.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n/**\\n * @title SimpleTimelock\\n * @dev SimpleTimelock is an ETH holder contract that will allow a\\n * beneficiary to receive the ETH after a given release time.\\n */\\ncontract TokenTimeLock {\\n\\n    using SafeMath for uint256;\\n    // beneficiary of ETH after it is released\\n    address public beneficiary;\\n\\n    // start time of Locked Token\\n     uint256 startTime;\\n\\n     uint256 counter; \\n     \\n     address owner;\\n    \\n    //Release Amount\\n    uint256  releaseAmount;\\n    uint256 public totalTokenLocked;\\n    //Token initializer\\n    ERC20Interface token;\\n    \\n    constructor(address _owner)public{\\n        owner = _owner;\\n    }\\n\\n    function lockedToken(address _beneficiary,  uint256 _amount, address _token) public {\\n        token = ERC20Interface(_token);\\n        require(msg.sender == owner, \\\"Only owner locked token\\\");\\n        require(beneficiary == address(0),\\\"Already Add token by beneficiary\\\");\\n        require(token.balanceOf(msg.sender) \\u003e= _amount, \\\"You have not enough Balance to Loked\\\");\\n       token.transferFrom(msg.sender, address(this), _amount);\\n        beneficiary = _beneficiary;\\n        startTime = block.timestamp;\\n        totalTokenLocked = _amount;\\n\\n    }\\n\\n    // transfers ETH held by timelock to beneficiary.\\n    function withdrawToken(uint256 _amount) public {\\n        //set only That benificiary will release token\\n        require(msg.sender == beneficiary, \\\"Only benificiary can unlock token\\\");\\n        if(block.timestamp \\u003e (counter.mul(30 days)).add(startTime) )\\n           counter++;\\n        uint256 amount = (token.balanceOf(address(this)));\\n        require(amount \\u003e 0, \\\"no Token to release\\\");\\n\\n        require(releaseAmount.add(_amount) \\u003c= counter.mul(20950), \\\"Not enough Balance left to Withdraw this month\\\");\\n        releaseAmount = releaseAmount.add(_amount);\\n\\n        token.transfer(beneficiary, _amount);\\n    }\\n    // Change Ownership Of Beneficiary\\n    function changeBeneficiary(address _beni) public {\\n        require(msg.sender == beneficiary,\\\"Un authorize call only Beneficiary change Ownership\\\");\\n        beneficiary = _beni;\\n    }\\n    \\n    // ------------------------------------------------------------------------\\n    // Get the token balance for account `tokenOwner`\\n    // ------------------------------------------------------------------------\\n    function tokenLeft() public view returns (uint256 balance) {\\n        require(msg.sender == owner ||msg.sender == beneficiary,\\\"Only Owner or beneficiary Call\\\");\\n        return  totalTokenLocked.sub(releaseAmount);\\n    }\\n\\n}\\n\\n\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beni\",\"type\":\"address\"}],\"name\":\"changeBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"lockedToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenTimeLock","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003a19afb2aff82440a881e1c7701cd45462353c4b","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5b91bdf18596f07ed144edd3edd0ae3885fc48dba0bd7f7d8d04bdb653a6f674"}]}