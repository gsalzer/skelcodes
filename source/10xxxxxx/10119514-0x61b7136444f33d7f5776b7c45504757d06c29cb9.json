{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\ncontract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\ncontract ZeroxyFactory is Context {\n    \n    function deployContract(bytes32 salt, bytes memory bytecode) public returns(address deployedAddress){\n        assembly { // solhint-disable-line\n          deployedAddress := create2(           // call CREATE2 with 4 arguments.\n            0x0,                            // forward any attached value.\n            add(0x20, bytecode),                         // pass in initialization code.\n            mload(bytecode),                         // pass in init code's length.\n            salt                                  // pass in the salt value.\n          )\n        }\n        require(address(deployedAddress) != address(0), \"deployContract call failed\");\n        return deployedAddress;\n    }\n    \n    function addressLookup(uint256 initNonce, bytes32 initCodeHash ) external view returns (address deploymentAddress, bytes32 salt, uint256 nonce) {\n        require(initNonce > 0, \"initNonce must be > 0\");\n        require(initCodeHash.length > 0, \"Invalid bytecode\");\n        uint256 existingContractSize;\n        nonce = initNonce;\n        while (true) {\n            salt = _getSalt(nonce,_msgSender());\n            // determine the address where the contract will be deployed.\n            deploymentAddress = address(\n              uint160(                      // downcast to match the address type.\n                uint256(                    // convert to uint to truncate upper digits.\n                  keccak256(                // compute the CREATE2 hash using 4 inputs.\n                    abi.encodePacked(       // pack all inputs to the hash together.\n                      bytes1(0xff),              // start with 0xff to distinguish from RLP.\n                      address(this),        // this contract will be the caller.\n                      salt,                 // pass in the supplied salt value.\n                      initCodeHash          // pass in the hash of initialization code.\n                    )\n                  )\n                )\n              )\n            );\n\n            assembly { existingContractSize := extcodesize(deploymentAddress) }\n\n          // Exit the loop if no contract is deployed to the target address.\n          (uint256 leading,uint256 total) = _getZeroBytes(deploymentAddress);\n          if(leading >= 3 && total >= 4 && existingContractSize == 0) {\n              break;\n          }\n          nonce++;\n        }\n        return (deploymentAddress, salt, nonce);\n  }\n  function getCodehashFromBytecode(bytes memory bytecode)public pure returns(bytes32) {\n     return keccak256(bytecode);\n  }\n  function _getZeroBytes(address account) internal pure returns (  uint256 leading,   uint256 total ) {\n    // convert the address to bytes.\n    bytes20 b = bytes20(account);\n\n    // designate a flag that will be flipped once leading zero bytes are found.\n    bool searchingForLeadingZeroBytes = true;\n\n    // iterate through each byte of the address and count the zero bytes found.\n    for (uint256 i; i < 20; i++) {\n      if (b[i] == 0) {\n        total++; // increment the total value if the byte is equal to 0x00.\n      } else if (searchingForLeadingZeroBytes) {\n        leading = i; // set leading byte value upon reaching a non-zero byte.\n        searchingForLeadingZeroBytes = false; // stop search upon finding value.\n      }\n    }\n\n    // special handling for the null address.\n    if (total == 20) {\n      leading = 20;\n    }\n  }\n  function _getSalt(uint256 _nonce,address _sender) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_nonce, _sender));\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"initCodeHash\",\"type\":\"bytes32\"}],\"name\":\"addressLookup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deploymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"}],\"name\":\"deployContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"}],\"name\":\"getCodehashFromBytecode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ZeroxyFactory","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}