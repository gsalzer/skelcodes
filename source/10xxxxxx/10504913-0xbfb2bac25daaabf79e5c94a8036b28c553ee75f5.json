{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/spec_interfaces/IContractRegistry.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface IContractRegistry {\r\n\r\n\tevent ContractAddressUpdated(string contractName, address addr);\r\n\r\n\t/// @dev updates the contracts address and emits a corresponding event\r\n\tfunction set(string calldata contractName, address addr) external /* onlyGovernor */;\r\n\r\n\t/// @dev returns the current address of the\r\n\tfunction get(string calldata contractName) external view returns (address);\r\n}\r\n\r\n// File: contracts/spec_interfaces/ICommittee.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title Elections contract interface\r\ninterface ICommittee {\r\n\tevent GuardianCommitteeChange(address addr, uint256 weight, bool certification, bool inCommittee);\r\n\tevent CommitteeSnapshot(address[] addrs, uint256[] weights, bool[] certification);\r\n\r\n\t// No external functions\r\n\r\n\t/*\r\n     * Methods restricted to other Orbs contracts\r\n     */\r\n\r\n\t/// @dev Called by: Elections contract\r\n\t/// Notifies a weight change for sorting to a relevant committee member.\r\n    /// weight = 0 indicates removal of the member from the committee (for exmaple on unregister, voteUnready, voteOut)\r\n\tfunction memberWeightChange(address addr, uint256 weight) external returns (bool committeeChanged) /* onlyElectionContract */;\r\n\r\n\t/// @dev Called by: Elections contract\r\n\t/// Notifies a guardian certification change\r\n\tfunction memberCertificationChange(address addr, bool isCertified) external returns (bool committeeChanged) /* onlyElectionsContract */;\r\n\r\n\t/// @dev Called by: Elections contract\r\n\t/// Notifies a a member removal for exampl\te due to voteOut / voteUnready\r\n\tfunction removeMember(address addr) external returns (bool committeeChanged) /* onlyElectionContract */;\r\n\r\n\t/// @dev Called by: Elections contract\r\n\t/// Notifies a new member applicable for committee (due to registration, unbanning, certification change)\r\n\tfunction addMember(address addr, uint256 weight, bool isCertified) external returns (bool committeeChanged) /* onlyElectionsContract */;\r\n\r\n\t/// @dev Called by: Elections contract\r\n\t/// Returns the committee members and their weights\r\n\tfunction getCommittee() external view returns (address[] memory addrs, uint256[] memory weights, bool[] memory certification);\r\n\r\n\t/*\r\n\t * Governance\r\n\t */\r\n\r\n\tfunction setMaxTimeBetweenRewardAssignments(uint32 maxTimeBetweenRewardAssignments) external /* onlyFunctionalOwner onlyWhenActive */;\r\n\tfunction setMaxCommittee(uint8 maxCommitteeSize) external /* onlyFunctionalOwner onlyWhenActive */;\r\n\r\n\tevent MaxTimeBetweenRewardAssignmentsChanged(uint32 newValue, uint32 oldValue);\r\n\tevent MaxCommitteeSizeChanged(uint8 newValue, uint8 oldValue);\r\n\r\n    /// @dev Updates the address calldata of the contract registry\r\n\tfunction setContractRegistry(IContractRegistry _contractRegistry) external /* onlyMigrationOwner */;\r\n\r\n    /*\r\n     * Getters\r\n     */\r\n\r\n    /// @dev returns the current committee\r\n    /// used also by the rewards and fees contracts\r\n\tfunction getCommitteeInfo() external view returns (address[] memory addrs, uint256[] memory weights, address[] memory orbsAddrs, bool[] memory certification, bytes4[] memory ips);\r\n\r\n\t/// @dev returns the current settings of the committee contract\r\n\tfunction getSettings() external view returns (uint32 maxTimeBetweenRewardAssignments, uint8 maxCommitteeSize);\r\n}\r\n\r\n// File: contracts/spec_interfaces/IGuardiansRegistration.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title Elections contract interface\r\ninterface IGuardiansRegistration {\r\n\tevent GuardianRegistered(address addr);\r\n\tevent GuardianDataUpdated(address addr, bytes4 ip, address orbsAddr, string name, string website, string contact);\r\n\tevent GuardianUnregistered(address addr);\r\n\tevent GuardianMetadataChanged(address addr, string key, string newValue, string oldValue);\r\n\r\n\t/*\r\n     * External methods\r\n     */\r\n\r\n    /// @dev Called by a participant who wishes to register as a guardian\r\n\tfunction registerGuardian(bytes4 ip, address orbsAddr, string calldata name, string calldata website, string calldata contact) external;\r\n\r\n    /// @dev Called by a participant who wishes to update its propertires\r\n\tfunction updateGuardian(bytes4 ip, address orbsAddr, string calldata name, string calldata website, string calldata contact) external;\r\n\r\n\t/// @dev Called by a participant who wishes to update its IP address (can be call by both main and Orbs addresses)\r\n\tfunction updateGuardianIp(bytes4 ip) external /* onlyWhenActive */;\r\n\r\n    /// @dev Called by a participant to update additional guardian metadata properties.\r\n    function setMetadata(string calldata key, string calldata value) external;\r\n\r\n    /// @dev Called by a participant to get additional guardian metadata properties.\r\n    function getMetadata(address addr, string calldata key) external view returns (string memory);\r\n\r\n    /// @dev Called by a participant who wishes to unregister\r\n\tfunction unregisterGuardian() external;\r\n\r\n    /// @dev Returns a guardian's data\r\n    /// Used also by the Election contract\r\n\tfunction getGuardianData(address addr) external view returns (bytes4 ip, address orbsAddr, string memory name, string memory website, string memory contact, uint registration_time, uint last_update_time);\r\n\r\n\t/// @dev Returns the Orbs addresses of a list of guardians\r\n\t/// Used also by the committee contract\r\n\tfunction getGuardiansOrbsAddress(address[] calldata addrs) external view returns (address[] memory orbsAddrs);\r\n\r\n\t/// @dev Returns a guardian's ip\r\n\t/// Used also by the Election contract\r\n\tfunction getGuardianIp(address addr) external view returns (bytes4 ip);\r\n\r\n\t/// @dev Returns guardian ips\r\n\tfunction getGuardianIps(address[] calldata addr) external view returns (bytes4[] memory ips);\r\n\r\n\r\n\t/// @dev Returns true if the given address is of a registered guardian\r\n\t/// Used also by the Election contract\r\n\tfunction isRegistered(address addr) external view returns (bool);\r\n\r\n\t/*\r\n     * Methods restricted to other Orbs contracts\r\n     */\r\n\r\n    /// @dev Translates a list guardians Ethereum addresses to Orbs addresses\r\n    /// Used by the Election contract\r\n\tfunction getOrbsAddresses(address[] calldata ethereumAddrs) external view returns (address[] memory orbsAddr);\r\n\r\n\t/// @dev Translates a list guardians Orbs addresses to Ethereum addresses\r\n\t/// Used by the Election contract\r\n\tfunction getEthereumAddresses(address[] calldata orbsAddrs) external view returns (address[] memory ethereumAddr);\r\n\r\n\t/// @dev Resolves the ethereum address for a guardian, given an Ethereum/Orbs address\r\n\tfunction resolveGuardianAddress(address ethereumOrOrbsAddress) external view returns (address mainAddress);\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/spec_interfaces/IProtocol.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface IProtocol {\r\n    event ProtocolVersionChanged(string deploymentSubset, uint256 currentVersion, uint256 nextVersion, uint256 fromTimestamp);\r\n\r\n    /*\r\n     *   External methods\r\n     */\r\n\r\n    /// @dev returns true if the given deployment subset exists (i.e - is registered with a protocol version)\r\n    function deploymentSubsetExists(string calldata deploymentSubset) external view returns (bool);\r\n\r\n    /// @dev returns the current protocol version for the given deployment subset.\r\n    function getProtocolVersion(string calldata deploymentSubset) external view returns (uint256);\r\n\r\n    /*\r\n     *   Governor methods\r\n     */\r\n\r\n    /// @dev create a new deployment subset.\r\n    function createDeploymentSubset(string calldata deploymentSubset, uint256 initialProtocolVersion) external /* onlyFunctionalOwner */;\r\n\r\n    /// @dev schedules a protocol version upgrade for the given deployment subset.\r\n    function setProtocolVersion(string calldata deploymentSubset, uint256 nextVersion, uint256 fromTimestamp) external /* onlyFunctionalOwner */;\r\n}\r\n\r\n// File: contracts/IStakeChangeNotifier.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @title An interface for notifying of stake change events (e.g., stake, unstake, partial unstake, restate, etc.).\r\ninterface IStakeChangeNotifier {\r\n    /// @dev Notifies of stake change event.\r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount uint256 The difference in the total staked amount.\r\n    /// @param _sign bool The sign of the added (true) or subtracted (false) amount.\r\n    /// @param _updatedStake uint256 The updated total staked amount.\r\n    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) external;\r\n\r\n    /// @dev Notifies of multiple stake change events.\r\n    /// @param _stakeOwners address[] The addresses of subject stake owners.\r\n    /// @param _amounts uint256[] The differences in total staked amounts.\r\n    /// @param _signs bool[] The signs of the added (true) or subtracted (false) amounts.\r\n    /// @param _updatedStakes uint256[] The updated total staked amounts.\r\n    function stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs,\r\n        uint256[] calldata _updatedStakes) external;\r\n\r\n    /// @dev Notifies of stake migration event.\r\n    /// @param _stakeOwner address The address of the subject stake owner.\r\n    /// @param _amount uint256 The migrated amount.\r\n    function stakeMigration(address _stakeOwner, uint256 _amount) external;\r\n}\r\n\r\n// File: contracts/interfaces/IElections.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n/// @title Elections contract interface\r\ninterface IElections /* is IStakeChangeNotifier */ {\r\n\t// Election state change events\r\n\tevent GuardianVotedUnready(address guardian);\r\n\tevent GuardianVotedOut(address guardian);\r\n\r\n\t// Function calls\r\n\tevent VoteUnreadyCasted(address voter, address subject);\r\n\tevent VoteOutCasted(address voter, address subject);\r\n\tevent StakeChanged(address addr, uint256 selfStake, uint256 delegated_stake, uint256 effective_stake);\r\n\r\n\tevent GuardianStatusUpdated(address addr, bool readyToSync, bool readyForCommittee);\r\n\r\n\t// Governance\r\n\tevent VoteUnreadyTimeoutSecondsChanged(uint32 newValue, uint32 oldValue);\r\n\tevent MinSelfStakePercentMilleChanged(uint32 newValue, uint32 oldValue);\r\n\tevent VoteOutPercentageThresholdChanged(uint8 newValue, uint8 oldValue);\r\n\tevent VoteUnreadyPercentageThresholdChanged(uint8 newValue, uint8 oldValue);\r\n\r\n\t/*\r\n\t * External methods\r\n\t */\r\n\r\n\t/// @dev Called by a guardian as part of the automatic vote-out flow\r\n\tfunction voteUnready(address subject_addr) external;\r\n\r\n\t/// @dev casts a voteOut vote by the sender to the given address\r\n\tfunction voteOut(address subjectAddr) external;\r\n\r\n\t/// @dev Called by a guardian when ready to start syncing with other nodes\r\n\tfunction readyToSync() external;\r\n\r\n\t/// @dev Called by a guardian when ready to join the committee, typically after syncing is complete or after being voted out\r\n\tfunction readyForCommittee() external;\r\n\r\n\t/*\r\n\t * Methods restricted to other Orbs contracts\r\n\t */\r\n\r\n\t/// @dev Called by: delegation contract\r\n\t/// Notifies a delegated stake change event\r\n\t/// total_delegated_stake = 0 if addr delegates to another guardian\r\n\tfunction delegatedStakeChange(address addr, uint256 selfStake, uint256 delegatedStake, uint256 totalDelegatedStake) external /* onlyDelegationContract */;\r\n\r\n\t/// @dev Called by: guardian registration contract\r\n\t/// Notifies a new guardian was registered\r\n\tfunction guardianRegistered(address addr) external /* onlyGuardiansRegistrationContract */;\r\n\r\n\t/// @dev Called by: guardian registration contract\r\n\t/// Notifies a new guardian was unregistered\r\n\tfunction guardianUnregistered(address addr) external /* onlyGuardiansRegistrationContract */;\r\n\r\n\t/// @dev Called by: guardian registration contract\r\n\t/// Notifies on a guardian certification change\r\n\tfunction guardianCertificationChanged(address addr, bool isCertified) external /* onlyCertificationContract */;\r\n\r\n\t/*\r\n     * Governance\r\n\t */\r\n\r\n\t/// @dev Updates the address of the contract registry\r\n\tfunction setContractRegistry(IContractRegistry _contractRegistry) external /* onlyMigrationOwner */;\r\n\r\n\tfunction setVoteUnreadyTimeoutSeconds(uint32 voteUnreadyTimeoutSeconds) external /* onlyFunctionalOwner onlyWhenActive */;\r\n\tfunction setMinSelfStakePercentMille(uint32 minSelfStakePercentMille) external /* onlyFunctionalOwner onlyWhenActive */;\r\n\tfunction setVoteOutPercentageThreshold(uint8 voteUnreadyPercentageThreshold) external /* onlyFunctionalOwner onlyWhenActive */;\r\n\tfunction setVoteUnreadyPercentageThreshold(uint8 voteUnreadyPercentageThreshold) external /* onlyFunctionalOwner onlyWhenActive */;\r\n\tfunction getSettings() external view returns (\r\n\t\tuint32 voteUnreadyTimeoutSeconds,\r\n\t\tuint32 minSelfStakePercentMille,\r\n\t\tuint8 voteUnreadyPercentageThreshold,\r\n\t\tuint8 voteOutPercentageThreshold\r\n\t);\r\n}\r\n\r\n// File: contracts/spec_interfaces/ICertification.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n/// @title Elections contract interface\r\ninterface ICertification /* is Ownable */ {\r\n\tevent GuardianCertificationUpdate(address guardian, bool isCertified);\r\n\r\n\t/*\r\n     * External methods\r\n     */\r\n\r\n    /// @dev Called by a guardian as part of the automatic vote unready flow\r\n    /// Used by the Election contract\r\n\tfunction isGuardianCertified(address addr) external view returns (bool isCertified);\r\n\r\n    /// @dev Called by a guardian as part of the automatic vote unready flow\r\n    /// Used by the Election contract\r\n\tfunction setGuardianCertification(address addr, bool isCertified) external /* Owner only */ ;\r\n\r\n\t/*\r\n\t * Governance\r\n\t */\r\n\r\n    /// @dev Updates the address calldata of the contract registry\r\n\tfunction setContractRegistry(IContractRegistry _contractRegistry) external /* onlyMigrationOwner */;\r\n\r\n}\r\n\r\n// File: contracts/spec_interfaces/ISubscriptions.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title Subscriptions contract interface\r\ninterface ISubscriptions {\r\n    event SubscriptionChanged(uint256 vcid, uint256 genRefTime, uint256 expiresAt, string tier, string deploymentSubset);\r\n    event Payment(uint256 vcid, address by, uint256 amount, string tier, uint256 rate);\r\n    event VcConfigRecordChanged(uint256 vcid, string key, string value);\r\n    event SubscriberAdded(address subscriber);\r\n    event VcCreated(uint256 vcid, address owner); // TODO what about isCertified, deploymentSubset?\r\n    event VcOwnerChanged(uint256 vcid, address previousOwner, address newOwner);\r\n\r\n    /*\r\n     *   Methods restricted to other Orbs contracts\r\n     */\r\n\r\n    /// @dev Called by: authorized subscriber (plan) contracts\r\n    /// Creates a new VC\r\n    function createVC(string calldata tier, uint256 rate, uint256 amount, address owner, bool isCertified, string calldata deploymentSubset) external returns (uint, uint);\r\n\r\n    /// @dev Called by: authorized subscriber (plan) contracts\r\n    /// Extends the subscription of an existing VC.\r\n    function extendSubscription(uint256 vcid, uint256 amount, address payer) external;\r\n\r\n    /// @dev called by VC owner to set a VC config record. Emits a VcConfigRecordChanged event.\r\n    function setVcConfigRecord(uint256 vcid, string calldata key, string calldata value) external /* onlyVcOwner */;\r\n\r\n    /// @dev returns the value of a VC config record\r\n    function getVcConfigRecord(uint256 vcid, string calldata key) external view returns (string memory);\r\n\r\n    /// @dev Transfers VC ownership to a new owner (can only be called by the current owner)\r\n    function setVcOwner(uint256 vcid, address owner) external /* onlyVcOwner */;\r\n\r\n    /// @dev Returns the genesis ref time delay\r\n    function getGenesisRefTimeDelay() external view returns (uint256);\r\n\r\n    /*\r\n     *   Governance methods\r\n     */\r\n\r\n    /// @dev Called by the owner to authorize a subscriber (plan)\r\n    function addSubscriber(address addr) external /* onlyFunctionalOwner */;\r\n\r\n    /// @dev Called by the owner to set the genesis ref time delay\r\n    function setGenesisRefTimeDelay(uint256 newGenesisRefTimeDelay) external /* onlyFunctionalOwner */;\r\n\r\n    /// @dev Updates the address of the contract registry\r\n    function setContractRegistry(IContractRegistry _contractRegistry) external /* onlyMigrationOwner */;\r\n\r\n}\r\n\r\n// File: contracts/spec_interfaces/IDelegation.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title Elections contract interface\r\ninterface IDelegations /* is IStakeChangeNotifier */ {\r\n    // Delegation state change events\r\n\tevent DelegatedStakeChanged(address indexed addr, uint256 selfDelegatedStake, uint256 delegatedStake, address[] delegators, uint256[] delegatorTotalStakes);\r\n\r\n    // Function calls\r\n\tevent Delegated(address indexed from, address indexed to);\r\n\r\n\t/*\r\n     * External methods\r\n     */\r\n\r\n\t/// @dev Stake delegation\r\n\tfunction delegate(address to) external /* onlyWhenActive */;\r\n\r\n\tfunction refreshStakeNotification(address addr) external /* onlyWhenActive */;\r\n\r\n\t/*\r\n\t * Governance\r\n\t */\r\n\r\n    /// @dev Updates the address calldata of the contract registry\r\n\tfunction setContractRegistry(IContractRegistry _contractRegistry) external /* onlyMigrationOwner */;\r\n\r\n\tfunction importDelegations(address[] calldata from, address[] calldata to, bool notifyElections) external /* onlyMigrationOwner onlyDuringDelegationImport */;\r\n\tfunction finalizeDelegationImport() external /* onlyMigrationOwner onlyDuringDelegationImport */;\r\n\r\n\tevent DelegationsImported(address[] from, address[] to, bool notifiedElections);\r\n\tevent DelegationImportFinalized();\r\n\r\n\t/*\r\n\t * Getters\r\n\t */\r\n\r\n\tfunction getDelegatedStakes(address addr) external view returns (uint256);\r\n\tfunction getSelfDelegatedStake(address addr) external view returns (uint256);\r\n\tfunction getDelegation(address addr) external view returns (address);\r\n\tfunction getTotalDelegatedStake() external view returns (uint256) ;\r\n\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/IMigratableStakingContract.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title An interface for staking contracts which support stake migration.\r\ninterface IMigratableStakingContract {\r\n    /// @dev Returns the address of the underlying staked token.\r\n    /// @return IERC20 The address of the token.\r\n    function getToken() external view returns (IERC20);\r\n\r\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\r\n    /// the required amount using ERC20 approve.\r\n    /// @param _stakeOwner address The specified stake owner.\r\n    /// @param _amount uint256 The number of tokens to stake.\r\n    function acceptMigration(address _stakeOwner, uint256 _amount) external;\r\n\r\n    event AcceptedMigration(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n}\r\n\r\n// File: contracts/IStakingContract.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/// @title An interface for staking contracts.\r\ninterface IStakingContract {\r\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\r\n    /// the required amount using ERC20 approve.\r\n    /// @param _amount uint256 The amount of tokens to stake.\r\n    function stake(uint256 _amount) external;\r\n\r\n    /// @dev Unstakes ORBS tokens from msg.sender. If successful, this will start the cooldown period, after which\r\n    /// msg.sender would be able to withdraw all of his tokens.\r\n    /// @param _amount uint256 The amount of tokens to unstake.\r\n    function unstake(uint256 _amount) external;\r\n\r\n    /// @dev Requests to withdraw all of staked ORBS tokens back to msg.sender. Stake owners can withdraw their ORBS\r\n    /// tokens only after previously unstaking them and after the cooldown period has passed (unless the contract was\r\n    /// requested to release all stakes).\r\n    function withdraw() external;\r\n\r\n    /// @dev Restakes unstaked ORBS tokens (in or after cooldown) for msg.sender.\r\n    function restake() external;\r\n\r\n    /// @dev Distributes staking rewards to a list of addresses by directly adding rewards to their stakes. This method\r\n    /// assumes that the user has already approved at least the required amount using ERC20 approve. Since this is a\r\n    /// convenience method, we aren't concerned about reaching block gas limit by using large lists. We assume that\r\n    /// callers will be able to properly batch/paginate their requests.\r\n    /// @param _totalAmount uint256 The total amount of rewards to distributes.\r\n    /// @param _stakeOwners address[] The addresses of the stake owners.\r\n    /// @param _amounts uint256[] The amounts of the rewards.\r\n    function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts) external;\r\n\r\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\r\n    /// @param _stakeOwner address The address to check.\r\n    /// @return uint256 The total stake.\r\n    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);\r\n\r\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\r\n    /// @return uint256 The total staked tokens of all stake owners.\r\n    function getTotalStakedTokens() external view returns (uint256);\r\n\r\n    /// @dev Returns the time that the cooldown period ends (or ended) and the amount of tokens to be released.\r\n    /// @param _stakeOwner address The address to check.\r\n    /// @return cooldownAmount uint256 The total tokens in cooldown.\r\n    /// @return cooldownEndTime uint256 The time when the cooldown period ends (in seconds).\r\n    function getUnstakeStatus(address _stakeOwner) external view returns (uint256 cooldownAmount,\r\n        uint256 cooldownEndTime);\r\n\r\n    /// @dev Migrates the stake of msg.sender from this staking contract to a new approved staking contract.\r\n    /// @param _newStakingContract IMigratableStakingContract The new staking contract which supports stake migration.\r\n    /// @param _amount uint256 The amount of tokens to migrate.\r\n    function migrateStakedTokens(IMigratableStakingContract _newStakingContract, uint256 _amount) external;\r\n\r\n    event Staked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event Unstaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event Withdrew(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event Restaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n    event MigratedStake(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\r\n}\r\n\r\n// File: contracts/interfaces/IRewards.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n/// @title Rewards contract interface\r\ninterface IRewards {\r\n\r\n    function assignRewards() external;\r\n    function assignRewardsToCommittee(address[] calldata generalCommittee, uint256[] calldata generalCommitteeWeights, bool[] calldata certification) external /* onlyCommitteeContract */;\r\n\r\n    // staking\r\n\r\n    event StakingRewardsDistributed(address indexed distributer, uint256 fromBlock, uint256 toBlock, uint split, uint txIndex, address[] to, uint256[] amounts);\r\n    event StakingRewardsAssigned(address[] assignees, uint256[] amounts); // todo balance?\r\n    event StakingRewardsAddedToPool(uint256 added, uint256 total);\r\n    event MaxDelegatorsStakingRewardsChanged(uint32 maxDelegatorsStakingRewardsPercentMille);\r\n\r\n    /// @return Returns the currently unclaimed orbs token reward balance of the given address.\r\n    function getStakingRewardBalance(address addr) external view returns (uint256 balance);\r\n\r\n    /// @dev Distributes msg.sender's orbs token rewards to a list of addresses, by transferring directly into the staking contract.\r\n    /// @dev `to[0]` must be the sender's main address\r\n    /// @dev Total delegators reward (`to[1:n]`) must be less then maxDelegatorsStakingRewardsPercentMille of total amount\r\n    function distributeOrbsTokenStakingRewards(uint256 totalAmount, uint256 fromBlock, uint256 toBlock, uint split, uint txIndex, address[] calldata to, uint256[] calldata amounts) external;\r\n\r\n    /// @dev Transfers the given amount of orbs tokens form the sender to this contract an update the pool.\r\n    function topUpStakingRewardsPool(uint256 amount) external;\r\n\r\n    /*\r\n    *   Reward-governor methods\r\n    */\r\n\r\n    /// @dev Assigns rewards and sets a new monthly rate for the pro-rata pool.\r\n    function setAnnualStakingRewardsRate(uint256 annual_rate_in_percent_mille, uint256 annual_cap) external /* onlyFunctionalOwner */;\r\n\r\n\r\n    // fees\r\n\r\n    event FeesAssigned(uint256 generalGuardianAmount, uint256 certifiedGuardianAmount);\r\n    event FeesWithdrawn(address guardian, uint256 amount);\r\n    event FeesWithdrawnFromBucket(uint256 bucketId, uint256 withdrawn, uint256 total, bool isCertified);\r\n    event FeesAddedToBucket(uint256 bucketId, uint256 added, uint256 total, bool isCertified);\r\n\r\n    /*\r\n     *   External methods\r\n     */\r\n\r\n    /// @return Returns the currently unclaimed orbs token reward balance of the given address.\r\n    function getFeeBalance(address addr) external view returns (uint256 balance);\r\n\r\n    /// @dev Transfer all of msg.sender's outstanding balance to their account\r\n    function withdrawFeeFunds() external;\r\n\r\n    /// @dev Called by: subscriptions contract\r\n    /// Top-ups the certification fee pool with the given amount at the given rate (typically called by the subscriptions contract)\r\n    function fillCertificationFeeBuckets(uint256 amount, uint256 monthlyRate, uint256 fromTimestamp) external;\r\n\r\n    /// @dev Called by: subscriptions contract\r\n    /// Top-ups the general fee pool with the given amount at the given rate (typically called by the subscriptions contract)\r\n    function fillGeneralFeeBuckets(uint256 amount, uint256 monthlyRate, uint256 fromTimestamp) external;\r\n\r\n    function getTotalBalances() external view returns (uint256 feesTotalBalance, uint256 stakingRewardsTotalBalance, uint256 bootstrapRewardsTotalBalance);\r\n\r\n    // bootstrap\r\n\r\n    event BootstrapRewardsAssigned(uint256 generalGuardianAmount, uint256 certifiedGuardianAmount);\r\n    event BootstrapAddedToPool(uint256 added, uint256 total);\r\n    event BootstrapRewardsWithdrawn(address guardian, uint256 amount);\r\n\r\n    /*\r\n     *   External methods\r\n     */\r\n\r\n    /// @return Returns the currently unclaimed bootstrap balance of the given address.\r\n    function getBootstrapBalance(address addr) external view returns (uint256 balance);\r\n\r\n    /// @dev Transfer all of msg.sender's outstanding balance to their account\r\n    function withdrawBootstrapFunds() external;\r\n\r\n    /// @return The timestamp of the last reward assignment.\r\n    function getLastRewardAssignmentTime() external view returns (uint256 time);\r\n\r\n    /// @dev Transfers the given amount of bootstrap tokens form the sender to this contract and update the pool.\r\n    /// Assumes the tokens were approved for transfer\r\n    function topUpBootstrapPool(uint256 amount) external;\r\n\r\n    /*\r\n     * Reward-governor methods\r\n     */\r\n\r\n    /// @dev Assigns rewards and sets a new monthly rate for the geenral commitee bootstrap.\r\n    function setGeneralCommitteeAnnualBootstrap(uint256 annual_amount) external /* onlyFunctionalOwner */;\r\n\r\n    /// @dev Assigns rewards and sets a new monthly rate for the certification commitee bootstrap.\r\n    function setCertificationCommitteeAnnualBootstrap(uint256 annual_amount) external /* onlyFunctionalOwner */;\r\n\r\n    event EmergencyWithdrawal(address addr);\r\n\r\n    function emergencyWithdraw() external /* onlyMigrationManager */;\r\n\r\n    /*\r\n     * General governance\r\n     */\r\n\r\n    /// @dev Updates the address of the contract registry\r\n    function setContractRegistry(IContractRegistry _contractRegistry) external /* onlyMigrationOwner */;\r\n\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/WithClaimableMigrationOwnership.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract WithClaimableMigrationOwnership is Context{\r\n    address private _migrationOwner;\r\n    address pendingMigrationOwner;\r\n\r\n    event MigrationOwnershipTransferred(address indexed previousMigrationOwner, address indexed newMigrationOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial migrationMigrationOwner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _migrationOwner = msgSender;\r\n        emit MigrationOwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current migrationOwner.\r\n     */\r\n    function migrationOwner() public view returns (address) {\r\n        return _migrationOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the migrationOwner.\r\n     */\r\n    modifier onlyMigrationOwner() {\r\n        require(isMigrationOwner(), \"WithClaimableMigrationOwnership: caller is not the migrationOwner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current migrationOwner.\r\n     */\r\n    function isMigrationOwner() public view returns (bool) {\r\n        return _msgSender() == _migrationOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without migrationOwner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current migrationOwner.\r\n     *\r\n     * NOTE: Renouncing migrationOwnership will leave the contract without an migrationOwner,\r\n     * thereby removing any functionality that is only available to the migrationOwner.\r\n     */\r\n    function renounceMigrationOwnership() public onlyMigrationOwner {\r\n        emit MigrationOwnershipTransferred(_migrationOwner, address(0));\r\n        _migrationOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers migrationOwnership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferMigrationOwnership(address newMigrationOwner) internal {\r\n        require(newMigrationOwner != address(0), \"MigrationOwner: new migrationOwner is the zero address\");\r\n        emit MigrationOwnershipTransferred(_migrationOwner, newMigrationOwner);\r\n        _migrationOwner = newMigrationOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingMigrationOwner() {\r\n        require(msg.sender == pendingMigrationOwner, \"Caller is not the pending migrationOwner\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Allows the current migrationOwner to set the pendingOwner address.\r\n     * @param newMigrationOwner The address to transfer migrationOwnership to.\r\n     */\r\n    function transferMigrationOwnership(address newMigrationOwner) public onlyMigrationOwner {\r\n        pendingMigrationOwner = newMigrationOwner;\r\n    }\r\n    /**\r\n     * @dev Allows the pendingMigrationOwner address to finalize the transfer.\r\n     */\r\n    function claimMigrationOwnership() external onlyPendingMigrationOwner {\r\n        _transferMigrationOwnership(pendingMigrationOwner);\r\n        pendingMigrationOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/Lockable.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Lockable is WithClaimableMigrationOwnership {\r\n\r\n    bool public locked;\r\n\r\n    event Locked();\r\n    event Unlocked();\r\n\r\n    function lock() external onlyMigrationOwner {\r\n        locked = true;\r\n        emit Locked();\r\n    }\r\n\r\n    function unlock() external onlyMigrationOwner {\r\n        locked = false;\r\n        emit Unlocked();\r\n    }\r\n\r\n    modifier onlyWhenActive() {\r\n        require(!locked, \"contract is locked for this operation\");\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/spec_interfaces/IProtocolWallet.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @title Protocol Wallet interface\r\ninterface IProtocolWallet {\r\n    event FundsAddedToPool(uint256 added, uint256 total);\r\n    event ClientSet(address client);\r\n    event MaxAnnualRateSet(uint256 maxAnnualRate);\r\n    event EmergencyWithdrawal(address addr);\r\n\r\n    /// @dev Returns the address of the underlying staked token.\r\n    /// @return IERC20 The address of the token.\r\n    function getToken() external view returns (IERC20);\r\n\r\n    /// @dev Returns the address of the underlying staked token.\r\n    /// @return IERC20 The address of the token.\r\n    function getBalance() external view returns (uint256 balance);\r\n\r\n    /// @dev Transfers the given amount of orbs tokens form the sender to this contract an update the pool.\r\n    function topUp(uint256 amount) external;\r\n\r\n    /// @dev Withdraw from pool to a the sender's address, limited by the pool's MaxRate.\r\n    /// A maximum of MaxRate x time period since the last Orbs transfer may be transferred out.\r\n    /// Flow:\r\n    /// PoolWallet.approveTransfer(amount);\r\n    /// ERC20.transferFrom(PoolWallet, client, amount)\r\n    function withdraw(uint256 amount) external; /* onlyClient */\r\n\r\n    /* Governance */\r\n    /// @dev Sets a new transfer rate for the Orbs pool.\r\n    function setMaxAnnualRate(uint256 annual_rate) external; /* onlyMigrationManager */\r\n\r\n    /// @dev transfer the entire pool's balance to a new wallet.\r\n    function emergencyWithdraw() external; /* onlyMigrationManager */\r\n\r\n    /// @dev sets the address of the new contract\r\n    function setClient(address client) external; /* onlyFunctionalManager */\r\n}\r\n\r\n// File: contracts/ContractRegistryAccessor.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ContractRegistryAccessor is WithClaimableMigrationOwnership {\r\n\r\n    IContractRegistry contractRegistry;\r\n\r\n    event ContractRegistryAddressUpdated(address addr);\r\n\r\n    function setContractRegistry(IContractRegistry _contractRegistry) external onlyMigrationOwner {\r\n        contractRegistry = _contractRegistry;\r\n        emit ContractRegistryAddressUpdated(address(_contractRegistry));\r\n    }\r\n\r\n    function getProtocolContract() public view returns (IProtocol) {\r\n        return IProtocol(contractRegistry.get(\"protocol\"));\r\n    }\r\n\r\n    function getRewardsContract() public view returns (IRewards) {\r\n        return IRewards(contractRegistry.get(\"rewards\"));\r\n    }\r\n\r\n    function getCommitteeContract() public view returns (ICommittee) {\r\n        return ICommittee(contractRegistry.get(\"committee\"));\r\n    }\r\n\r\n    function getElectionsContract() public view returns (IElections) {\r\n        return IElections(contractRegistry.get(\"elections\"));\r\n    }\r\n\r\n    function getDelegationsContract() public view returns (IDelegations) {\r\n        return IDelegations(contractRegistry.get(\"delegations\"));\r\n    }\r\n\r\n    function getGuardiansRegistrationContract() public view returns (IGuardiansRegistration) {\r\n        return IGuardiansRegistration(contractRegistry.get(\"guardiansRegistration\"));\r\n    }\r\n\r\n    function getCertificationContract() public view returns (ICertification) {\r\n        return ICertification(contractRegistry.get(\"certification\"));\r\n    }\r\n\r\n    function getStakingContract() public view returns (IStakingContract) {\r\n        return IStakingContract(contractRegistry.get(\"staking\"));\r\n    }\r\n\r\n    function getSubscriptionsContract() public view returns (ISubscriptions) {\r\n        return ISubscriptions(contractRegistry.get(\"subscriptions\"));\r\n    }\r\n\r\n    function getStakingRewardsWallet() public view returns (IProtocolWallet) {\r\n        return IProtocolWallet(contractRegistry.get(\"stakingRewardsWallet\"));\r\n    }\r\n\r\n    function getBootstrapRewardsWallet() public view returns (IProtocolWallet) {\r\n        return IProtocolWallet(contractRegistry.get(\"bootstrapRewardsWallet\"));\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/WithClaimableFunctionalOwnership.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract WithClaimableFunctionalOwnership is Context{\r\n    address private _functionalOwner;\r\n    address pendingFunctionalOwner;\r\n\r\n    event FunctionalOwnershipTransferred(address indexed previousFunctionalOwner, address indexed newFunctionalOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial functionalFunctionalOwner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _functionalOwner = msgSender;\r\n        emit FunctionalOwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current functionalOwner.\r\n     */\r\n    function functionalOwner() public view returns (address) {\r\n        return _functionalOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the functionalOwner.\r\n     */\r\n    modifier onlyFunctionalOwner() {\r\n        require(isFunctionalOwner(), \"WithClaimableFunctionalOwnership: caller is not the functionalOwner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current functionalOwner.\r\n     */\r\n    function isFunctionalOwner() public view returns (bool) {\r\n        return _msgSender() == _functionalOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without functionalOwner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current functionalOwner.\r\n     *\r\n     * NOTE: Renouncing functionalOwnership will leave the contract without an functionalOwner,\r\n     * thereby removing any functionality that is only available to the functionalOwner.\r\n     */\r\n    function renounceFunctionalOwnership() public onlyFunctionalOwner {\r\n        emit FunctionalOwnershipTransferred(_functionalOwner, address(0));\r\n        _functionalOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers functionalOwnership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferFunctionalOwnership(address newFunctionalOwner) internal {\r\n        require(newFunctionalOwner != address(0), \"FunctionalOwner: new functionalOwner is the zero address\");\r\n        emit FunctionalOwnershipTransferred(_functionalOwner, newFunctionalOwner);\r\n        _functionalOwner = newFunctionalOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingFunctionalOwner() {\r\n        require(msg.sender == pendingFunctionalOwner, \"Caller is not the pending functionalOwner\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Allows the current functionalOwner to set the pendingOwner address.\r\n     * @param newFunctionalOwner The address to transfer functionalOwnership to.\r\n     */\r\n    function transferFunctionalOwnership(address newFunctionalOwner) public onlyFunctionalOwner {\r\n        pendingFunctionalOwner = newFunctionalOwner;\r\n    }\r\n    /**\r\n     * @dev Allows the pendingFunctionalOwner address to finalize the transfer.\r\n     */\r\n    function claimFunctionalOwnership() external onlyPendingFunctionalOwner {\r\n        _transferFunctionalOwnership(pendingFunctionalOwner);\r\n        pendingFunctionalOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: solidity-bytes-utils/contracts/BytesLib.sol\r\n\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add \r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n                \r\n                for { \r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\r\n        require(_bytes.length >= (_start + 8));\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\r\n        require(_bytes.length >= (_start + 12));\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\r\n        require(_bytes.length >= (_start + 16));\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n\r\n// File: ../contracts/Committee.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Elections contract interface\r\ncontract Committee is ICommittee, ContractRegistryAccessor, WithClaimableFunctionalOwnership, Lockable {\r\n\tusing BytesLib for bytes;\r\n\r\n\tuint constant MAX_COMMITTEE_ARRAY_SIZE = 32; // Cannot be greater than 32 (number of bytes in bytes32)\r\n\r\n\tstruct CommitteeMember {\r\n\t\taddress addr;\r\n\t\tuint96 weight;\r\n\t}\r\n\tCommitteeMember[] public committee;\r\n\r\n\tstruct MemberData {\r\n\t\tuint96 weight;\r\n\t\tuint8 pos;\r\n\t\tbool isMember;\r\n\t\tbool isCertified;\r\n\r\n\t\tbool inCommittee;\r\n\t}\r\n\tmapping (address => MemberData) membersData;\r\n\r\n\t// Derived properties\r\n\tstruct CommitteeInfo {\r\n\t\tuint32 committeeBitmap; // TODO redundant, sort bytes can be used instead\r\n\t\tuint8 minCommitteeMemberPos;\r\n\t\tuint8 committeeSize;\r\n\t}\r\n\tCommitteeInfo committeeInfo;\r\n\tbytes32 committeeSortBytes;\r\n\r\n\tstruct Settings {\r\n\t\tuint32 maxTimeBetweenRewardAssignments;\r\n\t\tuint8 maxCommitteeSize;\r\n\t}\r\n\tSettings settings;\r\n\r\n\tmodifier onlyElectionsContract() {\r\n\t\trequire(msg.sender == address(getElectionsContract()), \"caller is not the elections\");\r\n\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction findFreePos(CommitteeInfo memory info) private pure returns (uint8 pos) {\r\n\t\tpos = 0;\r\n\t\tuint32 bitmap = info.committeeBitmap;\r\n\t\twhile (bitmap & 1 == 1) {\r\n\t\t\tbitmap >>= 1;\r\n\t\t\tpos++;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction qualifiesToEnterCommittee(address addr, MemberData memory data, CommitteeInfo memory info, Settings memory _settings) private view returns (bool qualified, uint8 entryPos) {\r\n\t\tif (!data.isMember || data.weight == 0) {\r\n\t\t\treturn (false, 0);\r\n\t\t}\r\n\r\n\t\tif (info.committeeSize < _settings.maxCommitteeSize) {\r\n\t\t\treturn (true, findFreePos(info));\r\n\t\t}\r\n\r\n\t\tCommitteeMember memory minMember = committee[info.minCommitteeMemberPos];\r\n\t\tif (data.weight < minMember.weight || data.weight == minMember.weight && addr < minMember.addr) {\r\n\t\t\treturn (false, 0);\r\n\t\t}\r\n\r\n\t\treturn (true, info.minCommitteeMemberPos);\r\n\t}\r\n\r\n\tfunction saveMemberData(address addr, MemberData memory data) private {\r\n\t\tif (data.isMember) {\r\n\t\t\tmembersData[addr] = data;\r\n\t\t} else {\r\n\t\t\tdelete membersData[addr];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction updateOnMemberChange(address addr, MemberData memory data) private returns (bool committeeChanged) {\r\n\t\tCommitteeInfo memory info = committeeInfo;\r\n\t\tSettings memory _settings = settings;\r\n\t\tbytes memory sortBytes = abi.encodePacked(committeeSortBytes);\r\n\r\n\t\tif (!data.inCommittee) {\r\n\t\t\t(bool qualified, uint8 entryPos) = qualifiesToEnterCommittee(addr, data, info, _settings);\r\n\t\t\tif (!qualified) {\r\n\t\t\t\tsaveMemberData(addr, data);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t(info, sortBytes) = removeMemberAtPos(entryPos, sortBytes, info);\r\n\t\t\t(info, sortBytes) = addToCommittee(addr, data, entryPos, sortBytes, info);\r\n\t\t}\r\n\r\n\t\t(info, sortBytes) = (data.isMember && data.weight > 0) ?\r\n\t\t\trankMember(addr, data, sortBytes, info) :\r\n\t\t\tremoveMemberFromCommittee(data, sortBytes, info);\r\n\r\n\t\temit GuardianCommitteeChange(addr, data.weight, data.isCertified, data.inCommittee);\r\n\r\n\t\tsaveMemberData(addr, data);\r\n\r\n\t\tcommitteeInfo = info;\r\n\t\tcommitteeSortBytes = sortBytes.toBytes32(0);\r\n\r\n\t\tassignRewardsIfNeeded(_settings);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction addToCommittee(address addr, MemberData memory data, uint8 entryPos, bytes memory sortBytes, CommitteeInfo memory info) private returns (CommitteeInfo memory newInfo, bytes memory newSortByes) {\r\n\t\tcommittee[entryPos] = CommitteeMember({\r\n\t\t\taddr: addr,\r\n\t\t\tweight: data.weight\r\n\t\t});\r\n\t\tdata.inCommittee = true;\r\n\t\tdata.pos = entryPos;\r\n\t\tinfo.committeeBitmap |= uint32(uint(1) << entryPos);\r\n\t\tinfo.committeeSize++;\r\n\r\n\t\tsortBytes[info.committeeSize - 1] = byte(entryPos);\r\n\t\treturn (info, sortBytes);\r\n\t}\r\n\r\n\tfunction removeMemberFromCommittee(MemberData memory data, bytes memory sortBytes, CommitteeInfo memory info) private returns (CommitteeInfo memory newInfo, bytes memory newSortBytes) {\r\n\t\tuint rank = 0;\r\n\t\twhile (uint8(sortBytes[rank]) != data.pos) {\r\n\t\t\trank++;\r\n\t\t}\r\n\r\n\t\tfor (; rank < info.committeeSize - 1; rank++) {\r\n\t\t\tsortBytes[rank] = sortBytes[rank + 1];\r\n\t\t}\r\n\t\tsortBytes[rank] = 0;\r\n\r\n\t\tinfo.committeeSize--;\r\n\t\tif (info.committeeSize > 0) {\r\n\t\t\tinfo.minCommitteeMemberPos = uint8(sortBytes[info.committeeSize - 1]);\r\n\t\t}\r\n\t\tinfo.committeeBitmap &= ~uint32(uint(1) << data.pos);\r\n\r\n\t\tdelete committee[data.pos];\r\n\t\tdata.inCommittee = false;\r\n\r\n\t\treturn (info, sortBytes);\r\n\t}\r\n\r\n\tfunction removeMemberAtPos(uint8 pos, bytes memory sortBytes, CommitteeInfo memory info) private returns (CommitteeInfo memory newInfo, bytes memory newSortBytes) {\r\n\t\tif (info.committeeBitmap & (uint(1) << pos) == 0) {\r\n\t\t\treturn (info, sortBytes);\r\n\t\t}\r\n\r\n\t\taddress addr = committee[pos].addr;\r\n\t\tMemberData memory data = membersData[addr];\r\n\r\n\t\t(newInfo, newSortBytes) = removeMemberFromCommittee(data, sortBytes, info);\r\n\r\n\t\temit GuardianCommitteeChange(addr, data.weight, data.isCertified, false);\r\n\r\n\t\tmembersData[addr] = data;\r\n\t}\r\n\r\n\tfunction rankMember(address addr, MemberData memory data, bytes memory sortBytes, CommitteeInfo memory info) private view returns (CommitteeInfo memory newInfo, bytes memory newSortBytes) {\r\n\t\tuint rank = 0;\r\n\t\twhile (uint8(sortBytes[rank]) != data.pos) {\r\n\t\t\trank++;\r\n\t\t}\r\n\r\n\t\tCommitteeMember memory cur = CommitteeMember({addr: addr, weight: data.weight});\r\n\t\tCommitteeMember memory next;\r\n\r\n\t\twhile (rank < info.committeeSize - 1) {\r\n\t\t\tnext = committee[uint8(sortBytes[rank + 1])];\r\n\t\t\tif (cur.weight > next.weight || cur.weight == next.weight && cur.addr > next.addr) break;\r\n\r\n\t\t\t(sortBytes[rank], sortBytes[rank + 1]) = (sortBytes[rank + 1], sortBytes[rank]);\r\n\t\t\trank++;\r\n\t\t}\r\n\r\n\t\twhile (rank > 0) {\r\n\t\t\tnext = committee[uint8(sortBytes[rank - 1])];\r\n\t\t\tif (cur.weight < next.weight || cur.weight == next.weight && cur.addr < next.addr) break;\r\n\r\n\t\t\t(sortBytes[rank], sortBytes[rank - 1]) = (sortBytes[rank - 1], sortBytes[rank]);\r\n\t\t\trank--;\r\n\t\t}\r\n\r\n\t\tinfo.minCommitteeMemberPos = uint8(sortBytes[info.committeeSize - 1]);\r\n\t\treturn (info, sortBytes);\r\n\t}\r\n\r\n\tfunction getMinCommitteeMemberWeight() external view returns (uint96) {\r\n\t\treturn committee[committeeInfo.minCommitteeMemberPos].weight;\r\n\t}\r\n\r\n\tfunction assignRewardsIfNeeded(Settings memory _settings) private {\r\n        IRewards rewardsContract = getRewardsContract();\r\n        uint lastAssignment = rewardsContract.getLastRewardAssignmentTime();\r\n        if (now - lastAssignment < _settings.maxTimeBetweenRewardAssignments) {\r\n             return;\r\n        }\r\n\r\n\t\t(address[] memory committeeAddrs, uint[] memory committeeWeights, bool[] memory committeeCertification) = _getCommittee();\r\n        rewardsContract.assignRewardsToCommittee(committeeAddrs, committeeWeights, committeeCertification);\r\n\r\n\t\temit CommitteeSnapshot(committeeAddrs, committeeWeights, committeeCertification);\r\n\t}\r\n\r\n\tconstructor(uint _maxCommitteeSize, uint32 maxTimeBetweenRewardAssignments) public {\r\n\t\trequire(_maxCommitteeSize > 0, \"maxCommitteeSize must be larger than 0\");\r\n\t\trequire(_maxCommitteeSize <= MAX_COMMITTEE_ARRAY_SIZE, \"maxCommitteeSize must be 32 at most\");\r\n\t\tsettings = Settings({\r\n\t\t\tmaxCommitteeSize: uint8(_maxCommitteeSize),\r\n\t\t\tmaxTimeBetweenRewardAssignments: maxTimeBetweenRewardAssignments\r\n\t\t});\r\n\r\n\t\tcommittee.length = MAX_COMMITTEE_ARRAY_SIZE;\r\n\t}\r\n\r\n\t/*\r\n\t * Methods restricted to other Orbs contracts\r\n\t */\r\n\r\n\t/// @dev Called by: Elections contract\r\n\t/// Notifies a weight change for sorting to a relevant committee member.\r\n\t/// weight = 0 indicates removal of the member from the committee (for example on unregister, voteUnready, voteOut)\r\n\tfunction memberWeightChange(address addr, uint256 weight) external onlyElectionsContract onlyWhenActive returns (bool committeeChanged) {\r\n\t\trequire(uint256(uint96(weight)) == weight, \"weight is out of range\");\r\n\r\n\t\tMemberData memory data = membersData[addr];\r\n\t\tif (!data.isMember) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdata.weight = uint96(weight);\r\n\t\tif (data.inCommittee) {\r\n\t\t\tcommittee[data.pos].weight = data.weight;\r\n\t\t}\r\n\t\treturn updateOnMemberChange(addr, data);\r\n\t}\r\n\r\n\tfunction memberCertificationChange(address addr, bool isCertified) external onlyElectionsContract onlyWhenActive returns (bool committeeChanged) {\r\n\t\tMemberData memory data = membersData[addr];\r\n\t\tif (!data.isMember) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tdata.isCertified = isCertified;\r\n\t\treturn updateOnMemberChange(addr, data);\r\n\t}\r\n\r\n\tfunction addMember(address addr, uint256 weight, bool isCertified) external onlyElectionsContract onlyWhenActive returns (bool committeeChanged) {\r\n\t\trequire(uint256(uint96(weight)) == weight, \"weight is out of range\");\r\n\r\n\t\tif (membersData[addr].isMember) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn updateOnMemberChange(addr, MemberData({\r\n\t\t\tisMember: true,\r\n\t\t\tweight: uint96(weight),\r\n\t\t\tisCertified: isCertified,\r\n\t\t\tinCommittee: false,\r\n\t\t\tpos: uint8(-1)\r\n\t\t}));\r\n\t}\r\n\r\n\t/// @dev Called by: Elections contract\r\n\t/// Notifies a a member removal for example due to voteOut / voteUnready\r\n\tfunction removeMember(address addr) external onlyElectionsContract onlyWhenActive returns (bool committeeChanged) {\r\n\t\tMemberData memory data = membersData[addr];\r\n\r\n\t\tif (!membersData[addr].isMember) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tdata.isMember = false;\r\n\t\treturn updateOnMemberChange(addr, data);\r\n\t}\r\n\r\n\t/// @dev Called by: Elections contract\r\n\t/// Returns the committee members and their weights\r\n\tfunction getCommittee() external view returns (address[] memory addrs, uint256[] memory weights, bool[] memory certification) {\r\n\t\treturn _getCommittee();\r\n\t}\r\n\r\n\t/// @dev Called by: Elections contract\r\n\t/// Returns the committee members and their weights\r\n\tfunction _getCommittee() public view returns (address[] memory addrs, uint256[] memory weights, bool[] memory certification) {\r\n\t\tCommitteeInfo memory _committeeInfo = committeeInfo;\r\n\t\tuint bitmap = uint(_committeeInfo.committeeBitmap);\r\n\t\tuint committeeSize = _committeeInfo.committeeSize;\r\n\r\n\t\taddrs = new address[](committeeSize);\r\n\t\tweights = new uint[](committeeSize);\r\n\t\tcertification = new bool[](committeeSize);\r\n\t\tuint aInd = 0;\r\n\t\tuint pInd = 0;\r\n\t\tMemberData memory md;\r\n\t\tbitmap = uint(_committeeInfo.committeeBitmap);\r\n\t\twhile (bitmap != 0) {\r\n\t\t\tif (bitmap & 1 == 1) {\r\n\t\t\t\taddrs[aInd] = committee[pInd].addr;\r\n\t\t\t\tmd = membersData[addrs[aInd]];\r\n\t\t\t\tweights[aInd] = md.weight;\r\n\t\t\t\tcertification[aInd] = md.isCertified;\r\n\t\t\t\taInd++;\r\n\t\t\t}\r\n\t\t\tbitmap >>= 1;\r\n\t\t\tpInd++;\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\t * Governance\r\n\t */\r\n\r\n\tfunction setMaxTimeBetweenRewardAssignments(uint32 maxTimeBetweenRewardAssignments) external onlyFunctionalOwner /* todo onlyWhenActive */ {\r\n\t\temit MaxTimeBetweenRewardAssignmentsChanged(maxTimeBetweenRewardAssignments, settings.maxTimeBetweenRewardAssignments);\r\n\t\tsettings.maxTimeBetweenRewardAssignments = maxTimeBetweenRewardAssignments;\r\n\t}\r\n\r\n\tfunction setMaxCommittee(uint8 maxCommitteeSize) external onlyFunctionalOwner /* todo onlyWhenActive */ {\r\n\t\trequire(maxCommitteeSize > 0, \"maxCommitteeSize must be larger than 0\");\r\n\t\trequire(maxCommitteeSize <= MAX_COMMITTEE_ARRAY_SIZE, \"maxCommitteeSize must be 32 at most\");\r\n\t\tSettings memory _settings = settings;\r\n\t\temit MaxCommitteeSizeChanged(maxCommitteeSize, _settings.maxCommitteeSize);\r\n\t\t_settings.maxCommitteeSize = maxCommitteeSize;\r\n\t\tsettings = _settings;\r\n\r\n\t\tCommitteeInfo memory info = committeeInfo;\r\n\t\tif (maxCommitteeSize >= info.committeeSize) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tbytes memory sortBytes = abi.encodePacked(committeeSortBytes);\r\n\t\tfor (int rank = int(info.committeeSize); rank >= int(maxCommitteeSize); rank--) {\r\n\t\t\t(info, sortBytes) = removeMemberAtPos(uint8(sortBytes[uint(rank)]), sortBytes, info);\r\n\t\t}\r\n\t\tcommitteeInfo = info;\r\n\t\tcommitteeSortBytes = sortBytes.toBytes32(0);\r\n\t}\r\n\r\n\t/*\r\n     * Getters\r\n     */\r\n\r\n\t/// @dev returns the current committee\r\n\t/// used also by the rewards and fees contracts\r\n\tfunction getCommitteeInfo() external view returns (address[] memory addrs, uint256[] memory weights, address[] memory orbsAddrs, bool[] memory certification, bytes4[] memory ips) {\r\n\t\t(addrs, weights, certification) = _getCommittee();\r\n\t\treturn (addrs, weights, _loadOrbsAddresses(addrs), certification, _loadIps(addrs));\r\n\t}\r\n\r\n\tfunction getSettings() external view returns (uint32 maxTimeBetweenRewardAssignments, uint8 maxCommitteeSize) {\r\n\t\tSettings memory _settings = settings;\r\n\t\tmaxTimeBetweenRewardAssignments = _settings.maxTimeBetweenRewardAssignments;\r\n\t\tmaxCommitteeSize = _settings.maxCommitteeSize;\r\n\t}\r\n\r\n\t/*\r\n\t * Private\r\n\t */\r\n\r\n\tfunction _loadOrbsAddresses(address[] memory addrs) private view returns (address[] memory) {\r\n\t\treturn getGuardiansRegistrationContract().getGuardiansOrbsAddress(addrs);\r\n\t}\r\n\r\n\tfunction _loadIps(address[] memory addrs) private view returns (bytes4[] memory) {\r\n\t\treturn getGuardiansRegistrationContract().getGuardianIps(addrs);\r\n\t}\r\n\r\n\tfunction _loadCertification(address[] memory addrs) private view returns (bool[] memory) {\r\n\t\tbool[] memory certification = new bool[](addrs.length);\r\n\t\tfor (uint i = 0; i < addrs.length; i++) {\r\n\t\t\tcertification[i] = membersData[addrs[i]].isCertified;\r\n\t\t}\r\n\t\treturn certification;\r\n\t}\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxCommitteeSize\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"maxTimeBetweenRewardAssignments\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"certification\",\"type\":\"bool[]\"}],\"name\":\"CommitteeSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ContractRegistryAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousFunctionalOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFunctionalOwner\",\"type\":\"address\"}],\"name\":\"FunctionalOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"certification\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"inCommittee\",\"type\":\"bool\"}],\"name\":\"GuardianCommitteeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newValue\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"oldValue\",\"type\":\"uint8\"}],\"name\":\"MaxCommitteeSizeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newValue\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"oldValue\",\"type\":\"uint32\"}],\"name\":\"MaxTimeBetweenRewardAssignmentsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousMigrationOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMigrationOwner\",\"type\":\"address\"}],\"name\":\"MigrationOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unlocked\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"_getCommittee\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"certification\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCertified\",\"type\":\"bool\"}],\"name\":\"addMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"committeeChanged\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimFunctionalOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimMigrationOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"committee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"weight\",\"type\":\"uint96\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"functionalOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBootstrapRewardsWallet\",\"outputs\":[{\"internalType\":\"contract IProtocolWallet\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCertificationContract\",\"outputs\":[{\"internalType\":\"contract ICertification\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCommittee\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"certification\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCommitteeContract\",\"outputs\":[{\"internalType\":\"contract ICommittee\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCommitteeInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"orbsAddrs\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"certification\",\"type\":\"bool[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"ips\",\"type\":\"bytes4[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDelegationsContract\",\"outputs\":[{\"internalType\":\"contract IDelegations\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getElectionsContract\",\"outputs\":[{\"internalType\":\"contract IElections\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGuardiansRegistrationContract\",\"outputs\":[{\"internalType\":\"contract IGuardiansRegistration\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinCommitteeMemberWeight\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProtocolContract\",\"outputs\":[{\"internalType\":\"contract IProtocol\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRewardsContract\",\"outputs\":[{\"internalType\":\"contract IRewards\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSettings\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"maxTimeBetweenRewardAssignments\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"maxCommitteeSize\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakingContract\",\"outputs\":[{\"internalType\":\"contract IStakingContract\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakingRewardsWallet\",\"outputs\":[{\"internalType\":\"contract IProtocolWallet\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSubscriptionsContract\",\"outputs\":[{\"internalType\":\"contract ISubscriptions\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFunctionalOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMigrationOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCertified\",\"type\":\"bool\"}],\"name\":\"memberCertificationChange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"committeeChanged\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"memberWeightChange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"committeeChanged\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"committeeChanged\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceFunctionalOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMigrationOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"_contractRegistry\",\"type\":\"address\"}],\"name\":\"setContractRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"maxCommitteeSize\",\"type\":\"uint8\"}],\"name\":\"setMaxCommittee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"maxTimeBetweenRewardAssignments\",\"type\":\"uint32\"}],\"name\":\"setMaxTimeBetweenRewardAssignments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFunctionalOwner\",\"type\":\"address\"}],\"name\":\"transferFunctionalOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMigrationOwner\",\"type\":\"address\"}],\"name\":\"transferMigrationOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Committee","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000002a300","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ccdfc99c1204912baa98c22d66f5f3949b7445dbc2d094ff5faf6fc1750e4dc8"}]}