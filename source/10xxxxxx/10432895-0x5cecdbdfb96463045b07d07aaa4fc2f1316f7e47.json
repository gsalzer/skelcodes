{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.10;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// Liquidity pool allows a user to stake Uniswap liquidity tokens (tokens representaing shares of ETH and PAMP tokens in the Uniswap liquidity pool)\r\n// Users receive rewards in tokens for locking up their liquidity\r\ncontract LiquidityPool {\r\n    using SafeMath for uint256;\r\n    \r\n    \r\n    IERC20 public uniswapPair;\r\n    \r\n    IERC20 public pampToken;\r\n    \r\n    address public owner;\r\n    \r\n    uint public minStakeDurationDays;\r\n    \r\n    uint public rewardAdjustmentFactor;\r\n    \r\n    bool public stakingEnabled;\r\n    \r\n    bool public exponentialRewardsEnabled;\r\n    \r\n    uint public exponentialDaysMax;\r\n    \r\n    struct staker {\r\n        uint startTimestamp;        // Unix timestamp of when the tokens were initially staked\r\n        uint poolTokenBalance;      // Balance of Uniswap liquidity tokens\r\n    }\r\n    \r\n    mapping(address => staker) public stakers;\r\n\r\n    \r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    \r\n    constructor(address _uniswapPair, address _pampToken) public {\r\n        uniswapPair = IERC20(_uniswapPair);\r\n        pampToken = IERC20(_pampToken);\r\n        minStakeDurationDays = 1;\r\n        owner = msg.sender;\r\n        rewardAdjustmentFactor = 4E21;\r\n        stakingEnabled = true;\r\n        exponentialRewardsEnabled = false;\r\n        exponentialDaysMax = 10;\r\n    }\r\n    \r\n    \r\n    function stakeLiquidityTokens(uint256 numPoolTokensToStake) external {\r\n        \r\n        require(numPoolTokensToStake > 0);\r\n        require(stakingEnabled, \"Staking is currently disabled.\");\r\n        \r\n        uint previousBalance = uniswapPair.balanceOf(address(this));                    \r\n        \r\n        uniswapPair.transferFrom(msg.sender, address(this), numPoolTokensToStake);      // Transfer liquidity tokens from the sender to this contract\r\n        \r\n        uint postBalance = uniswapPair.balanceOf(address(this));\r\n        \r\n        require(previousBalance.add(numPoolTokensToStake) == postBalance);              // This is a sanity check and likely not required as the Uniswap token is ERC20\r\n        \r\n        staker storage thisStaker = stakers[msg.sender];                                // Get the sender's information\r\n        \r\n        if(thisStaker.startTimestamp == 0 || thisStaker.poolTokenBalance == 0) {\r\n            thisStaker.startTimestamp = block.timestamp;\r\n        } else {                                                                        // If the sender is currently staking, adding to his balance results in a holding time penalty\r\n            uint percent = mulDiv(1000000, numPoolTokensToStake, thisStaker.poolTokenBalance);      // This is not really 'percent' it is just a number that represents the totalAmount as a fraction of the recipientBalance\r\n            assert(percent > 0);\r\n            if(percent > 1) {\r\n                percent = percent.div(2);           // We divide the 'penalty' by 2 so that the penalty is not as bad\r\n            }\r\n            if(percent.add(thisStaker.startTimestamp) > block.timestamp) {         // We represent the 'percent' or 'penalty' as seconds and add to the recipient's unix time\r\n               thisStaker.startTimestamp = block.timestamp; // Receiving too many tokens resets your holding time\r\n            } else {\r\n                thisStaker.startTimestamp = thisStaker.startTimestamp.add(percent);               \r\n            }\r\n        }\r\n        \r\n         \r\n        thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.add(numPoolTokensToStake);\r\n\r\n        \r\n    }\r\n    // Withdraw liquidity tokens, pretty self-explanatory\r\n    function withdrawLiquidityTokens(uint256 numPoolTokensToWithdraw) external {\r\n        \r\n        require(numPoolTokensToWithdraw > 0);\r\n        \r\n        staker storage thisStaker = stakers[msg.sender];\r\n        \r\n        require(thisStaker.poolTokenBalance >= numPoolTokensToWithdraw, \"Pool token balance too low\");\r\n        \r\n        uint daysStaked = block.timestamp.sub(thisStaker.startTimestamp) / 86400;  // Calculate time staked in days\r\n        \r\n        require(daysStaked >= minStakeDurationDays);\r\n        \r\n        uint tokensOwed = calculateTokensOwed(msg.sender);      // We give all of the rewards owed to the sender on a withdrawal, regardless of the amount withdrawn\r\n        \r\n        thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.sub(numPoolTokensToWithdraw);\r\n        \r\n        thisStaker.startTimestamp = block.timestamp; // Reset staking timer on withdrawal\r\n        \r\n        pampToken.transfer(msg.sender, tokensOwed);             \r\n        \r\n        uniswapPair.transfer(msg.sender, numPoolTokensToWithdraw);\r\n    }\r\n    \r\n    // If you call this function you forfeit your rewards\r\n    function emergencyWithdrawLiquidityTokens() external {\r\n        staker storage thisStaker = stakers[msg.sender];\r\n        uint poolTokenBalance = thisStaker.poolTokenBalance;\r\n        thisStaker.poolTokenBalance = 0;\r\n        thisStaker.startTimestamp = block.timestamp;\r\n        uniswapPair.transfer(msg.sender, poolTokenBalance);\r\n    }\r\n    \r\n    function calculateTokensOwed(address stakerAddr) public view returns (uint256) {\r\n        \r\n        staker memory thisStaker = stakers[stakerAddr];\r\n        \r\n        uint daysStaked = block.timestamp.sub(thisStaker.startTimestamp) / 86400;  // Calculate time staked in days\r\n        \r\n        \r\n        uint tokens = mulDiv(daysStaked.mul(rewardAdjustmentFactor), thisStaker.poolTokenBalance, uniswapPair.totalSupply()); // The formula is as follows: tokens owned = (days staked * reward adjustment factor) * (sender liquidity token balance / total supply of liquidity token)\r\n        \r\n        if(daysStaked > exponentialDaysMax) {\r\n            daysStaked = exponentialDaysMax;\r\n        }\r\n        \r\n        if(exponentialRewardsEnabled) {\r\n            return tokens * daysStaked;\r\n        } else {\r\n            return tokens;\r\n        }\r\n        \r\n        \r\n    }\r\n    \r\n    function pampTokenBalance() external view returns (uint256) {\r\n        return pampToken.balanceOf(address(this));\r\n    }\r\n    \r\n    function uniTokenBalance() external view returns (uint256) {\r\n        return uniswapPair.balanceOf(address(this));\r\n    }\r\n    \r\n    function updateUniswapPair(address _uniswapPair) external onlyOwner {\r\n        uniswapPair = IERC20(_uniswapPair);\r\n    }\r\n    \r\n    function updatePampToken(address _pampToken) external onlyOwner {\r\n        pampToken = IERC20(_pampToken);\r\n    }\r\n    \r\n    function updateMinStakeDurationDays(uint _minStakeDurationDays) external onlyOwner {\r\n        minStakeDurationDays = _minStakeDurationDays;\r\n    }\r\n    \r\n    function updateRewardAdjustmentFactor(uint _rewardAdjustmentFactor) external onlyOwner {\r\n        rewardAdjustmentFactor = _rewardAdjustmentFactor;\r\n    }\r\n    \r\n    function updateStakingEnabled(bool _stakingEnbaled) external onlyOwner {\r\n        stakingEnabled = _stakingEnbaled;\r\n    }\r\n    \r\n    function updateExponentialRewardsEnabled(bool _exponentialRewards) external onlyOwner {\r\n        exponentialRewardsEnabled = _exponentialRewards;\r\n    }\r\n    \r\n    function updateExponentialDaysMax(uint _exponentialDaysMax) external onlyOwner {\r\n        exponentialDaysMax = _exponentialDaysMax;\r\n    }\r\n    \r\n    function transferPampTokens(uint _numTokens) external onlyOwner {\r\n        pampToken.transfer(msg.sender, _numTokens);\r\n    }\r\n    \r\n    function giveMeDay() external onlyOwner {\r\n        stakers[owner].startTimestamp = block.timestamp.sub(86400);\r\n    }\r\n    \r\n    \r\n    function getStaker(address _staker) external view returns (uint, uint) {\r\n        return (stakers[_staker].startTimestamp, stakers[_staker].poolTokenBalance);\r\n    }\r\n    \r\n    \r\n     function mulDiv (uint x, uint y, uint z) public pure returns (uint) {\r\n          (uint l, uint h) = fullMul (x, y);\r\n          assert (h < z);\r\n          uint mm = mulmod (x, y, z);\r\n          if (mm > l) h -= 1;\r\n          l -= mm;\r\n          uint pow2 = z & -z;\r\n          z /= pow2;\r\n          l /= pow2;\r\n          l += h * ((-pow2) / pow2 + 1);\r\n          uint r = 1;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          return l * r;\r\n    }\r\n    \r\n    function fullMul (uint x, uint y) private pure returns (uint l, uint h) {\r\n          uint mm = mulmod (x, y, uint (-1));\r\n          l = x * y;\r\n          h = mm - l;\r\n          if (mm < l) h -= 1;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapPair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pampToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddr\",\"type\":\"address\"}],\"name\":\"calculateTokensOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exponentialDaysMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exponentialRewardsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getStaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"giveMeDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakeDurationDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pampToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pampTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAdjustmentFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numPoolTokensToStake\",\"type\":\"uint256\"}],\"name\":\"stakeLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolTokenBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"transferPampTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exponentialDaysMax\",\"type\":\"uint256\"}],\"name\":\"updateExponentialDaysMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_exponentialRewards\",\"type\":\"bool\"}],\"name\":\"updateExponentialRewardsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeDurationDays\",\"type\":\"uint256\"}],\"name\":\"updateMinStakeDurationDays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pampToken\",\"type\":\"address\"}],\"name\":\"updatePampToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardAdjustmentFactor\",\"type\":\"uint256\"}],\"name\":\"updateRewardAdjustmentFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_stakingEnbaled\",\"type\":\"bool\"}],\"name\":\"updateStakingEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapPair\",\"type\":\"address\"}],\"name\":\"updateUniswapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numPoolTokensToWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdrawLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidityPool","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001c608235e6a946403f2a048a38550befe41e1b85000000000000000000000000f0fac7104aac544e4a7ce1a55adf2b5a25c65bd1","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fb1efbab95b47a65bb5433398e66475e26bf2d590d3086988eb296f964937c3f"}]}