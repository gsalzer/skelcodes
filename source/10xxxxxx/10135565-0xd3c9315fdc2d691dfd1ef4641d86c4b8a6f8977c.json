{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.14;\r\n\r\ncontract ERC20 {\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  function transfer(address to, uint256 value) public returns(bool);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract Noda {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    event Deposit(address indexed user, address indexed tokenAddress, uint256 amount );\r\n    event Withdraw(address indexed user, address indexed tokenAddress, uint256 amount );\r\n    event Trade(uint256 indexed makerOrderID, address indexed  userAddress,\r\n    address tokenAddress, address requestTokenAddress, address feeAddress,\r\n    uint256 tradeAmount, uint256 feeAmount);\r\n    event OwnerProfit(address indexed tokenAddress, uint256 feeAmount);\r\n    \r\n    \r\n    address  payable public owner;\r\n    address public feeAddress;\r\n    bool public dexStatus;\r\n    \r\n    mapping( address => TokenDetails) public token;\r\n    \r\n    mapping( address => mapping(address => uint256)) public balance;\r\n    \r\n    mapping( address => uint256 ) public ownerFee;\r\n    \r\n    mapping( uint128 => OrderDetails ) public orders;\r\n    \r\n    mapping (bytes32 => bool) private hashComfirmation;\r\n    \r\n    struct TokenDetails {\r\n        address tokenAddress;\r\n        string symbol;\r\n        uint128 decimals_;\r\n        bool status;\r\n    }\r\n    \r\n    struct OrderDetails {\r\n        uint128 orderID;\r\n        address user;\r\n        uint8 status;\r\n    }\r\n   \r\n    constructor(address _feeaddress) public {\r\n        owner = msg.sender;  \r\n        feeAddress = _feeaddress;\r\n        dexStatus = true; \r\n    }\r\n    \r\n    modifier onlyFeeAddress() {\r\n        require(msg.sender == feeAddress, \"Call should be from fee address\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Call should be from owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier dexstatuscheck() { \r\n        require(dexStatus == true, \"Contract Inactive\");\r\n        _;\r\n    }\r\n    \r\n    function setDexStatus(bool _status) public onlyOwner returns(bool) { \r\n        dexStatus = _status; \r\n        return true;\r\n    }   \r\n    \r\n    function changeFeeAddress(address _feeAddress) public onlyOwner returns(bool) {\r\n        feeAddress = _feeAddress;\r\n        return true;\r\n    }\r\n    \r\n    function changeOwner(address payable _owner) public onlyOwner returns(bool) {\r\n        owner = _owner;\r\n        return true;\r\n    }\r\n    \r\n    function addToken(address _tokenAddress,string memory _symbol, uint128 _decimals) public onlyFeeAddress returns(bool) {\r\n        require(token[_tokenAddress].status != true, \"Token already exist\");\r\n        token[_tokenAddress].tokenAddress = _tokenAddress;\r\n        token[_tokenAddress].symbol = _symbol;\r\n        token[_tokenAddress].decimals_ = _decimals;\r\n        token[_tokenAddress].status = true;\r\n        return true;\r\n    }\r\n    \r\n    function removeToken(address _tokenAddress) public onlyFeeAddress returns(bool) {\r\n        require(token[_tokenAddress].status == true, \"Token does not exist\");\r\n        token[_tokenAddress].status = false;\r\n        return true;\r\n    }\r\n           \r\n    function ownerDeposit(address _tokenAddress, uint256 _amount) public dexstatuscheck onlyOwner payable returns(bool) {\r\n        require(token[_tokenAddress].status,\"token does not exist\");\r\n       \r\n        if (_tokenAddress == address(0)) {\r\n            require(msg.value > 0, \"Invalid eth amount\");\r\n            _amount = msg.value;\r\n        }else {\r\n            require(msg.value == 0, \"Invalid amount\");\r\n            require(_amount > 0, \"Invalid token amount\");\r\n            require(ERC20(_tokenAddress).balanceOf(msg.sender) >=  _amount, \"Insufficient Token balance\");\r\n            require(ERC20(_tokenAddress).allowance(msg.sender,address(this)) >= _amount, \"Insufficient allowance\");\r\n            ERC20(_tokenAddress).transferFrom(msg.sender, address(this), _amount);\r\n        }\r\n        balance[msg.sender][_tokenAddress] = balance[msg.sender][_tokenAddress].add(_amount);\r\n        emit Deposit(msg.sender, _tokenAddress, _amount);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function ownerWithdraw(address _tokenAddress, uint256 _amount)public dexstatuscheck onlyOwner returns(bool){\r\n          require(token[_tokenAddress].status,\"token does not exist\");\r\n          require(_amount > 0, \"Invalid amount\");\r\n          require(balance[msg.sender][_tokenAddress] >= _amount, \"Insufficient balance\");\r\n          \r\n          if (_tokenAddress == address(0)) {\r\n              msg.sender.transfer(_amount);\r\n          }else {\r\n              ERC20(_tokenAddress).transfer(msg.sender, _amount);\r\n          }\r\n          \r\n          balance[msg.sender][_tokenAddress] =  balance[msg.sender][_tokenAddress].sub(_amount);\r\n          emit Withdraw(msg.sender, _tokenAddress, _amount);\r\n          return true;\r\n    }\r\n    \r\n     function ownerProfitWithdraw(address _tokenAddr, uint256 _amount) public onlyOwner returns(bool){ \r\n         require(token[_tokenAddr].status,\"token does not exist\");\r\n         require(ownerFee[_tokenAddr] >=_amount, \"Insufficient balance\");\r\n         if (_tokenAddr == address(0)) { \r\n            owner.transfer(_amount);        \r\n        }else { \r\n            require(_tokenAddr != address(0), \"Invalid address\");\r\n            ERC20(_tokenAddr).transfer(owner, _amount); \r\n        }\r\n        \r\n        ownerFee[_tokenAddr] = ownerFee[_tokenAddr].sub(_amount); \r\n        emit Withdraw (owner, _tokenAddr, _amount);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function exchange(uint128 _orderID,uint256 _quantity,\r\n    uint128 _price,uint128 _fee,address _tokenAddress,\r\n    address _requestTokenAddress,address _feeAddress,uint8 v,bytes32 m,bytes32 r, bytes32 s) payable public returns(bool)\r\n    {\r\n      require(token[_tokenAddress].status && token[_requestTokenAddress].status, \"Maker token invalid\");\r\n      require(orders[_orderID].status != 2,\"order completed\");\r\n      require(!hashComfirmation[m],\"hash already used\");\r\n      require(ecrecover(m,v,r,s) == feeAddress, \"sign mismatch\");\r\n      hashComfirmation[m]=true;\r\n      address _user = msg.sender;\r\n        uint128 OrdId = _orderID;\r\n      if(_tokenAddress==address(0) && _feeAddress==address(0))\r\n      {\r\n          uint256 t_price = _quantity.mul(_price);\r\n          uint256 tt_price = addcalc(t_price,_requestTokenAddress).add(_fee);\r\n          require(tt_price==msg.value,\"Insufficient ether\");\r\n          \r\n          require(balance[owner][_requestTokenAddress] >= _quantity,\"Insufficient owner token balance\");\r\n          \r\n          balance[owner][_requestTokenAddress] = balance[owner][_requestTokenAddress].sub(_quantity);\r\n          balance[owner][_tokenAddress]=  balance[owner][_tokenAddress].add(tt_price);\r\n          ownerFee[_feeAddress]= ownerFee[_feeAddress].add(_fee);\r\n          uint256 qty=uint256(_quantity);\r\n          ERC20(_requestTokenAddress).transfer(_user,qty);\r\n      }\r\n      else\r\n      { \r\n         \r\n          if(_feeAddress==address(0))\r\n          {\r\n              require(_fee==msg.value,\"Insufficient Fee\");\r\n              ownerFee[_feeAddress]= ownerFee[_feeAddress].add(_fee);\r\n          }\r\n          else\r\n          {\r\n             require(ERC20(_feeAddress).balanceOf(_user) >=  _fee, \"Insufficient Token Fee balance\");\r\n             require(ERC20(_feeAddress).allowance(_user,address(this)) >= _fee, \"Insufficient Fee allowance\");\r\n             ERC20(_feeAddress).transferFrom(_user,address(this),_fee);\r\n             ownerFee[_feeAddress]= ownerFee[_feeAddress].add(_fee);\r\n          }\r\n           require(ERC20(_tokenAddress).balanceOf(_user) >=  _quantity, \"Insufficient Token balance\");\r\n          require(ERC20(_tokenAddress).allowance(_user,address(this)) >= _quantity, \"Insufficient allowance\");\r\n          uint256 qty=uint256(_quantity);\r\n          ERC20(_tokenAddress).transferFrom(_user,address(this),qty);\r\n          balance[owner][_tokenAddress]=  balance[owner][_tokenAddress].add(_quantity);\r\n          \r\n          uint256 t_price = qty.mul(_price);\r\n          t_price = t_price.div(token[_tokenAddress].decimals_);\r\n         \r\n          if(_requestTokenAddress==address(0))\r\n          {\r\n             require(balance[owner][_requestTokenAddress] >= t_price,\"Insufficient owner balance\");\r\n             address(uint160(_user)).transfer(t_price);\r\n          }\r\n          else\r\n          {\r\n              require(ERC20(_requestTokenAddress).balanceOf(owner) >=  t_price, \"Insufficient receiving Token balance\");\r\n              ERC20(_requestTokenAddress).transfer(_user,t_price);\r\n          }\r\n           balance[owner][_requestTokenAddress]=  balance[owner][_requestTokenAddress].sub(t_price);\r\n      }\r\n      \r\n      \r\n        emit OwnerProfit (_feeAddress, _fee);\r\n        \r\n         uint128 _feeev = _fee;\r\n         uint128 pprice = _price;\r\n         emit Trade(OrdId, _user, _tokenAddress, _requestTokenAddress,_feeAddress, pprice, _feeev);\r\n          \r\n          orders[OrdId].orderID = OrdId;\r\n          orders[OrdId].user = _user;\r\n          orders[OrdId].status = 2;\r\n        \r\n         return true;\r\n    }\r\n    \r\n    \r\n    function addcalc(uint256 a, address b)internal view returns(uint256)\r\n    {\r\n        uint256 c = a / token[b].decimals_;\r\n        return c;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeaddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"OwnerProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"makerOrderID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requestTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint128\",\"name\":\"_decimals\",\"type\":\"uint128\"}],\"name\":\"addToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"changeFeeAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_orderID\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_price\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_fee\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_requestTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"m\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"orderID\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ownerDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ownerProfitWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ownerWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setDexStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint128\",\"name\":\"decimals_\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Noda","CompilerVersion":"v0.5.14+commit.1f1aaa4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d39b9a2ac2c91500e54e30585aca3daac96035ad","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://61791ee350001bf2d65c0877172dd8631ee1d312cf89fd717d2da5fda50c6bc7"}]}