{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nDonation Exchange dexGiver smart-contract\r\n*/\r\n\r\npragma solidity ^0.5.17;\r\n\r\nlibrary SafeMath32 {  \r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\r\n        require(b <= a, errorMessage);\r\n        uint32 c = a - b;\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath128 {\r\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint128 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\r\n        require(b <= a, errorMessage);\r\n        uint128 c = a - b;\r\n        return c;\r\n    }\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        uint128 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath256 {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract dexTokenInterface {\r\n    function mintRefTokens(address referrer, address founder, uint32 id) external payable returns (bool);\r\n    function mintForUnreachableAddress(address userAddress, uint32 donationTurn) external payable returns (bool);\r\n}\r\n\r\n\r\ncontract dexGiver {\r\n    \r\n    using SafeMath32 for uint32;\r\n    using SafeMath128 for uint128;\r\n    using SafeMath256 for uint256;\r\n\r\n\r\n    event addDonationEvent(\r\n        address indexed user,\r\n        address indexed referrer,\r\n        uint128 amount,\r\n        uint32 indexed id,\r\n        uint64 time);\r\n        \r\n    event trasferDonationRewardEvent(\r\n        address indexed reciever,\r\n        address indexed donator,\r\n        uint128 amount,\r\n        uint32 indexed id,\r\n        uint64 time);\r\n        \r\n    event putedIntoUserList(\r\n        address indexed user,\r\n        address indexed referrer,\r\n        uint32 indexed id,\r\n        uint64 time);\r\n\r\n\r\n    struct DonationStruct {\r\n        address user;\r\n        uint128 trust;\r\n        uint128 reward;\r\n    }\r\n    \r\n    mapping (address => address) public refLinks;\r\n    mapping (uint32 => DonationStruct) public donationsList;\r\n    \r\n    address private owner;\r\n    address private founder;\r\n    address private dexTokenAddress;\r\n    string private support;\r\n    uint128 private min;\r\n    uint128 private max;\r\n    uint32 private donationsCounter;\r\n    uint32 private turn;\r\n    uint32 private currentUser;\r\n    uint8 constant donationPercent = 15;\r\n    uint8 constant rewardPercent = 15;\r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        founder = msg.sender;\r\n        refLinks[msg.sender] = msg.sender;\r\n        min = 50000000000000000;\r\n        max = 5000000000000000000;\r\n        donationsCounter = 0;\r\n        turn = 0;\r\n        currentUser = 1;\r\n    }\r\n    \r\n    dexTokenInterface dexToken;\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require (msg.sender == owner, \"Only for owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier dexTokenOnly() {\r\n        require (msg.sender == dexTokenAddress, \"Only for dexToken contract\");\r\n        _;\r\n    }\r\n    \r\n    function changeDexTokenAddress(address _newDexTokenAddress) external onlyOwner {\r\n        dexTokenAddress = _newDexTokenAddress;\r\n        dexToken = dexTokenInterface(_newDexTokenAddress);\r\n        assert(dexTokenAddress == _newDexTokenAddress);\r\n    }\r\n    \r\n    function changeOwnerAddress(address _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n        assert(owner == _newOwner);\r\n    }\r\n    \r\n    function changeFounderAddress(address _newFounder) external onlyOwner {\r\n        refLinks[founder] = _newFounder;\r\n        refLinks[_newFounder] = _newFounder;\r\n        founder = _newFounder;\r\n        assert(founder == _newFounder);\r\n    }\r\n\r\n    function changeMinMax(uint128 _newMin, uint128 _newMax) external onlyOwner {\r\n        min = _newMin;\r\n        max = _newMax;\r\n        assert(min == _newMin && max == _newMax);\r\n    }\r\n    \r\n    function changeSupport(string calldata _newSupport) external onlyOwner {\r\n        support = _newSupport;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    function () external payable {\r\n        require(msg.sender != dexTokenAddress, \"No access for dexToken\");\r\n        require(msg.value >= min && msg.value <= max, 'Wrong donation amount!');\r\n        \r\n        (address referrer, uint32 id) = setReferrer();\r\n        \r\n        transferRewards(referrer, id);\r\n        \r\n        donationsTransfer(msg.sender);\r\n    }\r\n    \r\n    \r\n    function setReferrer() private returns (address, uint32) {\r\n        \r\n        address refLinksReferrer = refLinks[msg.sender];\r\n        address hexDataAddress = bytesToAddress(msg.data);\r\n            require(hexDataAddress != address(this));\r\n        address resultReferrer;\r\n        \r\n        if (refLinksReferrer != address(0)) {\r\n\r\n            resultReferrer = refLinksReferrer;\r\n\r\n        } else if (refLinks[hexDataAddress] != address(0)) {\r\n\r\n            refLinks[msg.sender] = hexDataAddress;\r\n            putUserIntoUserList(msg.sender, hexDataAddress);\r\n            resultReferrer = hexDataAddress;\r\n\r\n        } else {\r\n            \r\n            refLinks[msg.sender] = dexTokenAddress;\r\n            putUserIntoUserList(msg.sender, dexTokenAddress);\r\n            resultReferrer = dexTokenAddress;\r\n            \r\n        }\r\n        \r\n        uint32 donationId = addDonation(resultReferrer);\r\n        return (resultReferrer, donationId);\r\n    }\r\n    \r\n\r\n    function addDonation(address _referrer) private returns (uint32) {\r\n        \r\n        uint32 donationId = donationsCounter;\r\n        \r\n        donationsList[donationId] = DonationStruct(msg.sender, uint128(msg.value.mul(uint(donationPercent).add(100)).div(100)), 0);\r\n        \r\n        donationsCounter++;\r\n        \r\n        emit addDonationEvent(\r\n            msg.sender,\r\n            _referrer,\r\n            uint128(msg.value),\r\n            donationId,\r\n            uint64(now));\r\n        \r\n        return donationId;\r\n    }\r\n    \r\n    \r\n    function transferRewards(address _referrer, uint32 _id) private {\r\n        \r\n        uint256 rewardAmount = uint256(msg.value.mul(uint(rewardPercent)).div(100));\r\n        \r\n        (bool success) = dexToken.mintRefTokens.value(rewardAmount)(_referrer, founder, _id);\r\n        require(success, \"Tokens were not minted\");\r\n    }\r\n    \r\n    \r\n    function _donationsTransfer(address _dexTokenBuyer) external payable dexTokenOnly returns (bool) {\r\n        bool result = donationsTransfer(_dexTokenBuyer);\r\n        return result;\r\n    }\r\n    \r\n\r\n    function donationsTransfer(address _donator) private returns (bool) {\r\n        \r\n        uint128 balance = uint128(address(this).balance);\r\n        uint32 tempTurn = turn;\r\n        uint32 tempDonationCounter = donationsCounter;\r\n\r\n        while (balance > 0 && tempDonationCounter > tempTurn) {\r\n            uint128 trust = donationsList[tempTurn].trust;\r\n            uint128 reward = donationsList[tempTurn].reward;\r\n            uint128 debt = trust.sub(reward);\r\n\r\n            if ( debt <= balance) {\r\n                \r\n                donationsList[tempTurn].reward = trust;\r\n                \r\n                address payable rewardReciever = address(uint160(donationsList[tempTurn].user));\r\n                \r\n                tempTurn++;\r\n                balance = balance.sub(debt);\r\n                \r\n                (bool wasEtherRecieved,) = rewardReciever.call.value(debt)(\"\");\r\n                \r\n                if(!wasEtherRecieved) {\r\n                    (bool success) = dexToken.mintForUnreachableAddress.value(debt)(rewardReciever, tempTurn.sub(1));\r\n                    require(success);\r\n                } else {\r\n                    emit trasferDonationRewardEvent(rewardReciever, _donator, debt, tempTurn.sub(1), uint64(now));\r\n                }\r\n                \r\n            } else {\r\n                \r\n                donationsList[tempTurn].reward = donationsList[tempTurn].reward.add(balance);\r\n                \r\n                address payable rewardReciever = address(uint160(donationsList[tempTurn].user));\r\n                uint128 tempBalance = balance;\r\n                balance = 0;\r\n                \r\n                (bool wasEtherRecieved,) = rewardReciever.call.value(tempBalance)(\"\");\r\n                \r\n                if(!wasEtherRecieved) {\r\n                    (bool success) = dexToken.mintForUnreachableAddress.value(tempBalance)(rewardReciever, tempTurn);\r\n                    require(success);\r\n                } else {\r\n                    emit trasferDonationRewardEvent(rewardReciever, _donator, tempBalance, tempTurn, uint64(now));\r\n                }\r\n            }\r\n            assert(address(this).balance == balance);\r\n        }\r\n        turn = tempTurn;\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function checkDexTokenUserReferrer(address _user, address _dataAddress) external dexTokenOnly returns (bool, address) {\r\n        \r\n        require(_dataAddress != address(this));\r\n        \r\n        address refLinksReferrer = refLinks[_user];\r\n        address hexDataAddress = _dataAddress;\r\n        \r\n        if (refLinksReferrer != address(0)) {\r\n            \r\n            return (true, refLinksReferrer);\r\n            \r\n        } else if (refLinks[hexDataAddress] != address(0)) {\r\n            \r\n            refLinks[_user] = hexDataAddress;\r\n            putUserIntoUserList(_user, hexDataAddress);\r\n            \r\n            return (true, hexDataAddress);\r\n            \r\n        } else {\r\n            \r\n            refLinks[_user] = dexTokenAddress;\r\n            putUserIntoUserList(_user, dexTokenAddress);\r\n            \r\n            return (true, dexTokenAddress);\r\n        }\r\n    }\r\n    \r\n    \r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        if (bys.length == 20) {\r\n            assembly {\r\n                addr := mload(add(bys, 20))\r\n            }\r\n            return addr;\r\n        } else {\r\n            return address(0);\r\n        }\r\n    }\r\n    \r\n    \r\n    function whoIsSupport() external view returns (string memory) {\r\n        return support;\r\n    }\r\n    \r\n    \r\n    function putUserIntoUserList(address _user, address _referrer) private {\r\n        emit putedIntoUserList(_user, _referrer, currentUser, uint64(now));\r\n        currentUser++;\r\n    }\r\n    \r\n    \r\n    function dataReturn(address _user) external view returns (address, uint32, uint32, uint32, uint128, uint128) {\r\n        return (refLinks[_user], donationsCounter, turn, currentUser, min, max);\r\n    }\r\n    \r\n    \r\n    function getAddressByDonationId(uint32 _donationId) external view returns (address) {\r\n        return donationsList[_donationId].user;\r\n    }\r\n    \r\n    \r\n    function userDonationsRewardReturn(uint[] calldata _array) external view returns (uint[] memory) {\r\n        require(_array.length <= 100, \"Too many donations\");\r\n        uint[] memory donationRewards = new uint[](_array.length);\r\n        for(uint i = 0; i < _array.length; ++i) {\r\n            donationRewards[i] = donationsList[uint32(_array[i])].reward;\r\n        }\r\n        return donationRewards;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"addDonationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"putedIntoUserList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reciever\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"donator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"trasferDonationRewardEvent\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexTokenBuyer\",\"type\":\"address\"}],\"name\":\"_donationsTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDexTokenAddress\",\"type\":\"address\"}],\"name\":\"changeDexTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFounder\",\"type\":\"address\"}],\"name\":\"changeFounderAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_newMin\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_newMax\",\"type\":\"uint128\"}],\"name\":\"changeMinMax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newSupport\",\"type\":\"string\"}],\"name\":\"changeSupport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dataAddress\",\"type\":\"address\"}],\"name\":\"checkDexTokenUserReferrer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"dataReturn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"donationsList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"trust\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"reward\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_donationId\",\"type\":\"uint32\"}],\"name\":\"getAddressByDonationId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"refLinks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_array\",\"type\":\"uint256[]\"}],\"name\":\"userDonationsRewardReturn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whoIsSupport\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"dexGiver","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d0b5a7df9124689ea03211a3de9a9548aa1b68295c2a9ebedc7e67f3dcb50e65"}]}