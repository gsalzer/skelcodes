{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\nlibrary SafeMath {\r\n \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary DataStructs {\r\n        struct Player {\r\n            uint256 totalInvestment;\r\n            uint256 referralIncome;\r\n            uint256 dailyIncome;\r\n            uint256 poolIncome;\r\n            uint256 lastSettledTime;\r\n            uint256 incomeLimit;\r\n            uint256 incomeLimitLeft;\r\n            uint256 referralCount;\r\n            address referrer;\r\n            uint256 RegDt;\r\n            uint256 DlyRIPer;\r\n            uint256 cycle;\r\n            uint256 CrnInv;\r\n            uint256 SPDiv;\r\n        }\r\n}\r\n\r\ncontract _Dice2win {\r\n    \r\n    using SafeMath for *;\r\n    address public owner;\r\n    uint256 houseFee = 2;\r\n    uint256 poolTime = 24 hours;\r\n    uint256 payoutPeriod = 24 hours;\r\n    uint256 incomeTimes = 3;\r\n    \r\n    uint256 public r1 = 0;\r\n    uint256 public r2 = 0;\r\n    \r\n    mapping (uint => uint) public CYCLE_PRICE;\r\n    mapping(uint=>uint) public LEVEL;\r\n    mapping(uint=>uint) public DlyGwths;\r\n    mapping(uint=>uint) public SPDiv;\r\n    \r\n    mapping (address => bool) public playerExist;\r\n    mapping (address => DataStructs.Player) public player;\r\n\r\n    /****************************  EVENTS   *****************************************/\r\n    event registerUserEvent(address indexed _playerAddress, address indexed _referrer);\r\n    event upgradeLevelEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event referralCommissionEvent(address _playerAddress, address indexed _referrer, uint256 indexed amount, uint256 indexed Levelno, uint256 timeStamp);\r\n    event UserregistrationDtls(address _playerAddress, address indexed _referrer, uint256 indexed amount, uint256 indexed Levelno, uint256 timeStamp);\r\n    event missedDirectreferralCommissionEvent(address indexed _playerAddress, address indexed _referrer, uint256 indexed amount, uint256  timeStamp);\r\n    event dailyPayoutEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event withdrawEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event ownershipTransferred(address indexed owner, address indexed newOwner);\r\n    //\r\n    \r\n    constructor (address ownerAddress) public {\r\n        \r\n         owner = ownerAddress;//msg.sender;\r\n\r\n         CYCLE_PRICE[1] = 0.1 ether;\r\n         CYCLE_PRICE[2] = 1 ether;\r\n         CYCLE_PRICE[3] = 1.1 ether;\r\n         CYCLE_PRICE[4] = 10 ether;\r\n         CYCLE_PRICE[5] = 10.1 ether;\r\n         CYCLE_PRICE[6] = 25.5 ether;\r\n         //\r\n            LEVEL[1]=5 ether;\r\n            LEVEL[2]=1 ether;\r\n            LEVEL[3]=0.75 ether;\r\n            LEVEL[4]=0.50 ether;\r\n            LEVEL[5]=0.25 ether;\r\n            LEVEL[6]=0.25 ether;\r\n            LEVEL[7]=0.75 ether;\r\n            LEVEL[8]=0.50 ether;\r\n            LEVEL[9]=0.25 ether;\r\n            LEVEL[10]=5 ether;\r\n            LEVEL[11]=.25 ether;\r\n            LEVEL[12]=.75 ether;\r\n            LEVEL[13]=.50 ether;\r\n            LEVEL[14]=.25 ether;\r\n            LEVEL[15]=0.25 ether;\r\n            LEVEL[16]=0.75 ether;\r\n            LEVEL[17]=0.50 ether;\r\n            LEVEL[18]=0.25 ether;\r\n            LEVEL[19]=0.25 ether;\r\n            LEVEL[20]=5 ether;\r\n            //\r\n            DlyGwths[1]=0.50 ether;\r\n            DlyGwths[2]=0.75 ether;\r\n            DlyGwths[3]=1 ether;\r\n            //\r\n            SPDiv[1]=50 ether;\r\n    }\r\n    /****************************  MODIFIERS    *****************************************/\r\n    \r\n    \r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth <= 25500000000000000000, \"Maximum contribution amount is 25.5 ETH\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev allows only the user to run the function\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only Owner\");\r\n        _;\r\n    }\r\n   \r\n    //if someone accidently sends eth to contract address\r\n    function () external payable {\r\n        playGame(address(0x0));\r\n    }\r\n    //\r\n    function playGame(address _referrer) public isWithinLimits(msg.value) payable {\r\n        //\r\n        uint256 amount = msg.value;\r\n        //\r\n        uint256 Dlyprott=0;\r\n        //\r\n         if (amount>=CYCLE_PRICE[1] && amount<=CYCLE_PRICE[2])\r\n        {\r\n            Dlyprott=DlyGwths[1];\r\n        }\r\n            if (amount>=CYCLE_PRICE[3] && amount<=CYCLE_PRICE[4])\r\n        {\r\n            Dlyprott=DlyGwths[2];\r\n        }\r\n            if (amount>=CYCLE_PRICE[5] && amount<=CYCLE_PRICE[6])\r\n        {\r\n            Dlyprott=DlyGwths[3];\r\n        }\r\n        //\r\n        if (playerExist[msg.sender] == false) \r\n        {\r\n            require(amount>= CYCLE_PRICE[1], \"joining fees should be 0.1 ether\");\r\n            //\r\n            player[msg.sender].lastSettledTime = now;\r\n            player[msg.sender].incomeLimit = amount.mul(incomeTimes);//.div(incomeDivide);\r\n            player[msg.sender].incomeLimitLeft = player[msg.sender].incomeLimit;\r\n            player[msg.sender].totalInvestment = amount;\r\n            player[msg.sender].RegDt=now;\r\n            player[msg.sender].DlyRIPer=0;\r\n            player[msg.sender].cycle=1;\r\n            //\r\n            playerExist[msg.sender] = true;\r\n            //\r\n            player[msg.sender].DlyRIPer=Dlyprott;\r\n            player[msg.sender].CrnInv=amount;\r\n            //\r\n            if(\r\n                // is this a referred purchase?\r\n                _referrer != address(0x0) && \r\n                //self referrer not allowed\r\n                _referrer != msg.sender &&\r\n                \r\n                //referrer exists?\r\n                playerExist[_referrer] == true\r\n              ) \r\n              \r\n              {\r\n                    //Assign referral to user\r\n                    player[msg.sender].referrer = _referrer;\r\n                    // Increase referral count of user referral\r\n                    player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                    //\r\n                    referralBonusTransferDirect(msg.sender, amount);\r\n                    //\r\n                    referralDirectsLvl(msg.sender, amount) ;\r\n                    //\r\n              }\r\n              else \r\n              {\r\n                  //\r\n                  r1 = r1.add(amount.mul(23).div(100));\r\n              }\r\n              //\r\n              emit registerUserEvent(msg.sender, _referrer);\r\n              //  \r\n        }\r\n            else {\r\n                    uint _cycle;\r\n                    //\r\n                    require(player[msg.sender].incomeLimitLeft==0,\"Oops Your limit is still remaining\");\r\n                    //\r\n                    _cycle =player[msg.sender].cycle; \r\n                    //\r\n                    player[msg.sender].lastSettledTime = now;\r\n                    player[msg.sender].incomeLimit = amount.mul(incomeTimes);//.div(incomeDivide);\r\n                    player[msg.sender].incomeLimitLeft = player[msg.sender].incomeLimit;\r\n                    player[msg.sender].totalInvestment = player[msg.sender].totalInvestment.add(amount);\r\n                    player[msg.sender].cycle = _cycle + 1;\r\n                    player[msg.sender].DlyRIPer=Dlyprott;\r\n                    player[msg.sender].CrnInv=amount;\r\n                    //\r\n                    if( _referrer != address(0x0) &&  _referrer != msg.sender && playerExist[_referrer] == true ) \r\n                      {\r\n                          if(player[msg.sender].referrer != address(0x0))\r\n                          {\r\n                                _referrer = player[msg.sender].referrer;\r\n                          }     \r\n                            else \r\n                            {\r\n                                player[msg.sender].referrer = _referrer;\r\n                            }\r\n                            //\r\n                            referralBonusTransferDirect(msg.sender, amount);\r\n                            //\r\n                            referralDirectsLvl(msg.sender, amount) ;\r\n                            //\r\n                      }\r\n                    else if(_referrer == address(0x0) && player[msg.sender].referrer != address(0x0)) \r\n                            {\r\n                                //\r\n                            _referrer = player[msg.sender].referrer;//amount.mul(18).div(100)\r\n                            //\r\n                            referralBonusTransferDirect(msg.sender, amount);\r\n                            //\r\n                             referralDirectsLvl(msg.sender, amount) ;\r\n                            //\r\n                            }\r\n                            else \r\n                            {\r\n                            r1 = r1.add(amount.mul(23).div(100));\r\n                            }\r\n                    //\r\n                    emit upgradeLevelEvent(msg.sender, amount);\r\n                    //\r\n            }\r\n    }\r\n    function referralBonusTransferDirect(address _playerAddress, uint256 amount)\r\n    internal\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint i;\r\n        uint256 TotBns;\r\n\r\n        for(i=0; i < 20; i++) {\r\n            //\r\n            uint256 refinc=amount.mul(LEVEL[i+1]).div(100000000000000000000);\r\n            //\r\n            TotBns=amount.mul(23).div(100);\r\n            //\r\n            if (_nextReferrer != address(0x0)) \r\n            {     \r\n            //\r\n            TotBns=TotBns.sub(refinc);\r\n            //\r\n                if(player[_nextReferrer].referralCount >= i+1) \r\n                {\r\n                    if (player[_nextReferrer].incomeLimitLeft >= refinc) \r\n                    {\r\n                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(refinc);\r\n                        player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(refinc);\r\n                       //\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, refinc,i+1, now);\r\n                    } \r\n                    \r\n                    else if(player[_nextReferrer].incomeLimitLeft !=0) \r\n                    {\r\n                        player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                        //r1.add(amount.div(10))\r\n                        r1 = r1.add(refinc.sub(player[_nextReferrer].incomeLimitLeft));\r\n                        //\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft,i+1, now);\r\n                        //\r\n                        player[_nextReferrer].incomeLimitLeft = 0;\r\n                        //\r\n                    }\r\n                    \r\n                    else  \r\n                    {\r\n                        r1 = r1.add(refinc); //\r\n                        emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, refinc, now);\r\n                        //\r\n                    }\r\n                }\r\n                else  \r\n                {\r\n                    r1 = r1.add(refinc); //\r\n                    emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, refinc, now);\r\n                    //\r\n                }\r\n            }\r\n            else \r\n            {\r\n                r1=r1.add(TotBns);\r\n              // r1 = r1.add(amount.mul((uint(23).sub(TotBns))).div(100000000000000000000));\r\n              //  r1 = r1.add((uint(23).sub(TotBns)).mul(refinc)); //uint(23).sub(i)).mul(refinc\r\n                emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, TotBns, now);\r\n                break;\r\n            }\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n    //\r\n    function referralDirectsLvl(address _playerAddress, uint256 amount)   internal\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint i;\r\n        for(i=0; i < 20; i++) {\r\n            //\r\n                    if( _nextReferrer != address(0x0) &&  _nextReferrer != msg.sender && playerExist[_nextReferrer] == true ) \r\n                    {\r\n                    //UserregistrationDtls(address _playerAddress, address indexed _referrer, uint256 indexed amount, uint256 indexed Levelno, uint256 timeStamp);\r\n                    emit UserregistrationDtls(_playerAddress, _nextReferrer, amount,i+1, now);\r\n                    //\r\n                    }\r\n                    else\r\n                    {\r\n                        break;\r\n                    }\r\n            //\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n            //\r\n        }\r\n    }\r\n    //\r\n    function referralBonusTransferDailyROI(address _playerAddress, uint256 amount) internal\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint i;\r\n        uint256 sproi=amount.mul(SPDiv[1]).div(100000000000000000000);\r\n        //\r\n        for(i=0; i < 1; i++) \r\n        {\r\n            if (_nextReferrer != address(0x0)) {\r\n                //\r\n                if(player[_nextReferrer].referralCount >= i+1) \r\n                {\r\n                    if (player[_nextReferrer].incomeLimitLeft >= sproi ) \r\n                    {\r\n                        //\r\n                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(sproi);\r\n                        player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(sproi);\r\n                        player[_nextReferrer].SPDiv = player[_nextReferrer].SPDiv.add(sproi);\r\n                        //\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, sproi,i+1, now);\r\n                        //\r\n                    } \r\n                    else if(player[_nextReferrer].incomeLimitLeft !=0) \r\n                    {\r\n                        player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                       \r\n                        player[_nextReferrer].SPDiv =  player[_nextReferrer].SPDiv.add(player[_nextReferrer].incomeLimitLeft);\r\n                        \r\n                        r2 = r2.add(sproi.sub(player[_nextReferrer].incomeLimitLeft));\r\n                        \r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft,i+1, now);\r\n                        \r\n                        player[_nextReferrer].incomeLimitLeft = 0;\r\n                        \r\n                    }\r\n                    else \r\n                    {\r\n                        r2 = r2.add(sproi); \r\n                        emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, sproi, now);\r\n                    }\r\n                }\r\n                else  \r\n                {\r\n                    r2 = r2.add(sproi); //\r\n                    emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, sproi, now);\r\n                }\r\n            }   \r\n            else \r\n            {\r\n                r2 = r2.add(sproi);\r\n                //r2 = r2.add((uint(10).sub(i)).mul(sproi)); //\r\n                emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, r2.add(sproi), now);\r\n                break;\r\n            }\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n    function settleIncome() public {\r\n        address _playerAddress = msg.sender;\r\n        //\r\n        uint256 remainingTimeForPayout;\r\n        //\r\n        uint256 currInvestedAmount;\r\n        //\r\n        if(now > player[_playerAddress].lastSettledTime + payoutPeriod) \r\n        {\r\n            //\r\n            uint256 extraTime = now.sub(player[_playerAddress].lastSettledTime);\r\n            //\r\n            uint256 _dailyIncome;\r\n            //\r\n            remainingTimeForPayout = (extraTime.sub((extraTime % payoutPeriod))).div(payoutPeriod);\r\n            //   player[msg.sender].DlyRIPer=Dlyprott;\r\n               //     player[msg.sender].CrnInv=amount;\r\n            currInvestedAmount = player[_playerAddress].CrnInv;//CYCLE_PRICE[player[_playerAddress].cycle];\r\n            //\r\n            _dailyIncome =currInvestedAmount.mul(player[_playerAddress].DlyRIPer).div(100000000000000000000); \r\n            //currInvestedAmount.player[msg.sender].DlyRIPer.div(100)\r\n            //\r\n            if (player[_playerAddress].incomeLimitLeft >= _dailyIncome.mul(remainingTimeForPayout)) \r\n            {\r\n                player[_playerAddress].incomeLimitLeft = player[_playerAddress].incomeLimitLeft.sub(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].lastSettledTime = player[_playerAddress].lastSettledTime.add((extraTime.sub((extraTime % payoutPeriod))));\r\n                //\r\n                emit dailyPayoutEvent( _playerAddress, _dailyIncome.mul(remainingTimeForPayout), now);\r\n                //\r\n                referralBonusTransferDailyROI(_playerAddress, _dailyIncome.mul(remainingTimeForPayout));\r\n            }\r\n            else if(player[_playerAddress].incomeLimitLeft !=0) \r\n            {\r\n                uint256 temp;\r\n                temp = player[_playerAddress].incomeLimitLeft;                 \r\n                player[_playerAddress].incomeLimitLeft = 0;\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(temp);\r\n                player[_playerAddress].lastSettledTime = now;\r\n                //\r\n                emit dailyPayoutEvent( _playerAddress, temp, now);\r\n                //\r\n                referralBonusTransferDailyROI(_playerAddress, temp);\r\n            }\r\n            \r\n        }\r\n    }\r\n    function withdrawIncome() public \r\n    {\r\n        address _playerAddress = msg.sender;\r\n        uint256 _earnings =\r\n                    player[_playerAddress].dailyIncome +\r\n                    player[_playerAddress].referralIncome +\r\n                    player[_playerAddress].poolIncome;\r\n        if(_earnings > 0) {\r\n            require(address(this).balance >= _earnings, \"Contract doesn't have sufficient amount to give you\");\r\n            player[_playerAddress].dailyIncome = 0;\r\n            player[_playerAddress].referralIncome = 0;\r\n            player[_playerAddress].poolIncome = 0;\r\n            \r\n            address(_playerAddress).transfer(_earnings);\r\n            emit withdrawEvent(_playerAddress, _earnings, now);\r\n        }\r\n    }\r\n    \r\n    function getPlayerInfo(address _playerAddress) public view returns(uint256) \r\n    {\r\n            uint256 remainingTimeForPayout;\r\n            if(playerExist[_playerAddress] == true) {\r\n            \r\n                if(player[_playerAddress].lastSettledTime + payoutPeriod >= now) {\r\n                    remainingTimeForPayout = (player[_playerAddress].lastSettledTime + payoutPeriod).sub(now);\r\n                }\r\n                else {\r\n                    uint256 temp = now.sub(player[_playerAddress].lastSettledTime);\r\n                    remainingTimeForPayout = payoutPeriod.sub((temp % payoutPeriod));\r\n                }\r\n                return remainingTimeForPayout;\r\n            }\r\n    }\r\n    function withdrawFees(uint256 _amount, address _receiver, uint256 _numberUI) public onlyOwner {\r\n\r\n        if(_numberUI == 1 && r1 >= _amount) {\r\n            if(_amount > 0) {\r\n                if(address(this).balance >= _amount) {\r\n                    r1 = r1.sub(_amount);\r\n                    address(_receiver).transfer(_amount);\r\n                }\r\n            }\r\n        }\r\n        else if(_numberUI == 2 && r2 >= _amount) {\r\n            if(_amount > 0) {\r\n                if(address(this).balance >= _amount) {\r\n                    r2 = r2.sub(_amount);\r\n                    address(_receiver).transfer(_amount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\r\n        emit ownershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"playGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"player\",\"outputs\":[{\"name\":\"totalInvestment\",\"type\":\"uint256\"},{\"name\":\"referralIncome\",\"type\":\"uint256\"},{\"name\":\"dailyIncome\",\"type\":\"uint256\"},{\"name\":\"poolIncome\",\"type\":\"uint256\"},{\"name\":\"lastSettledTime\",\"type\":\"uint256\"},{\"name\":\"incomeLimit\",\"type\":\"uint256\"},{\"name\":\"incomeLimitLeft\",\"type\":\"uint256\"},{\"name\":\"referralCount\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"RegDt\",\"type\":\"uint256\"},{\"name\":\"DlyRIPer\",\"type\":\"uint256\"},{\"name\":\"cycle\",\"type\":\"uint256\"},{\"name\":\"CrnInv\",\"type\":\"uint256\"},{\"name\":\"SPDiv\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEVEL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_numberUI\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SPDiv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CYCLE_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settleIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"DlyGwths\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ownerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"registerUserEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"upgradeLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"Levelno\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"referralCommissionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"Levelno\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"UserregistrationDtls\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"missedDirectreferralCommissionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"dailyPayoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"withdrawEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownershipTransferred\",\"type\":\"event\"}]","ContractName":"_Dice2win","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009c60c92a0acc6fbd6773f0002dd41451186135f6","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8c665a30de7610a1db1c5007d13e72dfe3d5a16925632a028b89d99c81d6919f"}]}