{"status":"1","message":"OK","result":[{"SourceCode":"{\"ExpertLegion.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Vars.sol\\\";\\r\\n\\r\\n\\r\\n// $$$$$$$$\\\\                                           $$\\\\     $$\\\\                           $$\\\\                     \\r\\n// $$  _____|                                          $$ |    $$ |                          \\\\__|                    \\r\\n// $$ |      $$\\\\   $$\\\\  $$$$$$\\\\   $$$$$$\\\\   $$$$$$\\\\  $$$$$$\\\\   $$ |       $$$$$$\\\\   $$$$$$\\\\  $$\\\\  $$$$$$\\\\  $$$$$$$\\\\  \\r\\n// $$$$$\\\\    \\\\$$\\\\ $$  |$$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ \\\\_$$  _|  $$ |      $$  __$$\\\\ $$  __$$\\\\ $$ |$$  __$$\\\\ $$  __$$\\\\ \\r\\n// $$  __|    \\\\$$$$  / $$ /  $$ |$$$$$$$$ |$$ |  \\\\__|  $$ |    $$ |      $$$$$$$$ |$$ /  $$ |$$ |$$ /  $$ |$$ |  $$ |\\r\\n// $$ |       $$  $$\\u003c  $$ |  $$ |$$   ____|$$ |        $$ |$$\\\\ $$ |      $$   ____|$$ |  $$ |$$ |$$ |  $$ |$$ |  $$ |\\r\\n// $$$$$$$$\\\\ $$  /\\\\$$\\\\ $$$$$$$  |\\\\$$$$$$$\\\\ $$ |        \\\\$$$$  |$$$$$$$$\\\\ \\\\$$$$$$$\\\\ \\\\$$$$$$$ |$$ |\\\\$$$$$$  |$$ |  $$ |\\r\\n// \\\\________|\\\\__/  \\\\__|$$  ____/  \\\\_______|\\\\__|         \\\\____/ \\\\________| \\\\_______| \\\\____$$ |\\\\__| \\\\______/ \\\\__|  \\\\__|\\r\\n//                     $$ |                                                        $$\\\\   $$ |        fork version 1.2  \\r\\n//                     $$ |                                                        \\\\$$$$$$  |                        \\r\\n//                     \\\\__|                                                         \\\\______/                             \\r\\n//  Official Smart Contract  expertlegion.com                                            Powered by Options Legion\\r\\n\\r\\n\\r\\ncontract ExpertLegion is Vars {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    constructor() public{\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n    \\r\\n  \\r\\n    receive() external payable{\\r\\n        require(!stop);\\r\\n     \\r\\n        if(!users[msg.sender].isExist)\\r\\n            registerUser(msg.sender, msg.value, 0,owner);\\r\\n        else \\r\\n            activateUser(msg.sender, msg.value);\\r\\n    }\\r\\n    \\r\\n   \\r\\n\\r\\n   \\r\\n    function registerUser(address payable _user, uint256 _fee, bytes32 _code, address _referer) public payable{\\r\\n        require(_fee \\u003e= activationCharges \\u0026\\u0026 msg.value \\u003e= activationCharges); \\r\\n        require(!users[_user].isExist); \\r\\n        \\r\\n       \\r\\n        isStop();\\r\\n        \\r\\n      \\r\\n        if(!stop){\\r\\n            if(_code != 0)\\r\\n                isReferred(_code);\\r\\n            \\r\\n            \\r\\n            storeUserData(_user ,  _referer);\\r\\n        \\r\\n            \\r\\n            distributeToUplines(_fee, _user , _referer,false);\\r\\n        \\r\\n            \\r\\n            emit UserRegistered(_user, users[_user].level, users[_user].id, users[_user].deadline );\\r\\n        } else{\\r\\n            revert(\\\"contract is full\\\");\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    \\r\\n       function populateExistingUsers(address payable  _user, bytes32 _code, address _referer)  public   { //v1.2 \\r\\n   \\r\\n        require(!users[_user].isExist); \\r\\n        require ( msg.sender == owner );\\r\\n            if(currentUserId \\u003c 12){\\r\\n                if (_code!=0)\\r\\n                    isReferred(_code);\\r\\n            storeUserData(_user ,  _referer);\\r\\n            emit UserRegistered(_user, users[_user].level, users[_user].id, users[_user].deadline );\\r\\n        } \\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    function storeUserData(address payable _user, address _referer) internal {\\r\\n       \\r\\n        if(_referer != owner){\\r\\n            \\r\\n             require(users[_referer].isExist); \\r\\n             \\r\\n        }\\r\\n        \\r\\n        currentUserId++; \\r\\n        userList[currentUserId] = _user; \\r\\n       \\r\\n        bytes32 code = generateReferral(_user);\\r\\n      \\r\\n        if(occupiedSlots == 3 ** (currentLevel)){ \\r\\n            currentLevel++;\\r\\n            occupiedSlots = 0;\\r\\n        }\\r\\n        \\r\\n        \\r\\n        User memory u;\\r\\n        u.isExist = true;\\r\\n        u.id = currentUserId;\\r\\n        u.totalReferrals = 0;\\r\\n        u.deadline = now.add(activationPeriod);\\r\\n        \\r\\n        uint256 level = 0;\\r\\n      if(_referer != owner){\\r\\n        level = (users[_referer].totalReferrals)-1;\\r\\n        }\\r\\n        if( level \\u003c 9/3){\\r\\n              u.level = users[_referer].level+1;\\r\\n        }else if( level \\u003c 27/3){\\r\\n              u.level = users[_referer].level+2;\\r\\n        }else if( level \\u003c 81/3){\\r\\n              u.level = users[_referer].level+3;\\r\\n        }else if( level \\u003c 243/3){\\r\\n              u.level = users[_referer].level+4;\\r\\n        }else if( level \\u003c 729/3){\\r\\n              u.level = users[_referer].level+5;\\r\\n        }else if( level \\u003c 2187/3){\\r\\n              u.level = users[_referer].level+6;\\r\\n        }else if( level \\u003c 2187/3){\\r\\n              u.level = users[_referer].level+7;\\r\\n        }else if( level \\u003c 6561/3){\\r\\n              u.level = users[_referer].level+8;\\r\\n        }else if( level \\u003c 19683/3){\\r\\n              u.level = users[_referer].level+9;\\r\\n        }else if( level \\u003c 59049/3){\\r\\n              u.level = users[_referer].level+10;\\r\\n        }else if( level \\u003c 177147/3){\\r\\n              u.level = users[_referer].level+11;\\r\\n        }else if( level \\u003c 531441/3){\\r\\n              u.level = users[_referer].level+12;\\r\\n        }\\r\\n        \\r\\n        u.initialInviter =  _referer;\\r\\n        address  referer =  _referer; \\r\\n        \\r\\n        \\r\\n        \\r\\n  if(level \\u003e= 9/3){\\r\\n       for(uint i = 12; i \\u003e= 1; i--){\\r\\n               \\r\\n                for(uint id = 1; id\\u003c= 3 ** i; id++){\\r\\n                    address  _user_compare = userList[id]; \\r\\n                    if (users[_user_compare].referer ==  _referer  \\u0026\\u0026 users[_user_compare].totalReferrals \\u003c= 4 ){\\r\\n                        \\r\\n                       u.level =  users[_user_compare].level+1;\\r\\n                        referer =  _user_compare;\\r\\n                        if (level \\u003c 13){\\r\\n                            users[_user_compare].totalReferrals +=1;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            \\r\\n  }else{\\r\\n     referer =  _referer;\\r\\n  }\\r\\n           \\r\\n            \\r\\n            \\r\\n\\r\\n        if (level \\u003e 12){\\r\\n           revert(\\\"contract is full\\\");\\r\\n        }\\r\\n     \\r\\n        u.referralLink = code;\\r\\n        u.referer  = referer;\\r\\n        users[_user] = u;\\r\\n        \\r\\n        occupiedSlots++;\\r\\n        totalMembers++;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n     function w() external  {\\r\\n    require ( msg.sender == owner );\\r\\n    owner.transfer(address(this).balance);\\r\\n    }\\r\\n     \\r\\n    \\r\\n    \\r\\n    function generateReferral(address _user) internal returns(bytes32){\\r\\n        bytes32 id = keccak256(abi.encode(_user, currentUserId)); \\r\\n        hashedIds[id] = _user;\\r\\n        return id;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function distributeToUplines(uint256 _fee, address _sender , address _referer, bool _activate) internal { \\r\\n        require(address(this).balance \\u003e= _fee);\\r\\n        \\r\\n        uint256 registerChargeFee = 0.005 ether;\\r\\n        uint256 ownerFunds;\\r\\n        uint256 amountToDistributeToUplines = _fee; \\r\\n        if (_activate == false){\\r\\n        amountToDistributeToUplines = _fee.sub(registerChargeFee); \\r\\n        }\\r\\n        uint256 eachUplineShare = amountToDistributeToUplines.div(12);\\r\\n        uint256 currentLevel_user =  users[_sender].level;\\r\\n        if(currentLevel_user == 1){\\r\\n            \\r\\n            ownerFunds = _fee;\\r\\n        } \\r\\n        else{\\r\\n            address  referer =  _referer;\\r\\n  \\r\\n            for(uint i = currentLevel_user-1; i \\u003e= 1; i--){\\r\\n            \\r\\n                uint256 userAmount = eachUplineShare;\\r\\n            \\r\\n               \\r\\n                for(uint id = 1; id\\u003c= 3 ** i; id++){\\r\\n                    address payable _user = userList[id]; \\r\\n                    if (_user ==  referer  ){\\r\\n                        bool _eligible = userEligible(_user, _sender);\\r\\n                \\r\\n                        if(_eligible){    \\r\\n                            _user.transfer(userAmount);     \\r\\n                            emit UserFundsTransfer(_user, userAmount, currentLevel, currentUserId);\\r\\n                        } else{                         \\r\\n                            ownerFunds += userAmount;      \\r\\n                        }\\r\\n                        referer = users[_user].referer;\\r\\n                        id = 1;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            emit UplineFundsDistributed((currentLevel_user-1).mul(eachUplineShare), currentLevel, currentUserId);\\r\\n        \\r\\n           \\r\\n            ownerFunds += _fee.sub((currentLevel_user-1).mul(eachUplineShare));\\r\\n        }\\r\\n        \\r\\n        \\r\\n        owner.transfer(ownerFunds);\\r\\n        emit OwnerFundsTransfer(ownerFunds, currentLevel, currentUserId);\\r\\n    }\\r\\n    \\r\\n    function userEligible(address _user, address _sender) internal view returns(bool _eligible){\\r\\n        \\r\\n        if(users[_user].deadline \\u003e now  \\u0026\\u0026 users[_user].level \\u003c users[_sender].level ){\\r\\n            if((users[_user].totalReferrals == 1 \\u0026\\u0026 users[_sender].level \\u003c= users[_user].level+3) || (_user == users[_sender].initialInviter))\\r\\n                return true;\\r\\n            else if((users[_user].totalReferrals == 2 \\u0026\\u0026 users[_sender].level \\u003c=  users[_user].level+6) || (_user == users[_sender].initialInviter) )\\r\\n                return true;\\r\\n            else if((users[_user].totalReferrals \\u003e= 3) || (_user == users[_sender].initialInviter))\\r\\n                return true;\\r\\n            else \\r\\n                return false;\\r\\n        } \\r\\n        \\r\\n        else{ \\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function isReferred(bytes32 _code) internal{\\r\\n        require(hashedIds[_code] != address(0));\\r\\n        users[hashedIds[_code]].totalReferrals++; \\r\\n    }\\r\\n    \\r\\n    // activates the existing user\\r\\n    function activateUser(address _user, uint256 _fee) public payable{\\r\\n        require(users[_user].isExist);\\r\\n        require(_fee \\u003e= (activationCharges));\\r\\n        \\r\\n        isStop();\\r\\n        \\r\\n        \\r\\n        if(!stop){\\r\\n            users[_user].deadline = (users[_user].deadline).add(activationPeriod); \\r\\n           \\r\\n            distributeToUplines(_fee, _user, users[_user].referer,false);\\r\\n            \\r\\n            emit UserActivated(_user, users[_user].level, users[_user].id, users[_user].deadline );\\r\\n        } else{\\r\\n            revert(\\\"Contract has been stopped\\\");\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function isStop() internal{\\r\\n        if(currentLevel == 12 \\u0026\\u0026 occupiedSlots == 3**12){\\r\\n            stop = true;\\r\\n        }\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"Vars.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\ncontract Vars{\\r\\n    uint256 public activationCharges = 0.255 ether; // fee paid to activate/join the game, 0.005 register charge fee will go to owner, rest will be distributed to uplines\\r\\n    uint256 public activationPeriod = 120 days; // expiration time since day of joining\\r\\n    uint256 public currentLevel = 1; // current level where people can join, 0 level is for the main wallet\\r\\n    uint256 public currentUserId = 0; // current active Id that will be assigned to the person who join, 0 Id is for the main wallet\\r\\n    uint256 occupiedSlots = 0; // slots that are already occupied in each level\\r\\n    uint256 public totalMembers = 0; // slots that are already occupied in each level\\r\\n    address payable public owner;\\r\\n\\r\\n    bool stop;\\r\\n    struct User{\\r\\n        bool isExist;\\r\\n        uint256 id;\\r\\n        uint256 totalReferrals;\\r\\n        uint256 deadline;\\r\\n        uint256 level;\\r\\n        address referer;\\r\\n        bytes32 referralLink;\\r\\n        address initialInviter;\\r\\n    }\\r\\n    \\r\\n    mapping(address =\\u003e User) public users; // stores information about users based on their addresses\\r\\n    mapping(bytes32 =\\u003e address) hashedIds; // stores the refferal codes for each user based on their addresses\\r\\n    mapping(uint256 =\\u003e address payable) userList; // stores the address of each user based on the Id assigned\\r\\n\\r\\n    \\r\\n    event OwnerFundsTransfer(uint256 amount, uint256 fromLevel, uint256 fromSlotId);\\r\\n    event UplineFundsDistributed(uint256 amount, uint256 fromLevel, uint256 fromSlotId);\\r\\n    event UserFundsTransfer(address user, uint256 amount, uint256 fromLevel, uint256 fromSlotId);\\r\\n    event UserRegistered(address user, uint256 level, uint256 slotId, uint256 expiresAt);\\r\\n    event UserActivated(address user, uint256 level, uint256 slotId, uint256 expiresAt);\\r\\n    event UserReferred(address referrer, uint256 referred);\\r\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromSlotId\",\"type\":\"uint256\"}],\"name\":\"OwnerFundsTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromSlotId\",\"type\":\"uint256\"}],\"name\":\"UplineFundsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"UserActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromSlotId\",\"type\":\"uint256\"}],\"name\":\"UserFundsTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referred\",\"type\":\"uint256\"}],\"name\":\"UserReferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"activateUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activationCharges\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activationPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_code\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_referer\",\"type\":\"address\"}],\"name\":\"populateExistingUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_code\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_referer\",\"type\":\"address\"}],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMembers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReferrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"referralLink\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"initialInviter\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"w\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ExpertLegion","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e9349ef3c7c7bf072bf238df5c0c5342b18f1b0588417df3e1f4b19a1580978b"}]}