{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.23 <0.6.0;\r\n\r\ncontract Million {\r\n    struct User {\r\n        uint key;\r\n        address referrer;\r\n        bool[] levelActived;\r\n        address[] levelReferrer;\r\n        address[][] levelReferrals;\r\n        address[][5][] levelMatrix;\r\n    }\r\n    mapping(address => User) public users;\r\n    address[] public addresses;\r\n    uint[4] public levelFee = [0.05 ether, 0.5 ether, 5 ether, 50 ether];\r\n  \r\n    constructor() public {\r\n        addresses.push(msg.sender);\r\n        User memory user = User({\r\n            key: addresses.length,\r\n            referrer: address(0),\r\n            levelActived: new bool[](0),\r\n            levelReferrer: new address[](0),\r\n            levelReferrals: new address[][](0),\r\n            levelMatrix: new address[][5][](0)\r\n        });\r\n        users[msg.sender] = user;\r\n        for (uint i = 1; i <= 4; i++) {\r\n            users[msg.sender].levelActived.push(true);\r\n            users[msg.sender].levelReferrer.push(address(0));\r\n            users[msg.sender].levelReferrals.push(new address[](0));\r\n            users[msg.sender].levelMatrix.push([new address[](0), new address[](0), new address[](0), new address[](0), new address[](0)]);\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        uint level;\r\n        if (msg.value == levelFee[0]) level = 1;\r\n        else if (msg.value == levelFee[1]) level = 2;\r\n        else if (msg.value == levelFee[2]) level = 3;\r\n        else if (msg.value == levelFee[3]) level = 4;\r\n        else revert(\"incorrect value\");\r\n\r\n        if (level == 1) {\r\n            if (userExist(msg.sender)) revert(\"already registered\");\r\n            address referrer = bytesToAddress(msg.data);\r\n            registerUser(referrer);\r\n        } else {\r\n            if (!userExist(msg.sender)) revert(\"user not exist\");\r\n            if (users[msg.sender].levelActived[level-1]) revert(\"level already actived\");\r\n            buyLevel(level);\r\n        }\r\n    }\r\n\r\n    function registerUser(address referrer) public payable {\r\n        require(msg.value == levelFee[0], \"incorrect value\");\r\n        require(!userExist(msg.sender), \"user exist\");\r\n        if (referrer == address(0) || !userExist(referrer)) referrer = addresses[0];\r\n       \r\n        referrer = findFreeUpline(referrer, 1);\r\n        addresses.push(msg.sender);\r\n        User memory user = User({\r\n            key: addresses.length,\r\n            referrer: referrer,\r\n            levelActived: new bool[](0),\r\n            levelReferrer: new address[](0),\r\n            levelReferrals: new address[][](0),\r\n            levelMatrix: new address[][5][](0)\r\n        });\r\n        users[msg.sender] = user;\r\n        for (uint i = 1; i <= 4; i++) {\r\n            users[msg.sender].levelActived.push(false);\r\n            users[msg.sender].levelReferrer.push(address(0));\r\n            users[msg.sender].levelReferrals.push(new address[](0));\r\n            users[msg.sender].levelMatrix.push([new address[](0), new address[](0), new address[](0), new address[](0), new address[](0)]);\r\n        }\r\n        users[msg.sender].levelActived[0] = true;\r\n        users[msg.sender].levelReferrer[0] = referrer;\r\n        \r\n        updateUplineMatrix(msg.sender, 1);\r\n        sendCoinToReferrer(msg.sender, 1);\r\n    }\r\n\r\n    function findFreeUpline(address referrer, uint level) public view returns(address) {\r\n        while(!users[referrer].levelActived[level-1]) {\r\n            referrer = users[referrer].referrer;\r\n        }\r\n        if (users[referrer].levelReferrals[level-1].length < 5) {\r\n            return referrer;\r\n        }\r\n\r\n        bool found = false;\r\n        address[] memory referrals = new address[](155);\r\n        for (uint i = 0; i < 5; i++) {\r\n            referrals[i] = users[referrer].levelReferrals[level-1][i];\r\n        }\r\n        for (uint i = 0; i < 155; i++) {\r\n            if (users[referrals[i]].levelReferrals[level-1].length == 5) {\r\n                if (i < 30) {\r\n                    for (uint k = 0; k < 5; k++) {\r\n                        referrals[(i+1)*5+k] = users[referrals[i]].levelReferrals[level-1][k];\r\n                    }\r\n                }\r\n            } else {\r\n                referrer = referrals[i];\r\n                found = true;\r\n                break;\r\n            } \r\n        }\r\n        require(found, \"cannot find upline\");\r\n        return referrer;\r\n    }\r\n\r\n    function buyLevel(uint level) public payable {\r\n        require(level >= 1 && level <= 4, \"invalid level\");\r\n        require(msg.value == levelFee[level-1], \"incorrect value\");\r\n        require(userExist(msg.sender), \"user not exist\");\r\n        require(!users[msg.sender].levelActived[level-1], \"level already actived\");\r\n\r\n        address referrer = findFreeUpline(users[msg.sender].referrer, level);\r\n        users[msg.sender].levelActived[level-1] = true;\r\n        users[msg.sender].levelReferrer[level-1] = referrer;\r\n        \r\n        updateUplineMatrix(msg.sender, level);\r\n        sendCoinToReferrer(msg.sender, level);\r\n    }\r\n\r\n    function updateUplineMatrix(address user, uint level) internal {\r\n        address referrer = users[user].levelReferrer[level-1];\r\n        users[referrer].levelReferrals[level-1].push(user);\r\n        address receiver = users[referrer].levelReferrer[level-1];\r\n        if (receiver == address(0)) return;\r\n        for (uint i = 0; i < users[receiver].levelReferrals[level-1].length; i++) {\r\n            if (users[receiver].levelReferrals[level-1][i] == referrer) {\r\n                users[receiver].levelMatrix[level-1][i].push(user);\r\n                break;\r\n            }    \r\n        }\r\n    }\r\n\r\n    function sendCoinToReferrer(address user, uint level) internal {\r\n        address referrer = users[user].levelReferrer[level-1];\r\n        address receiver = users[referrer].levelReferrer[level-1];\r\n        if (receiver == address(0)) receiver = addresses[0];\r\n        address(uint160(receiver)).transfer(levelFee[level-1]);\r\n    }\r\n     \r\n    function userExist(address user) public view returns(bool) {\r\n        return users[user].key > 0;\r\n    }\r\n\r\n    function viewUserExistAndLevelActived(address user) public view returns(bool, bool[] memory) {\r\n        if (users[user].key > 0) {\r\n            return (true, users[user].levelActived);\r\n        } else {\r\n            return (false, new bool[](0));\r\n        }\r\n    }\r\n\r\n    function viewUserLevelMatrix(address user, uint level) public view returns(address, address[] memory, address[] memory) {\r\n        address[] memory matrix = new address[](25);\r\n        for (uint i = 0; i < 5; i++) {\r\n            for (uint k = 0; k < users[user].levelMatrix[level-1][i].length; k++) {\r\n                matrix[i*5+k] = users[user].levelMatrix[level-1][i][k];\r\n            }\r\n        }\r\n        return (users[user].levelReferrer[level-1], users[user].levelReferrals[level-1], matrix);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"registerUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"findFreeUpline\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelMatrix\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"key\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"viewUserExistAndLevelActived\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Million","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://96623b0a8ccdb78a0e60703556066cefb1995c12871c6ad007a012097df485ff"}]}