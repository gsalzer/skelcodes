{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: solidity/contracts/utility/interfaces/IOwned.sol\n\npragma solidity 0.4.26;\n\n/*\n    Owned contract interface\n*/\ncontract IOwned {\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n    function owner() public view returns (address) {this;}\n\n    function transferOwnership(address _newOwner) public;\n    function acceptOwnership() public;\n}\n\n// File: solidity/contracts/token/interfaces/IERC20Token.sol\n\npragma solidity 0.4.26;\n\n/*\n    ERC20 Standard Token interface\n*/\ncontract IERC20Token {\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n    function name() public view returns (string) {this;}\n    function symbol() public view returns (string) {this;}\n    function decimals() public view returns (uint8) {this;}\n    function totalSupply() public view returns (uint256) {this;}\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n// File: solidity/contracts/utility/interfaces/ITokenHolder.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Token Holder interface\n*/\ncontract ITokenHolder is IOwned {\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterAnchor.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Converter Anchor interface\n*/\ncontract IConverterAnchor is IOwned, ITokenHolder {\n}\n\n// File: solidity/contracts/token/interfaces/ISmartToken.sol\n\npragma solidity 0.4.26;\n\n\n\n\n/*\n    Smart Token interface\n*/\ncontract ISmartToken is IConverterAnchor, IERC20Token {\n    function disableTransfers(bool _disable) public;\n    function issue(address _to, uint256 _amount) public;\n    function destroy(address _from, uint256 _amount) public;\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/interfaces/IPoolTokensContainer.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Pool Tokens Container interface\n*/\ncontract IPoolTokensContainer is IConverterAnchor {\n    function poolTokens() public view returns (ISmartToken[]);\n    function createToken() public returns (ISmartToken);\n    function mint(ISmartToken _token, address _to, uint256 _amount) public;\n    function burn(ISmartToken _token, address _from, uint256 _amount) public;\n}\n\n// File: solidity/contracts/utility/Owned.sol\n\npragma solidity 0.4.26;\n\n\n/**\n  * @dev Provides support and utilities for contract ownership\n*/\ncontract Owned is IOwned {\n    address public owner;\n    address public newOwner;\n\n    /**\n      * @dev triggered when the owner is updated\n      *\n      * @param _prevOwner previous owner\n      * @param _newOwner  new owner\n    */\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n\n    /**\n      * @dev initializes a new Owned instance\n    */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        _ownerOnly();\n        _;\n    }\n\n    // error message binary size optimization\n    function _ownerOnly() internal view {\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\n    }\n\n    /**\n      * @dev allows transferring the contract ownership\n      * the new owner still needs to accept the transfer\n      * can only be called by the contract owner\n      *\n      * @param _newOwner    new contract owner\n    */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\n        newOwner = _newOwner;\n    }\n\n    /**\n      * @dev used by a new owner to accept an ownership transfer\n    */\n    function acceptOwnership() public {\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\n        emit OwnerUpdate(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n// File: solidity/contracts/utility/Utils.sol\n\npragma solidity 0.4.26;\n\n/**\n  * @dev Utilities & Common Modifiers\n*/\ncontract Utils {\n    // verifies that a value is greater than zero\n    modifier greaterThanZero(uint256 _value) {\n        _greaterThanZero(_value);\n        _;\n    }\n\n    // error message binary size optimization\n    function _greaterThanZero(uint256 _value) internal pure {\n        require(_value > 0, \"ERR_ZERO_VALUE\");\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address _address) {\n        _validAddress(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validAddress(address _address) internal pure {\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\n    }\n\n    // verifies that the address is different than this contract address\n    modifier notThis(address _address) {\n        _notThis(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _notThis(address _address) internal view {\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\n    }\n}\n\n// File: solidity/contracts/utility/TokenHandler.sol\n\npragma solidity 0.4.26;\n\n\ncontract TokenHandler {\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n    /**\n      * @dev executes the ERC20 token's `approve` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _spender approved address\n      * @param _value   allowance amount\n    */\n    function safeApprove(IERC20Token _token, address _spender, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransfer(IERC20Token _token, address _to, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _from    source address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n    }\n\n    /**\n      * @dev executes a function on the ERC20 token and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _data    data to pass in to the token's contract for execution\n    */\n    function execute(IERC20Token _token, bytes memory _data) private {\n        uint256[1] memory ret = [uint256(1)];\n\n        assembly {\n            let success := call(\n                gas,            // gas remaining\n                _token,         // destination address\n                0,              // no ether\n                add(_data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\n                mload(_data),   // input length (loaded from the first 32 bytes in the `data` array)\n                ret,            // output buffer\n                32              // output length\n            )\n            if iszero(success) {\n                revert(0, 0)\n            }\n        }\n\n        require(ret[0] != 0, \"ERR_TRANSFER_FAILED\");\n    }\n}\n\n// File: solidity/contracts/utility/TokenHolder.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n\n/**\n  * @dev We consider every contract to be a 'token holder' since it's currently not possible\n  * for a contract to deny receiving tokens.\n  *\n  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\n  * the owner to send tokens that were sent to the contract by mistake back to their sender.\n  *\n  * Note that we use the non standard ERC-20 interface which has no return value for transfer\n  * in order to support both non standard as well as standard token contracts.\n  * see https://github.com/ethereum/solidity/issues/4116\n*/\ncontract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\n    /**\n      * @dev withdraws tokens held by the contract and sends them to an account\n      * can only be called by the owner\n      *\n      * @param _token   ERC20 token contract address\n      * @param _to      account to receive the new amount\n      * @param _amount  amount to withdraw\n    */\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n        public\n        ownerOnly\n        validAddress(_token)\n        validAddress(_to)\n        notThis(_to)\n    {\n        safeTransfer(_token, _to, _amount);\n    }\n}\n\n// File: solidity/contracts/utility/SafeMath.sol\n\npragma solidity 0.4.26;\n\n/**\n  * @dev Library for basic math operations with overflow/underflow protection\n*/\nlibrary SafeMath {\n    /**\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\n      *\n      * @param _x   value 1\n      * @param _y   value 2\n      *\n      * @return sum\n    */\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        uint256 z = _x + _y;\n        require(z >= _x, \"ERR_OVERFLOW\");\n        return z;\n    }\n\n    /**\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\n      *\n      * @param _x   minuend\n      * @param _y   subtrahend\n      *\n      * @return difference\n    */\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        require(_x >= _y, \"ERR_UNDERFLOW\");\n        return _x - _y;\n    }\n\n    /**\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\n      *\n      * @param _x   factor 1\n      * @param _y   factor 2\n      *\n      * @return product\n    */\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        // gas optimization\n        if (_x == 0)\n            return 0;\n\n        uint256 z = _x * _y;\n        require(z / _x == _y, \"ERR_OVERFLOW\");\n        return z;\n    }\n\n    /**\n      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n      *\n      * @param _x   dividend\n      * @param _y   divisor\n      *\n      * @return quotient\n    */\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\n        uint256 c = _x / _y;\n        return c;\n    }\n}\n\n// File: solidity/contracts/token/ERC20Token.sol\n\npragma solidity 0.4.26;\n\n\n\n\n/**\n  * @dev ERC20 Standard Token implementation\n*/\ncontract ERC20Token is IERC20Token, Utils {\n    using SafeMath for uint256;\n\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    /**\n      * @dev triggered when tokens are transferred between wallets\n      *\n      * @param _from    source address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    /**\n      * @dev triggered when a wallet allows another wallet to transfer tokens from on its behalf\n      *\n      * @param _owner   wallet that approves the allowance\n      * @param _spender wallet that receives the allowance\n      * @param _value   allowance amount\n    */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /**\n      * @dev initializes a new ERC20Token instance\n      *\n      * @param _name        token name\n      * @param _symbol      token symbol\n      * @param _decimals    decimal points, for display purposes\n      * @param _totalSupply total supply of token units\n    */\n    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {\n        // validate input\n        require(bytes(_name).length > 0, \"ERR_INVALID_NAME\");\n        require(bytes(_symbol).length > 0, \"ERR_INVALID_SYMBOL\");\n\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _totalSupply;\n        balanceOf[msg.sender] = _totalSupply;\n    }\n\n    /**\n      * @dev transfers tokens to a given address\n      * throws on any error rather then return a false flag to minimize user errors\n      *\n      * @param _to      target address\n      * @param _value   transfer amount\n      *\n      * @return true if the transfer was successful, false if it wasn't\n    */\n    function transfer(address _to, uint256 _value)\n        public\n        validAddress(_to)\n        returns (bool success)\n    {\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n      * @dev transfers tokens to a given address on behalf of another address\n      * throws on any error rather then return a false flag to minimize user errors\n      *\n      * @param _from    source address\n      * @param _to      target address\n      * @param _value   transfer amount\n      *\n      * @return true if the transfer was successful, false if it wasn't\n    */\n    function transferFrom(address _from, address _to, uint256 _value)\n        public\n        validAddress(_from)\n        validAddress(_to)\n        returns (bool success)\n    {\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n        balanceOf[_from] = balanceOf[_from].sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n      * @dev allows another account/contract to transfers tokens on behalf of the caller\n      * throws on any error rather then return a false flag to minimize user errors\n      *\n      * also, to minimize the risk of the approve/transferFrom attack vector\n      * (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\n      * in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\n      *\n      * @param _spender approved address\n      * @param _value   allowance amount\n      *\n      * @return true if the approval was successful, false if it wasn't\n    */\n    function approve(address _spender, uint256 _value)\n        public\n        validAddress(_spender)\n        returns (bool success)\n    {\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\n        require(_value == 0 || allowance[msg.sender][_spender] == 0, \"ERR_INVALID_AMOUNT\");\n\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n}\n\n// File: solidity/contracts/token/SmartToken.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n/**\n  * @dev Smart Token\n  *\n  * 'Owned' is specified here for readability reasons\n*/\ncontract SmartToken is ISmartToken, Owned, ERC20Token, TokenHolder {\n    using SafeMath for uint256;\n\n    uint16 public constant version = 4;\n\n    bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false otherwise\n\n    /**\n      * @dev triggered when the total supply is increased\n      *\n      * @param _amount  amount that gets added to the supply\n    */\n    event Issuance(uint256 _amount);\n\n    /**\n      * @dev triggered when the total supply is decreased\n      *\n      * @param _amount  amount that gets removed from the supply\n    */\n    event Destruction(uint256 _amount);\n\n    /**\n      * @dev initializes a new SmartToken instance\n      *\n      * @param _name       token name\n      * @param _symbol     token short symbol, minimum 1 character\n      * @param _decimals   for display purposes only\n    */\n    constructor(string _name, string _symbol, uint8 _decimals)\n        public\n        ERC20Token(_name, _symbol, _decimals, 0)\n    {\n    }\n\n    // allows execution only when transfers are enabled\n    modifier transfersAllowed {\n        _transfersAllowed();\n        _;\n    }\n\n    // error message binary size optimization\n    function _transfersAllowed() internal view {\n        require(transfersEnabled, \"ERR_TRANSFERS_DISABLED\");\n    }\n\n    /**\n      * @dev disables/enables transfers\n      * can only be called by the contract owner\n      *\n      * @param _disable    true to disable transfers, false to enable them\n    */\n    function disableTransfers(bool _disable) public ownerOnly {\n        transfersEnabled = !_disable;\n    }\n\n    /**\n      * @dev increases the token supply and sends the new tokens to the given account\n      * can only be called by the contract owner\n      *\n      * @param _to      account to receive the new amount\n      * @param _amount  amount to increase the supply by\n    */\n    function issue(address _to, uint256 _amount)\n        public\n        ownerOnly\n        validAddress(_to)\n        notThis(_to)\n    {\n        totalSupply = totalSupply.add(_amount);\n        balanceOf[_to] = balanceOf[_to].add(_amount);\n\n        emit Issuance(_amount);\n        emit Transfer(address(0), _to, _amount);\n    }\n\n    /**\n      * @dev removes tokens from the given account and decreases the token supply\n      * can only be called by the contract owner\n      *\n      * @param _from    account to remove the amount from\n      * @param _amount  amount to decrease the supply by\n    */\n    function destroy(address _from, uint256 _amount) public ownerOnly {\n        balanceOf[_from] = balanceOf[_from].sub(_amount);\n        totalSupply = totalSupply.sub(_amount);\n\n        emit Transfer(_from, address(0), _amount);\n        emit Destruction(_amount);\n    }\n\n    // ERC20 standard method overrides with some extra functionality\n\n    /**\n      * @dev send coins\n      * throws on any error rather then return a false flag to minimize user errors\n      * in addition to the standard checks, the function throws if transfers are disabled\n      *\n      * @param _to      target address\n      * @param _value   transfer amount\n      *\n      * @return true if the transfer was successful, false if it wasn't\n    */\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\n        assert(super.transfer(_to, _value));\n        return true;\n    }\n\n    /**\n      * @dev an account/contract attempts to get the coins\n      * throws on any error rather then return a false flag to minimize user errors\n      * in addition to the standard checks, the function throws if transfers are disabled\n      *\n      * @param _from    source address\n      * @param _to      target address\n      * @param _value   transfer amount\n      *\n      * @return true if the transfer was successful, false if it wasn't\n    */\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\n        assert(super.transferFrom(_from, _to, _value));\n        return true;\n    }\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/PoolTokensContainer.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n/**\n  * @dev The PoolTokensContainer contract serves as a container for multiple pool tokens.\n  * It is used by specific liquidity pool types that require more than a single pool token,\n  * while still maintaining the single converter / anchor relationship.\n  *\n  * It maintains and provides a list of the underlying pool tokens.\n */\ncontract PoolTokensContainer is IPoolTokensContainer, Owned, TokenHolder {\n    uint8 internal constant MAX_POOL_TOKENS = 5;    // maximum pool tokens in the container\n\n    string public name;                 // pool name\n    string public symbol;               // pool symbol\n    uint8 public decimals;              // underlying pool tokens decimals\n    ISmartToken[] private _poolTokens;  // underlying pool tokens\n\n    /**\n      * @dev initializes a new PoolTokensContainer instance\n      *\n      * @param  _name       pool name, also used as a prefix for the underlying pool token names\n      * @param  _symbol     pool symbol, also used as a prefix for the underlying pool token symbols\n      * @param  _decimals   used for the underlying pool token decimals\n    */\n    constructor(string _name, string _symbol, uint8 _decimals) public {\n         // validate input\n        require(bytes(_name).length > 0, \"ERR_INVALID_NAME\");\n        require(bytes(_symbol).length > 0, \"ERR_INVALID_SYMBOL\");\n\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    /**\n      * @dev returns the list of pool tokens\n      *\n      * @return list of pool tokens\n    */\n    function poolTokens() public view returns (ISmartToken[] memory) {\n        return _poolTokens;\n    }\n\n    /**\n      * @dev creates a new pool token and adds it to the list\n      *\n      * @return new pool token address\n    */\n    function createToken() public ownerOnly returns (ISmartToken) {\n        // verify that the max limit wasn't reached\n        require(_poolTokens.length < MAX_POOL_TOKENS, \"ERR_MAX_LIMIT_REACHED\");\n\n        string memory poolName = concatStrDigit(name, uint8(_poolTokens.length + 1));\n        string memory poolSymbol = concatStrDigit(symbol, uint8(_poolTokens.length + 1));\n\n        SmartToken token = new SmartToken(poolName, poolSymbol, decimals);\n        _poolTokens.push(token);\n        return token;\n    }\n\n    /**\n      * @dev increases the pool token supply and sends the new tokens to the given account\n      * can only be called by the contract owner\n      *\n      * @param _token   pool token address\n      * @param _to      account to receive the newly minted tokens\n      * @param _amount  amount to mint\n    */\n    function mint(ISmartToken _token, address _to, uint256 _amount) public ownerOnly {\n        _token.issue(_to, _amount);\n    }\n\n    /**\n      * @dev removes tokens from the given account and decreases the pool token supply\n      * can only be called by the contract owner\n      *\n      * @param _token   pool token address\n      * @param _from    account to remove the tokens from\n      * @param _amount  amount to burn\n    */\n    function burn(ISmartToken _token, address _from, uint256 _amount) public ownerOnly {\n        _token.destroy(_from, _amount);\n    }\n\n    /**\n      * @dev concatenates a string and a digit (single only) and returns the result string\n      *\n      * @param _str     string\n      * @param _digit   digit\n      * @return concatenated string\n    */\n    function concatStrDigit(string _str, uint8 _digit) private pure returns (string) {\n        return string(abi.encodePacked(_str, uint8(bytes1('0')) + _digit));\n    }\n}\n\n// File: solidity/contracts/converter/interfaces/ITypedConverterCustomFactory.sol\n\npragma solidity 0.4.26;\n\n/*\n    Typed Converter Custom Factory interface\n*/\ncontract ITypedConverterCustomFactory {\n    function converterType() public pure returns (uint16);\n}\n\n// File: solidity/contracts/utility/interfaces/IChainlinkPriceOracle.sol\n\npragma solidity 0.4.26;\n\n/*\n    Chainlink Price Oracle interface\n*/\ninterface IChainlinkPriceOracle {\n    function latestAnswer() external view returns (int256);\n    function latestTimestamp() external view returns (uint256);\n}\n\n// File: solidity/contracts/utility/interfaces/IPriceOracle.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Price Oracle interface\n*/\ncontract IPriceOracle {\n    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB) public view returns (uint256, uint256);\n    function lastUpdateTime() public view returns (uint256);\n    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB) public view returns (uint256, uint256, uint256);\n\n    function tokenAOracle() public view returns (IChainlinkPriceOracle) {this;}\n    function tokenBOracle() public view returns (IChainlinkPriceOracle) {this;}\n}\n\n// File: solidity/contracts/utility/PriceOracle.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n/**\n  * @dev Provides the off-chain rate between two tokens\n  *\n  * The price oracle uses chainlink oracles internally to get the rates of the two tokens\n  * with respect to a common denominator, and then returns the rate between them, which\n  * is equivalent to the rate of TokenA / TokenB\n*/\ncontract PriceOracle is IPriceOracle, Utils {\n    using SafeMath for uint256;\n\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint8 private constant ETH_DECIMALS = 18;\n\n    IERC20Token public tokenA;                  // token A the oracle supports\n    IERC20Token public tokenB;                  // token B the oracle supports\n    mapping (address => uint8) public tokenDecimals; // token -> token decimals\n\n    IChainlinkPriceOracle public tokenAOracle;  // token A chainlink price oracle\n    IChainlinkPriceOracle public tokenBOracle;  // token B chainlink price oracle\n    mapping (address => IChainlinkPriceOracle) public tokensToOracles;  // token -> price oracle for easier access\n\n    /**\n      * @dev initializes a new PriceOracle instance\n      * note that the oracles must have the same common denominator (USD, ETH etc.)\n      *\n      * @param  _tokenA         first token to support\n      * @param  _tokenB         second token to support\n      * @param  _tokenAOracle   first token price oracle\n      * @param  _tokenBOracle   second token price oracle\n    */\n    constructor(IERC20Token _tokenA, IERC20Token _tokenB, IChainlinkPriceOracle _tokenAOracle, IChainlinkPriceOracle _tokenBOracle)\n        public\n        validUniqueAddresses(_tokenA, _tokenB)\n        validUniqueAddresses(_tokenAOracle, _tokenBOracle)\n    {\n        tokenA = _tokenA;\n        tokenB = _tokenB;\n        tokenDecimals[_tokenA] = decimals(_tokenA);\n        tokenDecimals[_tokenB] = decimals(_tokenB);\n\n        tokenAOracle = _tokenAOracle;\n        tokenBOracle = _tokenBOracle;\n        tokensToOracles[_tokenA] = _tokenAOracle;\n        tokensToOracles[_tokenB] = _tokenBOracle;\n    }\n\n    // ensures that the provided addresses are unique valid\n    modifier validUniqueAddresses(address _address1, address _address2) {\n        _validUniqueAddresses(_address1, _address2);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validUniqueAddresses(address _address1, address _address2) internal pure {\n        _validAddress(_address1);\n        _validAddress(_address2);\n        require(_address1 != _address2, \"ERR_SAME_ADDRESS\");\n    }\n\n    // ensures that the provides tokens are supported by the oracle\n    modifier supportedTokens(IERC20Token _tokenA, IERC20Token _tokenB) {\n        _supportedTokens(_tokenA, _tokenB);\n        _;\n    }\n\n    // error message binary size optimization\n    function _supportedTokens(IERC20Token _tokenA, IERC20Token _tokenB) internal view {\n        _validUniqueAddresses(_tokenA, _tokenB);\n        require(tokensToOracles[_tokenA] != address(0) && tokensToOracles[_tokenB] != address(0), \"ERR_UNSUPPORTED_TOKEN\");\n    }\n\n    /**\n      * @dev returns the latest known rate between the two given tokens\n      * for a given pair of tokens A and B, returns the rate of A / B\n      * (the number of B units equivalent to a single A unit)\n      * the rate is returned as a fraction (numerator / denominator) for accuracy\n      *\n      * @param  _tokenA token to get the rate of 1 unit of\n      * @param  _tokenB token to get the rate of 1 `_tokenA` against\n      *\n      * @return numerator\n      * @return denominator\n    */\n    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB)\n        public\n        view\n        supportedTokens(_tokenA, _tokenB)\n        returns (uint256, uint256)\n    {\n        uint256 rateTokenA = uint256(tokensToOracles[_tokenA].latestAnswer());\n        uint256 rateTokenB = uint256(tokensToOracles[_tokenB].latestAnswer());\n        uint8 decimalsTokenA = tokenDecimals[_tokenA];\n        uint8 decimalsTokenB = tokenDecimals[_tokenB];\n\n        // the normalization works as follows:\n        //   - token A with decimals of dA and price of rateA per one token (e.g., for 10^dA weiA)\n        //   - token B with decimals of dB < dA and price of rateB per one token (e.g., for 10^dB weiB)\n        // then the normalized rate, representing the rate between 1 weiA and 1 weiB is rateA / (rateB * 10^(dA - dB)).\n        //\n        // for example:\n        //   - token A with decimals of 5 and price of $10 per one token (e.g., for 100,000 weiA)\n        //   - token B with decimals of 2 and price of $2 per one token (e.g., for 100 weiB)\n        // then the normalized rate would be: 5 / (2 * 10^3) = 0.0025, which is the correct rate since\n        // 1 weiA costs $0.00005, 1 weiB costs $0.02, and weiA / weiB is 0.0025.\n\n        if (decimalsTokenA > decimalsTokenB) {\n            rateTokenB = rateTokenB.mul(uint256(10) ** (decimalsTokenA - decimalsTokenB));\n        }\n        else if (decimalsTokenA < decimalsTokenB) {\n            rateTokenA = rateTokenA.mul(uint256(10) ** (decimalsTokenB - decimalsTokenA));\n        }\n\n        return (rateTokenA, rateTokenB);\n    }\n\n    /**\n      * @dev returns the timestamp of the last price update the rates are returned as numerator (token1) and denominator\n      * (token2) for accuracy\n      *\n      * @return timestamp\n    */\n    function lastUpdateTime()\n        public\n        view\n        returns (uint256) {\n        // returns the oldest timestamp between the two\n        uint256 timestampA = tokenAOracle.latestTimestamp();\n        uint256 timestampB = tokenBOracle.latestTimestamp();\n\n        return  timestampA < timestampB ? timestampA : timestampB;\n    }\n\n    /**\n      * @dev returns both the rate and the timestamp of the last update in a single call (gas optimization)\n      *\n      * @param  _tokenA token to get the rate of 1 unit of\n      * @param  _tokenB token to get the rate of 1 `_tokenA` against\n      *\n      * @return numerator\n      * @return denominator\n      * @return timestamp of the last update\n    */\n    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB)\n        public\n        view\n        returns (uint256, uint256, uint256)\n    {\n        (uint256 numerator, uint256 denominator) = latestRate(_tokenA, _tokenB);\n\n        return (numerator, denominator, lastUpdateTime());\n    }\n\n    /** @dev returns the decimals of a given token */\n    function decimals(IERC20Token _token) private view returns (uint8) {\n        if (_token == ETH_ADDRESS) {\n            return ETH_DECIMALS;\n        }\n\n        return _token.decimals();\n    }\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/LiquidityPoolV2ConverterCustomFactory.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    LiquidityPoolV2ConverterCustomFactory Factory\n*/\ncontract LiquidityPoolV2ConverterCustomFactory is ITypedConverterCustomFactory {\n    /**\n      * @dev returns the converter type the factory is associated with\n      *\n      * @return converter type\n    */\n    function converterType() public pure returns (uint16) {\n        return 2;\n    }\n\n    /**\n      * @dev creates a new price oracle\n      * note that the oracles must have the same common denominator (USD, ETH etc.)\n      *\n      * @param  _primaryReserveToken    primary reserve token address\n      * @param  _secondaryReserveToken  secondary reserve token address\n      * @param  _primaryReserveOracle   primary reserve oracle address\n      * @param  _secondaryReserveOracle secondary reserve oracle address\n    */\n    function createPriceOracle(\n        IERC20Token _primaryReserveToken,\n        IERC20Token _secondaryReserveToken,\n        IChainlinkPriceOracle _primaryReserveOracle,\n        IChainlinkPriceOracle _secondaryReserveOracle)\n        public\n        returns (IPriceOracle)\n    {\n        return new PriceOracle(_primaryReserveToken, _secondaryReserveToken, _primaryReserveOracle, _secondaryReserveOracle);\n    }\n}\n\n// File: solidity/contracts/utility/interfaces/IWhitelist.sol\n\npragma solidity 0.4.26;\n\n/*\n    Whitelist interface\n*/\ncontract IWhitelist {\n    function isWhitelisted(address _address) public view returns (bool);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverter.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n/*\n    Converter interface\n*/\ncontract IConverter is IOwned {\n    function converterType() public pure returns (uint16);\n    function anchor() public view returns (IConverterAnchor) {this;}\n    function isActive() public view returns (bool);\n\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256);\n    function convert(IERC20Token _sourceToken,\n                     IERC20Token _targetToken,\n                     uint256 _amount,\n                     address _trader,\n                     address _beneficiary) public payable returns (uint256);\n\n    function conversionWhitelist() public view returns (IWhitelist) {this;}\n    function conversionFee() public view returns (uint32) {this;}\n    function maxConversionFee() public view returns (uint32) {this;}\n    function reserveBalance(IERC20Token _reserveToken) public view returns (uint256);\n    function() external payable;\n\n    function transferAnchorOwnership(address _newOwner) public;\n    function acceptAnchorOwnership() public;\n    function setConversionFee(uint32 _conversionFee) public;\n    function setConversionWhitelist(IWhitelist _whitelist) public;\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n    function withdrawETH(address _to) public;\n    function addReserve(IERC20Token _token, uint32 _ratio) public;\n\n    // deprecated, backward compatibility\n    function token() public view returns (IConverterAnchor);\n    function transferTokenOwnership(address _newOwner) public;\n    function acceptTokenOwnership() public;\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool);\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\n    function connectorTokens(uint256 _index) public view returns (IERC20Token);\n    function connectorTokenCount() public view returns (uint16);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterUpgrader.sol\n\npragma solidity 0.4.26;\n\n/*\n    Converter Upgrader interface\n*/\ncontract IConverterUpgrader {\n    function upgrade(bytes32 _version) public;\n    function upgrade(uint16 _version) public;\n}\n\n// File: solidity/contracts/converter/interfaces/IBancorFormula.sol\n\npragma solidity 0.4.26;\n\n/*\n    Bancor Formula interface\n*/\ncontract IBancorFormula {\n    function purchaseTargetAmount(uint256 _supply,\n                                  uint256 _reserveBalance,\n                                  uint32 _reserveWeight,\n                                  uint256 _amount)\n                                  public view returns (uint256);\n\n    function saleTargetAmount(uint256 _supply,\n                              uint256 _reserveBalance,\n                              uint32 _reserveWeight,\n                              uint256 _amount)\n                              public view returns (uint256);\n\n    function crossReserveTargetAmount(uint256 _sourceReserveBalance,\n                                      uint32 _sourceReserveWeight,\n                                      uint256 _targetReserveBalance,\n                                      uint32 _targetReserveWeight,\n                                      uint256 _amount)\n                                      public view returns (uint256);\n\n    function fundCost(uint256 _supply,\n                      uint256 _reserveBalance,\n                      uint32 _reserveRatio,\n                      uint256 _amount)\n                      public view returns (uint256);\n\n    function fundSupplyAmount(uint256 _supply,\n                              uint256 _reserveBalance,\n                              uint32 _reserveRatio,\n                              uint256 _amount)\n                              public view returns (uint256);\n\n    function liquidateReserveAmount(uint256 _supply,\n                                    uint256 _reserveBalance,\n                                    uint32 _reserveRatio,\n                                    uint256 _amount)\n                                    public view returns (uint256);\n\n    function balancedWeights(uint256 _primaryReserveStakedBalance,\n                             uint256 _primaryReserveBalance,\n                             uint256 _secondaryReserveBalance,\n                             uint256 _reserveRateNumerator,\n                             uint256 _reserveRateDenominator)\n                             public view returns (uint32, uint32);\n}\n\n// File: solidity/contracts/IBancorNetwork.sol\n\npragma solidity 0.4.26;\n\n\n/*\n    Bancor Network interface\n*/\ncontract IBancorNetwork {\n    function convert2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public payable returns (uint256);\n\n    function claimAndConvert2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public returns (uint256);\n\n    function convertFor2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public payable returns (uint256);\n\n    function claimAndConvertFor2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public returns (uint256);\n\n    // deprecated, backward compatibility\n    function convert(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn\n    ) public payable returns (uint256);\n\n    // deprecated, backward compatibility\n    function claimAndConvert(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn\n    ) public returns (uint256);\n\n    // deprecated, backward compatibility\n    function convertFor(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for\n    ) public payable returns (uint256);\n\n    // deprecated, backward compatibility\n    function claimAndConvertFor(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for\n    ) public returns (uint256);\n}\n\n// File: solidity/contracts/utility/interfaces/IContractRegistry.sol\n\npragma solidity 0.4.26;\n\n/*\n    Contract Registry interface\n*/\ncontract IContractRegistry {\n    function addressOf(bytes32 _contractName) public view returns (address);\n\n    // deprecated, backward compatibility\n    function getAddress(bytes32 _contractName) public view returns (address);\n}\n\n// File: solidity/contracts/utility/ContractRegistryClient.sol\n\npragma solidity 0.4.26;\n\n\n\n\n/**\n  * @dev Base contract for ContractRegistry clients\n*/\ncontract ContractRegistryClient is Owned, Utils {\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\n    bytes32 internal constant CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\n    bytes32 internal constant CONVERTER_REGISTRY = \"BancorConverterRegistry\";\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\n    bytes32 internal constant BANCOR_X = \"BancorX\";\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\n    bytes32 internal constant CHAINLINK_ORACLE_WHITELIST = \"ChainlinkOracleWhitelist\";\n\n    IContractRegistry public registry;      // address of the current contract-registry\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\n\n    /**\n      * @dev verifies that the caller is mapped to the given contract name\n      *\n      * @param _contractName    contract name\n    */\n    modifier only(bytes32 _contractName) {\n        _only(_contractName);\n        _;\n    }\n\n    // error message binary size optimization\n    function _only(bytes32 _contractName) internal view {\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\n    }\n\n    /**\n      * @dev initializes a new ContractRegistryClient instance\n      *\n      * @param  _registry   address of a contract-registry contract\n    */\n    constructor(IContractRegistry _registry) internal validAddress(_registry) {\n        registry = IContractRegistry(_registry);\n        prevRegistry = IContractRegistry(_registry);\n    }\n\n    /**\n      * @dev updates to the new contract-registry\n     */\n    function updateRegistry() public {\n        // verify that this function is permitted\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\n\n        // get the new contract-registry\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\n\n        // verify that the new contract-registry is different and not zero\n        require(newRegistry != address(registry) && newRegistry != address(0), \"ERR_INVALID_REGISTRY\");\n\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\n\n        // save a backup of the current contract-registry before replacing it\n        prevRegistry = registry;\n\n        // replace the current contract-registry with the new contract-registry\n        registry = newRegistry;\n    }\n\n    /**\n      * @dev restores the previous contract-registry\n    */\n    function restoreRegistry() public ownerOnly {\n        // restore the previous contract-registry\n        registry = prevRegistry;\n    }\n\n    /**\n      * @dev restricts the permission to update the contract-registry\n      *\n      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\n    */\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\n        // change the permission to update the contract-registry\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\n    }\n\n    /**\n      * @dev returns the address associated with the given contract name\n      *\n      * @param _contractName    contract name\n      *\n      * @return contract address\n    */\n    function addressOf(bytes32 _contractName) internal view returns (address) {\n        return registry.addressOf(_contractName);\n    }\n}\n\n// File: solidity/contracts/utility/ReentrancyGuard.sol\n\npragma solidity 0.4.26;\n\n/**\n  * @dev ReentrancyGuard\n  *\n  * The contract provides protection against re-entrancy - calling a function (directly or\n  * indirectly) from within itself.\n*/\ncontract ReentrancyGuard {\n    // true while protected code is being executed, false otherwise\n    bool private locked = false;\n\n    /**\n      * @dev ensures instantiation only by sub-contracts\n    */\n    constructor() internal {}\n\n    // protects a function against reentrancy attacks\n    modifier protected() {\n        _protected();\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    // error message binary size optimization\n    function _protected() internal view {\n        require(!locked, \"ERR_REENTRANCY\");\n    }\n}\n\n// File: solidity/contracts/token/interfaces/IEtherToken.sol\n\npragma solidity 0.4.26;\n\n\n/*\n    Ether Token interface\n*/\ncontract IEtherToken is IERC20Token {\n    function deposit() public payable;\n    function withdraw(uint256 _amount) public;\n    function depositTo(address _to) public payable;\n    function withdrawTo(address _to, uint256 _amount) public;\n}\n\n// File: solidity/contracts/bancorx/interfaces/IBancorX.sol\n\npragma solidity 0.4.26;\n\n\ncontract IBancorX {\n    function token() public view returns (IERC20Token) {this;}\n    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) public;\n    function getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);\n}\n\n// File: solidity/contracts/converter/ConverterBase.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n  * @dev ConverterBase\n  *\n  * The converter contains the main logic for conversions between different ERC20 tokens.\n  *\n  * It is also the upgradable part of the mechanism (note that upgrades are opt-in).\n  *\n  * The anchor must be set on construction and cannot be changed afterwards.\n  * Wrappers are provided for some of the anchor's functions, for easier access.\n  *\n  * Once the converter accepts ownership of the anchor, it becomes the anchor's sole controller\n  * and can execute any of its functions.\n  *\n  * To upgrade the converter, anchor ownership must be transferred to a new converter, along with\n  * any relevant data.\n  *\n  * Note that the converter can transfer anchor ownership to a new converter that\n  * doesn't allow upgrades anymore, for finalizing the relationship between the converter\n  * and the anchor.\n  *\n  * Converter types (defined as uint16 type) -\n  * 0 = liquid token converter\n  * 1 = liquidity pool v1 converter\n  * 2 = liquidity pool v2 converter\n  *\n  * Note that converters don't currently support tokens with transfer fees.\n*/\ncontract ConverterBase is IConverter, TokenHandler, TokenHolder, ContractRegistryClient, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    uint32 internal constant WEIGHT_RESOLUTION = 1000000;\n    uint32 internal constant CONVERSION_FEE_RESOLUTION = 1000000;\n    address internal constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    struct Reserve {\n        uint256 balance;    // reserve balance\n        uint32 weight;      // reserve weight, represented in ppm, 1-1000000\n        bool deprecated1;   // deprecated\n        bool deprecated2;   // deprecated\n        bool isSet;         // true if the reserve is valid, false otherwise\n    }\n\n    /**\n      * @dev version number\n    */\n    uint16 public constant version = 37;\n\n    IConverterAnchor public anchor;                 // converter anchor contract\n    IWhitelist public conversionWhitelist;          // whitelist contract with list of addresses that are allowed to use the converter\n    IERC20Token[] public reserveTokens;             // ERC20 standard token addresses (prior version 17, use 'connectorTokens' instead)\n    mapping (address => Reserve) public reserves;   // reserve token addresses -> reserve data (prior version 17, use 'connectors' instead)\n    uint32 public reserveRatio = 0;                 // ratio between the reserves and the market cap, equal to the total reserve weights\n    uint32 public maxConversionFee = 0;             // maximum conversion fee for the lifetime of the contract,\n                                                    // represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\n    uint32 public conversionFee = 0;                // current conversion fee, represented in ppm, 0...maxConversionFee\n    bool public constant conversionsEnabled = true; // deprecated, backward compatibility\n\n    /**\n      * @dev triggered when the converter is activated\n      *\n      * @param _type        converter type\n      * @param _anchor      converter anchor\n      * @param _activated   true if the converter was activated, false if it was deactivated\n    */\n    event Activation(uint16 indexed _type, IConverterAnchor indexed _anchor, bool indexed _activated);\n\n    /**\n      * @dev triggered when a conversion between two tokens occurs\n      *\n      * @param _fromToken       source ERC20 token\n      * @param _toToken         target ERC20 token\n      * @param _trader          wallet that initiated the trade\n      * @param _amount          amount converted, in the source token\n      * @param _return          amount returned, minus conversion fee\n      * @param _conversionFee   conversion fee\n    */\n    event Conversion(\n        address indexed _fromToken,\n        address indexed _toToken,\n        address indexed _trader,\n        uint256 _amount,\n        uint256 _return,\n        int256 _conversionFee\n    );\n\n    /**\n      * @dev triggered when the rate between two tokens in the converter changes\n      * note that the event might be dispatched for rate updates between any two tokens in the converter\n      * note that prior to version 28, you should use the 'PriceDataUpdate' event instead\n      *\n      * @param  _token1 address of the first token\n      * @param  _token2 address of the second token\n      * @param  _rateN  rate of 1 unit of `_token1` in `_token2` (numerator)\n      * @param  _rateD  rate of 1 unit of `_token1` in `_token2` (denominator)\n    */\n    event TokenRateUpdate(\n        address indexed _token1,\n        address indexed _token2,\n        uint256 _rateN,\n        uint256 _rateD\n    );\n\n    /**\n      * @dev triggered when the conversion fee is updated\n      *\n      * @param  _prevFee    previous fee percentage, represented in ppm\n      * @param  _newFee     new fee percentage, represented in ppm\n    */\n    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\n\n    /**\n      * @dev used by sub-contracts to initialize a new converter\n      *\n      * @param  _anchor             anchor governed by the converter\n      * @param  _registry           address of a contract registry contract\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\n    */\n    constructor(\n        IConverterAnchor _anchor,\n        IContractRegistry _registry,\n        uint32 _maxConversionFee\n    )\n        validAddress(_anchor)\n        ContractRegistryClient(_registry)\n        internal\n        validConversionFee(_maxConversionFee)\n    {\n        anchor = _anchor;\n        maxConversionFee = _maxConversionFee;\n    }\n\n    // ensures that the converter is active\n    modifier active() {\n        _active();\n        _;\n    }\n\n    // error message binary size optimization\n    function _active() internal view {\n        require(isActive(), \"ERR_INACTIVE\");\n    }\n\n    // ensures that the converter is not active\n    modifier inactive() {\n        _inactive();\n        _;\n    }\n\n    // error message binary size optimization\n    function _inactive() internal view {\n        require(!isActive(), \"ERR_ACTIVE\");\n    }\n\n    // validates a reserve token address - verifies that the address belongs to one of the reserve tokens\n    modifier validReserve(IERC20Token _address) {\n        _validReserve(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validReserve(IERC20Token _address) internal view {\n        require(reserves[_address].isSet, \"ERR_INVALID_RESERVE\");\n    }\n\n    // validates conversion fee\n    modifier validConversionFee(uint32 _conversionFee) {\n        _validConversionFee(_conversionFee);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validConversionFee(uint32 _conversionFee) internal pure {\n        require(_conversionFee <= CONVERSION_FEE_RESOLUTION, \"ERR_INVALID_CONVERSION_FEE\");\n    }\n\n    // validates reserve weight\n    modifier validReserveWeight(uint32 _weight) {\n        _validReserveWeight(_weight);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validReserveWeight(uint32 _weight) internal pure {\n        require(_weight > 0 && _weight <= WEIGHT_RESOLUTION, \"ERR_INVALID_RESERVE_WEIGHT\");\n    }\n\n    /**\n      * @dev deposits ether\n      * can only be called if the converter has an ETH reserve\n    */\n    function() external payable {\n        require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_INVALID_RESERVE\"); // require(hasETHReserve(), \"ERR_INVALID_RESERVE\");\n        // a workaround for a problem when running solidity-coverage\n        // see https://github.com/sc-forks/solidity-coverage/issues/487\n    }\n\n    /**\n      * @dev withdraws ether\n      * can only be called by the owner if the converter is inactive or by upgrader contract\n      * can only be called after the upgrader contract has accepted the ownership of this contract\n      * can only be called if the converter has an ETH reserve\n      *\n      * @param _to  address to send the ETH to\n    */\n    function withdrawETH(address _to)\n        public\n        protected\n        ownerOnly\n        validReserve(IERC20Token(ETH_RESERVE_ADDRESS))\n    {\n        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\n\n        // verify that the converter is inactive or that the owner is the upgrader contract\n        require(!isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\n        _to.transfer(address(this).balance);\n\n        // sync the ETH reserve balance\n        syncReserveBalance(IERC20Token(ETH_RESERVE_ADDRESS));\n    }\n\n    /**\n      * @dev checks whether or not the converter version is 28 or higher\n      *\n      * @return true, since the converter version is 28 or higher\n    */\n    function isV28OrHigher() public pure returns (bool) {\n        return true;\n    }\n\n    /**\n      * @dev allows the owner to update & enable the conversion whitelist contract address\n      * when set, only addresses that are whitelisted are actually allowed to use the converter\n      * note that the whitelist check is actually done by the BancorNetwork contract\n      *\n      * @param _whitelist    address of a whitelist contract\n    */\n    function setConversionWhitelist(IWhitelist _whitelist)\n        public\n        ownerOnly\n        notThis(_whitelist)\n    {\n        conversionWhitelist = _whitelist;\n    }\n\n    /**\n      * @dev returns true if the converter is active, false otherwise\n      *\n      * @return true if the converter is active, false otherwise\n    */\n    function isActive() public view returns (bool) {\n        return anchor.owner() == address(this);\n    }\n\n    /**\n      * @dev transfers the anchor ownership\n      * the new owner needs to accept the transfer\n      * can only be called by the converter upgrder while the upgrader is the owner\n      * note that prior to version 28, you should use 'transferAnchorOwnership' instead\n      *\n      * @param _newOwner    new token owner\n    */\n    function transferAnchorOwnership(address _newOwner)\n        public\n        ownerOnly\n        only(CONVERTER_UPGRADER)\n    {\n        anchor.transferOwnership(_newOwner);\n    }\n\n    /**\n      * @dev accepts ownership of the anchor after an ownership transfer\n      * most converters are also activated as soon as they accept the anchor ownership\n      * can only be called by the contract owner\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\n    */\n    function acceptAnchorOwnership() public ownerOnly {\n        // verify the the converter has at least one reserve\n        require(reserveTokenCount() > 0, \"ERR_INVALID_RESERVE_COUNT\");\n        anchor.acceptOwnership();\n        syncReserveBalances();\n    }\n\n    /**\n      * @dev withdraws tokens held by the anchor and sends them to an account\n      * can only be called by the owner\n      *\n      * @param _token   ERC20 token contract address\n      * @param _to      account to receive the new amount\n      * @param _amount  amount to withdraw\n    */\n    function withdrawFromAnchor(IERC20Token _token, address _to, uint256 _amount) public ownerOnly {\n        anchor.withdrawTokens(_token, _to, _amount);\n    }\n\n    /**\n      * @dev updates the current conversion fee\n      * can only be called by the contract owner\n      *\n      * @param _conversionFee new conversion fee, represented in ppm\n    */\n    function setConversionFee(uint32 _conversionFee) public ownerOnly {\n        require(_conversionFee <= maxConversionFee, \"ERR_INVALID_CONVERSION_FEE\");\n        emit ConversionFeeUpdate(conversionFee, _conversionFee);\n        conversionFee = _conversionFee;\n    }\n\n    /**\n      * @dev withdraws tokens held by the converter and sends them to an account\n      * can only be called by the owner\n      * note that reserve tokens can only be withdrawn by the owner while the converter is inactive\n      * unless the owner is the converter upgrader contract\n      *\n      * @param _token   ERC20 token contract address\n      * @param _to      account to receive the new amount\n      * @param _amount  amount to withdraw\n    */\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public protected ownerOnly {\n        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\n\n        // if the token is not a reserve token, allow withdrawal\n        // otherwise verify that the converter is inactive or that the owner is the upgrader contract\n        require(!reserves[_token].isSet || !isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\n        super.withdrawTokens(_token, _to, _amount);\n\n        // if the token is a reserve token, sync the reserve balance\n        if (reserves[_token].isSet)\n            syncReserveBalance(_token);\n    }\n\n    /**\n      * @dev upgrades the converter to the latest version\n      * can only be called by the owner\n      * note that the owner needs to call acceptOwnership on the new converter after the upgrade\n    */\n    function upgrade() public ownerOnly {\n        IConverterUpgrader converterUpgrader = IConverterUpgrader(addressOf(CONVERTER_UPGRADER));\n\n        // trigger de-activation event\n        emit Activation(converterType(), anchor, false);\n\n        transferOwnership(converterUpgrader);\n        converterUpgrader.upgrade(version);\n        acceptOwnership();\n    }\n\n    /**\n      * @dev returns the number of reserve tokens defined\n      * note that prior to version 17, you should use 'connectorTokenCount' instead\n      *\n      * @return number of reserve tokens\n    */\n    function reserveTokenCount() public view returns (uint16) {\n        return uint16(reserveTokens.length);\n    }\n\n    /**\n      * @dev defines a new reserve token for the converter\n      * can only be called by the owner while the converter is inactive\n      *\n      * @param _token   address of the reserve token\n      * @param _weight  reserve weight, represented in ppm, 1-1000000\n    */\n    function addReserve(IERC20Token _token, uint32 _weight)\n        public\n        ownerOnly\n        inactive\n        validAddress(_token)\n        notThis(_token)\n        validReserveWeight(_weight)\n    {\n        // validate input\n        require(_token != address(anchor) && !reserves[_token].isSet, \"ERR_INVALID_RESERVE\");\n        require(_weight <= WEIGHT_RESOLUTION - reserveRatio, \"ERR_INVALID_RESERVE_WEIGHT\");\n        require(reserveTokenCount() < uint16(-1), \"ERR_INVALID_RESERVE_COUNT\");\n\n        Reserve storage newReserve = reserves[_token];\n        newReserve.balance = 0;\n        newReserve.weight = _weight;\n        newReserve.isSet = true;\n        reserveTokens.push(_token);\n        reserveRatio += _weight;\n    }\n\n    /**\n      * @dev returns the reserve's weight\n      * added in version 28\n      *\n      * @param _reserveToken    reserve token contract address\n      *\n      * @return reserve weight\n    */\n    function reserveWeight(IERC20Token _reserveToken)\n        public\n        view\n        validReserve(_reserveToken)\n        returns (uint32)\n    {\n        return reserves[_reserveToken].weight;\n    }\n\n    /**\n      * @dev returns the reserve's balance\n      * note that prior to version 17, you should use 'getConnectorBalance' instead\n      *\n      * @param _reserveToken    reserve token contract address\n      *\n      * @return reserve balance\n    */\n    function reserveBalance(IERC20Token _reserveToken)\n        public\n        view\n        validReserve(_reserveToken)\n        returns (uint256)\n    {\n        return reserves[_reserveToken].balance;\n    }\n\n    /**\n      * @dev checks whether or not the converter has an ETH reserve\n      *\n      * @return true if the converter has an ETH reserve, false otherwise\n    */\n    function hasETHReserve() public view returns (bool) {\n        return reserves[ETH_RESERVE_ADDRESS].isSet;\n    }\n\n    /**\n      * @dev converts a specific amount of source tokens to target tokens\n      * can only be called by the bancor network contract\n      *\n      * @param _sourceToken source ERC20 token\n      * @param _targetToken target ERC20 token\n      * @param _amount      amount of tokens to convert (in units of the source token)\n      * @param _trader      address of the caller who executed the conversion\n      * @param _beneficiary wallet to receive the conversion result\n      *\n      * @return amount of tokens received (in units of the target token)\n    */\n    function convert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address _beneficiary)\n        public\n        payable\n        protected\n        only(BANCOR_NETWORK)\n        returns (uint256)\n    {\n        // validate input\n        require(_sourceToken != _targetToken, \"ERR_SAME_SOURCE_TARGET\");\n\n        // if a whitelist is set, verify that both and trader and the beneficiary are whitelisted\n        require(conversionWhitelist == address(0) ||\n                (conversionWhitelist.isWhitelisted(_trader) && conversionWhitelist.isWhitelisted(_beneficiary)),\n                \"ERR_NOT_WHITELISTED\");\n\n        return doConvert(_sourceToken, _targetToken, _amount, _trader, _beneficiary);\n    }\n\n    /**\n      * @dev converts a specific amount of source tokens to target tokens\n      * called by ConverterBase and allows the inherited contracts to implement custom conversion logic\n      *\n      * @param _sourceToken source ERC20 token\n      * @param _targetToken target ERC20 token\n      * @param _amount      amount of tokens to convert (in units of the source token)\n      * @param _trader      address of the caller who executed the conversion\n      * @param _beneficiary wallet to receive the conversion result\n      *\n      * @return amount of tokens received (in units of the target token)\n    */\n    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address _beneficiary) internal returns (uint256);\n\n    /**\n      * @dev returns the conversion fee for a given target amount\n      *\n      * @param _targetAmount  target amount\n      *\n      * @return conversion fee\n    */\n    function calculateFee(uint256 _targetAmount) internal view returns (uint256) {\n        return _targetAmount.mul(conversionFee).div(CONVERSION_FEE_RESOLUTION);\n    }\n\n    /**\n      * @dev syncs the stored reserve balance for a given reserve with the real reserve balance\n      *\n      * @param _reserveToken    address of the reserve token\n    */\n    function syncReserveBalance(IERC20Token _reserveToken) internal validReserve(_reserveToken) {\n        if (_reserveToken == ETH_RESERVE_ADDRESS)\n            reserves[_reserveToken].balance = address(this).balance;\n        else\n            reserves[_reserveToken].balance = _reserveToken.balanceOf(this);\n    }\n\n    /**\n      * @dev syncs all stored reserve balances\n    */\n    function syncReserveBalances() internal {\n        uint256 reserveCount = reserveTokens.length;\n        for (uint256 i = 0; i < reserveCount; i++)\n            syncReserveBalance(reserveTokens[i]);\n    }\n\n    /**\n      * @dev helper, dispatches the Conversion event\n      *\n      * @param _sourceToken     source ERC20 token\n      * @param _targetToken     target ERC20 token\n      * @param _trader          address of the caller who executed the conversion\n      * @param _amount          amount purchased/sold (in the source token)\n      * @param _returnAmount    amount returned (in the target token)\n    */\n    function dispatchConversionEvent(\n        IERC20Token _sourceToken,\n        IERC20Token _targetToken,\n        address _trader,\n        uint256 _amount,\n        uint256 _returnAmount,\n        uint256 _feeAmount)\n        internal\n    {\n        // fee amount is converted to 255 bits -\n        // negative amount means the fee is taken from the source token, positive amount means its taken from the target token\n        // currently the fee is always taken from the target token\n        // since we convert it to a signed number, we first ensure that it's capped at 255 bits to prevent overflow\n        assert(_feeAmount < 2 ** 255);\n        emit Conversion(_sourceToken, _targetToken, _trader, _amount, _returnAmount, int256(_feeAmount));\n    }\n\n    /**\n      * @dev deprecated since version 28, backward compatibility - use only for earlier versions\n    */\n    function token() public view returns (IConverterAnchor) {\n        return anchor;\n    }\n\n    /**\n      * @dev deprecated, backward compatibility\n    */\n    function transferTokenOwnership(address _newOwner) public ownerOnly {\n        transferAnchorOwnership(_newOwner);\n    }\n\n    /**\n      * @dev deprecated, backward compatibility\n    */\n    function acceptTokenOwnership() public ownerOnly {\n        acceptAnchorOwnership();\n    }\n\n    /**\n      * @dev deprecated, backward compatibility\n    */\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) {\n        Reserve memory reserve = reserves[_address];\n        return(reserve.balance, reserve.weight, false, false, reserve.isSet);\n    }\n\n    /**\n      * @dev deprecated, backward compatibility\n    */\n    function connectorTokens(uint256 _index) public view returns (IERC20Token) {\n        return ConverterBase.reserveTokens[_index];\n    }\n\n    /**\n      * @dev deprecated, backward compatibility\n    */\n    function connectorTokenCount() public view returns (uint16) {\n        return reserveTokenCount();\n    }\n\n    /**\n      * @dev deprecated, backward compatibility\n    */\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256) {\n        return reserveBalance(_connectorToken);\n    }\n\n    /**\n      * @dev deprecated, backward compatibility\n    */\n    function getReturn(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256) {\n        return targetAmountAndFee(_sourceToken, _targetToken, _amount);\n    }\n}\n\n// File: solidity/contracts/converter/LiquidityPoolConverter.sol\n\npragma solidity 0.4.26;\n\n\n/**\n  * @dev Liquidity Pool Converter\n  *\n  * The liquidity pool converter is the base contract for specific types of converters that\n  * manage liquidity pools.\n  *\n  * Liquidity pools have 2 reserves or more and they allow converting between them.\n  *\n  * Note that TokenRateUpdate events are dispatched for pool tokens as well.\n  * The pool token is the first token in the event in that case.\n*/\ncontract LiquidityPoolConverter is ConverterBase {\n    /**\n      * @dev triggered after liquidity is added\n      *\n      * @param  _provider       liquidity provider\n      * @param  _reserveToken   reserve token address\n      * @param  _amount         reserve token amount\n      * @param  _newBalance     reserve token new balance\n      * @param  _newSupply      pool token new supply\n    */\n    event LiquidityAdded(\n        address indexed _provider,\n        address indexed _reserveToken,\n        uint256 _amount,\n        uint256 _newBalance,\n        uint256 _newSupply\n    );\n\n    /**\n      * @dev triggered after liquidity is removed\n      *\n      * @param  _provider       liquidity provider\n      * @param  _reserveToken   reserve token address\n      * @param  _amount         reserve token amount\n      * @param  _newBalance     reserve token new balance\n      * @param  _newSupply      pool token new supply\n    */\n    event LiquidityRemoved(\n        address indexed _provider,\n        address indexed _reserveToken,\n        uint256 _amount,\n        uint256 _newBalance,\n        uint256 _newSupply\n    );\n\n    /**\n      * @dev initializes a new LiquidityPoolConverter instance\n      *\n      * @param  _anchor             anchor governed by the converter\n      * @param  _registry           address of a contract registry contract\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\n    */\n    constructor(\n        IConverterAnchor _anchor,\n        IContractRegistry _registry,\n        uint32 _maxConversionFee\n    )\n        ConverterBase(_anchor, _registry, _maxConversionFee)\n        internal\n    {\n    }\n\n    /**\n      * @dev accepts ownership of the anchor after an ownership transfer\n      * also activates the converter\n      * can only be called by the contract owner\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\n    */\n    function acceptAnchorOwnership() public {\n        // verify that the converter has at least 2 reserves\n        require(reserveTokenCount() > 1, \"ERR_INVALID_RESERVE_COUNT\");\n        super.acceptAnchorOwnership();\n    }\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterFactory.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n/*\n    Converter Factory interface\n*/\ncontract IConverterFactory {\n    function createAnchor(uint16 _type, string _name, string _symbol, uint8 _decimals) public returns (IConverterAnchor);\n    function createConverter(uint16 _type, IConverterAnchor _anchor, IContractRegistry _registry, uint32 _maxConversionFee) public returns (IConverter);\n\n    function customFactories(uint16 _type) public view returns (ITypedConverterCustomFactory) { _type; this; }\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/LiquidityPoolV2Converter.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n\n/**\n  * @dev Liquidity Pool v2 Converter\n  *\n  * The liquidity pool v2 converter is a specialized version of a converter that uses\n  * price oracles to rebalance the reserve weights in such a way that the primary token\n  * balance always strives to match the staked balance.\n  *\n  * This type of liquidity pool always has 2 reserves and the reserve weights are dynamic.\n*/\ncontract LiquidityPoolV2Converter is LiquidityPoolConverter {\n    uint8 internal constant AMPLIFICATION_FACTOR = 20;  // factor to use for conversion calculations (reduces slippage)\n\n    struct Fraction {\n        uint256 n;  // numerator\n        uint256 d;  // denominator\n    }\n\n    IPriceOracle public priceOracle;                                // external price oracle\n    IERC20Token public primaryReserveToken;                         // primary reserve in the pool\n    IERC20Token public secondaryReserveToken;                       // secondary reserve in the pool (cache)\n    mapping (address => uint256) private stakedBalances;            // tracks the staked liquidity in the pool plus the fees\n    mapping (address => ISmartToken) private reservesToPoolTokens;  // maps each reserve to its pool token\n    mapping (address => IERC20Token) private poolTokensToReserves;  // maps each pool token to its reserve\n\n    bool public referenceRateEnabled = true;    // reference rate enable / disable flag\n    Fraction public referenceRate;              // reference rate from the previous block(s) of 1 primary token in secondary tokens\n    uint256 public referenceRateUpdateTime;     // last time when the reference rate was updated (in seconds)\n\n    Fraction public lastConversionRate;         // last conversion rate of 1 primary token in secondary tokens\n\n    // used by the temp liquidity limit mechanism during the pilot\n    mapping (address => uint256) public maxStakedBalances;\n    bool public maxStakedBalanceEnabled = true;\n\n    uint256 public dynamicFeeFactor = 0; // initial dynamic fee factor is 0%, represented in ppm\n    uint256 public weightSpreadFactor = 20000; // initial weight spread factor is 2%, represented in ppm\n    uint256 public ratePropagationPeriod = 600 seconds; // initial time until the last rate takes full effect, represented in seconds\n\n    /**\n      * @dev triggered when the reference rate is enabled or disabled\n      *\n      * @param  _newState   true if enabled, false if disabled\n    */\n    event ReferenceRateEnabled(bool _newState);\n\n    /**\n      * @dev triggered when the dynamic fee factor is updated\n      *\n      * @param  _prevFactor    previous factor percentage, represented in ppm\n      * @param  _newFactor     new factor percentage, represented in ppm\n    */\n    event DynamicFeeFactorUpdate(uint256 _prevFactor, uint256 _newFactor);\n\n    /**\n      * @dev triggered when the weight spread factor is updated\n      *\n      * @param  _prevFactor    previous factor percentage, represented in ppm\n      * @param  _newFactor     new factor percentage, represented in ppm\n    */\n    event WeightSpreadFactorUpdate(uint256 _prevFactor, uint256 _newFactor);\n\n    /**\n      * @dev triggered when the rate propagation period is updated\n      *\n      * @param  _prevPeriod    previous time period, represented in seconds\n      * @param  _newPeriod     new time period, represented in seconds\n    */\n    event RatePropagationPeriodUpdate(uint256 _prevPeriod, uint256 _newPeriod);\n\n    /**\n      * @dev initializes a new LiquidityPoolV2Converter instance\n      *\n      * @param  _poolTokensContainer    pool tokens container governed by the converter\n      * @param  _registry               address of a contract registry contract\n      * @param  _maxConversionFee       maximum conversion fee, represented in ppm\n    */\n    constructor(IPoolTokensContainer _poolTokensContainer, IContractRegistry _registry, uint32 _maxConversionFee)\n        public LiquidityPoolConverter(_poolTokensContainer, _registry, _maxConversionFee)\n    {\n    }\n\n    // ensures the address is a pool token\n    modifier validPoolToken(ISmartToken _address) {\n        _validPoolToken(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validPoolToken(ISmartToken _address) internal view {\n        require(poolTokensToReserves[_address] != address(0), \"ERR_INVALID_POOL_TOKEN\");\n    }\n\n    /**\n      * @dev returns the converter type\n      *\n      * @return see the converter types in the the main contract doc\n    */\n    function converterType() public pure returns (uint16) {\n        return 2;\n    }\n\n    /**\n      * @dev returns true if the converter is active, false otherwise\n      *\n      * @return true if the converter is active, false otherwise\n    */\n    function isActive() public view returns (bool) {\n        return super.isActive() && priceOracle != address(0);\n    }\n\n    /**\n      * @dev returns the liquidity amplification factor in the pool\n      *\n      * @return liquidity amplification factor\n    */\n    function amplificationFactor() public pure returns (uint8) {\n        return AMPLIFICATION_FACTOR;\n    }\n\n    /**\n      * @dev sets the pool's primary reserve token / price oracles and activates the pool\n      * each oracle must be able to provide the rate for each reserve token\n      * note that the oracle must be whitelisted prior to the call\n      * can only be called by the owner while the pool is inactive\n      *\n      * @param _primaryReserveToken     address of the pool's primary reserve token\n      * @param _primaryReserveOracle    address of a chainlink price oracle for the primary reserve token\n      * @param _secondaryReserveOracle  address of a chainlink price oracle for the secondary reserve token\n    */\n    function activate(IERC20Token _primaryReserveToken, IChainlinkPriceOracle _primaryReserveOracle, IChainlinkPriceOracle _secondaryReserveOracle)\n        public\n        inactive\n        ownerOnly\n        validReserve(_primaryReserveToken)\n        notThis(_primaryReserveOracle)\n        notThis(_secondaryReserveOracle)\n        validAddress(_primaryReserveOracle)\n        validAddress(_secondaryReserveOracle)\n    {\n        // validate anchor ownership\n        require(anchor.owner() == address(this), \"ERR_ANCHOR_NOT_OWNED\");\n\n        // validate oracles\n        IWhitelist oracleWhitelist = IWhitelist(addressOf(CHAINLINK_ORACLE_WHITELIST));\n        require(oracleWhitelist.isWhitelisted(_primaryReserveOracle), \"ERR_INVALID_ORACLE\");\n        require(oracleWhitelist.isWhitelisted(_secondaryReserveOracle), \"ERR_INVALID_ORACLE\");\n\n        // create the converter's pool tokens if they don't already exist\n        createPoolTokens();\n\n        // sets the primary & secondary reserve tokens\n        primaryReserveToken = _primaryReserveToken;\n        if (_primaryReserveToken == reserveTokens[0])\n            secondaryReserveToken = reserveTokens[1];\n        else\n            secondaryReserveToken = reserveTokens[0];\n\n        // creates and initalizes the price oracle and sets initial rates\n        LiquidityPoolV2ConverterCustomFactory customFactory =\n            LiquidityPoolV2ConverterCustomFactory(IConverterFactory(addressOf(CONVERTER_FACTORY)).customFactories(converterType()));\n        priceOracle = customFactory.createPriceOracle(_primaryReserveToken, secondaryReserveToken, _primaryReserveOracle, _secondaryReserveOracle);\n\n        (referenceRate.n, referenceRate.d) = priceOracle.latestRate(primaryReserveToken, secondaryReserveToken);\n        lastConversionRate = referenceRate;\n\n        referenceRateUpdateTime = time();\n\n        // if we are upgrading from an older converter, make sure that reserve balances are in-sync and rebalance\n        uint256 primaryReserveStakedBalance = reserveStakedBalance(primaryReserveToken);\n        uint256 primaryReserveBalance = reserveBalance(primaryReserveToken);\n        uint256 secondaryReserveBalance = reserveBalance(secondaryReserveToken);\n\n        if (primaryReserveStakedBalance == primaryReserveBalance) {\n            if (primaryReserveStakedBalance > 0 || secondaryReserveBalance > 0) {\n                rebalance();\n            }\n        }\n        else if (primaryReserveStakedBalance > 0 && primaryReserveBalance > 0 && secondaryReserveBalance > 0) {\n            rebalance();\n        }\n\n        emit Activation(converterType(), anchor, true);\n    }\n\n    /**\n      * @dev enables or disables the reference rate\n      * can only be called by the contract owner\n      *\n      * @param _referenceRateEnabled    true for enabling, false for disabling\n    */\n    function setReferenceRateEnabled(bool _referenceRateEnabled) public ownerOnly {\n        emit ReferenceRateEnabled(_referenceRateEnabled);\n        referenceRateEnabled = _referenceRateEnabled;\n    }\n\n    /**\n      * @dev updates the current dynamic fee factor\n      * can only be called by the contract owner\n      *\n      * @param _dynamicFeeFactor new dynamic fee factor, represented in ppm\n    */\n    function setDynamicFeeFactor(uint256 _dynamicFeeFactor) public ownerOnly {\n        require(_dynamicFeeFactor <= CONVERSION_FEE_RESOLUTION, \"ERR_INVALID_DYNAMIC_FEE_FACTOR\");\n        emit DynamicFeeFactorUpdate(dynamicFeeFactor, _dynamicFeeFactor);\n        dynamicFeeFactor = _dynamicFeeFactor;\n    }\n\n    /**\n      * @dev updates the current weight spread factor\n      * can only be called by the contract owner\n      *\n      * @param _weightSpreadFactor new weight spread factor, represented in ppm\n    */\n    function setWeightSpreadFactor(uint256 _weightSpreadFactor) public ownerOnly {\n        require(_weightSpreadFactor <= CONVERSION_FEE_RESOLUTION, \"ERR_INVALID_WEIGHT_SPREAD_FACTOR\");\n        emit WeightSpreadFactorUpdate(weightSpreadFactor, _weightSpreadFactor);\n        weightSpreadFactor = _weightSpreadFactor;\n    }\n\n    /**\n      * @dev updates the current rate propagation period\n      * can only be called by the contract owner\n      *\n      * @param _ratePropagationPeriod new rate propagation period, represented in seconds\n    */\n    function setRatePropagationPeriod(uint256 _ratePropagationPeriod) public ownerOnly {\n        emit RatePropagationPeriodUpdate(ratePropagationPeriod, _ratePropagationPeriod);\n        ratePropagationPeriod = _ratePropagationPeriod;\n    }\n\n    /**\n      * @dev updates the current dynamic fee factor, the current weight spread factor and the current rate propagation period\n      * can only be called by the contract owner\n      *\n      * @param _dynamicFeeFactor new dynamic fee factor, represented in ppm\n      * @param _weightSpreadFactor new weight spread factor, represented in ppm\n      * @param _ratePropagationPeriod new rate propagation period, represented in seconds\n    */\n    function customizeAll(uint256 _dynamicFeeFactor, uint256 _weightSpreadFactor, uint256 _ratePropagationPeriod) public ownerOnly {\n        if (_dynamicFeeFactor != dynamicFeeFactor)\n            setDynamicFeeFactor(_dynamicFeeFactor);\n        if (_weightSpreadFactor != weightSpreadFactor)\n            setWeightSpreadFactor(_weightSpreadFactor);\n        if (_ratePropagationPeriod != ratePropagationPeriod)\n            setRatePropagationPeriod(_ratePropagationPeriod);\n    }\n\n    /**\n      * @dev returns the staked balance of a given reserve token\n      *\n      * @param _reserveToken    reserve token address\n      *\n      * @return staked balance\n    */\n    function reserveStakedBalance(IERC20Token _reserveToken)\n        public\n        view\n        validReserve(_reserveToken)\n        returns (uint256)\n    {\n        return stakedBalances[_reserveToken];\n    }\n\n    /**\n      * @dev returns the amplified balance of a given reserve token\n      *\n      * @param _reserveToken   reserve token address\n      *\n      * @return amplified balance\n    */\n    function reserveAmplifiedBalance(IERC20Token _reserveToken)\n        public\n        view\n        validReserve(_reserveToken)\n        returns (uint256)\n    {\n        return stakedBalances[_reserveToken].mul(AMPLIFICATION_FACTOR - 1).add(reserveBalance(_reserveToken));\n    }\n\n    /**\n      * @dev sets the reserve's staked balance\n      * can only be called by the upgrader contract while the upgrader is the owner\n      *\n      * @param _reserveToken    reserve token address\n      * @param _balance         new reserve staked balance\n    */\n    function setReserveStakedBalance(IERC20Token _reserveToken, uint256 _balance)\n        public\n        ownerOnly\n        only(CONVERTER_UPGRADER)\n        validReserve(_reserveToken)\n    {\n        stakedBalances[_reserveToken] = _balance;\n    }\n\n    /**\n      * @dev sets the max staked balance for both reserves\n      * available as a temporary mechanism during the pilot\n      * can only be called by the owner\n      *\n      * @param _reserve1MaxStakedBalance    max staked balance for reserve 1\n      * @param _reserve2MaxStakedBalance    max staked balance for reserve 2\n    */\n    function setMaxStakedBalances(uint256 _reserve1MaxStakedBalance, uint256 _reserve2MaxStakedBalance) public ownerOnly {\n        maxStakedBalances[reserveTokens[0]] = _reserve1MaxStakedBalance;\n        maxStakedBalances[reserveTokens[1]] = _reserve2MaxStakedBalance;\n    }\n\n    /**\n      * @dev disables the max staked balance mechanism\n      * available as a temporary mechanism during the pilot\n      * once disabled, it cannot be re-enabled\n      * can only be called by the owner\n    */\n    function disableMaxStakedBalances() public ownerOnly {\n        maxStakedBalanceEnabled = false;\n    }\n\n    /**\n      * @dev returns the pool token address by the reserve token address\n      *\n      * @param _reserveToken    reserve token address\n      *\n      * @return pool token address\n    */\n    function poolToken(IERC20Token _reserveToken) public view returns (ISmartToken) {\n        return reservesToPoolTokens[_reserveToken];\n    }\n\n    /**\n      * @dev returns the maximum number of pool tokens that can currently be liquidated\n      *\n      * @param _poolToken   address of the pool token\n      *\n      * @return liquidation limit\n    */\n    function liquidationLimit(ISmartToken _poolToken) public view returns (uint256) {\n        // get the pool token supply\n        uint256 poolTokenSupply = _poolToken.totalSupply();\n\n        // get the reserve token associated with the pool token and its balance / staked balance\n        IERC20Token reserveToken = poolTokensToReserves[_poolToken];\n        uint256 balance = reserveBalance(reserveToken);\n        uint256 stakedBalance = stakedBalances[reserveToken];\n\n        // calculate the amount that's available for liquidation\n        return balance.mul(poolTokenSupply).div(stakedBalance);\n    }\n\n    /**\n      * @dev defines a new reserve token for the converter\n      * can only be called by the owner while the converter is inactive and\n      * 2 reserves aren't defined yet\n      *\n      * @param _token   address of the reserve token\n      * @param _weight  reserve weight, represented in ppm, 1-1000000\n    */\n    function addReserve(IERC20Token _token, uint32 _weight) public {\n        // verify that the converter doesn't have 2 reserves yet\n        require(reserveTokenCount() < 2, \"ERR_INVALID_RESERVE_COUNT\");\n        super.addReserve(_token, _weight);\n    }\n\n    /**\n      * @dev returns the effective rate of 1 primary token in secondary tokens\n      *\n      * @return rate of 1 primary token in secondary tokens (numerator)\n      * @return rate of 1 primary token in secondary tokens (denominator)\n    */\n    function effectiveTokensRate() public view returns (uint256, uint256) {\n        Fraction memory rate = _effectiveTokensRate();\n        return (rate.n, rate.d);\n    }\n\n    /**\n      * @dev returns the effective reserve tokens weights\n      *\n      * @return reserve1 weight\n      * @return reserve2 weight\n    */\n    function effectiveReserveWeights() public view returns (uint256, uint256) {\n        Fraction memory rate = _effectiveTokensRate();\n        (uint32 primaryReserveWeight, uint32 secondaryReserveWeight) = effectiveReserveWeights(rate);\n\n        if (primaryReserveToken == reserveTokens[0]) {\n            return (primaryReserveWeight, secondaryReserveWeight);\n        }\n\n        return (secondaryReserveWeight, primaryReserveWeight);\n    }\n\n    /**\n      * @dev returns the expected target amount of converting one reserve to another along with the fee\n      *\n      * @param _sourceToken contract address of the source reserve token\n      * @param _targetToken contract address of the target reserve token\n      * @param _amount      amount of tokens received from the user\n      *\n      * @return expected target amount\n      * @return expected fee\n    */\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount)\n        public\n        view\n        active\n        returns (uint256, uint256)\n    {\n        // validate input\n        // not using the `validReserve` modifier to circumvent `stack too deep` compiler error\n        _validReserve(_sourceToken);\n        _validReserve(_targetToken);\n        require(_sourceToken != _targetToken, \"ERR_SAME_SOURCE_TARGET\");\n\n        // check if rebalance is required (some of this code is duplicated for gas optimization)\n        uint32 sourceTokenWeight;\n        uint32 targetTokenWeight;\n\n        // if the rate was already checked in this block, use the current weights.\n        // otherwise, get the new weights\n        Fraction memory rate;\n        if (referenceRateUpdateTime == time()) {\n            rate = referenceRate;\n            sourceTokenWeight = reserves[_sourceToken].weight;\n            targetTokenWeight = reserves[_targetToken].weight;\n        }\n        else {\n            // get the new rate / reserve weights\n            rate = _effectiveTokensRate();\n            (uint32 primaryReserveWeight, uint32 secondaryReserveWeight) = effectiveReserveWeights(rate);\n\n            if (_sourceToken == primaryReserveToken) {\n                sourceTokenWeight = primaryReserveWeight;\n                targetTokenWeight = secondaryReserveWeight;\n            }\n            else {\n                sourceTokenWeight = secondaryReserveWeight;\n                targetTokenWeight = primaryReserveWeight;\n            }\n        }\n\n        // return the target amount and the conversion fee using the updated reserve weights\n        (uint256 targetAmount, , uint256 fee) = targetAmountAndFees(_sourceToken, _targetToken, sourceTokenWeight, targetTokenWeight, rate, _amount);\n        return (targetAmount, fee);\n    }\n\n    /**\n      * @dev converts a specific amount of source tokens to target tokens\n      * can only be called by the bancor network contract\n      *\n      * @param _sourceToken source ERC20 token\n      * @param _targetToken target ERC20 token\n      * @param _amount      amount of tokens to convert (in units of the source token)\n      * @param _trader      address of the caller who executed the conversion\n      * @param _beneficiary wallet to receive the conversion result\n      *\n      * @return amount of tokens received (in units of the target token)\n    */\n    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address _beneficiary)\n        internal\n        active\n        validReserve(_sourceToken)\n        validReserve(_targetToken)\n        returns (uint256)\n    {\n        // convert the amount and return the resulted amount and fee\n        (uint256 amount, uint256 fee) = doConvert(_sourceToken, _targetToken, _amount);\n\n        // transfer funds to the beneficiary in the to reserve token\n        if (_targetToken == ETH_RESERVE_ADDRESS) {\n            _beneficiary.transfer(amount);\n        }\n        else {\n            safeTransfer(_targetToken, _beneficiary, amount);\n        }\n\n        // dispatch the conversion event\n        dispatchConversionEvent(_sourceToken, _targetToken, _trader, _amount, amount, fee);\n\n        // dispatch rate updates for the pool / reserve tokens\n        dispatchRateEvents(_sourceToken, _targetToken, reserves[_sourceToken].weight, reserves[_targetToken].weight);\n\n        // return the conversion result amount\n        return amount;\n    }\n\n    /**\n      * @dev converts a specific amount of source tokens to target tokens\n      * can only be called by the bancor network contract\n      *\n      * @param _sourceToken source ERC20 token\n      * @param _targetToken target ERC20 token\n      * @param _amount      amount of tokens to convert (in units of the source token)\n      *\n      * @return amount of tokens received (in units of the target token)\n      * @return expected fee\n    */\n    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) private returns (uint256, uint256) {\n        // check if the rate has changed and rebalance the pool if needed (once in a block)\n        (bool rateUpdated, Fraction memory rate) = handleRateChange();\n\n        // get expected target amount and fees\n        (uint256 amount, uint256 standardFee, uint256 dynamicFee) = targetAmountAndFees(_sourceToken, _targetToken, 0, 0, rate, _amount);\n\n        // ensure that the trade gives something in return\n        require(amount != 0, \"ERR_ZERO_TARGET_AMOUNT\");\n\n        // ensure that the trade won't deplete the reserve balance\n        uint256 targetReserveBalance = reserveBalance(_targetToken);\n        require(amount < targetReserveBalance, \"ERR_TARGET_AMOUNT_TOO_HIGH\");\n\n        // ensure that the input amount was already deposited\n        if (_sourceToken == ETH_RESERVE_ADDRESS)\n            require(msg.value == _amount, \"ERR_ETH_AMOUNT_MISMATCH\");\n        else\n            require(msg.value == 0 && _sourceToken.balanceOf(this).sub(reserveBalance(_sourceToken)) >= _amount, \"ERR_INVALID_AMOUNT\");\n\n        // sync the reserve balances\n        syncReserveBalance(_sourceToken);\n        reserves[_targetToken].balance = targetReserveBalance.sub(amount);\n\n        // update the target staked balance with the fee\n        stakedBalances[_targetToken] = stakedBalances[_targetToken].add(standardFee);\n\n        // update the last conversion rate\n        if (rateUpdated) {\n            lastConversionRate = tokensRate(primaryReserveToken, secondaryReserveToken, 0, 0);\n        }\n\n        return (amount, dynamicFee);\n    }\n\n    /**\n      * @dev increases the pool's liquidity and mints new shares in the pool to the caller\n      *\n      * @param _reserveToken    address of the reserve token to add liquidity to\n      * @param _amount          amount of liquidity to add\n      * @param _minReturn       minimum return-amount of pool tokens\n      *\n      * @return amount of pool tokens minted\n    */\n    function addLiquidity(IERC20Token _reserveToken, uint256 _amount, uint256 _minReturn)\n        public\n        payable\n        protected\n        active\n        validReserve(_reserveToken)\n        greaterThanZero(_amount)\n        greaterThanZero(_minReturn)\n        returns (uint256)\n    {\n        // verify that msg.value is identical to the provided amount for ETH reserve, or 0 otherwise\n        require(_reserveToken == ETH_RESERVE_ADDRESS ? msg.value == _amount : msg.value == 0, \"ERR_ETH_AMOUNT_MISMATCH\");\n\n        // sync the reserve balances just in case\n        syncReserveBalances();\n\n        // for ETH reserve, deduct the amount that was just synced (since it's already in the converter)\n        if (_reserveToken == ETH_RESERVE_ADDRESS)\n            reserves[ETH_RESERVE_ADDRESS].balance = reserves[ETH_RESERVE_ADDRESS].balance.sub(msg.value);\n\n        // get the reserve staked balance before adding the liquidity to it\n        uint256 initialStakedBalance = stakedBalances[_reserveToken];\n\n        // during the pilot, ensure that the new staked balance isn't greater than the max limit\n        if (maxStakedBalanceEnabled) {\n            require(maxStakedBalances[_reserveToken] == 0 || initialStakedBalance.add(_amount) <= maxStakedBalances[_reserveToken], \"ERR_MAX_STAKED_BALANCE_REACHED\");\n        }\n\n        // get the pool token associated with the reserve and its supply\n        ISmartToken reservePoolToken = reservesToPoolTokens[_reserveToken];\n        uint256 poolTokenSupply = reservePoolToken.totalSupply();\n\n        // for non ETH reserve, transfer the funds from the user to the pool\n        if (_reserveToken != ETH_RESERVE_ADDRESS)\n            safeTransferFrom(_reserveToken, msg.sender, this, _amount);\n\n        // sync the reserve balance / staked balance\n        reserves[_reserveToken].balance = reserves[_reserveToken].balance.add(_amount);\n        stakedBalances[_reserveToken] = initialStakedBalance.add(_amount);\n\n        // calculate how many pool tokens to mint\n        // for an empty pool, the price is 1:1, otherwise the price is based on the ratio\n        // between the pool token supply and the staked balance\n        uint256 poolTokenAmount = 0;\n        if (initialStakedBalance == 0 || poolTokenSupply == 0)\n            poolTokenAmount = _amount;\n        else\n            poolTokenAmount = _amount.mul(poolTokenSupply).div(initialStakedBalance);\n        require(poolTokenAmount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\n\n        // mint new pool tokens to the caller\n        IPoolTokensContainer(anchor).mint(reservePoolToken, msg.sender, poolTokenAmount);\n\n        // rebalance the pool's reserve weights\n        rebalance();\n\n        // dispatch the LiquidityAdded event\n        emit LiquidityAdded(msg.sender, _reserveToken, _amount, initialStakedBalance.add(_amount), poolTokenSupply.add(poolTokenAmount));\n\n        // dispatch the `TokenRateUpdate` event for the pool token\n        dispatchPoolTokenRateUpdateEvent(reservePoolToken, poolTokenSupply.add(poolTokenAmount), _reserveToken);\n\n        // dispatch the `TokenRateUpdate` event for the reserve tokens\n        dispatchTokenRateUpdateEvent(reserveTokens[0], reserveTokens[1], 0, 0);\n\n        // return the amount of pool tokens minted\n        return poolTokenAmount;\n    }\n\n    /**\n      * @dev decreases the pool's liquidity and burns the caller's shares in the pool\n      *\n      * @param _poolToken   address of the pool token\n      * @param _amount      amount of pool tokens to burn\n      * @param _minReturn   minimum return-amount of reserve tokens\n      *\n      * @return amount of liquidity removed\n    */\n    function removeLiquidity(ISmartToken _poolToken, uint256 _amount, uint256 _minReturn)\n        public\n        protected\n        active\n        validPoolToken(_poolToken)\n        greaterThanZero(_amount)\n        greaterThanZero(_minReturn)\n        returns (uint256)\n    {\n        // sync the reserve balances just in case\n        syncReserveBalances();\n\n        // get the pool token supply before burning the caller's shares\n        uint256 initialPoolSupply = _poolToken.totalSupply();\n\n        // get the reserve token return before burning the caller's shares\n        (uint256 reserveAmount, ) = removeLiquidityReturnAndFee(_poolToken, _amount);\n        require(reserveAmount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\n\n        // get the reserve token associated with the pool token\n        IERC20Token reserveToken = poolTokensToReserves[_poolToken];\n\n        // burn the caller's pool tokens\n        IPoolTokensContainer(anchor).burn(_poolToken, msg.sender, _amount);\n\n        // sync the reserve balance / staked balance\n        reserves[reserveToken].balance = reserves[reserveToken].balance.sub(reserveAmount);\n        uint256 newStakedBalance = stakedBalances[reserveToken].sub(reserveAmount);\n        stakedBalances[reserveToken] = newStakedBalance;\n\n        // transfer the reserve amount to the caller\n        if (reserveToken == ETH_RESERVE_ADDRESS)\n            msg.sender.transfer(reserveAmount);\n        else\n            safeTransfer(reserveToken, msg.sender, reserveAmount);\n\n        // rebalance the pool's reserve weights\n        rebalance();\n\n        uint256 newPoolTokenSupply = initialPoolSupply.sub(_amount);\n\n        // dispatch the LiquidityRemoved event\n        emit LiquidityRemoved(msg.sender, reserveToken, reserveAmount, newStakedBalance, newPoolTokenSupply);\n\n        // dispatch the `TokenRateUpdate` event for the pool token\n        dispatchPoolTokenRateUpdateEvent(_poolToken, newPoolTokenSupply, reserveToken);\n\n        // dispatch the `TokenRateUpdate` event for the reserve tokens\n        dispatchTokenRateUpdateEvent(reserveTokens[0], reserveTokens[1], 0, 0);\n\n        // return the amount of liquidity removed\n        return reserveAmount;\n    }\n\n    /**\n      * @dev calculates the amount of reserve tokens entitled for a given amount of pool tokens\n      * note that a fee is applied according to the equilibrium level of the primary reserve token\n      *\n      * @param _poolToken   address of the pool token\n      * @param _amount      amount of pool tokens\n      *\n      * @return amount after fee and fee, in reserve token units\n    */\n    function removeLiquidityReturnAndFee(ISmartToken _poolToken, uint256 _amount)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        uint256 totalSupply = _poolToken.totalSupply();\n        uint256 stakedBalance = stakedBalances[poolTokensToReserves[_poolToken]];\n\n        if (_amount < totalSupply) {\n            uint256 x = stakedBalances[primaryReserveToken].mul(AMPLIFICATION_FACTOR);\n            uint256 y = reserveAmplifiedBalance(primaryReserveToken);\n            (uint256 min, uint256 max) = x < y ? (x, y) : (y, x);\n            uint256 amountBeforeFee = _amount.mul(stakedBalance).div(totalSupply);\n            uint256 amountAfterFee = amountBeforeFee.mul(min).div(max);\n            return (amountAfterFee, amountBeforeFee - amountAfterFee);\n        }\n        return (stakedBalance, 0);\n    }\n\n    /**\n      * @dev returns the expected target amount of converting one reserve to another along with the fees\n      * this version of the function expects the reserve weights as an input (gas optimization)\n      *\n      * @param _sourceToken     contract address of the source reserve token\n      * @param _targetToken     contract address of the target reserve token\n      * @param _sourceWeight    source reserve token weight or 0 to read it from storage\n      * @param _targetWeight    target reserve token weight or 0 to read it from storage\n      * @param _rate            rate between the reserve tokens\n      * @param _amount          amount of tokens received from the user\n      *\n      * @return expected target amount\n      * @return expected standard conversion fee\n      * @return expected dynamic conversion fee\n    */\n    function targetAmountAndFees(\n        IERC20Token _sourceToken,\n        IERC20Token _targetToken,\n        uint32 _sourceWeight,\n        uint32 _targetWeight,\n        Fraction memory _rate,\n        uint256 _amount)\n        private\n        view\n        returns (uint256 targetAmount, uint256 standardFee, uint256 dynamicFee)\n    {\n        if (_sourceWeight == 0)\n            _sourceWeight = reserves[_sourceToken].weight;\n        if (_targetWeight == 0)\n            _targetWeight = reserves[_targetToken].weight;\n\n        // get the tokens amplified balances\n        uint256 sourceBalance = reserveAmplifiedBalance(_sourceToken);\n        uint256 targetBalance = reserveAmplifiedBalance(_targetToken);\n\n        // get the weight spread\n        uint32 weightSpread = uint32(uint256(_sourceWeight) * weightSpreadFactor / CONVERSION_FEE_RESOLUTION);\n\n        // get the target amount\n        targetAmount = IBancorFormula(addressOf(BANCOR_FORMULA)).crossReserveTargetAmount(\n            sourceBalance,\n            _sourceWeight - weightSpread,\n            targetBalance,\n            _targetWeight + weightSpread,\n            _amount\n        );\n\n        // return a tuple of [target amount minus dynamic conversion fee, standard conversion fee, dynamic conversion fee]\n        standardFee = calculateFee(targetAmount);\n        dynamicFee = calculateDynamicFee(_targetToken, _sourceWeight, _targetWeight, _rate, targetAmount).add(standardFee);\n        targetAmount = targetAmount.sub(dynamicFee);\n    }\n\n    /**\n      * @dev returns the dynamic fee for a given target amount\n      *\n      * @param _targetToken     contract address of the target reserve token\n      * @param _sourceWeight    source reserve token weight\n      * @param _targetWeight    target reserve token weight\n      * @param _rate            rate of 1 primary token in secondary tokens\n      * @param _targetAmount    target amount\n      *\n      * @return dynamic fee\n    */\n    function calculateDynamicFee(\n        IERC20Token _targetToken,\n        uint32 _sourceWeight,\n        uint32 _targetWeight,\n        Fraction memory _rate,\n        uint256 _targetAmount)\n        internal view returns (uint256)\n    {\n        uint256 fee;\n\n        if (_targetToken == secondaryReserveToken) {\n            fee = calculateFeeToEquilibrium(\n                stakedBalances[primaryReserveToken],\n                stakedBalances[secondaryReserveToken],\n                _sourceWeight,\n                _targetWeight,\n                _rate.n,\n                _rate.d,\n                dynamicFeeFactor);\n        }\n        else {\n            fee = calculateFeeToEquilibrium(\n                stakedBalances[primaryReserveToken],\n                stakedBalances[secondaryReserveToken],\n                _targetWeight,\n                _sourceWeight,\n                _rate.n,\n                _rate.d,\n                dynamicFeeFactor);\n        }\n\n        return _targetAmount.mul(fee).div(CONVERSION_FEE_RESOLUTION);\n    }\n\n    /**\n      * @dev returns the relative fee required for mitigating the secondary reserve distance from equilibrium\n      *\n      * @param _primaryReserveStaked    primary reserve staked balance\n      * @param _secondaryReserveStaked  secondary reserve staked balance\n      * @param _primaryReserveWeight    primary reserve weight\n      * @param _secondaryReserveWeight  secondary reserve weight\n      * @param _primaryReserveRate      primary reserve rate\n      * @param _secondaryReserveRate    secondary reserve rate\n      * @param _dynamicFeeFactor        dynamic fee factor\n      *\n      * @return relative fee, represented in ppm\n    */\n    function calculateFeeToEquilibrium(\n        uint256 _primaryReserveStaked,\n        uint256 _secondaryReserveStaked,\n        uint256 _primaryReserveWeight,\n        uint256 _secondaryReserveWeight,\n        uint256 _primaryReserveRate,\n        uint256 _secondaryReserveRate,\n        uint256 _dynamicFeeFactor)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 x = _primaryReserveStaked.mul(_primaryReserveRate).mul(_secondaryReserveWeight);\n        uint256 y = _secondaryReserveStaked.mul(_secondaryReserveRate).mul(_primaryReserveWeight);\n        if (y > x)\n            return (y - x).mul(_dynamicFeeFactor).mul(AMPLIFICATION_FACTOR).div(y);\n        return 0;\n    }\n\n    /**\n      * @dev creates the converter's pool tokens\n      * note that technically pool tokens can be created on deployment but gas limit\n      * might get too high for a block, so creating them on first activation\n      *\n    */\n    function createPoolTokens() internal {\n        IPoolTokensContainer container = IPoolTokensContainer(anchor);\n        ISmartToken[] memory poolTokens = container.poolTokens();\n        bool initialSetup = poolTokens.length == 0;\n\n        uint256 reserveCount = reserveTokens.length;\n        for (uint256 i = 0; i < reserveCount; i++) {\n            ISmartToken reservePoolToken;\n            if (initialSetup) {\n                reservePoolToken = container.createToken();\n            }\n            else {\n                reservePoolToken = poolTokens[i];\n            }\n\n            // cache the pool token address (gas optimization)\n            reservesToPoolTokens[reserveTokens[i]] = reservePoolToken;\n            poolTokensToReserves[reservePoolToken] = reserveTokens[i];\n        }\n    }\n\n    /**\n      * @dev returns the effective rate between the two reserve tokens\n      *\n      * @return rate\n    */\n    function _effectiveTokensRate() private view returns (Fraction memory) {\n        // get the external rate between the reserves\n        (uint256 externalRateN, uint256 externalRateD, uint256 updateTime) = priceOracle.latestRateAndUpdateTime(primaryReserveToken, secondaryReserveToken);\n\n        // if the reference rate is not enabled or the external rate was recently updated - prefer it over the internal rate\n        if (!referenceRateEnabled || updateTime > referenceRateUpdateTime) {\n            return Fraction({ n: externalRateN, d: externalRateD });\n        }\n\n        // get the elapsed time between the current and the last conversion\n        uint256 timeElapsed = time() - referenceRateUpdateTime;\n\n        // if both of the conversions are in the same block - use the reference rate\n        if (timeElapsed == 0) {\n            return referenceRate;\n        }\n\n        // given N as the sampling window, the new internal rate is calculated according to the following formula:\n        //   newRate = referenceRate + timeElapsed * [lastConversionRate - referenceRate] / N\n\n        // if a long period of time, since the last update, has passed - the last rate should fully take effect\n        if (timeElapsed >= ratePropagationPeriod) {\n            return lastConversionRate;\n        }\n\n        // calculate the numerator and the denumerator of the new rate\n        Fraction memory ref = referenceRate;\n        Fraction memory last = lastConversionRate;\n\n        uint256 x = ref.d.mul(last.n);\n        uint256 y = ref.n.mul(last.d);\n\n        // since we know that timeElapsed < ratePropagationPeriod, we can avoid using SafeMath:\n        uint256 newRateN = y.mul(ratePropagationPeriod - timeElapsed).add(x.mul(timeElapsed));\n        uint256 newRateD = ref.d.mul(last.d).mul(ratePropagationPeriod);\n\n        return reduceRate(newRateN, newRateD);\n    }\n\n    /**\n      * @dev checks if the rate has changed and if so, rebalances the weights\n      * note that rebalancing based on rate change only happens once per block\n      *\n      * @return whether the rate was updated\n      * @return rate between the reserve tokens\n    */\n    function handleRateChange() private returns (bool, Fraction memory) {\n        uint256 currentTime = time();\n\n        // avoid updating the rate more than once per block\n        if (referenceRateUpdateTime == currentTime) {\n            return (false, referenceRate);\n        }\n\n        // get and store the effective rate between the reserves\n        Fraction memory newRate = _effectiveTokensRate();\n\n        // if the rate has changed, update it and rebalance the pool\n        Fraction memory ref = referenceRate;\n        if (newRate.n == ref.n && newRate.d == ref.d) {\n            return (false, newRate);\n        }\n\n        referenceRate = newRate;\n        referenceRateUpdateTime = currentTime;\n\n        rebalance();\n\n        return (true, newRate);\n    }\n\n    /**\n      * @dev updates the pool's reserve weights with new values in order to push the current primary\n      * reserve token balance to its staked balance\n    */\n    function rebalance() private {\n        // get the new reserve weights\n        (uint32 primaryReserveWeight, uint32 secondaryReserveWeight) = effectiveReserveWeights(referenceRate);\n\n        // update the reserve weights with the new values\n        reserves[primaryReserveToken].weight = primaryReserveWeight;\n        reserves[secondaryReserveToken].weight = secondaryReserveWeight;\n    }\n\n    /**\n      * @dev returns the effective reserve weights based on the staked balance, current balance and oracle price\n      *\n      * @param _rate    rate between the reserve tokens\n      *\n      * @return new primary reserve weight\n      * @return new secondary reserve weight\n    */\n    function effectiveReserveWeights(Fraction memory _rate) private view returns (uint32, uint32) {\n        // get the primary reserve staked balance\n        uint256 primaryStakedBalance = stakedBalances[primaryReserveToken];\n\n        // get the tokens amplified balances\n        uint256 primaryBalance = reserveAmplifiedBalance(primaryReserveToken);\n        uint256 secondaryBalance = reserveAmplifiedBalance(secondaryReserveToken);\n\n        // get the new weights\n        return IBancorFormula(addressOf(BANCOR_FORMULA)).balancedWeights(\n            primaryStakedBalance.mul(AMPLIFICATION_FACTOR),\n            primaryBalance,\n            secondaryBalance,\n            _rate.n,\n            _rate.d);\n    }\n\n    /**\n      * @dev calculates and returns the rate between two reserve tokens\n      *\n      * @param _token1          contract address of the token to calculate the rate of one unit of\n      * @param _token2          contract address of the token to calculate the rate of one `_token1` unit in\n      * @param _token1Weight    reserve weight of token1\n      * @param _token2Weight    reserve weight of token2\n      *\n      * @return rate\n    */\n    function tokensRate(IERC20Token _token1, IERC20Token _token2, uint32 _token1Weight, uint32 _token2Weight) private view returns (Fraction memory) {\n        // apply the amplification factor\n        uint256 token1Balance = reserveAmplifiedBalance(_token1);\n        uint256 token2Balance = reserveAmplifiedBalance(_token2);\n\n        // get reserve weights\n        if (_token1Weight == 0) {\n            _token1Weight = reserves[_token1].weight;\n        }\n\n        if (_token2Weight == 0) {\n            _token2Weight = reserves[_token2].weight;\n        }\n\n        return Fraction({ n: token2Balance.mul(_token1Weight), d: token1Balance.mul(_token2Weight) });\n    }\n\n    /**\n      * @dev dispatches rate events for both reserve tokens and for the target pool token\n      * only used to circumvent the `stack too deep` compiler error\n      *\n      * @param _sourceToken     contract address of the source reserve token\n      * @param _targetToken     contract address of the target reserve token\n      * @param _sourceWeight    source reserve token weight\n      * @param _targetWeight    target reserve token weight\n    */\n    function dispatchRateEvents(IERC20Token _sourceToken, IERC20Token _targetToken, uint32 _sourceWeight, uint32 _targetWeight) private {\n        dispatchTokenRateUpdateEvent(_sourceToken, _targetToken, _sourceWeight, _targetWeight);\n\n        // dispatch the `TokenRateUpdate` event for the pool token\n        // the target reserve pool token rate is the only one that's affected\n        // by conversions since conversion fees are applied to the target reserve\n        ISmartToken targetPoolToken = poolToken(_targetToken);\n        uint256 targetPoolTokenSupply = targetPoolToken.totalSupply();\n        dispatchPoolTokenRateUpdateEvent(targetPoolToken, targetPoolTokenSupply, _targetToken);\n    }\n\n    /**\n      * @dev dispatches token rate update event\n      * only used to circumvent the `stack too deep` compiler error\n      *\n      * @param _token1          contract address of the token to calculate the rate of one unit of\n      * @param _token2          contract address of the token to calculate the rate of one `_token1` unit in\n      * @param _token1Weight    reserve weight of token1\n      * @param _token2Weight    reserve weight of token2\n    */\n    function dispatchTokenRateUpdateEvent(IERC20Token _token1, IERC20Token _token2, uint32 _token1Weight, uint32 _token2Weight) private {\n        // dispatch token rate update event\n        Fraction memory rate = tokensRate(_token1, _token2, _token1Weight, _token2Weight);\n\n        emit TokenRateUpdate(_token1, _token2, rate.n, rate.d);\n    }\n\n    /**\n      * @dev dispatches the `TokenRateUpdate` for the pool token\n      * only used to circumvent the `stack too deep` compiler error\n      *\n      * @param _poolToken       address of the pool token\n      * @param _poolTokenSupply total pool token supply\n      * @param _reserveToken    address of the reserve token\n    */\n    function dispatchPoolTokenRateUpdateEvent(ISmartToken _poolToken, uint256 _poolTokenSupply, IERC20Token _reserveToken) private {\n        emit TokenRateUpdate(_poolToken, _reserveToken, stakedBalances[_reserveToken], _poolTokenSupply);\n    }\n\n    /**\n      * @dev returns the current time\n    */\n    function time() internal view returns (uint256) {\n        return now;\n    }\n\n    uint256 private constant MAX_RATE_FACTOR_LOWER_BOUND = 1e30;\n    uint256 private constant MAX_RATE_FACTOR_UPPER_BOUND = uint256(-1) / MAX_RATE_FACTOR_LOWER_BOUND;\n\n    /**\n      * @dev reduces the numerator and denominator while maintaining the ratio between them as accurately as possible\n    */\n    function reduceRate(uint256 _n, uint256 _d) internal pure returns (Fraction memory) {\n        if (_n >= _d) {\n            return reduceFactors(_n, _d);\n        }\n\n        Fraction memory rate = reduceFactors(_d, _n);\n        return Fraction({ n: rate.d, d: rate.n });\n    }\n\n    /**\n      * @dev reduces the factors while maintaining the ratio between them as accurately as possible\n    */\n    function reduceFactors(uint256 _max, uint256 _min) internal pure returns (Fraction memory) {\n        if (_min > MAX_RATE_FACTOR_UPPER_BOUND) {\n            return Fraction({\n                n: MAX_RATE_FACTOR_LOWER_BOUND,\n                d: _min / (_max / MAX_RATE_FACTOR_LOWER_BOUND)\n            });\n        }\n\n        if (_max > MAX_RATE_FACTOR_LOWER_BOUND) {\n            return Fraction({\n                n: MAX_RATE_FACTOR_LOWER_BOUND,\n                d: _min * MAX_RATE_FACTOR_LOWER_BOUND / _max\n            });\n        }\n\n        return Fraction({ n: _max, d: _min });\n    }\n}\n","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"reserveStakedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_onlyOwnerCanUpdateRegistry\",\"type\":\"bool\"}],\"name\":\"restrictRegistryUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"primaryReserveToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxStakedBalanceEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"connectors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primaryReserveToken\",\"type\":\"address\"},{\"name\":\"_primaryReserveOracle\",\"type\":\"address\"},{\"name\":\"_secondaryReserveOracle\",\"type\":\"address\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasETHReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableMaxStakedBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"connectorTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"reserveWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sourceToken\",\"type\":\"address\"},{\"name\":\"_targetToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"reserveAmplifiedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"liquidationLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyOwnerCanUpdateRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referenceRateEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromAnchor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"converterType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dynamicFeeFactor\",\"type\":\"uint256\"},{\"name\":\"_weightSpreadFactor\",\"type\":\"uint256\"},{\"name\":\"_ratePropagationPeriod\",\"type\":\"uint256\"}],\"name\":\"customizeAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserve1MaxStakedBalance\",\"type\":\"uint256\"},{\"name\":\"_reserve2MaxStakedBalance\",\"type\":\"uint256\"}],\"name\":\"setMaxStakedBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelist\",\"type\":\"address\"}],\"name\":\"setConversionWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weightSpreadFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"poolToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_weightSpreadFactor\",\"type\":\"uint256\"}],\"name\":\"setWeightSpreadFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratePropagationPeriod\",\"type\":\"uint256\"}],\"name\":\"setRatePropagationPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prevRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferAnchorOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_poolToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityReturnAndFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dynamicFeeFactor\",\"type\":\"uint256\"}],\"name\":\"setDynamicFeeFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_weight\",\"type\":\"uint32\"}],\"name\":\"addReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"connectorTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxConversionFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxStakedBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratePropagationPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referenceRate\",\"outputs\":[{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sourceToken\",\"type\":\"address\"},{\"name\":\"_targetToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"targetAmountAndFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restoreRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionsEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"},{\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"setReserveStakedBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referenceRateUpdateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptAnchorOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserveTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isV28OrHigher\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"anchor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amplificationFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"reserves\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"weight\",\"type\":\"uint32\"},{\"name\":\"deprecated1\",\"type\":\"bool\"},{\"name\":\"deprecated2\",\"type\":\"bool\"},{\"name\":\"isSet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referenceRateEnabled\",\"type\":\"bool\"}],\"name\":\"setReferenceRateEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_connectorToken\",\"type\":\"address\"}],\"name\":\"getConnectorBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"effectiveTokensRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondaryReserveToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_reserveToken\",\"type\":\"address\"}],\"name\":\"reserveBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dynamicFeeFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sourceToken\",\"type\":\"address\"},{\"name\":\"_targetToken\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_trader\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"effectiveReserveWeights\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_conversionFee\",\"type\":\"uint32\"}],\"name\":\"setConversionFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastConversionRate\",\"outputs\":[{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_poolTokensContainer\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_maxConversionFee\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newState\",\"type\":\"bool\"}],\"name\":\"ReferenceRateEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newFactor\",\"type\":\"uint256\"}],\"name\":\"DynamicFeeFactorUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newFactor\",\"type\":\"uint256\"}],\"name\":\"WeightSpreadFactorUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newPeriod\",\"type\":\"uint256\"}],\"name\":\"RatePropagationPeriodUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_reserveToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newSupply\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_reserveToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newSupply\",\"type\":\"uint256\"}],\"name\":\"LiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_type\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"_anchor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_activated\",\"type\":\"bool\"}],\"name\":\"Activation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_fromToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_toToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_trader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_return\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_conversionFee\",\"type\":\"int256\"}],\"name\":\"Conversion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token1\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token2\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_rateN\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rateD\",\"type\":\"uint256\"}],\"name\":\"TokenRateUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevFee\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_newFee\",\"type\":\"uint32\"}],\"name\":\"ConversionFeeUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"LiquidityPoolV2Converter","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000bfa9a42e1a86bbb9e0bc43e394b88041632563000000000000000000000000052ae12abe5d8bd778bd5397f99ca900624cfadd400000000000000000000000000000000000000000000000000000000000003e8","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}