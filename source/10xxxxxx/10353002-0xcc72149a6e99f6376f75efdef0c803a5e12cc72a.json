{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.7 <0.6.0;\r\n\r\n/*\r\nMIT License\r\n\r\nCopyright (c) 2020 Daniel Britten\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n// Facilitates a tree of points with pros and cons where only additions to the 'reasoning tree' can be made.\r\ncontract ReasoningTree {\r\n\r\n    struct Node { // Point/Idea/Content\r\n        string keyIdea; // Intended to be a brief key idea.\r\n        string moreDetail; // Intended to include more detail such as explanation or a URL or ipfs link with even more information.\r\n        address author; // Ethereum address of the person who submitted the key idea and more detail.\r\n        uint[] pros; // Supporting points, 'Pros', which have been added later by anyone, accessible via retrieve or getKeyIdea.\r\n        uint[] cons; // Negating points, 'Cons', which have been added later by anyone, accessible via retrieve or getKeyIdea.\r\n    }\r\n    \r\n    mapping(uint => Node) nodes;\r\n    uint nextId;\r\n    uint[] topLevelNodes;\r\n    event ReturnValue(address indexed _from, uint thisNodeId);\r\n\r\n    constructor() public {\r\n        nextId = 1; // Node Ids start from 1\r\n    }\r\n    \r\n    function getTopLevelNodes() public view returns (uint[] memory) {\r\n        return topLevelNodes;\r\n    }\r\n\r\n    // Sets the required details of the next node\r\n    function setNextNodeDetails(uint thisNodeId, string memory newKeyIdea, string memory newMoreDetail, address author) private {\r\n        nodes[thisNodeId].keyIdea = newKeyIdea;\r\n        nodes[thisNodeId].moreDetail = newMoreDetail;\r\n        nodes[thisNodeId].author = author;\r\n    }\r\n\r\n    // Add a Node/Point/Idea that is not linked to any parent Node\r\n    function addNewTopic(string memory newKeyIdea, string memory newMoreDetail) public returns (uint thisNodeId) {\r\n        thisNodeId = nextId;\r\n        setNextNodeDetails(thisNodeId, newKeyIdea, newMoreDetail, msg.sender);\r\n        topLevelNodes.push(thisNodeId);\r\n        nextId = nextId + 1;\r\n        emit ReturnValue(msg.sender, thisNodeId);\r\n        return thisNodeId;\r\n    }\r\n    \r\n    // Add a Node/Point/Idea that is either a pro or con of another Node\r\n    function add(string memory newKeyIdea, string memory newMoreDetail, uint parent, bool supportsParent) public returns (uint thisNodeId) {\r\n        require((0 < parent) && (parent < nextId), \"The given parent must already exist.\");\r\n        thisNodeId = nextId;\r\n        setNextNodeDetails(thisNodeId, newKeyIdea, newMoreDetail, msg.sender);\r\n        if (supportsParent)\r\n            nodes[parent].pros.push(thisNodeId);\r\n        else\r\n            nodes[parent].cons.push(thisNodeId);\r\n        nextId = nextId + 1;\r\n        emit ReturnValue(msg.sender, thisNodeId);\r\n        return thisNodeId;\r\n    }\r\n    \r\n    // Retrieve the details about a given Node\r\n    function retrieve (uint nodeId) public view returns (string memory, string memory, address, uint[] memory, uint[] memory)  {\r\n        require(nodeId > 0, \"NodeIds start from 1.\");\r\n        require(nodeId < nextId, \"The given node must already exist.\");\r\n        return (nodes[nodeId].keyIdea, nodes[nodeId].moreDetail, nodes[nodeId].author, nodes[nodeId].pros, nodes[nodeId].cons);\r\n    }\r\n    \r\n    // Get the key idea of a given node\r\n    function getKeyIdea(uint nodeId) public view returns (string memory) {\r\n        require(nodeId > 0, \"NodeIds start from 1.\");\r\n        require(nodeId < nextId, \"The given node must already exist.\");\r\n        return nodes[nodeId].keyIdea;\r\n    }\r\n    \r\n    // Get the current node count. NodeIds from 1 up to and including the node count will hold data.\r\n    function nodeCount() public view returns (uint) {\r\n        return nextId - 1; // NodeIds start from 1, so the count of current nodes is 1 less than nextId.\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"thisNodeId\",\"type\":\"uint256\"}],\"name\":\"ReturnValue\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"newKeyIdea\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newMoreDetail\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"supportsParent\",\"type\":\"bool\"}],\"name\":\"add\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"thisNodeId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"newKeyIdea\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newMoreDetail\",\"type\":\"string\"}],\"name\":\"addNewTopic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"thisNodeId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nodeId\",\"type\":\"uint256\"}],\"name\":\"getKeyIdea\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTopLevelNodes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nodeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nodeId\",\"type\":\"uint256\"}],\"name\":\"retrieve\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ReasoningTree","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6245077404d2bbc0146bf826672e536e2f03c8b79bfb7fd529a86151a552d857"}]}