{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n██╗  ██╗██████╗ ███╗   ███╗ \r\n╚██╗██╔╝╚════██╗████╗ ████║ \r\n ╚███╔╝  █████╔╝██╔████╔██║\r\n ██╔██╗  ╚═══██╗██║╚██╔╝██║\r\n██╔╝ ██╗██████╔╝██║ ╚═╝ ██║ \r\n╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝ \r\n                                                                               \r\n\r\n\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2020-06-21\r\n*/\r\n\r\npragma solidity 0.5.16; \r\n\r\n\r\n// Owner Handler\r\ncontract ownerShip    // Auction Contract Owner and OwherShip change\r\n{\r\n    //Global storage declaration\r\n    address payable public ownerWallet;\r\n    address payable private newOwner;\r\n    //Event defined for ownership transfered\r\n    event OwnershipTransferredEv(address indexed previousOwner, address indexed newOwner);\r\n\r\n    //Sets owner only on first run\r\n    constructor() public \r\n    {\r\n        //Set contract owner\r\n        ownerWallet = msg.sender;\r\n        emit OwnershipTransferredEv(address(0), msg.sender);\r\n    }\r\n\r\n    function transferOwnership(address payable  _newOwner) public onlyOwner \r\n    {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //the reason for this flow is to protect owners from sending ownership to unintended address due to human error\r\n    function acceptOwnership() public \r\n    {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferredEv(ownerWallet, newOwner);\r\n        ownerWallet = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n\r\n    //This will restrict function only for owner where attached\r\n    modifier onlyOwner() \r\n    {\r\n        require(msg.sender == ownerWallet);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract X3METHER is ownerShip {\r\n\r\n\r\n    uint public maxDownLimit = 2;\r\n    uint public levelLifeTime = 9999999999999999999;  // = 100 days;\r\n    uint public lastIDCount = 0;\r\n\r\n\r\n    // user address\r\n    mapping (address => uint) public walletAmount;\r\n    mapping(address => uint) public userLevel;\r\n    uint public lastFreeParent;\r\n\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint referrerID;\r\n        uint childCount;\r\n        uint mainRef;\r\n        address[] referral;\r\n        mapping(uint => uint) levelExpired;\r\n    }\r\n\r\n    mapping(uint => uint) public priceOfLevel;\r\n\r\n    mapping (address => userInfo) public userInfos;\r\n    mapping (uint => address payable) public userAddressByID;\r\n\r\n\r\n    event regLevelEv(uint indexed _userID, address indexed _userWallet, uint indexed _referrerID, address _refererWallet,uint originalReferrer, uint _time);\r\n    event reEntryEv(uint indexed _userID, address indexed _userWallet, uint indexed _referrerID, address _refererWallet,uint originalReferrer, uint _time);\r\n\r\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\r\n    event relevelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\r\n    event paidForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\r\n\r\n    constructor() public {\r\n\r\n        priceOfLevel[1] = 0.03 ether;\r\n        priceOfLevel[2] = 0.05 ether;\r\n        priceOfLevel[3] = 0.1 ether;\r\n        priceOfLevel[4] = 0.4 ether;\r\n        priceOfLevel[5] = 1 ether;\r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: 0,\r\n            childCount: 0,\r\n            mainRef: 1,\r\n            referral: new address[](0)\r\n        });\r\n        lastFreeParent = 1;\r\n        userInfos[ownerWallet] = UserInfo;\r\n        userAddressByID[lastIDCount] = ownerWallet;\r\n        userLevel[ownerWallet] = 10;\r\n        for(uint i = 1; i <= 10; i++) {\r\n            userInfos[ownerWallet].levelExpired[i] = 9999999999999999999;\r\n            emit paidForLevelEv(ownerWallet, address(0), i, priceOfLevel[i], now);\r\n            emit levelBuyEv(msg.sender, i, priceOfLevel[i], now);\r\n        }\r\n        \r\n        emit regLevelEv(lastIDCount, msg.sender, 0, address(0), 0, now);\r\n\r\n    }\r\n\r\n    function () external payable {\r\n        uint level;\r\n\r\n        if(msg.value == priceOfLevel[1]) level = 1;\r\n        else revert('Incorrect Value send');\r\n        require(! userInfos[msg.sender].joined, 'User already exist'); \r\n        regUser(1);\r\n    }\r\n\r\n    event paidReferalEv(address user, uint _mainReferral, uint amount, uint level);\r\n    function regUser(uint _mainReferral) public payable {\r\n        if(!(_mainReferral > 0 && _mainReferral <= lastIDCount)) _mainReferral = 1;\r\n        require(!userInfos[msg.sender].joined, 'User exist');\r\n        require(msg.value == priceOfLevel[1], 'Incorrect Value');\r\n\r\n        if(userInfos[userAddressByID[lastFreeParent]].childCount >= maxDownLimit) lastFreeParent++;\r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: lastFreeParent,\r\n            childCount: 0,\r\n            mainRef: _mainReferral,\r\n            referral: new address[](0)\r\n        });\r\n\r\n        userInfos[msg.sender] = UserInfo;\r\n        userInfos[userAddressByID[lastFreeParent]].childCount++;\r\n        userAddressByID[lastIDCount] = msg.sender;\r\n\r\n        userInfos[msg.sender].levelExpired[1] = now + levelLifeTime;\r\n        userLevel[msg.sender] = 1;\r\n\r\n        userInfos[userAddressByID[_mainReferral]].referral.push(msg.sender);\r\n        userAddressByID[_mainReferral].transfer(msg.value / 10);\r\n        emit paidReferalEv(msg.sender, _mainReferral, msg.value / 10, 1);\r\n        payForLevel(1, msg.sender);\r\n\r\n        emit regLevelEv(lastIDCount, msg.sender, lastFreeParent, userAddressByID[lastFreeParent],_mainReferral, now);\r\n        emit levelBuyEv(msg.sender, 1, msg.value, now);\r\n    }\r\n\r\n\r\n    function _regUser(address _user, uint _mainReferral) internal  {\r\n        uint _referrerID = lastFreeParent;\r\n        //require(!userInfos[msg.sender].joined, 'User exist');\r\n        //require(msg.value == priceOfLevel[1], 'Incorrect Value');\r\n        uint amount =  priceOfLevel[1];\r\n        if(userInfos[userAddressByID[_referrerID]].childCount >= maxDownLimit) lastFreeParent++;\r\n\r\n        lastIDCount++;\r\n\r\n        userInfos[_user].id = lastIDCount;\r\n\r\n        userInfos[_user].levelExpired[1] = now + levelLifeTime;\r\n        userLevel[_user] = 1;\r\n        userAddressByID[_mainReferral].transfer(amount /10);\r\n        emit paidReferalEv(_user, _mainReferral, amount / 10, 1);\r\n        payForLevel(1, _user);\r\n\r\n        emit reEntryEv(lastIDCount, _user, _referrerID, userAddressByID[_referrerID],_mainReferral, now);\r\n        emit relevelBuyEv(_user, 1, amount, now);\r\n    }\r\n\r\n\r\n    function _buyLevel(uint _level, address payable user) internal returns(bool)\r\n    {\r\n        require(userInfos[user].joined, 'User not exist'); \r\n        require(_level > 0 && _level <= 10, 'Incorrect level');\r\n        uint amount;\r\n        \r\n        amount = priceOfLevel[_level];\r\n        \r\n        if(_level == 1) {\r\n            userInfos[user].levelExpired[1] += levelLifeTime;\r\n             userLevel[user] = 1;\r\n        }\r\n        else {\r\n            \r\n            for(uint l =_level - 1; l > 0; l--) require(userInfos[user].levelExpired[l] >= now, 'Buy the previous level');\r\n\r\n            if(userInfos[user].levelExpired[_level] == 0) \r\n            {\r\n                userInfos[user].levelExpired[_level] = now + levelLifeTime;\r\n            }\r\n            else\r\n            {\r\n                userInfos[user].levelExpired[_level] += levelLifeTime;\r\n            }\r\n             userLevel[user] = _level;\r\n        }\r\n        uint refId = userInfos[user].mainRef;\r\n        userAddressByID[refId].transfer(amount /10);\r\n        emit paidReferalEv(user, refId, amount / 10, _level);\r\n        payForLevel(_level, user);\r\n\r\n        emit levelBuyEv(user, _level, amount, now);\r\n        return true;\r\n    }\r\n    \r\n\r\n    function payForLevel(uint _level, address _user) internal {\r\n        address payable referer;\r\n        address payable referer1;\r\n        address payable referer2;\r\n        address payable referer3;\r\n        address payable referer4;\r\n        uint amount_;\r\n\r\n        amount_ = priceOfLevel[_level] * 9 / 10;       \r\n\r\n        if(_level == 1 ) {\r\n            referer = userAddressByID[userInfos[_user].referrerID];\r\n        }\r\n        else if(_level == 2) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer = userAddressByID[userInfos[referer1].referrerID];\r\n        }\r\n        else if(_level == 3) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer = userAddressByID[userInfos[referer2].referrerID];\r\n        }\r\n        else if(_level == 4) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer3 = userAddressByID[userInfos[referer2].referrerID];\r\n            referer = userAddressByID[userInfos[referer3].referrerID];\r\n        }\r\n        else if(_level == 5) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer3 = userAddressByID[userInfos[referer2].referrerID];\r\n            referer4 = userAddressByID[userInfos[referer3].referrerID];\r\n            referer = userAddressByID[userInfos[referer4].referrerID];\r\n        }\r\n\r\n        if(!userInfos[referer].joined) referer = userAddressByID[1];\r\n\r\n        if(userLevel[referer] == 5 )\r\n        {\r\n            if(userInfos[referer].referral.length >= 62)\r\n            {\r\n                walletAmount[referer] = 0;\r\n                referer.transfer(amount_ - priceOfLevel[1]);  // substraction is for register again\r\n                _regUser(referer,1);\r\n            }\r\n            else\r\n            {\r\n                walletAmount[referer] = 0;                \r\n                ownerWallet.transfer(amount_ - priceOfLevel[1]); // substraction is for register again\r\n                _regUser(referer,1);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            walletAmount[referer] += amount_;\r\n            emit paidForLevelEv(referer, msg.sender, _level, amount_, now);\r\n            uint priceCheck = priceOfLevel[_level] * (2 ** _level);\r\n            priceCheck = priceCheck - ( priceCheck / 10 );\r\n            if(walletAmount[referer] >= priceCheck ) \r\n            {\r\n                uint amt = walletAmount[referer];\r\n                if(userInfos[referer].id != 1)\r\n                {                   \r\n                    walletAmount[referer] = 0;\r\n                    referer.transfer(amt - priceOfLevel[_level + 1] );\r\n                    require(_buyLevel(_level + 1, referer),\"level upgrade fail\"); \r\n                    \r\n                }\r\n                else\r\n                {\r\n                    walletAmount[referer] = 0;\r\n                    referer.transfer(amt);\r\n                }              \r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function viewUserReferral(address _user) public view returns(address[] memory) {\r\n        return userInfos[_user].referral;\r\n    }\r\n\r\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\r\n        return userInfos[_user].levelExpired[_level];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n    \r\n    function viewTimestampSinceJoined(address usr) public view returns(uint256[10] memory timeSinceJoined )\r\n    {\r\n        if(userInfos[usr].joined)\r\n        {\r\n            for(uint256 i=0;i<10;i++)\r\n            {\r\n                uint256 t = userInfos[usr].levelExpired[i+1];\r\n                if(t>now)\r\n                {\r\n                    timeSinceJoined[i] = (t-now);\r\n                }\r\n            }\r\n        }\r\n        return timeSinceJoined;\r\n    }\r\n\r\n    function emergencySwapExit() public returns(bool)\r\n    {\r\n        require(msg.sender == ownerWallet);\r\n        ownerWallet.transfer(address(this).balance);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferredEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"levelBuyEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"paidForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_mainReferral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"paidReferalEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_refererWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originalReferrer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"reEntryEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_refererWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originalReferrer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"regLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"relevelBuyEv\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencySwapExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastFreeParent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levelLifeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDownLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceOfLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mainReferral\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mainRef\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"viewTimestampSinceJoined\",\"outputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"timeSinceJoined\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelExpired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"X3METHER","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://01fcd1509b21b7ec9a1ade45a98b384fb10a59b6b83adfc9c8a7583569433244"}]}