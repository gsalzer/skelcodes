{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n* @title Tellor Transfer\r\n* @dev Contais the methods related to transfers and ERC20. Tellor.sol and TellorGetters.sol\r\n* reference this library for function's logic.\r\n* Many of the functions have been commented out for simplicity.\r\n*/\r\nlibrary TellorTransfer {\r\n    using SafeMath for uint256;\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);//ERC20 Approval event\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);//ERC20 Transfer Event\r\n\r\n    /*Functions*/\r\n\r\n    /**\r\n    * @dev Allows for a transfer of tokens to _to\r\n    * @param _to The address to send tokens to\r\n    * @param _amount The amount of tokens to send\r\n    * @return true if transfer is successful\r\n    */\r\n    function transfer(TellorStorage.TellorStorageStruct storage self, address _to, uint256 _amount) public returns (bool success) {\r\n        doTransfer(self,msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Send _amount tokens to _to from _from on the condition it\r\n    * is approved by _from\r\n    * @param _from The address holding the tokens being transferred\r\n    * @param _to The address of the recipient\r\n    * @param _amount The amount of tokens to be transferred\r\n    * @return True if the transfer was successful\r\n    */\r\n    function transferFrom(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount) public returns (bool success) {\r\n        require(self.allowed[_from][msg.sender] >= _amount);\r\n        self.allowed[_from][msg.sender] -= _amount;\r\n        doTransfer(self,_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev This function approves a _spender an _amount of tokens to use\r\n    * @param _spender address\r\n    * @param _amount amount the spender is being approved for\r\n    * @return true if spender appproved successfully\r\n    */\r\n    function approve(TellorStorage.TellorStorageStruct storage self, address _spender, uint _amount) public returns (bool) {\r\n        require(_spender != address(0));\r\n        self.allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    // /**\r\n    // * @param _user address of party with the balance\r\n    // * @param _spender address of spender of parties said balance\r\n    // * @return Returns the remaining allowance of tokens granted to the _spender from the _user\r\n    // */\r\n    // function allowance(TellorStorage.TellorStorageStruct storage self,address _user, address _spender) public view returns (uint) {\r\n    //    return self.allowed[_user][_spender];\r\n    // }\r\n\r\n\r\n    /**\r\n    * @dev Completes POWO transfers by updating the balances on the current block number\r\n    * @param _from address to transfer from\r\n    * @param _to addres to transfer to\r\n    * @param _amount to transfer\r\n    */\r\n    function doTransfer(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint _amount) public {\r\n        require(_amount > 0);\r\n        require(_to != address(0));\r\n        require(allowedToTrade(self,_from,_amount)); //allowedToTrade checks the stakeAmount is removed from balance if the _user is staked\r\n        uint previousBalance = balanceOfAt(self,_from, block.number);\r\n        updateBalanceAtNow(self.balances[_from], previousBalance - _amount);\r\n        previousBalance = balanceOfAt(self,_to, block.number);\r\n        require(previousBalance + _amount >= previousBalance); // Check for overflow\r\n        updateBalanceAtNow(self.balances[_to], previousBalance + _amount);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets balance of owner specified\r\n    * @param _user is the owner address used to look up the balance\r\n    * @return Returns the balance associated with the passed in _user\r\n    */\r\n    function balanceOf(TellorStorage.TellorStorageStruct storage self,address _user) public view returns (uint) {\r\n        return balanceOfAt(self,_user, block.number);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Queries the balance of _user at a specific _blockNumber\r\n    * @param _user The address from which the balance will be retrieved\r\n    * @param _blockNumber The block number when the balance is queried\r\n    * @return The balance at _blockNumber specified\r\n    */\r\n    function balanceOfAt(TellorStorage.TellorStorageStruct storage self,address _user, uint _blockNumber) public view returns (uint) {\r\n        if ((self.balances[_user].length == 0) || (self.balances[_user][0].fromBlock > _blockNumber)) {\r\n                return 0;\r\n        }\r\n     else {\r\n        return getBalanceAt(self.balances[_user], _blockNumber);\r\n     }\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter for balance for owner on the specified _block number\r\n    * @param checkpoints gets the mapping for the balances[owner]\r\n    * @param _block is the block number to search the balance on\r\n    * @return the balance at the checkpoint\r\n    */\r\n    function getBalanceAt(TellorStorage.Checkpoint[] storage checkpoints, uint _block) view public returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev This function returns whether or not a given user is allowed to trade a given amount\r\n    * and removing the staked amount from their balance if they are staked\r\n    * @param _user address of user\r\n    * @param _amount to check if the user can spend\r\n    * @return true if they are allowed to spend the amount being checked\r\n    */\r\n    function allowedToTrade(TellorStorage.TellorStorageStruct storage self,address _user,uint _amount) public view returns(bool) {\r\n        if(self.stakerDetails[_user].currentStatus >0){\r\n            //Removes the stakeAmount from balance if the _user is staked\r\n            if(balanceOf(self,_user).sub(self.uintVars[keccak256(\"stakeAmount\")]).sub(_amount) >= 0){\r\n                return true;\r\n            }\r\n        }\r\n        else if(balanceOf(self,_user).sub(_amount) >= 0){\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Updates balance for from and to on the current block number via doTransfer\r\n    * @param checkpoints gets the mapping for the balances[owner]\r\n    * @param _value is the new balance\r\n    */\r\n    function updateBalanceAtNow(TellorStorage.Checkpoint[] storage checkpoints, uint _value) public {\r\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               TellorStorage.Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n        } else {\r\n               TellorStorage.Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n//Slightly modified SafeMath library - includes a min and max function, removes useless div function\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\r\n        if (b > 0) {\r\n            c = a + b;\r\n            assert(c >= a);\r\n        } else {\r\n            c = a + b;\r\n            assert(c <= a);\r\n        }\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    function max(int256 a, int256 b) internal pure returns (uint256) {\r\n        return a > b ? uint256(a) : uint256(b);\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\r\n        if (b > 0) {\r\n            c = a - b;\r\n            assert(c <= a);\r\n        } else {\r\n            c = a - b;\r\n            assert(c >= a);\r\n        }\r\n\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Tellor Oracle Storage Library\r\n * @dev Contains all the variables/structs used by Tellor\r\n * This test file is exactly the same as the production/mainnet file.\r\n */\r\n\r\nlibrary TellorStorage {\r\n    //Internal struct for use in proof-of-work submission\r\n    struct Details {\r\n        uint value;\r\n        address miner;\r\n    }\r\n\r\n    struct Dispute {\r\n        bytes32 hash;//unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\r\n        int tally;//current tally of votes for - against measure\r\n        bool executed;//is the dispute settled\r\n        bool disputeVotePassed;//did the vote pass?\r\n        bool isPropFork; //true for fork proposal NEW\r\n        address reportedMiner; //miner who alledgedly submitted the 'bad value' will get disputeFee if dispute vote fails\r\n        address reportingParty;//miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\r\n        address proposedForkAddress;//new fork address (if fork proposal)\r\n        mapping(bytes32 => uint) disputeUintVars;\r\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\r\n        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\"requestId\")]\r\n        //These are the variables saved in this mapping:\r\n            // uint keccak256(\"requestId\");//apiID of disputed value\r\n            // uint keccak256(\"timestamp\");//timestamp of distputed value\r\n            // uint keccak256(\"value\"); //the value being disputed\r\n            // uint keccak256(\"minExecutionDate\");//7 days from when dispute initialized\r\n            // uint keccak256(\"numberOfVotes\");//the number of parties who have voted on the measure\r\n            // uint keccak256(\"blockNumber\");// the blocknumber for which votes will be calculated from\r\n            // uint keccak256(\"minerSlot\"); //index in dispute array\r\n            // uint keccak256(\"quorum\"); //quorum for dispute vote NEW\r\n            // uint keccak256(\"fee\"); //fee paid corresponding to dispute\r\n        mapping (address => bool) voted; //mapping of address to whether or not they voted\r\n    }\r\n\r\n    struct StakeInfo {\r\n        uint currentStatus;//0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute\r\n        uint startDate; //stake start date\r\n    }\r\n\r\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\r\n    struct  Checkpoint {\r\n        uint128 fromBlock;// fromBlock is the block number that the value was generated from\r\n        uint128 value;// value is the amount of tokens at a specific block number\r\n    }\r\n\r\n    struct Request {\r\n        string queryString;//id to string api\r\n        string dataSymbol;//short name for api request\r\n        bytes32 queryHash;//hash of api string and granularity e.g. keccak256(abi.encodePacked(_sapi,_granularity))\r\n        uint[]  requestTimestamps; //array of all newValueTimestamps requested\r\n        mapping(bytes32 => uint) apiUintVars;\r\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\r\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\"totalTip\")]\r\n        //These are the variables saved in this mapping:\r\n            // uint keccak256(\"granularity\"); //multiplier for miners\r\n            // uint keccak256(\"requestQPosition\"); //index in requestQ\r\n            // uint keccak256(\"totalTip\");//bonus portion of payout\r\n        mapping(uint => uint) minedBlockNum;//[apiId][minedTimestamp]=>block.number\r\n        mapping(uint => uint) finalValues;//This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\r\n        mapping(uint => bool) inDispute;//checks if API id is in dispute or finalized.\r\n        mapping(uint => address[5]) minersByValue;\r\n        mapping(uint => uint[5])valuesByTimestamp;\r\n    }\r\n\r\n    struct TellorStorageStruct {\r\n        bytes32 currentChallenge; //current challenge to be solved\r\n        uint[51]  requestQ; //uint50 array of the top50 requests by payment amount\r\n        uint[]  newValueTimestamps; //array of all timestamps requested\r\n        Details[5]  currentMiners; //This struct is for organizing the five mined values to find the median\r\n        mapping(bytes32 => address) addressVars;\r\n        //Address fields in the Tellor contract are saved the addressVars mapping\r\n        //e.g. addressVars[keccak256(\"tellorContract\")] = address\r\n        //These are the variables saved in this mapping:\r\n            // address keccak256(\"tellorContract\");//Tellor address\r\n            // address  keccak256(\"_owner\");//Tellor Owner address\r\n            // address  keccak256(\"_deity\");//Tellor Owner that can do things at will\r\n        mapping(bytes32 => uint) uintVars;\r\n        //uint fields in the Tellor contract are saved the uintVars mapping\r\n        //e.g. uintVars[keccak256(\"decimals\")] = uint\r\n        //These are the variables saved in this mapping:\r\n            // keccak256(\"decimals\");    //18 decimal standard ERC20\r\n            // keccak256(\"disputeFee\");//cost to dispute a mined value\r\n            // keccak256(\"disputeCount\");//totalHistoricalDisputes\r\n            // keccak256(\"total_supply\"); //total_supply of the token in circulation\r\n            // keccak256(\"stakeAmount\");//stakeAmount for miners (we can cut gas if we just hardcode it in...or should it be variable?)\r\n            // keccak256(\"stakerCount\"); //number of parties currently staked\r\n            // keccak256(\"timeOfLastNewValue\"); // time of last challenge solved\r\n            // keccak256(\"difficulty\"); // Difficulty of current block\r\n            // keccak256(\"currentTotalTips\"); //value of highest api/timestamp PayoutPool\r\n            // keccak256(\"currentRequestId\"); //API being mined--updates with the ApiOnQ Id\r\n            // keccak256(\"requestCount\"); // total number of requests through the system\r\n            // keccak256(\"slotProgress\");//Number of miners who have mined this value so far\r\n            // keccak256(\"miningReward\");//Mining Reward in PoWo tokens given to all miners per value\r\n            // keccak256(\"timeTarget\"); //The time between blocks (mined Oracle values)\r\n        mapping(bytes32 => mapping(address=>bool)) minersByChallenge;//This is a boolean that tells you if a given challenge has been completed by a given miner\r\n        mapping(uint => uint) requestIdByTimestamp;//minedTimestamp to apiId\r\n        mapping(uint => uint) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\r\n        mapping(uint => Dispute) disputesById;//disputeId=> Dispute details\r\n        mapping (address => Checkpoint[]) balances; //balances of a party given blocks\r\n        mapping(address => mapping (address => uint)) allowed; //allowance for a given party and approver\r\n        mapping(address => StakeInfo)  stakerDetails;//mapping from a persons address to their staking info\r\n        mapping(uint => Request) requestDetails;//mapping of apiID to details\r\n        mapping(bytes32 => uint) requestIdByQueryHash;// api bytes32 gets an id = to count of requests array\r\n        mapping(bytes32 => uint) disputeIdByDisputeHash;//maps a hash to an ID for each dispute\r\n    }\r\n}\r\n\r\n//Functions for retrieving min and Max in 51 length array (requestQ)\r\n//Taken partly from: https://github.com/modular-network/ethereum-libraries-array-utils/blob/master/contracts/Array256Lib.sol\r\n\r\nlibrary Utilities{\r\n\r\n    /**\r\n    * @dev Returns the minimum value in an array.\r\n    */\r\n    function getMax(uint[51] memory data) internal pure returns(uint256 max,uint256 maxIndex) {\r\n        max = data[1];\r\n        maxIndex;\r\n        for(uint i=1;i < data.length;i++){\r\n            if(data[i] > max){\r\n                max = data[i];\r\n                maxIndex = i;\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the minimum value in an array.\r\n    */\r\n    function getMin(uint[51] memory data) internal pure returns(uint256 min,uint256 minIndex) {\r\n        minIndex = data.length - 1;\r\n        min = data[minIndex];\r\n        for(uint i = data.length-1;i > 0;i--) {\r\n            if(data[i] < min) {\r\n                min = data[i];\r\n                minIndex = i;\r\n            }\r\n        }\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n* @title Tellor Getters Library\r\n* @dev This is the test getter library for all variables in the Tellor Tributes system. TellorGetters references this\r\n* libary for the getters logic.\r\n* Many of the functions have been commented out for simplicity.\r\n*/\r\n\r\n\r\n\r\nlibrary TellorGettersLibrary{\r\n    using SafeMath for uint256;\r\n\r\n    event NewTellorAddress(address _newTellor); //emmited when a proposed fork is voted true\r\n\r\n    /*Functions*/\r\n\r\n    //The next two functions are onlyOwner functions.  For Tellor to be truly decentralized, we will need to transfer the Deity to the 0 address.\r\n    //Only needs to be in library\r\n    /**\r\n    * @dev This function allows us to set a new Deity (or remove it)\r\n    * @param _newDeity address of the new Deity of the tellor system\r\n    */\r\n    function changeDeity(TellorStorage.TellorStorageStruct storage self, address _newDeity) internal{\r\n        require(self.addressVars[keccak256(\"_deity\")] == msg.sender);\r\n        self.addressVars[keccak256(\"_deity\")] =_newDeity;\r\n    }\r\n\r\n\r\n    //Only needs to be in library\r\n    /**\r\n    * @dev This function allows the deity to upgrade the Tellor System\r\n    * @param _tellorContract address of new updated TellorCore contract\r\n    */\r\n    function changeTellorContract(TellorStorage.TellorStorageStruct storage self,address _tellorContract) internal{\r\n        require(self.addressVars[keccak256(\"_deity\")] == msg.sender);\r\n        self.addressVars[keccak256(\"tellorContract\")]= _tellorContract;\r\n        emit NewTellorAddress(_tellorContract);\r\n    }\r\n\r\n\r\n    // /*Tellor Getters*/\r\n\r\n    // /**\r\n    // * @dev This function tells you if a given challenge has been completed by a given miner\r\n    // * @param _challenge the challenge to search for\r\n    // * @param _miner address that you want to know if they solved the challenge\r\n    // * @return true if the _miner address provided solved the\r\n    // */\r\n    // function didMine(TellorStorage.TellorStorageStruct storage self, bytes32 _challenge,address _miner) internal view returns(bool){\r\n    //     return self.minersByChallenge[_challenge][_miner];\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Checks if an address voted in a dispute\r\n    // * @param _disputeId to look up\r\n    // * @param _address of voting party to look up\r\n    // * @return bool of whether or not party voted\r\n    // */\r\n    // function didVote(TellorStorage.TellorStorageStruct storage self,uint _disputeId, address _address) internal view returns(bool){\r\n    //     return self.disputesById[_disputeId].voted[_address];\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev allows Tellor to read data from the addressVars mapping\r\n    // * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\r\n    // * These are examples of how the variables are saved within other functions:\r\n    // * addressVars[keccak256(\"_owner\")]\r\n    // * addressVars[keccak256(\"tellorContract\")]\r\n    // */\r\n    // function getAddressVars(TellorStorage.TellorStorageStruct storage self, bytes32 _data) view internal returns(address){\r\n    //     return self.addressVars[_data];\r\n    // }\r\n\r\n\r\n    // *\r\n    // * @dev Gets all dispute variables\r\n    // * @param _disputeId to look up\r\n    // * @return bytes32 hash of dispute\r\n    // * @return bool executed where true if it has been voted on\r\n    // * @return bool disputeVotePassed\r\n    // * @return bool isPropFork true if the dispute is a proposed fork\r\n    // * @return address of reportedMiner\r\n    // * @return address of reportingParty\r\n    // * @return address of proposedForkAddress\r\n    // * @return uint of requestId\r\n    // * @return uint of timestamp\r\n    // * @return uint of value\r\n    // * @return uint of minExecutionDate\r\n    // * @return uint of numberOfVotes\r\n    // * @return uint of blocknumber\r\n    // * @return uint of minerSlot\r\n    // * @return uint of quorum\r\n    // * @return uint of fee\r\n    // * @return int count of the current tally\r\n\r\n    // function getAllDisputeVars(TellorStorage.TellorStorageStruct storage self,uint _disputeId) internal view returns(bytes32, bool, bool, bool, address, address, address,uint[9] memory, int){\r\n    //     TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\r\n    //     return(disp.hash,disp.executed, disp.disputeVotePassed, disp.isPropFork, disp.reportedMiner, disp.reportingParty,disp.proposedForkAddress,[disp.disputeUintVars[keccak256(\"requestId\")], disp.disputeUintVars[keccak256(\"timestamp\")], disp.disputeUintVars[keccak256(\"value\")], disp.disputeUintVars[keccak256(\"minExecutionDate\")], disp.disputeUintVars[keccak256(\"numberOfVotes\")], disp.disputeUintVars[keccak256(\"blockNumber\")], disp.disputeUintVars[keccak256(\"minerSlot\")], disp.disputeUintVars[keccak256(\"quorum\")],disp.disputeUintVars[keccak256(\"fee\")]],disp.tally);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\r\n    // * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\r\n    // */\r\n    // function getCurrentVariables(TellorStorage.TellorStorageStruct storage self) internal view returns(bytes32, uint, uint,string memory,uint,uint){\r\n    //     return (self.currentChallenge,self.uintVars[keccak256(\"currentRequestId\")],self.uintVars[keccak256(\"difficulty\")],self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].queryString,self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].apiUintVars[keccak256(\"granularity\")],self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].apiUintVars[keccak256(\"totalTip\")]);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Checks if a given hash of miner,requestId has been disputed\r\n    // * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\r\n    // * @return uint disputeId\r\n    // */\r\n    // function getDisputeIdByDisputeHash(TellorStorage.TellorStorageStruct storage self,bytes32 _hash) internal view returns(uint){\r\n    //     return  self.disputeIdByDisputeHash[_hash];\r\n    // }\r\n\r\n\r\n    // /*\r\n    // * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\r\n    // * @param _disputeId is the dispute id;\r\n    // * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    // * the variables/strings used to save the data in the mapping. The variables names are\r\n    // * commented out under the disputeUintVars under the Dispute struct\r\n    // * @return uint value for the bytes32 data submitted\r\n    // */\r\n    // function getDisputeUintVars(TellorStorage.TellorStorageStruct storage self,uint _disputeId,bytes32 _data) internal view returns(uint){\r\n    //     return self.disputesById[_disputeId].disputeUintVars[_data];\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Gets the a value for the latest timestamp available\r\n    // * @return value for timestamp of last proof of work submited\r\n    // * @return true if the is a timestamp for the lastNewValue\r\n    // */\r\n    // function getLastNewValue(TellorStorage.TellorStorageStruct storage self) internal view returns(uint,bool){\r\n    //     return (retrieveData(self,self.requestIdByTimestamp[self.uintVars[keccak256(\"timeOfLastNewValue\")]], self.uintVars[keccak256(\"timeOfLastNewValue\")]),true);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Gets the a value for the latest timestamp available\r\n    // * @param _requestId being requested\r\n    // * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\r\n    // */\r\n    // function getLastNewValueById(TellorStorage.TellorStorageStruct storage self,uint _requestId) internal view returns(uint,bool){\r\n    //     TellorStorage.Request storage _request = self.requestDetails[_requestId];\r\n    //     if(_request.requestTimestamps.length > 0){\r\n    //         return (retrieveData(self,_requestId,_request.requestTimestamps[_request.requestTimestamps.length - 1]),true);\r\n    //     }\r\n    //     else{\r\n    //         return (0,false);\r\n    //     }\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Gets blocknumber for mined timestamp\r\n    // * @param _requestId to look up\r\n    // * @param _timestamp is the timestamp to look up blocknumber\r\n    // * @return uint of the blocknumber which the dispute was mined\r\n    // */\r\n    // function getMinedBlockNum(TellorStorage.TellorStorageStruct storage self,uint _requestId, uint _timestamp) internal view returns(uint){\r\n    //     return self.requestDetails[_requestId].minedBlockNum[_timestamp];\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    // * @param _requestId to look up\r\n    // * @param _timestamp is the timestamp to look up miners for\r\n    // * @return the 5 miners' addresses\r\n    // */\r\n    // function getMinersByRequestIdAndTimestamp(TellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns(address[5] memory){\r\n    //     return self.requestDetails[_requestId].minersByValue[_timestamp];\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Get the name of the token\r\n    // * @return string of the token name\r\n    // */\r\n    // function getName(TellorStorage.TellorStorageStruct storage self) internal pure returns(string memory){\r\n    //     return \"Tellor Tributes\";\r\n    // }\r\n\r\n\r\n    /**\r\n    * @dev Counts the number of values that have been submited for the request\r\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\r\n    * request so far\r\n    * @param _requestId the requestId to look up\r\n    * @return uint count of the number of values received for the requestId\r\n    */\r\n    function getNewValueCountbyRequestId(TellorStorage.TellorStorageStruct storage self, uint _requestId) internal view returns(uint){\r\n        return self.requestDetails[_requestId].requestTimestamps.length;\r\n    }\r\n\r\n\r\n    // /**\r\n    // * @dev Getter function for the specified requestQ index\r\n    // * @param _index to look up in the requestQ array\r\n    // * @return uint of reqeuestId\r\n    // */\r\n    // function getRequestIdByRequestQIndex(TellorStorage.TellorStorageStruct storage self, uint _index) internal view returns(uint){\r\n    //     require(_index <= 50);\r\n    //     return self.requestIdByRequestQIndex[_index];\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Getter function for requestId based on timestamp\r\n    // * @param _timestamp to check requestId\r\n    // * @return uint of reqeuestId\r\n    // */\r\n    // function getRequestIdByTimestamp(TellorStorage.TellorStorageStruct storage self, uint _timestamp) internal view returns(uint){\r\n    //     return self.requestIdByTimestamp[_timestamp];\r\n    // }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on the qeuaryHash\r\n    * @param _queryHash hash(of string api and granularity) to check if a request already exists\r\n    * @return uint requestId\r\n    */\r\n    function getRequestIdByQueryHash(TellorStorage.TellorStorageStruct storage self, bytes32 _queryHash) internal view returns(uint){\r\n        return self.requestIdByQueryHash[_queryHash];\r\n    }\r\n\r\n\r\n    // /**\r\n    // * @dev Getter function for the requestQ array\r\n    // * @return the requestQ arrray\r\n    // */\r\n    // function getRequestQ(TellorStorage.TellorStorageStruct storage self) view internal returns(uint[51] memory){\r\n    //     return self.requestQ;\r\n    // }\r\n\r\n\r\n    // *\r\n    // * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\r\n    // * for the requestId specified\r\n    // * @param _requestId to look up\r\n    // * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    // * the variables/strings used to save the data in the mapping. The variables names are\r\n    // * commented out under the apiUintVars under the requestDetails struct\r\n    // * @return uint value of the apiUintVars specified in _data for the requestId specified\r\n\r\n    // function getRequestUintVars(TellorStorage.TellorStorageStruct storage self,uint _requestId,bytes32 _data) internal view returns(uint){\r\n    //     return self.requestDetails[_requestId].apiUintVars[_data];\r\n    // }\r\n\r\n\r\n    /**\r\n    * @dev Gets the API struct variables that are not mappings\r\n    * @param _requestId to look up\r\n    * @return string of api to query\r\n    * @return string of symbol of api to query\r\n    * @return bytes32 hash of string\r\n    * @return bytes32 of the granularity(decimal places) requested\r\n    * @return uint of index in requestQ array\r\n    * @return uint of current payout/tip for this requestId\r\n    */\r\n    function getRequestVars(TellorStorage.TellorStorageStruct storage self,uint _requestId) internal view returns(string memory,string memory, bytes32,uint, uint, uint) {\r\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\r\n        return (_request.queryString,_request.dataSymbol,_request.queryHash, _request.apiUintVars[keccak256(\"granularity\")],_request.apiUintVars[keccak256(\"requestQPosition\")],_request.apiUintVars[keccak256(\"totalTip\")]);\r\n    }\r\n\r\n\r\n    // /**\r\n    // * @dev This function allows users to retireve all information about a staker\r\n    // * @param _staker address of staker inquiring about\r\n    // * @return uint current state of staker\r\n    // * @return uint startDate of staking\r\n    // */\r\n    // function getStakerInfo(TellorStorage.TellorStorageStruct storage self,address _staker) internal view returns(uint,uint){\r\n    //     return (self.stakerDetails[_staker].currentStatus,self.stakerDetails[_staker].startDate);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    // * @param _requestId to look up\r\n    // * @param _timestamp is the timestampt to look up miners for\r\n    // * @return address[5] array of 5 addresses ofminers that mined the requestId\r\n    // */\r\n    // function getSubmissionsByTimestamp(TellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns(uint[5] memory){\r\n    //     return self.requestDetails[_requestId].valuesByTimestamp[_timestamp];\r\n    // }\r\n\r\n    // /**\r\n    // * @dev Get the symbol of the token\r\n    // * @return string of the token symbol\r\n    // */\r\n    // function getSymbol(TellorStorage.TellorStorageStruct storage self) internal pure returns(string memory){\r\n    //     return \"TT\";\r\n    // }\r\n\r\n\r\n    /**\r\n    * @dev Gets the timestamp for the value based on their index\r\n    * @param _requestID is the requestId to look up\r\n    * @param _index is the value index to look up\r\n    * @return uint timestamp\r\n    */\r\n    function getTimestampbyRequestIDandIndex(TellorStorage.TellorStorageStruct storage self,uint _requestID, uint _index) internal view returns(uint){\r\n        return self.requestDetails[_requestID].requestTimestamps[_index];\r\n    }\r\n\r\n\r\n    // /**\r\n    // * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\r\n    // * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    // * the variables/strings used to save the data in the mapping. The variables names are\r\n    // * commented out under the uintVars under the TellorStorageStruct struct\r\n    // * This is an example of how data is saved into the mapping within other functions:\r\n    // * self.uintVars[keccak256(\"stakerCount\")]\r\n    // * @return uint of specified variable\r\n    // */\r\n    // function getUintVar(TellorStorage.TellorStorageStruct storage self,bytes32 _data) view internal returns(uint){\r\n    //     return self.uintVars[_data];\r\n    // }\r\n\r\n\r\n\r\n   /**\r\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\r\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\r\n    */\r\n    function getVariablesOnDeck(TellorStorage.TellorStorageStruct storage self) internal view returns(uint, uint,string memory){\r\n        uint newRequestId = getTopRequestID(self);\r\n        return (newRequestId,self.requestDetails[newRequestId].apiUintVars[keccak256(\"totalTip\")],self.requestDetails[newRequestId].queryString);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for the request with highest payout. This function is used within the getVariablesOnDeck function\r\n    * @return uint _requestId of request with highest payout at the time the function is called\r\n    */\r\n    function getTopRequestID(TellorStorage.TellorStorageStruct storage self) internal view returns(uint _requestId){\r\n            uint _max;\r\n            uint _index;\r\n            (_max,_index) = Utilities.getMax(self.requestQ);\r\n             _requestId = self.requestIdByRequestQIndex[_index];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return bool true if requestId/timestamp is under dispute\r\n    */\r\n    function isInDispute(TellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns(bool){\r\n        return self.requestDetails[_requestId].inDispute[_timestamp];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Retreive value from oracle based on requestId/timestamp\r\n    * @param _requestId being requested\r\n    * @param _timestamp to retreive data/value from\r\n    * @return uint value for requestId/timestamp submitted\r\n    */\r\n    function retrieveData(TellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns (uint) {\r\n        return self.requestDetails[_requestId].finalValues[_timestamp];\r\n    }\r\n\r\n\r\n//     /**\r\n//     * @dev Getter for the total_supply of oracle tokens\r\n//     * @return uint total supply\r\n//     */\r\n//     function totalSupply(TellorStorage.TellorStorageStruct storage self) internal view returns (uint) {\r\n//        return self.uintVars[keccak256(\"total_supply\")];\r\n//     }\r\n\r\n}\r\n\r\n/**\r\n* @title Tellor Getters\r\n* @dev Oracle contract with all tellor getter functions. The logic for the functions on this contract\r\n* is saved on the TellorGettersLibrary, TellorTransfer, TellorGettersLibrary, and TellorStake\r\n*/\r\ncontract TellorGetters{\r\n    using SafeMath for uint256;\r\n\r\n    using TellorTransfer for TellorStorage.TellorStorageStruct;\r\n    using TellorGettersLibrary for TellorStorage.TellorStorageStruct;\r\n    //using TellorStake for TellorStorage.TellorStorageStruct;\r\n\r\n    TellorStorage.TellorStorageStruct tellor;\r\n\r\n\r\n    // *\r\n    // * @param _user address\r\n    // * @param _spender address\r\n    // * @return Returns the remaining allowance of tokens granted to the _spender from the _user\r\n\r\n    // function allowance(address _user, address _spender) external view returns (uint) {\r\n    //    return tellor.allowance(_user,_spender);\r\n    // }\r\n\r\n    /**\r\n    * @dev This function returns whether or not a given user is allowed to trade a given amount\r\n    * @param _user address\r\n    * @param _amount uint of amount\r\n    * @return true if the user is alloed to trade the amount specified\r\n    */\r\n    function allowedToTrade(address _user,uint _amount) external view returns(bool){\r\n        return tellor.allowedToTrade(_user,_amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets balance of owner specified\r\n    * @param _user is the owner address used to look up the balance\r\n    * @return Returns the balance associated with the passed in _user\r\n    */\r\n    function balanceOf(address _user) external view returns (uint) {\r\n        return tellor.balanceOf(_user);\r\n    }\r\n\r\n    /**\r\n    * @dev Queries the balance of _user at a specific _blockNumber\r\n    * @param _user The address from which the balance will be retrieved\r\n    * @param _blockNumber The block number when the balance is queried\r\n    * @return The balance at _blockNumber\r\n    */\r\n    function balanceOfAt(address _user, uint _blockNumber) external view returns (uint) {\r\n        return tellor.balanceOfAt(_user,_blockNumber);\r\n    }\r\n\r\n    // /**\r\n    // * @dev This function tells you if a given challenge has been completed by a given miner\r\n    // * @param _challenge the challenge to search for\r\n    // * @param _miner address that you want to know if they solved the challenge\r\n    // * @return true if the _miner address provided solved the\r\n    // */\r\n    // function didMine(bytes32 _challenge, address _miner) external view returns(bool){\r\n    //     return tellor.didMine(_challenge,_miner);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Checks if an address voted in a given dispute\r\n    // * @param _disputeId to look up\r\n    // * @param _address to look up\r\n    // * @return bool of whether or not party voted\r\n    // */\r\n    // function didVote(uint _disputeId, address _address) external view returns(bool){\r\n    //     return tellor.didVote(_disputeId,_address);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev allows Tellor to read data from the addressVars mapping\r\n    // * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\r\n    // * These are examples of how the variables are saved within other functions:\r\n    // * addressVars[keccak256(\"_owner\")]\r\n    // * addressVars[keccak256(\"tellorContract\")]\r\n    // */\r\n    // function getAddressVars(bytes32 _data) view external returns(address){\r\n    //     return tellor.getAddressVars(_data);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Gets all dispute variables\r\n    // * @param _disputeId to look up\r\n    // * @return bytes32 hash of dispute\r\n    // * @return bool executed where true if it has been voted on\r\n    // * @return bool disputeVotePassed\r\n    // * @return bool isPropFork true if the dispute is a proposed fork\r\n    // * @return address of reportedMiner\r\n    // * @return address of reportingParty\r\n    // * @return address of proposedForkAddress\r\n    // * @return uint of requestId\r\n    // * @return uint of timestamp\r\n    // * @return uint of value\r\n    // * @return uint of minExecutionDate\r\n    // * @return uint of numberOfVotes\r\n    // * @return uint of blocknumber\r\n    // * @return uint of minerSlot\r\n    // * @return uint of quorum\r\n    // * @return uint of fee\r\n    // * @return int count of the current tally\r\n    // */\r\n    // function getAllDisputeVars(uint _disputeId) public view returns(bytes32, bool, bool, bool, address, address, address,uint[9] memory, int){\r\n    //     return tellor.getAllDisputeVars(_disputeId);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\r\n    // * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\r\n    // */\r\n    // function getCurrentVariables() external view returns(bytes32, uint, uint,string memory,uint,uint){\r\n    //     return tellor.getCurrentVariables();\r\n    // }\r\n\r\n    // *\r\n    // * @dev Checks if a given hash of miner,requestId has been disputed\r\n    // * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\r\n    // * @return uint disputeId\r\n\r\n    // function getDisputeIdByDisputeHash(bytes32 _hash) external view returns(uint){\r\n    //     return  tellor.getDisputeIdByDisputeHash(_hash);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\r\n    // * @param _disputeId is the dispute id;\r\n    // * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    // * the variables/strings used to save the data in the mapping. The variables names are\r\n    // * commented out under the disputeUintVars under the Dispute struct\r\n    // * @return uint value for the bytes32 data submitted\r\n    // */\r\n    // function getDisputeUintVars(uint _disputeId,bytes32 _data) external view returns(uint){\r\n    //     return tellor.getDisputeUintVars(_disputeId,_data);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Gets the a value for the latest timestamp available\r\n    // * @return value for timestamp of last proof of work submited\r\n    // * @return true if the is a timestamp for the lastNewValue\r\n    // */\r\n    // function getLastNewValue() external view returns(uint,bool){\r\n    //     return tellor.getLastNewValue();\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Gets the a value for the latest timestamp available\r\n    // * @param _requestId being requested\r\n    // * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\r\n    // */\r\n    // function getLastNewValueById(uint _requestId) external view returns(uint,bool){\r\n    //     return tellor.getLastNewValueById(_requestId);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Gets blocknumber for mined timestamp\r\n    // * @param _requestId to look up\r\n    // * @param _timestamp is the timestamp to look up blocknumber\r\n    // * @return uint of the blocknumber which the dispute was mined\r\n    // */\r\n    // function getMinedBlockNum(uint _requestId, uint _timestamp) external view returns(uint){\r\n    //     return tellor.getMinedBlockNum(_requestId,_timestamp);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    // * @param _requestId to look up\r\n    // * @param _timestamp is the timestamp to look up miners for\r\n    // * @return the 5 miners' addresses\r\n    // */\r\n    // function getMinersByRequestIdAndTimestamp(uint _requestId, uint _timestamp) external view returns(address[5] memory){\r\n    //     return tellor.getMinersByRequestIdAndTimestamp(_requestId,_timestamp);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Get the name of the token\r\n    // * return string of the token name\r\n    // */\r\n    // function getName() external view returns(string memory){\r\n    //     return tellor.getName();\r\n    // }\r\n\r\n\r\n    /**\r\n    * @dev Counts the number of values that have been submited for the request\r\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\r\n    * request so far\r\n    * @param _requestId the requestId to look up\r\n    * @return uint count of the number of values received for the requestId\r\n    */\r\n    function getNewValueCountbyRequestId(uint _requestId) external view returns(uint){\r\n        return tellor.getNewValueCountbyRequestId(_requestId);\r\n    }\r\n\r\n\r\n    // /**\r\n    // * @dev Getter function for the specified requestQ index\r\n    // * @param _index to look up in the requestQ array\r\n    // * @return uint of reqeuestId\r\n    // */\r\n    // function getRequestIdByRequestQIndex(uint _index) external view returns(uint){\r\n    //     return tellor.getRequestIdByRequestQIndex(_index);\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Getter function for requestId based on timestamp\r\n    // * @param _timestamp to check requestId\r\n    // * @return uint of reqeuestId\r\n    // */\r\n    // function getRequestIdByTimestamp(uint _timestamp) external view returns(uint){\r\n    //     return tellor.getRequestIdByTimestamp(_timestamp);\r\n    // }\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on the queryHash\r\n    * @param _request is the hash(of string api and granularity) to check if a request already exists\r\n    * @return uint requestId\r\n    */\r\n    function getRequestIdByQueryHash(bytes32 _request) external view returns(uint){\r\n        return tellor.getRequestIdByQueryHash(_request);\r\n    }\r\n\r\n\r\n    // /**\r\n    // * @dev Getter function for the requestQ array\r\n    // * @return the requestQ arrray\r\n    // */\r\n    // function getRequestQ() view public returns(uint[51] memory){\r\n    //     return tellor.getRequestQ();\r\n    // }\r\n\r\n\r\n    // /**\r\n    // * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\r\n    // * for the requestId specified\r\n    // * @param _requestId to look up\r\n    // * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    // * the variables/strings used to save the data in the mapping. The variables names are\r\n    // * commented out under the apiUintVars under the requestDetails struct\r\n    // * @return uint value of the apiUintVars specified in _data for the requestId specified\r\n    // */\r\n    // function getRequestUintVars(uint _requestId,bytes32 _data) external view returns(uint){\r\n    //     return tellor.getRequestUintVars(_requestId,_data);\r\n    // }\r\n\r\n\r\n    /**\r\n    * @dev Gets the API struct variables that are not mappings\r\n    * @param _requestId to look up\r\n    * @return string of api to query\r\n    * @return string of symbol of api to query\r\n    * @return bytes32 hash of string\r\n    * @return bytes32 of the granularity(decimal places) requested\r\n    * @return uint of index in requestQ array\r\n    * @return uint of current payout/tip for this requestId\r\n    */\r\n    function getRequestVars(uint _requestId) external view returns(string memory, string memory,bytes32,uint, uint, uint) {\r\n        return tellor.getRequestVars(_requestId);\r\n    }\r\n\r\n\r\n    // /**\r\n    // * @dev This function allows users to retireve all information about a staker\r\n    // * @param _staker address of staker inquiring about\r\n    // * @return uint current state of staker\r\n    // * @return uint startDate of staking\r\n    // */\r\n    // function getStakerInfo(address _staker) external view returns(uint,uint){\r\n    //     return tellor.getStakerInfo(_staker);\r\n    // }\r\n\r\n    // /**\r\n    // * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    // * @param _requestId to look up\r\n    // * @param _timestamp is the timestampt to look up miners for\r\n    // * @return address[5] array of 5 addresses ofminers that mined the requestId\r\n    // */\r\n    // function getSubmissionsByTimestamp(uint _requestId, uint _timestamp) external view returns(uint[5] memory){\r\n    //     return tellor.getSubmissionsByTimestamp(_requestId,_timestamp);\r\n    // }\r\n\r\n    // /**\r\n    // * @dev Get the symbol of the token\r\n    // * return string of the token symbol\r\n    // */\r\n    // function getSymbol() external view returns(string memory){\r\n    //     return tellor.getSymbol();\r\n    // }\r\n\r\n    /**\r\n    * @dev Gets the timestamp for the value based on their index\r\n    * @param _requestID is the requestId to look up\r\n    * @param _index is the value index to look up\r\n    * @return uint timestamp\r\n    */\r\n    function getTimestampbyRequestIDandIndex(uint _requestID, uint _index) external view returns(uint){\r\n        return tellor.getTimestampbyRequestIDandIndex(_requestID,_index);\r\n    }\r\n\r\n\r\n    // /**\r\n    // * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\r\n    // * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    // * the variables/strings used to save the data in the mapping. The variables names are\r\n    // * commented out under the uintVars under the TellorStorageStruct struct\r\n    // * This is an example of how data is saved into the mapping within other functions:\r\n    // * self.uintVars[keccak256(\"stakerCount\")]\r\n    // * @return uint of specified variable\r\n    // */\r\n    // function getUintVar(bytes32 _data) view public returns(uint){\r\n    //     return tellor.getUintVar(_data);\r\n    // }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\r\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\r\n    */\r\n    function getVariablesOnDeck() external view returns(uint, uint,string memory){\r\n        return tellor.getVariablesOnDeck();\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return bool true if requestId/timestamp is under dispute\r\n    */\r\n    function isInDispute(uint _requestId, uint _timestamp) external view returns(bool){\r\n        return tellor.isInDispute(_requestId,_timestamp);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Retreive value from oracle based on timestamp\r\n    * @param _requestId being requested\r\n    * @param _timestamp to retreive data/value from\r\n    * @return value for timestamp submitted\r\n    */\r\n    function retrieveData(uint _requestId, uint _timestamp) external view returns (uint) {\r\n        return tellor.retrieveData(_requestId,_timestamp);\r\n    }\r\n\r\n\r\n    // *\r\n    // * @dev Getter for the total_supply of oracle tokens\r\n    // * @return uint total supply\r\n\r\n    // function totalSupply() external view returns (uint) {\r\n    //    return tellor.totalSupply();\r\n    // }\r\n\r\n\r\n}\r\n\r\n/**** TellorMaster Test Contract***/\r\n/*WARNING: This contract is used for the delegate calls to the Test Tellor contract\r\n           wich excludes mining for testing purposes\r\n           This has bee adapted for projects testing Tellor integration\r\n\r\n**/\r\n\r\n\r\n/**\r\n* @title Tellor Master\r\n* @dev This is the Master contract with all tellor getter functions and delegate call to Tellor.\r\n* The logic for the functions on this contract is saved on the TellorGettersLibrary, TellorTransfer,\r\n* TellorGettersLibrary, and TellorStake\r\n*/\r\ncontract TellorMaster is TellorGetters{\r\n\r\n    event NewTellorAddress(address _newTellor);\r\n\r\n    /**\r\n    * @dev The constructor sets the original `tellorStorageOwner` of the contract to the sender\r\n    * account, the tellor contract to the Tellor master address and owner to the Tellor master owner address\r\n    * @param _tellorContract is the address for the tellor contract\r\n    */\r\n    constructor (address _tellorContract)  public{\r\n        init();\r\n        tellor.addressVars[keccak256(\"_owner\")] = msg.sender;\r\n        tellor.addressVars[keccak256(\"_deity\")] = msg.sender;\r\n        tellor.addressVars[keccak256(\"tellorContract\")]= _tellorContract;\r\n        emit NewTellorAddress(_tellorContract);\r\n    }\r\n\r\n    /**\r\n    * @dev This function stakes the five initial miners, sets the supply and all the constant variables.\r\n    * This function is called by the constructor function on TellorMaster.sol\r\n    */\r\n    function init() internal {\r\n        require(tellor.uintVars[keccak256(\"decimals\")] == 0);\r\n        //Give this contract 6000 Tellor Tributes so that it can stake the initial 6 miners\r\n        TellorTransfer.updateBalanceAtNow(tellor.balances[address(this)], 2**256-1 - 6000e18);\r\n\r\n        // //the initial 5 miner addresses are specfied below\r\n        // //changed payable[5] to 6\r\n        address payable[6] memory _initalMiners = [address(0xE037EC8EC9ec423826750853899394dE7F024fee),\r\n        address(0xcdd8FA31AF8475574B8909F135d510579a8087d3),\r\n        address(0xb9dD5AfD86547Df817DA2d0Fb89334A6F8eDd891),\r\n        address(0x230570cD052f40E14C14a81038c6f3aa685d712B),\r\n        address(0x3233afA02644CCd048587F8ba6e99b3C00A34DcC),\r\n        address(0xe010aC6e0248790e08F42d5F697160DEDf97E024)];\r\n        //Stake each of the 5 miners specified above\r\n        for(uint i=0;i<6;i++){//6th miner to allow for dispute\r\n            //Miner balance is set at 1000e18 at the block that this function is ran\r\n            TellorTransfer.updateBalanceAtNow(tellor.balances[_initalMiners[i]],1000e18);\r\n\r\n            //newStake(self, _initalMiners[i]);\r\n        }\r\n\r\n        //update the total suppply\r\n        tellor.uintVars[keccak256(\"total_supply\")] += 6000e18;//6th miner to allow for dispute\r\n        //set Constants\r\n        tellor.uintVars[keccak256(\"decimals\")] = 18;\r\n        tellor.uintVars[keccak256(\"targetMiners\")] = 200;\r\n        tellor.uintVars[keccak256(\"stakeAmount\")] = 1000e18;\r\n        tellor.uintVars[keccak256(\"disputeFee\")] = 970e18;\r\n        tellor.uintVars[keccak256(\"timeTarget\")]= 600;\r\n        tellor.uintVars[keccak256(\"timeOfLastNewValue\")] = now - now  % tellor.uintVars[keccak256(\"timeTarget\")];\r\n        tellor.uintVars[keccak256(\"difficulty\")] = 1;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @dev Only needs to be in library\r\n    * @param _newDeity the new Deity in the contract\r\n    */\r\n\r\n    function changeDeity(address _newDeity) external{\r\n        tellor.changeDeity(_newDeity);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev  allows for the deity to make fast upgrades.  Deity should be 0 address if decentralized\r\n    * @param _tellorContract the address of the new Tellor Contract\r\n    */\r\n    function changeTellorContract(address _tellorContract) external{\r\n        tellor.changeTellorContract(_tellorContract);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev This is the fallback function that allows contracts to call the tellor contract at the address stored\r\n    */\r\n    function () external payable {\r\n        address addr = tellor.addressVars[keccak256(\"tellorContract\")];\r\n        bytes memory _calldata = msg.data;\r\n        assembly {\r\n            let result := delegatecall(not(0), addr, add(_calldata, 0x20), mload(_calldata), 0, 0)\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n * @title Price/numeric Pull Oracle mapping contract\r\n*/\r\n\r\ncontract OracleIDDescriptions {\r\n\r\n    /*Variables*/\r\n    mapping(uint=>bytes32) tellorIDtoBytesID;\r\n    mapping(bytes32 => uint) bytesIDtoTellorID;\r\n    mapping(uint => uint) tellorCodeToStatusCode;\r\n    mapping(uint => uint) statusCodeToTellorCode;\r\n    mapping(uint => int) tellorIdtoAdjFactor;\r\n\r\n    /*Events*/\r\n    event TellorIdMappedToBytes(uint _requestID, bytes32 _id);\r\n    event StatusMapped(uint _tellorStatus, uint _status);\r\n    event AdjFactorMapped(uint _requestID, int _adjFactor);\r\n\r\n\r\n    /**\r\n    * @dev This function allows the user to map the tellor's Id to it's _adjFactor and\r\n    * to match the standarized granularity\r\n    * @param _tellorId uint the tellor status\r\n    * @param _adjFactor is 1eN where N is the number of decimals to convert to ADO standard\r\n    */\r\n    function defineTellorIdtoAdjFactor(uint _tellorId, int _adjFactor) external{\r\n        require(tellorIdtoAdjFactor[_tellorId] == 0, \"Already Set\");\r\n        tellorIdtoAdjFactor[_tellorId] = _adjFactor;\r\n        emit AdjFactorMapped(_tellorId, _adjFactor);\r\n    }\r\n\r\n    /**\r\n    * @dev This function allows the user to map the tellor uint data status code to the standarized\r\n    * ADO uint status code such as null, retreived etc...\r\n    * @param _tellorStatus uint the tellor status\r\n    * @param _status the ADO standarized uint status\r\n    */\r\n    function defineTellorCodeToStatusCode(uint _tellorStatus, uint _status) external{\r\n        require(tellorCodeToStatusCode[_tellorStatus] == 0, \"Already Set\");\r\n        tellorCodeToStatusCode[_tellorStatus] = _status;\r\n        statusCodeToTellorCode[_status] = _tellorStatus;\r\n        emit StatusMapped(_tellorStatus, _status);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows user to map the standarized bytes32 Id to a specific requestID from Tellor\r\n    * The dev should ensure the _requestId exists otherwise request the data on Tellor to get a requestId\r\n    * @param _requestID is the existing Tellor RequestID\r\n    * @param _id is the descption of the ID in bytes\r\n    */\r\n    function defineTellorIdToBytesID(uint _requestID, bytes32 _id) external{\r\n        require(tellorIDtoBytesID[_requestID] == bytes32(0), \"Already Set\");\r\n        tellorIDtoBytesID[_requestID] = _id;\r\n        bytesIDtoTellorID[_id] = _requestID;\r\n        emit TellorIdMappedToBytes(_requestID,_id);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for the uint Tellor status code from the specified uint ADO standarized status code\r\n    * @param _status the uint ADO standarized status\r\n    * @return _tellorStatus uint\r\n    */\r\n    function getTellorStatusFromStatus(uint _status) public view returns(uint _tellorStatus){\r\n        return statusCodeToTellorCode[_status];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function of the uint ADO standarized status code from the specified Tellor uint status\r\n    * @param _tellorStatus uint\r\n    * @return _status the uint ADO standarized status\r\n    */\r\n    function getStatusFromTellorStatus (uint _tellorStatus) public view returns(uint _status) {\r\n        return tellorCodeToStatusCode[_tellorStatus];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function of the Tellor RequestID based on the specified bytes32 ADO standaraized _id\r\n    * @param _id is the bytes32 descriptor mapped to an existing Tellor's requestId\r\n    * @return _requestId is Tellor's requestID corresnpoding to _id\r\n    */\r\n    function getTellorIdFromBytes(bytes32 _id) public view  returns(uint _requestId)  {\r\n       return bytesIDtoTellorID[_id];\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function of the Tellor RequestID based on the specified bytes32 ADO standaraized _id\r\n    * @param _id is the bytes32 descriptor mapped to an existing Tellor's requestId\r\n    * @return _requestId is Tellor's requestID corresnpoding to _id\r\n    */\r\n    function getGranularityAdjFactor(bytes32 _id) public view  returns(int adjFactor)  {\r\n       uint requestID = bytesIDtoTellorID[_id];\r\n       adjFactor = tellorIdtoAdjFactor[requestID];\r\n       return adjFactor;\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function of the bytes32 ADO standaraized _id based on the specified Tellor RequestID\r\n    * @param _requestId is Tellor's requestID\r\n    * @return _id is the bytes32 descriptor mapped to an existing Tellor's requestId\r\n    */\r\n    function getBytesFromTellorID(uint _requestId) public view returns(bytes32 _id) {\r\n        return tellorIDtoBytesID[_requestId];\r\n    }\r\n\r\n}\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n/**\r\n    * @dev EIP2362 Interface for pull oracles\r\n    * https://github.com/tellor-io/EIP-2362\r\n*/\r\ninterface EIP2362Interface{\r\n    /**\r\n        * @dev Exposed function pertaining to EIP standards\r\n        * @param _id bytes32 ID of the query\r\n        * @return int,uint,uint returns the value, timestamp, and status code of query\r\n    */\r\n    function valueFor(bytes32 _id) external view returns(int256,uint256,uint256);\r\n}\r\n\r\n\r\n/**\r\n* @title UserContract\r\n* This contracts creates for easy integration to the Tellor System\r\n* by allowing smart contracts to read data off Tellor\r\n*/\r\ncontract UsingTellor is EIP2362Interface{\r\n    address payable public tellorStorageAddress;\r\n    address public oracleIDDescriptionsAddress;\r\n    TellorMaster _tellorm;\r\n    OracleIDDescriptions descriptions;\r\n\r\n    event NewDescriptorSet(address _descriptorSet);\r\n\r\n    /*Constructor*/\r\n    /**\r\n    * @dev the constructor sets the storage address and owner\r\n    * @param _storage is the TellorMaster address\r\n    */\r\n    constructor(address payable _storage) public {\r\n        tellorStorageAddress = _storage;\r\n        _tellorm = TellorMaster(tellorStorageAddress);\r\n    }\r\n\r\n    /*Functions*/\r\n    /*\r\n    * @dev Allows the owner to set the address for the oracleID descriptors\r\n    * used by the ADO members for price key value pairs standarization\r\n    * _oracleDescriptors is the address for the OracleIDDescriptions contract\r\n    */\r\n    function setOracleIDDescriptors(address _oracleDescriptors) external {\r\n        require(oracleIDDescriptionsAddress == address(0), \"Already Set\");\r\n        oracleIDDescriptionsAddress = _oracleDescriptors;\r\n        descriptions = OracleIDDescriptions(_oracleDescriptors);\r\n        emit NewDescriptorSet(_oracleDescriptors);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to get the latest value for the requestId specified\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @return bool true if it is able to retreive a value, the value, and the value's timestamp\r\n    */\r\n    function getCurrentValue(uint256 _requestId) public view returns (bool ifRetrieve, uint256 value, uint256 _timestampRetrieved) {\r\n        return getDataBefore(_requestId,now,1,0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to get the latest value for the requestId specified using the\r\n    * ADO specification for the standard inteface for price oracles\r\n    * @param _bytesId is the ADO standarized bytes32 price/key value pair identifier\r\n    * @return the timestamp, outcome or value/ and the status code (for retreived, null, etc...)\r\n    */\r\n    function valueFor(bytes32 _bytesId) external view returns (int value, uint256 timestamp, uint status) {\r\n        uint _id = descriptions.getTellorIdFromBytes(_bytesId);\r\n        int n = descriptions.getGranularityAdjFactor(_bytesId);\r\n        if (_id > 0){\r\n            bool _didGet;\r\n            uint256 _returnedValue;\r\n            uint256 _timestampRetrieved;\r\n            (_didGet,_returnedValue,_timestampRetrieved) = getDataBefore(_id,now,1,0);\r\n            if(_didGet){\r\n                return (int(_returnedValue)*n,_timestampRetrieved, descriptions.getStatusFromTellorStatus(1));\r\n            }\r\n            else{\r\n                return (0,0,descriptions.getStatusFromTellorStatus(2));\r\n            }\r\n        }\r\n        return (0, 0, descriptions.getStatusFromTellorStatus(0));\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to get the first value for the requestId before the specified timestamp\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @param _timestamp before which to search for first verified value\r\n    * @param _limit a limit on the number of values to look at\r\n    * @param _offset the number of values to go back before looking for data values\r\n    * @return bool true if it is able to retreive a value, the value, and the value's timestamp\r\n    */\r\n    function getDataBefore(uint256 _requestId, uint256 _timestamp, uint256 _limit, uint256 _offset)\r\n        public\r\n        view\r\n        returns (bool _ifRetrieve, uint256 _value, uint256 _timestampRetrieved)\r\n    {\r\n        uint256 _count = _tellorm.getNewValueCountbyRequestId(_requestId) - _offset;\r\n        if (_count > 0) {\r\n            for (uint256 i = _count; i > _count - _limit; i--) {\r\n                uint256 _time = _tellorm.getTimestampbyRequestIDandIndex(_requestId, i - 1);\r\n                if (_time > 0 && _time <= _timestamp && _tellorm.isInDispute(_requestId,_time) == false) {\r\n                    return (true, _tellorm.retrieveData(_requestId, _time), _time);\r\n                }\r\n            }\r\n        }\r\n        return (false, 0, 0);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract BankStorage{\r\n  /*Variables*/\r\n  struct Reserve {\r\n    uint256 collateralBalance;\r\n    uint256 debtBalance;\r\n    uint256 interestRate;\r\n    uint256 originationFee;\r\n    uint256 collateralizationRatio;\r\n    uint256 liquidationPenalty;\r\n    address oracleContract;\r\n    uint256 period;\r\n  }\r\n\r\n  struct Token {\r\n    address tokenAddress;\r\n    uint256 price;\r\n    uint256 priceGranularity;\r\n    uint256 tellorRequestId;\r\n    uint256 reserveBalance;\r\n  }\r\n\r\n  struct Vault {\r\n    uint256 collateralAmount;\r\n    uint256 debtAmount;\r\n    uint256 createdAt;\r\n  }\r\n\r\n  mapping (address => Vault) public vaults;\r\n  Token debt;\r\n  Token collateral;\r\n  Reserve reserve;\r\n\r\n\r\n  /**\r\n  * @dev Getter function for the current interest rate\r\n  * @return interest rate\r\n  */\r\n  function getInterestRate() public view returns (uint256) {\r\n    return reserve.interestRate;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the origination fee\r\n  * @return origination fee\r\n  */\r\n  function getOriginationFee() public view returns (uint256) {\r\n    return reserve.originationFee;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the current collateralization ratio\r\n  * @return collateralization ratio\r\n  */\r\n  function getCollateralizationRatio() public view returns (uint256) {\r\n    return reserve.collateralizationRatio;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the liquidation penalty\r\n  * @return liquidation penalty\r\n  */\r\n  function getLiquidationPenalty() public view returns (uint256) {\r\n    return reserve.liquidationPenalty;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for debt token address\r\n  * @return debt token price\r\n  */\r\n  function getDebtTokenAddress() public view returns (address) {\r\n    return debt.tokenAddress;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the debt token(reserve) price\r\n  * @return debt token price\r\n  */\r\n  function getDebtTokenPrice() public view returns (uint256) {\r\n    return debt.price;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the debt token price granularity\r\n  * @return debt token price granularity\r\n  */\r\n  function getDebtTokenPriceGranularity() public view returns (uint256) {\r\n    return debt.priceGranularity;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for debt token address\r\n  * @return debt token price\r\n  */\r\n  function getCollateralTokenAddress() public view returns (address) {\r\n    return collateral.tokenAddress;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the collateral token price\r\n  * @return collateral token price\r\n  */\r\n  function getCollateralTokenPrice() public view returns (uint256) {\r\n    return collateral.price;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the collateral token price granularity\r\n  * @return collateral token price granularity\r\n  */\r\n  function getCollateralTokenPriceGranularity() public view returns (uint256) {\r\n    return collateral.priceGranularity;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the debt token(reserve) balance\r\n  * @return debt reserve balance\r\n  */\r\n  function getReserveBalance() public view returns (uint256) {\r\n    return reserve.debtBalance;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the debt reserve collateral balance\r\n  * @return collateral reserve balance\r\n  */\r\n  function getReserveCollateralBalance() public view returns (uint256) {\r\n    return reserve.collateralBalance;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the user's vault collateral amount\r\n  * @return collateral amount\r\n  */\r\n  function getVaultCollateralAmount() public view returns (uint256) {\r\n    return vaults[msg.sender].collateralAmount;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the user's vault debt amount\r\n  * @return debt amount\r\n  */\r\n  function getVaultDebtAmount() public view returns (uint256) {\r\n    return vaults[msg.sender].debtAmount;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the user's vault debt amount\r\n  *   uses a simple interest formula (i.e. not compound  interest)\r\n  * @return debt amount\r\n  */\r\n  function getVaultRepayAmount() public view returns (uint256 principal) {\r\n    principal = vaults[msg.sender].debtAmount;\r\n    uint256 periodsPerYear = 365 days / reserve.period;\r\n    uint256 periodsElapsed = (block.timestamp / reserve.period) - (vaults[msg.sender].createdAt / reserve.period);\r\n    principal += principal * reserve.interestRate / 100 / periodsPerYear * periodsElapsed;\r\n  }\r\n\r\n  /**\r\n  * @dev Getter function for the collateralization ratio\r\n  * @return collateralization ratio\r\n  */\r\n  function getVaultCollateralizationRatio(address vaultOwner) public view returns (uint256) {\r\n    if(vaults[vaultOwner].debtAmount == 0 ){\r\n      return 0;\r\n    } else {\r\n      return _percent(vaults[vaultOwner].collateralAmount * collateral.price * 1000 / collateral.priceGranularity,\r\n                      vaults[vaultOwner].debtAmount * debt.price * 1000 / debt.priceGranularity,\r\n                      4);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev This function calculates the percent of the given numerator, denominator to the\r\n  * specified precision\r\n  * @return _quotient\r\n  */\r\n  function _percent(uint numerator, uint denominator, uint precision) private pure returns(uint256 _quotient) {\r\n        _quotient =  ((numerator * 10 ** (precision+1) / denominator) + 5) / 10;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n* @title Bank\r\n* This contract allows the owner to deposit reserves(debt token), earn interest and\r\n* origination fees from users that borrow against their collateral.\r\n* The oracle for Bank is Tellor.\r\n*/\r\ncontract Bank is BankStorage, Ownable, UsingTellor {\r\n  /*Events*/\r\n  event ReserveDeposit(uint256 amount);\r\n  event ReserveWithdraw(address token, uint256 amount);\r\n  event VaultDeposit(address owner, uint256 amount);\r\n  event VaultBorrow(address borrower, uint256 amount);\r\n  event VaultRepay(address borrower, uint256 amount);\r\n  event VaultWithdraw(address borrower, uint256 amount);\r\n  event PriceUpdate(address token, uint256 price);\r\n  event Liquidation(address borrower, uint256 debtAmount);\r\n\r\n  /*Constructor*/\r\n  constructor(\r\n    uint256 interestRate,\r\n    uint256 originationFee,\r\n    uint256 collateralizationRatio,\r\n    uint256 liquidationPenalty,\r\n    uint256 period,\r\n    address collateralToken,\r\n    uint256 collateralTokenTellorRequestId,\r\n    uint256 collateralTokenPriceGranularity,\r\n    uint256 collateralTokenPrice,\r\n    address debtToken,\r\n    uint256 debtTokenTellorRequestId,\r\n    uint256 debtTokenPriceGranularity,\r\n    uint256 debtTokenPrice,\r\n    address payable oracleContract ) public UsingTellor(oracleContract) {\r\n    reserve.interestRate = interestRate;\r\n    reserve.originationFee = originationFee;\r\n    reserve.collateralizationRatio = collateralizationRatio;\r\n    reserve.liquidationPenalty = liquidationPenalty;\r\n    reserve.period = period;\r\n    debt.tokenAddress = debtToken;\r\n    debt.price = debtTokenPrice;\r\n    debt.priceGranularity = debtTokenPriceGranularity;\r\n    debt.tellorRequestId = debtTokenTellorRequestId;\r\n    collateral.tokenAddress = collateralToken;\r\n    collateral.price = collateralTokenPrice;\r\n    collateral.priceGranularity = collateralTokenPriceGranularity;\r\n    collateral.tellorRequestId = collateralTokenTellorRequestId;\r\n    reserve.oracleContract = oracleContract;\r\n  }\r\n\r\n  /*Functions*/\r\n  /**\r\n  * @dev This function allows the Bank owner to deposit the reserve (debt tokens)\r\n  * @param amount is the amount to deposit\r\n  */\r\n  function reserveDeposit(uint256 amount) external onlyOwner {\r\n    require(IERC20(debt.tokenAddress).transferFrom(msg.sender, address(this), amount));\r\n    reserve.debtBalance += amount;\r\n    emit ReserveDeposit(amount);\r\n  }\r\n\r\n  /**\r\n  * @dev This function allows the Bank owner to withdraw the reserve (debt tokens)\r\n  * @param amount is the amount to withdraw\r\n  */\r\n  function reserveWithdraw(uint256 amount) external onlyOwner {\r\n    require(reserve.debtBalance >= amount, \"NOT ENOUGH DEBT TOKENS IN RESERVE\");\r\n    require(IERC20(debt.tokenAddress).transfer(msg.sender, amount));\r\n    reserve.debtBalance -= amount;\r\n    emit ReserveWithdraw(debt.tokenAddress, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev This function allows the user to withdraw their collateral\r\n  * @param amount is the amount to withdraw\r\n  */\r\n  function reserveWithdrawCollateral(uint256 amount) external onlyOwner {\r\n    require(reserve.collateralBalance >= amount, \"NOT ENOUGH COLLATERAL IN RESERVE\");\r\n    require(IERC20(collateral.tokenAddress).transfer(msg.sender, amount));\r\n    reserve.collateralBalance -= amount;\r\n    emit ReserveWithdraw(collateral.tokenAddress, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Use this function to get and update the price for the collateral token\r\n  * using the Tellor Oracle.\r\n  */\r\n  function updateCollateralPrice() external {\r\n    bool ifRetrieve;\r\n    uint256 _timestampRetrieved;\r\n    (ifRetrieve, collateral.price, _timestampRetrieved) = getCurrentValue(collateral.tellorRequestId); //,now - 1 hours);\r\n    emit PriceUpdate(collateral.tokenAddress, collateral.price);\r\n  }\r\n\r\n  /**\r\n  * @dev Use this function to get and update the price for the debt token\r\n  * using the Tellor Oracle.\r\n  */\r\n  function updateDebtPrice() external {\r\n    bool ifRetrieve;\r\n    uint256 _timestampRetrieved;\r\n    (ifRetrieve, debt.price, _timestampRetrieved) = getCurrentValue(debt.tellorRequestId); //,now - 1 hours);\r\n    emit PriceUpdate(debt.tokenAddress, debt.price);\r\n  }\r\n\r\n  /**\r\n  * @dev Anyone can use this function to liquidate a vault's debt,\r\n  * the bank owner gets the collateral liquidated\r\n  * @param vaultOwner is the user the bank owner wants to liquidate\r\n  */\r\n  function liquidate(address vaultOwner) external {\r\n    // Require undercollateralization\r\n    require(getVaultCollateralizationRatio(vaultOwner) < reserve.collateralizationRatio * 100, \"VAULT NOT UNDERCOLLATERALIZED\");\r\n    uint256 debtOwned = vaults[vaultOwner].debtAmount + (vaults[vaultOwner].debtAmount * 100 * reserve.liquidationPenalty / 100 / 100);\r\n    uint256 collateralToLiquidate = debtOwned * debt.price / collateral.price;\r\n\r\n    if(collateralToLiquidate <= vaults[vaultOwner].collateralAmount) {\r\n      reserve.collateralBalance +=  collateralToLiquidate;\r\n      vaults[vaultOwner].collateralAmount -= collateralToLiquidate;\r\n    } else {\r\n      reserve.collateralBalance +=  vaults[vaultOwner].collateralAmount;\r\n      vaults[vaultOwner].collateralAmount = 0;\r\n    }\r\n    reserve.debtBalance += vaults[vaultOwner].debtAmount;\r\n    vaults[vaultOwner].debtAmount = 0;\r\n    emit Liquidation(vaultOwner, debtOwned);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Use this function to allow users to deposit collateral to the vault\r\n  * @param amount is the collateral amount\r\n  */\r\n  function vaultDeposit(uint256 amount) external {\r\n    require(IERC20(collateral.tokenAddress).transferFrom(msg.sender, address(this), amount));\r\n    vaults[msg.sender].collateralAmount += amount;\r\n    emit VaultDeposit(msg.sender, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Use this function to allow users to borrow against their collateral\r\n  * @param amount to borrow\r\n  */\r\n  function vaultBorrow(uint256 amount) external {\r\n    if (vaults[msg.sender].debtAmount != 0) {\r\n      vaults[msg.sender].debtAmount = getVaultRepayAmount();\r\n    }\r\n    uint256 maxBorrow = vaults[msg.sender].collateralAmount * collateral.price / debt.price / reserve.collateralizationRatio * 100;\r\n    maxBorrow *= debt.priceGranularity;\r\n    maxBorrow /= collateral.priceGranularity;\r\n    maxBorrow -= vaults[msg.sender].debtAmount;\r\n    require(amount < maxBorrow, \"NOT ENOUGH COLLATERAL\");\r\n    require(amount <= reserve.debtBalance, \"NOT ENOUGH RESERVES\");\r\n    vaults[msg.sender].debtAmount += amount + ((amount * reserve.originationFee) / 100);\r\n    if (block.timestamp - vaults[msg.sender].createdAt > reserve.period) {\r\n      // Only adjust if more than 1 interest rate period has past\r\n      vaults[msg.sender].createdAt = block.timestamp;\r\n    }\r\n    reserve.debtBalance -= amount;\r\n    require(IERC20(debt.tokenAddress).transfer(msg.sender, amount));\r\n    emit VaultBorrow(msg.sender, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev This function allows users to pay the interest and origination fee to the\r\n  *  vault before being able to withdraw\r\n  * @param amount owed\r\n  */\r\n  function vaultRepay(uint256 amount) external {\r\n    vaults[msg.sender].debtAmount = getVaultRepayAmount();\r\n    require(amount <= vaults[msg.sender].debtAmount, \"CANNOT REPAY MORE THAN OWED\");\r\n    require(IERC20(debt.tokenAddress).transferFrom(msg.sender, address(this), amount));\r\n    vaults[msg.sender].debtAmount -= amount;\r\n    reserve.debtBalance += amount;\r\n    uint256 periodsElapsed = (block.timestamp / reserve.period) - (vaults[msg.sender].createdAt / reserve.period);\r\n    vaults[msg.sender].createdAt += periodsElapsed * reserve.period;\r\n    emit VaultRepay(msg.sender, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Allows users to withdraw their collateral from the vault\r\n  */\r\n  function vaultWithdraw(uint256 amount) external {\r\n    uint256 maxBorrowAfterWithdraw = (vaults[msg.sender].collateralAmount - amount) * collateral.price / debt.price / reserve.collateralizationRatio * 100;\r\n    maxBorrowAfterWithdraw *= debt.priceGranularity;\r\n    maxBorrowAfterWithdraw /= collateral.priceGranularity;\r\n    require(vaults[msg.sender].debtAmount <= maxBorrowAfterWithdraw, \"CANNOT UNDERCOLLATERALIZE VAULT\");\r\n    require(IERC20(collateral.tokenAddress).transfer(msg.sender, amount));\r\n    vaults[msg.sender].collateralAmount -= amount;\r\n    reserve.collateralBalance -= amount;\r\n    emit VaultWithdraw(msg.sender, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the user to get the first value for the requestId after the specified timestamp\r\n  * @param _requestId is the requestId to look up the value for\r\n  * @param _timestamp after which to search for first verified value\r\n  * @return bool true if it is able to retreive a value, the value, and the value's timestamp\r\n  */\r\n  function getDataBefore(uint256 _requestId, uint256 _timestamp)\r\n      public\r\n      view\r\n      returns (bool _ifRetrieve, uint256 _value, uint256 _timestampRetrieved)\r\n  {\r\n      uint256 _count = _tellorm.getNewValueCountbyRequestId(_requestId);\r\n      if (_count > 0) {\r\n          for (uint256 i = 1; i <= _count; i++) {\r\n              uint256 _time = _tellorm.getTimestampbyRequestIDandIndex(_requestId, i - 1);\r\n              if (_time <= _timestamp && _tellorm.isInDispute(_requestId,_time) == false) {\r\n                  _timestampRetrieved = _time;\r\n              }\r\n          }\r\n          if (_timestampRetrieved > 0) {\r\n              return (true, _tellorm.retrieveData(_requestId, _timestampRetrieved), _timestampRetrieved);\r\n          }\r\n      }\r\n      return (false, 0, 0);\r\n  }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralizationRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationPenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenTellorRequestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenPriceGranularity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"debtToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtTokenTellorRequestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtTokenPriceGranularity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"oracleContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"}],\"name\":\"Liquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_descriptorSet\",\"type\":\"address\"}],\"name\":\"NewDescriptorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReserveDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReserveWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VaultBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VaultDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VaultRepay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VaultWithdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateralTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateralTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateralTokenPriceGranularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateralizationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getCurrentValue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ifRetrieve\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getDataBefore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_ifRetrieve\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"}],\"name\":\"getDataBefore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_ifRetrieve\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDebtTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDebtTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDebtTokenPriceGranularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLiquidationPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOriginationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReserveBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReserveCollateralBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVaultCollateralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"getVaultCollateralizationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVaultDebtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVaultRepayAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"liquidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleIDDescriptionsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reserveDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reserveWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reserveWithdrawCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleDescriptors\",\"type\":\"address\"}],\"name\":\"setOracleIDDescriptors\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tellorStorageAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateCollateralPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateDebtPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytesId\",\"type\":\"bytes32\"}],\"name\":\"valueFor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vaultBorrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vaultDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vaultRepay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vaultWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Bank","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000096000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000151800000000000000000000000000ba45a8b5d5575935b8158a88c631e9f9c95a2e5000000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000f42400000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000000000000000000000000000000000000000002700000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000ba45a8b5d5575935b8158a88c631e9f9c95a2e5","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://db094ec9bfb3e13f1471ddf685e7f9e055be5db3b1e61f8bc1d9dcd252bf4c76"}]}