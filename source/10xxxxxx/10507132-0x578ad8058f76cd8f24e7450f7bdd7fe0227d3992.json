{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\ncontract ERC1820Implementer {\r\n  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\r\n\r\n  mapping(bytes32 => bool) internal _interfaceHashes;\r\n\r\n  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\r\n    external\r\n    view\r\n    returns(bytes32)\r\n  {\r\n    if(_interfaceHashes[interfaceHash]) {\r\n      return ERC1820_ACCEPT_MAGIC;\r\n    } else {\r\n      return \"\";\r\n    }\r\n  }\r\n\r\n  function _setInterface(string memory interfaceLabel) internal {\r\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400 security token standard\r\n * @dev See https://github.com/SecurityTokenStandard/EIP-Spec/blob/master/eip/eip-1400.md\r\n */\r\ninterface IERC1400 /*is IERC20*/ { // Interfaces can currently not inherit interfaces, but IERC1400 shall include IERC20\r\n\r\n  // ****************** Document Management *******************\r\n  function getDocument(bytes32 name) external view returns (string memory, bytes32);\r\n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\r\n\r\n  // ******************* Token Information ********************\r\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256);\r\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory);\r\n\r\n  // *********************** Transfers ************************\r\n  function transferWithData(address to, uint256 value, bytes calldata data) external;\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external;\r\n\r\n  // *************** Partition Token Transfers ****************\r\n  function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32);\r\n  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\r\n\r\n  // ****************** Controller Operation ******************\r\n  function isControllable() external view returns (bool);\r\n  // function controllerTransfer(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorTransferByPartition\"\r\n  // function controllerRedeem(address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorRedeemByPartition\"\r\n\r\n  // ****************** Operator Management *******************\r\n  function authorizeOperator(address operator) external;\r\n  function revokeOperator(address operator) external;\r\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external;\r\n  function revokeOperatorByPartition(bytes32 partition, address operator) external;\r\n\r\n  // ****************** Operator Information ******************\r\n  function isOperator(address operator, address tokenHolder) external view returns (bool);\r\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool);\r\n\r\n  // ********************* Token Issuance *********************\r\n  function isIssuable() external view returns (bool);\r\n  function issue(address tokenHolder, uint256 value, bytes calldata data) external;\r\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external;\r\n\r\n  // ******************** Token Redemption ********************\r\n  function redeem(uint256 value, bytes calldata data) external;\r\n  function redeemFrom(address tokenHolder, uint256 value, bytes calldata data) external;\r\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external;\r\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData) external;\r\n\r\n  // ******************* Transfer Validity ********************\r\n  // We use different transfer validity functions because those described in the interface don't allow to verify the certificate's validity.\r\n  // Indeed, verifying the ecrtificate's validity requires to keeps the function's arguments in the exact same order as the transfer function.\r\n  //\r\n  // function canTransfer(address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\r\n  // function canTransferFrom(address from, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\r\n  // function canTransferByPartition(address from, address to, bytes32 partition, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32);    \r\n\r\n  // ******************* Controller Events ********************\r\n  // We don't use this event as we don't use \"controllerTransfer\"\r\n  //   event ControllerTransfer(\r\n  //       address controller,\r\n  //       address indexed from,\r\n  //       address indexed to,\r\n  //       uint256 value,\r\n  //       bytes data,\r\n  //       bytes operatorData\r\n  //   );\r\n  //\r\n  // We don't use this event as we don't use \"controllerRedeem\"\r\n  //   event ControllerRedemption(\r\n  //       address controller,\r\n  //       address indexed tokenHolder,\r\n  //       uint256 value,\r\n  //       bytes data,\r\n  //       bytes operatorData\r\n  //   );\r\n\r\n  // ******************** Document Events *********************\r\n  event Document(bytes32 indexed name, string uri, bytes32 documentHash);\r\n\r\n  // ******************** Transfer Events *********************\r\n  event TransferByPartition(\r\n      bytes32 indexed fromPartition,\r\n      address operator,\r\n      address indexed from,\r\n      address indexed to,\r\n      uint256 value,\r\n      bytes data,\r\n      bytes operatorData\r\n  );\r\n\r\n  event ChangedPartition(\r\n      bytes32 indexed fromPartition,\r\n      bytes32 indexed toPartition,\r\n      uint256 value\r\n  );\r\n\r\n  // ******************** Operator Events *********************\r\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n  event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n  // ************** Issuance / Redemption Events **************\r\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data);\r\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data);\r\n  event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n  event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes operatorData);\r\n\r\n}\r\n\r\n/**\r\n * Reason codes - ERC-1066\r\n *\r\n * To improve the token holder experience, canTransfer MUST return a reason byte code\r\n * on success or failure based on the ERC-1066 application-specific status codes specified below.\r\n * An implementation can also return arbitrary data as a bytes32 to provide additional\r\n * information not captured by the reason code.\r\n * \r\n * Code\tReason\r\n * 0x50\ttransfer failure\r\n * 0x51\ttransfer success\r\n * 0x52\tinsufficient balance\r\n * 0x53\tinsufficient allowance\r\n * 0x54\ttransfers halted (contract paused)\r\n * 0x55\tfunds locked (lockup period)\r\n * 0x56\tinvalid sender\r\n * 0x57\tinvalid receiver\r\n * 0x58\tinvalid operator (transfer agent)\r\n * 0x59\t\r\n * 0x5a\t\r\n * 0x5b\t\r\n * 0x5a\t\r\n * 0x5b\t\r\n * 0x5c\t\r\n * 0x5d\t\r\n * 0x5e\t\r\n * 0x5f\ttoken meta or info\r\n *\r\n * These codes are being discussed at: https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283/24\r\n */\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IERC1400Extended {\r\n    // Not a real interface but added here since 'totalSupplyByPartition' doesn't belong to IERC1400\r\n\r\n    function totalSupplyByPartition(bytes32 partition)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n/**\r\n * @title BatchBalanceReader\r\n * @dev Proxy contract to read multiple ERC1400/ERC20 token balances in a single contract call.\r\n */\r\ncontract BatchBalanceReader is ERC1820Implementer {\r\n    string internal constant BALANCE_READER = \"BatchBalanceReader\";\r\n\r\n    constructor() public {\r\n        ERC1820Implementer._setInterface(BALANCE_READER);\r\n    }\r\n\r\n    /**\r\n     * @dev Get a batch of ERC1400 token balances.\r\n     * @param tokenHolders Addresses for which the balance is required.\r\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\r\n     * @param partitions Name of the partitions.\r\n     * @return Balances array.\r\n     */\r\n    function balancesOfByPartition(\r\n        address[] calldata tokenHolders,\r\n        address[] calldata tokenAddresses,\r\n        bytes32[] calldata partitions\r\n    ) external view returns (uint256[] memory) {\r\n        uint256[] memory partitionBalances = new uint256[](\r\n            tokenAddresses.length * partitions.length * tokenHolders.length\r\n        );\r\n        uint256 index;\r\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\r\n            for (uint256 j = 0; j < tokenAddresses.length; j++) {\r\n                for (uint256 k = 0; k < partitions.length; k++) {\r\n                    index =\r\n                        i *\r\n                        (tokenAddresses.length * partitions.length) +\r\n                        j *\r\n                        partitions.length +\r\n                        k;\r\n                    partitionBalances[index] = IERC1400(tokenAddresses[j])\r\n                        .balanceOfByPartition(partitions[k], tokenHolders[i]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return partitionBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev Get a batch of ERC20 token balances.\r\n     * @param tokenHolders Addresses for which the balance is required.\r\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\r\n     * @return Balances array.\r\n     */\r\n    function balancesOf(\r\n        address[] calldata tokenHolders,\r\n        address[] calldata tokenAddresses\r\n    ) external view returns (uint256[] memory) {\r\n        uint256[] memory balances = new uint256[](\r\n            tokenHolders.length * tokenAddresses.length\r\n        );\r\n        uint256 index;\r\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\r\n            for (uint256 j = 0; j < tokenAddresses.length; j++) {\r\n                index = i * tokenAddresses.length + j;\r\n                balances[index] = IERC20(tokenAddresses[j]).balanceOf(\r\n                    tokenHolders[i]\r\n                );\r\n            }\r\n        }\r\n        return balances;\r\n    }\r\n\r\n    /**\r\n     * @dev Get a batch of ERC1400 token total supplies by partitions.\r\n     * @param partitions Name of the partitions.\r\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\r\n     * @return Balances array.\r\n     */\r\n    function totalSuppliesByPartition(\r\n        bytes32[] calldata partitions,\r\n        address[] calldata tokenAddresses\r\n    ) external view returns (uint256[] memory) {\r\n        uint256[] memory partitionSupplies = new uint256[](\r\n            partitions.length * tokenAddresses.length\r\n        );\r\n        uint256 index;\r\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\r\n            for (uint256 j = 0; j < partitions.length; j++) {\r\n                index = i * partitions.length + j;\r\n                partitionSupplies[index] = IERC1400Extended(tokenAddresses[i])\r\n                    .totalSupplyByPartition(partitions[j]);\r\n            }\r\n        }\r\n        return partitionSupplies;\r\n    }\r\n\r\n    /**\r\n     * @dev Get a batch of ERC20 token total supplies.\r\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\r\n     * @return Balances array.\r\n     */\r\n    function totalSupplies(address[] calldata tokenAddresses)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory supplies = new uint256[](tokenAddresses.length);\r\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\r\n            supplies[i] = IERC20(tokenAddresses[i]).totalSupply();\r\n        }\r\n        return supplies;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"partitions\",\"type\":\"bytes32[]\"},{\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"totalSuppliesByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolders\",\"type\":\"address[]\"},{\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"balancesOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"totalSupplies\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolders\",\"type\":\"address[]\"},{\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"name\":\"partitions\",\"type\":\"bytes32[]\"}],\"name\":\"balancesOfByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"BatchBalanceReader","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e922ca8aef27cd8813458c08921606c57f92e648fa364ee474dd8483bfd84ef8"}]}