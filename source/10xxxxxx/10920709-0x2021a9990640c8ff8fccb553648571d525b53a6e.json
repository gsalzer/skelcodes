{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.4\r\n\"\"\"\r\n@title \"Zap\" Depositer for Curve Snow pool\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020 - all rights reserved\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n# External Contracts\r\ninterface yERC20:\r\n    def deposit(depositAmount: uint256): nonpayable\r\n    def withdraw(withdrawTokens: uint256): nonpayable\r\n\r\ninterface Curve:\r\n    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256): nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]): nonpayable\r\n    def remove_liquidity_imbalance(amounts: uint256[N_COINS], max_burn_amount: uint256): nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def get_coin_rates() -> uint256[N_COINS]: view\r\n\r\n\r\nN_COINS: constant(int128) = 6\r\nLENDING_PRECISION: constant(uint256) = 10 ** 18\r\n\r\ncoins: public(address[N_COINS])\r\nunderlying_coins: public(address[N_COINS])\r\ncurve: public(address)\r\ntoken: public(address)\r\n\r\n\r\n@external\r\ndef __init__(\r\n    _coins: address[N_COINS],\r\n    _underlying_coins: address[N_COINS],\r\n    _curve: address,\r\n    _token: address\r\n):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @dev Where a token does not use wrapping, use the same address\r\n         for `_coins` and `_underlying_coins`\r\n    @param _coins List of wrapped coin addresses\r\n    @param _underlying_coins List of underlying coin addresses\r\n    @param _curve Pool address\r\n    @param _token Pool LP token address\r\n    \"\"\"\r\n    for i in range(N_COINS):\r\n        assert _coins[i] != ZERO_ADDRESS\r\n        assert _underlying_coins[i] != ZERO_ADDRESS\r\n\r\n        # approve underlying and wrapped coins for infinite transfers\r\n        _response: Bytes[32] = raw_call(\r\n            _underlying_coins[i],\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(_coins[i], bytes32),\r\n                convert(MAX_UINT256, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(_response) > 0:\r\n            assert convert(_response, bool)\r\n        _response = raw_call(\r\n            _coins[i],\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(_curve, bytes32),\r\n                convert(MAX_UINT256, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(_response) > 0:\r\n            assert convert(_response, bool)\r\n\r\n    self.coins = _coins\r\n    self.underlying_coins = _underlying_coins\r\n    self.curve = _curve\r\n    self.token = _token\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef add_liquidity(_underlying_amounts: uint256[N_COINS], _min_mint_amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Wrap underlying coins and deposit them in the pool\r\n    @param _underlying_amounts List of amounts of underlying coins to deposit\r\n    @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit\r\n    @return Amount of LP tokens received by depositing\r\n    \"\"\"\r\n    _wrapped_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    for i in range(N_COINS):\r\n        _amount: uint256 = _underlying_amounts[i]\r\n\r\n        if _amount != 0:\r\n            # Transfer the underlying coin from owner\r\n            _response: Bytes[32] = raw_call(\r\n                self.underlying_coins[i],\r\n                concat(\r\n                    method_id(\"transferFrom(address,address,uint256)\"),\r\n                    convert(msg.sender, bytes32),\r\n                    convert(self, bytes32),\r\n                    convert(_amount, bytes32)\r\n                ),\r\n                max_outsize=32\r\n            )\r\n            if len(_response) > 0:\r\n                assert convert(_response, bool)\r\n\r\n            # Mint if needed\r\n            if i < 5:\r\n                # only self.coins[5] is not wrapped\r\n                _coin: address = self.coins[i]\r\n                yERC20(_coin).deposit(_amount)\r\n                _wrapped_amounts[i] = ERC20(_coin).balanceOf(self)\r\n            else:\r\n                _wrapped_amounts[i] = _amount\r\n\r\n    Curve(self.curve).add_liquidity(_wrapped_amounts, _min_mint_amount)\r\n\r\n    _lp_token: address = self.token\r\n    _lp_amount: uint256 = ERC20(_lp_token).balanceOf(self)\r\n    assert ERC20(_lp_token).transfer(msg.sender, _lp_amount)\r\n\r\n    return _lp_amount\r\n\r\n\r\n@internal\r\ndef _unwrap_and_transfer(_addr: address, _min_amounts: uint256[N_COINS]) -> uint256[N_COINS]:\r\n    # unwrap coins and transfer them to the sender\r\n    _amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    for x in range(N_COINS):\r\n        # we iterate backwards so that USDC is handled before unwrapping yvUSDC into USDC\r\n        i: int128 = N_COINS - 1 - x\r\n        if i < 5:\r\n            # only self.coins[5] is not wrapped\r\n            _coin: address = self.coins[i]\r\n            _balance: uint256 = ERC20(_coin).balanceOf(self)\r\n            if _balance == 0:  # Do nothing if there are 0 coins\r\n                continue\r\n            yERC20(_coin).withdraw(_balance)\r\n\r\n        _ucoin: address = self.underlying_coins[i]\r\n        _uamount: uint256 = ERC20(_ucoin).balanceOf(self)\r\n        assert _uamount >= _min_amounts[i], \"Not enough coins withdrawn\"\r\n\r\n        # Send only if we have something to send\r\n        if _uamount != 0:\r\n            _response: Bytes[32] = raw_call(\r\n                _ucoin,\r\n                concat(\r\n                    method_id(\"transfer(address,uint256)\"),\r\n                    convert(_addr, bytes32),\r\n                    convert(_uamount, bytes32)\r\n                ),\r\n                max_outsize=32\r\n            )\r\n            if len(_response) > 0:\r\n                assert convert(_response, bool)\r\n            _amounts[i] = _uamount\r\n\r\n    return _amounts\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity(\r\n    _amount: uint256,\r\n    _min_underlying_amounts: uint256[N_COINS]\r\n) -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap coins from the pool\r\n    @dev Withdrawal amounts are based on current deposit ratios\r\n    @param _amount Quantity of LP tokens to burn in the withdrawal\r\n    @param _min_underlying_amounts Minimum amounts of underlying coins to receive\r\n    @return List of amounts of underlying coins that were withdrawn\r\n    \"\"\"\r\n    assert ERC20(self.token).transferFrom(msg.sender, self, _amount)\r\n    Curve(self.curve).remove_liquidity(_amount, empty(uint256[N_COINS]))\r\n\r\n    return self._unwrap_and_transfer(msg.sender, _min_underlying_amounts)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_imbalance(\r\n    _underlying_amounts: uint256[N_COINS],\r\n    _max_burn_amount: uint256\r\n) -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap coins from the pool in an imbalanced amount\r\n    @dev Amounts in `_underlying_amounts` correspond to withdrawn amounts\r\n         before any fees charge for unwrapping.\r\n    @param _underlying_amounts List of amounts of underlying coins to withdraw\r\n    @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal\r\n    @return List of amounts of underlying coins that were withdrawn\r\n    \"\"\"\r\n    _token: address = self.token\r\n    _curve: address = self.curve\r\n\r\n    amounts: uint256[N_COINS] = _underlying_amounts\r\n    _coin_rates: uint256[N_COINS] = Curve(_curve).get_coin_rates()\r\n    for i in range(N_COINS):\r\n        if i < 5 and amounts[i] > 0:\r\n            # only self.coins[5] is not wrapped\r\n            amounts[i] = amounts[i] * LENDING_PRECISION / _coin_rates[i]\r\n\r\n    # Transfer max tokens in\r\n    _lp_amount: uint256 = ERC20(_token).balanceOf(msg.sender)\r\n    if _lp_amount > _max_burn_amount:\r\n        _lp_amount = _max_burn_amount\r\n    assert ERC20(_token).transferFrom(msg.sender, self, _lp_amount)\r\n\r\n    Curve(_curve).remove_liquidity_imbalance(amounts, _max_burn_amount)\r\n\r\n    # Transfer unused LP tokens back\r\n    _lp_amount = ERC20(_token).balanceOf(self)\r\n    if _lp_amount != 0:\r\n        assert ERC20(_token).transfer(msg.sender, _lp_amount)\r\n\r\n    # Unwrap and transfer all the coins we've got\r\n    return self._unwrap_and_transfer(msg.sender, empty(uint256[N_COINS]))\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_one_coin(\r\n    _amount: uint256,\r\n    i: int128,\r\n    _min_underlying_amount: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap a single coin from the pool\r\n    @param _amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @param _min_underlying_amount Minimum amount of underlying coin to receive\r\n    @return Amount of underlying coin received\r\n    \"\"\"\r\n    assert ERC20(self.token).transferFrom(msg.sender, self, _amount)\r\n\r\n    Curve(self.curve).remove_liquidity_one_coin(_amount, i, 0)\r\n\r\n    if i < 5:\r\n        # only self.coins[5] is not wrapped\r\n        _coin: address = self.coins[i]\r\n        _balance: uint256 = ERC20(_coin).balanceOf(self)\r\n        yERC20(_coin).withdraw(_balance)\r\n\r\n    _coin: address = self.underlying_coins[i]\r\n    _balance: uint256 = ERC20(_coin).balanceOf(self)\r\n    assert _balance >= _min_underlying_amount, \"Not enough coins removed\"\r\n\r\n    _response: Bytes[32] = raw_call(\r\n        _coin,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(msg.sender, bytes32),\r\n            convert(_balance, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool)\r\n\r\n    return _balance","ABI":"[{\"outputs\":[],\"inputs\":[{\"type\":\"address[6]\",\"name\":\"_coins\"},{\"type\":\"address[6]\",\"name\":\"_underlying_coins\"},{\"type\":\"address\",\"name\":\"_curve\"},{\"type\":\"address\",\"name\":\"_token\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"add_liquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256[6]\",\"name\":\"_underlying_amounts\"},{\"type\":\"uint256\",\"name\":\"_min_mint_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":130985},{\"name\":\"remove_liquidity\",\"outputs\":[{\"type\":\"uint256[6]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256[6]\",\"name\":\"_min_underlying_amounts\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":136931},{\"name\":\"remove_liquidity_imbalance\",\"outputs\":[{\"type\":\"uint256[6]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256[6]\",\"name\":\"_underlying_amounts\"},{\"type\":\"uint256\",\"name\":\"_max_burn_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":142919},{\"name\":\"remove_liquidity_one_coin\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"int128\",\"name\":\"i\"},{\"type\":\"uint256\",\"name\":\"_min_underlying_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":90150},{\"name\":\"coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1410},{\"name\":\"underlying_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1440},{\"name\":\"curve\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1361},{\"name\":\"token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1391}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.4","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000acd43e627e64355f1861cec6d3a6688b31a6f952000000000000000000000000597ad1e0c13bfe8025993d9e79c69e1c0233522e0000000000000000000000002f08119c6f07c006695e079aafc638b8789faf1800000000000000000000000037d19d1c4e1fa9dc47bd1ea12f742a0887eda74a0000000000000000000000005dbcf33d8c2e976c6b560249878e6f1491bca25c000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000000085d4780b73119b644ae5ecd22b376000000000000000000000000df5e0e81dff6faf3a7e52ba697820c5e32d806a8000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000f0f745c81e4533c697cf0104c5efdcbf843595420000000000000000000000003921574e4146fc09701a1b24cfb0f9906e8fee92","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}