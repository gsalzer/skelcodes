{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ConditionCompareAssetPriceForStopLoss.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport { GelatoConditionsStandard } from \\\"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\\\";\\nimport { SafeMath } from \\\"@gelatonetwork/core/contracts/external/SafeMath.sol\\\";\\nimport { GelatoBytes } from \\\"./GelatoBytes.sol\\\";\\n\\ncontract ConditionCompareAssetPriceForStopLoss is GelatoConditionsStandard {\\n\\n    using GelatoBytes for bytes;\\n\\n    function getConditionData( address _source, bytes calldata  _sourceData, uint _limit)\\n        public\\n        pure\\n        virtual\\n        returns (bytes memory)\\n    {\\n        return abi.encode(_source, _sourceData, _limit);\\n    }\\n    function ok(uint256, bytes calldata _conditionData, uint256)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (string memory)\\n    {\\n        (address source,\\n         bytes memory sourceData,\\n         uint limit) = abi.decode(\\n            _conditionData,\\n            (address,bytes,uint)\\n        );\\n\\n        return stopLoss(source, sourceData, limit);\\n    }\\n\\n    function stopLoss(address _source, bytes memory _sourceData, uint limit)\\n        internal\\n        view\\n        returns(string memory)\\n    {\\n        (bool success, bytes memory returndata) = _source.staticcall(_sourceData);\\n        if(!success) {\\n            return returndata.generateErrorString(\\n                \\\"ConditionCompareAssetPrice.stopLoss._source:\\\"\\n            );\\n        }\\n\\n        uint price = abi.decode(returndata, (uint));\\n\\n        if (price <= limit) return OK;\\n        return \\\"NotOKPriceStillGreaterThanTheStopLossLimit\\\";\\n    }\\n}\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\n\\nimport \\\"./IGelatoCondition.sol\\\";\\n\\nabstract contract GelatoConditionsStandard is IGelatoCondition {\\n    string internal constant OK = \\\"OK\\\";\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/conditions/IGelatoCondition.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\\n/// @notice all the APIs of GelatoConditionsStandard\\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\\ninterface IGelatoCondition {\\n\\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\\n    ///  \\\"ok\\\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\\n    ///  source of Task identification.\\n    /// @param _conditionData This is the Condition.data field developers must encode their\\n    ///  Condition's specific parameters in.\\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\\n        external\\n        view\\n        returns(string memory);\\n}\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/external/SafeMath.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/GelatoBytes.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity 0.6.12;\\n\\nlibrary GelatoBytes {\\n    function calldataSliceSelector(bytes calldata _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function memorySliceSelector(bytes memory _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function revertWithErrorString(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly { selector := mload(add(0x20, _bytes)) }\\n            if (selector == 0x08c379a0) {  // Function selector for Error(string)\\n                assembly { _bytes := add(_bytes, 68) }\\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\\n            } else {\\n                revert(string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\")));\\n            }\\n        } else {\\n            revert(string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\")));\\n        }\\n    }\\n\\n    function generateErrorString(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly { selector := mload(add(0x20, _bytes)) }\\n            if (selector == 0x08c379a0) {  // Function selector for Error(string)\\n                assembly { _bytes := add(_bytes, 68) }\\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\\n            } else {\\n                return string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"));\\n            }\\n        } else {\\n            return string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"));\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/ConditionCompareAssetPriceForTakeProfit.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport { GelatoConditionsStandard } from \\\"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\\\";\\nimport { SafeMath } from \\\"@gelatonetwork/core/contracts/external/SafeMath.sol\\\";\\nimport { GelatoBytes } from \\\"./GelatoBytes.sol\\\";\\n\\ncontract ConditionCompareAssetPriceForTakeProfit is GelatoConditionsStandard {\\n\\n    using GelatoBytes for bytes;\\n\\n    function getConditionData( address _source, bytes calldata  _sourceData, int _limit)\\n        public\\n        pure\\n        virtual\\n        returns (bytes memory)\\n    {\\n        return abi.encode(_source, _sourceData, _limit);\\n    }\\n    function ok(uint256, bytes calldata _conditionData, uint256)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (string memory)\\n    {\\n        (address source,\\n         bytes memory sourceData,\\n         int limit) = abi.decode(\\n            _conditionData,\\n            (address,bytes,int)\\n        );\\n\\n        return takeProfit(source, sourceData, limit);\\n    }\\n\\n    function takeProfit(address _source, bytes memory _sourceData, int limit)\\n        internal\\n        view\\n        returns(string memory)\\n    {\\n        (bool success, bytes memory returndata) = _source.staticcall(_sourceData);\\n        if(!success) {\\n            return returndata.generateErrorString(\\n                \\\"ConditionCompareAssetPrice.takeProfit._source:\\\"\\n            );\\n        }\\n\\n        int price = abi.decode(returndata, (int));\\n\\n        if (price >= limit) return OK;\\n        return \\\"NotOKPriceStillLesserThanTheTakeProfitLimit\\\";\\n    }\\n}\"\r\n    },\r\n    \"contracts/DSMath.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.6.2;\\n\\ncontract DSMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        return x <= y ? x : y;\\n    }\\n    function max(uint x, uint y) internal pure returns (uint z) {\\n        return x >= y ? x : y;\\n    }\\n    function imin(int x, int y) internal pure returns (int z) {\\n        return x <= y ? x : y;\\n    }\\n    function imax(int x, int y) internal pure returns (int z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint constant WAD = 10 ** 18;\\n    uint constant RAY = 10 ** 27;\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n    //rounds to zero if x*y < WAD / 2\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint x, uint n) internal pure returns (uint z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/Extensions.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\ncontract Extensions {\\n    function convertIntToUint(int a) internal pure returns(uint) {\\n        if (a >= 0) {\\n            return uint(a);\\n        }\\n        return uint(a * -1);\\n    }\\n}\"\r\n    },\r\n    \"contracts/IPriceFeed.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\ninterface IPriceFeed {\\n    function getLatestPriceToken0() external view virtual returns (uint);\\n\\n    function getLatestPriceToken1() external view virtual returns (uint);\\n}\"\r\n    },\r\n    \"contracts/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"contracts/Mocks/Compare.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport \\\"./../DSMath.sol\\\";\\n\\ncontract Compare is DSMath {\\n    \\n    function getbytes(string memory _data) public view returns(bytes memory result) {\\n        result = bytes(_data);\\n    } \\n    \\n    function compareBytes(bytes memory _a, bytes memory _b) public view returns(bool same) {\\n        \\n        same = true;\\n        \\n        same = _a.length == _b.length;\\n        if(!same) {\\n            return same;\\n        }\\n        \\n        for(uint i = 0; i< _a.length; i++) { // compare each bytes32\\n            same = same && _a[i] == _b[i];\\n            if (!same) {\\n                return same;\\n            }\\n        }\\n    }\\n\\n    function equalUint(uint _a, uint _b) public view returns(bool) {\\n        return _a == _b;\\n    }\\n\\n    function gteUint(uint _a, uint _b) public view returns(bool) {\\n        return _a >= _b;\\n    }\\n\\n    function gtUint(uint _a, uint _b) public view returns(bool) {\\n        return _a > _b;\\n    }\\n    function substraction(uint _a, uint _b) public view returns(uint) {\\n        return sub(_a, _b);\\n    }\\n}\"\r\n    },\r\n    \"contracts/Mocks/PriceFeedMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport \\\"./../IPriceFeed.sol\\\";\\nimport { SafeMath } from \\\"@gelatonetwork/core/contracts/external/SafeMath.sol\\\";\\n\\ncontract PriceFeedMock {\\n\\n    using SafeMath for uint;\\n\\n    IPriceFeed internal priceFeed;\\n    bool internal mockMode;\\n    uint internal adjustmentValue;\\n\\n    constructor(address _priceFeed) public {\\n        priceFeed = IPriceFeed(_priceFeed);\\n        mockMode = false;\\n    }\\n\\n    function mock(uint _adjustmentValue) public {\\n        mockMode = true;\\n        adjustmentValue = _adjustmentValue;\\n    }\\n\\n    function getLatestPriceToken0() public view returns (uint) {\\n        if (mockMode) {\\n            return priceFeed.getLatestPriceToken0().sub(adjustmentValue) ;\\n        }\\n        return priceFeed.getLatestPriceToken0();\\n    }\\n\\n    function getLatestPriceToken1() public view returns (uint) {\\n        if (mockMode) {\\n            return priceFeed.getLatestPriceToken1().sub(adjustmentValue);\\n        }\\n        return priceFeed.getLatestPriceToken1();\\n    }\\n}\"\r\n    },\r\n    \"contracts/Mocks/PriceFeedMockETHUSD.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"./../Extensions.sol\\\";\\nimport \\\"./../DSMath.sol\\\";\\nimport \\\"./../IPriceFeed.sol\\\";\\n\\ncontract PriceFeedMockETHUSD is Extensions, DSMath, Ownable {\\n\\n    bool public mockMode;\\n    uint public adjustmentValue;\\n    AggregatorV3Interface public priceFeed;\\n\\n    constructor() public {\\n        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\\n        mockMode = false;\\n        adjustmentValue = 0;\\n    }\\n\\n    function setOracleAddress(address _oracle) public onlyOwner {\\n        require(address(priceFeed) != _oracle, \\\"Price Feeder ETH/USD : Already set.\\\");\\n        priceFeed = AggregatorV3Interface(_oracle);\\n    }\\n\\n    function unmock() public onlyOwner {\\n        mockMode = false;\\n    }\\n\\n    function mock(uint _adjustmentValue) public onlyOwner {\\n        mockMode = true;\\n        adjustmentValue = _adjustmentValue;\\n    }\\n\\n    function getLatestPriceToken0() public view returns (uint) {\\n        if (mockMode) {\\n            return sub(getOraclePriceToken0(), adjustmentValue);\\n        }\\n        return getOraclePriceToken0();\\n    }\\n\\n    function getLatestPriceToken1() public view returns (uint) {\\n        if (mockMode) {\\n            return sub(getOraclePriceToken1(), adjustmentValue);\\n        }\\n        return getOraclePriceToken1();\\n    }\\n\\n    function getOraclePriceToken0() internal view returns (uint) {\\n        (\\n            uint80 roundID, \\n            int price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeed.latestRoundData();\\n\\n        require(timeStamp > 0, \\\"Round not complete\\\");\\n        return mul(convertIntToUint(price), 10 ** 10); // Transform to wad\\n    }\\n\\n    function getOraclePriceToken1() internal view returns (uint) { // Use Wad for ETH/USD\\n        return wdiv(1 ether, getOraclePriceToken0());\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/Mocks/UniswapPriceOracle.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\nimport { SafeMath } from \\\"@gelatonetwork/core/contracts/external/SafeMath.sol\\\";\\n\\nlibrary UniswapV2Library {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n            ))));\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint amountInWithFee = amountIn.mul(997);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint i; i < path.length - 1; i++) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint i = path.length - 1; i > 0; i--) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface TokenInterface {\\n    function approve(address, uint256) external;\\n    function transfer(address, uint) external;\\n    function transferFrom(address, address, uint) external;\\n    function deposit() external payable;\\n    function withdraw(uint) external;\\n    function balanceOf(address) external view returns (uint);\\n    function decimals() external view returns (uint);\\n}\\n\\ncontract UniswapPriceOracle {\\n    function getPrice(address buyAddr, address sellAddr, uint sellAmt) public view returns(uint) {\\n        (TokenInterface _buyAddr, TokenInterface _sellAddr) = changeEthAddress(buyAddr, sellAddr);\\n        address[] memory paths = getPaths(address(_buyAddr), address(_sellAddr));\\n        IUniswapV2Router02 router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\n        return getAmountsOut(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f, sellAmt, paths);\\n    }\\n\\n    function getPaths(\\n        address buyAddr,\\n        address sellAddr\\n    ) internal pure returns(address[] memory paths) {\\n        paths = new address[](2);\\n        paths[0] = address(sellAddr);\\n        paths[1] = address(buyAddr);\\n    }\\n\\n    function changeEthAddress(address buy, address sell) internal pure returns(TokenInterface _buy, TokenInterface _sell){\\n        _buy = buy == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? TokenInterface(getAddressWETH()) : TokenInterface(buy);\\n        _sell = sell == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? TokenInterface(getAddressWETH()) : TokenInterface(sell);\\n    }\\n\\n    function getAddressWETH() internal pure returns (address) {\\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    }\\n\\n    function getExpectedBuyAmt(\\n        IUniswapV2Router02 router,\\n        address[] memory paths,\\n        uint sellAmt\\n    ) internal view returns(uint buyAmt) {\\n        uint[] memory amts = router.getAmountsOut(\\n            sellAmt,\\n            paths\\n        );\\n        buyAmt = amts[1];\\n    }\\n\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path)\\n        public view\\n        returns (uint) {\\n        uint[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n        return amounts[amounts.length - 1];\\n    }\\n}\"\r\n    },\r\n    \"contracts/PriceFeedDAIETH.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"./DSMath.sol\\\";\\nimport \\\"./Extensions.sol\\\";\\nimport \\\"./IPriceFeed.sol\\\";\\n\\ncontract PriceFeedDAIETH is IPriceFeed, DSMath, Extensions {\\n    AggregatorV3Interface internal priceFeed;\\n\\n    constructor() public {\\n        priceFeed = AggregatorV3Interface(0x773616E4d11A78F511299002da57A0a94577F1f4);\\n    }\\n\\n    function getLatestPriceToken0() public view override returns (uint) {\\n        (\\n            uint80 roundID, \\n            int price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeed.latestRoundData();\\n\\n        require(timeStamp > 0, \\\"Round not complete\\\");\\n        return convertIntToUint(price);\\n    }\\n\\n    function getLatestPriceToken1() public view override returns (uint) { // Use Wad  for DAI/ETH\\n        return wdiv(1 ether, getLatestPriceToken0());\\n    }\\n}\"\r\n    },\r\n    \"contracts/PriceFeedETHUSD.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"./DSMath.sol\\\";\\nimport \\\"./Extensions.sol\\\";\\nimport \\\"./IPriceFeed.sol\\\";\\n\\ncontract PriceFeedETHUSD is IPriceFeed, DSMath, Extensions {\\n    AggregatorV3Interface internal priceFeed;\\n\\n    constructor() public {\\n        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\\n    }\\n\\n    function getLatestPriceToken0() public view override returns (uint) {\\n        (\\n            uint80 roundID, \\n            int price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeed.latestRoundData();\\n\\n        require(timeStamp > 0, \\\"Round not complete\\\");\\n        return mul(convertIntToUint(price), 10 ** 10); // Transform to wad\\n    }\\n\\n    function getLatestPriceToken1() public view override returns (uint) { // Use Wad  for ETH/USD\\n        return wdiv(1 ether, getLatestPriceToken0());\\n    }\\n}\"\r\n    },\r\n    \"contracts/ProviderModuleDSA.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n    GelatoProviderModuleStandard\\n} from \\\"@gelatonetwork/core/contracts/provider_modules/GelatoProviderModuleStandard.sol\\\";\\nimport {Task} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\n/// @dev InstaDapp Index\\ninterface IndexInterface {\\n    function connectors(uint version) external view returns (address);\\n    function list() external view returns (address);\\n}\\n\\n/// @dev InstaDapp List\\ninterface ListInterface {\\n    function accountID(address _account) external view returns (uint64);\\n}\\n\\n/// @dev InstaDapp Connectors\\ninterface ConnectorsInterface {\\n    function isConnector(address[] calldata logicAddr) external view returns (bool);\\n    function isStaticConnector(address[] calldata logicAddr) external view returns (bool);\\n}\\n\\n/// @dev InstaDapp Defi Smart Account wallet\\ninterface AccountInterface {\\n    function version() external view returns (uint);\\n    function isAuth(address user) external view returns (bool);\\n    function shield() external view returns (bool);\\n    function cast(address[] calldata _targets, bytes[] calldata _datas, address _origin)\\n        external\\n        payable\\n        returns (bytes32[] memory responses);\\n}\\n\\ncontract ProviderModuleDSA is GelatoProviderModuleStandard {\\n    IndexInterface public immutable index;\\n    address public immutable gelatoCore;\\n\\n    constructor(IndexInterface _index, address _gelatoCore) public {\\n        index = _index;\\n        gelatoCore = _gelatoCore;\\n    }\\n\\n    // ================= GELATO PROVIDER MODULE STANDARD ================\\n    function isProvided(address _userProxy, address, Task calldata _task)\\n        external\\n        view\\n        override\\n        returns(string memory)\\n    {\\n        // Verify InstaDapp account identity\\n        if (ListInterface(index.list()).accountID(_userProxy) == 0)\\n            return \\\"ProviderModuleDSA.isProvided:InvalidUserProxy\\\";\\n\\n        // Is GelatoCore authorized\\n        if (!AccountInterface(_userProxy).isAuth(gelatoCore))\\n            return \\\"ProviderModuleDSA.isProvided:GelatoCoreNotAuth\\\";\\n\\n        // @dev commented out for gas savings\\n\\n        // // Is connector valid\\n        // ConnectorsInterface connectors = ConnectorsInterface(index.connectors(\\n        //     AccountInterface(_userProxy).version()\\n        // ));\\n\\n        // address[] memory targets = new address[](_task.actions.length);\\n        // for (uint i = 0; i < _task.actions.length; i++)\\n        //     targets[i] = _task.actions[i].addr;\\n\\n        // bool isShield = AccountInterface(_userProxy).shield();\\n        // if (isShield)\\n        //     if (!connectors.isStaticConnector(targets))\\n        //         return \\\"ProviderModuleDSA.isProvided:not-static-connector\\\";\\n        // else\\n        //     if (!connectors.isConnector(targets))\\n        //         return \\\"ProviderModuleDSA.isProvided:not-connector\\\";\\n\\n        return OK;\\n    }\\n\\n    /// @dev DS PROXY ONLY ALLOWS DELEGATE CALL for single actions, that's why we also use multisend\\n    function execPayload(uint256, address, address, Task calldata _task, uint256)\\n        external\\n        view\\n        override\\n        returns(bytes memory payload, bool)\\n    {\\n        address[] memory targets = new address[](_task.actions.length);\\n        for (uint i = 0; i < _task.actions.length; i++)\\n            targets[i] = _task.actions[i].addr;\\n\\n        bytes[] memory datas = new bytes[](_task.actions.length);\\n        for (uint i = 0; i < _task.actions.length; i++)\\n            datas[i] = _task.actions[i].data;\\n\\n        payload = abi.encodeWithSelector(\\n            AccountInterface.cast.selector,\\n            targets,\\n            datas,\\n            gelatoCore\\n        );\\n    }\\n}\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/provider_modules/GelatoProviderModuleStandard.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {IGelatoProviderModule} from \\\"./IGelatoProviderModule.sol\\\";\\nimport {Task} from \\\"../gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\nabstract contract GelatoProviderModuleStandard is IGelatoProviderModule {\\n\\n    string internal constant OK = \\\"OK\\\";\\n\\n    function isProvided(address, address, Task calldata)\\n        external\\n        view\\n        virtual\\n        override\\n        returns(string memory)\\n    {\\n        return OK;\\n    }\\n\\n    function execPayload(uint256, address, address, Task calldata, uint256)\\n        external\\n        view\\n        virtual\\n        override\\n        returns(bytes memory payload, bool)\\n    {\\n        return (payload, false);\\n    }\\n\\n    /// @dev Overriding fns should revert with the revertMsg they detected on the userProxy\\n    function execRevertCheck(bytes calldata) external pure override virtual {\\n        // By default no reverts detected => do nothing\\n    }\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/provider_modules/IGelatoProviderModule.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {Action, Task} from \\\"../gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\ninterface IGelatoProviderModule {\\n\\n    /// @notice Check if provider agrees to pay for inputted task receipt\\n    /// @dev Enables arbitrary checks by provider\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @return \\\"OK\\\" if provider agrees\\n    function isProvided(address _userProxy, address _provider, Task calldata _task)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice Convert action specific payload into proxy specific payload\\n    /// @dev Encoded multiple actions into a multisend\\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\\n    /// @return Encoded payload that will be used for low-level .call on user proxy\\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\\n    function execPayload(\\n        uint256 _taskReceiptId,\\n        address _userProxy,\\n        address _provider,\\n        Task calldata _task,\\n        uint256 _cycleId\\n    )\\n        external\\n        view\\n        returns(bytes memory, bool checkReturndata);\\n\\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {IGelatoProviderModule} from \\\"../../provider_modules/IGelatoProviderModule.sol\\\";\\nimport {IGelatoCondition} from \\\"../../conditions/IGelatoCondition.sol\\\";\\n\\nstruct Provider {\\n    address addr;  //  if msg.sender == provider => self-Provider\\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\\n}\\n\\nstruct Condition {\\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\\n    bytes data;  // can be bytes32(0) for self-conditional Actions\\n}\\n\\nenum Operation { Call, Delegatecall }\\n\\nenum DataFlow { None, In, Out, InAndOut }\\n\\nstruct Action {\\n    address addr;\\n    bytes data;\\n    Operation operation;\\n    DataFlow dataFlow;\\n    uint256 value;\\n    bool termsOkCheck;\\n}\\n\\nstruct Task {\\n    Condition[] conditions;  // optional\\n    Action[] actions;\\n    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\\n    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\\n}\\n\\nstruct TaskReceipt {\\n    uint256 id;\\n    address userProxy;\\n    Provider provider;\\n    uint256 index;\\n    Task[] tasks;\\n    uint256 expiryDate;\\n    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\\n    uint256 submissionsLeft;\\n}\\n\\ninterface IGelatoCore {\\n    event LogTaskSubmitted(\\n        uint256 indexed taskReceiptId,\\n        bytes32 indexed taskReceiptHash,\\n        TaskReceipt taskReceipt\\n    );\\n\\n    event LogExecSuccess(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        uint256 executorSuccessFee,\\n        uint256 sysAdminSuccessFee\\n    );\\n    event LogCanExecFailed(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        string reason\\n    );\\n    event LogExecReverted(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        uint256 executorRefund,\\n        string reason\\n    );\\n\\n    event LogTaskCancelled(uint256 indexed taskReceiptId, address indexed cancellor);\\n\\n    /// @notice API to query whether Task can be submitted successfully.\\n    /// @dev In submitTask the msg.sender must be the same as _userProxy here.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _userProxy The userProxy from which the task will be submitted.\\n    /// @param _task Selected provider, conditions, actions, expiry date of the task\\n    function canSubmitTask(\\n        address _userProxy,\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    )\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice API to submit a single Task.\\n    /// @dev You can let users submit multiple tasks at once by batching calls to this.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _task A Gelato Task object: provider, conditions, actions.\\n    /// @param _expiryDate From then on the task cannot be executed. 0 for infinity.\\n    function submitTask(\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    )\\n        external;\\n\\n\\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\\n    ///  the next one, after they have been executed.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _tasks This can be a single task or a sequence of tasks.\\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\\n    /// @param _cycles How many full cycles will be submitted\\n    function submitTaskCycle(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _cycles\\n    )\\n        external;\\n\\n\\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\\n    ///  the next one, after they have been executed.\\n    /// @dev CAUTION: _sumOfRequestedTaskSubmits does not mean the number of cycles.\\n    /// @dev If _sumOfRequestedTaskSubmits = 1 && _tasks.length = 2, only the first task\\n    ///  would be submitted, but not the second\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _tasks This can be a single task or a sequence of tasks.\\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\\n    /// @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\\n    ///  that should have occured once the cycle is complete:\\n    ///  _sumOfRequestedTaskSubmits = 0 => One Task will resubmit the next Task infinitly\\n    ///  _sumOfRequestedTaskSubmits = 1 => One Task will resubmit no other task\\n    ///  _sumOfRequestedTaskSubmits = 2 => One Task will resubmit 1 other task\\n    ///  ...\\n    function submitTaskChain(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _sumOfRequestedTaskSubmits\\n    )\\n        external;\\n\\n    // ================  Exec Suite =========================\\n    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\\n    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\\n    /// @param _gasLimit Task.selfProviderGasLimit is used for SelfProviders. All other\\n    ///  Providers must use gelatoMaxGas. If the _gasLimit is used by an Executor and the\\n    ///  tx reverts, a refund is paid by the Provider and the TaskReceipt is annulated.\\n    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\\n    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\\n    function canExec(TaskReceipt calldata _TR, uint256 _gasLimit, uint256 _execTxGasPrice)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\\n    /// @dev Executors get rewarded for successful Execution. The Task remains open until\\n    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\\n    ///   In the latter case Executors are refunded by the Task Provider.\\n    /// @param _TR TaskReceipt: id, userProxy, Task.\\n    function exec(TaskReceipt calldata _TR) external;\\n\\n    /// @notice Cancel task\\n    /// @dev Callable only by userProxy or selected provider\\n    /// @param _TR TaskReceipt: id, userProxy, Task.\\n    function cancelTask(TaskReceipt calldata _TR) external;\\n\\n    /// @notice Cancel multiple tasks at once\\n    /// @dev Callable only by userProxy or selected provider\\n    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\\n\\n    /// @notice Compute hash of task receipt\\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\\n    /// @return hash of taskReceipt\\n    function hashTaskReceipt(TaskReceipt calldata _TR) external pure returns(bytes32);\\n\\n    // ================  Getters =========================\\n    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\\n    /// @return currentId currentId, last TaskReceiptId submitted\\n    function currentTaskReceiptId() external view returns(uint256);\\n\\n    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\\n    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\\n    /// @return hash of taskReceipt\\n    function taskReceiptHash(uint256 _taskReceiptId) external view returns(bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/WETH.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\ninterface WETH {\\n    function deposit() external payable;\\n    function withdraw(uint wad) external;\\n\\n    function approve(address guy, uint wad) external returns (bool);\\n\\n    function transfer(address dst, uint wad) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adjustmentValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPriceToken0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPriceToken1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_adjustmentValue\",\"type\":\"uint256\"}],\"name\":\"mock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unmock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PriceFeedMockETHUSD","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}