{"status":"1","message":"OK","result":[{"SourceCode":"{\"BalancerSharedPoolPriceProvider.sol\":{\"content\":\"pragma solidity ^0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./BPool.sol\\\";\\nimport \\\"./ILatestAnswerGetter.sol\\\";\\nimport \\\"./BNum.sol\\\";\\n\\n/** @title BalancerSharedPoolPriceProvider\\n * @notice Price provider for a balancer pool token\\n * It calculates the price using Chainlink as an external price source and the pool\\u0027s tokens balances using the weigthed arithmetic mean formula.\\n * If there is a price deviation, instead of the balances, it uses a weighted geometric mean with the token\\u0027s weights and constant value function V.\\n */\\n\\ncontract BalancerSharedPoolPriceProvider is BNum {\\n    BPool public pool;\\n    address[] public tokens;\\n    uint256[] public weights;\\n    bool[] public isPeggedToEth;\\n    uint8[] public decimals;\\n    ILatestAnswerGetter[] public tokenPriceProviders;\\n    uint256 public immutable priceDeviation;\\n    uint256 internal immutable K;\\n    uint256 internal immutable powerPrecision;\\n    uint256[][] internal approximationMatrix;\\n\\n    /**\\n     * BalancerSharedPoolPriceProvider constructor.\\n     * @param _pool Balancer pool address.\\n     * @param _isPeggedToEth For each token, true if it is pegged to eth (token order determined by pool.getFinalTokens()).\\n     * @param _decimals Number of decimals for each token (token order determined by pool.getFinalTokens()).\\n     * @param _tokenPriceProviders Chainlinkprice aggregators for each token (token order determined by pool.getFinalTokens()).\\n     * @param _priceDeviation Threshold of spot prices deviation: 10ˆ16 represents a 1% deviation.\\n     * @param _K //Constant K = 1 / (w1ˆw1 * .. * wn^wn)\\n     * @param _powerPrecision //Precision for power math function.\\n     * @param _approximationMatrix //Approximation matrix for gas optimization.\\n     */\\n    constructor(\\n        BPool _pool,\\n        bool[] memory _isPeggedToEth,\\n        uint8[] memory _decimals,\\n        ILatestAnswerGetter[] memory _tokenPriceProviders,\\n        uint256 _priceDeviation,\\n        uint256 _K,\\n        uint256 _powerPrecision,\\n        uint256[][] memory _approximationMatrix\\n    ) public {\\n        pool = _pool;\\n        //Get token list\\n        tokens = pool.getFinalTokens(); //This already checks for pool finalized\\n        //Get token normalizsed weights\\n        for (uint256 i = 0; i \\u003c tokens.length; i++) {\\n            weights.push(pool.getNormalizedWeight(tokens[i]));\\n        }\\n        isPeggedToEth = _isPeggedToEth;\\n        decimals = _decimals;\\n        tokenPriceProviders = _tokenPriceProviders;\\n        priceDeviation = _priceDeviation;\\n        K = _K;\\n        powerPrecision = _powerPrecision;\\n        approximationMatrix = _approximationMatrix;\\n    }\\n\\n    /**\\n     * Returns the token balance in ethers by multiplying its balance with its price in ethers.\\n     * @param index Token index.\\n     */\\n    function getEthBalanceByToken(uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 pi = isPeggedToEth[index]\\n            ? BONE\\n            : uint256(tokenPriceProviders[index].latestAnswer());\\n        uint256 missingDecimals = 18 - decimals[index];\\n        uint256 bi = bmul(\\n            pool.getBalance(tokens[index]),\\n            BONE * 10**(missingDecimals)\\n        );\\n        return bmul(bi, pi);\\n    }\\n\\n    /**\\n     * Using the matrix approximation, returns a near base and exponentiation result, for num ^ weights[index]\\n     * @param index Token index.\\n     * @param num Base to approximate.\\n     */\\n    function getClosestBaseAndExponetation(uint256 index, uint256 num)\\n        internal\\n        view\\n        returns (uint256, uint256)\\n    {\\n        uint256 k = index + 1;\\n        for (uint256 i = 0; i \\u003c approximationMatrix.length; i++) {\\n            if (approximationMatrix[i][0] \\u003e= num) {\\n                return (approximationMatrix[i][0], approximationMatrix[i][k]);\\n            }\\n        }\\n        return (0, 0);\\n    }\\n\\n    /**\\n     * Returns true if there is a price deviation.\\n     * @param ethTotals Balance of each token in ethers.\\n     */\\n    function hasDeviation(uint256[] memory ethTotals)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        //Check for a price deviation\\n        for (uint256 i = 0; i \\u003c tokens.length; i++) {\\n            for (uint256 o = i + 1; o \\u003c tokens.length; o++) {\\n                uint256 price_deviation = bdiv(\\n                    bdiv(ethTotals[i], weights[i]),\\n                    bdiv(ethTotals[o], weights[o])\\n                );\\n                if (\\n                    price_deviation \\u003e (BONE + priceDeviation) ||\\n                    price_deviation \\u003c (BONE - priceDeviation)\\n                ) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Calculates the price of the pool token using the formula of weigthed arithmetic mean.\\n     * @param ethTotals Balance of each token in ethers.\\n     */\\n    function getArithmeticMean(uint256[] memory ethTotals)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 totalEth = 0;\\n        for (uint256 i = 0; i \\u003c tokens.length; i++) {\\n            totalEth = badd(totalEth, ethTotals[i]);\\n        }\\n        return bdiv(totalEth, pool.totalSupply());\\n    }\\n\\n    /**\\n     * Returns the weigthed token balance in ethers by calculating the balance in eth of the token to the power of its weight.\\n     * @param index Token index.\\n     */\\n    function getWeightedEthBalanceByToken(uint256 index, uint256 ethTotal)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 weight = weights[index];\\n        (uint256 base, uint256 result) = getClosestBaseAndExponetation(\\n            index,\\n            ethTotal\\n        );\\n        if (base == 0 || ethTotal \\u003c MAX_BPOW_BASE) {\\n            return bpowApprox(ethTotal, weight, BPOW_PRECISION);\\n        } else {\\n            return\\n                bmul(\\n                    result,\\n                    bpowApprox(bdiv(ethTotal, base), weight, powerPrecision)\\n                );\\n        }\\n    }\\n\\n    /**\\n     * Calculates the price of the pool token using the formula of weighted geometric mean.\\n     * @param ethTotals Balance of each token in ethers.\\n     */\\n    function getWeightedGeometricMean(uint256[] memory ethTotals)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 mult = BONE;\\n        for (uint256 i = 0; i \\u003c tokens.length; i++) {\\n            mult = bmul(mult, getWeightedEthBalanceByToken(i, ethTotals[i]));\\n        }\\n        return bdiv(bmul(mult, K), pool.totalSupply());\\n    }\\n\\n    /**\\n     * Returns the pool\\u0027s token price.\\n     * It calculates the price using Chainlink as an external price source and the pool\\u0027s tokens balances using the weigthed arithmetic mean formula.\\n     * If there is a price deviation, instead of the balances, it uses a weighted geometric mean with the token\\u0027s weights and constant value function V.\\n     */\\n    function latestAnswer() external view returns (uint256) {\\n        //Ge token balances in eth\\n        uint256[] memory ethTotals = new uint256[](tokens.length);\\n        for (uint256 i = 0; i \\u003c tokens.length; i++) {\\n            ethTotals[i] = getEthBalanceByToken(i);\\n        }\\n\\n        if (hasDeviation(ethTotals)) {\\n            //Calculte the weighted geometric mean\\n            return getWeightedGeometricMean(ethTotals);\\n        } else {\\n            //Calculte the weigthed arithmetic mean\\n            return getArithmeticMean(ethTotals);\\n        }\\n    }\\n\\n    /**\\n     * Returns all tokens.\\n     */\\n    function getTokens() external view returns (address[] memory) {\\n        return tokens;\\n    }\\n\\n    /**\\n     * Returns all tokens\\u0027s weights.\\n     */\\n    function getWeights() external view returns (uint256[] memory) {\\n        return weights;\\n    }\\n}\\n\"},\"BConst.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity ^0.6.6;\\n\\ncontract BConst {\\n    uint public constant BONE              = 10**18;\\n\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\n    uint public constant MAX_BOUND_TOKENS  = 8;\\n\\n    uint public constant MIN_FEE           = BONE / 10**6;\\n    uint public constant MAX_FEE           = BONE / 10;\\n    uint public constant EXIT_FEE          = 0;\\n\\n    uint public constant MIN_WEIGHT        = BONE;\\n    uint public constant MAX_WEIGHT        = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\\n    uint public constant MIN_BALANCE       = BONE / 10**12;\\n\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\"},\"BNum.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity ^0.6.6;\\n\\nimport \\\"./BConst.sol\\\";\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure \\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a \\u003e= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 \\u003e= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 \\u003e= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base \\u003e= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base \\u003c= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = bfloor(exp);   \\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom \\n        //         = (product(a - i - 1, i=1--\\u003ek) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term \\u003e= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n}\"},\"BPool.sol\":{\"content\":\"pragma solidity ^0.6.6;\\n\\n\\ninterface BPool {\\n\\n    function getFinalTokens() external view returns (address[] memory tokens);\\n    function getNormalizedWeight(address token) external view returns (uint);\\n    function getBalance(address token) external view returns (uint);\\n    function totalSupply() external view returns (uint);\\n \\n}\"},\"ILatestAnswerGetter.sol\":{\"content\":\"pragma solidity ^0.6.6;\\n\\ninterface ILatestAnswerGetter {\\n  function latestAnswer() external view returns (int256);\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract BPool\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"_isPeggedToEth\",\"type\":\"bool[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_decimals\",\"type\":\"uint8[]\"},{\"internalType\":\"contract ILatestAnswerGetter[]\",\"name\":\"_tokenPriceProviders\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_priceDeviation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_powerPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"_approximationMatrix\",\"type\":\"uint256[][]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeights\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isPeggedToEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract BPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenPriceProviders\",\"outputs\":[{\"internalType\":\"contract ILatestAnswerGetter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"weights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BalancerSharedPoolPriceProvider","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009866772a9bdb4dc9d2c5a4753e8658b8b0ca1fc30000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000006a94d74f4300000000000000000000000000000000000000000000000000001b33c7d98b9620000000000000000000000000000000000000000000000000000000000005f5e10000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000002000000000000000000000000da3d675d50ff6c555973c4f0424964e1f6a4e7d3000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000048000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000580000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000006800000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000078000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000880000000000000000000000000000000000000000000000000000000000000090000000000000000000000000000000000000000000000000000000000000009800000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a800000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000b800000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000008ac7230489e80000000000000000000000000000000000000000000000000000373f9b9fa1c5412800000000000000000000000000000000000000000000000022dc0366a24088e000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000056bc75e2d63100000000000000000000000000000000000000000000000000000dbf2b79d3bcb6e4800000000000000000000000000000000000000000000000057901b9e55a82ec8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000036ba1142f58915ea0000000000000000000000000000000000000000000000000dbf2b79d3bcb9170000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000000d9df1541761350250000000000000000000000000000000000000000000000002287c143c51b4ba70000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000152d02c7e14af680000000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000056bc75e2d63100000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000d3c21bcecceda10000000000000000000000000000000000000000000000000000d7d077e78fea55b04000000000000000000000000000000000000000000000000d9df154176138f9f00000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000084595161401484a00000000000000000000000000000000000000000000000000035b2c1d3e3193119900000000000000000000000000000000000000000000000022344ac9d975b860a0000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000d5c6d36d8f1f7d9a100000000000000000000000000000000000000000000000055eacfb96b5b81c28000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000033b2e3c9fd0803ce8000000000000000000000000000000000000000000000000003530f6b07b53a6f929000000000000000000000000000000000000000000000000d7d077e78fea974d2000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000204fce5e3e2502611000000000000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000001431e0fae6d7217caa0000000000000000000000000000000000000000000000000034b0654608a2b7c85df00000000000000000000000000000000000000000000000551b244d921fa41a1c00000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000c9f2c9cd04674edea400000000000000000000000000000000000000000000000000d1c24523af19f09646800000000000000000000000000000000000000000000000d5c6d36d8f1ff9945800000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000007e37be2022c0914b268000000000000000000000000000000000000000000000000034310a9e3f712f3bb1c00000000000000000000000000000000000000000000000218fb9246defbeaffa00000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000004ee2d6d415b85acef8100000000000000000000000000000000000000000000000000cfc743a161bf38a79ab00000000000000000000000000000000000000000000000544d6ed67437bb8a3b000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000314dc6448d9338c15b0a000000000000000000000000000000000000000000000000033b2e3c9fd0803ce800000000000000000000000000000000000000000000000000d3c21bcecceda10000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000001ed09bead87c0378d8e640000000000000000000000000000000000000000000000000cdd10b9991bb9afda0148000000000000000000000000000000000000000000000213e9a2e4d145c1a32f000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000013426172c74d822b878fe80000000000000000000000000000000000000000000000003335ede1363fd62584db500000000000000000000000000000000000000000000005381aa96cbe879c445c0000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000c097ce7bc90715b34b9f10000000000000000000000000000000000000000000000000cbdf917a27d1ade8851820000000000000000000000000000000000000000000000d1c24523af1a6f3f33c000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000785ee10d5da46d900f436a00000000000000000000000000000000000000000000000032ba2602e65d3077f5124c00000000000000000000000000000000000000000000020ee3f4bc565c57d99d6000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000004b3b4ca85a86c47a098a224000000000000000000000000000000000000000000000000c9f2c9cd04674edea4000000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000","EVMVersion":"petersburg","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6231f5a77d8a61ea8addc508fe8ecfc1f7707ce428101654e014e1b3c3708dac"}]}