{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\n\n\ninterface IERCProxy {\n    function proxyType() external pure returns (uint proxyTypeId);\n    function implementation() external view returns (address codeAddr);\n}\n\ncontract Proxy is IERCProxy {\n    function delegatedFwd(address _dst, bytes memory _calldata) internal {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let result := delegatecall(\n                sub(gas(), 10000),\n                _dst,\n                add(_calldata, 0x20),\n                mload(_calldata),\n                0,\n                0\n            )\n            let size := returndatasize()\n\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result\n                case 0 {\n                    revert(ptr, size)\n                }\n                default {\n                    return(ptr, size)\n                }\n        }\n    }\n\n    function proxyType() external pure returns (uint proxyTypeId) {\n        // Upgradeable proxy\n        proxyTypeId = 2;\n    }\n\n    function implementation() public view returns (address);\n}\n\ncontract OwnableProxy {\n    bytes32 constant OWNER_SLOT = keccak256(\"proxy.owner\");\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() internal {\n        _transferOwnership(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns(address _owner) {\n        bytes32 position = OWNER_SLOT;\n        assembly {\n            _owner := sload(position)\n        }\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(), \"NOT_OWNER\");\n        _;\n    }\n\n    function isOwner() public view returns (bool) {\n        return owner() == msg.sender;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"OwnableProxy: new owner is the zero address\");\n        emit OwnershipTransferred(owner(), newOwner);\n        bytes32 position = OWNER_SLOT;\n        assembly {\n            sstore(position, newOwner)\n        }\n    }\n}\n\ncontract UpgradableProxy is OwnableProxy, Proxy {\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(\"proxy.implementation\");\n\n    event ProxyUpdated(address indexed previousImpl, address indexed newImpl);\n\n    function() external payable {\n        delegatedFwd(implementation(), msg.data);\n    }\n\n    function implementation() public view returns(address _impl) {\n        bytes32 position = IMPLEMENTATION_SLOT;\n        assembly {\n            _impl := sload(position)\n        }\n    }\n\n    // ACLed on onlyOwner via the call to updateImplementation()\n    function updateAndCall(address _newProxyTo, bytes memory data) public {\n        updateImplementation(_newProxyTo);\n        // sometimes required to initialize the contract\n        (bool success, bytes memory returnData) = address(this).call(data);\n        require(success, string(returnData));\n    }\n\n    function updateImplementation(address _newProxyTo) public onlyOwner {\n        require(_newProxyTo != address(0x0), \"INVALID_PROXY_ADDRESS\");\n        require(isContract(_newProxyTo), \"DESTINATION_ADDRESS_IS_NOT_A_CONTRACT\");\n        emit ProxyUpdated(implementation(), _newProxyTo);\n        setImplementation(_newProxyTo);\n    }\n\n    function setImplementation(address _newProxyTo) private {\n        bytes32 position = IMPLEMENTATION_SLOT;\n        assembly {\n            sstore(position, _newProxyTo)\n        }\n    }\n\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n        uint size;\n        assembly {\n            size := extcodesize(_target)\n        }\n        return size > 0;\n    }\n}\n\ncontract CoreProxy is UpgradableProxy {\n    constructor() public UpgradableProxy() {}\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousImpl\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImpl\",\"type\":\"address\"}],\"name\":\"ProxyUpdated\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proxyTypeId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newProxyTo\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"updateAndCall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newProxyTo\",\"type\":\"address\"}],\"name\":\"updateImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CoreProxy","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"1","Implementation":"0x154c28ba3736ee4e5e89e0081a00f04ec67992f0","SwarmSource":""}]}