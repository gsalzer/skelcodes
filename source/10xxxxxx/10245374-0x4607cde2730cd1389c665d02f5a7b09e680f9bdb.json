{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n*\r\n*  ███████╗████████╗██╗  ██╗    ██████╗ ██████╗  ██████╗ \r\n*  ██╔════╝╚══██╔══╝██║  ██║    ██╔══██╗██╔══██╗██╔═══██╗\r\n*  █████╗     ██║   ███████║    ██████╔╝██████╔╝██║   ██║\r\n*  ██╔══╝     ██║   ██╔══██║    ██╔═══╝ ██╔══██╗██║   ██║\r\n*  ███████╗   ██║   ██║  ██║    ██║     ██║  ██║╚██████╔╝\r\n*  ╚══════╝   ╚═╝   ╚═╝  ╚═╝    ╚═╝     ╚═╝  ╚═╝ ╚═════╝ \r\n*\r\n* \r\n* ETH PRO\r\n* https://eth-pro.github.io/\r\n* or\r\n* https://eth-pro.netlify.app/\r\n* \r\n**/\r\n\r\n\r\npragma solidity ^0.6.7;\r\n\r\n/**\r\n    Utilities & Common Modifiers\r\n*/\r\n\r\ncontract GreaterThanZero {\r\n    // verifies that an amount is greater than zero\r\n    modifier greaterThanZero(uint256 _amount) {\r\n        require(_amount > 0);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ValidAddress {\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n}\r\n\r\ncontract OnlyPayloadSize {\r\n\t//Mitigate short address attack and compatible padding problem while using “call“ \r\n\tmodifier onlyPayloadSize(uint256 numCount){\r\n\t\tassert((msg.data.length == numCount*32 + 4) || (msg.data.length == (numCount + 1)*32));\r\n\t\t_;\r\n\t}\r\n}\r\n\r\ncontract NotThis {\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n}\r\n\r\ncontract SafeMath {\r\n    // Overflow protected math functions\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x);        //assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y);        //assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        require(_x == 0 || z / _x == _y);        //assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n\t\r\n\tfunction safeDiv(uint256 _x, uint256 _y)internal pure returns (uint256){\r\n\t    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return _x / _y;\r\n\t}\r\n\t\r\n\tfunction ceilDiv(uint256 _x, uint256 _y)internal pure returns (uint256){\r\n\t\treturn (_x + _y - 1) / _y;\r\n\t}\r\n}\r\n\r\n\r\ncontract Sqrt {\r\n\tfunction sqrt(uint x)public pure returns(uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract Floor {\r\n\t/**\r\n        @dev Returns the largest integer smaller than or equal to _x.\r\n        @param _x   number _x\r\n        @return     value\r\n    */\r\n\tfunction floor(uint _x)public pure returns(uint){\r\n\t\treturn (_x / 1 ether) * 1 ether;\r\n\t}\r\n}\r\n\r\ncontract Ceil {\r\n\t/**\r\n        @dev Returns the smallest integer larger than or equal to _x.\r\n        @param _x   number _x\r\n        @return ret    value ret\r\n    */\r\n\tfunction ceil(uint _x)public pure returns(uint ret){\r\n\t\tret = (_x / 1 ether) * 1 ether;\r\n\t\tif((_x % 1 ether) == 0){\r\n\t\t\treturn ret;\r\n\t\t}else{\r\n\t\t\treturn ret + 1 ether;\r\n\t\t}\r\n\t}\r\n}\r\n\t\r\ncontract IsContract {\r\n\t//assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) internal view returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n              //retrieve the size of the code on target address, this needs assembly\r\n              length := extcodesize(_addr)\r\n        }\r\n        return (length>0);\r\n    }\r\n}\r\n    \r\ncontract LogEvent {\r\n    // todo: for debug\r\n    event logEvent(string name, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n    ERC20 Standard Token interface\r\n*/\r\ninterface IERC20Token {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _holder) external view returns (uint256);\r\n    function allowance(address _holder, address _spender) external view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _amount) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\r\n    function approve(address _spender, uint256 _amount) external returns (bool success);\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(address indexed _holder, address indexed _spender, uint256 _amount);\r\n}\r\n\r\n\r\n/**\r\n    ERC20 Standard Token implementation\r\n*/\r\ncontract ERC20Token is IERC20Token, SafeMath, ValidAddress {\r\n    string  internal/*public*/ m_name = '';\r\n    string  internal/*public*/ m_symbol = '';\r\n    uint8   internal/*public*/ m_decimals = 0;\r\n    uint256 internal/*public*/ m_totalSupply = 0;\r\n    mapping (address => uint256) internal/*public*/ m_balanceOf;\r\n    mapping (address => mapping (address => uint256)) internal/*public*/ m_allowance;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(address indexed _holder, address indexed _spender, uint256 _amount);\r\n\r\n    ///**\r\n    //    @dev constructor\r\n    //\r\n    //    @param _name        token name\r\n    //    @param _symbol      token symbol\r\n    //    @param _decimals    decimal points, for display purposes\r\n    //*/\r\n    //constructor(string  memory _name, string  memory _symbol, uint8 _decimals) public{\r\n    //    require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input\r\n    //\r\n    //    m_name = _name;\r\n    //    m_symbol = _symbol;\r\n    //    m_decimals = _decimals;\r\n    //}\r\n\r\n    function name() override public view returns (string memory){\r\n        return m_name;\r\n    }\r\n    function symbol() override public view returns (string memory){\r\n        return m_symbol;\r\n    }\r\n    function decimals() override public view returns (uint8){\r\n        return m_decimals;\r\n    }\r\n    function totalSupply() override public view returns (uint256){\r\n        return m_totalSupply;\r\n    }\r\n    function balanceOf(address _holder) override public view returns(uint256){\r\n        return m_balanceOf[_holder];\r\n    }\r\n    function allowance(address _holder, address _spender) override public view returns (uint256){\r\n        return m_allowance[_holder][_spender];\r\n    }\r\n    \r\n    /**\r\n        @dev send coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        @param _to      target address\r\n        @param _amount   transfer amount\r\n\r\n        @return success is true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _amount)\r\n        virtual \r\n        override \r\n        public\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        m_balanceOf[msg.sender] = safeSub(m_balanceOf[msg.sender], _amount);\r\n        m_balanceOf[_to]        = safeAdd(m_balanceOf[_to], _amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev an account/contract attempts to get the coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        @param _from    source address\r\n        @param _to      target address\r\n        @param _amount   transfer amount\r\n\r\n        @return success is true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount)\r\n        virtual\r\n        override \r\n        public\r\n        validAddress(_from)\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        m_allowance[_from][msg.sender]  = safeSub(m_allowance[_from][msg.sender], _amount);\r\n        m_balanceOf[_from]              = safeSub(m_balanceOf[_from], _amount);\r\n        m_balanceOf[_to]                = safeAdd(m_balanceOf[_to], _amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev allow another account/contract to spend some tokens on your behalf\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        also, to minimize the risk of the approve/transferFrom attack vector\r\n        (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\r\n        in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\r\n\r\n        @param _spender approved address\r\n        @param _amount   allowance amount\r\n\r\n        @return success is true if the approval was successful, false if it wasn't\r\n    */\r\n    function approve(address _spender, uint256 _amount)\r\n        override \r\n        public\r\n        validAddress(_spender)\r\n        returns (bool success)\r\n    {\r\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\r\n        require(_amount == 0 || m_allowance[msg.sender][_spender] == 0);\r\n\r\n        m_allowance[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n    Provides support and utilities for contract Creator\r\n*/\r\ncontract Creator {\r\n    address payable public creator;\r\n    address payable public newCreator;\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    constructor() public {\r\n        creator = msg.sender;\r\n    }\r\n\r\n    // allows execution by the creator only\r\n    modifier creatorOnly {\r\n        assert(msg.sender == creator);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract creatorship\r\n        the new creator still needs to accept the transfer\r\n        can only be called by the contract creator\r\n\r\n        @param _newCreator    new contract creator\r\n    */\r\n    function transferCreator(address payable _newCreator) virtual public creatorOnly {\r\n        require(_newCreator != creator);\r\n        newCreator = _newCreator;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new creator to accept an Creator transfer\r\n    */\r\n    function acceptCreator() virtual public {\r\n        require(msg.sender == newCreator);\r\n        creator = newCreator;\r\n        newCreator = address(0x0);\r\n    }\r\n}\r\n\r\n/**\r\n    Provides support and utilities for disable contract functions\r\n*/\r\ncontract Disable is Creator {\r\n\tbool public disabled;\r\n\t\r\n\tmodifier enabled {\r\n\t\tassert(!disabled);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tfunction disable(bool _disable) public creatorOnly {\r\n\t\tdisabled = _disable;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n    Smart Token interface\r\n     is IOwned, IERC20Token\r\n*/\r\nabstract contract ISmartToken{\r\n    function disableTransfers(bool _disable) virtual public;\r\n    function issue(address _to, uint256 _amount) virtual internal;\r\n    function destroy(address _from, uint256 _amount) virtual internal;\r\n\t//function() public payable;\r\n}\r\n\r\n\r\n/**\r\n    SmartToken implementation\r\n*/\r\ncontract SmartToken is ISmartToken, Creator, ERC20Token, NotThis {\r\n\r\n    bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false if not\r\n\r\n    // triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory\r\n    event NewSmartToken(address _token);\r\n    // triggered when the total supply is increased\r\n    event Issuance(uint256 _amount);\r\n    // triggered when the total supply is decreased\r\n    event Destruction(uint256 _amount);\r\n\r\n    ///**\r\n    //    @dev constructor\r\n    //\r\n    //    @param _name       token name\r\n    //    @param _symbol     token short symbol, minimum 1 character\r\n    //    @param _decimals   for display purposes only\r\n    //*/\r\n    //constructor(string memory _name, string memory _symbol, uint8 _decimals)\r\n    //    ERC20Token(_name, _symbol, _decimals) public\r\n    //{\r\n    //    emit NewSmartToken(address(this));\r\n    //}\r\n\r\n    // allows execution only when transfers aren't disabled\r\n    modifier transfersAllowed {\r\n        assert(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev disables/enables transfers\r\n        can only be called by the contract creator\r\n\r\n        @param _disable    true to disable transfers, false to enable them\r\n    */\r\n    function disableTransfers(bool _disable) override public creatorOnly {\r\n        transfersEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n        @dev increases the token supply and sends the new tokens to an account\r\n        can only be called by the contract creator\r\n\r\n        @param _to         account to receive the new amount\r\n        @param _amount     amount to increase the supply by\r\n    */\r\n    function issue(address _to, uint256 _amount)\r\n        override\r\n        internal\r\n        //creatorOnly\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        m_totalSupply = safeAdd(m_totalSupply, _amount);\r\n        m_balanceOf[_to] = safeAdd(m_balanceOf[_to], _amount);\r\n\r\n        emit Issuance(_amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev removes tokens from an account and decreases the token supply\r\n        can be called by the contract creator to destroy tokens from any account or by any holder to destroy tokens from his/her own account\r\n\r\n        @param _from       account to remove the amount from\r\n        @param _amount     amount to decrease the supply by\r\n    */\r\n    function destroy(address _from, uint256 _amount) virtual override internal {\r\n        //require(msg.sender == _from || msg.sender == creator); // validate input\r\n\r\n        m_balanceOf[_from] = safeSub(m_balanceOf[_from], _amount);\r\n        m_totalSupply = safeSub(m_totalSupply, _amount);\r\n\r\n        emit Transfer(_from, address(0), _amount);\r\n        emit Destruction(_amount);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _amount) virtual override public transfersAllowed returns (bool success){\r\n        return super.transfer(_to, _amount);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _amount) virtual override public transfersAllowed returns (bool success){\r\n        return super.transferFrom(_from, _to, _amount);\r\n    }\r\n}\r\n\r\n\r\ncontract Formula is SafeMath {\r\n\r\n    uint256 public constant ONE = 1; \r\n    uint32 public constant MAX_WEIGHT = 1000000;\r\n    uint8 public constant MIN_PRECISION = 32;\r\n    uint8 public constant MAX_PRECISION = 127;\r\n\r\n    /**\r\n        The values below depend on MAX_PRECISION. If you choose to change it:\r\n        Apply the same change in file 'PrintIntScalingFactors.py', run it and paste the results below.\r\n    */\r\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\r\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\r\n    uint256 private constant MAX_NUM = 0x1ffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n        The values below depend on MAX_PRECISION. If you choose to change it:\r\n        Apply the same change in file 'PrintLn2ScalingFactors.py', run it and paste the results below.\r\n    */\r\n    uint256 private constant LN2_NUMERATOR   = 0x3f80fe03f80fe03f80fe03f80fe03f8;\r\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\r\n\r\n    /**\r\n        The values below depend on MIN_PRECISION and MAX_PRECISION. If you choose to change either one of them:\r\n        Apply the same change in file 'PrintFunctionBancorFormula.py', run it and paste the results below.\r\n    */\r\n    uint256[128] private maxExpArray;\r\n\r\n    constructor () public {\r\n\r\n    //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\r\n    //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\r\n    //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\r\n    //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\r\n    //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\r\n    //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\r\n        maxExpArray[ 32] = 0x1c35fedd14ffffffffffffffffffffffff;\r\n        maxExpArray[ 33] = 0x1b0ce43b323fffffffffffffffffffffff;\r\n        maxExpArray[ 34] = 0x19f0028ec1ffffffffffffffffffffffff;\r\n        maxExpArray[ 35] = 0x18ded91f0e7fffffffffffffffffffffff;\r\n        maxExpArray[ 36] = 0x17d8ec7f0417ffffffffffffffffffffff;\r\n        maxExpArray[ 37] = 0x16ddc6556cdbffffffffffffffffffffff;\r\n        maxExpArray[ 38] = 0x15ecf52776a1ffffffffffffffffffffff;\r\n        maxExpArray[ 39] = 0x15060c256cb2ffffffffffffffffffffff;\r\n        maxExpArray[ 40] = 0x1428a2f98d72ffffffffffffffffffffff;\r\n        maxExpArray[ 41] = 0x13545598e5c23fffffffffffffffffffff;\r\n        maxExpArray[ 42] = 0x1288c4161ce1dfffffffffffffffffffff;\r\n        maxExpArray[ 43] = 0x11c592761c666fffffffffffffffffffff;\r\n        maxExpArray[ 44] = 0x110a688680a757ffffffffffffffffffff;\r\n        maxExpArray[ 45] = 0x1056f1b5bedf77ffffffffffffffffffff;\r\n        maxExpArray[ 46] = 0x0faadceceeff8bffffffffffffffffffff;\r\n        maxExpArray[ 47] = 0x0f05dc6b27edadffffffffffffffffffff;\r\n        maxExpArray[ 48] = 0x0e67a5a25da4107fffffffffffffffffff;\r\n        maxExpArray[ 49] = 0x0dcff115b14eedffffffffffffffffffff;\r\n        maxExpArray[ 50] = 0x0d3e7a392431239fffffffffffffffffff;\r\n        maxExpArray[ 51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\r\n        maxExpArray[ 52] = 0x0c2d415c3db974afffffffffffffffffff;\r\n        maxExpArray[ 53] = 0x0bad03e7d883f69bffffffffffffffffff;\r\n        maxExpArray[ 54] = 0x0b320d03b2c343d5ffffffffffffffffff;\r\n        maxExpArray[ 55] = 0x0abc25204e02828dffffffffffffffffff;\r\n        maxExpArray[ 56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\r\n        maxExpArray[ 57] = 0x09deaf736ac1f569ffffffffffffffffff;\r\n        maxExpArray[ 58] = 0x0976bd9952c7aa957fffffffffffffffff;\r\n        maxExpArray[ 59] = 0x09131271922eaa606fffffffffffffffff;\r\n        maxExpArray[ 60] = 0x08b380f3558668c46fffffffffffffffff;\r\n        maxExpArray[ 61] = 0x0857ddf0117efa215bffffffffffffffff;\r\n        maxExpArray[ 62] = 0x07ffffffffffffffffffffffffffffffff;\r\n        maxExpArray[ 63] = 0x07abbf6f6abb9d087fffffffffffffffff;\r\n        maxExpArray[ 64] = 0x075af62cbac95f7dfa7fffffffffffffff;\r\n        maxExpArray[ 65] = 0x070d7fb7452e187ac13fffffffffffffff;\r\n        maxExpArray[ 66] = 0x06c3390ecc8af379295fffffffffffffff;\r\n        maxExpArray[ 67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\r\n        maxExpArray[ 68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\r\n        maxExpArray[ 69] = 0x05f63b1fc104dbd39587ffffffffffffff;\r\n        maxExpArray[ 70] = 0x05b771955b36e12f7235ffffffffffffff;\r\n        maxExpArray[ 71] = 0x057b3d49dda84556d6f6ffffffffffffff;\r\n        maxExpArray[ 72] = 0x054183095b2c8ececf30ffffffffffffff;\r\n        maxExpArray[ 73] = 0x050a28be635ca2b888f77fffffffffffff;\r\n        maxExpArray[ 74] = 0x04d5156639708c9db33c3fffffffffffff;\r\n        maxExpArray[ 75] = 0x04a23105873875bd52dfdfffffffffffff;\r\n        maxExpArray[ 76] = 0x0471649d87199aa990756fffffffffffff;\r\n        maxExpArray[ 77] = 0x04429a21a029d4c1457cfbffffffffffff;\r\n        maxExpArray[ 78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\r\n        maxExpArray[ 79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\r\n        maxExpArray[ 80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\r\n        maxExpArray[ 81] = 0x0399e96897690418f785257fffffffffff;\r\n        maxExpArray[ 82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\r\n        maxExpArray[ 83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\r\n        maxExpArray[ 84] = 0x032cbfd4a7adc790560b3337ffffffffff;\r\n        maxExpArray[ 85] = 0x030b50570f6e5d2acca94613ffffffffff;\r\n        maxExpArray[ 86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\r\n        maxExpArray[ 87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\r\n        maxExpArray[ 88] = 0x02af09481380a0a35cf1ba02ffffffffff;\r\n        maxExpArray[ 89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\r\n        maxExpArray[ 90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\r\n        maxExpArray[ 91] = 0x025daf6654b1eaa55fd64df5efffffffff;\r\n        maxExpArray[ 92] = 0x0244c49c648baa98192dce88b7ffffffff;\r\n        maxExpArray[ 93] = 0x022ce03cd5619a311b2471268bffffffff;\r\n        maxExpArray[ 94] = 0x0215f77c045fbe885654a44a0fffffffff;\r\n        maxExpArray[ 95] = 0x01ffffffffffffffffffffffffffffffff;\r\n        maxExpArray[ 96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\r\n        maxExpArray[ 97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\r\n        maxExpArray[ 98] = 0x01c35fedd14b861eb0443f7f133fffffff;\r\n        maxExpArray[ 99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\r\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\r\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\r\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\r\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\r\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\r\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\r\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\r\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\r\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\r\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\r\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\r\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\r\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\r\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\r\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\r\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\r\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\r\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\r\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\r\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\r\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\r\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\r\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\r\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\r\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\r\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\r\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\r\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\r\n    }\r\n\r\n    /**\r\n        @dev given a token supply, connector balance, weight and a deposit amount (in the connector token),\r\n        calculates the return for a given conversion (in the main token)\r\n\r\n        Formula:\r\n        Return = _supply * ((1 + _depositAmount / _connectorBalance) ^ (_connectorWeight / 1000000) - 1)\r\n\r\n        @param _supply              token total supply\r\n        @param _connectorBalance    total connector balance\r\n        @param _connectorWeight     connector weight, represented in ppm, 1-1000000\r\n        @param _depositAmount       deposit amount, in connector token\r\n\r\n        @return purchase return amount\r\n    */\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256) {\r\n        // validate input\r\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT);\r\n\r\n        // special case for 0 deposit amount\r\n        if (_depositAmount == 0)\r\n            return 0;\r\n\r\n        // special case if the weight = 100%\r\n        if (_connectorWeight == MAX_WEIGHT)\r\n            return safeMul(_supply, _depositAmount) / _connectorBalance;\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseN = safeAdd(_depositAmount, _connectorBalance);\r\n        (result, precision) = power(baseN, _connectorBalance, _connectorWeight, MAX_WEIGHT);\r\n        uint256 temp = safeMul(_supply, result) >> precision;\r\n        return temp - _supply;\r\n    }\r\n\r\n    /**\r\n        @dev given a token supply, connector balance, weight and a sell amount (in the main token),\r\n        calculates the return for a given conversion (in the connector token)\r\n\r\n        Formula:\r\n        Return = _connectorBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_connectorWeight / 1000000)))\r\n\r\n        @param _supply              token total supply\r\n        @param _connectorBalance    total connector\r\n        @param _connectorWeight     constant connector Weight, represented in ppm, 1-1000000\r\n        @param _sellAmount          sell amount, in the token itself\r\n\r\n        @return sale return amount\r\n    */\r\n    function calculateRedeemReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256) {\r\n        // validate input\r\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT && _sellAmount <= _supply);\r\n\r\n        // special case for 0 sell amount\r\n        if (_sellAmount == 0)\r\n            return 0;\r\n\r\n        // special case for selling the entire supply\r\n        if (_sellAmount == _supply)\r\n            return _connectorBalance;\r\n\r\n        // special case if the weight = 100%\r\n        if (_connectorWeight == MAX_WEIGHT)\r\n            return safeMul(_connectorBalance, _sellAmount) / _supply;\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseD = _supply - _sellAmount;\r\n        (result, precision) = power(_supply, baseD, MAX_WEIGHT, _connectorWeight);\r\n        uint256 temp1 = safeMul(_connectorBalance, result);\r\n        uint256 temp2 = _connectorBalance << precision;\r\n        return (temp1 - temp2) / result;\r\n    }\r\n    \r\n    /**\r\n        General Description:\r\n            Determine a value of precision.\r\n            Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\r\n            Return the result along with the precision used.\r\n\r\n        Detailed Description:\r\n            Instead of calculating \"base ^ exp\", we calculate \"e ^ (ln(base) * exp)\".\r\n            The value of \"ln(base)\" is represented with an integer slightly smaller than \"ln(base) * 2 ^ precision\".\r\n            The larger \"precision\" is, the more accurately this value represents the real value.\r\n            However, the larger \"precision\" is, the more bits are required in order to store this value.\r\n            And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\r\n            This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\r\n            Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\r\n            This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\r\n            This functions assumes that \"_expN < (1 << 256) / ln(MAX_NUM, 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\r\n    */\r\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) public view returns (uint256, uint8) {\r\n        \r\n        uint256 lnBaseTimesExp = ln(_baseN, _baseD) * _expN / _expD;\r\n        uint8 precision = findPositionInMaxExpArray(lnBaseTimesExp);\r\n        assert(precision >= MIN_PRECISION);                                     //hhj+ move from findPositionInMaxExpArray\r\n        return (fixedExp(lnBaseTimesExp >> (MAX_PRECISION - precision), precision), precision);\r\n    }\r\n\r\n    // support _baseN < _baseD\r\n    function power2(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) public view returns (uint256, uint8) {\r\n        if(_baseN >= _baseD)\r\n            return power(_baseN, _baseD, _expN, _expD);\r\n        uint256 lnBaseTimesExp = ln(_baseD, _baseN) * _expN / _expD;\r\n        uint8 precision = findPositionInMaxExpArray(lnBaseTimesExp);\r\n        if(precision < MIN_PRECISION)\r\n            return (0, 0);\r\n        uint256 base = fixedExp(lnBaseTimesExp >> (MAX_PRECISION - precision), precision);\r\n        base = (uint256(1) << (MIN_PRECISION + MAX_PRECISION)) / base;\r\n        precision = MIN_PRECISION + MAX_PRECISION - precision;\r\n        return (base, precision);\r\n    }\r\n\r\n    /**\r\n        Return floor(ln(numerator / denominator) * 2 ^ MAX_PRECISION), where:\r\n        - The numerator   is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\r\n        - The denominator is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\r\n        - The output      is a value between 0 and floor(ln(2 ^ (256 - MAX_PRECISION) - 1) * 2 ^ MAX_PRECISION)\r\n        This functions assumes that the numerator is larger than or equal to the denominator, because the output would be negative otherwise.\r\n    */\r\n    function ln(uint256 _numerator, uint256 _denominator) public pure returns (uint256) {\r\n        assert(_numerator <= MAX_NUM);\r\n\r\n        uint256 res = 0;\r\n        uint256 x = _numerator * FIXED_1 / _denominator;\r\n\r\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\r\n        if (x >= FIXED_2) {\r\n            uint8 count = floorLog2(x / FIXED_1);\r\n            x >>= count; // now x < 2\r\n            res = count * FIXED_1;\r\n        }\r\n\r\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\r\n        if (x > FIXED_1) {\r\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\r\n                x = (x * x) / FIXED_1; // now 1 < x < 4\r\n                if (x >= FIXED_2) {\r\n                    x >>= 1; // now 1 < x < 2\r\n                    res += ONE << (i - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return res * LN2_NUMERATOR / LN2_DENOMINATOR;\r\n    }\r\n\r\n    /**\r\n        Compute the largest integer smaller than or equal to the binary logarithm of the input.\r\n    */\r\n    function floorLog2(uint256 _n) internal/*public*/ pure returns (uint8) {\r\n        uint8 res = 0;\r\n\r\n        if (_n < 256) {\r\n            // At most 8 iterations\r\n            while (_n > 1) {\r\n                _n >>= 1;\r\n                res += 1;\r\n            }\r\n        }\r\n        else {\r\n            // Exactly 8 iterations\r\n            for (uint8 s = 128; s > 0; s >>= 1) {\r\n                if (_n >= (ONE << s)) {\r\n                    _n >>= s;\r\n                    res |= s;\r\n                }\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n        The global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\r\n        - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\r\n        - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\r\n    */\r\n    function findPositionInMaxExpArray(uint256 _x) internal/*public*/ view returns (uint8) {\r\n        uint8 lo = MIN_PRECISION;\r\n        uint8 hi = MAX_PRECISION;\r\n\r\n        while (lo + 1 < hi) {\r\n            uint8 mid = (lo + hi) / 2;\r\n            if (maxExpArray[mid] >= _x)\r\n                lo = mid;\r\n            else\r\n                hi = mid;\r\n        }\r\n\r\n        if (maxExpArray[hi] >= _x)\r\n            return hi;\r\n        if (maxExpArray[lo] >= _x)\r\n            return lo;\r\n\r\n        //assert(false);                                                        // move to power\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n        This function can be auto-generated by the script 'PrintFunctionFixedExp.py'.\r\n        It approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\r\n        It returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\r\n        The global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\r\n        The maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\r\n    */\r\n    function fixedExp(uint256 _x, uint8 _precision) internal/*public*/ pure returns (uint256) {\r\n        uint256 xi = _x;\r\n        uint256 res = 0;\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x03442c4e6074a82f1797f72ac0000000; // add x^2 * (33! / 2!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0116b96f757c380fb287fd0e40000000; // add x^3 * (33! / 3!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0045ae5bdd5f0e03eca1ff4390000000; // add x^4 * (33! / 4!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000defabf91302cd95b9ffda50000000; // add x^5 * (33! / 5!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0002529ca9832b22439efff9b8000000; // add x^6 * (33! / 6!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000054f1cf12bd04e516b6da88000000; // add x^7 * (33! / 7!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000a9e39e257a09ca2d6db51000000; // add x^8 * (33! / 8!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000012e066e7b839fa050c309000000; // add x^9 * (33! / 9!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000052b6b54569976310000; // add x^17 * (33! / 17!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000004985f67696bf748000; // add x^18 * (33! / 18!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000001317c70077000; // add x^23 * (33! / 23!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000082573a0a00; // add x^25 * (33! / 25!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000005035ad900; // add x^26 * (33! / 26!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000002f881b00; // add x^27 * (33! / 27!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000001b29340; // add x^28 * (33! / 28!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000000000efc40; // add x^29 * (33! / 29!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000007fe0; // add x^30 * (33! / 30!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000000420; // add x^31 * (33! / 31!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000000021; // add x^32 * (33! / 32!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000000001; // add x^33 * (33! / 33!)\r\n\r\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\r\n    }\r\n   \r\n} \r\n\r\n\r\ncontract Constant {\r\n    uint256 internal constant ONE_DAY                           = 86400;\r\n    uint256 internal constant ONE_HOUR                          = 3600; \r\n    uint256 internal constant UP_NODE_CONTER                    = 9;     \r\n    uint256 internal constant SPEND_PERSENT_EVERY_DATE          = 1;    \r\n    \r\n    function getAdjustedNow() internal view returns(uint256){\r\n       return   now+ONE_HOUR*9;\r\n    }\r\n    function getAdjustedDate()internal view returns(uint256)\r\n    {\r\n        return (now+ONE_HOUR*9) - (now+ONE_HOUR*9)%ONE_DAY - ONE_HOUR*9;\r\n    }\r\n    \r\n}\r\n\r\n\r\n/**\r\n    EProToken implementation\r\n*/\r\ncontract EProToken is SmartToken, Constant, Floor, Sqrt, Formula {\r\n    uint32  public weight                           = MAX_WEIGHT;               // 100%\r\n    uint256 public reserve;\r\n    uint256 public profitPool;\r\n    mapping (address => uint256) public stakingOf;\r\n    mapping (address => uint256) public lastDay4ProfitOf;\r\n    mapping (address => uint256) public profitedOf;\r\n    uint256 public totalProfited;\r\n    uint256 public totalDestroyed;\r\n    mapping (address => uint256) public remainderOf;\r\n    \r\n    constructor() public{\r\n        m_name = \"ETH PRO Token\";\r\n        m_symbol = \"EPRO\";\r\n        m_decimals = 18;\r\n    }\r\n    \r\n    function issueToken(address _holder, address _parent, uint256 _value) virtual internal {\r\n        uint256 value2 = safeAdd(_value, remainderOf[_holder]);\r\n        uint256 amount = floor(safeDiv(value2, 9));\r\n        remainderOf[_holder] = safeSub(value2, safeMul(amount, 9)); \r\n        issue(_holder, amount);\r\n        if(_parent != address(0)){\r\n\t\t    value2 = safeAdd(_value, remainderOf[_parent]);\r\n\t\t\tamount = floor(safeDiv(value2, 9));\r\n\t\t\tremainderOf[_parent] = safeSub(value2, safeMul(amount, 9));\r\n            issue(_parent, amount);\r\n\t\t}\r\n        _value = safeDiv(_value, 40);                                           // 2.5%\r\n        profitPool = safeAdd(profitPool, _value);\r\n        reserve = safeAdd(reserve, _value);\r\n        adjustWeight();\r\n        emitPrice();\r\n    }\r\n    \r\n    function destroy(address _from, uint256 _amount) virtual override internal {\r\n        super.destroy(_from, _amount);\r\n        totalDestroyed = safeAdd(totalDestroyed, _amount);\r\n    }\r\n    \r\n    function calcWeight(uint256 _reserve) virtual public pure returns (uint32 weight_) {\r\n        weight_ = uint32(safeDiv(safeMul(MAX_WEIGHT, 2e9), sqrt(_reserve)));\r\n        if(weight_ > MAX_WEIGHT)\r\n            weight_ = MAX_WEIGHT;\r\n    }\r\n    \r\n    // adjust weight when reserve changed\r\n    function adjustWeight() virtual internal {\r\n        weight = calcWeight(reserve);\r\n    }\r\n    \r\n    // tax 10% when transfer or unstake\r\n    event Tax(address _to, uint256 _amount);\r\n    function tax(address _to, uint256 _amount) virtual internal {\r\n        if(_to == address(this))                                                // no tax when stake\r\n            return;\r\n            \r\n        destroy(_to, _amount / 10);\r\n        emit Tax(_to, _amount / 10);\r\n        emitPrice();\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _amount) override public transfersAllowed returns (bool success){\r\n        success = super.transfer(_to, _amount);\r\n        tax(_to, _amount);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _amount) override public transfersAllowed returns (bool success){\r\n        success = super.transferFrom(_from, _to, _amount);\r\n        tax(_to, _amount);\r\n    }\r\n    \r\n    function totalStaking() virtual public view returns (uint256){\r\n        return balanceOf(address(this));\r\n    }\r\n    \r\n    event Stake(address _holder, uint256 _amount);\r\n    function stake(uint256 _amount) virtual public returns (bool success){\r\n        success = transfer(address(this), _amount);\r\n        stakingOf[msg.sender] = safeAdd(stakingOf[msg.sender], _amount);\r\n        lastDay4ProfitOf[msg.sender] = getAdjustedNow() / ONE_DAY;\r\n        emit Stake(msg.sender, _amount);\r\n    }\r\n    \r\n    event Unstake(address _holder, uint256 _amount);\r\n    function unstake(uint256 _amount) virtual public returns (bool success){\r\n        stakingOf[msg.sender] = safeSub(stakingOf[msg.sender], _amount);\r\n        success = this.transfer(msg.sender, _amount);\r\n        emit Unstake(msg.sender, _amount);\r\n    }\r\n    \r\n    function profitingOf(address _holder) virtual public view returns (uint256){\r\n        uint256 day = safeSub( getAdjustedNow() / ONE_DAY, lastDay4ProfitOf[_holder]);\r\n        if(day < 1)\r\n            return 0;\r\n        //if(day > 7)\r\n        //    day = 7;\r\n        if(totalStaking() == 0)\r\n            return 0;\r\n        if(stakingOf[_holder] * day > totalStaking())\r\n            return profitPool / 10;\r\n        else\r\n            return profitPool / 10 * stakingOf[_holder] * day / totalStaking();\r\n    }\r\n    \r\n    event DivideProfit(address _holder, uint256 _value);\r\n    function divideProfit() virtual public returns (uint256 profit){\r\n        profit = profitingOf(msg.sender);\r\n        profitedOf[msg.sender] = safeAdd(profitedOf[msg.sender], profit);\r\n        totalProfited = safeAdd(totalProfited, profit);\r\n        profitPool = safeSub(profitPool, profit);\r\n        lastDay4ProfitOf[msg.sender] =  getAdjustedNow() / ONE_DAY;\r\n        msg.sender.transfer(profit);\r\n        emit DivideProfit(msg.sender, profit);\r\n    }\r\n    \r\n    function price() virtual public view returns (uint256){\r\n        if(m_totalSupply == 0)\r\n            return 0.01 ether;\r\n\t\treturn safeDiv(safeMul(safeDiv(safeMul(reserve, MAX_WEIGHT), weight), 1 ether), m_totalSupply);   \r\n    }\r\n    \r\n    event Price(uint256 _price, uint256 _reserve, uint256 _supply, uint32 _weight);\r\n    function emitPrice() virtual internal {\r\n        emit Price(price(), reserve, m_totalSupply, weight);\r\n    }\r\n    \r\n    function calcPurchaseRet(uint256 _value) virtual public view returns (uint256 amount, uint256 price_, uint256 tax_) {\r\n        uint256 value_90 = safeDiv(safeMul(_value, 90), 100);                   // 90% into reserve, 10% to distributePool\r\n        uint32  weight_ = calcWeight(safeAdd(reserve, value_90));\r\n        uint256 value_85 = safeDiv(safeMul(_value, 85), 100);                   // 85% token returns\r\n        amount = calculatePurchaseReturn(m_totalSupply, reserve, weight_, value_85);\r\n        price_ = safeDiv(safeMul(value_85, 1 ether), amount);\r\n        tax_ = safeSub(_value, value_85);\r\n    }\r\n    \r\n    function purchase() virtual public payable returns (uint256 amount){\r\n        uint256 value_90 = safeDiv(safeMul(msg.value, 90), 100);                // 90% into reserve, 10% to distributePool\r\n        weight = calcWeight(safeAdd(reserve, value_90));\r\n        uint256 value_85 = safeDiv(safeMul(msg.value, 85), 100);                // 85% token returns\r\n        amount = calculatePurchaseReturn(m_totalSupply, reserve, weight, value_85);\r\n        reserve = safeAdd(reserve, value_90);\r\n        issue(msg.sender, amount);\r\n        emitPrice();\r\n    }\r\n    \r\n    function calcRedeemRet(uint256 _amount) virtual public view returns (uint256 value_, uint256 price_, uint256 tax_) {\r\n        value_ = calculateRedeemReturn(m_totalSupply, reserve, weight, _amount);\r\n        price_ = safeDiv(safeMul(value_, 1 ether), _amount);\r\n        tax_ = safeDiv(safeMul(value_, 15), 100); \r\n        value_ -= tax_;\r\n    }\r\n    \r\n    function redeem(uint256 _amount) virtual public returns (uint256 value_){\r\n        value_ = calculateRedeemReturn(m_totalSupply, reserve, weight, _amount);\r\n        reserve = safeSub(reserve, safeDiv(safeMul(value_, 95), 100));\r\n        adjustWeight();\r\n        destroy(msg.sender, _amount);\r\n        value_ = safeDiv(safeMul(value_, 85), 100);                             // 85% redeem, 5% to reserve, 10% to distributePool\r\n        msg.sender.transfer(value_);\r\n        emitPrice();\r\n    }\r\n        \r\n}\r\n\r\n\r\n/**\r\n    Main contract Ethpro implementation\r\n*/\r\ncontract EthPro is EProToken {\r\n    \r\n    function purchase() virtual override public payable returns (uint256 amount){\r\n        uint256 tax = safeDiv(msg.value, 10);\r\n        distributePool = safeAdd(distributePool, tax);  // 10% to distributePool\r\n        ethTax[roundNo] = safeAdd(ethTax[roundNo], tax);\r\n        amount = super.purchase();\r\n    }\r\n    \r\n    function redeem(uint256 _amount) virtual override public returns (uint256 value_){\r\n        value_ = super.redeem(_amount);\r\n        uint256 tax = safeDiv(safeMul(value_, 10), 85);\r\n        distributePool = safeAdd(distributePool, tax);  // 10% to distributePool\r\n        ethTax[roundNo] = safeAdd(ethTax[roundNo], tax);\r\n    }\r\n\r\n    uint256 public distributePool;                      \r\n    uint256 public devFund;                             \r\n    uint256 public top3Pool;                            \r\n    mapping (uint256 => uint256) public totalInvestment;\r\n    mapping (uint256 => uint256) public ethTax;         \r\n    mapping (uint256 => uint256) public lastSeriesNo;   \r\n    uint256 public roundNo;                           \r\n\r\n\r\n    struct User{ \r\n        uint256 seriesNo;\r\n        uint256 investment;                           \r\n        mapping (uint256 => uint256) investmentHistory;\r\n        uint256 ethDone;                              \r\n        mapping (uint256 => uint256) ethDoneHistory;   \r\n        uint256 disDone;                              \r\n        uint256 roundFirstDate;                       \r\n        uint256 distributeLastTime;                   \r\n        bool quitted;                                \r\n        bool boxReward;                              \r\n    }\r\n    \r\n    struct User1{                                     \r\n        uint256 sonAmount;                            \r\n        uint256 sonAmountPre;                         \r\n        uint256 sonAmountDate;                        \r\n        uint256 sonTotalAmount1;                      \r\n        uint256 sonTotalAmount9;                      \r\n        \r\n        uint256 linkReward;                           \r\n        uint256 nodeReward;                           \r\n        uint256 supNodeReward;                        \r\n        uint256 linkRewardTotal;                      \r\n        uint256 nodeRewardTotal;                      \r\n        uint256 supNodeRewardTotal;                   \r\n    }\r\n    \r\n    struct User2{\r\n\t    uint256 firstTime;                            \r\n        uint256 roundNo;                              \r\n        address parent;                               \r\n        uint256 sonCount;                             \r\n        uint256 sonNodeCount;                         \r\n\t\tuint256 supNodeCount;                         \r\n    }\r\n\r\n    mapping (uint256 => mapping(address => User)) public user;     \r\n    mapping (uint256 => mapping(address => User1)) public user1;   \r\n    mapping (address => User2) public user2;                     \r\n    \r\n    mapping(uint256 => uint256) public quitAmount;                \r\n    mapping(uint256 => uint256) public quitLastTime;              \r\n\r\n    address[3] public top3;                                      \r\n    address[3] public top3Pre;                                   \r\n    bool[3]    public top3Withdraw;                             \r\n    uint256    public top3date;                                 \r\n    uint256    public top3PoolPre;                                 \r\n    \r\n    mapping(uint256 => uint256) public boxExpire;\r\n    mapping(uint256 => uint256) public boxLastSeriesNo;           \r\n    \r\n    constructor() public{\r\n        roundNo = 1;\r\n        boxExpire[roundNo]=now+72*ONE_HOUR;\r\n        quitLastTime[roundNo] = getAdjustedDate();\r\n    }\r\n    \r\n    event logAddrAmount(uint256 indexed lastSeriesNo,uint256 indexed round,address send, uint256 amount,uint256 logtime);\r\n    event logProfit(uint256 indexed round,address addr, uint256 profitAmount,uint256 invitAmount,uint256 logtime);\r\n    \r\n    event loglink(uint256 indexed round, address indexed parent, address indexed addr, uint256 investment, uint256 invitAmount, uint256 sonCount, uint256 nodeCount, uint256 supNodeCount, uint256 firstTime);\r\n\r\n\t\r\n    receive() external payable  {\r\n      if (msg.value==0)\r\n        distributionReward();\r\n      else\r\n        play(address(0));\r\n    }\r\n\r\n    function limSub(uint256 _x,uint256 _y) internal pure returns (uint256) {\r\n      if (_x>_y)\r\n        return _x - _y;\r\n      else\r\n        return 0;\r\n    }\r\n\r\n    function play(address parent) public payable { \r\n      address addr=msg.sender;\r\n      uint256 value=msg.value;\r\n      if (value<(1 ether))\r\n        revert();\r\n      if (now > boxExpire[roundNo])          \r\n        revert();\r\n      if  (((parent==address(0))||(user2[parent].roundNo == 0))&&(addr!=creator)){ \r\n          parent=creator;\r\n      }\r\n      if(user2[addr].parent==address(0))\r\n        user2[addr].parent = parent;\r\n      else\r\n        parent = user2[addr].parent;\r\n        \r\n\t  if (user2[addr].firstTime==0)\r\n\t       user2[addr].firstTime = now;\r\n      bool reinvestment = false; \r\n      if (roundNo>user2[addr].roundNo){ \r\n        user2[addr].roundNo = roundNo;\r\n      }\r\n      \r\n      if(user[roundNo][addr].investment>0){\r\n\t\tif (user[roundNo][addr].ethDone < user[roundNo][addr].investment *125/100){ \r\n          revert();\r\n        }else{\r\n          reinvestment = true;\r\n        }\r\n      }\r\n\r\n      \r\n      uint256 curDay = getAdjustedDate();\r\n      user[roundNo][addr].investment += value;\r\n      user[roundNo][addr].investmentHistory[curDay] = user[roundNo][addr].investment; \r\n      if(user[roundNo][addr].roundFirstDate == 0)\r\n         user[roundNo][addr].roundFirstDate = curDay; \r\n      user[roundNo][addr].distributeLastTime = curDay; \r\n\r\n      totalInvestment[roundNo]     += value;\r\n      distributePool        += value *85 / 100; \r\n      devFund               += value * 4 / 100; \r\n      top3Pool              += value * 3 / 100; \r\n\r\n      if (parent!=address(0)){\r\n          \r\n        nodeReward(parent, value);\r\n\r\n        if (!reinvestment) {\r\n            address parent_temp = addSon(parent);\r\n            if(parent_temp != address(0))\r\n                addSonNode(parent_temp);\r\n        }\r\n\t\t  \r\n        updateSonAmount(parent,value);\r\n\t\t\r\n        emit loglink(roundNo, parent, addr, user[roundNo][addr].investment, user1[roundNo][addr].sonTotalAmount9, user2[addr].sonCount, user2[addr].sonNodeCount, user2[addr].supNodeCount, user2[addr].firstTime);\r\n            \r\n        updateTop3(parent);\r\n\r\n      }\r\n\r\n      lastSeriesNo[roundNo]=lastSeriesNo[roundNo]+1;\r\n      user[roundNo][addr].seriesNo=lastSeriesNo[roundNo];\r\n      if (now<=boxExpire[roundNo]){\r\n        boxLastSeriesNo[roundNo]=lastSeriesNo[roundNo];\r\n        if ((now+72*ONE_HOUR)>(boxExpire[roundNo]+3*ONE_HOUR))\r\n          boxExpire[roundNo]=boxExpire[roundNo]+3*ONE_HOUR;\r\n        else\r\n          boxExpire[roundNo]=now+72*ONE_HOUR;\r\n      }\r\n\r\n      issueToken(addr, parent, value);\r\n\r\n      emit logAddrAmount(lastSeriesNo[roundNo],roundNo,addr,value,now);\r\n    }\r\n\r\n\r\n  function addSon(address addr) internal returns(address){\r\n        user2[addr].sonCount += 1;\r\n        if ((user2[addr].sonCount==UP_NODE_CONTER)&&(user2[addr].parent!=address(0))){\r\n          return user2[addr].parent;\r\n        }\r\n        return address(0);\r\n    }\r\n\r\n    function addSonNode(address addr)internal {\r\n       user2[addr].sonNodeCount += 1;\r\n\t\tif ((user2[addr].sonNodeCount==UP_NODE_CONTER)&&(user2[addr].parent!=address(0)))\r\n\t\t {\r\n\t\t      user2[user2[addr].parent].supNodeCount += 1;\r\n\t\t }\r\n    }\r\n\r\n    function restart() internal returns(bool){\r\n      if (now>boxExpire[roundNo]){ \r\n        if (distributePool < (10 ether)){\r\n          distributePool += totalInvestment[roundNo]* 1/100;\r\n          roundNo = roundNo + 1;\r\n          boxExpire[roundNo]=now + 72*ONE_HOUR;\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n\r\n    function quit() public { \r\n        address payable addr = msg.sender;\r\n        if (user[roundNo][addr].quitted) \r\n            revert();\r\n        uint256 curDay = getAdjustedDate();\r\n        uint256 quitDone = 0; \r\n        if (quitLastTime[roundNo] == curDay)\r\n            quitDone = quitAmount[roundNo];\r\n\r\n        uint256 value = safeSub(user[roundNo][addr].investment*80/100, (user[roundNo][addr].ethDone * 2));\r\n        uint256 quitAmount1= quitDone + value;\r\n        if(quitAmount1 > distributePool *1/100)\r\n            revert();\r\n        \r\n        user[roundNo][addr].quitted = true;\r\n        if (quitLastTime[roundNo] != curDay)\r\n            quitLastTime[roundNo] = curDay;\r\n        \r\n        quitAmount[roundNo] = quitDone + value;\r\n        distributePool = limSub(distributePool, value);\r\n        addr.transfer(value);\r\n        restart();\r\n    }\r\n\r\n\r\n    function distributionReward() public {\r\n      if (user[roundNo][msg.sender].quitted) \r\n         revert();\r\n      address payable addr=msg.sender;\r\n      uint256 curDay = getAdjustedDate();\r\n      uint256[9] memory r=calcUserReward(addr);\r\n      user[roundNo][addr].distributeLastTime = curDay;\r\n      user[roundNo][addr].ethDone += r[4];\r\n      user[roundNo][addr].ethDoneHistory[curDay] = user[roundNo][addr].ethDone;\r\n      user[roundNo][addr].disDone += r[0];\r\n\r\n      distributePool = limSub(distributePool, r[4]);\r\n\r\n      user1[roundNo][addr].linkReward = 0;\r\n      user1[roundNo][addr].nodeReward = 0;\r\n      user1[roundNo][addr].supNodeReward = 0;\r\n      if (addr == creator){\r\n        addr.transfer(r[4] + devFund); \r\n        devFund = 0;\r\n      }\r\n      else\r\n        addr.transfer(r[4]);  \r\n  \r\n      emit logProfit(roundNo, addr, r[8], user1[roundNo][addr].sonTotalAmount1, now);\r\n\r\n      if (user2[addr].parent!=address(0))\r\n        linkReward(user2[addr].parent, r[6] *10/100 /2);\r\n      restart();\r\n    }\r\n    \r\n    function ceilReward(address addr, uint256 amount) public view returns(uint256 amount_) {\r\n        uint256 curDay = getAdjustedDate();\r\n        uint256 day = limSub(curDay , user[roundNo][addr].distributeLastTime) / ONE_DAY;\r\n        if (day>7)\r\n            day=7;\r\n        uint256 disReward = (user[roundNo][addr].investment + floor(user[roundNo][addr].ethDone)) *SPEND_PERSENT_EVERY_DATE/100 * day;\r\n        uint256 sumReward =disReward + user1[roundNo][addr].linkReward + user1[roundNo][addr].nodeReward + user1[roundNo][addr].supNodeReward;\r\n        return limSub(amount, limSub(amount + user[roundNo][addr].ethDone + sumReward, user[roundNo][addr].investment *125/100));\r\n    }\r\n    \r\n    function linkReward(address addr,uint256 amount) internal {\r\n        for(uint i=0; i<9; i++){\r\n            if(user2[addr].sonCount > i) {\r\n                uint256 amount_ = ceilReward(addr, amount);\r\n                if(amount_ > 0){\r\n                    user1[roundNo][addr].linkReward += amount_;\r\n                    user1[roundNo][addr].linkRewardTotal += amount_;\r\n                }\r\n            }\r\n            addr = user2[addr].parent;\r\n            if (addr==address(0))\r\n               break;\r\n        }\r\n    }\r\n\r\n    function nodeReward(address addr,uint256 amount) internal {\r\n        bool bNode = false;\r\n        bool bSupNode = false;\r\n        for (uint i=0; i<200; i++){\r\n            if (addr==address(0))\r\n                break;\r\n            if ((user2[addr].sonCount >= UP_NODE_CONTER) && (user2[addr].sonNodeCount < UP_NODE_CONTER) && (!bNode)){\r\n                uint256 amount_ =  ceilReward(addr, amount * 5/100/2);\r\n                if(amount_ > 0){\r\n                    user1[roundNo][addr].nodeReward += amount_;\r\n                    user1[roundNo][addr].nodeRewardTotal += amount_;\r\n                }\r\n                bNode = true;\r\n            }\r\n            if (user2[addr].sonNodeCount >= UP_NODE_CONTER){                \r\n                if (bNode){\r\n                    uint256 amount_ =  ceilReward(addr, amount * 5/100/2);  \r\n                    if(amount_ > 0){\r\n                        user1[roundNo][addr].supNodeReward += amount_;      \r\n                        user1[roundNo][addr].supNodeRewardTotal += amount_; \r\n                    }\r\n                }else{\r\n                    uint256 amount_ =  ceilReward(addr, amount * 10/100/2); \r\n                    if(amount_ > 0){\r\n                        user1[roundNo][addr].supNodeReward += amount_;      \r\n                        user1[roundNo][addr].supNodeRewardTotal += amount_; \r\n                    }\r\n                }\r\n                bSupNode = true;\r\n            }\r\n            if (bSupNode || addr==creator)\r\n                break;\r\n            addr = user2[addr].parent;\r\n        }\r\n    }\r\n\r\n    function updateSonAmount(address addr,uint value) internal {\r\n      uint256 date = getAdjustedDate();\r\n      if (date == user1[roundNo][addr].sonAmountDate){\r\n        user1[roundNo][addr].sonAmount = user1[roundNo][addr].sonAmount + value;\r\n      }\r\n      else if (date-ONE_DAY == user1[roundNo][addr].sonAmountDate){\r\n        user1[roundNo][addr].sonAmountPre = user1[roundNo][addr].sonAmount;\r\n        user1[roundNo][addr].sonAmount = value;\r\n      }\r\n      else if (user1[roundNo][addr].sonAmountDate==0){\r\n        user1[roundNo][addr].sonAmount = value;\r\n      }\r\n      else{\r\n        user1[roundNo][addr].sonAmountPre = 0;\r\n        user1[roundNo][addr].sonAmount = value;\r\n      }\r\n      user1[roundNo][addr].sonAmountDate = date;\r\n      \r\n      user1[roundNo][addr].sonTotalAmount1 += value;\r\n      for(uint256 i=0; i<9; i++) {\r\n        user1[roundNo][addr].sonTotalAmount9 += value;\r\n\r\n\t\taddress parent = user2[addr].parent;\r\n\t\tif(parent == address(0))\r\n\t\t    break;\r\n\t\t    \r\n        emit loglink(roundNo, parent, addr, user[roundNo][addr].investment, user1[roundNo][addr].sonTotalAmount9, user2[addr].sonCount, user2[addr].sonNodeCount, user2[addr].supNodeCount, user2[addr].firstTime);\r\n            \r\n        addr = parent;\r\n      }\r\n    }\r\n\r\n\r\n    function updateTop3(address addr) internal {\r\n      if (addr == creator) \r\n        return;\r\n      uint256 amount1 = user1[roundNo][addr].sonAmount;\r\n      uint256 date =  getAdjustedDate();\r\n      bool updateTop3date=false;\r\n      address addr0 = top3[0];\r\n      address addr1 = top3[1];\r\n      address addr2 = top3[2];\r\n      if (date == top3date){\r\n        uint256 insertIndex=100;\r\n        uint256 repeateIndex=100;\r\n        address[3] memory tmp;\r\n        if(!((amount1>user1[roundNo][top3[2]].sonAmount)||(amount1>user1[roundNo][top3[1]].sonAmount)))\r\n          return;\r\n        for (uint i=0;i<3;i++){\r\n\t      if (top3[i] == addr)\r\n\t        repeateIndex=i;\r\n\t      else\r\n\t        tmp[i] = top3[i];\r\n        }\r\n        for (uint i=0;i<3;i++){\r\n          if (amount1>user1[roundNo][tmp[i]].sonAmount){\r\n\t        insertIndex = i;\r\n            break;\r\n          }\r\n        }\r\n        uint j=0;//tmp\r\n        for (uint i=0;i<3;i++){\r\n          if (insertIndex==i){\r\n            if (top3[i]!=addr)\r\n\t          top3[i]=addr;\r\n\t      }\r\n          else{\r\n            if (top3[i]!=tmp[j])\r\n              top3[i]=tmp[j];\r\n\t        j += 1;\r\n\t      }\r\n         if(j == repeateIndex)\r\n\t          j += 1;\r\n        }\r\n      }\r\n      else if (date-ONE_DAY == top3date){\r\n        top3Pre[0]=addr0;\r\n        top3Pre[1]=addr1;\r\n        top3Pre[2]=addr2;\r\n        top3[0]=addr;\r\n        top3[1]=address(0);\r\n        top3[2]=address(0);\r\n        top3PoolPre = limSub(top3Pool , msg.value*3/100);\r\n        updateTop3date=true;\r\n      } \r\n      else if(top3date == 0){\r\n        top3[0] = addr;\r\n        updateTop3date = true;\r\n      }\r\n      else{\r\n        for (uint i=0; i<3; i++){\r\n          top3Pre[i] = address(0);\r\n          if (i != 0)\r\n          top3[i] = address(0);\r\n        }\r\n        top3[0] = addr;\r\n        updateTop3date = true;\r\n      }\r\n      if (updateTop3date){\r\n        top3date = date;\r\n        for (uint i=0; i<3; i++)\r\n          top3Withdraw[i] = false;\r\n      }\r\n    }\r\n\r\n    function calcTop3Reward(uint256 rank,uint256 poolAmount) public pure returns(uint256) {\r\n      uint256 ret=0;\r\n      //if (top3date==date){\r\n        if (rank==0)\r\n          ret=poolAmount*3*6/100;\r\n        else if(rank==1)\r\n          ret = poolAmount*3*3/100;\r\n        else if(rank==2)\r\n          ret = poolAmount*3*1/100;\r\n      //}\r\n      return ret;\r\n    }\r\n\r\n    function getTop3Reward() public {\r\n      if (user[roundNo][msg.sender].quitted) \r\n         revert();\r\n      address payable addr=msg.sender;\r\n      uint256 date = getAdjustedDate();\r\n      //uint256 ret = 0;\r\n      uint256 index = 100;\r\n   \r\n      if (date-ONE_DAY == top3date){\r\n        top3Pre[0] = top3[0];\r\n        top3Pre[1] = top3[1];\r\n        top3Pre[2] = top3[2];\r\n        for (uint i=0; i<3; i++){\r\n          top3[i] = address(0);\r\n          top3Withdraw[i] = false;\r\n        }\r\n        top3date = date;\r\n\t\ttop3PoolPre=top3Pool;\r\n      } \r\n\r\n      if (top3date==date){\r\n\r\n        if (addr == top3Pre[0]){\r\n          index = 0;\r\n        }\r\n        else if(addr==top3Pre[1]){\r\n          index =1;\r\n        }\r\n        else if(addr==top3Pre[2]){\r\n          index = 2;\r\n        }\r\n      }\r\n      if ((index<3)&&(!top3Withdraw[index])){\r\n        uint256 ret = calcTop3Reward(index,top3PoolPre);\r\n        top3Pool = limSub(top3Pool,ret);\r\n        top3Withdraw[index] = true;\r\n        addr.transfer(ret);  \r\n      }\r\n    }\r\n\r\n    function calcBoxReward(uint256 rank,uint256 curRoundNo) internal view returns(uint256) {\r\n      if (rank==1){\r\n        //return boxPool[curRoundNo]*25/100;\r\n        return totalInvestment[curRoundNo]*2/100 *25/100;\r\n      }\r\n      else if(rank>=2 && rank<=6){\r\n        //return boxPool[curRoundNo]*25/100/5;\r\n        return totalInvestment[curRoundNo]*2/100 *25/100 /5;\r\n      }\r\n      else if(rank>=7 && rank<=56){\r\n        //return boxPool[curRoundNo]*25/100/50;\r\n        return totalInvestment[curRoundNo]*2/100 *25/100 /50;\r\n      }\r\n      else if(rank>=57 && rank<=556){\r\n        //return boxPool[curRoundNo]*25/100/500;\r\n        return totalInvestment[curRoundNo]*2/100 *25/100 /500;\r\n      }\r\n      return 0;\r\n    }\r\n\r\n    function userBoxInfo(address addr) public view returns(uint256 curRoundNo,uint256 userBoxReward,bool boxOpened,bool drew){\r\n      curRoundNo = user2[addr].roundNo;\r\n      drew = false;\r\n      userBoxReward = 0;\r\n      if (curRoundNo==0){\r\n        boxOpened = false;\r\n        return (curRoundNo,userBoxReward,boxOpened,drew);\r\n      }\r\n      if (now>boxExpire[curRoundNo]){\r\n        boxOpened = true;\r\n        if ((user[curRoundNo][addr].seriesNo>0)&&(boxLastSeriesNo[curRoundNo]>=user[curRoundNo][addr].seriesNo)&&(boxLastSeriesNo[curRoundNo]-user[curRoundNo][addr].seriesNo<556)){\r\n          drew = user[curRoundNo][addr].boxReward;\r\n            //user[curRoundNo][addr].boxReward = true;\r\n          uint256 rank = boxLastSeriesNo[curRoundNo]-user[curRoundNo][addr].seriesNo+1;\r\n          userBoxReward = calcBoxReward(rank,curRoundNo);\r\n        }\r\n      }\r\n    }\r\n\r\n    function getBoxReward() public {\r\n      if (user[roundNo][msg.sender].quitted)\r\n        revert();\r\n      address payable addr=msg.sender;\r\n      uint256 curRoundNo;\r\n      uint256 userBoxReward;\r\n      bool boxOpened;\r\n      bool drew=false;\r\n      (curRoundNo,userBoxReward,boxOpened,drew) = userBoxInfo(addr);\r\n      if ((userBoxReward>0)&&(!drew)){\r\n        user[curRoundNo][addr].boxReward = true;\r\n        //boxPool[curRoundNo] = boxPool[curRoundNo]-userBoxReward;\r\n        addr.transfer(userBoxReward);\r\n      }\r\n    }\r\n\r\n    function quitable(address addr) public view returns(uint256){ \r\n      if (user[roundNo][addr].quitted){\r\n        return 0;\r\n      }\r\n      uint256 curDay = getAdjustedDate();\r\n      uint256 quitDone=0; \r\n      if (quitLastTime[roundNo]==curDay)\r\n        quitDone=quitAmount[roundNo];\r\n      \r\n      uint256 value = limSub(user[roundNo][addr].investment *80/100, user[roundNo][addr].ethDone * 2); \r\n      uint256 quitAmount1= quitDone + value;\r\n      if(quitAmount1 > distributePool *1/100){\r\n         return 2;\r\n      }\r\n      return 1;\r\n\r\n    }\r\n\r\n    function boolToUint256(bool bVar) public pure returns (uint256) {\r\n      if (bVar)\r\n        return 1;\r\n      else\r\n        return 0;\r\n    }\r\n\r\n    function calcIndateInvestment(address addr, uint256 curDay) public view returns (uint256) {\r\n        mapping (uint256 => uint256) storage investmentHistory = user[roundNo][addr].investmentHistory;\r\n        uint256 outdated = 0;\r\n        uint256 roundFirstDate = user[roundNo][addr].roundFirstDate;\r\n        if(roundFirstDate > 0) {\r\n            for(uint256 i = curDay - 125 * ONE_DAY; i >= roundFirstDate; i-= ONE_DAY) {\r\n                if(investmentHistory[i] > 0) {\r\n                    outdated = investmentHistory[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return limSub(user[roundNo][addr].investment, outdated);\r\n    }\r\n    \r\n    function calcIndateEthDone(address addr, uint256 curDay) public view returns (uint256) {\r\n        mapping (uint256 => uint256) storage ethDoneHistory = user[roundNo][addr].ethDoneHistory;\r\n        uint256 outdated = 0;\r\n        uint256 roundFirstDate = user[roundNo][addr].roundFirstDate;\r\n        if(roundFirstDate > 0) {\r\n            for(uint256 i = curDay - 125 * ONE_DAY; i >= roundFirstDate; i-= ONE_DAY) {\r\n                if(ethDoneHistory[i] > 0) {\r\n                    outdated = ethDoneHistory[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return limSub(floor(user[roundNo][addr].ethDone), floor(outdated));\r\n    }\r\n    \r\n    function calcUserReward(address  addr) public view returns(uint256[9] memory r){ \r\n        uint256 curDay = getAdjustedDate();\r\n        uint256 day = limSub(curDay , user[roundNo][addr].distributeLastTime) / ONE_DAY;\r\n        if (day < 1){\r\n            for(uint256 i=0; i<9; i++){\r\n                r[i]=0;\r\n            }\r\n            //return r;\r\n        }\r\n        if (day>7)\r\n            day=7;\r\n        \r\n        uint256 disPure   = calcIndateInvestment(addr, curDay) *SPEND_PERSENT_EVERY_DATE/100 * day;   \r\n        uint256 disReward = disPure + calcIndateEthDone(addr, curDay) *SPEND_PERSENT_EVERY_DATE/100 * day; \r\n        uint256 sumReward = disReward + user1[roundNo][addr].linkReward + user1[roundNo][addr].nodeReward + user1[roundNo][addr].supNodeReward; \r\n        \r\n        if ((user[roundNo][addr].ethDone + sumReward) > (user[roundNo][addr].investment *125/100)){\r\n            sumReward = limSub(user[roundNo][addr].investment *125/100, user[roundNo][addr].ethDone);\r\n        }\r\n        if (disPure > sumReward)\r\n            disPure = sumReward;\r\n        if (sumReward < disReward)\r\n            disReward = sumReward;\r\n        \r\n        r[0] = disReward;                                \r\n        r[1] = user1[roundNo][addr].linkRewardTotal *2;   \r\n        r[2] = user1[roundNo][addr].nodeRewardTotal *2;   \r\n        r[3] = user1[roundNo][addr].supNodeRewardTotal *2;\r\n        \r\n        r[4] = sumReward;                                \r\n        r[5] = limSub((user[roundNo][addr].investment + floor(user[roundNo][addr].ethDone)) *250/100, user[roundNo][addr].disDone *2);\r\n        r[6] = disPure;                                         \r\n        r[7] = user[roundNo][addr].ethDone *2;                   \r\n        if (addr != creator)\r\n            r[8] = (user[roundNo][addr].ethDone + sumReward) *2; \r\n    }\r\n    \r\n \r\n function userTop3RewardInfo(address addr) public view returns(uint256 reward,bool done){  \r\n    uint256 date = getAdjustedDate();\r\n    uint256 index =100;\r\n\tuint256 poolAmount;\r\n    if (top3date==date){\r\n        if (addr == top3Pre[0]){\r\n          index = 0;\r\n        }\r\n        else if(addr==top3Pre[1]){\r\n          index =1;\r\n        }\r\n        else if(addr==top3Pre[2]){\r\n          index = 2;\r\n        }\r\n\t\tpoolAmount = top3PoolPre;\r\n    }\r\n    else if (date-ONE_DAY == top3date){\r\n        if (addr == top3[0]){\r\n          index = 0;\r\n        }\r\n        else if(addr==top3[1]){\r\n          index =1;\r\n        }\r\n        else if(addr==top3[2]){\r\n          index = 2;\r\n        }\r\n\t\tpoolAmount = top3Pool;\r\n    }\r\n    if (index<3){\r\n        reward =  calcTop3Reward(index,poolAmount);\r\n        done = top3Withdraw[index];\r\n    }else{\r\n        reward = 0;\r\n        done = false;\r\n    }\r\n\r\n    \r\n }\r\n\r\n    function getUserInfo(address addr) public view returns(uint256[50] memory ret) {\r\n        uint256[9] memory r= calcUserReward(addr);\r\n        uint256 curUserRoundNo = user2[addr].roundNo;\r\n        \r\n        ret[0] = user[roundNo][addr].seriesNo;\r\n        ret[1] = user[roundNo][addr].investment;           \r\n        ret[2] = user[roundNo][addr].ethDone + r[4];       \r\n        ret[3] = user[roundNo][addr].ethDone;              \r\n        ret[4] = user[roundNo][addr].distributeLastTime;   \r\n        ret[5] = boolToUint256(user[roundNo][addr].quitted);\r\n        ret[6] = uint256(user2[addr].parent);               \r\n        ret[7] = user2[addr].sonCount;                     \r\n        ret[8] = user2[addr].sonNodeCount;                 \r\n        \r\n        uint256 date = getAdjustedDate();\r\n        if (user1[roundNo][addr].sonAmountDate == date){\r\n          ret[9] = user1[roundNo][addr].sonAmount;                       \r\n          ret[10] = user1[roundNo][addr].sonAmountPre;                   \r\n        }else if(date-ONE_DAY == user1[roundNo][addr].sonAmountDate) {\r\n          ret[9] = 0;                              \r\n          ret[10] = user1[roundNo][addr].sonAmount;                      \r\n        }\r\n        bool top3Done;\r\n        (ret[30],top3Done) = userTop3RewardInfo(addr);                   \r\n        ret[31] = boolToUint256(top3Done);                               \r\n        ret[11] = user1[roundNo][addr].sonAmountDate;                    \r\n\r\n        ret[12] = boolToUint256(user[curUserRoundNo][addr].boxReward);   \r\n        ret[13] = user[roundNo][addr].roundFirstDate;\r\n        ret[14] = quitable(addr);                                        \r\n        ret[15] = user[roundNo][addr].ethDone;                           \r\n        ret[16] = balanceOf(addr);                                       \r\n        ret[17] = stakingOf[addr];                                       \r\n        ret[18] = profitedOf[addr];                                      \r\n        \r\n        ret[19] = user[roundNo][addr].disDone *2;                        \r\n        ret[20] = r[1];                                                  \r\n        ret[21] = r[2];                                                  \r\n        ret[22] = r[3];                                                  \r\n        ret[23] = r[4];                                                  \r\n        ret[24] = r[5];                                                  \r\n        ret[25] = limSub(user[roundNo][addr].investment * 250/100, r[7]); \r\n        ret[26] = r[7];                                                  \r\n\r\n        uint256 curRoundNo;\r\n        bool boxOpened;\r\n        bool drew=false;\r\n        //(curRoundNo,userBoxReward,boxOpened,drew) = userBoxInfo(addr);\r\n        (curRoundNo,ret[27], boxOpened, drew) = userBoxInfo(addr);           \r\n        ret[28] = boolToUint256(boxOpened);                                  \r\n        ret[29] = profitingOf(addr);                                         \r\n        \r\n        ret[32] = r[8];                                                      \r\n        \r\n        return ret;\r\n    }\r\n\r\n    function getInfo() public view returns(uint256[50] memory) {\r\n        uint256[50] memory ret;\r\n        ret[0] = distributePool;                 \r\n        ret[1] = top3Pool;                       \r\n        ret[2] = totalInvestment[roundNo]* 2/100;\r\n        ret[3] = totalInvestment[roundNo]* 1/100;\r\n        ret[4] = devFund;                        \r\n        ret[5] = totalInvestment[roundNo];       \r\n        ret[6] = lastSeriesNo[roundNo];          \r\n        ret[7] = roundNo;                        \r\n        ret[8] = boxExpire[roundNo];             \r\n        ret[9] = boxLastSeriesNo[roundNo];       \r\n        ret[10]= ethTax[roundNo];                \r\n\r\n      uint256 i=11;\r\n      uint256 date = getAdjustedDate();\r\n      if (top3date == date){\r\n        for (uint256 j=0;j<3;j++){\r\n          ret[i]=uint256(top3[j]); \r\n          i=i+1;\r\n          ret[i]=user1[roundNo][top3[j]].sonAmount;\r\n          i=i+1;\r\n          if (ret[i-2]==0)\r\n            ret[i] = 0;\r\n          else\r\n            ret[i]=calcTop3Reward(j,top3Pool);\r\n          i=i+1;\r\n        }\r\n      }\r\n      ret[20] = m_totalSupply;\r\n      ret[21] = reserve;\r\n      ret[22] = profitPool;\r\n      ret[23] = totalProfited;\r\n      ret[24] = totalDestroyed;\r\n      ret[25] = price();\r\n      ret[26] = totalStaking();\r\n      ret[27] = uint256(creator);\r\n      ret[28] = weight;\r\n      ret[29] = totalInvestment[roundNo-1]; \r\n\t  uint256 quitDone = 0;  \r\n      if (quitLastTime[roundNo] == date)\r\n\t\tquitDone = quitAmount[roundNo];\r\n\t  ret[30] = limSub(distributePool *1/100, quitDone);\r\n      ret[49] = now;\r\n      return ret;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"DivideProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"NewSmartToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_reserve\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_weight\",\"type\":\"uint32\"}],\"name\":\"Price\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Tax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lastSeriesNo\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"send\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"logtime\",\"type\":\"uint256\"}],\"name\":\"logAddrAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"invitAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"logtime\",\"type\":\"uint256\"}],\"name\":\"logProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"invitAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sonCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supNodeCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstTime\",\"type\":\"uint256\"}],\"name\":\"loglink\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_PRECISION\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_PRECISION\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bVar\",\"type\":\"bool\"}],\"name\":\"boolToUint256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"boxExpire\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"boxLastSeriesNo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"curDay\",\"type\":\"uint256\"}],\"name\":\"calcIndateEthDone\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"curDay\",\"type\":\"uint256\"}],\"name\":\"calcIndateInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"calcPurchaseRet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tax_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calcRedeemRet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tax_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmount\",\"type\":\"uint256\"}],\"name\":\"calcTop3Reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"calcUserReward\",\"outputs\":[{\"internalType\":\"uint256[9]\",\"name\":\"r\",\"type\":\"uint256[9]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserve\",\"type\":\"uint256\"}],\"name\":\"calcWeight\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"weight_\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_connectorBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_connectorWeight\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_depositAmount\",\"type\":\"uint256\"}],\"name\":\"calculatePurchaseReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_connectorBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_connectorWeight\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_sellAmount\",\"type\":\"uint256\"}],\"name\":\"calculateRedeemReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ceilReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"divideProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_x\",\"type\":\"uint256\"}],\"name\":\"floor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBoxReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInfo\",\"outputs\":[{\"internalType\":\"uint256[50]\",\"name\":\"\",\"type\":\"uint256[50]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTop3Reward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256[50]\",\"name\":\"ret\",\"type\":\"uint256[50]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastDay4ProfitOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastSeriesNo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"ln\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newCreator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"}],\"name\":\"play\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_baseD\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_expN\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_expD\",\"type\":\"uint32\"}],\"name\":\"power\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_baseD\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_expN\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_expD\",\"type\":\"uint32\"}],\"name\":\"power2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"profitedOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"profitingOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"quitAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"quitLastTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"quitable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"remainderOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundNo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"sqrt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"top3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"top3Pool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"top3PoolPre\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"top3Pre\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"top3Withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"top3date\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDestroyed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalProfited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newCreator\",\"type\":\"address\"}],\"name\":\"transferCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seriesNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethDone\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"disDone\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundFirstDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distributeLastTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"quitted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"boxReward\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sonAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sonAmountPre\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sonAmountDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sonTotalAmount1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sonTotalAmount9\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"linkReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nodeReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supNodeReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"linkRewardTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nodeRewardTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supNodeRewardTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"firstTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundNo\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sonCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sonNodeCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supNodeCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userBoxInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"curRoundNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userBoxReward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"boxOpened\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"drew\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userTop3RewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"done\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weight\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"EthPro","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://109ad270bb29cf90e3a3537cb7aec6760e684e90eb7c8fce81f96e778bf14faf"}]}