{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"pragma solidity 0.6.4;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);//from address(0) for minting\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"multiSigMobile.sol\":{\"content\":\"pragma solidity 0.6.4;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface aaRouter{\\r\\n    function setHXYAddress(address _hxyAddress) external;\\r\\n    \\r\\n    function setHXBAddress(address _hxbAddress) external;\\r\\n    \\r\\n    function setHXPAddress(address _hxpAddress) external;\\r\\n    \\r\\n    function setSplitter(address _splitter) external;\\r\\n    \\r\\n    function setRatios(uint _hxy, uint _hxb, uint _hxp) external;\\r\\n    \\r\\n    function unlockHxp() external;\\r\\n    \\r\\n}\\r\\n\\r\\n\\r\\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\\r\\ncontract MultiSigWallet {\\r\\n    \\r\\n    //uniswap setup\\r\\n    address public routerAddress = address(0xc1154C084E19cD21002DB3ff5dAF0B4E18f949a2);\\r\\n    aaRouter internal aaRouterInterface = aaRouter(routerAddress);\\r\\n    //constants\\r\\n    uint constant public MAX_OWNER_COUNT = 8;\\r\\n    //events\\r\\n    event Confirmation(address indexed sender, uint indexed transactionId);\\r\\n    event Revocation(address indexed sender, uint indexed transactionId);\\r\\n    event Submission(uint indexed transactionId);\\r\\n    event Execution(uint indexed transactionId);\\r\\n    event ExecutionFailure(uint indexed transactionId);\\r\\n    event Deposit(address indexed sender, uint value);\\r\\n    event OwnerAddition(address indexed owner);\\r\\n    event OwnerRemoval(address indexed owner);\\r\\n    event RequirementChange(uint required);\\r\\n    //mappings\\r\\n    mapping (uint =\\u003e Transaction) public transactions;\\r\\n    mapping (uint =\\u003e mapping (address =\\u003e bool)) public confirmations;\\r\\n    mapping (address =\\u003e bool) public isOwner;\\r\\n    //data\\r\\n    address[] public owners;\\r\\n    uint public required;\\r\\n    uint public transactionCount;\\r\\n\\r\\n    struct Transaction {\\r\\n        address payable destination;\\r\\n        uint inputValue;\\r\\n        uint functionCall;\\r\\n        address tokenAddress;\\r\\n        uint hxyMint;\\r\\n        uint hxbMint;\\r\\n        uint hxpMint;\\r\\n        bool executed;\\r\\n    }\\r\\n    //modifiers\\r\\n    modifier onlyWallet() {\\r\\n        if (msg.sender != address(this))\\r\\n            revert();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier ownerDoesNotExist(address owner) {\\r\\n        if (isOwner[owner])\\r\\n            revert();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier ownerExists(address owner) {\\r\\n        if (!isOwner[owner])\\r\\n            revert();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier transactionExists(uint transactionId) {\\r\\n        if (transactions[transactionId].destination == address(0))\\r\\n            revert();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier confirmed(uint transactionId, address owner) {\\r\\n        if (!confirmations[transactionId][owner])\\r\\n            revert();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notConfirmed(uint transactionId, address owner) {\\r\\n        if (confirmations[transactionId][owner])\\r\\n            revert();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notExecuted(uint transactionId) {\\r\\n        if (transactions[transactionId].executed)\\r\\n            revert();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notNull(address _address) {\\r\\n        if (_address == address(0))\\r\\n            revert();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validRequirement(uint ownerCount, uint _required) {\\r\\n        if (   ownerCount \\u003e MAX_OWNER_COUNT\\r\\n            || _required \\u003e ownerCount\\r\\n            || _required == 0\\r\\n            || ownerCount == 0)\\r\\n            revert();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback function allows to deposit ether.\\r\\n    receive()\\r\\n        external\\r\\n        payable\\r\\n    {\\r\\n        if (msg.value \\u003e 0)\\r\\n            emit Deposit(msg.sender, msg.value);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Public functions\\r\\n     */\\r\\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\\r\\n    /// @param _owners List of initial owners.\\r\\n    /// @param _required Number of required confirmations.\\r\\n    constructor(address[] memory _owners, uint _required)\\r\\n        public\\r\\n        validRequirement(_owners.length, _required)\\r\\n    {\\r\\n        for (uint i=0; i\\u003c_owners.length; i++) {\\r\\n            if (isOwner[_owners[i]] || _owners[i] == address(0))\\r\\n                revert();\\r\\n            isOwner[_owners[i]] = true;\\r\\n        }\\r\\n        owners = _owners;\\r\\n        required = _required;\\r\\n    }\\r\\n\\r\\n    \\r\\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\\r\\n    /// @param owner Address of new owner.\\r\\n    function addOwner(address owner)\\r\\n        public\\r\\n        onlyWallet\\r\\n        ownerDoesNotExist(owner)\\r\\n        notNull(owner)\\r\\n        validRequirement(owners.length + 1, required)\\r\\n    {\\r\\n        isOwner[owner] = true;\\r\\n        owners.push(owner);\\r\\n        emit OwnerAddition(owner);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\\r\\n    /// @param owner Address of owner.\\r\\n    function removeOwner(address owner)\\r\\n        public\\r\\n        onlyWallet\\r\\n        ownerExists(owner)\\r\\n    {\\r\\n        isOwner[owner] = false;\\r\\n        for (uint i=0; i\\u003cowners.length - 1; i++)\\r\\n            if (owners[i] == owner) {\\r\\n                owners[i] = owners[owners.length - 1];\\r\\n                break;\\r\\n            }\\r\\n        owners.pop();\\r\\n        if (required \\u003e owners.length)\\r\\n            changeRequirement(owners.length);\\r\\n        emit OwnerRemoval(owner);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\\r\\n    /// @param owner Address of owner to be replaced.\\r\\n    /// @param owner Address of new owner.\\r\\n    function replaceOwner(address owner, address newOwner)\\r\\n        public\\r\\n        onlyWallet\\r\\n        ownerExists(owner)\\r\\n        ownerDoesNotExist(newOwner)\\r\\n    {\\r\\n        for (uint i=0; i\\u003cowners.length; i++)\\r\\n            if (owners[i] == owner) {\\r\\n                owners[i] = newOwner;\\r\\n                break;\\r\\n            }\\r\\n        isOwner[owner] = false;\\r\\n        isOwner[newOwner] = true;\\r\\n        emit OwnerRemoval(owner);\\r\\n        emit OwnerAddition(newOwner);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\\r\\n    /// @param _required Number of required confirmations.\\r\\n    function changeRequirement(uint _required)\\r\\n        public\\r\\n        onlyWallet\\r\\n        validRequirement(owners.length, _required)\\r\\n    {\\r\\n        \\r\\n        required = _required;\\r\\n        emit RequirementChange(_required);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows an owner to submit and confirm a transaction.\\r\\n    /// @param destination Transaction target address.\\r\\n    /// @param inputValue value to send as input\\r\\n    /// @param callTo define function to call as uint\\r\\n    /// @param tokenAddress use when sending tokens directly as desired token to send\\r\\n    /// @return transactionId Returns transactionId.\\r\\n    function submitTransaction(address payable destination, uint inputValue, uint callTo, address tokenAddress, uint hxyMint, uint hxbMint, uint hxpMint)\\r\\n        public\\r\\n        returns (uint transactionId)\\r\\n    {\\r\\n        transactionId = addTransaction(destination, inputValue, callTo, tokenAddress, hxyMint, hxbMint, hxpMint);\\r\\n        confirmTransaction(transactionId);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows an owner to confirm a transaction.\\r\\n    /// @param transactionId Transaction ID.\\r\\n    function confirmTransaction(uint transactionId)\\r\\n        public\\r\\n        ownerExists(msg.sender)\\r\\n        transactionExists(transactionId)\\r\\n        notConfirmed(transactionId, msg.sender)\\r\\n    {\\r\\n        confirmations[transactionId][msg.sender] = true;\\r\\n        emit Confirmation(msg.sender, transactionId);\\r\\n        uint callTo = transactions[transactionId].functionCall;\\r\\n        if(callTo == 0){\\r\\n            sendEth(transactionId);\\r\\n        }\\r\\n        else if(callTo == 1)\\r\\n        {\\r\\n            sendToken(transactionId);\\r\\n        }\\r\\n        else if(callTo == 2)\\r\\n        {\\r\\n            setHxyAddress(transactionId);\\r\\n        }\\r\\n        else if(callTo == 3)\\r\\n        {\\r\\n            setHxbAddress(transactionId);\\r\\n        }\\r\\n        else if(callTo == 4)\\r\\n        {\\r\\n            setHxpAddress(transactionId);\\r\\n        }\\r\\n        else if(callTo == 5)\\r\\n        {\\r\\n            setSplitterAddress(transactionId);\\r\\n        }\\r\\n        else if(callTo == 6)\\r\\n        {\\r\\n            setMintRatios(transactionId);\\r\\n        }\\r\\n        else if(callTo == 7)\\r\\n        {\\r\\n            setHxpUnlock(transactionId);\\r\\n        }\\r\\n        else{\\r\\n            revert();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\\r\\n    /// @param transactionId Transaction ID.\\r\\n    function revokeConfirmation(uint transactionId)\\r\\n        public\\r\\n        ownerExists(msg.sender)\\r\\n        confirmed(transactionId, msg.sender)\\r\\n        notExecuted(transactionId)\\r\\n    {\\r\\n        confirmations[transactionId][msg.sender] = false;\\r\\n        Revocation(msg.sender, transactionId);\\r\\n    }\\r\\n    \\r\\n    //sends inputValue as ETH to destination\\r\\n    function sendEth(uint transactionId)\\r\\n        public\\r\\n        notExecuted(transactionId)\\r\\n    {\\r\\n        if (isConfirmed(transactionId)) {\\r\\n            Transaction memory _tx = transactions[transactionId];\\r\\n            _tx.executed = true;\\r\\n            require(address(this).balance \\u003e= _tx.inputValue, \\\"eth balance too low\\\");\\r\\n             _tx.destination.transfer(_tx.inputValue);\\r\\n            emit Execution(transactionId);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    //sends inputValue as tokenAddress amount to destination\\r\\n    function sendToken(uint transactionId)\\r\\n        public\\r\\n        notExecuted(transactionId)\\r\\n    {\\r\\n        if (isConfirmed(transactionId)) {\\r\\n            Transaction memory _tx = transactions[transactionId];\\r\\n            _tx.executed = true;\\r\\n            address _token = _tx.tokenAddress;\\r\\n            require(IERC20(_token).balanceOf(address(this)) \\u003e= _tx.inputValue, \\\"hex balance too low\\\");\\r\\n             IERC20(_token).transfer(_tx.destination, _tx.inputValue);\\r\\n            emit Execution(transactionId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //sets aaRouter HXY address as destination\\r\\n    function setHxyAddress(uint transactionId)\\r\\n    public\\r\\n    notExecuted(transactionId)\\r\\n    {\\r\\n        if(isConfirmed(transactionId)){\\r\\n            Transaction memory _tx = transactions[transactionId];\\r\\n            _tx.executed = true;\\r\\n           aaRouterInterface.setHXYAddress(_tx.destination);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    //sets aaRouter HXB address as destination\\r\\n    function setHxbAddress(uint transactionId)\\r\\n    public\\r\\n    notExecuted(transactionId)\\r\\n    {\\r\\n        if(isConfirmed(transactionId)){\\r\\n            Transaction memory _tx = transactions[transactionId];\\r\\n            _tx.executed = true;\\r\\n           aaRouterInterface.setHXBAddress(_tx.destination);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    //sets aaRouter HXP address as destination\\r\\n    function setHxpAddress(uint transactionId)\\r\\n    public\\r\\n    notExecuted(transactionId)\\r\\n    {\\r\\n        if(isConfirmed(transactionId)){\\r\\n            Transaction memory _tx = transactions[transactionId];\\r\\n            _tx.executed = true;\\r\\n           aaRouterInterface.setHXPAddress(_tx.destination);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n   //sets aaRouter SPLITTER address as destination\\r\\n    function setSplitterAddress(uint transactionId)\\r\\n    public\\r\\n    notExecuted(transactionId)\\r\\n    {\\r\\n        if(isConfirmed(transactionId)){\\r\\n            Transaction memory _tx = transactions[transactionId];\\r\\n            _tx.executed = true;\\r\\n           aaRouterInterface.setSplitter(_tx.destination);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    //sets aaRouter mintRatios address as inputValues\\r\\n    function setMintRatios(uint transactionId)\\r\\n    public\\r\\n    notExecuted(transactionId)\\r\\n    {\\r\\n        if(isConfirmed(transactionId)){\\r\\n            Transaction memory _tx = transactions[transactionId];\\r\\n            _tx.executed = true;\\r\\n           aaRouterInterface.setRatios(_tx.hxyMint, _tx.hxbMint, _tx.hxpMint);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    //sets hxp unlockable from contract\\r\\n    function setHxpUnlock(uint transactionId)\\r\\n    public\\r\\n    notExecuted(transactionId)\\r\\n    {\\r\\n        if(isConfirmed(transactionId)){\\r\\n            Transaction memory _tx = transactions[transactionId];\\r\\n            _tx.executed = true;\\r\\n           aaRouterInterface.unlockHxp();\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /// @dev Returns the confirmation status of a transaction.\\r\\n    /// @param transactionId Transaction ID.\\r\\n    /// @return Confirmation status.\\r\\n    function isConfirmed(uint transactionId)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint count = 0;\\r\\n        for (uint i=0; i\\u003cowners.length; i++) {\\r\\n            if (confirmations[transactionId][owners[i]])\\r\\n                count += 1;\\r\\n            if (count == required)\\r\\n                return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Internal functions\\r\\n     */\\r\\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\\r\\n    /// @param destination Transaction target address.\\r\\n    /// @param inputValue  to add as input\\r\\n    /// @return transactionId Returns transaction ID.\\r\\n    function addTransaction(address payable destination, uint inputValue, uint functionCall, address tokenAddress, uint hxyMint, uint hxbMint, uint hxpMint)\\r\\n        internal\\r\\n        notNull(destination)\\r\\n        returns (uint transactionId)\\r\\n    {\\r\\n        transactionId = transactionCount;\\r\\n        transactions[transactionId] = Transaction({\\r\\n            destination: destination,\\r\\n            inputValue: inputValue,\\r\\n            functionCall: functionCall,\\r\\n            tokenAddress: tokenAddress,\\r\\n            hxyMint: hxyMint,\\r\\n            hxbMint: hxbMint,\\r\\n            hxpMint: hxpMint,\\r\\n            executed: false\\r\\n        });\\r\\n        transactionCount += 1;\\r\\n        Submission(transactionId);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Web3 call functions\\r\\n     */\\r\\n    /// @dev Returns number of confirmations of a transaction.\\r\\n    /// @param transactionId Transaction ID.\\r\\n    /// @return count Number of confirmations.\\r\\n    function getConfirmationCount(uint transactionId)\\r\\n        public\\r\\n        view\\r\\n        returns (uint count)\\r\\n    {\\r\\n        for (uint i=0; i\\u003cowners.length; i++)\\r\\n            if (confirmations[transactionId][owners[i]])\\r\\n                count += 1;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns total number of transactions after filers are applied.\\r\\n    /// @param pending Include pending transactions.\\r\\n    /// @param executed Include executed transactions.\\r\\n    /// @return count Total number of transactions after filters are applied.\\r\\n    function getTransactionCount(bool pending, bool executed)\\r\\n        public\\r\\n        view\\r\\n        returns (uint count)\\r\\n    {\\r\\n        for (uint i=0; i\\u003ctransactionCount; i++)\\r\\n            if (   pending \\u0026\\u0026 !transactions[i].executed\\r\\n                || executed \\u0026\\u0026 transactions[i].executed)\\r\\n                count += 1;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns list of owners.\\r\\n    /// @return List of owner addresses.\\r\\n    function getOwners()\\r\\n        public\\r\\n        view\\r\\n        returns (address[]memory)\\r\\n    {\\r\\n        return owners;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns array with owner addresses, which confirmed transaction.\\r\\n    /// @param transactionId Transaction ID.\\r\\n    /// @return _confirmations Returns array of owner addresses.\\r\\n    function getConfirmations(uint transactionId)\\r\\n        public\\r\\n        view\\r\\n        returns (address[] memory _confirmations)\\r\\n    {\\r\\n        address[] memory confirmationsTemp = new address[](owners.length);\\r\\n        uint count = 0;\\r\\n        uint i;\\r\\n        for (i=0; i\\u003cowners.length; i++)\\r\\n            if (confirmations[transactionId][owners[i]]) {\\r\\n                confirmationsTemp[count] = owners[i];\\r\\n                count += 1;\\r\\n            }\\r\\n        _confirmations = new address[](count);\\r\\n        for (i=0; i\\u003ccount; i++)\\r\\n            _confirmations[i] = confirmationsTemp[i];\\r\\n    }\\r\\n\\r\\n    /// @dev Returns list of transaction IDs in defined range.\\r\\n    /// @param from Index start position of transaction array.\\r\\n    /// @param to Index end position of transaction array.\\r\\n    /// @param pending Include pending transactions.\\r\\n    /// @param executed Include executed transactions.\\r\\n    /// @return _transactionIds Returns array of transaction IDs.\\r\\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\\r\\n        public\\r\\n        view\\r\\n        returns (uint[] memory _transactionIds)\\r\\n    {\\r\\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\\r\\n        uint count = 0;\\r\\n        uint i;\\r\\n        for (i=0; i\\u003ctransactionCount; i++)\\r\\n            if (   pending \\u0026\\u0026 !transactions[i].executed\\r\\n                || executed \\u0026\\u0026 transactions[i].executed)\\r\\n            {\\r\\n                transactionIdsTemp[count] = i;\\r\\n                count += 1;\\r\\n            }\\r\\n        _transactionIds = new uint[](to - from);\\r\\n        for (i=from; i\\u003cto; i++)\\r\\n            _transactionIds[i - from] = transactionIdsTemp[i];\\r\\n    }\\r\\n}\\r\\n\\r\\n \"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_required\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"RequirementChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Submission\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"confirmations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_confirmations\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"pending\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"pending\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_transactionIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"sendEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"sendToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"setHxbAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"setHxpAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"setHxpUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"setHxyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"setMintRatios\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"setSplitterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callTo\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hxyMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hxbMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hxpMint\",\"type\":\"uint256\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"functionCall\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hxyMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hxbMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hxpMint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MultiSigWallet","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000cc5dabe96779ebe121da246a6cd45fa8fa4af208000000000000000000000000b5cdb0ad2b6097cb051b27d3149ef80eaa623527000000000000000000000000f72842821c58ade72eda5ec5399b959b499d4aa4000000000000000000000000e551072153c02fa33d4903cab0435fb86f1a80cb","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://de16b99d56d298c9737a414f077ea65b9ff87a9fbb17932e071e6ed0c54f8107"}]}