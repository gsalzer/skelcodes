{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\n\n/**\nAuthor: CoFiX Core\n*/\n\npragma solidity ^0.6.6;\n\n\n// \ninterface ICoFiXFactory {\n    // All pairs: {ETH <-> ERC20 Token}\n    event PairCreated(address indexed token, address pair, uint256);\n\n    /// @dev Create a new token pair for trading\n    /// @param  token the address of token to trade\n    /// @return pair the address of new token pair\n    function createPair(\n        address token\n        )\n        external\n        returns (address pair);\n\n    function getPair(address token) external view returns (address pair);\n    function allPairs(uint256) external view returns (address pair);\n    function allPairsLength() external view returns (uint256);\n\n    function setGovernance(address _new) external;\n    function setController(address _new) external;\n    function setFeeReceiver(address _new) external;\n    function getController() external view returns (address controller);\n    function getFeeReceiver() external view returns (address feeReceiver);\n}\n\n// \n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\n// \ninterface ICoFiXRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    // All pairs: {ETH <-> ERC20 Token}\n\n    /// @dev Maker add liquidity to pool, get pool token (mint XToken to maker) (notice: msg.value = amountETH + oracle fee)\n    /// @param  token The address of ERC20 Token\n    /// @param  amountETH The amount of ETH added to pool\n    /// @param  amountToken The amount of Token added to pool\n    /// @param  liquidityMin The minimum liquidity maker wanted\n    /// @param  to The target address receiving the liquidity pool (XToken)\n    /// @param  deadline The dealine of this request\n    /// @return liquidity The real liquidity or XToken minted from pool\n    function addLiquidity(\n        address token,\n        uint amountETH,\n        uint amountToken,\n        uint liquidityMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint liquidity);\n\n    /// @dev Maker remove liquidity from pool to get ERC20 Token back (maker burn XToken) (notice: msg.value = oracle fee)\n    /// @param  token The address of ERC20 Token\n    /// @param  liquidity The amount of liquidity (XToken) sent to pool, or the liquidity to remove\n    /// @param  amountTokenMin The minimum amount of Token wanted to get from pool\n    /// @param  to The target address receiving the Token\n    /// @param  deadline The dealine of this request\n    /// @return amountToken The real amount of Token transferred from the pool\n    function removeLiquidityGetToken(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken);\n\n    /// @dev Maker remove liquidity from pool to get ETH back (maker burn XToken) (notice: msg.value = oracle fee)\n    /// @param  token The address of ERC20 Token\n    /// @param  liquidity The amount of liquidity (XToken) sent to pool, or the liquidity to remove\n    /// @param  amountETHMin The minimum amount of ETH wanted to get from pool\n    /// @param  to The target address receiving the ETH\n    /// @param  deadline The dealine of this request\n    /// @return amountETH The real amount of ETH transferred from the pool\n    function removeLiquidityGetETH(\n        address token,\n        uint liquidity,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountETH);\n\n    /// @dev Trader swap exact amount of ETH for ERC20 Tokens (notice: msg.value = amountIn + oracle fee)\n    /// @param  token The address of ERC20 Token\n    /// @param  amountIn The exact amount of ETH a trader want to swap into pool\n    /// @param  amountOutMin The minimum amount of Token a trader want to swap out of pool\n    /// @param  to The target address receiving the Token\n    /// @param  deadline The dealine of this request\n    /// @return _amountIn The real amount of ETH transferred into pool\n    /// @return _amountOut The real amount of Token transferred out of pool\n    function swapExactETHForTokens(\n        address token,\n        uint amountIn,\n        uint amountOutMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint _amountIn, uint _amountOut);\n\n    /// @dev Trader swap exact amount of ERC20 Tokens for ETH (notice: msg.value = oracle fee)\n    /// @param  token The address of ERC20 Token\n    /// @param  amountIn The exact amount of Token a trader want to swap into pool\n    /// @param  amountOutMin The mininum amount of ETH a trader want to swap out of pool\n    /// @param  to The target address receiving the ETH\n    /// @param  deadline The dealine of this request\n    /// @return _amountIn The real amount of Token transferred into pool\n    /// @return _amountOut The real amount of ETH transferred out of pool\n    function swapExactTokensForETH(\n        address token,\n        uint amountIn,\n        uint amountOutMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint _amountIn, uint _amountOut);\n\n    /// @dev Trader swap ETH for exact amount of ERC20 Tokens (notice: msg.value = amountInMax + oracle fee)\n    /// @param  token The address of ERC20 Token\n    /// @param  amountInMax The max amount of ETH a trader want to swap into pool\n    /// @param  amountOutExact The exact amount of Token a trader want to swap out of pool\n    /// @param  to The target address receiving the Token\n    /// @param  deadline The dealine of this request\n    /// @return _amountIn The real amount of ETH transferred into pool\n    /// @return _amountOut The real amount of Token transferred out of pool\n    function swapETHForExactTokens(\n        address token,\n        uint amountInMax,\n        uint amountOutExact,\n        address to,\n        uint deadline\n    ) external payable returns (uint _amountIn, uint _amountOut);\n\n    /// @dev Trader swap ERC20 Tokens for exact amount of ETH (notice: msg.value = oracle fee)\n    /// @param  token The address of ERC20 Token\n    /// @param  amountInMax The max amount of Token a trader want to swap into pool\n    /// @param  amountOutExact The exact amount of ETH a trader want to swap out of pool\n    /// @param  to The target address receiving the ETH\n    /// @param  deadline The dealine of this request\n    /// @return _amountIn The real amount of Token transferred into pool\n    /// @return _amountOut The real amount of ETH transferred out of pool\n    function swapTokensForExactETH(\n        address token,\n        uint amountInMax,\n        uint amountOutExact,\n        address to,\n        uint deadline\n    ) external payable returns (uint _amountIn, uint _amountOut); \n}\n\n// \n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n\n    function div(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"ds-math-div-zero\");\n        z = x / y;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    }\n}\n\n// \ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n// \ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n\n// \ninterface ICoFiXERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    // function name() external pure returns (string memory);\n    // function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n\n// \ninterface ICoFiXPair is ICoFiXERC20 {\n\n    struct OraclePrice {\n        uint256 ethAmount;\n        uint256 erc20Amount;\n        uint256 blockNum;\n        uint256 K;\n        uint256 theta;\n    }\n    \n    // All pairs: {ETH <-> ERC20 Token}\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\n\n    function mint(address to) external payable returns (uint liquidity, uint oracleFeeChange);\n    function burn(address outToken, address to) external payable returns (uint amountOut, uint oracleFeeChange);\n    function swapWithExact(address outToken, address to) external payable returns (uint amountIn, uint amountOut, uint oracleFeeChange);\n    function swapForExact(address outToken, uint amountOutExact, address to) external payable returns (uint amountIn, uint amountOut, uint oracleFeeChange);\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address, string memory, string memory) external;\n}\n\n// \ncontract CoFiXRouter is ICoFiXRouter {\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'CRouter: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _WETH) public {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {}\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address _factory, address token) internal view returns (address pair) {\n        // pair = address(uint(keccak256(abi.encodePacked(\n        //         hex'ff',\n        //         _factory,\n        //         keccak256(abi.encodePacked(token)),\n        //         hex'fb0c5470b7fbfce7f512b5035b5c35707fd5c7bd43c8d81959891b0296030118' // init code hash\n        //     )))); // calc the real init code hash, not suitable for us now, could use this in the future\n        return ICoFiXFactory(_factory).getPair(token);\n    }\n\n    // msg.value = amountETH + oracle fee\n    function addLiquidity(\n        address token,\n        uint amountETH,\n        uint amountToken,\n        uint liquidityMin,\n        address to,\n        uint deadline\n    ) external override payable ensure(deadline) returns (uint liquidity)\n    {\n        // create the pair if it doesn't exist yet\n        if (ICoFiXFactory(factory).getPair(token) == address(0)) {\n            ICoFiXFactory(factory).createPair(token);\n        }\n        require(msg.value > amountETH, \"CRouter: insufficient msg.value\");\n        uint256 _oracleFee = msg.value.sub(amountETH);\n        address pair = pairFor(factory, token);\n        if (amountToken > 0 ) { // support for tokens which do not allow to transfer zero values\n            TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        }\n        if (amountETH > 0) {\n            IWETH(WETH).deposit{value: amountETH}();\n            assert(IWETH(WETH).transfer(pair, amountETH));\n        }\n        uint256 oracleFeeChange;\n        (liquidity, oracleFeeChange) = ICoFiXPair(pair).mint{value: _oracleFee}(to);\n        require(liquidity >= liquidityMin, \"CRouter: less liquidity than expected\");\n        // refund oracle fee to msg.sender, if any\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n    }\n\n    // msg.value = oracle fee\n    function removeLiquidityGetToken(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        address to,\n        uint deadline\n    ) external override payable ensure(deadline) returns (uint amountToken)\n    {\n        require(msg.value > 0, \"CRouter: insufficient msg.value\");\n        address pair = pairFor(factory, token);\n        ICoFiXPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        uint oracleFeeChange; \n        (amountToken, oracleFeeChange) = ICoFiXPair(pair).burn{value: msg.value}(token, to);\n        require(amountToken >= amountTokenMin, \"CRouter: got less than expected\");\n        // refund oracle fee to msg.sender, if any\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n    }\n\n    // msg.value = oracle fee\n    function removeLiquidityGetETH(\n        address token,\n        uint liquidity,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external override payable ensure(deadline) returns (uint amountETH)\n    {\n        require(msg.value > 0, \"CRouter: insufficient msg.value\");\n        address pair = pairFor(factory, token);\n        ICoFiXPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        uint oracleFeeChange; \n        (amountETH, oracleFeeChange) = ICoFiXPair(pair).burn{value: msg.value}(WETH, address(this));\n        require(amountETH >= amountETHMin, \"CRouter: got less than expected\");\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n        // refund oracle fee to msg.sender, if any\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n    }\n\n    // msg.value = amountIn + oracle fee\n    function swapExactETHForTokens(\n        address token,\n        uint amountIn,\n        uint amountOutMin,\n        address to,\n        uint deadline\n    ) external override payable ensure(deadline) returns (uint _amountIn, uint _amountOut)\n    {\n        require(msg.value > amountIn, \"CRouter: insufficient msg.value\");\n        IWETH(WETH).deposit{value: amountIn}();\n        address pair = pairFor(factory, token);\n        assert(IWETH(WETH).transfer(pair, amountIn));\n        uint oracleFeeChange; \n        (_amountIn, _amountOut, oracleFeeChange) = ICoFiXPair(pair).swapWithExact{\n            value: msg.value.sub(amountIn)}(token, to);\n        require(_amountOut >= amountOutMin, \"CRouter: got less than expected\");\n        // refund oracle fee to msg.sender, if any\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n    }\n\n    // msg.value = oracle fee\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        uint amountOutMin,\n        address to,\n        uint deadline\n    ) external payable ensure(deadline) returns (uint _amountIn, uint _amountOut) {\n        // swapExactTokensForETH\n        require(msg.value > 0, \"CRouter: insufficient msg.value\");\n        address pairIn = pairFor(factory, tokenIn);\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, pairIn, amountIn);\n        uint oracleFeeChange; \n        (_amountIn, _amountOut, oracleFeeChange) = ICoFiXPair(pairIn).swapWithExact{value: msg.value}(WETH, address(this));\n\n        // swapExactETHForTokens\n        address pairOut = pairFor(factory, tokenOut);\n        assert(IWETH(WETH).transfer(pairOut, _amountOut)); // swap with all amountOut in last swap\n        (, _amountOut, oracleFeeChange) = ICoFiXPair(pairOut).swapWithExact{value: oracleFeeChange}(tokenOut, to);\n        require(_amountOut >= amountOutMin, \"CRouter: got less than expected\");\n        // refund oracle fee to msg.sender, if any\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n    }\n\n    // msg.value = oracle fee\n    function swapExactTokensForETH(\n        address token,\n        uint amountIn,\n        uint amountOutMin,\n        address to,\n        uint deadline\n    ) external override payable ensure(deadline) returns (uint _amountIn, uint _amountOut)\n    {\n        require(msg.value > 0, \"CRouter: insufficient msg.value\");\n        address pair = pairFor(factory, token);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountIn);\n        uint oracleFeeChange; \n        (_amountIn, _amountOut, oracleFeeChange) = ICoFiXPair(pair).swapWithExact{value: msg.value}(WETH, address(this));\n        require(_amountOut >= amountOutMin, \"CRouter: got less than expected\");\n        IWETH(WETH).withdraw(_amountOut);\n        TransferHelper.safeTransferETH(to, _amountOut);\n        // refund oracle fee to msg.sender, if any\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n    }\n\n    // msg.value = amountInMax + oracle fee\n    function swapETHForExactTokens(\n        address token,\n        uint amountInMax,\n        uint amountOutExact,\n        address to,\n        uint deadline\n    ) external override payable ensure(deadline) returns (uint _amountIn, uint _amountOut)\n    {\n        require(msg.value > amountInMax, \"CRouter: insufficient msg.value\");\n        IWETH(WETH).deposit{value: amountInMax}();\n        address pair = pairFor(factory, token);\n        assert(IWETH(WETH).transfer(pair, amountInMax));\n        uint oracleFeeChange; \n        (_amountIn, _amountOut, oracleFeeChange) = ICoFiXPair(pair).swapForExact{\n            value: msg.value.sub(amountInMax) }(token, amountOutExact, to);\n        // assert amountOutExact equals with _amountOut\n        require(_amountIn <= amountInMax, \"CRouter: spend more than expected\");\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n    }\n\n    // msg.value = oracle fee\n    function swapTokensForExactETH(\n        address token,\n        uint amountInMax,\n        uint amountOutExact,\n        address to,\n        uint deadline\n    ) external override payable ensure(deadline) returns (uint _amountIn, uint _amountOut)\n    {\n        require(msg.value > 0, \"CRouter: insufficient msg.value\");\n        address pair = pairFor(factory, token);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountInMax);\n        uint oracleFeeChange; \n        (_amountIn, _amountOut, oracleFeeChange) = ICoFiXPair(pair).swapForExact{\n            value: msg.value}(WETH, amountOutExact, address(this));\n        // assert amountOutExact equals with _amountOut\n        require(_amountIn <= amountInMax, \"CRouter: got less than expected\");\n        IWETH(WETH).withdraw(_amountOut);\n        TransferHelper.safeTransferETH(to, amountOutExact);\n        // refund oracle fee to msg.sender, if any\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityGetETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityGetToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutExact\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutExact\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CoFiXRouter","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"000000000000000000000000d5a19e1adb5592921dcc42e48623d75c4c91e405000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}