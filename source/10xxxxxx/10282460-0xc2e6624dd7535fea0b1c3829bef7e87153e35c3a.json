{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IAaveLendingPool.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract IAaveLendingPool {\r\n  function deposit(\r\n    address _reserve,\r\n    uint256 _amount,\r\n    uint16 _referralCode\r\n  ) public virtual;\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract IERC20 {\r\n  function balanceOf(address user) external virtual view returns (uint256);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external virtual returns (bool);\r\n\r\n  function transfer(address recipient, uint256 amount)\r\n    external\r\n    virtual\r\n    returns (bool);\r\n\r\n  function allowance(address owner, address spender)\r\n    external\r\n    virtual\r\n    view\r\n    returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount)\r\n    external\r\n    virtual\r\n    returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IADai.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\nabstract contract IADai is IERC20 {\r\n  function redeem(uint256 _amount) public virtual;\r\n  // function redirectInterestStream(address _to) public virtual;\r\n}\r\n\r\n// File: contracts/interfaces/IPoolDeposits.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract IPoolDeposits {\r\n  mapping(address => uint256) public depositedDai;\r\n\r\n  function usersDeposit(address userAddress)\r\n    external\r\n    virtual\r\n    view\r\n    returns (uint256);\r\n\r\n  function changeProposalAmount(uint256 amount) external virtual;\r\n\r\n  function redirectInterestStreamToWinner(address _winner) external virtual;\r\n\r\n  function distributeInterest(\r\n    address[] calldata receivers,\r\n    uint256[] calldata percentages,\r\n    address winner,\r\n    uint256 iteration\r\n  ) external virtual;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/NoLossDao_v0.sol\r\n\r\npragma solidity 0.6.10;\r\n\r\n// import \"./interfaces/IERC20.sol\";\r\n\r\n\r\n\r\n// import '@nomiclabs/buidler/console.sol';\r\n\r\n\r\n\r\n/** @title No Loss Dao Contract. */\r\ncontract NoLossDao_v0 is Initializable {\r\n  using SafeMath for uint256;\r\n\r\n  //////// MASTER //////////////\r\n  address public admin;\r\n\r\n  //////// Iteration specific //////////\r\n  uint256 public votingInterval;\r\n  uint256 public proposalIteration;\r\n\r\n  ///////// Proposal specific ///////////\r\n  uint256 public proposalId;\r\n  uint256 public proposalDeadline; // keeping track of time\r\n  mapping(uint256 => string) public proposalIdentifier;\r\n  mapping(address => uint256) public benefactorsProposal; // benefactor -> proposal id\r\n  mapping(uint256 => address) public proposalOwner; // proposal id -> benefactor (1:1 mapping)\r\n  enum ProposalState {DoesNotExist, Withdrawn, Active, Cooldown} // Add Cooldown state and pending state\r\n  mapping(uint256 => ProposalState) public state; // ProposalId to current state\r\n\r\n  //////// User specific //////////\r\n  mapping(address => uint256) public iterationJoined; // Which iteration did user join DAO\r\n  mapping(uint256 => mapping(address => uint256)) public usersNominatedProject; // iteration -> user -> chosen project\r\n\r\n  //////// DAO / VOTE specific //////////\r\n  mapping(uint256 => mapping(uint256 => uint256)) public proposalVotes; /// iteration -> proposalId -> num votes\r\n  mapping(uint256 => uint256) public topProject;\r\n  mapping(address => address) public voteDelegations; // For vote proxy\r\n\r\n  //////// Necessary to fund dev and miners //////////\r\n  address[] interestReceivers; // in v0, the interestReceivers is the address of the miner.\r\n  uint256[] percentages;\r\n\r\n  ///////// DEFI Contrcats ///////////\r\n  IPoolDeposits public depositContract;\r\n\r\n  // Crrate blank 256 arrays of fixed length for upgradability.\r\n\r\n  ///////// Events ///////////\r\n  event VoteDelegated(address indexed user, address delegatedTo);\r\n  event VotedDirect(\r\n    address indexed user,\r\n    uint256 indexed iteration,\r\n    uint256 indexed proposalId\r\n  );\r\n  event VotedViaProxy(\r\n    address indexed proxy,\r\n    address user,\r\n    uint256 indexed iteration,\r\n    uint256 indexed proposalId\r\n  );\r\n  event IterationChanged(\r\n    uint256 indexed newIterationId,\r\n    address miner,\r\n    uint256 timeStamp\r\n  );\r\n  event IterationWinner(\r\n    uint256 indexed propsalIteration,\r\n    address indexed winner,\r\n    uint256 indexed projectId\r\n  );\r\n  event InterestConfigChanged(\r\n    address[] addresses,\r\n    uint256[] percentages,\r\n    uint256 iteration\r\n  );\r\n  // Test these events\r\n  event ProposalActive(\r\n    uint256 indexed proposalId,\r\n    address benefactor,\r\n    uint256 iteration\r\n  );\r\n  event ProposalCooldown(uint256 indexed proposalId, uint256 iteration);\r\n  event ProposalWithdrawn(uint256 indexed proposalId, uint256 iteration);\r\n\r\n  ////////////////////////////////////\r\n  //////// Modifiers /////////////////\r\n  ////////////////////////////////////\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, 'Not admin');\r\n    _;\r\n  }\r\n\r\n  modifier hasDeposit(address givenAddress) {\r\n    require(\r\n      depositContract.depositedDai(givenAddress) > 0,\r\n      'User has no stake'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier noVoteYet(address givenAddress) {\r\n    require(\r\n      usersNominatedProject[proposalIteration][givenAddress] == 0,\r\n      'User already voted this iteration'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier userHasActiveProposal(address givenAddress) {\r\n    require(\r\n      state[benefactorsProposal[givenAddress]] == ProposalState.Active,\r\n      'User proposal does not exist'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier userHasNoActiveProposal(address givenAddress) {\r\n    require(\r\n      state[benefactorsProposal[givenAddress]] != ProposalState.Active,\r\n      'User has an active proposal'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier userHasNoProposal(address givenAddress) {\r\n    require(benefactorsProposal[givenAddress] == 0, 'User has a proposal');\r\n    _;\r\n  }\r\n\r\n  modifier proposalActive(uint256 propId) {\r\n    require(state[propId] == ProposalState.Active, 'Proposal is not active');\r\n    _;\r\n  }\r\n\r\n  modifier proxyRight(address delegatedFrom) {\r\n    require(\r\n      voteDelegations[delegatedFrom] == msg.sender,\r\n      'User does not have proxy right'\r\n    );\r\n    _;\r\n  }\r\n\r\n  // We reset the iteration back to zero when a user leaves. Means this modifier will no longer protect.\r\n  // But, its okay because it cannot be exploited. When 0, the user will have zero deposit.\r\n  // Therefore that modifier will always catch them in that case :)\r\n  modifier joinedInTime(address givenAddress) {\r\n    require(\r\n      iterationJoined[givenAddress] < proposalIteration,\r\n      'User only eligible to vote next iteration'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier lockInFulfilled(address givenAddress) {\r\n    require(\r\n      iterationJoined[givenAddress] + 2 < proposalIteration,\r\n      'Benefactor has not fulfilled the minimum lockin period of 2 iterations'\r\n    );\r\n    _;\r\n  }\r\n  modifier iterationElapsed() {\r\n    require(proposalDeadline < now, 'iteration interval not ended');\r\n    _;\r\n  }\r\n\r\n  modifier depositContractOnly() {\r\n    require(\r\n      address(depositContract) == msg.sender, // Is this a valid way of getting the address?\r\n      'function can only be called by deposit contract'\r\n    );\r\n    _;\r\n  }\r\n\r\n  ////////////////////////////////////\r\n  //////// SETUP CONTRACT////////////\r\n  //// NOTE: Upgradable at the moment\r\n  function initialize(\r\n    address depositContractAddress,\r\n    uint256 _votingInterval,\r\n    uint256 _lengthOfIterationZero\r\n  ) public initializer {\r\n    depositContract = IPoolDeposits(depositContractAddress);\r\n    admin = msg.sender;\r\n    votingInterval = _votingInterval;\r\n    // Length of the 1st iteration can be set here. For mainnet we use 2 months to 'warmup' the dao (5184000 = 60days)\r\n    proposalDeadline = now.add(_lengthOfIterationZero);\r\n    interestReceivers.push(admin); // This will change to miner when iterationchanges\r\n    percentages.push(15); // 1.5% for miner\r\n    interestReceivers.push(admin);\r\n    percentages.push(135); // 13.5% for devlopers\r\n\r\n    emit IterationChanged(0, msg.sender, now);\r\n  }\r\n\r\n  ///////////////////////////////////\r\n  /////// Config functions //////////\r\n  ///////////////////////////////////\r\n\r\n  /// @dev Changes the time iteration  between intervals\r\n  /// @param newInterval new time interval between interations\r\n  function changeVotingInterval(uint256 newInterval) public onlyAdmin {\r\n    votingInterval = newInterval;\r\n  }\r\n\r\n  /// @dev Changes the amount required to stake for new proposal\r\n  /// @param amount how much new amount is.\r\n  function changeProposalStakingAmount(uint256 amount) public onlyAdmin {\r\n    depositContract.changeProposalAmount(amount);\r\n  }\r\n\r\n  /// @dev Admin function for setting the who recieves interest and what percentage.\r\n  /// @param _interestReceivers The list of addresses to recieve interest\r\n  /// @param _percentages The percentage they each will recieve\r\n  function setInterestReceivers(\r\n    address[] memory _interestReceivers,\r\n    uint256[] memory _percentages\r\n  ) public onlyAdmin {\r\n    require(\r\n      _interestReceivers.length == _percentages.length,\r\n      'Arrays should be equal length'\r\n    );\r\n    uint256 percentagesSum = 0;\r\n    for (uint256 i = 0; i < _percentages.length; i++) {\r\n      percentagesSum = percentagesSum.add(_percentages[i]);\r\n    }\r\n    require(percentagesSum < 1000, 'Percentages total too high');\r\n\r\n    interestReceivers = _interestReceivers;\r\n    percentages = _percentages;\r\n    emit InterestConfigChanged(\r\n      _interestReceivers,\r\n      _percentages,\r\n      proposalIteration\r\n    );\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  /////// Deposit & withdraw function for users //////////\r\n  ////////and proposal holders (benefactors) /////////////\r\n  ////////////////////////////////////////////////////////\r\n\r\n  /// @dev Returns true if the user has not voted this iteration and they are not a proposal\r\n  /// @param userAddress address of the user we are checking\r\n  /// @return boolean true if user hasn't voted and isn't a proposal\r\n  /// Indentical to modifier, hasNoVote && userHasNoProposal, but funciton need for poolDeposits to allow partial withdrawl\r\n  function userHasNotVotedThisIterationAndIsNotProposal(address userAddress)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return\r\n      usersNominatedProject[proposalIteration][userAddress] == 0 &&\r\n      benefactorsProposal[userAddress] == 0;\r\n  }\r\n\r\n  /// @dev Checks whether user is eligible deposit and sets the proposal iteration joined, to the current iteration\r\n  /// @param userAddress address of the user wanting to deposit\r\n  /// @return boolean whether the above executes successfully\r\n  function noLossDeposit(address userAddress)\r\n    external\r\n    depositContractOnly\r\n    userHasNoProposal(userAddress) // Checks they are not a benefactor\r\n    returns (bool)\r\n  {\r\n    iterationJoined[userAddress] = proposalIteration;\r\n    return true;\r\n  }\r\n\r\n  /// @dev Checks whether user is eligible to withdraw their deposit and sets the proposal iteration joined to zero\r\n  /// @param userAddress address of the user wanting to withdraw\r\n  /// @return boolean whether the above executes successfully\r\n  function noLossWithdraw(address userAddress)\r\n    external\r\n    depositContractOnly\r\n    noVoteYet(userAddress)\r\n    userHasNoProposal(userAddress)\r\n    returns (bool)\r\n  {\r\n    iterationJoined[userAddress] = 0;\r\n    return true;\r\n  }\r\n\r\n  /// @dev Checks whether user is eligible to create a proposal then creates it. Executes a range of logic to add the new propsal (increments proposal ID, sets proposal owner, sets iteration joined, etc...)\r\n  /// @param _proposalIdentifier Hash of the proposal text\r\n  /// @param benefactorAddress address of benefactor creating proposal\r\n  /// @return newProposalId boolean whether the above executes successfully\r\n  function noLossCreateProposal(\r\n    string calldata _proposalIdentifier,\r\n    address benefactorAddress\r\n  ) external depositContractOnly returns (uint256 newProposalId) {\r\n    proposalId = proposalId.add(1);\r\n\r\n    proposalIdentifier[proposalId] = _proposalIdentifier;\r\n    proposalOwner[proposalId] = benefactorAddress;\r\n    benefactorsProposal[benefactorAddress] = proposalId;\r\n    state[proposalId] = ProposalState.Active;\r\n    iterationJoined[benefactorAddress] = proposalIteration;\r\n    emit ProposalActive(proposalId, benefactorAddress, proposalIteration);\r\n    return proposalId;\r\n  }\r\n\r\n  /// @dev Checks whether user is eligible to withdraw their proposal\r\n  /// Sets the state of the users proposal to withdrawn\r\n  /// resets the iteration of user joined back to 0\r\n  /// @param benefactorAddress address of benefactor withdrawing proposal\r\n  /// @return boolean whether the above is possible\r\n  function noLossWithdrawProposal(address benefactorAddress)\r\n    external\r\n    depositContractOnly\r\n    userHasActiveProposal(benefactorAddress)\r\n    lockInFulfilled(benefactorAddress)\r\n    returns (bool)\r\n  {\r\n    uint256 benefactorsProposalId = benefactorsProposal[benefactorAddress];\r\n    iterationJoined[benefactorAddress] = 0;\r\n    state[benefactorsProposalId] = ProposalState.Withdrawn;\r\n    emit ProposalWithdrawn(benefactorsProposalId, proposalIteration);\r\n    return true;\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  /////// DAO voting functionality  //////////////////////\r\n  ////////////////////////////////////////////////////////\r\n\r\n  /// @dev Allows user to delegate their full voting power to another user\r\n  /// @param delegatedAddress the address to which you are delegating your voting rights\r\n  function delegateVoting(address delegatedAddress)\r\n    external\r\n    hasDeposit(msg.sender)\r\n    userHasNoActiveProposal(msg.sender)\r\n    userHasNoActiveProposal(delegatedAddress)\r\n  {\r\n    voteDelegations[msg.sender] = delegatedAddress;\r\n    emit VoteDelegated(msg.sender, delegatedAddress);\r\n  }\r\n\r\n  /// @dev Allows user to vote for an active proposal. Once voted they cannot withdraw till next iteration.\r\n  /// @param proposalIdToVoteFor Id of the proposal they are voting for\r\n  function voteDirect(\r\n    uint256 proposalIdToVoteFor // breaking change -> function name change from vote to voteDirect\r\n  )\r\n    external\r\n    proposalActive(proposalIdToVoteFor)\r\n    noVoteYet(msg.sender)\r\n    hasDeposit(msg.sender)\r\n    userHasNoActiveProposal(msg.sender)\r\n    joinedInTime(msg.sender)\r\n  {\r\n    _vote(proposalIdToVoteFor, msg.sender);\r\n    emit VotedDirect(msg.sender, proposalIteration, proposalIdToVoteFor);\r\n  }\r\n\r\n  /// @dev Allows user proxy to vote on behalf of a user.\r\n  /// @param proposalIdToVoteFor Id of the proposal they are voting for\r\n  /// @param delegatedFrom user they are voting on behalf of\r\n  function voteProxy(uint256 proposalIdToVoteFor, address delegatedFrom)\r\n    external\r\n    proposalActive(proposalIdToVoteFor)\r\n    proxyRight(delegatedFrom)\r\n    noVoteYet(delegatedFrom)\r\n    hasDeposit(delegatedFrom)\r\n    userHasNoActiveProposal(delegatedFrom)\r\n    userHasNoActiveProposal(msg.sender)\r\n    joinedInTime(delegatedFrom)\r\n  {\r\n    _vote(proposalIdToVoteFor, delegatedFrom);\r\n    emit VotedViaProxy(\r\n      msg.sender,\r\n      delegatedFrom,\r\n      proposalIteration,\r\n      proposalIdToVoteFor\r\n    );\r\n  }\r\n\r\n  /// @dev Internal function casting the actual vote from the requested address\r\n  /// @param proposalIdToVoteFor Id of the proposal they are voting for\r\n  /// @param voteAddress address the vote is stemming from\r\n  function _vote(uint256 proposalIdToVoteFor, address voteAddress) internal {\r\n    usersNominatedProject[proposalIteration][voteAddress] = proposalIdToVoteFor;\r\n    proposalVotes[proposalIteration][proposalIdToVoteFor] = proposalVotes[proposalIteration][proposalIdToVoteFor]\r\n      .add(depositContract.depositedDai(voteAddress));\r\n\r\n\r\n      uint256 topProjectVotes\r\n     = proposalVotes[proposalIteration][topProject[proposalIteration]];\r\n\r\n    // Currently, proposal getting to top vote first will win [this is fine]\r\n    if (\r\n      proposalVotes[proposalIteration][proposalIdToVoteFor] > topProjectVotes\r\n    ) {\r\n      topProject[proposalIteration] = proposalIdToVoteFor;\r\n    }\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  /////// Iteration changer / mining function  //////////////////////\r\n  ///////////////////////////////////////////////////////////////////\r\n\r\n  /// @dev Anyone can call this every 2 weeks (more specifically every *iteration interval*) to receive a reward, and increment onto the next iteration of voting\r\n  function distributeFunds() external iterationElapsed {\r\n    interestReceivers[0] = msg.sender; // Set the miners address to receive a small reward\r\n\r\n    if (proposalIteration > 0) {\r\n      // distribute interest from previous week.\r\n      uint256 previousIterationTopProject = topProject[proposalIteration.sub(\r\n        1\r\n      )];\r\n      if (previousIterationTopProject != 0) {\r\n        // Only if last winner is not withdrawn (i.e. st ill in cooldown) make it active again\r\n        if (state[previousIterationTopProject] == ProposalState.Cooldown) {\r\n          state[previousIterationTopProject] = ProposalState.Active;\r\n          emit ProposalActive(\r\n            previousIterationTopProject,\r\n            proposalOwner[previousIterationTopProject],\r\n            proposalIteration\r\n          );\r\n        }\r\n\r\n        address previousWinner = proposalOwner[previousIterationTopProject]; // This cannot be null, since we check that there was a winner above.\r\n        depositContract.distributeInterest(\r\n          interestReceivers,\r\n          percentages,\r\n          previousWinner,\r\n          proposalIteration\r\n        );\r\n      }\r\n\r\n      uint256 iterationTopProject = topProject[proposalIteration];\r\n      if (iterationTopProject != 0) {\r\n        // TODO: Do some asserts here for safety...\r\n        if (state[iterationTopProject] != ProposalState.Withdrawn) {\r\n          state[iterationTopProject] = ProposalState.Cooldown;\r\n          emit ProposalCooldown(iterationTopProject, proposalIteration);\r\n        }\r\n        address winner = proposalOwner[iterationTopProject]; // This cannot be null, since we check that there was a winner above.\r\n        emit IterationWinner(proposalIteration, winner, iterationTopProject);\r\n      }\r\n    }\r\n\r\n    proposalDeadline = now.add(votingInterval);\r\n    proposalIteration = proposalIteration.add(1);\r\n\r\n    // send winning miner a little surprise [NFT]\r\n    emit IterationChanged(proposalIteration, msg.sender, now);\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"percentages\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"}],\"name\":\"InterestConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newIterationId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"IterationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"propsalIteration\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"IterationWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"benefactor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"}],\"name\":\"ProposalActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"}],\"name\":\"ProposalCooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"}],\"name\":\"ProposalWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatedTo\",\"type\":\"address\"}],\"name\":\"VoteDelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"VotedDirect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"VotedViaProxy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"benefactorsProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"changeProposalStakingAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newInterval\",\"type\":\"uint256\"}],\"name\":\"changeVotingInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatedAddress\",\"type\":\"address\"}],\"name\":\"delegateVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositContract\",\"outputs\":[{\"internalType\":\"contract IPoolDeposits\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_votingInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lengthOfIterationZero\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"iterationJoined\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_proposalIdentifier\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"benefactorAddress\",\"type\":\"address\"}],\"name\":\"noLossCreateProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newProposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"noLossDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"noLossWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"benefactorAddress\",\"type\":\"address\"}],\"name\":\"noLossWithdrawProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalIdentifier\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalIteration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_interestReceivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_percentages\",\"type\":\"uint256[]\"}],\"name\":\"setInterestReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum NoLossDao_v0.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"topProject\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"userHasNotVotedThisIterationAndIsNotProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersNominatedProject\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteDelegations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIdToVoteFor\",\"type\":\"uint256\"}],\"name\":\"voteDirect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIdToVoteFor\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegatedFrom\",\"type\":\"address\"}],\"name\":\"voteProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NoLossDao_v0","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://079ff991d3931f9120bb9d6f4f42488e1dcf6aa3317a93ea0de6d75b2b54b082"}]}