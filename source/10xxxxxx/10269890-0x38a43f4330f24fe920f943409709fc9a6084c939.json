{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/UpgradeGatekeeper.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Events.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./UpgradeableMaster.sol\\\";\\n\\n/// @title Upgrade Gatekeeper Contract\\n/// @author Matter Labs\\ncontract UpgradeGatekeeper is UpgradeEvents, Ownable {\\n    using SafeMath for uint256;\\n\\n    /// @notice Array of addresses of upgradeable contracts managed by the gatekeeper\\n    Upgradeable[] public managedContracts;\\n\\n    /// @notice Upgrade mode statuses\\n    enum UpgradeStatus {\\n        Idle,\\n        NoticePeriod,\\n        Preparation\\n    }\\n\\n    UpgradeStatus public upgradeStatus;\\n\\n    /// @notice Notice period finish timestamp (as seconds since unix epoch)\\n    /// @dev Will be equal to zero in case of not active upgrade mode\\n    uint public noticePeriodFinishTimestamp;\\n\\n    /// @notice Addresses of the next versions of the contracts to be upgraded (if element of this array is equal to zero address it means that appropriate upgradeable contract wouldn't be upgraded this time)\\n    /// @dev Will be empty in case of not active upgrade mode\\n    address[] public nextTargets;\\n\\n    /// @notice Version id of contracts\\n    uint public versionId;\\n\\n    /// @notice Contract which defines notice period duration and allows finish upgrade during preparation of it\\n    UpgradeableMaster public mainContract;\\n\\n    /// @notice Contract constructor\\n    /// @param _mainContract Contract which defines notice period duration and allows finish upgrade during preparation of it\\n    /// @dev Calls Ownable contract constructor\\n    constructor(UpgradeableMaster _mainContract) Ownable(msg.sender) public {\\n        mainContract = _mainContract;\\n        versionId = 0;\\n    }\\n\\n    /// @notice Adds a new upgradeable contract to the list of contracts managed by the gatekeeper\\n    /// @param addr Address of upgradeable contract to add\\n    function addUpgradeable(address addr) external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.Idle, \\\"apc11\\\"); /// apc11 - upgradeable contract can't be added during upgrade\\n\\n        managedContracts.push(Upgradeable(addr));\\n        emit NewUpgradable(versionId, addr);\\n    }\\n\\n    /// @notice Starts upgrade (activates notice period)\\n    /// @param newTargets New managed contracts targets (if element of this array is equal to zero address it means that appropriate upgradeable contract wouldn't be upgraded this time)\\n    function startUpgrade(address[] calldata newTargets) external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.Idle, \\\"spu11\\\"); // spu11 - unable to activate active upgrade mode\\n        require(newTargets.length == managedContracts.length, \\\"spu12\\\"); // spu12 - number of new targets must be equal to the number of managed contracts\\n\\n        uint noticePeriod = mainContract.getNoticePeriod();\\n        mainContract.upgradeNoticePeriodStarted();\\n        upgradeStatus = UpgradeStatus.NoticePeriod;\\n        noticePeriodFinishTimestamp = now.add(noticePeriod);\\n        nextTargets = newTargets;\\n        emit NoticePeriodStart(versionId, newTargets, noticePeriod);\\n    }\\n\\n    /// @notice Cancels upgrade\\n    function cancelUpgrade() external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus != UpgradeStatus.Idle, \\\"cpu11\\\"); // cpu11 - unable to cancel not active upgrade mode\\n\\n        mainContract.upgradeCanceled();\\n        upgradeStatus = UpgradeStatus.Idle;\\n        noticePeriodFinishTimestamp = 0;\\n        delete nextTargets;\\n        emit UpgradeCancel(versionId);\\n    }\\n\\n    /// @notice Activates preparation status\\n    /// @return Bool flag indicating that preparation status has been successfully activated\\n    function startPreparation() external returns (bool) {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.NoticePeriod, \\\"ugp11\\\"); // ugp11 - unable to activate preparation status in case of not active notice period status\\n\\n        if (now >= noticePeriodFinishTimestamp) {\\n            upgradeStatus = UpgradeStatus.Preparation;\\n            mainContract.upgradePreparationStarted();\\n            emit PreparationStart(versionId);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /// @notice Finishes upgrade\\n    /// @param targetsUpgradeParameters New targets upgrade parameters per each upgradeable contract\\n    function finishUpgrade(bytes[] calldata targetsUpgradeParameters) external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.Preparation, \\\"fpu11\\\"); // fpu11 - unable to finish upgrade without preparation status active\\n        require(targetsUpgradeParameters.length == managedContracts.length, \\\"fpu12\\\"); // fpu12 - number of new targets upgrade parameters must be equal to the number of managed contracts\\n        require(mainContract.isReadyForUpgrade(), \\\"fpu13\\\"); // fpu13 - main contract is not ready for upgrade\\n        mainContract.upgradeFinishes();\\n\\n        for (uint64 i = 0; i < managedContracts.length; i++) {\\n            address newTarget = nextTargets[i];\\n            if (newTarget != address(0)) {\\n                managedContracts[i].upgradeTarget(newTarget, targetsUpgradeParameters[i]);\\n            }\\n        }\\n        versionId++;\\n        emit UpgradeComplete(versionId, nextTargets);\\n\\n        upgradeStatus = UpgradeStatus.Idle;\\n        noticePeriodFinishTimestamp = 0;\\n        delete nextTargets;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Events.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\n\\n/// @title zkSync events\\n/// @author Matter Labs\\ninterface Events {\\n\\n    /// @notice Event emitted when a block is committed\\n    event BlockCommit(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when a block is verified\\n    event BlockVerification(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when user send a transaction to withdraw her funds from onchain balance\\n    event OnchainWithdrawal(\\n        address indexed owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Event emitted when user send a transaction to deposit her funds\\n    event OnchainDeposit(\\n        address indexed sender,\\n        uint16 indexed tokenId,\\n        uint128 amount,\\n        address indexed owner\\n    );\\n\\n    /// @notice Event emitted when user sends a authentication fact (e.g. pub-key hash)\\n    event FactAuth(\\n        address indexed sender,\\n        uint32 nonce,\\n        bytes fact\\n    );\\n\\n    /// @notice Event emitted when blocks are reverted\\n    event BlocksRevert(\\n        uint32 totalBlocksVerified,\\n        uint32 totalBlocksCommitted\\n    );\\n\\n    /// @notice Exodus mode entered event\\n    event ExodusMode();\\n\\n    /// @notice New priority request event. Emitted when a request is placed into mapping\\n    event NewPriorityRequest(\\n        address sender,\\n        uint64 serialId,\\n        Operations.OpType opType,\\n        bytes pubData,\\n        uint256 expirationBlock\\n    );\\n\\n    event DepositCommit(\\n        uint32 indexed franklinBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    event FullExitCommit(\\n        uint32 indexed franklinBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n}\\n\\n/// @title Upgrade events\\n/// @author Matter Labs\\ninterface UpgradeEvents {\\n\\n    /// @notice Event emitted when new upgradeable contract is added to upgrade gatekeeper's list of managed contracts\\n    event NewUpgradable(\\n        uint indexed versionId,\\n        address indexed upgradeable\\n    );\\n\\n    /// @notice Upgrade mode enter event\\n    event NoticePeriodStart(\\n        uint indexed versionId,\\n        address[] newTargets,\\n        uint noticePeriod // notice period (in seconds)\\n    );\\n\\n    /// @notice Upgrade mode cancel event\\n    event UpgradeCancel(\\n        uint indexed versionId\\n    );\\n\\n    /// @notice Upgrade mode preparation status event\\n    event PreparationStart(\\n        uint indexed versionId\\n    );\\n\\n    /// @notice Upgrade mode complete event\\n    event UpgradeComplete(\\n        uint indexed versionId,\\n        address[] newTargets\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/// @title Ownable Contract\\n/// @author Matter Labs\\ncontract Ownable {\\n\\n    /// @notice Storage position of the masters address (keccak256('eip1967.proxy.admin') - 1)\\n    bytes32 private constant masterPosition = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice Contract constructor\\n    /// @dev Sets msg sender address as masters address\\n    /// @param masterAddress Master address\\n    constructor(address masterAddress) public {\\n        setMaster(masterAddress);\\n    }\\n\\n    /// @notice Check if specified address is master\\n    /// @param _address Address to check\\n    function requireMaster(address _address) internal view {\\n        require(_address == getMaster(), \\\"oro11\\\"); // oro11 - only by master\\n    }\\n\\n    /// @notice Returns contract masters address\\n    /// @return Masters address\\n    function getMaster() public view returns (address master) {\\n        bytes32 position = masterPosition;\\n        assembly {\\n            master := sload(position)\\n        }\\n    }\\n\\n    /// @notice Sets new masters address\\n    /// @param _newMaster New masters address\\n    function setMaster(address _newMaster) internal {\\n        bytes32 position = masterPosition;\\n        assembly {\\n            sstore(position, _newMaster)\\n        }\\n    }\\n\\n    /// @notice Transfer mastership of the contract to new master\\n    /// @param _newMaster New masters address\\n    function transferMastership(address _newMaster) external {\\n        requireMaster(msg.sender);\\n        require(_newMaster != address(0), \\\"otp11\\\"); // otp11 - new masters address can't be zero address\\n        setMaster(_newMaster);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Upgradeable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title Interface of the upgradeable contract\\n/// @author Matter Labs\\ninterface Upgradeable {\\n\\n    /// @notice Upgrades target of upgradeable contract\\n    /// @param newTarget New target\\n    /// @param newTargetInitializationParameters New target initialization parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/UpgradeableMaster.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title Interface of the upgradeable master contract (defines notice period duration and allows finish upgrade during preparation of it)\\n/// @author Matter Labs\\ninterface UpgradeableMaster {\\n\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external returns (uint);\\n\\n    /// @notice Notifies contract that notice period started\\n    function upgradeNoticePeriodStarted() external;\\n\\n    /// @notice Notifies contract that upgrade preparation status is activated\\n    function upgradePreparationStarted() external;\\n\\n    /// @notice Notifies contract that upgrade canceled\\n    function upgradeCanceled() external;\\n\\n    /// @notice Notifies contract that upgrade finishes\\n    function upgradeFinishes() external;\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external returns (bool);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Operations.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./Bytes.sol\\\";\\n\\n\\n/// @title zkSync operations tools\\nlibrary Operations {\\n\\n    // Circuit ops and their pubdata (chunks * bytes)\\n\\n    /// @notice zkSync circuit operation type\\n    enum OpType {\\n        Noop,\\n        Deposit,\\n        TransferToNew,\\n        PartialExit,\\n        _CloseAccount, // used for correct op id offset\\n        Transfer,\\n        FullExit,\\n        ChangePubKey\\n    }\\n\\n    // Byte lengths\\n\\n    uint8 constant TOKEN_BYTES = 2;\\n\\n    uint8 constant PUBKEY_BYTES = 32;\\n\\n    uint8 constant NONCE_BYTES = 4;\\n\\n    uint8 constant PUBKEY_HASH_BYTES = 20;\\n\\n    uint8 constant ADDRESS_BYTES = 20;\\n\\n    /// @notice Packed fee bytes lengths\\n    uint8 constant FEE_BYTES = 2;\\n\\n    /// @notice zkSync account id bytes lengths\\n    uint8 constant ACCOUNT_ID_BYTES = 4;\\n\\n    uint8 constant AMOUNT_BYTES = 16;\\n\\n    /// @notice Signature (for example full exit signature) bytes length\\n    uint8 constant SIGNATURE_BYTES = 64;\\n\\n    // Deposit pubdata\\n    struct Deposit {\\n        uint32 accountId;\\n        uint16 tokenId;\\n        uint128 amount;\\n        address owner;\\n    }\\n\\n    uint public constant PACKED_DEPOSIT_PUBDATA_BYTES = \\n        ACCOUNT_ID_BYTES + TOKEN_BYTES + AMOUNT_BYTES + ADDRESS_BYTES;\\n\\n    /// Deserialize deposit pubdata\\n    function readDepositPubdata(bytes memory _data) internal pure\\n        returns (Deposit memory parsed)\\n    {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint offset = 0;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset);   // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset);   // amount\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);    // owner\\n\\n        require(offset == PACKED_DEPOSIT_PUBDATA_BYTES, \\\"rdp10\\\"); // reading invalid deposit pubdata size\\n    }\\n\\n    /// Serialize deposit pubdata\\n    function writeDepositPubdata(Deposit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            bytes4(0),   // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenId,  // tokenId\\n            op.amount,   // amount\\n            op.owner     // owner\\n        );\\n    }\\n\\n    /// @notice Check that deposit pubdata from request and block matches\\n    function depositPubdataMatch(bytes memory _lhs, bytes memory _rhs) internal pure returns (bool) {\\n        // We must ignore `accountId` because it is present in block pubdata but not in priority queue\\n        bytes memory lhs_trimmed = Bytes.slice(_lhs, ACCOUNT_ID_BYTES, PACKED_DEPOSIT_PUBDATA_BYTES - ACCOUNT_ID_BYTES);\\n        bytes memory rhs_trimmed = Bytes.slice(_rhs, ACCOUNT_ID_BYTES, PACKED_DEPOSIT_PUBDATA_BYTES - ACCOUNT_ID_BYTES);\\n        return keccak256(lhs_trimmed) == keccak256(rhs_trimmed);\\n    }\\n\\n    // FullExit pubdata\\n\\n    struct FullExit {\\n        uint32 accountId;\\n        address owner;\\n        uint16 tokenId;\\n        uint128 amount;\\n    }\\n\\n    uint public constant PACKED_FULL_EXIT_PUBDATA_BYTES = \\n        ACCOUNT_ID_BYTES + ADDRESS_BYTES + TOKEN_BYTES + AMOUNT_BYTES;\\n\\n    function readFullExitPubdata(bytes memory _data) internal pure\\n        returns (FullExit memory parsed)\\n    {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint offset = 0;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset);      // accountId\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);         // owner\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset);        // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset);        // amount\\n\\n        require(offset == PACKED_FULL_EXIT_PUBDATA_BYTES, \\\"rfp10\\\"); // reading invalid full exit pubdata size\\n    }\\n\\n    function writeFullExitPubdata(FullExit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            op.accountId,  // accountId\\n            op.owner,      // owner\\n            op.tokenId,    // tokenId\\n            op.amount      // amount\\n        );\\n    }\\n\\n    /// @notice Check that full exit pubdata from request and block matches\\n    function fullExitPubdataMatch(bytes memory _lhs, bytes memory _rhs) internal pure returns (bool) {\\n        // `amount` is ignored because it is present in block pubdata but not in priority queue\\n        uint lhs = Bytes.trim(_lhs, PACKED_FULL_EXIT_PUBDATA_BYTES - AMOUNT_BYTES);\\n        uint rhs = Bytes.trim(_rhs, PACKED_FULL_EXIT_PUBDATA_BYTES - AMOUNT_BYTES);\\n        return lhs == rhs;\\n    }\\n\\n    // PartialExit pubdata\\n    \\n    struct PartialExit {\\n        //uint32 accountId; -- present in pubdata, ignored at serialization\\n        uint16 tokenId;\\n        uint128 amount;\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n        address owner;\\n    }\\n\\n    function readPartialExitPubdata(bytes memory _data, uint _offset) internal pure\\n        returns (PartialExit memory parsed)\\n    {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint offset = _offset + ACCOUNT_ID_BYTES;                   // accountId (ignored)\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        offset += FEE_BYTES;                                        // fee (ignored)\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);  // owner\\n    }\\n\\n    function writePartialExitPubdata(PartialExit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            bytes4(0),  // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenId, // tokenId\\n            op.amount,  // amount\\n            bytes2(0),  // fee (ignored)  (update when FEE_BYTES is changed)\\n            op.owner    // owner\\n        );\\n    }\\n\\n    // ChangePubKey\\n\\n    struct ChangePubKey {\\n        uint32 accountId;\\n        bytes20 pubKeyHash;\\n        address owner;\\n        uint32 nonce;\\n    }\\n\\n    function readChangePubKeyPubdata(bytes memory _data, uint _offset) internal pure\\n        returns (ChangePubKey memory parsed)\\n    {\\n        uint offset = _offset;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset);                // accountId\\n        (offset, parsed.pubKeyHash) = Bytes.readBytes20(_data, offset);              // pubKeyHash\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset);                   // owner\\n        (offset, parsed.nonce) = Bytes.readUInt32(_data, offset);                    // nonce\\n    }\\n\\n    // Withdrawal data process\\n\\n    function readWithdrawalData(bytes memory _data, uint _offset) internal pure\\n        returns (bool _addToPendingWithdrawalsQueue, address _to, uint16 _tokenId, uint128 _amount)\\n    {\\n        uint offset = _offset;\\n        (offset, _addToPendingWithdrawalsQueue) = Bytes.readBool(_data, offset);\\n        (offset, _to) = Bytes.readAddress(_data, offset);\\n        (offset, _tokenId) = Bytes.readUInt16(_data, offset);\\n        (offset, _amount) = Bytes.readUInt128(_data, offset);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Bytes.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n// Functions named bytesToX, except bytesToBytes20, where X is some type of size N < 32 (size of one word)\\n// implements the following algorithm:\\n// f(bytes memory input, uint offset) -> X out\\n// where byte representation of out is N bytes from input at the given offset\\n// 1) We compute memory location of the word W such that last N bytes of W is input[offset..offset+N]\\n// W_address = input + 32 (skip stored length of bytes) + offset - (32 - N) == input + offset + N\\n// 2) We load W from memory into out, last N bytes of W are placed into out\\n\\nlibrary Bytes {\\n\\n    function toBytesFromUInt16(uint16 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 2);\\n    }\\n\\n    function toBytesFromUInt24(uint24 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 3);\\n    }\\n\\n    function toBytesFromUInt32(uint32 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 4);\\n    }\\n\\n    function toBytesFromUInt128(uint128 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint(self), 16);\\n    }\\n\\n    // Copies 'len' lower bytes from 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length 'len'.\\n    function toBytesFromUIntTruncated(uint self, uint8 byteLength) private pure returns (bytes memory bts) {\\n        require(byteLength <= 32, \\\"bt211\\\");\\n        bts = new bytes(byteLength);\\n        // Even though the bytes will allocate a full word, we don't want\\n        // any potential garbage bytes in there.\\n        uint data = self << ((32 - byteLength) * 8);\\n        assembly {\\n            mstore(add(bts, /*BYTES_HEADER_SIZE*/32), data)\\n        }\\n    }\\n\\n    // Copies 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length '20'.\\n    function toBytesFromAddress(address self) internal pure returns (bytes memory bts) {\\n        bts = toBytesFromUIntTruncated(uint(self), 20);\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToAddress(bytes memory self, uint256 _start) internal pure returns (address addr) {\\n        uint256 offset = _start + 20;\\n        require(self.length >= offset, \\\"bta11\\\");\\n        assembly {\\n            addr := mload(add(self, offset))\\n        }\\n    }\\n\\n    // Reasoning about why this function works is similar to that of other similar functions, except NOTE below.\\n    // NOTE: that bytes1..32 is stored in the beginning of the word unlike other primitive types\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToBytes20(bytes memory self, uint256 _start) internal pure returns (bytes20 r) {\\n        require(self.length >= (_start + 20), \\\"btb20\\\");\\n        assembly {\\n            r := mload(add(add(self, 0x20), _start))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x2)\\n    function bytesToUInt16(bytes memory _bytes, uint256 _start) internal pure returns (uint16 r) {\\n        uint256 offset = _start + 0x2;\\n        require(_bytes.length >= offset, \\\"btu02\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x3)\\n    function bytesToUInt24(bytes memory _bytes, uint256 _start) internal pure returns (uint24 r) {\\n        uint256 offset = _start + 0x3;\\n        require(_bytes.length >= offset, \\\"btu03\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x4)\\n    function bytesToUInt32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 r) {\\n        uint256 offset = _start + 0x4;\\n        require(_bytes.length >= offset, \\\"btu04\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x10)\\n    function bytesToUInt128(bytes memory _bytes, uint256 _start) internal pure returns (uint128 r) {\\n        uint256 offset = _start + 0x10;\\n        require(_bytes.length >= offset, \\\"btu16\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x14)\\n    function bytesToUInt160(bytes memory _bytes, uint256 _start) internal pure returns (uint160 r) {\\n        uint256 offset = _start + 0x14;\\n        require(_bytes.length >= offset, \\\"btu20\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x20)\\n    function bytesToBytes32(bytes memory  _bytes, uint256 _start) internal pure returns (bytes32 r) {\\n        uint256 offset = _start + 0x20;\\n        require(_bytes.length >= offset, \\\"btb32\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\\n    // Get slice from bytes arrays\\n    // Returns the newly created 'bytes memory'\\n    // NOTE: theoretically possible overflow of (_start + _length)\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length), \\\"bse11\\\"); // bytes length is less then start byte + length bytes\\n\\n        bytes memory tempBytes = new bytes(_length);\\n\\n        if (_length != 0) {\\n            // TODO: Review this thoroughly.\\n            assembly {\\n                let slice_curr := add(tempBytes, 0x20)\\n                let slice_end := add(slice_curr, _length)\\n\\n                for {\\n                    let array_current := add(_bytes, add(_start, 0x20))\\n                } lt(slice_curr, slice_end) {\\n                    slice_curr := add(slice_curr, 0x20)\\n                    array_current := add(array_current, 0x20)\\n                } {\\n                    mstore(slice_curr, mload(array_current))\\n                }\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// Reads byte stream\\n    /// @return new_offset - offset + amount of bytes read\\n    /// @return data - actually read data\\n    // NOTE: theoretically possible overflow of (_offset + _length)\\n    function read(bytes memory _data, uint _offset, uint _length) internal pure returns (uint new_offset, bytes memory data) {\\n        data = slice(_data, _offset, _length);\\n        new_offset = _offset + _length;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readBool(bytes memory _data, uint _offset) internal pure returns (uint new_offset, bool r) {\\n        new_offset = _offset + 1;\\n        r = uint8(_data[_offset]) != 0;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readUint8(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint8 r) {\\n        new_offset = _offset + 1;\\n        r = uint8(_data[_offset]);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 2)\\n    function readUInt16(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint16 r) {\\n        new_offset = _offset + 2;\\n        r = bytesToUInt16(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 3)\\n    function readUInt24(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint24 r) {\\n        new_offset = _offset + 3;\\n        r = bytesToUInt24(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 4)\\n    function readUInt32(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint32 r) {\\n        new_offset = _offset + 4;\\n        r = bytesToUInt32(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 16)\\n    function readUInt128(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint128 r) {\\n        new_offset = _offset + 16;\\n        r = bytesToUInt128(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readUInt160(bytes memory _data, uint _offset) internal pure returns (uint new_offset, uint160 r) {\\n        new_offset = _offset + 20;\\n        r = bytesToUInt160(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readAddress(bytes memory _data, uint _offset) internal pure returns (uint new_offset, address r) {\\n        new_offset = _offset + 20;\\n        r = bytesToAddress(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readBytes20(bytes memory _data, uint _offset) internal pure returns (uint new_offset, bytes20 r) {\\n        new_offset = _offset + 20;\\n        r = bytesToBytes20(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 32)\\n    function readBytes32(bytes memory _data, uint _offset) internal pure returns (uint new_offset, bytes32 r) {\\n        new_offset = _offset + 32;\\n        r = bytesToBytes32(_data, _offset);\\n    }\\n\\n    // Helper function for hex conversion.\\n    function halfByteToHex(byte _byte) internal pure returns (byte _hexByte) {\\n        require(uint8(_byte) < 0x10, \\\"hbh11\\\");  // half byte's value is out of 0..15 range.\\n\\n        // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n        return byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byte) * 8)));\\n    }\\n\\n    // Convert bytes to ASCII hex representation\\n    function bytesToHexASCIIBytes(bytes memory  _input) internal pure returns (bytes memory _output) {\\n        bytes memory outStringBytes = new bytes(_input.length * 2);\\n\\n        // code in `assembly` construction is equivalent of the next code:\\n        // for (uint i = 0; i < _input.length; ++i) {\\n        //     outStringBytes[i*2] = halfByteToHex(_input[i] >> 4);\\n        //     outStringBytes[i*2+1] = halfByteToHex(_input[i] & 0x0f);\\n        // }\\n        assembly {\\n            let input_curr := add(_input, 0x20)\\n            let input_end := add(input_curr, mload(_input))\\n\\n            for {\\n                let out_curr := add(outStringBytes, 0x20)\\n            } lt(input_curr, input_end) {\\n                input_curr := add(input_curr, 0x01)\\n                out_curr := add(out_curr, 0x02)\\n            } {\\n                let curr_input_byte := shr(0xf8, mload(input_curr))\\n                // here outStringByte from each half of input byte calculates by the next:\\n                //\\n                // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n                // outStringByte = byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byteHalf) * 8)))\\n                mstore(out_curr,            shl(0xf8, shr(mul(shr(0x04, curr_input_byte), 0x08), 0x66656463626139383736353433323130)))\\n                mstore(add(out_curr, 0x01), shl(0xf8, shr(mul(and(0x0f, curr_input_byte), 0x08), 0x66656463626139383736353433323130)))\\n            }\\n        }\\n        return outStringBytes;\\n    }\\n\\n    /// Trim bytes into single word\\n    function trim(bytes memory _data, uint _new_length) internal pure returns (uint r) {\\n        require(_new_length <= 0x20, \\\"trm10\\\");  // new_length is longer than word\\n        require(_data.length >= _new_length, \\\"trm11\\\");  // data is to short\\n\\n        uint a;\\n        assembly {\\n            a := mload(add(_data, 0x20)) // load bytes into uint256\\n        }\\n\\n        return a >> ((0x20 - _new_length) * 8);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract UpgradeableMaster\",\"name\":\"_mainContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upgradeable\",\"type\":\"address\"}],\"name\":\"NewUpgradable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newTargets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"noticePeriod\",\"type\":\"uint256\"}],\"name\":\"NoticePeriodStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionId\",\"type\":\"uint256\"}],\"name\":\"PreparationStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionId\",\"type\":\"uint256\"}],\"name\":\"UpgradeCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"versionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newTargets\",\"type\":\"address[]\"}],\"name\":\"UpgradeComplete\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addUpgradeable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"targetsUpgradeParameters\",\"type\":\"bytes[]\"}],\"name\":\"finishUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"master\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainContract\",\"outputs\":[{\"internalType\":\"contract UpgradeableMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"managedContracts\",\"outputs\":[{\"internalType\":\"contract Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextTargets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noticePeriodFinishTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPreparation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newTargets\",\"type\":\"address[]\"}],\"name\":\"startUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMaster\",\"type\":\"address\"}],\"name\":\"transferMastership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeStatus\",\"outputs\":[{\"internalType\":\"enum UpgradeGatekeeper.UpgradeStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"versionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UpgradeGatekeeper","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000abea9132b05a70803a4e85094fd0e1800777fbef","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}