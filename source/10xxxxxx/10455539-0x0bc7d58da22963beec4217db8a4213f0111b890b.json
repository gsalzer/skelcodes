{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.10;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a/*, \"SafeMath: addition overflow\"*/);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        assert(b <= a/*, errorMessage*/);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        assert(c / a == b/*, \"SafeMath: multiplication overflow\"*/);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        assert(b > 0/*, errorMessage*/);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        assert(b != 0/*, errorMessage*/);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\nabstract contract Staking {\r\n    struct update {             // Price updateState\r\n        uint timestamp;         // Last update timestamp, unix time\r\n        uint numerator;         // Numerator of percent change (1% increase = 1/100)\r\n        uint denominator;       // Denominator of percent change\r\n        uint price;         // In USD. 0001 is $0.001, 1000 is $1.000, 1001 is $1.001, etc\r\n        uint volume;        // In whole USD (100 = $100)\r\n    }\r\n    update public _lastUpdate; \r\n    function streak() public virtual view returns (uint);\r\n}\r\n\r\ncontract Calculator {\r\n    using SafeMath for uint256;\r\n    \r\n    struct update {             // Price updateState\r\n        uint timestamp;         // Last update timestamp, unix time\r\n        uint numerator;         // Numerator of percent change (1% increase = 1/100)\r\n        uint denominator;       // Denominator of percent change\r\n        uint price;         // In USD. 0001 is $0.001, 1000 is $1.000, 1001 is $1.001, etc\r\n        uint volume;        // In whole USD (100 = $100)\r\n    }\r\n    \r\n    uint public _percent;\r\n    \r\n    uint public _inflationAdjustmentFactor;\r\n    \r\n    Staking public _stakingContract;\r\n    \r\n    uint public _maxStreak;\r\n    \r\n    address payable public _owner;\r\n    \r\n    constructor(address stakingContract) public {\r\n        _stakingContract = Staking(stakingContract);\r\n        _owner = msg.sender;\r\n        _percent = 8;\r\n        _inflationAdjustmentFactor = 350;\r\n        _maxStreak = 7;\r\n    }\r\n    \r\n    \r\n    \r\n    function mulDiv (uint x, uint y, uint z) public pure returns (uint) {\r\n          (uint l, uint h) = fullMul (x, y);\r\n          assert (h < z);\r\n          uint mm = mulmod (x, y, z);\r\n          if (mm > l) h -= 1;\r\n          l -= mm;\r\n          uint pow2 = z & -z;\r\n          z /= pow2;\r\n          l /= pow2;\r\n          l += h * ((-pow2) / pow2 + 1);\r\n          uint r = 1;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          return l * r;\r\n    }\r\n    \r\n    function fullMul (uint x, uint y) private pure returns (uint l, uint h) {\r\n          uint mm = mulmod (x, y, uint (-1));\r\n          l = x * y;\r\n          h = mm - l;\r\n          if (mm < l) h -= 1;\r\n    }\r\n    \r\n    function calculateNumTokens(uint256 balance, uint256 daysStaked, address stakerAddress, uint256 totalSupply) external view returns (uint256) {\r\n        require(msg.sender == address(_stakingContract));\r\n        uint256 inflationAdjustmentFactor = _inflationAdjustmentFactor;\r\n        uint _streak = _stakingContract.streak();\r\n        (uint _, uint numerator, uint denominator, uint price, uint volume) = _stakingContract._lastUpdate();\r\n        \r\n        if(_streak > _maxStreak) {\r\n            _streak = _maxStreak;\r\n        }\r\n        \r\n        if (_streak > 1) {\r\n            inflationAdjustmentFactor /= _streak;       // If there is a streak, we decrease the inflationAdjustmentFactor\r\n        }\r\n        \r\n        if (daysStaked > 60) {      // If you stake for more than 60 days, you have hit the upper limit of the multiplier\r\n            daysStaked = 60;\r\n        } else if (daysStaked == 0) {   // If the minimum days staked is zero, we change the number to 1 so we don't return zero below\r\n            daysStaked = 1;\r\n        }\r\n        \r\n        uint ratio = mulDiv(totalSupply, price, 1000E18).div(volume);     // Ratio of market cap to volume\r\n        \r\n        if (ratio > 50) {  // Too little volume. Decrease rewards. To be honest, this number was arbitrarily chosen.\r\n            inflationAdjustmentFactor = inflationAdjustmentFactor.mul(10);\r\n        } else if (ratio > 25) { // Still not enough. Streak doesn't count.\r\n            inflationAdjustmentFactor = _inflationAdjustmentFactor;\r\n        }\r\n        \r\n        uint numTokens = mulDiv(balance, numerator * daysStaked, denominator * inflationAdjustmentFactor);      // Function that calculates how many tokens are due. See muldiv below.\r\n        uint tenPercent = mulDiv(balance, 1, 10);\r\n        \r\n        if (numTokens > tenPercent) {       // We don't allow a daily rewards of greater than ten percent of a holder's balance.\r\n            numTokens = tenPercent;\r\n        }\r\n        \r\n        return numTokens;\r\n    }\r\n    \r\n    function randomness() public view returns (uint256) {\r\n        return _percent;\r\n    }\r\n    \r\n    function updatePercent(uint percent) external {\r\n        require(msg.sender == _owner);\r\n        _percent = percent;\r\n    }\r\n    \r\n    function updateMaxStreak(uint maxStreak) external {\r\n        require(msg.sender == _owner);\r\n        _maxStreak = maxStreak;\r\n    }\r\n    \r\n    function updateInflationAdjustmentFactor(uint inflationAdjustmentFactor) external {\r\n        require(msg.sender == _owner);\r\n        _inflationAdjustmentFactor = inflationAdjustmentFactor;\r\n    }\r\n    \r\n    function selfDestruct() external {\r\n        require(msg.sender == _owner);\r\n        selfdestruct(_owner);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_inflationAdjustmentFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxStreak\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_stakingContract\",\"outputs\":[{\"internalType\":\"contract Staking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daysStaked\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"calculateNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inflationAdjustmentFactor\",\"type\":\"uint256\"}],\"name\":\"updateInflationAdjustmentFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxStreak\",\"type\":\"uint256\"}],\"name\":\"updateMaxStreak\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"updatePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Calculator","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001d2121efe25535850d1fdb65f930feab093416e0","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6cb454ea7abe1a5ca64ccef8c5caf19f5c3276b521ad98bbcddab3079710a772"}]}