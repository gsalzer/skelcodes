{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function owner() external view returns (address);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ISushiSwapPoolNames {\n    function logos(uint256) external view returns(string memory);\n    function names(uint256) external view returns(string memory);\n    function setPoolInfo(uint256 pid, string memory logo, string memory name) external;\n}\n\ninterface ISushiToken is IERC20{\n    function delegates(address who) external view returns(address);\n    function getCurrentVotes(address who) external view returns(uint256);\n    function nonces(address who) external view returns(uint256);\n}\n\ninterface IMasterChef {\n    function BONUS_MULTIPLIER() external view returns (uint256);\n    function bonusEndBlock() external view returns (uint256);\n    function devaddr() external view returns (address);\n    function migrator() external view returns (address);\n    function owner() external view returns (address);\n    function startBlock() external view returns (uint256);\n    function sushi() external view returns (address);\n    function sushiPerBlock() external view returns (uint256);\n    function totalAllocPoint() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function poolInfo(uint256 nr) external view returns (address, uint256, uint256, uint256);\n    function userInfo(uint256 nr, address who) external view returns (uint256, uint256);\n    function pendingSushi(uint256 nr, address who) external view returns (uint256);\n}\n\ninterface IFactory {\n    function getPair(address token0, address token1) external view returns (address);\n}\n\ninterface IPair is IERC20 {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112, uint112, uint32);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"Overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"Underflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"Mul Overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"Div by 0\");\n        uint256 c = a / b;\n\n        return c;\n    }\n}\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nstruct BaseInfo {\n    uint256 BONUS_MULTIPLIER;\n    uint256 bonusEndBlock;\n    address devaddr;\n    address migrator;\n    address owner;\n    uint256 startBlock;\n    address sushi;\n    uint256 sushiPerBlock;\n    uint256 totalAllocPoint;\n    \n    uint256 sushiTotalSupply;\n    address sushiOwner;\n}\n\nstruct PoolInfo {\n    string logo;\n    string name;\n    IPair lpToken;           // Address of LP token contract.\n    uint256 allocPoint;       // How many allocation points assigned to this pool. SUSHIs to distribute per block.\n    uint256 lastRewardBlock;  // Last block number that SUSHIs distribution occurs.\n    uint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.\n    IERC20 token0;\n    IERC20 token1;\n    string token0name;\n    string token1name;\n    string token0symbol;\n    string token1symbol;\n    uint256 token0decimals;\n    uint256 token1decimals;\n}\n\nstruct UserInfo {\n    uint256 block;\n    uint256 timestamp;\n    uint256 eth_rate;\n    uint256 sushiBalance;\n    address delegates;\n    uint256 currentVotes;\n    uint256 nonces;\n}\n\nstruct UserPoolInfo {\n    uint256 lastRewardBlock;  // Last block number that SUSHIs distribution occurs.\n    uint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.\n    uint256 balance; // Balance of pool tokens\n    uint256 totalSupply; // Token staked lp tokens\n    uint256 uniBalance; // Balance of uniswap lp tokens not staked\n    uint256 uniTotalSupply; // TotalSupply of uniswap lp tokens\n    uint256 uniAllowance; // UniSwap LP tokens approved for masterchef\n    uint256 reserve0;\n    uint256 reserve1;\n    uint256 token0rate;\n    uint256 token1rate;\n    uint256 rewardDebt;\n    uint256 pending; // Pending SUSHI\n}\n\ncontract SushiSwapBaseInfo is Ownable {\n    // Mainnet\n    //ISushiSwapPoolNames names = ISushiSwapPoolNames(0xb373a5def62A907696C0bBd22Dc512e2Fc8cfC7E);\n    //IMasterChef masterChef = IMasterChef(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);\n    \n    // Ropsten\n    ISushiSwapPoolNames names = ISushiSwapPoolNames(0x7685f4c573cE27C94F6aF70B330C29b9c41B8290);\n    IMasterChef masterChef = IMasterChef(0xFF281cEF43111A83f09C656734Fa03E6375d432A);\n    \n    function setContracts(address names_, address masterChef_) public onlyOwner {\n        names = ISushiSwapPoolNames(names_);\n        masterChef = IMasterChef(masterChef_);\n    }\n\n    function getInfo() public view returns(BaseInfo memory, PoolInfo[] memory) {\n        BaseInfo memory info;\n        info.BONUS_MULTIPLIER = masterChef.BONUS_MULTIPLIER();\n        info.bonusEndBlock = masterChef.bonusEndBlock();\n        info.devaddr = masterChef.devaddr();\n        info.migrator = masterChef.migrator();\n        info.owner = masterChef.owner();\n        info.startBlock = masterChef.startBlock();\n        info.sushi = masterChef.sushi();\n        info.sushiPerBlock = masterChef.sushiPerBlock();\n        info.totalAllocPoint = masterChef.totalAllocPoint();\n        \n        info.sushiTotalSupply = IERC20(info.sushi).totalSupply();\n        info.sushiOwner = IERC20(info.sushi).owner();\n\n        uint256 poolLength = masterChef.poolLength();\n        PoolInfo[] memory pools = new PoolInfo[](poolLength);\n        for (uint256 i = 0; i < poolLength; i++) {\n            (address lpToken, uint256 allocPoint, uint256 lastRewardBlock, uint256 accSushiPerShare) = masterChef.poolInfo(i);\n            IPair uniV2 = IPair(lpToken);\n            pools[i].lpToken = uniV2;\n            pools[i].allocPoint = allocPoint;\n            pools[i].lastRewardBlock = lastRewardBlock;\n            pools[i].accSushiPerShare = accSushiPerShare;\n            \n            IERC20 token0 = IERC20(uniV2.token0());\n            pools[i].token0 = token0;\n            IERC20 token1 = IERC20(uniV2.token1());\n            pools[i].token1 = token1;\n            \n            pools[i].token0name = token0.name();\n            pools[i].token0symbol = token0.symbol();\n            pools[i].token0decimals = token0.decimals();\n            \n            pools[i].token1name = token1.name();\n            pools[i].token1symbol = token1.symbol();\n            pools[i].token1decimals = token1.decimals();\n            \n            pools[i].logo = names.logos(i);\n            pools[i].name = names.names(i);\n        }\n        return (info, pools);\n    }\n}\n\ncontract SushiSwapUserInfo is Ownable\n{\n    using SafeMath for uint256;\n\n    IFactory factory = IFactory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\n    IMasterChef masterChef = IMasterChef(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);\n    ISushiToken sushi = ISushiToken(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2);\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    function setContracts(address factory_, address masterChef_, address sushi_, address WETH_) public onlyOwner {\n        factory = IFactory(factory_);\n        masterChef = IMasterChef(masterChef_);\n        sushi = ISushiToken(sushi_);\n        WETH = WETH_;\n    }\n\n    function getETHRate(address token) public view returns(uint256) {\n        uint256 eth_rate = 1e18;\n        if (token != WETH)\n        {\n            IPair pair = IPair(factory.getPair(token, WETH));\n            (uint112 reserve0, uint112 reserve1,) = pair.getReserves();\n            if (pair.token0() == WETH) {\n                eth_rate = uint256(reserve1).mul(1e18).div(reserve0);\n            } else {\n                eth_rate = uint256(reserve0).mul(1e18).div(reserve1);\n            }\n        }\n        return eth_rate;\n    }\n    \n    function _getUserInfo(address who, address currency) private view returns(UserInfo memory) {\n        UserInfo memory user;\n        \n        user.block = block.number;\n        user.timestamp = block.timestamp;\n        user.sushiBalance = sushi.balanceOf(who);\n        user.delegates = sushi.delegates(who);\n        user.currentVotes = sushi.getCurrentVotes(who);\n        user.nonces = sushi.nonces(who);\n        user.eth_rate = getETHRate(currency);\n        \n        return user;\n    }\n    \n    function getUserInfo(address who, address currency) public view returns(UserInfo memory, UserPoolInfo[] memory) {\n        uint256 poolLength = masterChef.poolLength();\n        UserPoolInfo[] memory pools = new UserPoolInfo[](poolLength);\n\n        for (uint256 i = 0; i < poolLength; i++) {\n            (uint256 amount, uint256 rewardDebt) = masterChef.userInfo(i, who);\n            pools[i].balance = amount;\n            pools[i].rewardDebt = rewardDebt;\n            pools[i].pending = masterChef.pendingSushi(i, who);\n\n            (address lpToken, , uint256 lastRewardBlock, uint256 accSushiPerShare) = masterChef.poolInfo(i);\n            IPair uniV2 = IPair(lpToken);\n            pools[i].totalSupply = uniV2.balanceOf(address(masterChef));\n            pools[i].uniAllowance = uniV2.allowance(who, address(masterChef));\n            pools[i].lastRewardBlock = lastRewardBlock;\n            pools[i].accSushiPerShare = accSushiPerShare;\n            pools[i].uniBalance = uniV2.balanceOf(who);\n            pools[i].uniTotalSupply = uniV2.totalSupply();\n            pools[i].token0rate = getETHRate(uniV2.token0());\n            pools[i].token1rate = getETHRate(uniV2.token1());\n            \n            (uint112 reserve0, uint112 reserve1,) = uniV2.getReserves();\n            pools[i].reserve0 = reserve0;\n            pools[i].reserve1 = reserve1;\n        }\n        return (_getUserInfo(who, currency), pools);\n    }\n    \n    function getMyInfoInUSDT() public view returns(UserInfo memory, UserPoolInfo[] memory) {\n        return getUserInfo(msg.sender, 0x292c703A980fbFce4708864Ae6E8C40584DAF323);\n    }\n}\n\nstruct PairInfo {\n    string logo;\n    string name;\n    IPair lpToken;           // Address of LP token contract.\n    uint256 allocPoint;       // How many allocation points assigned to this pool. SUSHIs to distribute per block.\n    uint256 lastRewardBlock;  // Last block number that SUSHIs distribution occurs.\n    uint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.\n    IERC20 token0;\n    IERC20 token1;\n    string token0name;\n    string token1name;\n    string token0symbol;\n    string token1symbol;\n    uint256 token0decimals;\n    uint256 token1decimals;\n    \n    uint256 makerBalance;\n    uint256 totalSupply;\n    uint256 reserve0;\n    uint256 reserve1;\n    uint256 token0rate;\n    uint256 token1rate;\n}\n\ncontract SushiMakerInfo is Ownable\n{\n    using SafeMath for uint256;\n\n    address sushiMaker = 0x54844afe358Ca98E4D09AAe869f25bfe072E1B1a;\n    IFactory factory = IFactory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\n    IFactory factory_backup = IFactory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n    ISushiToken sushi = ISushiToken(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2);\n    IMasterChef masterChef = IMasterChef(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);\n    ISushiSwapPoolNames names = ISushiSwapPoolNames(0xb373a5def62A907696C0bBd22Dc512e2Fc8cfC7E);\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    \n    mapping(uint256 => bool) public skipPID;\n    uint256 public skipCount;\n    \n    constructor() public {\n        setSkipPID(29, true);\n        setSkipPID(30, true);\n    }\n\n    function setContracts(address sushiMaker_, address factory_, address factory_backup_, address sushi_, address masterChef_, address names_, address WETH_) public onlyOwner {\n        sushiMaker = sushiMaker_;\n        factory = IFactory(factory_);\n        factory_backup = IFactory(factory_backup_);\n        sushi = ISushiToken(sushi_);\n        masterChef = IMasterChef(masterChef_);\n        names = ISushiSwapPoolNames(names_);\n        WETH = WETH_;\n    }\n    \n    function setSkipPID(uint pid, bool skip) public onlyOwner {\n        skipPID[pid] = skip;\n        if (skip) {\n            skipCount++;\n        } else {\n            skipCount--;\n        }\n    }\n\n    function getETHRate(address token) public view returns(uint256) {\n        uint256 eth_rate = 1e18;\n        if (token != WETH)\n        {\n            IPair pair;\n            pair = IPair(factory.getPair(token, WETH));\n            if (address(pair) == address(0)) {\n                pair = IPair(factory_backup.getPair(token, WETH));\n                if (address(pair) == address(0)) {\n                    return 0;\n                }\n            }\n            (uint112 reserve0, uint112 reserve1,) = pair.getReserves();\n            if (pair.token0() == WETH) {\n                eth_rate = uint256(reserve1).mul(1e18).div(reserve0);\n            } else {\n                eth_rate = uint256(reserve0).mul(1e18).div(reserve1);\n            }\n        }\n        return eth_rate;\n    }\n    \n    function getPair(uint256 pid) public view returns(PairInfo memory) {\n        PairInfo memory info;\n\n        (address lpToken, uint256 allocPoint, uint256 lastRewardBlock, uint256 accSushiPerShare) = masterChef.poolInfo(pid);\n        IPair pair = IPair(lpToken);\n        info.lpToken = pair;\n        info.allocPoint = allocPoint;\n        info.lastRewardBlock = lastRewardBlock;\n        info.accSushiPerShare = accSushiPerShare;\n        \n        IERC20 token0 = IERC20(pair.token0());\n        info.token0 = token0;\n        IERC20 token1 = IERC20(pair.token1());\n        info.token1 = token1;\n        \n        info.token0name = token0.name();\n        info.token0symbol = token0.symbol();\n        info.token0decimals = token0.decimals();\n        \n        info.token1name = token1.name();\n        info.token1symbol = token1.symbol();\n        info.token1decimals = token1.decimals();\n        \n        info.logo = names.logos(pid);\n        info.name = names.names(pid);\n\n        info.makerBalance = pair.balanceOf(sushiMaker);\n        info.totalSupply = pair.totalSupply();\n        \n        (uint112 reserve0, uint112 reserve1,) = pair.getReserves();\n        info.reserve0 = reserve0;\n        info.reserve1 = reserve1;\n\n        info.token0rate = getETHRate(address(token0));\n        info.token1rate = getETHRate(address(token1));\n\n        return info;\n    }    \n    \n    function getPairs(address currency) public view returns(uint256, PairInfo[] memory) {\n        uint pairCount = masterChef.poolLength();\n        PairInfo[] memory infos = new PairInfo[](pairCount.sub(skipCount));\n\n        uint256 currentPair;\n        for (uint256 i = 0; i < pairCount; i++) {\n            if (!skipPID[i]) {\n                (address lpToken, uint256 allocPoint, uint256 lastRewardBlock, uint256 accSushiPerShare) = masterChef.poolInfo(i);\n                IPair pair = IPair(lpToken);\n                infos[currentPair].lpToken = pair;\n                infos[currentPair].allocPoint = allocPoint;\n                infos[currentPair].lastRewardBlock = lastRewardBlock;\n                infos[currentPair].accSushiPerShare = accSushiPerShare;\n                \n                IERC20 token0 = IERC20(pair.token0());\n                infos[currentPair].token0 = token0;\n                IERC20 token1 = IERC20(pair.token1());\n                infos[currentPair].token1 = token1;\n                \n                infos[currentPair].token0name = token0.name();\n                infos[currentPair].token0symbol = token0.symbol();\n                infos[currentPair].token0decimals = token0.decimals();\n                \n                infos[currentPair].token1name = token1.name();\n                infos[currentPair].token1symbol = token1.symbol();\n                infos[currentPair].token1decimals = token1.decimals();\n                \n                infos[currentPair].logo = names.logos(i);\n                infos[currentPair].name = names.names(i);\n    \n                infos[currentPair].makerBalance = pair.balanceOf(sushiMaker);\n                infos[currentPair].totalSupply = pair.totalSupply();\n                \n                (uint112 reserve0, uint112 reserve1,) = pair.getReserves();\n                infos[currentPair].reserve0 = reserve0;\n                infos[currentPair].reserve1 = reserve1;\n    \n                infos[currentPair].token0rate = getETHRate(address(token0));\n                infos[currentPair].token1rate = getETHRate(address(token1));\n                \n                currentPair++;\n            }\n        }\n        return (getETHRate(currency), infos);\n    }\n}\n\n\n","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getETHRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"getPair\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"logo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"contract IPair\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accSushiPerShare\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"token0name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"token1name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"token0symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"token1symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"token0decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1rate\",\"type\":\"uint256\"}],\"internalType\":\"struct PairInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"getPairs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"logo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"contract IPair\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accSushiPerShare\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"token0name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"token1name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"token0symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"token1symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"token0decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1rate\",\"type\":\"uint256\"}],\"internalType\":\"struct PairInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sushiMaker_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory_backup_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sushi_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"masterChef_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"names_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"WETH_\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skip\",\"type\":\"bool\"}],\"name\":\"setSkipPID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skipCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"skipPID\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SushiMakerInfo","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}