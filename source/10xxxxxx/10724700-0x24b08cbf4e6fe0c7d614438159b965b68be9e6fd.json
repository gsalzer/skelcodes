{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IUniswapV1.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ninterface IUniswapV1Factory {\r\n    function getExchange(IERC20 token) external view returns (IUniswapV1Exchange exchange);\r\n}\r\n\r\ninterface IUniswapV1Exchange {\r\n    function getEthToTokenInputPrice(uint256 ethSold) external view returns (uint256 tokensBought);\r\n    function getTokenToEthInputPrice(uint256 tokensSold) external view returns (uint256 ethBought);\r\n\r\n    function ethToTokenSwapInput(uint256 minTokens, uint256 deadline)\r\n        external payable returns (uint256 tokensBought);\r\n    function tokenToEthSwapInput(uint256 tokensSold, uint256 minEth, uint256 deadline)\r\n        external returns (uint256 ethBought);\r\n}\r\n\r\n// File: contracts/interfaces/IUniswapV2.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(IERC20 tokenA, IERC20 tokenB) external view returns (IUniswapV2Exchange pair);\r\n}\r\n\r\ninterface IUniswapV2Exchange {\r\n    function getReserves() external view returns(uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n}\r\n\r\n// File: contracts/interfaces/IBalancer.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ninterface IBalancerPool {\r\n    function getSwapFee() external view returns (uint256 balance);\r\n    function getDenormalizedWeight(IERC20 token) external view returns (uint256 balance);\r\n    function getBalance(IERC20 token) external view returns (uint256 balance);\r\n\r\n    function swapExactAmountIn(\r\n        IERC20 tokenIn,\r\n        uint256 tokenAmountIn,\r\n        IERC20 tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n        external\r\n        returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\r\n}\r\n\r\ninterface IBalancerRegistry {\r\n    // Get info about pool pair for 1 SLOAD\r\n    function getPairInfo(address pool, IERC20 fromToken, IERC20 destToken)\r\n        external view returns(uint256 weight1, uint256 weight2, uint256 swapFee);\r\n\r\n    // Pools\r\n    function checkAddedPools(address pool)\r\n        external view returns(bool);\r\n    function getAddedPoolsLength()\r\n        external view returns(uint256);\r\n    function getAddedPools()\r\n        external view returns(address[] memory);\r\n    function getAddedPoolsWithLimit(uint256 offset, uint256 limit)\r\n        external view returns(address[] memory result);\r\n\r\n    // Tokens\r\n    function getAllTokensLength()\r\n        external view returns(uint256);\r\n    function getAllTokens()\r\n        external view returns(address[] memory);\r\n    function getAllTokensWithLimit(uint256 offset, uint256 limit)\r\n        external view returns(address[] memory result);\r\n\r\n    // Pairs\r\n    function getPoolsLength(IERC20 fromToken, IERC20 destToken)\r\n        external view returns(uint256);\r\n    function getPools(IERC20 fromToken, IERC20 destToken)\r\n        external view returns(IBalancerPool[] memory);\r\n    function getPoolsWithLimit(IERC20 fromToken, IERC20 destToken, uint256 offset, uint256 limit)\r\n        external view returns(IBalancerPool[] memory result);\r\n    function getBestPools(IERC20 fromToken, IERC20 destToken)\r\n        external view returns(IBalancerPool[] memory pools);\r\n    function getBestPoolsWithLimit(IERC20 fromToken, IERC20 destToken, uint256 limit)\r\n        external view returns(IBalancerPool[] memory pools);\r\n\r\n    // Get swap rates\r\n    function getPoolReturn(address pool, IERC20 fromToken, IERC20 destToken, uint256 amount)\r\n        external view returns(uint256);\r\n    function getPoolReturns(address pool, IERC20 fromToken, IERC20 destToken, uint256[] calldata amounts)\r\n        external view returns(uint256[] memory result);\r\n\r\n    // Add and update registry\r\n    function addPool(address pool) external returns(uint256 listed);\r\n    function addPools(address[] calldata pools) external returns(uint256[] memory listed);\r\n    function updatedIndices(address[] calldata tokens, uint256 lengthLimit) external;\r\n}\r\n\r\n// File: contracts/interfaces/IAaveRegistry.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ninterface IAaveRegistry {\r\n    function tokenByAToken(IERC20 aToken) external view returns(IERC20);\r\n    function aTokenByToken(IERC20 token) external view returns(IERC20);\r\n}\r\n\r\n// File: contracts/interfaces/ICompoundRegistry.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ninterface ICompoundRegistry {\r\n    function tokenByCToken(IERC20 cToken) external view returns(IERC20);\r\n    function cTokenByToken(IERC20 token) external view returns(IERC20);\r\n}\r\n\r\n// File: contracts/IOneRouter.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\ninterface IOneRouterView {\r\n    struct Swap {\r\n        IERC20 destToken;\r\n        uint256 flags;\r\n        uint256 destTokenEthPriceTimesGasPrice;\r\n        address[] disabledDexes;\r\n    }\r\n\r\n    struct Path {\r\n        Swap[] swaps;\r\n    }\r\n\r\n    struct SwapResult {\r\n        uint256[] returnAmounts;\r\n        uint256[] estimateGasAmounts;\r\n        uint256[][] distributions;\r\n        address[][] dexes;\r\n    }\r\n\r\n    struct PathResult {\r\n        SwapResult[] swaps;\r\n    }\r\n\r\n    function getReturn(\r\n        IERC20 fromToken,\r\n        uint256[] calldata amounts,\r\n        Swap calldata swap\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            Path[] memory paths,\r\n            PathResult[] memory pathResults,\r\n            SwapResult memory splitResult\r\n        );\r\n\r\n    function getSwapReturn(\r\n        IERC20 fromToken,\r\n        uint256[] calldata amounts,\r\n        Swap calldata swap\r\n    )\r\n        external\r\n        view\r\n        returns(SwapResult memory result);\r\n\r\n    function getPathReturn(\r\n        IERC20 fromToken,\r\n        uint256[] calldata amounts,\r\n        Path calldata path\r\n    )\r\n        external\r\n        view\r\n        returns(PathResult memory result);\r\n\r\n    function getMultiPathReturn(\r\n        IERC20 fromToken,\r\n        uint256[] calldata amounts,\r\n        Path[] calldata paths\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            PathResult[] memory pathResults,\r\n            SwapResult memory splitResult\r\n        );\r\n}\r\n\r\n\r\nabstract contract IOneRouter is IOneRouterView {\r\n    struct Referral {\r\n        address payable ref;\r\n        uint256 fee;\r\n    }\r\n\r\n    struct SwapInput {\r\n        IERC20 fromToken;\r\n        IERC20 destToken;\r\n        uint256 amount;\r\n        uint256 minReturn;\r\n        Referral referral;\r\n    }\r\n\r\n    struct SwapDistribution {\r\n        uint256[] weights;\r\n    }\r\n\r\n    struct PathDistribution {\r\n        SwapDistribution[] swapDistributions;\r\n    }\r\n\r\n    function makeSwap(\r\n        SwapInput calldata input,\r\n        Swap calldata swap,\r\n        SwapDistribution calldata swapDistribution\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        returns(uint256 returnAmount);\r\n\r\n    function makePathSwap(\r\n        SwapInput calldata input,\r\n        Path calldata path,\r\n        PathDistribution calldata pathDistribution\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        returns(uint256 returnAmount);\r\n\r\n    function makeMultiPathSwap(\r\n        SwapInput calldata input,\r\n        Path[] calldata paths,\r\n        PathDistribution[] calldata pathDistributions,\r\n        SwapDistribution calldata interPathsDistribution\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        returns(uint256 returnAmount);\r\n}\r\n\r\n// File: contracts/ISource.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ninterface ISource {\r\n    function calculate(IERC20 fromToken, uint256[] calldata amounts, IOneRouterView.Swap calldata swap)\r\n        external view returns(uint256[] memory rets, address dex, uint256 gas);\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) external;\r\n}\r\n\r\n// File: contracts/OneRouterConstants.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract OneRouterConstants {\r\n    uint256 constant internal _FLAG_DISABLE_ALL_SOURCES          = 0x100000000000000000000000000000000;\r\n    uint256 constant internal _FLAG_DISABLE_RECALCULATION        = 0x200000000000000000000000000000000;\r\n    uint256 constant internal _FLAG_ENABLE_CHI_BURN              = 0x400000000000000000000000000000000;\r\n    uint256 constant internal _FLAG_ENABLE_CHI_BURN_ORIGIN       = 0x800000000000000000000000000000000;\r\n    uint256 constant internal _FLAG_ENABLE_REFERRAL_GAS_DISCOUNT = 0x1000000000000000000000000000000000;\r\n\r\n\r\n    uint256 constant internal _FLAG_DISABLE_KYBER_ALL =\r\n        _FLAG_DISABLE_KYBER_1 +\r\n        _FLAG_DISABLE_KYBER_2 +\r\n        _FLAG_DISABLE_KYBER_3 +\r\n        _FLAG_DISABLE_KYBER_4;\r\n    uint256 constant internal _FLAG_DISABLE_CURVE_ALL =\r\n        _FLAG_DISABLE_CURVE_COMPOUND +\r\n        _FLAG_DISABLE_CURVE_USDT +\r\n        _FLAG_DISABLE_CURVE_Y +\r\n        _FLAG_DISABLE_CURVE_BINANCE +\r\n        _FLAG_DISABLE_CURVE_SYNTHETIX +\r\n        _FLAG_DISABLE_CURVE_PAX +\r\n        _FLAG_DISABLE_CURVE_RENBTC +\r\n        _FLAG_DISABLE_CURVE_TBTC +\r\n        _FLAG_DISABLE_CURVE_SBTC;\r\n    uint256 constant internal _FLAG_DISABLE_BALANCER_ALL =\r\n        _FLAG_DISABLE_BALANCER_1 +\r\n        _FLAG_DISABLE_BALANCER_2 +\r\n        _FLAG_DISABLE_BALANCER_3;\r\n    uint256 constant internal _FLAG_DISABLE_BANCOR_ALL =\r\n        _FLAG_DISABLE_BANCOR_1 +\r\n        _FLAG_DISABLE_BANCOR_2 +\r\n        _FLAG_DISABLE_BANCOR_3;\r\n\r\n    uint256 constant internal _FLAG_DISABLE_UNISWAP_V1      = 0x1;\r\n    uint256 constant internal _FLAG_DISABLE_UNISWAP_V2      = 0x2;\r\n    uint256 constant internal _FLAG_DISABLE_MOONISWAP       = 0x4;\r\n    uint256 constant internal _FLAG_DISABLE_KYBER_1         = 0x8;\r\n    uint256 constant internal _FLAG_DISABLE_KYBER_2         = 0x10;\r\n    uint256 constant internal _FLAG_DISABLE_KYBER_3         = 0x20;\r\n    uint256 constant internal _FLAG_DISABLE_KYBER_4         = 0x40;\r\n    uint256 constant internal _FLAG_DISABLE_CURVE_COMPOUND  = 0x80;\r\n    uint256 constant internal _FLAG_DISABLE_CURVE_USDT      = 0x100;\r\n    uint256 constant internal _FLAG_DISABLE_CURVE_Y         = 0x200;\r\n    uint256 constant internal _FLAG_DISABLE_CURVE_BINANCE   = 0x400;\r\n    uint256 constant internal _FLAG_DISABLE_CURVE_SYNTHETIX = 0x800;\r\n    uint256 constant internal _FLAG_DISABLE_CURVE_PAX       = 0x1000;\r\n    uint256 constant internal _FLAG_DISABLE_CURVE_RENBTC    = 0x2000;\r\n    uint256 constant internal _FLAG_DISABLE_CURVE_TBTC      = 0x4000;\r\n    uint256 constant internal _FLAG_DISABLE_CURVE_SBTC      = 0x8000;\r\n    uint256 constant internal _FLAG_DISABLE_BALANCER_1      = 0x10000;\r\n    uint256 constant internal _FLAG_DISABLE_BALANCER_2      = 0x20000;\r\n    uint256 constant internal _FLAG_DISABLE_BALANCER_3      = 0x40000;\r\n    uint256 constant internal _FLAG_DISABLE_BANCOR_1        = 0x80000;\r\n    uint256 constant internal _FLAG_DISABLE_BANCOR_2        = 0x100000;\r\n    uint256 constant internal _FLAG_DISABLE_BANCOR_3        = 0x200000;\r\n    uint256 constant internal _FLAG_DISABLE_OASIS           = 0x400000;\r\n    uint256 constant internal _FLAG_DISABLE_DFORCE_SWAP     = 0x800000;\r\n    uint256 constant internal _FLAG_DISABLE_SHELL           = 0x1000000;\r\n    uint256 constant internal _FLAG_DISABLE_MSTABLE_MUSD    = 0x2000000;\r\n    uint256 constant internal _FLAG_DISABLE_BLACK_HOLE_SWAP = 0x4000000;\r\n\r\n    IERC20 constant internal _DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\r\n    IERC20 constant internal _USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    IERC20 constant internal _USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n    IERC20 constant internal _TUSD = IERC20(0x0000000000085d4780B73119b644AE5ecd22b376);\r\n    IERC20 constant internal _BUSD = IERC20(0x4Fabb145d64652a948d72533023f6E7A623C7C53);\r\n    IERC20 constant internal _SUSD = IERC20(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);\r\n    IERC20 constant internal _PAX = IERC20(0x8E870D67F660D95d5be530380D0eC0bd388289E1);\r\n    IERC20 constant internal _RENBTC = IERC20(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D);\r\n    IERC20 constant internal _WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\r\n    IERC20 constant internal _SBTC = IERC20(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6);\r\n    IERC20 constant internal _CHI = IERC20(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/Algo.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\nlibrary Algo {\r\n    using SafeMath for uint256;\r\n\r\n    int256 public constant VERY_NEGATIVE_VALUE = -1e72;\r\n\r\n    function findBestDistribution(int256[][] memory amounts, uint256 parts)\r\n        internal\r\n        pure\r\n        returns(\r\n            int256[] memory returnAmounts,\r\n            uint256[][] memory distributions\r\n        )\r\n    {\r\n        uint256 n = amounts.length;\r\n\r\n        int256[][] memory answer = new int256[][](n); // int[n][parts+1]\r\n        uint256[][] memory parent = new uint256[][](n); // int[n][parts+1]\r\n\r\n        for (uint i = 0; i < n; i++) {\r\n            answer[i] = new int256[](parts + 1);\r\n            parent[i] = new uint256[](parts + 1);\r\n        }\r\n\r\n        for (uint j = 0; j <= parts; j++) {\r\n            answer[0][j] = amounts[0][j];\r\n            for (uint i = 1; i < n; i++) {\r\n                answer[i][j] = VERY_NEGATIVE_VALUE;\r\n            }\r\n            parent[0][j] = 0;\r\n        }\r\n\r\n        for (uint i = 1; i < n; i++) {\r\n            for (uint j = 0; j <= parts; j++) {\r\n                answer[i][j] = answer[i - 1][j];\r\n                parent[i][j] = j;\r\n\r\n                for (uint k = 1; k <= j; k++) {\r\n                    if (answer[i - 1][j - k] + amounts[i][k] > answer[i][j]) {\r\n                        answer[i][j] = answer[i - 1][j - k] + amounts[i][k];\r\n                        parent[i][j] = j - k;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        distributions = new uint256[][](parts);\r\n        returnAmounts = new int256[](parts);\r\n        for (uint256 i = 1; i <= parts; i++) {\r\n            uint256 partsLeft = i;\r\n            distributions[i - 1] = new uint256[](n);\r\n            for (uint curExchange = n - 1; partsLeft > 0; curExchange--) {\r\n                distributions[i - 1][curExchange] = partsLeft - parent[curExchange][partsLeft];\r\n                partsLeft = parent[curExchange][partsLeft];\r\n            }\r\n\r\n            returnAmounts[i - 1] = (answer[n - 1][i] == VERY_NEGATIVE_VALUE) ? 0 : answer[n - 1][i];\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/Address2.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\nlibrary Address2 {\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(Address.isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/UniERC20.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\nlibrary UniERC20 {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 public constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n    IERC20 public constant ZERO_ADDRESS = IERC20(0);\r\n\r\n    function isETH(IERC20 token) internal pure returns(bool) {\r\n        return (token == ZERO_ADDRESS || token == ETH_ADDRESS);\r\n    }\r\n\r\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\r\n        if (isETH(token)) {\r\n            return account.balance;\r\n        } else {\r\n            return token.balanceOf(account);\r\n        }\r\n    }\r\n\r\n    function uniTransfer(IERC20 token, address payable to, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            if (isETH(token)) {\r\n                to.transfer(amount);\r\n            } else {\r\n                token.safeTransfer(to, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function uniTransferFromSender(IERC20 token, address payable target, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            if (isETH(token)) {\r\n                require(msg.value >= amount, \"UniERC20: not enough value\");\r\n                target.transfer(amount);\r\n                if (msg.value > amount) {\r\n                    // Return remainder if exist\r\n                    msg.sender.transfer(msg.value.sub(amount));\r\n                }\r\n            } else {\r\n                token.safeTransferFrom(msg.sender, target, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function uniApprove(IERC20 token, address to, uint256 amount) internal {\r\n        if (!isETH(token)) {\r\n            if (amount == 0) {\r\n                token.safeApprove(to, 0);\r\n                return;\r\n            }\r\n\r\n            uint256 allowance = token.allowance(address(this), to);\r\n            if (allowance < amount) {\r\n                if (allowance > 0) {\r\n                    token.safeApprove(to, 0);\r\n                }\r\n                token.safeApprove(to, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function uniDecimals(IERC20 token) internal view returns (uint256) {\r\n        if (isETH(token)) {\r\n            return 18;\r\n        }\r\n\r\n        (bool success, bytes memory data) = address(token).staticcall{ gas: 20000 }(\r\n            abi.encodeWithSignature(\"decimals()\")\r\n        );\r\n        if (!success) {\r\n            (success, data) = address(token).staticcall{ gas: 20000 }(\r\n                abi.encodeWithSignature(\"DECIMALS()\")\r\n            );\r\n        }\r\n\r\n        return success ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    function uniSymbol(IERC20 token) internal view returns(string memory) {\r\n        if (isETH(token)) {\r\n            return \"ETH\";\r\n        }\r\n\r\n        (bool success, bytes memory data) = address(token).staticcall{ gas: 20000 }(\r\n            abi.encodeWithSignature(\"symbol()\")\r\n        );\r\n        if (!success) {\r\n            (success, data) = address(token).staticcall{ gas: 20000 }(\r\n                abi.encodeWithSignature(\"SYMBOL()\")\r\n            );\r\n        }\r\n\r\n        if (success && data.length >= 96) {\r\n            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\r\n            if (offset == 0x20 && len > 0 && len <= 256) {\r\n                return string(abi.decode(data, (bytes)));\r\n            }\r\n        }\r\n\r\n        if (success && data.length == 32) {\r\n            uint len = 0;\r\n            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\r\n                len++;\r\n            }\r\n\r\n            if (len > 0) {\r\n                bytes memory result = new bytes(len);\r\n                for (uint i = 0; i < len; i++) {\r\n                    result[i] = data[i];\r\n                }\r\n                return string(result);\r\n            }\r\n        }\r\n\r\n        return _toHex(address(token));\r\n    }\r\n\r\n    function _toHex(address account) private pure returns(string memory) {\r\n        return _toHex(abi.encodePacked(account));\r\n    }\r\n\r\n    function _toHex(bytes memory data) private pure returns(string memory) {\r\n        bytes memory str = new bytes(2 + data.length * 2);\r\n        str[0] = \"0\";\r\n        str[1] = \"x\";\r\n        uint j = 2;\r\n        for (uint i = 0; i < data.length; i++) {\r\n            uint a = uint8(data[i]) >> 4;\r\n            uint b = uint8(data[i]) & 0x0f;\r\n            str[j++] = byte(uint8(a + 48 + (a/10)*39));\r\n            str[j++] = byte(uint8(b + 48 + (b/10)*39));\r\n        }\r\n\r\n        return string(str);\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/RevertReason.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\nlibrary RevertReason {\r\n    function parse(bytes memory data, string memory message) internal pure returns (string memory) {\r\n        (, string memory reason) = abi.decode(abi.encodePacked(bytes28(0), data), (uint256, string));\r\n        return string(abi.encodePacked(message, reason));\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/FlagsChecker.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\nlibrary FlagsChecker {\r\n    function check(uint256 flags, uint256 flag) internal pure returns(bool) {\r\n        return (flags & flag) != 0;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/DynamicMemoryArray.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\nlibrary DynamicMemoryArray {\r\n    using SafeMath for uint256;\r\n\r\n    struct Addresses {\r\n        uint256 length;\r\n        address[1000] _arr;\r\n    }\r\n\r\n    function at(DynamicMemoryArray.Addresses memory self, uint256 index) internal pure returns(address) {\r\n        require(index < self.length, \"DynMemArr: out of range\");\r\n        return self._arr[index];\r\n    }\r\n\r\n    function push(DynamicMemoryArray.Addresses memory self, address item) internal pure returns(uint256) {\r\n        require(self.length < self._arr.length, \"DynMemArr: out of limit\");\r\n        self._arr[self.length++] = item;\r\n        return self.length;\r\n    }\r\n\r\n    function pop(DynamicMemoryArray.Addresses memory self) internal pure returns(address) {\r\n        require(self.length > 0, \"DynMemArr: already empty\");\r\n        return self._arr[--self.length];\r\n    }\r\n\r\n    function copy(DynamicMemoryArray.Addresses memory self) internal pure returns(address[] memory arr) {\r\n        arr = new address[](self.length);\r\n        for (uint i = 0; i < arr.length; i++) {\r\n            arr[i] = self._arr[i];\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/sources/UniswapV1Source.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract UniswapV1SourceView {\r\n    using SafeMath for uint256;\r\n    using UniERC20 for IERC20;\r\n\r\n    IUniswapV1Factory constant private _FACTORY = IUniswapV1Factory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\r\n\r\n    function _calculateUniswapV1Formula(uint256 fromBalance, uint256 toBalance, uint256 amount) private pure returns(uint256) {\r\n        if (amount > 0) {\r\n            return amount.mul(toBalance).mul(997).div(\r\n                fromBalance.mul(1000).add(amount.mul(997))\r\n            );\r\n        }\r\n    }\r\n\r\n    function _calculateUniswapV1(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        rets = new uint256[](amounts.length);\r\n\r\n        if (fromToken.isETH() || swap.destToken.isETH()) {\r\n            IUniswapV1Exchange exchange = _FACTORY.getExchange(fromToken.isETH() ? swap.destToken : fromToken);\r\n            if (exchange == IUniswapV1Exchange(0)) {\r\n                return (rets, address(0), 0);\r\n            }\r\n\r\n            for (uint t = 0; t < swap.disabledDexes.length; t++) {\r\n                if (swap.disabledDexes[t] == address(exchange)) {\r\n                    return (rets, address(0), 0);\r\n                }\r\n            }\r\n\r\n            uint256 fromBalance = fromToken.uniBalanceOf(address(exchange));\r\n            uint256 destBalance = swap.destToken.uniBalanceOf(address(exchange));\r\n            for (uint i = 0; i < amounts.length; i++) {\r\n                rets[i] = _calculateUniswapV1Formula(fromBalance, destBalance, amounts[i]);\r\n            }\r\n            return (rets, address(exchange), 60_000);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract UniswapV1SourceSwap {\r\n    using UniERC20 for IERC20;\r\n\r\n    IUniswapV1Factory constant private _FACTORY = IUniswapV1Factory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\r\n\r\n    function _swapOnUniswapV1(\r\n        IERC20 fromToken,\r\n        IERC20 destToken,\r\n        uint256 amount,\r\n        uint256 /*flags*/\r\n    ) internal {\r\n        IUniswapV1Exchange exchange = _FACTORY.getExchange(fromToken.isETH() ? destToken : fromToken);\r\n        fromToken.uniApprove(address(exchange), amount);\r\n        if (fromToken.isETH()) {\r\n            exchange.ethToTokenSwapInput{ value: amount }(1, block.timestamp);\r\n        } else {\r\n            exchange.tokenToEthSwapInput(amount, 1, block.timestamp);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract UniswapV1SourcePublic is ISource, UniswapV1SourceView, UniswapV1SourceSwap {\r\n    receive() external payable {\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\r\n    }\r\n\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateUniswapV1(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnUniswapV1(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IWETH.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\nabstract contract IWETH is IERC20 {\r\n    function deposit() external payable virtual;\r\n    function withdraw(uint256 amount) external virtual;\r\n}\r\n\r\n// File: contracts/sources/UniswapV2Source.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary UniswapV2Helper {\r\n    using Math for uint256;\r\n    using SafeMath for uint256;\r\n    using UniERC20 for IERC20;\r\n\r\n    IUniswapV2Factory constant public FACTORY = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n    IWETH constant public WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n\r\n    function getReturns(\r\n        IUniswapV2Exchange exchange,\r\n        IERC20 fromToken,\r\n        IERC20 destToken,\r\n        uint256[] memory amounts\r\n    ) internal view returns (\r\n        uint256[] memory results,\r\n        uint256 reserveIn,\r\n        uint256 reverseOut,\r\n        bool needSync,\r\n        bool needSkim\r\n    ) {\r\n        return _getReturns(\r\n            exchange,\r\n            fromToken.isETH() ? UniswapV2Helper.WETH : fromToken,\r\n            destToken.isETH() ? UniswapV2Helper.WETH : destToken,\r\n            amounts\r\n        );\r\n    }\r\n\r\n    function _getReturns(\r\n        IUniswapV2Exchange exchange,\r\n        IERC20 fromToken,\r\n        IERC20 destToken,\r\n        uint256[] memory amounts\r\n    ) private view returns (\r\n        uint256[] memory results,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut,\r\n        bool needSync,\r\n        bool needSkim\r\n    ) {\r\n        reserveIn = fromToken.uniBalanceOf(address(exchange));\r\n        reserveOut = destToken.uniBalanceOf(address(exchange));\r\n        (uint112 reserve0, uint112 reserve1,) = exchange.getReserves();\r\n        if (fromToken > destToken) {\r\n            (reserve0, reserve1) = (reserve1, reserve0);\r\n        }\r\n        needSync = (reserveIn < reserve0 || reserveOut < reserve1);\r\n        needSkim = !needSync && (reserveIn > reserve0 || reserveOut > reserve1);\r\n\r\n        reserveIn = Math.min(reserveIn, reserve0);\r\n        reserveOut = Math.min(reserveOut, reserve1);\r\n\r\n        results = new uint256[](amounts.length);\r\n        for (uint i = 0; i < amounts.length; i++) {\r\n            results[i] = calculateUniswapV2Formula(reserveIn, reserveOut, amounts[i]);\r\n        }\r\n    }\r\n\r\n    function calculateUniswapV2Formula(uint256 reserveIn, uint256 reserveOut, uint256 amount) internal pure returns(uint256) {\r\n        if (amount > 0) {\r\n            return amount.mul(reserveOut).mul(997).div(\r\n                reserveIn.mul(1000).add(amount.mul(997))\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract UniswapV2SourceView {\r\n    using SafeMath for uint256;\r\n    using UniERC20 for IERC20;\r\n    using UniswapV2Helper for IUniswapV2Exchange;\r\n\r\n    function _calculateUniswapV2(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        rets = new uint256[](amounts.length);\r\n\r\n        IERC20 fromTokenWrapped = fromToken.isETH() ? UniswapV2Helper.WETH : fromToken;\r\n        IERC20 destTokenWrapped = swap.destToken.isETH() ? UniswapV2Helper.WETH : swap.destToken;\r\n        IUniswapV2Exchange exchange = UniswapV2Helper.FACTORY.getPair(fromTokenWrapped, destTokenWrapped);\r\n        if (exchange == IUniswapV2Exchange(0)) {\r\n            return (rets, address(0), 0);\r\n        }\r\n\r\n        for (uint t = 0; t < swap.disabledDexes.length; t++) {\r\n            if (swap.disabledDexes[t] == address(exchange)) {\r\n                return (rets, address(0), 0);\r\n            }\r\n        }\r\n\r\n        (rets,,,,) = exchange.getReturns(fromToken, swap.destToken, amounts);\r\n        return (rets, address(exchange), 50_000 + (fromToken.isETH() || swap.destToken.isETH() ? 0 : 30_000));\r\n    }\r\n}\r\n\r\n\r\ncontract UniswapV2SourceSwap {\r\n    using UniERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using UniswapV2Helper for IUniswapV2Exchange;\r\n\r\n    function _swapOnUniswapV2(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) internal {\r\n        if (fromToken.isETH()) {\r\n            UniswapV2Helper.WETH.deposit{ value: amount }();\r\n        }\r\n\r\n        _swapOnUniswapV2Wrapped(\r\n            fromToken.isETH() ? UniswapV2Helper.WETH : fromToken,\r\n            destToken.isETH() ? UniswapV2Helper.WETH : destToken,\r\n            amount,\r\n            flags\r\n        );\r\n\r\n        if (destToken.isETH()) {\r\n            UniswapV2Helper.WETH.withdraw(UniswapV2Helper.WETH.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    function _swapOnUniswapV2Wrapped(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) private {\r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = amount;\r\n\r\n        IUniswapV2Exchange exchange = UniswapV2Helper.FACTORY.getPair(fromToken, destToken);\r\n        (\r\n            /*uint256[] memory returnAmounts*/,\r\n            uint256 reserveIn,\r\n            uint256 reserveOut,\r\n            bool needSync,\r\n            bool needSkim\r\n        ) = exchange.getReturns(fromToken, destToken, amounts);\r\n\r\n        if (needSync) {\r\n            exchange.sync();\r\n        }\r\n        else if (needSkim) {\r\n            exchange.skim(0x68a17B587CAF4f9329f0e372e3A78D23A46De6b5);\r\n        }\r\n\r\n        fromToken.uniTransfer(payable(address(exchange)), amount);\r\n        uint256 confirmed = fromToken.uniBalanceOf(address(exchange)).sub(reserveIn);\r\n        uint256 returnAmount = UniswapV2Helper.calculateUniswapV2Formula(reserveIn, reserveOut, confirmed);\r\n\r\n        if (fromToken < destToken) {\r\n            exchange.swap(0, returnAmount, address(this), \"\");\r\n        } else {\r\n            exchange.swap(returnAmount, 0, address(this), \"\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract UniswapV2SourcePublic is ISource, UniswapV2SourceView, UniswapV2SourceSwap {\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateUniswapV2(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnUniswapV2(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IMooniswap.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ninterface IMooniswapRegistry {\r\n    function pools(IERC20 token1, IERC20 token2) external view returns(IMooniswap);\r\n    function isPool(address addr) external view returns(bool);\r\n}\r\n\r\n\r\ninterface IMooniswap {\r\n    function fee() external view returns (uint256);\r\n    function tokens(uint256 i) external view returns (IERC20);\r\n    function getBalanceForAddition(IERC20 token) external view returns(uint256);\r\n    function getBalanceForRemoval(IERC20 token) external view returns(uint256);\r\n    function getReturn(IERC20 fromToken, IERC20 destToken, uint256 amount) external view returns(uint256 returnAmount);\r\n\r\n    function deposit(uint256[] calldata amounts, uint256[] calldata minAmounts) external payable returns(uint256 fairSupply);\r\n    function withdraw(uint256 amount, uint256[] calldata minReturns) external;\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 minReturn, address referral) external payable returns(uint256 returnAmount);\r\n}\r\n\r\n// File: contracts/sources/MooniswapSource.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary MooniswapHelper {\r\n    using SafeMath for uint256;\r\n    using UniERC20 for IERC20;\r\n\r\n    IMooniswapRegistry constant public REGISTRY = IMooniswapRegistry(0x71CD6666064C3A1354a3B4dca5fA1E2D3ee7D303);\r\n\r\n    function getReturn(\r\n        IMooniswap mooniswap,\r\n        IERC20 fromToken,\r\n        IERC20 destToken,\r\n        uint256 amount\r\n    ) internal view returns(uint256 ret) {\r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = amount;\r\n        uint256[] memory rets = getReturns(mooniswap, fromToken, destToken, amounts);\r\n        if (rets.length > 0) {\r\n            return rets[0];\r\n        }\r\n    }\r\n\r\n    function getReturns(\r\n        IMooniswap mooniswap,\r\n        IERC20 fromToken,\r\n        IERC20 destToken,\r\n        uint256[] memory amounts\r\n    ) internal view returns(uint256[] memory rets) {\r\n        rets = new uint256[](amounts.length);\r\n\r\n        uint256 fee = mooniswap.fee();\r\n        uint256 fromBalance = mooniswap.getBalanceForAddition(fromToken.isETH() ? UniERC20.ZERO_ADDRESS : fromToken);\r\n        uint256 destBalance = mooniswap.getBalanceForRemoval(destToken.isETH() ? UniERC20.ZERO_ADDRESS : destToken);\r\n        if (fromBalance > 0 && destBalance > 0) {\r\n            for (uint i = 0; i < amounts.length; i++) {\r\n                uint256 amount = amounts[i].sub(amounts[i].mul(fee).div(1e18));\r\n                rets[i] = amount.mul(destBalance).div(\r\n                    fromBalance.add(amount)\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract MooniswapSourceView {\r\n    using SafeMath for uint256;\r\n    using UniERC20 for IERC20;\r\n    using MooniswapHelper for IMooniswap;\r\n\r\n    function _calculateMooniswap(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        IMooniswap mooniswap = MooniswapHelper.REGISTRY.pools(\r\n            fromToken.isETH() ? UniERC20.ZERO_ADDRESS : fromToken,\r\n            swap.destToken.isETH() ? UniERC20.ZERO_ADDRESS : swap.destToken\r\n        );\r\n        if (mooniswap == IMooniswap(0)) {\r\n            return (new uint256[](0), address(0), 0);\r\n        }\r\n\r\n        for (uint t = 0; t < swap.disabledDexes.length; t++) {\r\n            if (swap.disabledDexes[t] == address(mooniswap)) {\r\n                return (new uint256[](0), address(0), 0);\r\n            }\r\n        }\r\n\r\n        rets = mooniswap.getReturns(fromToken, swap.destToken, amounts);\r\n        if (rets.length == 0 || rets[0] == 0) {\r\n            return (new uint256[](0), address(0), 0);\r\n        }\r\n\r\n        return (rets, address(mooniswap), (fromToken.isETH() || swap.destToken.isETH()) ? 80_000 : 110_000);\r\n    }\r\n}\r\n\r\n\r\ncontract MooniswapSourceSwap {\r\n    using UniERC20 for IERC20;\r\n\r\n    function _swapOnMooniswap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\r\n        IMooniswap mooniswap = MooniswapHelper.REGISTRY.pools(\r\n            fromToken.isETH() ? UniERC20.ZERO_ADDRESS : fromToken,\r\n            destToken.isETH() ? UniERC20.ZERO_ADDRESS : destToken\r\n        );\r\n\r\n        fromToken.uniApprove(address(mooniswap), amount);\r\n        mooniswap.swap{ value: fromToken.isETH() ? amount : 0 }(\r\n            fromToken.isETH() ? UniERC20.ZERO_ADDRESS : fromToken,\r\n            destToken.isETH() ? UniERC20.ZERO_ADDRESS : destToken,\r\n            amount,\r\n            0,\r\n            0x68a17B587CAF4f9329f0e372e3A78D23A46De6b5\r\n        );\r\n    }\r\n}\r\n\r\n\r\ncontract MooniswapSourcePublic is ISource, MooniswapSourceView, MooniswapSourceSwap {\r\n    receive() external payable {\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\r\n    }\r\n\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateMooniswap(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnMooniswap(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IKyber.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ninterface IKyberStorage {\r\n    function getReserveIdsPerTokenSrc(IERC20 token) external view returns (bytes32[] memory);\r\n    function getReserveAddressesByReserveId(bytes32 reserveId) external view returns (IKyberReserve[] memory reserveAddresses);\r\n}\r\n\r\n\r\ninterface IKyberReserve {\r\n    function getConversionRate(IERC20 src, IERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\r\n}\r\n\r\n\r\ninterface IKyberHintHandler {\r\n    enum TradeType {\r\n        BestOfAll,\r\n        MaskIn,\r\n        MaskOut,\r\n        Split\r\n    }\r\n\r\n    function buildTokenToEthHint(\r\n        IERC20 tokenSrc,\r\n        TradeType tokenToEthType,\r\n        bytes32[] calldata tokenToEthReserveIds,\r\n        uint256[] calldata tokenToEthSplits\r\n    ) external view returns (bytes memory hint);\r\n\r\n    function buildEthToTokenHint(\r\n        IERC20 tokenDest,\r\n        TradeType ethToTokenType,\r\n        bytes32[] calldata ethToTokenReserveIds,\r\n        uint256[] calldata ethToTokenSplits\r\n    ) external view returns (bytes memory hint);\r\n}\r\n\r\n\r\ninterface IKyberNetworkProxy {\r\n    function getExpectedRateAfterFee(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external view returns (uint256 expectedRate);\r\n\r\n    function tradeWithHintAndFee(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256 destAmount);\r\n}\r\n\r\n// File: contracts/sources/KyberSource.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary KyberHelper {\r\n    using UniERC20 for IERC20;\r\n\r\n    IKyberNetworkProxy constant public PROXY = IKyberNetworkProxy(0x9AAb3f75489902f3a48495025729a0AF77d4b11e);\r\n    IKyberStorage constant public STORAGE = IKyberStorage(0xC8fb12402cB16970F3C5F4b48Ff68Eb9D1289301);\r\n    IKyberHintHandler constant public HINT_HANDLER = IKyberHintHandler(0xa1C0Fa73c39CFBcC11ec9Eb1Afc665aba9996E2C);\r\n\r\n    // https://github.com/CryptoManiacsZone/1inchProtocol/blob/master/KyberReserves.md\r\n    bytes1 constant public RESERVE_BRIDGE_PREFIX = 0xbb;\r\n    bytes32 constant public RESERVE_ID_1 = 0xff4b796265722046707200000000000000000000000000000000000000000000; // 0x63825c174ab367968EC60f061753D3bbD36A0D8F\r\n    bytes32 constant public RESERVE_ID_2 = 0xffabcd0000000000000000000000000000000000000000000000000000000000; // 0x7a3370075a54B187d7bD5DceBf0ff2B5552d4F7D\r\n    bytes32 constant public RESERVE_ID_3 = 0xff4f6e65426974205175616e7400000000000000000000000000000000000000; // 0x4f32BbE8dFc9efD54345Fc936f9fEF1048746fCF\r\n\r\n    function getReserveId(IERC20 fromToken, IERC20 destToken) internal view returns(bytes32) {\r\n        if (fromToken.isETH() || destToken.isETH()) {\r\n            bytes32[] memory reserveIds = STORAGE.getReserveIdsPerTokenSrc(\r\n                fromToken.isETH() ? destToken : fromToken\r\n            );\r\n\r\n            for (uint i = 0; i < reserveIds.length; i++) {\r\n                if (reserveIds[i][0] != RESERVE_BRIDGE_PREFIX &&\r\n                    reserveIds[i] != RESERVE_ID_1 &&\r\n                    reserveIds[i] != RESERVE_ID_2 &&\r\n                    reserveIds[i] != RESERVE_ID_3)\r\n                {\r\n                    return reserveIds[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract KyberSourceView is OneRouterConstants {\r\n    using SafeMath for uint256;\r\n    using UniERC20 for IERC20;\r\n    using FlagsChecker for uint256;\r\n\r\n    function _calculateKyber1(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateKyber(fromToken, amounts, swap, KyberHelper.RESERVE_ID_1);\r\n    }\r\n\r\n    function _calculateKyber2(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateKyber(fromToken, amounts, swap, KyberHelper.RESERVE_ID_2);\r\n    }\r\n\r\n    function _calculateKyber3(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateKyber(fromToken, amounts, swap, KyberHelper.RESERVE_ID_3);\r\n    }\r\n\r\n    function _calculateKyber4(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        bytes32 reserveId = KyberHelper.getReserveId(fromToken, swap.destToken);\r\n        if (reserveId != 0) {\r\n            return _calculateKyber(fromToken, amounts, swap, reserveId);\r\n        }\r\n    }\r\n\r\n    // Fix for \"Stack too deep\"\r\n    struct Decimals {\r\n        uint256 fromTokenDecimals;\r\n        uint256 destTokenDecimals;\r\n    }\r\n\r\n    function _calculateKyber(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap, bytes32 reserveId) private view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        rets = new uint256[](amounts.length);\r\n\r\n        IKyberReserve reserve = KyberHelper.STORAGE.getReserveAddressesByReserveId(reserveId)[0];\r\n\r\n        for (uint t = 0; t < swap.disabledDexes.length; t++) {\r\n            if (swap.disabledDexes[t] == address(reserve)) {\r\n                return (rets, address(0), 0);\r\n            }\r\n        }\r\n\r\n        Decimals memory decimals = Decimals({\r\n            fromTokenDecimals: 10 ** IERC20(fromToken).uniDecimals(),\r\n            destTokenDecimals: 10 ** IERC20(swap.destToken).uniDecimals()\r\n        });\r\n        for (uint i = 0; i < amounts.length; i++) {\r\n            if (i > 0 && rets[i - 1] == 0) {\r\n                break;\r\n            }\r\n\r\n            uint256 amount = amounts[0].mul(uint256(1e18).sub((swap.flags >> 255) * 1e15)).div(1e18);\r\n            try reserve.getConversionRate(\r\n                fromToken.isETH() ? UniERC20.ETH_ADDRESS : fromToken,\r\n                swap.destToken.isETH() ? UniERC20.ETH_ADDRESS : swap.destToken,\r\n                amount,\r\n                block.number\r\n            )\r\n            returns(uint256 rate) {\r\n                uint256 preResult = amounts[i].mul(rate).mul(decimals.destTokenDecimals);\r\n                rets[i] = preResult.div(decimals.fromTokenDecimals).div(1e18);\r\n            } catch {\r\n            }\r\n        }\r\n\r\n        return (rets, address(reserve), 100_000);\r\n    }\r\n}\r\n\r\n\r\ncontract KyberSourceSwap {\r\n    using UniERC20 for IERC20;\r\n\r\n    function _swapOnKyber1(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) internal {\r\n        _swapOnKyber(fromToken, destToken, amount, flags, KyberHelper.RESERVE_ID_1);\r\n    }\r\n\r\n    function _swapOnKyber2(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) internal {\r\n        _swapOnKyber(fromToken, destToken, amount, flags, KyberHelper.RESERVE_ID_2);\r\n    }\r\n\r\n    function _swapOnKyber3(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) internal {\r\n        _swapOnKyber(fromToken, destToken, amount, flags, KyberHelper.RESERVE_ID_3);\r\n    }\r\n\r\n    function _swapOnKyber4(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) internal {\r\n        _swapOnKyber(fromToken, destToken, amount, flags, KyberHelper.getReserveId(fromToken, destToken));\r\n    }\r\n\r\n    function _swapOnKyber(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags, bytes32 reserveId) internal {\r\n        bytes32[] memory reserveIds = new bytes32[](1);\r\n        reserveIds[0] = reserveId;\r\n\r\n        bytes memory hint;\r\n        if (fromToken.isETH()) {\r\n            hint = KyberHelper.HINT_HANDLER.buildEthToTokenHint(destToken, IKyberHintHandler.TradeType.MaskIn, reserveIds, new uint256[](0));\r\n        }\r\n        else {\r\n            hint = KyberHelper.HINT_HANDLER.buildTokenToEthHint(fromToken, IKyberHintHandler.TradeType.MaskIn, reserveIds, new uint256[](0));\r\n        }\r\n\r\n        fromToken.uniApprove(address(KyberHelper.PROXY), amount);\r\n        KyberHelper.PROXY.tradeWithHintAndFee{ value: fromToken.isETH() ? amount : 0 }(\r\n            fromToken,\r\n            amount,\r\n            destToken,\r\n            payable(address(this)),\r\n            uint256(-1),\r\n            0,\r\n            0x68a17B587CAF4f9329f0e372e3A78D23A46De6b5,\r\n            (flags >> 255) * 10,\r\n            hint\r\n        );\r\n    }\r\n\r\n    function _kyberGetHint(IERC20 fromToken, IERC20 destToken, bytes32 reserveId) private view returns(bytes memory) {\r\n        bytes32[] memory reserveIds = new bytes32[](1);\r\n        reserveIds[0] = reserveId;\r\n\r\n        if (fromToken.isETH()) {\r\n            try KyberHelper.HINT_HANDLER.buildEthToTokenHint(destToken, IKyberHintHandler.TradeType.MaskIn, reserveIds, new uint256[](0))\r\n            returns (bytes memory data) {\r\n                return data;\r\n            } catch {}\r\n        }\r\n\r\n        if (destToken.isETH()) {\r\n            try KyberHelper.HINT_HANDLER.buildTokenToEthHint(fromToken, IKyberHintHandler.TradeType.MaskIn, reserveIds, new uint256[](0))\r\n            returns (bytes memory data) {\r\n                return data;\r\n            } catch {}\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract KyberSourcePublic1 is ISource, KyberSourceView, KyberSourceSwap {\r\n    receive() external payable {\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\r\n    }\r\n\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateKyber1(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnKyber1(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n\r\ncontract KyberSourcePublic2 is ISource, KyberSourceView, KyberSourceSwap {\r\n    receive() external payable {\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\r\n    }\r\n\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateKyber2(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnKyber2(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n\r\ncontract KyberSourcePublic3 is ISource, KyberSourceView, KyberSourceSwap {\r\n    receive() external payable {\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\r\n    }\r\n\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateKyber3(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnKyber3(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n\r\ncontract KyberSourcePublic4 is ISource, KyberSourceView, KyberSourceSwap {\r\n    receive() external payable {\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\r\n    }\r\n\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateKyber4(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnKyber4(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ICurve.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ninterface ICurve {\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns(uint256 dy);\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns(uint256 dy);\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 minDy) external;\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 minDy) external;\r\n}\r\n\r\n\r\ninterface ICurveRegistry {\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function get_pool_info(address pool)\r\n        external\r\n        view\r\n        returns(\r\n            uint256[8] memory balances,\r\n            uint256[8] memory underlyingBalances,\r\n            uint256[8] memory decimals,\r\n            uint256[8] memory underlyingDecimals,\r\n            address lpToken,\r\n            uint256 a,\r\n            uint256 fee\r\n        );\r\n}\r\n\r\n\r\ninterface ICurveCalculator {\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function get_dy(\r\n        int128 nCoins,\r\n        uint256[8] calldata balances,\r\n        uint256 amp,\r\n        uint256 fee,\r\n        uint256[8] calldata rates,\r\n        uint256[8] calldata precisions,\r\n        bool underlying,\r\n        int128 i,\r\n        int128 j,\r\n        uint256[100] calldata dx\r\n    ) external view returns(uint256[100] memory dy);\r\n}\r\n\r\n// File: contracts/sources/CurveSource.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary CurveHelper {\r\n    ICurve constant public CURVE_COMPOUND = ICurve(0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56);\r\n    ICurve constant public CURVE_USDT = ICurve(0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C);\r\n    ICurve constant public CURVE_Y = ICurve(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);\r\n    ICurve constant public CURVE_BINANCE = ICurve(0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27);\r\n    ICurve constant public CURVE_SYNTHETIX = ICurve(0xA5407eAE9Ba41422680e2e00537571bcC53efBfD);\r\n    ICurve constant public CURVE_PAX = ICurve(0x06364f10B501e868329afBc005b3492902d6C763);\r\n    ICurve constant public CURVE_RENBTC = ICurve(0x93054188d876f558f4a66B2EF1d97d16eDf0895B);\r\n    ICurve constant public CURVE_SBTC = ICurve(0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714);\r\n\r\n    function dynarr(IERC20[2] memory tokens) internal pure returns(IERC20[] memory result) {\r\n        result = new IERC20[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            result[i] = tokens[i];\r\n        }\r\n    }\r\n\r\n    function dynarr(IERC20[3] memory tokens) internal pure returns(IERC20[] memory result) {\r\n        result = new IERC20[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            result[i] = tokens[i];\r\n        }\r\n    }\r\n\r\n    function dynarr(IERC20[4] memory tokens) internal pure returns(IERC20[] memory result) {\r\n        result = new IERC20[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            result[i] = tokens[i];\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract CurveSourceView is OneRouterConstants {\r\n    using SafeMath for uint256;\r\n    using UniERC20 for IERC20;\r\n    using FlagsChecker for uint256;\r\n\r\n    ICurveCalculator constant private _CURVE_CALCULATOR = ICurveCalculator(0xc1DB00a8E5Ef7bfa476395cdbcc98235477cDE4E);\r\n    ICurveRegistry constant private _CURVE_REGISTRY = ICurveRegistry(0x7002B727Ef8F5571Cb5F9D70D13DBEEb4dFAe9d1);\r\n\r\n    function _calculateCurveCompound(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_COMPOUND, true, CurveHelper.dynarr([_DAI, _USDC])), address(CurveHelper.CURVE_COMPOUND), 720_000);\r\n    }\r\n\r\n    function _calculateCurveUSDT(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_USDT, true, CurveHelper.dynarr([_DAI, _USDC, _USDT])), address(CurveHelper.CURVE_USDT), 720_000);\r\n    }\r\n\r\n    function _calculateCurveY(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_Y, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _TUSD])), address(CurveHelper.CURVE_Y), 1_400_000);\r\n    }\r\n\r\n    function _calculateCurveBinance(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_BINANCE, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _BUSD])), address(CurveHelper.CURVE_BINANCE), 1_400_000);\r\n    }\r\n\r\n    function _calculateCurveSynthetix(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_SYNTHETIX, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _SUSD])), address(CurveHelper.CURVE_SYNTHETIX), 200_000);\r\n    }\r\n\r\n    function _calculateCurvePAX(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_PAX, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _PAX])), address(CurveHelper.CURVE_PAX), 1_000_000);\r\n    }\r\n\r\n    function _calculateCurveRENBTC(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_RENBTC, false, CurveHelper.dynarr([_RENBTC, _WBTC])), address(CurveHelper.CURVE_RENBTC), 130_000);\r\n    }\r\n\r\n    function _calculateCurveSBTC(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_SBTC, false, CurveHelper.dynarr([_RENBTC, _WBTC, _SBTC])), address(CurveHelper.CURVE_SBTC), 150_000);\r\n    }\r\n\r\n    function _calculateCurveSelector(\r\n        IERC20 fromToken,\r\n        IOneRouterView.Swap memory swap,\r\n        uint256[] memory amounts,\r\n        ICurve curve,\r\n        bool haveUnderlying,\r\n        IERC20[] memory tokens\r\n    ) private view returns(uint256[] memory rets) {\r\n        rets = new uint256[](amounts.length);\r\n\r\n        for (uint t = 0; t < swap.disabledDexes.length; t++) {\r\n            if (swap.disabledDexes[t] == address(curve)) {\r\n                return rets;\r\n            }\r\n        }\r\n\r\n        int128 i = 0;\r\n        int128 j = 0;\r\n        for (uint t = 0; t < tokens.length; t++) {\r\n            if (fromToken == tokens[t]) {\r\n                i = int128(t + 1);\r\n            }\r\n            if (swap.destToken == tokens[t]) {\r\n                j = int128(t + 1);\r\n            }\r\n        }\r\n\r\n        if (i == 0 || j == 0) {\r\n            return rets;\r\n        }\r\n\r\n        bytes memory data = abi.encodePacked(\r\n            uint256(haveUnderlying ? 1 : 0),\r\n            uint256(i - 1),\r\n            uint256(j - 1),\r\n            _toFixedArray100(amounts)\r\n        );\r\n\r\n        (\r\n            uint256[8] memory balances,\r\n            uint256[8] memory precisions,\r\n            uint256[8] memory rates,\r\n            uint256 amp,\r\n            uint256 fee\r\n        ) = _getCurvePoolInfo(curve, haveUnderlying);\r\n\r\n        bool success;\r\n        (success, data) = address(_CURVE_CALCULATOR).staticcall(\r\n            abi.encodePacked(\r\n                abi.encodeWithSelector(\r\n                    _CURVE_CALCULATOR.get_dy.selector,\r\n                    tokens.length,\r\n                    balances,\r\n                    amp,\r\n                    fee,\r\n                    rates,\r\n                    precisions\r\n                ),\r\n                data\r\n            )\r\n        );\r\n\r\n        if (!success || data.length == 0) {\r\n            return rets;\r\n        }\r\n\r\n        uint256[100] memory dy = abi.decode(data, (uint256[100]));\r\n        for (uint t = 0; t < amounts.length; t++) {\r\n            rets[t] = dy[t];\r\n        }\r\n    }\r\n\r\n    function _getCurvePoolInfo(\r\n        ICurve curve,\r\n        bool haveUnderlying\r\n    ) private view returns(\r\n        uint256[8] memory balances,\r\n        uint256[8] memory precisions,\r\n        uint256[8] memory rates,\r\n        uint256 amp,\r\n        uint256 fee\r\n    ) {\r\n        uint256[8] memory underlyingBalances;\r\n        uint256[8] memory decimals;\r\n        uint256[8] memory underlyingDecimals;\r\n\r\n        (\r\n            balances,\r\n            underlyingBalances,\r\n            decimals,\r\n            underlyingDecimals,\r\n            /*address lpToken*/,\r\n            amp,\r\n            fee\r\n        ) = _CURVE_REGISTRY.get_pool_info(address(curve));\r\n\r\n        for (uint k = 0; k < 8 && balances[k] > 0; k++) {\r\n            precisions[k] = 10 ** (18 - (haveUnderlying ? underlyingDecimals : decimals)[k]);\r\n            if (haveUnderlying) {\r\n                rates[k] = underlyingBalances[k].mul(1e18).div(balances[k]);\r\n            } else {\r\n                rates[k] = 1e18;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _toFixedArray100(uint256[] memory values) private pure returns(uint256[100] memory rets) {\r\n        for (uint i = 0; i < values.length; i++) {\r\n            rets[i] = values[i];\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract CurveSourceSwap is OneRouterConstants {\r\n    using UniERC20 for IERC20;\r\n\r\n    function _swapOnCurveCompound(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\r\n        _swapOnCurve(CurveHelper.CURVE_COMPOUND, true, CurveHelper.dynarr([_DAI, _USDC]), fromToken, destToken, amount);\r\n    }\r\n\r\n    function _swapOnCurveUSDT(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\r\n        _swapOnCurve(CurveHelper.CURVE_USDT, true, CurveHelper.dynarr([_DAI, _USDC, _USDT]), fromToken, destToken, amount);\r\n    }\r\n\r\n    function _swapOnCurveY(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\r\n        _swapOnCurve(CurveHelper.CURVE_Y, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _TUSD]), fromToken, destToken, amount);\r\n    }\r\n\r\n    function _swapOnCurveBinance(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\r\n        _swapOnCurve(CurveHelper.CURVE_BINANCE, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _BUSD]), fromToken, destToken, amount);\r\n    }\r\n\r\n    function _swapOnCurveSynthetix(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\r\n        _swapOnCurve(CurveHelper.CURVE_SYNTHETIX, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _SUSD]), fromToken, destToken, amount);\r\n    }\r\n\r\n    function _swapOnCurvePAX(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\r\n        _swapOnCurve(CurveHelper.CURVE_PAX, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _PAX]), fromToken, destToken, amount);\r\n    }\r\n\r\n    function _swapOnCurveRENBTC(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\r\n        _swapOnCurve(CurveHelper.CURVE_RENBTC, false, CurveHelper.dynarr([_RENBTC, _WBTC]), fromToken, destToken, amount);\r\n    }\r\n\r\n    function _swapOnCurveSBTC(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\r\n        _swapOnCurve(CurveHelper.CURVE_SBTC, false, CurveHelper.dynarr([_RENBTC, _WBTC, _SBTC]), fromToken, destToken, amount);\r\n    }\r\n\r\n    function _swapOnCurve(\r\n        ICurve curve,\r\n        bool underlying,\r\n        IERC20[] memory tokens,\r\n        IERC20 fromToken,\r\n        IERC20 destToken,\r\n        uint256 amount\r\n    ) private {\r\n        int128 i = 0;\r\n        int128 j = 0;\r\n        for (uint t = 0; t < tokens.length; t++) {\r\n            if (fromToken == tokens[t]) {\r\n                i = int128(t + 1);\r\n            }\r\n            if (destToken == tokens[t]) {\r\n                j = int128(t + 1);\r\n            }\r\n        }\r\n\r\n        fromToken.uniApprove(address(curve), amount);\r\n        if (underlying) {\r\n            curve.exchange_underlying(i - 1, j - 1, amount, 0);\r\n        } else {\r\n            curve.exchange(i - 1, j - 1, amount, 0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract CurveSourcePublicCompound is ISource, CurveSourceView, CurveSourceSwap {\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateCurveCompound(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnCurveCompound(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n\r\ncontract CurveSourcePublicUSDT is ISource, CurveSourceView, CurveSourceSwap {\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateCurveUSDT(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnCurveUSDT(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n\r\ncontract CurveSourcePublicY is ISource, CurveSourceView, CurveSourceSwap {\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateCurveY(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnCurveY(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n\r\ncontract CurveSourcePublicBinance is ISource, CurveSourceView, CurveSourceSwap {\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateCurveBinance(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnCurveBinance(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n\r\ncontract CurveSourcePublicSynthetix is ISource, CurveSourceView, CurveSourceSwap {\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateCurveSynthetix(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnCurveSynthetix(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n\r\ncontract CurveSourcePublicPAX is ISource, CurveSourceView, CurveSourceSwap {\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateCurvePAX(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnCurvePAX(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n\r\ncontract CurveSourcePublicRENBTC is ISource, CurveSourceView, CurveSourceSwap {\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateCurveRENBTC(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnCurveRENBTC(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n\r\ncontract CurveSourcePublicSBTC is ISource, CurveSourceView, CurveSourceSwap {\r\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\r\n        return _calculateCurveSBTC(fromToken, amounts, swap);\r\n    }\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\r\n        return _swapOnCurveSBTC(fromToken, destToken, amount, flags);\r\n    }\r\n}\r\n\r\n// File: contracts/OneRouter.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import \"./sources/BalancerSource.sol\";\r\n\r\n\r\ncontract PathsAdvisor is OneRouterConstants {\r\n    using UniERC20 for IERC20;\r\n\r\n    IAaveRegistry constant private _AAVE_REGISTRY = IAaveRegistry(0xEd8b133B7B88366E01Bb9E38305Ab11c26521494);\r\n    ICompoundRegistry constant private _COMPOUND_REGISTRY = ICompoundRegistry(0xF451Dbd7Ba14BFa7B1B78A766D3Ed438F79EE1D1);\r\n\r\n    function getPathsForTokens(IERC20 fromToken, IERC20 destToken) external view returns(IERC20[][] memory paths) {\r\n        IERC20[4] memory midTokens = [_DAI, _USDC, _USDT, _WBTC];\r\n        paths = new IERC20[][](2 + midTokens.length);\r\n\r\n        IERC20 aFromToken = _AAVE_REGISTRY.aTokenByToken(fromToken);\r\n        IERC20 aDestToken = _AAVE_REGISTRY.aTokenByToken(destToken);\r\n        if (aFromToken != IERC20(0)) {\r\n            aFromToken = _COMPOUND_REGISTRY.cTokenByToken(fromToken);\r\n        }\r\n        if (aDestToken != IERC20(0)) {\r\n            aDestToken = _COMPOUND_REGISTRY.cTokenByToken(destToken);\r\n        }\r\n\r\n        uint index = 0;\r\n        paths[index] = new IERC20[](0);\r\n        index++;\r\n\r\n        if (!fromToken.isETH() && !aFromToken.isETH() && !destToken.isETH() && !aDestToken.isETH()) {\r\n            paths[index] = new IERC20[](1);\r\n            paths[index][0] = UniERC20.ETH_ADDRESS;\r\n            index++;\r\n        }\r\n\r\n        for (uint i = 0; i < midTokens.length; i++) {\r\n            if (fromToken != midTokens[i] && aFromToken != midTokens[i] && destToken != midTokens[i] && aDestToken != midTokens[i]) {\r\n                paths[index] = new IERC20[](\r\n                    1 +\r\n                    ((aFromToken != IERC20(0)) ? 1 : 0) +\r\n                    ((aDestToken != IERC20(0)) ? 1 : 0)\r\n                );\r\n\r\n                paths[index][0] = aFromToken;\r\n                paths[index][paths[index].length / 2] = midTokens[i];\r\n                if (aDestToken != IERC20(0)) {\r\n                    paths[index][paths[index].length - 1] = aDestToken;\r\n                }\r\n                index++;\r\n            }\r\n        }\r\n\r\n        IERC20[][] memory paths2 = new IERC20[][](index);\r\n        for (uint i = 0; i < paths2.length; i++) {\r\n            paths2[i] = paths[i];\r\n        }\r\n        paths = paths2;\r\n    }\r\n}\r\n\r\n\r\ncontract HotSwapSources is Ownable {\r\n    uint256 public sourcesCount = 15;\r\n    mapping(uint256 => ISource) public sources;\r\n    PathsAdvisor public pathsAdvisor;\r\n\r\n    constructor() public {\r\n        pathsAdvisor = new PathsAdvisor();\r\n    }\r\n\r\n    function setSource(uint256 index, ISource source) external onlyOwner {\r\n        require(index <= sourcesCount, \"Router: index is too high\");\r\n        sources[index] = source;\r\n        sourcesCount = Math.max(sourcesCount, index + 1);\r\n    }\r\n\r\n    function setPathsForTokens(PathsAdvisor newPathsAdvisor) external onlyOwner {\r\n        pathsAdvisor = newPathsAdvisor;\r\n    }\r\n\r\n    function _getPathsForTokens(IERC20 fromToken, IERC20 destToken) internal view returns(IERC20[][] memory paths) {\r\n        return pathsAdvisor.getPathsForTokens(fromToken, destToken);\r\n    }\r\n}\r\n\r\n\r\ncontract OneRouterView is\r\n    OneRouterConstants,\r\n    IOneRouterView,\r\n    HotSwapSources,\r\n    UniswapV1SourceView,\r\n    UniswapV2SourceView,\r\n    MooniswapSourceView,\r\n    KyberSourceView,\r\n    CurveSourceView\r\n    // BalancerSourceView\r\n{\r\n    using UniERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using FlagsChecker for uint256;\r\n    using DynamicMemoryArray for DynamicMemoryArray.Addresses;\r\n\r\n    function getReturn(IERC20 fromToken, uint256[] memory amounts, Swap memory swap)\r\n        public\r\n        view\r\n        override\r\n        returns(\r\n            Path[] memory paths,\r\n            PathResult[] memory pathResults,\r\n            SwapResult memory splitResult\r\n        )\r\n    {\r\n        IERC20[][] memory midTokens = _getPathsForTokens(fromToken, swap.destToken);\r\n\r\n        paths = new Path[](midTokens.length);\r\n        pathResults = new PathResult[](paths.length);\r\n        DynamicMemoryArray.Addresses memory disabledDexes;\r\n        for (uint i = 0; i < paths.length; i++) {\r\n            paths[i] = Path({swaps: new Swap[](1 + midTokens[i - 1].length)});\r\n            for (uint j = 0; j < midTokens[i - 1].length; j++) {\r\n                if (fromToken == midTokens[i - 1][j] || swap.destToken == midTokens[i - 1][j]) {\r\n                    paths[i] = Path({swaps: new Swap[](1)});\r\n                    break;\r\n                }\r\n\r\n                paths[i].swaps[j] = Swap({\r\n                    destToken: midTokens[i - 1][j],\r\n                    flags: swap.flags,\r\n                    destTokenEthPriceTimesGasPrice: _scaleDestTokenEthPriceTimesGasPrice(fromToken, midTokens[i - 1][j], swap.destTokenEthPriceTimesGasPrice),\r\n                    disabledDexes: disabledDexes.copy()\r\n                });\r\n            }\r\n            paths[i].swaps[paths[i].swaps.length - 1] = swap;\r\n\r\n            pathResults[i] = getPathReturn(fromToken, amounts, paths[i]);\r\n            for (uint j = 0; j < pathResults[i].swaps.length; j++) {\r\n                for (uint k = 0; k < pathResults[i].swaps[j].dexes.length; k++) {\r\n                    for (uint t = 0; t < pathResults[i].swaps[j].dexes[k].length; t++) {\r\n                        if (pathResults[i].swaps[j].dexes[k][t] != address(0)) {\r\n                            disabledDexes.push(pathResults[i].swaps[j].dexes[k][t]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        splitResult = bestDistributionAmongPaths(paths, pathResults);\r\n    }\r\n\r\n    function getMultiPathReturn(IERC20 fromToken, uint256[] memory amounts, Path[] memory paths)\r\n        public\r\n        view\r\n        override\r\n        returns(\r\n            PathResult[] memory pathResults,\r\n            SwapResult memory splitResult\r\n        )\r\n    {\r\n        pathResults = new PathResult[](paths.length);\r\n        for (uint i = 0; i < paths.length; i++) {\r\n            pathResults[i] = getPathReturn(fromToken, amounts, paths[i]);\r\n        }\r\n        splitResult = bestDistributionAmongPaths(paths, pathResults);\r\n    }\r\n\r\n    function bestDistributionAmongPaths(Path[] memory paths, PathResult[] memory pathResults) public pure returns(SwapResult memory) {\r\n        uint256[][] memory input = new uint256[][](paths.length);\r\n        uint256[][] memory gases = new uint256[][](paths.length);\r\n        uint256[][] memory costs = new uint256[][](paths.length);\r\n        for (uint i = 0; i < pathResults.length; i++) {\r\n            Swap memory subSwap = paths[i].swaps[paths[i].swaps.length - 1];\r\n            SwapResult memory swapResult = pathResults[i].swaps[pathResults[i].swaps.length - 1];\r\n\r\n            input[i] = new uint256[](swapResult.returnAmounts.length);\r\n            gases[i] = new uint256[](swapResult.returnAmounts.length);\r\n            costs[i] = new uint256[](swapResult.returnAmounts.length);\r\n            for (uint j = 0; j < swapResult.returnAmounts.length; j++) {\r\n                input[i][j] = swapResult.returnAmounts[j];\r\n                gases[i][j] = swapResult.estimateGasAmounts[j];\r\n                costs[i][j] = swapResult.estimateGasAmounts[j].mul(subSwap.destTokenEthPriceTimesGasPrice).div(1e18);\r\n            }\r\n        }\r\n        return _findBestDistribution(input, costs, gases, input[0].length);\r\n    }\r\n\r\n    function getPathReturn(IERC20 fromToken, uint256[] memory amounts, Path memory path)\r\n        public\r\n        view\r\n        override\r\n        returns(PathResult memory result)\r\n    {\r\n        result.swaps = new SwapResult[](path.swaps.length);\r\n\r\n        for (uint i = 0; i < path.swaps.length; i++) {\r\n            result.swaps[i] = getSwapReturn(fromToken, amounts, path.swaps[i]);\r\n            fromToken = path.swaps[i].destToken;\r\n            amounts = result.swaps[i].returnAmounts;\r\n        }\r\n    }\r\n\r\n    function getSwapReturn(IERC20 fromToken, uint256[] memory amounts, Swap memory swap)\r\n        public\r\n        view\r\n        override\r\n        returns(SwapResult memory result)\r\n    {\r\n        if (fromToken == swap.destToken) {\r\n            result.returnAmounts = amounts;\r\n            return result;\r\n        }\r\n\r\n        function(IERC20,uint256[] memory,Swap memory) view returns(uint256[] memory, address, uint256)[15] memory reserves = [\r\n            _calculateUniswapV1,\r\n            _calculateUniswapV2,\r\n            _calculateMooniswap,\r\n            _calculateKyber1,\r\n            _calculateKyber2,\r\n            _calculateKyber3,\r\n            _calculateKyber4,\r\n            _calculateCurveCompound,\r\n            _calculateCurveUSDT,\r\n            _calculateCurveY,\r\n            _calculateCurveBinance,\r\n            _calculateCurveSynthetix,\r\n            _calculateCurvePAX,\r\n            _calculateCurveRENBTC,\r\n            _calculateCurveSBTC\r\n            // _calculateBalancer1,\r\n            // _calculateBalancer2,\r\n            // _calculateBalancer3,\r\n            // calculateBancor,\r\n            // calculateOasis,\r\n            // calculateDforceSwap,\r\n            // calculateShell,\r\n            // calculateMStableMUSD,\r\n            // calculateBlackHoleSwap\r\n        ];\r\n\r\n        uint256[][] memory input = new uint256[][](sourcesCount);\r\n        uint256[][] memory gases = new uint256[][](sourcesCount);\r\n        uint256[][] memory costs = new uint256[][](sourcesCount);\r\n        bool disableAll = swap.flags.check(_FLAG_DISABLE_ALL_SOURCES);\r\n        for (uint i = 0; i < sourcesCount; i++) {\r\n            uint256 gas;\r\n            if (disableAll == swap.flags.check(1 << i)) {\r\n                if (sources[i] != ISource(0)) {\r\n                    (input[i], , gas) = sources[i].calculate(fromToken, amounts, swap);\r\n                }\r\n                else if (i < reserves.length) {\r\n                    (input[i], , gas) = reserves[i](fromToken, amounts, swap);\r\n                }\r\n            }\r\n\r\n            gases[i] = new uint256[](amounts.length);\r\n            costs[i] = new uint256[](amounts.length);\r\n            uint256 fee = gas.mul(swap.destTokenEthPriceTimesGasPrice).div(1e18);\r\n            for (uint j = 0; j < amounts.length; j++) {\r\n                gases[i][j] = gas;\r\n                costs[i][j] = fee;\r\n            }\r\n        }\r\n\r\n        result = _findBestDistribution(input, costs, gases, amounts.length);\r\n    }\r\n\r\n    function _calculateNoReturn(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap)\r\n        private view returns(uint256[] memory rets, uint256 gas)\r\n    {\r\n    }\r\n\r\n    function _scaleDestTokenEthPriceTimesGasPrice(IERC20 fromToken, IERC20 destToken, uint256 destTokenEthPriceTimesGasPrice) private view returns(uint256) {\r\n        if (fromToken == destToken) {\r\n            return destTokenEthPriceTimesGasPrice;\r\n        }\r\n\r\n        uint256 mul = _cheapGetPrice(UniERC20.ETH_ADDRESS, destToken, 0.001 ether);\r\n        uint256 div = _cheapGetPrice(UniERC20.ETH_ADDRESS, fromToken, 0.001 ether);\r\n        return (div == 0) ? 0 : destTokenEthPriceTimesGasPrice.mul(mul).div(div);\r\n    }\r\n\r\n    function _cheapGetPrice(IERC20 fromToken, IERC20 destToken, uint256 amount) private view returns(uint256 returnAmount) {\r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = amount;\r\n\r\n        uint256 flags = _FLAG_DISABLE_RECALCULATION |\r\n            _FLAG_DISABLE_ALL_SOURCES |\r\n            _FLAG_DISABLE_UNISWAP_V1 |\r\n            _FLAG_DISABLE_UNISWAP_V2;\r\n\r\n        return this.getSwapReturn(\r\n            fromToken,\r\n            amounts,\r\n            Swap({\r\n                destToken: destToken,\r\n                flags: flags,\r\n                destTokenEthPriceTimesGasPrice: 0,\r\n                disabledDexes: new address[](0)\r\n            })\r\n        ).returnAmounts[0];\r\n    }\r\n\r\n    function _findBestDistribution(uint256[][] memory input, uint256[][] memory costs, uint256[][] memory gases, uint256 parts)\r\n        private pure returns(SwapResult memory result)\r\n    {\r\n        int256[][] memory matrix = new int256[][](input.length);\r\n        for (uint i = 0; i < input.length; i++) {\r\n            matrix[i] = new int256[](1 + parts);\r\n            matrix[i][0] = Algo.VERY_NEGATIVE_VALUE;\r\n            for (uint j = 0; j < parts; j++) {\r\n                matrix[i][j + 1] =\r\n                    (j < input[i].length && input[i][j] != 0)\r\n                    ? int256(input[i][j]) - int256(costs[i][j])\r\n                    : Algo.VERY_NEGATIVE_VALUE;\r\n            }\r\n        }\r\n\r\n        (, result.distributions) = Algo.findBestDistribution(matrix, parts);\r\n\r\n        result.returnAmounts = new uint256[](parts);\r\n        result.estimateGasAmounts = new uint256[](parts);\r\n        for (uint i = 0; i < input.length; i++) {\r\n            for (uint j = 0; j < parts; j++) {\r\n                if (result.distributions[j][i] > 0) {\r\n                    uint256 index = result.distributions[j][i] - 1;\r\n                    result.returnAmounts[j] = result.returnAmounts[j].add(index < input[i].length ? input[i][index] : 0);\r\n                    result.estimateGasAmounts[j] = result.estimateGasAmounts[j].add(gases[i][j]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract OneRouter is\r\n    OneRouterConstants,\r\n    IOneRouter,\r\n    HotSwapSources,\r\n    UniswapV1SourceSwap,\r\n    UniswapV2SourceSwap,\r\n    MooniswapSourceSwap,\r\n    KyberSourceSwap,\r\n    CurveSourceSwap\r\n    // BalancerSourceSwap\r\n{\r\n    using UniERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using Address2 for address;\r\n    using FlagsChecker for uint256;\r\n\r\n    IOneRouterView public oneRouterView;\r\n\r\n    constructor(IOneRouterView _oneRouterView) public {\r\n        oneRouterView = _oneRouterView;\r\n    }\r\n\r\n    receive() external payable {\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\r\n    }\r\n\r\n    function getReturn(\r\n        IERC20 fromToken,\r\n        uint256[] calldata amounts,\r\n        Swap calldata swap\r\n    )\r\n        external\r\n        view\r\n        override\r\n        returns(\r\n            Path[] memory paths,\r\n            PathResult[] memory pathResults,\r\n            SwapResult memory splitResult\r\n        )\r\n    {\r\n        return oneRouterView.getReturn(fromToken, amounts, swap);\r\n    }\r\n\r\n    function getSwapReturn(\r\n        IERC20 fromToken,\r\n        uint256[] calldata amounts,\r\n        Swap calldata swap\r\n    )\r\n        external\r\n        view\r\n        override\r\n        returns(SwapResult memory result)\r\n    {\r\n        return oneRouterView.getSwapReturn(fromToken, amounts, swap);\r\n    }\r\n\r\n    function getPathReturn(\r\n        IERC20 fromToken,\r\n        uint256[] calldata amounts,\r\n        Path calldata path\r\n    )\r\n        external\r\n        view\r\n        override\r\n        returns(PathResult memory result)\r\n    {\r\n        return oneRouterView.getPathReturn(fromToken, amounts, path);\r\n    }\r\n\r\n    function getMultiPathReturn(\r\n        IERC20 fromToken,\r\n        uint256[] calldata amounts,\r\n        Path[] calldata paths\r\n    )\r\n        external\r\n        view\r\n        override\r\n        returns(\r\n            PathResult[] memory pathResults,\r\n            SwapResult memory splitResult\r\n        )\r\n    {\r\n        return oneRouterView.getMultiPathReturn(fromToken, amounts, paths);\r\n    }\r\n\r\n    function makeSwap(\r\n        SwapInput memory input,\r\n        Swap memory swap,\r\n        SwapDistribution memory swapDistribution\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        returns(uint256 returnAmount)\r\n    {\r\n        Path memory path = Path({\r\n            swaps: new IOneRouterView.Swap[](1)\r\n        });\r\n        path.swaps[0] = swap;\r\n\r\n        PathDistribution memory pathDistribution = PathDistribution({\r\n            swapDistributions: new SwapDistribution[](1)\r\n        });\r\n        pathDistribution.swapDistributions[0] = swapDistribution;\r\n\r\n        return makePathSwap(input, path, pathDistribution);\r\n    }\r\n\r\n    function makePathSwap(\r\n        SwapInput memory input,\r\n        Path memory path,\r\n        PathDistribution memory pathDistribution\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        returns(uint256 returnAmount)\r\n    {\r\n        Path[] memory paths = new Path[](1);\r\n        paths[0] = path;\r\n\r\n        PathDistribution[] memory pathDistributions = new PathDistribution[](1);\r\n        pathDistributions[0] = pathDistribution;\r\n\r\n        SwapDistribution memory swapDistribution = SwapDistribution({\r\n            weights: new uint256[](1)\r\n        });\r\n        swapDistribution.weights[0] = 1;\r\n\r\n        return makeMultiPathSwap(input, paths, pathDistributions, swapDistribution);\r\n    }\r\n\r\n    struct Indexes {\r\n        uint p; // path\r\n        uint s; // swap\r\n        uint i; // index\r\n    }\r\n\r\n    function makeMultiPathSwap(\r\n        SwapInput memory input,\r\n        Path[] memory paths,\r\n        PathDistribution[] memory pathDistributions,\r\n        SwapDistribution memory interPathsDistribution\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        returns(uint256 returnAmount)\r\n    {\r\n        require(msg.value == (input.fromToken.isETH() ? input.amount : 0), \"Wrong msg.value\");\r\n        require(paths.length == pathDistributions.length, \"Wrong arrays length\");\r\n        require(paths.length == interPathsDistribution.weights.length, \"Wrong arrays length\");\r\n\r\n        input.fromToken.uniTransferFromSender(address(this), input.amount);\r\n\r\n        function(IERC20,IERC20,uint256,uint256)[15] memory reserves = [\r\n            _swapOnUniswapV1,\r\n            _swapOnUniswapV2,\r\n            _swapOnMooniswap,\r\n            _swapOnKyber1,\r\n            _swapOnKyber2,\r\n            _swapOnKyber3,\r\n            _swapOnKyber4,\r\n            _swapOnCurveCompound,\r\n            _swapOnCurveUSDT,\r\n            _swapOnCurveY,\r\n            _swapOnCurveBinance,\r\n            _swapOnCurveSynthetix,\r\n            _swapOnCurvePAX,\r\n            _swapOnCurveRENBTC,\r\n            _swapOnCurveSBTC\r\n            // _swapOnBalancer1,\r\n            // _swapOnBalancer2,\r\n            // _swapOnBalancer3,\r\n            // _swapOnBancor,\r\n            // _swapOnOasis,\r\n            // _swapOnDforceSwap,\r\n            // _swapOnShell,\r\n            // _swapOnMStableMUSD,\r\n            // _swapOnBlackHoleSwap\r\n        ];\r\n\r\n        uint256 interTotalWeight = 0;\r\n        for (uint i = 0; i < interPathsDistribution.weights.length; i++) {\r\n            interTotalWeight = interTotalWeight.add(interPathsDistribution.weights[i]);\r\n        }\r\n\r\n        Indexes memory z;\r\n        for (z.p = 0; z.p < pathDistributions.length && interTotalWeight > 0; z.p++) {\r\n            uint256 confirmed = input.fromToken.uniBalanceOf(address(this))\r\n                    .mul(interPathsDistribution.weights[z.p])\r\n                    .div(interTotalWeight);\r\n            interTotalWeight = interTotalWeight.sub(interPathsDistribution.weights[z.p]);\r\n\r\n            IERC20 token = input.fromToken;\r\n            for (z.s = 0; z.s < pathDistributions[z.p].swapDistributions.length; z.s++) {\r\n                uint256 totalSwapWeight = 0;\r\n                for (z.i = 0; z.i < pathDistributions[z.p].swapDistributions[z.s].weights.length; z.i++) {\r\n                    totalSwapWeight = totalSwapWeight.add(pathDistributions[z.p].swapDistributions[z.s].weights[z.i]);\r\n                }\r\n\r\n                for (z.i = 0; z.i < pathDistributions[z.p].swapDistributions[z.s].weights.length && totalSwapWeight > 0; z.i++) {\r\n                    uint256 amount = ((z.s == 0) ? confirmed : token.uniBalanceOf(address(this)))\r\n                        .mul(pathDistributions[z.p].swapDistributions[z.s].weights[z.i])\r\n                        .div(totalSwapWeight);\r\n                    totalSwapWeight = totalSwapWeight.sub(pathDistributions[z.p].swapDistributions[z.s].weights[z.i]);\r\n\r\n                    if (sources[z.i] != ISource(0)) {\r\n                        address(sources[z.i]).functionDelegateCall(\r\n                            abi.encodeWithSelector(\r\n                                sources[z.i].swap.selector,\r\n                                input.fromToken,\r\n                                input.destToken,\r\n                                amount,\r\n                                paths[z.p].swaps[z.s].flags\r\n                            ),\r\n                            \"Delegatecall failed\"\r\n                        );\r\n                    }\r\n                    else if (z.i < reserves.length) {\r\n                        reserves[z.i](input.fromToken, input.destToken, amount, paths[z.p].swaps[z.s].flags);\r\n                    }\r\n                }\r\n\r\n                token = paths[z.p].swaps[z.s].destToken;\r\n            }\r\n        }\r\n\r\n        uint256 remaining = input.fromToken.uniBalanceOf(address(this));\r\n        returnAmount = input.destToken.uniBalanceOf(address(this));\r\n        require(returnAmount >= input.minReturn, \"Min returns is not enough\");\r\n        input.fromToken.uniTransfer(msg.sender, remaining);\r\n        input.destToken.uniTransfer(msg.sender, returnAmount);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IOneRouterView\",\"name\":\"_oneRouterView\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"components\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destTokenEthPriceTimesGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"disabledDexes\",\"type\":\"address[]\"}],\"internalType\":\"struct IOneRouterView.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IOneRouterView.Path[]\",\"name\":\"paths\",\"type\":\"tuple[]\"}],\"name\":\"getMultiPathReturn\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"returnAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"estimateGasAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"distributions\",\"type\":\"uint256[][]\"},{\"internalType\":\"address[][]\",\"name\":\"dexes\",\"type\":\"address[][]\"}],\"internalType\":\"struct IOneRouterView.SwapResult[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IOneRouterView.PathResult[]\",\"name\":\"pathResults\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"returnAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"estimateGasAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"distributions\",\"type\":\"uint256[][]\"},{\"internalType\":\"address[][]\",\"name\":\"dexes\",\"type\":\"address[][]\"}],\"internalType\":\"struct IOneRouterView.SwapResult\",\"name\":\"splitResult\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"components\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destTokenEthPriceTimesGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"disabledDexes\",\"type\":\"address[]\"}],\"internalType\":\"struct IOneRouterView.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IOneRouterView.Path\",\"name\":\"path\",\"type\":\"tuple\"}],\"name\":\"getPathReturn\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"returnAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"estimateGasAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"distributions\",\"type\":\"uint256[][]\"},{\"internalType\":\"address[][]\",\"name\":\"dexes\",\"type\":\"address[][]\"}],\"internalType\":\"struct IOneRouterView.SwapResult[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IOneRouterView.PathResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destTokenEthPriceTimesGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"disabledDexes\",\"type\":\"address[]\"}],\"internalType\":\"struct IOneRouterView.Swap\",\"name\":\"swap\",\"type\":\"tuple\"}],\"name\":\"getReturn\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destTokenEthPriceTimesGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"disabledDexes\",\"type\":\"address[]\"}],\"internalType\":\"struct IOneRouterView.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IOneRouterView.Path[]\",\"name\":\"paths\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"returnAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"estimateGasAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"distributions\",\"type\":\"uint256[][]\"},{\"internalType\":\"address[][]\",\"name\":\"dexes\",\"type\":\"address[][]\"}],\"internalType\":\"struct IOneRouterView.SwapResult[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IOneRouterView.PathResult[]\",\"name\":\"pathResults\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"returnAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"estimateGasAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"distributions\",\"type\":\"uint256[][]\"},{\"internalType\":\"address[][]\",\"name\":\"dexes\",\"type\":\"address[][]\"}],\"internalType\":\"struct IOneRouterView.SwapResult\",\"name\":\"splitResult\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destTokenEthPriceTimesGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"disabledDexes\",\"type\":\"address[]\"}],\"internalType\":\"struct IOneRouterView.Swap\",\"name\":\"swap\",\"type\":\"tuple\"}],\"name\":\"getSwapReturn\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"returnAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"estimateGasAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"distributions\",\"type\":\"uint256[][]\"},{\"internalType\":\"address[][]\",\"name\":\"dexes\",\"type\":\"address[][]\"}],\"internalType\":\"struct IOneRouterView.SwapResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct IOneRouter.Referral\",\"name\":\"referral\",\"type\":\"tuple\"}],\"internalType\":\"struct IOneRouter.SwapInput\",\"name\":\"input\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destTokenEthPriceTimesGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"disabledDexes\",\"type\":\"address[]\"}],\"internalType\":\"struct IOneRouterView.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IOneRouterView.Path[]\",\"name\":\"paths\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IOneRouter.SwapDistribution[]\",\"name\":\"swapDistributions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IOneRouter.PathDistribution[]\",\"name\":\"pathDistributions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IOneRouter.SwapDistribution\",\"name\":\"interPathsDistribution\",\"type\":\"tuple\"}],\"name\":\"makeMultiPathSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct IOneRouter.Referral\",\"name\":\"referral\",\"type\":\"tuple\"}],\"internalType\":\"struct IOneRouter.SwapInput\",\"name\":\"input\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destTokenEthPriceTimesGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"disabledDexes\",\"type\":\"address[]\"}],\"internalType\":\"struct IOneRouterView.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IOneRouterView.Path\",\"name\":\"path\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IOneRouter.SwapDistribution[]\",\"name\":\"swapDistributions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IOneRouter.PathDistribution\",\"name\":\"pathDistribution\",\"type\":\"tuple\"}],\"name\":\"makePathSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct IOneRouter.Referral\",\"name\":\"referral\",\"type\":\"tuple\"}],\"internalType\":\"struct IOneRouter.SwapInput\",\"name\":\"input\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destTokenEthPriceTimesGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"disabledDexes\",\"type\":\"address[]\"}],\"internalType\":\"struct IOneRouterView.Swap\",\"name\":\"swap\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IOneRouter.SwapDistribution\",\"name\":\"swapDistribution\",\"type\":\"tuple\"}],\"name\":\"makeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneRouterView\",\"outputs\":[{\"internalType\":\"contract IOneRouterView\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pathsAdvisor\",\"outputs\":[{\"internalType\":\"contract PathsAdvisor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PathsAdvisor\",\"name\":\"newPathsAdvisor\",\"type\":\"address\"}],\"name\":\"setPathsForTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"contract ISource\",\"name\":\"source\",\"type\":\"address\"}],\"name\":\"setSource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sources\",\"outputs\":[{\"internalType\":\"contract ISource\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sourcesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"OneRouter","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000548a6610378e80A0cFEE1f1738b9E70176366C64","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8a10215dd7b1f1b39af92bc3ff0c7bb96101cccc44bee36895536a9ccb43ca1e"}]}