{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/madmax/projects/imty-token/contracts/Helpers.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.10;\\n\\ncontract OnlyDeployer {\\n    address deployer;\\n\\n    constructor () public {\\n        deployer = msg.sender;\\n    }\\n\\n    modifier onlyDeployer () {\\n        require(msg.sender == deployer, \\\"Method is preserved for the deployer\\\");\\n        _;\\n    }\\n}\\n\\ncontract OnlyOnce {\\n    mapping (string => bool) onlyOnceData;\\n\\n    modifier onlyOnce (string memory id) {\\n        require(!onlyOnceData[id], \\\"Can only be executed once\\\");\\n        _;\\n        onlyOnceData[id] = true;\\n    }\\n}\"\r\n    },\r\n    \"/home/madmax/projects/imty-token/contracts/MultiSigWallet.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\r\\nimport \\\"./Wallet.sol\\\";\\r\\nimport \\\"./Helpers.sol\\\";\\r\\n\\r\\ncontract SetOperator is Wallet, ReentrancyGuard {\\r\\n    address signerOne;\\r\\n    address signerTwo;\\r\\n\\r\\n    address operator;\\r\\n\\r\\n    event NewOperatorVote ();\\r\\n    event AuthorizedOperator (address operator);\\r\\n    event RevokedOperator (address operator);\\r\\n\\r\\n    address[] public operators;\\r\\n\\r\\n    bool public operatorVoteOne;\\r\\n    bool public operatorVoteTwo;\\r\\n    address public operatorVoteAddress;\\r\\n\\r\\n    bool firstOperator = false;\\r\\n\\r\\n   constructor (address _signerOne, address _signerTwo, address _tokenContract) public {\\r\\n        signerOne = _signerOne;\\r\\n        signerTwo = _signerTwo;\\r\\n        tokenContract = IERC777(_tokenContract);\\r\\n    }\\r\\n\\r\\n    function getOperators () external view returns (address[] memory) {\\r\\n        return operators;\\r\\n    } //TODO: Check if works\\r\\n\\r\\n    function setDefaultOperators(address[] memory _defaultOperators) external onlyOnce(\\\"assignFirstOperator\\\") onlyDeployer {\\r\\n        require(firstOperator == false, \\\"Can only be ran once!\\\");\\r\\n\\r\\n        for (uint i = 0; i < _defaultOperators.length; i++) {\\r\\n            _authorizeOperator(_defaultOperators[i]);\\r\\n            emit AuthorizedOperator(_defaultOperators[i]);\\r\\n        }\\r\\n\\r\\n        firstOperator = true;\\r\\n    }\\r\\n\\r\\n    function revokeOperator (address _operator) isSigner external returns (address[] memory){\\r\\n        uint i = 0;\\r\\n        for (;i < operators.length; i++) {\\r\\n            if (_operator == operators[i]) {\\r\\n                break;\\r\\n            }\\r\\n            if (i == operators.length - 1) {\\r\\n                revert(\\\"Address is not an operator\\\");\\r\\n            }\\r\\n        }\\r\\n        tokenContract.revokeOperator(_operator);\\r\\n        _removeOperator(i);\\r\\n        emit RevokedOperator(_operator);\\r\\n\\r\\n        return operators;\\r\\n    }\\r\\n\\r\\n    function _removeOperator (uint index) private {\\r\\n        if (index >= operators.length) {\\r\\n             require(false, \\\"index out of bounds\\\");\\r\\n        }\\r\\n\\r\\n        for (uint i = index; i < operators.length-1; i++){\\r\\n            operators[i] = operators[i+1];\\r\\n        }\\r\\n        operators.pop();\\r\\n    }\\r\\n\\r\\n    //TODO: revoke operator\\r\\n    function _authorizeOperator (address _operator) private {\\r\\n        tokenContract.authorizeOperator(_operator);\\r\\n        operators.push(_operator);\\r\\n\\r\\n        emit AuthorizedOperator(_operator);\\r\\n    }\\r\\n\\r\\n    function createOperatorVote (address _operator) external isSigner {\\r\\n        operatorVoteAddress = _operator;\\r\\n        operatorVoteOne = msg.sender == signerOne;\\r\\n        operatorVoteTwo = msg.sender == signerTwo;\\r\\n\\r\\n        emit NewOperatorVote();\\r\\n    }\\r\\n\\r\\n    function approveOperatorVote () external nonReentrant isSigner {\\r\\n        if (msg.sender == signerOne) {\\r\\n            operatorVoteOne = true;\\r\\n        }\\r\\n        if (msg.sender == signerTwo) {\\r\\n            operatorVoteTwo = true;\\r\\n        }\\r\\n\\r\\n        if (operatorVoteOne == operatorVoteTwo) {\\r\\n            _authorizeOperator(operatorVoteAddress);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier isSigner () {\\r\\n        require(msg.sender == signerOne || msg.sender == signerTwo, \\\"Not allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n} \\r\\n\\r\\ncontract MultiSigWallet is SetOperator {\\r\\n    uint public currentPaymentId = 0;\\r\\n\\r\\n    event UpdatedPayment (uint paymentId);\\r\\n\\r\\n    enum TxType { Eth, Imty }\\r\\n    enum TxStatus { Pending, Completed }\\r\\n\\r\\n    struct Payment {\\r\\n        TxType txType;\\r\\n        TxStatus txStatus;\\r\\n        address payable to;\\r\\n        uint amount;\\r\\n        bool approvalOne;\\r\\n        bool approvalTwo;\\r\\n        uint creationTime;\\r\\n        uint completionTime;\\r\\n    }\\r\\n\\r\\n    mapping (uint => Payment) payments;\\r\\n\\r\\n    constructor (address _signerOne, address _signerTwo, address _tokenContract)\\r\\n                ReentrancyGuard()\\r\\n                SetOperator(_signerOne, _signerTwo, _tokenContract)\\r\\n                public {}\\r\\n\\r\\n    function createPayment (address _to, uint amount, TxType txType) external nonReentrant isSigner returns (uint) {\\r\\n        address payable to = payable(_to);\\r\\n        uint id = _createPayment(to, amount, txType);\\r\\n        \\r\\n        return id;\\r\\n    }\\r\\n\\r\\n    function _createPayment (address payable to, uint amount, TxType txType) private returns (uint) {\\r\\n        require(amount > 0, \\\"amount is below zero\\\");\\r\\n\\r\\n        currentPaymentId++;\\r\\n\\r\\n        payments[currentPaymentId] = Payment({\\r\\n            to: to,\\r\\n            amount: amount,\\r\\n            txType: txType,\\r\\n            txStatus: TxStatus.Pending,\\r\\n            creationTime: block.timestamp,\\r\\n            completionTime: 0,\\r\\n            approvalOne: msg.sender == signerOne,\\r\\n            approvalTwo: msg.sender == signerTwo\\r\\n        });\\r\\n\\r\\n        emit UpdatedPayment(currentPaymentId);\\r\\n\\r\\n        return currentPaymentId;\\r\\n    }\\r\\n\\r\\n    function approvePayment (uint id) external nonReentrant isSigner {\\r\\n        Payment storage payment = payments[id];\\r\\n\\r\\n        if (msg.sender == signerOne) {\\r\\n            payment.approvalOne = true;\\r\\n        }\\r\\n        if (msg.sender == signerTwo) {\\r\\n            payment.approvalTwo = true;\\r\\n        }\\r\\n\\r\\n        emit UpdatedPayment(id);\\r\\n    }\\r\\n\\r\\n    function sendPayment (uint id) external nonReentrant isSigner {\\r\\n        Payment storage payment = payments[id];\\r\\n        require(payment.txStatus == TxStatus.Pending, \\\"Payment already completed\\\");\\r\\n        require(payment.approvalOne == true && payment.approvalTwo == true, \\\"Payment has not been approved\\\");\\r\\n\\r\\n        if (payment.txType == TxType.Eth) {\\r\\n            _ethTransfer(payment.to, payment.amount);\\r\\n        }\\r\\n        if (payment.txType == TxType.Imty) {\\r\\n            _imtyTransfer(payment.to, payment.amount);\\r\\n        }\\r\\n\\r\\n        payment.txStatus = TxStatus.Completed;\\r\\n        payment.completionTime = block.timestamp;\\r\\n\\r\\n        emit UpdatedPayment(id);\\r\\n    }\\r\\n\\r\\n    function getPayment (uint id) external view returns (\\r\\n            TxType txType,\\r\\n            TxStatus txStatus,\\r\\n            address to,\\r\\n            uint amount,\\r\\n            bool approvalOne,\\r\\n            bool approvalTwo,\\r\\n            uint creationTime,\\r\\n            uint completionTime\\r\\n    ){\\r\\n        Payment memory payment = payments[id];\\r\\n\\r\\n        txStatus = payment.txStatus;\\r\\n        to = payment.to;\\r\\n        amount = payment.amount;\\r\\n        approvalOne = payment.approvalOne;\\r\\n        approvalTwo = payment.approvalTwo;\\r\\n        creationTime = payment.creationTime;\\r\\n        completionTime = payment.completionTime;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"/home/madmax/projects/imty-token/contracts/Wallet.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/introspection/ERC1820Implementer.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/IERC1820Registry.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC777/IERC777Sender.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./Helpers.sol\\\";\\n\\ncontract Wallet is Context, IERC777Recipient, IERC777Sender, ERC1820Implementer, OnlyDeployer, OnlyOnce  {\\n    IERC777 tokenContract;\\n    bool tokenContractSet;\\n\\n    event ImtyTransaction(address operator, address from, address to, uint256 amount, bytes userData, bytes operatorData);\\n    event EthTransaction(address from, address to, uint amount);\\n\\n    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\\n\\n    bytes32 constant private _TOKENS_SENDER_INTERFACE_HASH = keccak256(\\\"ERC777TokensSender\\\");\\n    bytes32 constant private _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\\\"ERC777TokensRecipient\\\");\\n\\n    constructor () OnlyDeployer() public {\\n        _erc1820.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\\n        registerRecipient(address(this));\\n        registerSender(address(this));\\n    }\\n    modifier senderIsImty () {\\n        require(address(_msgSender()) == address(tokenContract), \\\"Caller is not IMTY token\\\");\\n        _;\\n    }\\n\\n    function senderFor(address account) public {\\n        _registerInterfaceForAddress(_TOKENS_SENDER_INTERFACE_HASH, account);\\n\\n        address self = address(this);\\n        if (account == self) {\\n            registerSender(self);\\n        }\\n    }\\n\\n    function recipientFor(address account) public {\\n        _registerInterfaceForAddress(_TOKENS_RECIPIENT_INTERFACE_HASH, account);\\n\\n        address self = address(this);\\n        if (account == self) {\\n            registerRecipient(self);\\n        }\\n    }\\n\\n    function registerRecipient(address recipient) internal {\\n        _erc1820.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, recipient);\\n    }\\n\\n    function registerSender(address sender) public {\\n        _erc1820.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, sender);\\n    }\\n\\n    receive () external payable {\\n        emit EthTransaction(msg.sender, address(this), msg.value);\\n    }\\n\\n    function tokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) senderIsImty external override(IERC777Recipient) {\\n        emit ImtyTransaction(operator, from, to, amount, userData, operatorData);\\n    }\\n\\n    function tokensToSend(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) senderIsImty external override {\\n        emit ImtyTransaction(operator, from, to, amount, userData, operatorData);\\n    }\\n\\n    function setTokenContract (address _tokenAddress) onlyDeployer onlyOnce(\\\"setTokenContract\\\") external {\\n        require(!tokenContractSet, \\\"Current token contract is not null\\\");\\n        tokenContract = IERC777(_tokenAddress);\\n        tokenContractSet = true;\\n    }\\n\\n    function getImtyBalance () public view returns (uint) {\\n        return tokenContract.balanceOf(address(this));\\n    }\\n\\n    function getEthBalance () public view returns (uint) {\\n        address payable self = payable(address(this));\\n        return self.balance;\\n    }\\n\\n    function _ethTransfer (address payable to, uint amount) internal {\\n        Address.sendValue(to, amount);\\n        emit EthTransaction(address(this), to, amount);\\n    }\\n\\n    function _imtyTransfer (address payable to, uint amount) internal {\\n        tokenContract.send(to, amount, \\\"\\\");\\n    }\\n\\n    function crowdsaleAllowance (address _crowdsaleAddress) onlyDeployer onlyOnce(\\\"crowdsaleAllowance\\\") external returns (bool) {\\n        return IERC20(address(tokenContract)).approve(_crowdsaleAddress, 780000000 * (10 ** 18));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC1820Implementer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC1820Implementer.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC1820Implementer} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterfaceForAddress} to\\n * declare their willingness to be implementers.\\n * {IERC1820Registry-setInterfaceImplementer} should then be called for the\\n * registration to be complete.\\n */\\ncontract ERC1820Implementer is IERC1820Implementer {\\n    bytes32 constant private _ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\\\"ERC1820_ACCEPT_MAGIC\\\"));\\n\\n    mapping(bytes32 => mapping(address => bool)) private _supportedInterfaces;\\n\\n    /**\\n     * See {IERC1820Implementer-canImplementInterfaceForAddress}.\\n     */\\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) public view override returns (bytes32) {\\n        return _supportedInterfaces[interfaceHash][account] ? _ERC1820_ACCEPT_MAGIC : bytes32(0x00);\\n    }\\n\\n    /**\\n     * @dev Declares the contract as willing to be an implementer of\\n     * `interfaceHash` for `account`.\\n     *\\n     * See {IERC1820Registry-setInterfaceImplementer} and\\n     * {IERC1820Registry-interfaceHash}.\\n     */\\n    function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal virtual {\\n        _supportedInterfaces[interfaceHash][account] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC1820Implementer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface for an ERC1820 implementer, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1820#interface-implementation-erc1820implementerinterface[EIP].\\n * Used by contracts that will be registered as implementers in the\\n * {IERC1820Registry}.\\n */\\ninterface IERC1820Implementer {\\n    /**\\n     * @dev Returns a special value (`ERC1820_ACCEPT_MAGIC`) if this contract\\n     * implements `interfaceHash` for `account`.\\n     *\\n     * See {IERC1820Registry-setInterfaceImplementer}.\\n     */\\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the global ERC1820 Registry, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\\n * implementers for interfaces in this registry, as well as query support.\\n *\\n * Implementers may be shared by multiple accounts, and can also implement more\\n * than a single interface for each account. Contracts can implement interfaces\\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\\n * contract.\\n *\\n * {IERC165} interfaces can also be queried via the registry.\\n *\\n * For an in-depth explanation and source code analysis, see the EIP text.\\n */\\ninterface IERC1820Registry {\\n    /**\\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\\n     * account is able to set interface implementers for it.\\n     *\\n     * By default, each account is its own manager. Passing a value of `0x0` in\\n     * `newManager` will reset the manager to this initial state.\\n     *\\n     * Emits a {ManagerChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     */\\n    function setManager(address account, address newManager) external;\\n\\n    /**\\n     * @dev Returns the manager for `account`.\\n     *\\n     * See {setManager}.\\n     */\\n    function getManager(address account) external view returns (address);\\n\\n    /**\\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\\n     * `interfaceHash`.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     * The zero address can also be used in `implementer` to remove an old one.\\n     *\\n     * See {interfaceHash} to learn how these are created.\\n     *\\n     * Emits an {InterfaceImplementerSet} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\\n     * end in 28 zeroes).\\n     * - `implementer` must implement {IERC1820Implementer} and return true when\\n     * queried for support, unless `implementer` is the caller. See\\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\\n     */\\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\\n\\n    /**\\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\\n     * implementer is registered, returns the zero address.\\n     *\\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\\n     * zeroes), `account` will be queried for support of it.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     */\\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\\n\\n    /**\\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\\n     * corresponding\\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\\n     */\\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\\n\\n    /**\\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\\n     *  @param account Address of the contract for which to update the cache.\\n     *  @param interfaceId ERC165 interface for which to update the cache.\\n     */\\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\\n\\n    /**\\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\\n     *  If the result is not cached a direct lookup on the contract address is performed.\\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\\n     *  {updateERC165Cache} with the contract address.\\n     *  @param account Address of the contract to check.\\n     *  @param interfaceId ERC165 interface to check.\\n     *  @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    /**\\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\\n     *  @param account Address of the contract to check.\\n     *  @param interfaceId ERC165 interface to check.\\n     *  @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\\n\\n    event ManagerChanged(address indexed account, address indexed newManager);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC777/IERC777.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\\n *\\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\\n * contract implement this interface (contract holders can be their own\\n * implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777Recipient {\\n    /**\\n     * @dev Called by an {IERC777} token contract whenever tokens are being\\n     * moved or created into a registered account (`to`). The type of operation\\n     * is conveyed by `from` being the zero address or not.\\n     *\\n     * This call occurs _after_ the token contract's state is updated, so\\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\\n     *\\n     * This function may revert to prevent the operation from being executed.\\n     */\\n    function tokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC777/IERC777Sender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\\n *\\n * {IERC777} Token holders can be notified of operations performed on their\\n * tokens by having a contract implement this interface (contract holders can be\\n *  their own implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777Sender {\\n    /**\\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\\n     * is conveyed by `to` being the zero address or not.\\n     *\\n     * This call occurs _before_ the token contract's state is updated, so\\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\\n     *\\n     * This function may revert to prevent the operation from being executed.\\n     */\\n    function tokensToSend(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerOne\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signerTwo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"ImtyTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewOperatorVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentId\",\"type\":\"uint256\"}],\"name\":\"UpdatedPayment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"approveOperatorVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approvePayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"createOperatorVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum MultiSigWallet.TxType\",\"name\":\"txType\",\"type\":\"uint8\"}],\"name\":\"createPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"name\":\"crowdsaleAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPaymentId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEthBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImtyBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getPayment\",\"outputs\":[{\"internalType\":\"enum MultiSigWallet.TxType\",\"name\":\"txType\",\"type\":\"uint8\"},{\"internalType\":\"enum MultiSigWallet.TxStatus\",\"name\":\"txStatus\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approvalOne\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"approvalTwo\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"completionTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorVoteAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorVoteOne\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorVoteTwo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"recipientFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"registerSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"sendPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"senderFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_defaultOperators\",\"type\":\"address[]\"}],\"name\":\"setDefaultOperators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"tokensToSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MultiSigWallet","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"0000000000000000000000005630ac50d62a57e9489bd77518bd89981f2bed88000000000000000000000000fd21299386a10b3acd28ffa5281a86f89ca76d18000000000000000000000000bec6cf25afb79b975e57b93f3216e468f8fed910","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}