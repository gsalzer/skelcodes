{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Copyright (c) The Force Protocol Development Team\r\n * Submitted for verification at Etherscan.io on 2019-09-17\r\n*/\r\n\r\npragma solidity ^0.5.13;\r\n// pragma experimental ABIEncoderV2;\r\n\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n// import \"./ReentrancyGuard.sol\";\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"uint mul overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"uint div by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"uint sub overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"uint add overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"uint mod by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n\r\n        require(address(token).isContract());\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success);\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            require(abi.decode(returndata, (bool)));\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary address_make_payable {\r\n  function make_payable(address x) internal pure returns (address payable) {\r\n    return address(uint160(x));\r\n  }\r\n}\r\n\r\ncontract IOracle {\r\n  function get(address token) external view returns (uint, bool);\r\n}\r\n\r\ncontract IInterestRateModel {\r\n  function getLoanRate(int cash, int borrow) external view returns (int y);\r\n  function getDepositRate(int cash, int borrow) external view returns (int y);\r\n\r\n  function calculateBalance(int principal, int lastIndex, int newIndex) external view returns (int y);\r\n  function calculateInterestIndex(int Index, int r, int t) external view returns (int y);\r\n  function pert(int principal, int r, int t) external view returns (int y);\r\n  function getNewReserve(int oldReserve, int cash, int borrow, int blockDelta) external view returns (int y);\r\n}\r\n\r\ncontract PoolPawn is ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using address_make_payable for address;\r\n\r\n    address public admin; //the admin address\r\n    address public proposedAdmin;//use pull over push pattern for admin\r\n\r\n    uint256 public constant interestRateDenomitor = 1e18;\r\n\r\n    /**\r\n      * @notice Container for borrow balance information\r\n      * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\r\n      * @member interestIndex Global borrowIndex as of the most recent balance-changing action\r\n      */\r\n    //存款/贷款本金和利息\r\n    struct Balance {\r\n        uint principal;\r\n        uint interestIndex;\r\n\r\n        uint totalPnl;//total profit and loss\r\n    }\r\n\r\n    struct Market {\r\n      uint accrualBlockNumber;\r\n      int supplyRate;//存款利率\r\n      int demondRate;//借款利率\r\n\r\n      IInterestRateModel irm;\r\n\r\n      uint totalSupply;\r\n      uint supplyIndex;\r\n\r\n      uint totalBorrows;\r\n      uint borrowIndex;\r\n\r\n      uint totalReserves;//系统盈利\r\n\r\n      uint minPledgeRate;//最小质押率\r\n      uint liquidationDiscount;//清算折扣\r\n\r\n      uint decimals;//币种的最小精度\r\n    }\r\n\r\n    // 存币与借币的映射关系\r\n    mapping (address => mapping (address => Balance)) public accountSupplySnapshot;//tokenContract->address(usr)->SupplySnapshot\r\n    mapping (address => mapping (address => Balance)) public accountBorrowSnapshot;//tokenContract->address(usr)->BorrowSnapshot\r\n\r\n    struct LiquidateInfo {\r\n        address targetAccount;//被清算账户\r\n        address liquidator;//清算人\r\n        address assetCollatera;//抵押物token地址\r\n        address assetBorrow;//债务token地址\r\n        uint256 liquidateAmount;//清算额度，抵押物\r\n        uint256 targetAmount;//目标额度, 债务\r\n        uint256 timestamp;\r\n    }\r\n\r\n    mapping (uint => LiquidateInfo) public liquidateInfoMap;\r\n    uint public liquidateIndexes;\r\n\r\n    function setLiquidateInfoMap(address _targetAccount, address _liquidator, address _assetCollatera, address _assetBorrow, uint256 x, uint256 y) internal {\r\n        //更新清算的历史记录Map\r\n        liquidateInfoMap[liquidateIndexes].targetAccount = _targetAccount;\r\n        liquidateInfoMap[liquidateIndexes].liquidator = _liquidator;\r\n        liquidateInfoMap[liquidateIndexes].assetCollatera = _assetCollatera;\r\n        liquidateInfoMap[liquidateIndexes].assetBorrow = _assetBorrow;\r\n        liquidateInfoMap[liquidateIndexes].liquidateAmount = x;\r\n        liquidateInfoMap[liquidateIndexes].targetAmount = y;\r\n        liquidateInfoMap[liquidateIndexes].timestamp = now;\r\n\r\n        liquidateIndexes++;\r\n    }\r\n\r\n    //user table\r\n    mapping (uint256 => address) public accounts;\r\n    mapping (address => uint256) public indexes;\r\n    uint256 public index = 1;\r\n    // 添加用户\r\n    function join(address who) internal {\r\n      if (indexes[who] == 0) {\r\n        accounts[index] = who;\r\n        indexes[who] = index;\r\n        ++index;\r\n      }\r\n    }\r\n\r\n    event SupplyPawnLog(address usr, address t, uint amount, uint beg, uint end);\r\n    event WithdrawPawnLog(address usr, address t, uint amount, uint beg, uint end);\r\n    event BorrowPawnLog(address usr, address t, uint amount, uint beg, uint end);\r\n    event RepayFastBorrowLog(address usr, address t, uint amount, uint beg, uint end);\r\n    event LiquidateBorrowPawnLog(\r\n      address usr, address tBorrow, uint endBorrow,\r\n      address liquidator, address tCol, uint endCol);\r\n    event WithdrawPawnEquityLog(address t, uint equityAvailableBefore, uint amount, address owner);\r\n\r\n\r\n    mapping (address => Market) public mkts;//tokenAddress->Market\r\n    address[] public collateralTokens;//抵押币种\r\n    IOracle public oracleInstance;\r\n\r\n    uint public constant initialInterestIndex = 10 ** 18;\r\n    uint public constant defaultOriginationFee = 0; // default is zero bps\r\n    uint public constant originationFee = 0;\r\n    uint public constant ONE_ETH = 1 ether;\r\n\r\n    //增加抵押币种，WBTC，ETH，TBTC\r\n    function addCollateralMarket(address asset) public onlyAdmin {\r\n      for (uint i = 0; i < collateralTokens.length; i++) {\r\n        if (collateralTokens[i] == asset) {\r\n          return;\r\n        }\r\n      }\r\n      collateralTokens.push(asset);\r\n    }\r\n\r\n    function getCollateralMarketsLength() external view returns (uint) {\r\n      return collateralTokens.length;\r\n    }\r\n\r\n    function setInterestRateModel(address t, address irm) public onlyAdmin {\r\n      mkts[t].irm = IInterestRateModel(irm);\r\n    }\r\n\r\n    function setMinPledgeRate(address t, uint minPledgeRate) external onlyAdmin {\r\n      mkts[t].minPledgeRate = minPledgeRate;\r\n    }\r\n\r\n    function setLiquidationDiscount(address t, uint liquidationDiscount) external onlyAdmin {\r\n      mkts[t].liquidationDiscount = liquidationDiscount;\r\n    }\r\n\r\n    function initCollateralMarket(address t, address irm, address oracle, uint decimals) external onlyAdmin {\r\n      if (address(oracleInstance) == address(0)) {\r\n        setOracle(oracle);\r\n      }\r\n\r\n      if (address(mkts[t].irm) == address(0)) {\r\n        setInterestRateModel(t, irm);\r\n      }\r\n\r\n      addCollateralMarket(t);\r\n      if (mkts[t].supplyIndex == 0) {\r\n        mkts[t].supplyIndex = initialInterestIndex;\r\n      }\r\n\r\n      if (mkts[t].borrowIndex == 0) {\r\n        mkts[t].borrowIndex = initialInterestIndex;\r\n      }\r\n\r\n      if (mkts[t].decimals == 0) {\r\n        mkts[t].decimals = decimals;\r\n      }\r\n    }\r\n\r\nconstructor() public {\r\n  admin = msg.sender;\r\n}\r\n\r\n//Starting from Solidity 0.4.0, contracts without a fallback function automatically revert payments, making the code above redundant.\r\n// function() external payable {\r\n//   revert(\"fallback can't be payable\");\r\n// }\r\n\r\nmodifier onlyAdmin() {\r\n  require(msg.sender == admin, \"only admin can do this!\");\r\n  _;\r\n}\r\n\r\nfunction proposeNewAdmin(address admin_) external onlyAdmin {\r\n    proposedAdmin = admin_;\r\n}\r\n\r\nfunction claimAdministration() external {\r\n    require(msg.sender == proposedAdmin, \"Not proposed admin.\");\r\n    admin = proposedAdmin;\r\n    proposedAdmin = address(0);\r\n}\r\n\r\n    //设置USDT，DAI和抵押品的起始时间戳\r\n    function setInitialTimestamp(address token) external onlyAdmin {\r\n      mkts[token].accrualBlockNumber = now;\r\n    }\r\n\r\n    function setDecimals(address t, uint decimals) external onlyAdmin {\r\n      mkts[t].decimals = decimals;\r\n    }\r\n\r\n    function setOracle(address oracle) public onlyAdmin {\r\n      oracleInstance = IOracle(oracle);\r\n    }\r\n\r\n    modifier existOracle() {\r\n      require(address(oracleInstance) != address(0), \"oracle not set\");\r\n      _;\r\n    }\r\n\r\n    // 从预言机获取币种价格\r\n    function fetchAssetPrice(address asset) public view returns (uint, bool) {\r\n      require(address(oracleInstance) != address(0), \"oracle not set\");\r\n      return oracleInstance.get(asset);\r\n    }\r\n\r\n    // 计算 assetAmount 数量的币种价格\r\n    function getPriceForAssetAmount(address asset, uint assetAmount) public view returns (uint) {\r\n      require(address(oracleInstance) != address(0), \"oracle not set\");\r\n      (uint price, bool ok) = fetchAssetPrice(asset);\r\n      require(ok && price > 0, \"invalid token price\");\r\n      return price.mul(assetAmount).div(10**mkts[asset].decimals);\r\n    }\r\n\r\n    // 计算 usdValue 价值的币种数量\r\n    function getAssetAmountForValue(address t, uint usdValue) public view returns (uint) {\r\n      require(address(oracleInstance) != address(0), \"oracle not set\");\r\n      (uint price, bool ok) = fetchAssetPrice(t);\r\n      require(ok && price > 0, \"invalid token price\");\r\n      return usdValue.mul(10**mkts[t].decimals).div(price);\r\n    }\r\n\r\n    //合约拥有的 t 币种余额\r\n    function getCash(address t) public view returns (uint) {\r\n      if (t == address(0)) {\r\n        return address(this).balance;\r\n      }\r\n      IERC20 token = IERC20(t);\r\n      return token.balanceOf(address(this));\r\n    }\r\n\r\n    // from 账户拥有的 asset 币种余额\r\n    function getBalanceOf(address asset, address from) internal view returns (uint) {\r\n\r\n      if (asset == address(0)) {\r\n        return address(from).balance;\r\n      }\r\n      \r\n      IERC20 token = IERC20(asset);\r\n\r\n      return token.balanceOf(from);\r\n    }\r\n\r\n    //借存比，总借/总存 * 1e18，存贷比，贷存比\r\n    function loanToDepositRatio(address asset) public view returns (uint) {\r\n      uint256 loan = mkts[asset].totalBorrows;\r\n      uint256 deposit = mkts[asset].totalSupply;\r\n      uint256 _1 = 1 ether;\r\n\r\n      return loan.mul(_1).div(deposit);\r\n    }\r\n\r\n    //m:market, a:account\r\n    //i(n,m)=i(n-1,m)*(1+rm*t)\r\n    //return P*(i(n,m)/i(n-1,a))\r\n    // 计算当前 acc 用户的 t 币种存款额\r\n    function getSupplyBalance(address acc, address t) public view returns (uint) {\r\n      Balance storage supplyBalance = accountSupplySnapshot[t][acc];\r\n\r\n      int mSupplyIndex = mkts[t].irm.pert(int(mkts[t].supplyIndex), int(mkts[t].supplyRate), int(now - mkts[t].accrualBlockNumber));\r\n\r\n      uint userSupplyCurrent = uint(mkts[t].irm.calculateBalance(int(supplyBalance.principal), int(supplyBalance.interestIndex), mSupplyIndex));\r\n      return userSupplyCurrent;\r\n    }\r\n\r\n    // 计算当前 who 用户 的 t 币种存款价值\r\n    function getSupplyBalanceInUSD(address who, address t) public view returns (uint) {\r\n      return getPriceForAssetAmount(t, getSupplyBalance(who, t));\r\n    }\r\n\r\n    // 计算当前总收益\r\n    function getSupplyPnl(address acc, address t) public view returns (uint) {\r\n      Balance storage supplyBalance = accountSupplySnapshot[t][acc];\r\n\r\n      int mSupplyIndex = mkts[t].irm.pert(int(mkts[t].supplyIndex), int(mkts[t].supplyRate), int(now - mkts[t].accrualBlockNumber));\r\n\r\n      uint userSupplyCurrent = uint(mkts[t].irm.calculateBalance(int(supplyBalance.principal), int(supplyBalance.interestIndex), mSupplyIndex));\r\n\r\n      if (userSupplyCurrent > supplyBalance.principal) {\r\n        return supplyBalance.totalPnl.add(userSupplyCurrent.sub(supplyBalance.principal));\r\n      } else {\r\n        return supplyBalance.totalPnl;\r\n      }\r\n    }\r\n\r\n    //计算总利息（单位为美元）\r\n    function getSupplyPnlInUSD(address who, address t) public view returns (uint) {\r\n      return getPriceForAssetAmount(t, getSupplyPnl(who, t));\r\n    }\r\n\r\n    //Gets USD all token values of supply profit\r\n    function getTotalSupplyPnl(address who) public view returns (uint) {\r\n      uint length = collateralTokens.length;\r\n      uint sumPnl = 0;\r\n\r\n      for (uint i = 0; i < length; i++) {\r\n        uint pnl = getSupplyPnlInUSD(who, collateralTokens[i]);\r\n        sumPnl = sumPnl.add(pnl);\r\n      }\r\n      return sumPnl;\r\n    }\r\n\r\n    //m:market, a:account\r\n    //i(n,m)=i(n-1,m)*(1+rm*t)\r\n    //return P*(i(n,m)/i(n-1,a))\r\n    function getBorrowBalance(address acc, address t) public view returns (uint) {\r\n      Balance storage borrowBalance = accountBorrowSnapshot[t][acc];\r\n\r\n      int mBorrowIndex = mkts[t].irm.pert(int(mkts[t].borrowIndex), int(mkts[t].demondRate), int(now - mkts[t].accrualBlockNumber));\r\n\r\n      uint userBorrowCurrent = uint(mkts[t].irm.calculateBalance(int(borrowBalance.principal), int(borrowBalance.interestIndex), mBorrowIndex));\r\n      return userBorrowCurrent;\r\n    }\r\n\r\n    function getBorrowBalanceInUSD(address who, address t) public view returns (uint) {\r\n      return getPriceForAssetAmount(t, getBorrowBalance(who, t));\r\n    }\r\n\r\n    function getBorrowPnl(address acc, address t) public view returns (uint) {\r\n      Balance storage borrowBalance = accountBorrowSnapshot[t][acc];\r\n\r\n      int mBorrowIndex = mkts[t].irm.pert(int(mkts[t].borrowIndex), int(mkts[t].demondRate), int(now - mkts[t].accrualBlockNumber));\r\n\r\n      uint userBorrowCurrent = uint(mkts[t].irm.calculateBalance(int(borrowBalance.principal), int(borrowBalance.interestIndex), mBorrowIndex));\r\n\r\n      return borrowBalance.totalPnl.add(userBorrowCurrent).sub(borrowBalance.principal);\r\n    }\r\n\r\n    //计算总利息（单位为美元）\r\n    function getBorrowPnlInUSD(address who, address t) public view returns (uint) {\r\n      return getPriceForAssetAmount(t, getBorrowPnl(who, t));\r\n    }\r\n\r\n    //Gets USD all token values of borrow lose\r\n    function getTotalBorrowPnl(address who) public view returns (uint) {\r\n      uint length = collateralTokens.length;\r\n      uint sumPnl = 0;\r\n\r\n      for (uint i = 0; i < length; i++) {\r\n        uint pnl = getBorrowPnlInUSD(who, collateralTokens[i]);\r\n        sumPnl = sumPnl.add(pnl);\r\n      }\r\n      return sumPnl;\r\n    }\r\n\r\n    // BorrowBalance * collateral ratio\r\n    // 用户 who 借的 t 币种的价值 * 该币种的质押率(质押率总大于1)\r\n    function getBorrowBalanceLeverage(address who, address t) public view returns (uint) {\r\n      return getBorrowBalanceInUSD(who,t).mul(mkts[t].minPledgeRate).div(ONE_ETH);\r\n    }\r\n\r\n    //Gets USD token values of supply and borrow balances\r\n    // 返回 who 用户的 t 币种存款价值和借款价值\r\n    function calcAccountTokenValuesInternal(address who, address t) public view returns (uint, uint) {\r\n      return (getSupplyBalanceInUSD(who, t), getBorrowBalanceInUSD(who, t));\r\n    }\r\n\r\n    //Gets USD token values of supply and borrow balances\r\n    // 返回 who 用户的 t 币种存款价值，与 借款价值质押率乘积\r\n    function calcAccountTokenValuesLeverageInternal(address who, address t) public view returns (uint, uint) {\r\n      return (getSupplyBalanceInUSD(who, t), getBorrowBalanceLeverage(who, t));\r\n    }\r\n\r\n    //Gets USD all token values of supply and borrow balances\r\n    // 所有币种总存款价值 与 总借款价值质押率乘积\r\n    function calcAccountAllTokenValuesLeverageInternal(address who) public view returns (uint, uint) {\r\n      uint length = collateralTokens.length;\r\n      uint sumSupplies;\r\n      uint sumBorrowLeverage;\r\n\r\n      for (uint i = 0; i < length; i++) {\r\n        (uint supplyValue, uint borrowsLeverage) = calcAccountTokenValuesLeverageInternal(who, collateralTokens[i]);\r\n        sumSupplies = sumSupplies.add(supplyValue);\r\n        sumBorrowLeverage = sumBorrowLeverage.add(borrowsLeverage);\r\n      }\r\n      return (sumSupplies, sumBorrowLeverage);\r\n    }\r\n\r\n    // 计算用户此时是盈余状态还是亏欠状态，并返回差值\r\n    function calcAccountLiquidity(address who) public view returns (uint, uint) {\r\n      uint sumSupplies;\r\n      uint sumBorrowsLeverage;//sumBorrows* collateral ratio\r\n      (sumSupplies, sumBorrowsLeverage) = calcAccountAllTokenValuesLeverageInternal(who);\r\n      if (sumSupplies < sumBorrowsLeverage) {\r\n        return (0, sumBorrowsLeverage.sub(sumSupplies));//不足\r\n      } else {\r\n        return (sumSupplies.sub(sumBorrowsLeverage), 0);//有余\r\n      }\r\n    }\r\n\r\n  struct SupplyIR {\r\n      uint startingBalance;\r\n      uint newSupplyIndex;\r\n      uint userSupplyCurrent;\r\n      uint userSupplyUpdated;\r\n      uint newTotalSupply;\r\n      uint currentCash;\r\n      uint updatedCash;\r\n      uint newBorrowIndex;\r\n  }\r\n\r\n  // 存钱\r\n  function supplyPawn(address t, uint amount) external payable nonReentrant returns (uint) {\r\n    uint supplyAmount = amount;\r\n    if (t == address(0)) {\r\n      require(amount == msg.value, \"Eth value should be equal to amount\");\r\n      supplyAmount = msg.value;\r\n    }\r\n    SupplyIR memory tmp;\r\n    Market storage market = mkts[t];\r\n    Balance storage supplyBalance = accountSupplySnapshot[t][msg.sender];\r\n\r\n    uint lastTimestamp = mkts[t].accrualBlockNumber;\r\n    uint blockDelta = now - lastTimestamp;\r\n\r\n    // 计算 t 币种的存款利率并更新用户的存款额\r\n    tmp.newSupplyIndex = uint(mkts[t].irm.pert(int(mkts[t].supplyIndex), int(mkts[t].supplyRate), int(blockDelta)));\r\n    tmp.userSupplyCurrent = uint(mkts[t].irm.calculateBalance(int(accountSupplySnapshot[t][msg.sender].principal), int(supplyBalance.interestIndex), int(tmp.newSupplyIndex)));\r\n    tmp.userSupplyUpdated = tmp.userSupplyCurrent.add(supplyAmount);\r\n    // 更新市场的存量\r\n    tmp.newTotalSupply = market.totalSupply.add(tmp.userSupplyUpdated).sub(supplyBalance.principal);\r\n\r\n    tmp.currentCash = getCash(t);\r\n    // 如果是 ERC-20 代币，加 amount\r\n    // 如果是 ETH，则已经在函数调用的时候转入了，就不用加了\r\n    tmp.updatedCash = t != address(0) ? tmp.currentCash.add(supplyAmount) : tmp.currentCash;\r\n\r\n    // 更新存借比率\r\n    mkts[t].supplyRate = mkts[t].irm.getDepositRate(int(tmp.updatedCash), int(mkts[t].totalBorrows));\r\n    tmp.newBorrowIndex = uint(mkts[t].irm.pert(int(mkts[t].borrowIndex), int(mkts[t].demondRate), int(blockDelta)));\r\n    mkts[t].demondRate = mkts[t].irm.getLoanRate(int(tmp.updatedCash), int(mkts[t].totalBorrows));\r\n\r\n    mkts[t].borrowIndex = tmp.newBorrowIndex;\r\n    mkts[t].supplyIndex = tmp.newSupplyIndex;\r\n    mkts[t].totalSupply = tmp.newTotalSupply;\r\n    mkts[t].accrualBlockNumber = now;\r\n\r\n    tmp.startingBalance = supplyBalance.principal;\r\n    supplyBalance.principal = tmp.userSupplyUpdated;\r\n    supplyBalance.interestIndex = tmp.newSupplyIndex;\r\n\r\n    // 更新用户的 t 币种总收益\r\n    if (tmp.userSupplyCurrent > tmp.startingBalance) {\r\n      supplyBalance.totalPnl = supplyBalance.totalPnl.add(tmp.userSupplyCurrent.sub(tmp.startingBalance));\r\n    }\r\n\r\n    join(msg.sender);\r\n\r\n    require(safeTransferFrom(t, msg.sender, address(this), address(this).make_payable(), supplyAmount, 0) == 0, \"supply error\");\r\n\r\n    emit SupplyPawnLog(msg.sender, t, supplyAmount, tmp.startingBalance, tmp.userSupplyUpdated);\r\n    return 0;\r\n  }\r\n\r\n  struct WithdrawIR {\r\n    uint withdrawAmount;\r\n    uint startingBalance;\r\n    uint newSupplyIndex;\r\n    uint userSupplyCurrent;\r\n    uint userSupplyUpdated;\r\n    uint newTotalSupply;\r\n    uint currentCash;\r\n    uint updatedCash;\r\n    uint newBorrowIndex;\r\n\r\n    uint accountLiquidity;\r\n    uint accountShortfall;\r\n    uint usdValueOfWithdrawal;\r\n    uint withdrawCapacity;\r\n  }\r\n\r\n  // 取钱\r\n  function withdrawPawn(address t, uint requestedAmount) external nonReentrant returns (uint) {\r\n    Market storage market = mkts[t];\r\n    Balance storage supplyBalance = accountSupplySnapshot[t][msg.sender];\r\n\r\n    WithdrawIR memory tmp;\r\n\r\n    uint lastTimestamp = mkts[t].accrualBlockNumber;\r\n    uint blockDelta = now - lastTimestamp;\r\n\r\n    // 先计算盈亏，判断是否还有能力取钱\r\n    (tmp.accountLiquidity, tmp.accountShortfall) = calcAccountLiquidity(msg.sender);\r\n    require(tmp.accountLiquidity > 0 && tmp.accountShortfall == 0, \"can't withdraw, shortfall\");\r\n    // 更新存币的余额\r\n    tmp.newSupplyIndex = uint(mkts[t].irm.pert(int(mkts[t].supplyIndex), int(mkts[t].supplyRate), int(blockDelta)));\r\n    tmp.userSupplyCurrent = uint(mkts[t].irm.calculateBalance(int(supplyBalance.principal), int(supplyBalance.interestIndex), int(tmp.newSupplyIndex)));\r\n\r\n    // 获取合约余额\r\n    tmp.currentCash = getCash(t);\r\n    if (requestedAmount == uint(-1)) {\r\n      // 计算可以取的最大数量，最大数量只能为 （盈亏差值，当前币种余额，合约余额）中的较小值\r\n      tmp.withdrawCapacity = getAssetAmountForValue(t, tmp.accountLiquidity);\r\n      tmp.withdrawAmount = min(tmp.withdrawCapacity, tmp.userSupplyCurrent);\r\n      tmp.withdrawAmount = min(tmp.withdrawAmount, tmp.currentCash);\r\n    } else {\r\n      tmp.withdrawAmount = requestedAmount;\r\n    }\r\n\r\n    // 更新本合约的余额\r\n    tmp.updatedCash = tmp.currentCash.sub(tmp.withdrawAmount);\r\n    tmp.userSupplyUpdated = tmp.userSupplyCurrent.sub(tmp.withdrawAmount);\r\n\r\n    // 获取实际要取的币种价值\r\n    tmp.usdValueOfWithdrawal = getPriceForAssetAmount(t, tmp.withdrawAmount);\r\n    // 判断要取出的币种价值不能超过盈亏差值\r\n    require(tmp.usdValueOfWithdrawal <= tmp.accountLiquidity);\r\n\r\n    // 更新市场存量\r\n    tmp.newTotalSupply = market.totalSupply.add(tmp.userSupplyUpdated).sub(supplyBalance.principal);\r\n\r\n    // 更新利率\r\n    tmp.newSupplyIndex = uint(mkts[t].irm.pert(int(mkts[t].supplyIndex), int(mkts[t].supplyRate), int(blockDelta)));\r\n\r\n    // 更新存借比率\r\n    market.supplyRate = mkts[t].irm.getDepositRate(int(tmp.updatedCash), int(market.totalBorrows));\r\n    tmp.newBorrowIndex = uint(mkts[t].irm.pert(int(mkts[t].borrowIndex), mkts[t].demondRate, int(blockDelta)));\r\n    market.demondRate = mkts[t].irm.getLoanRate(int(tmp.updatedCash), int(market.totalBorrows));\r\n\r\n\r\n    market.accrualBlockNumber = now;\r\n    market.totalSupply = tmp.newTotalSupply;\r\n    market.supplyIndex = tmp.newSupplyIndex;\r\n    market.borrowIndex = tmp.newBorrowIndex;\r\n\r\n    tmp.startingBalance = supplyBalance.principal;\r\n    supplyBalance.principal = tmp.userSupplyUpdated;\r\n    supplyBalance.interestIndex = tmp.newSupplyIndex;\r\n\r\n    safeTransferFrom(t, address(this).make_payable(), address(this), msg.sender, tmp.withdrawAmount, 0);\r\n    \r\n    emit WithdrawPawnLog(msg.sender, t, tmp.withdrawAmount, tmp.startingBalance, tmp.userSupplyUpdated);\r\n    return 0;\r\n  }\r\n\r\n  struct PayBorrowIR {\r\n    uint newBorrowIndex;\r\n    uint userBorrowCurrent;\r\n    uint repayAmount;\r\n\r\n    uint userBorrowUpdated;\r\n    uint newTotalBorrows;\r\n    uint currentCash;\r\n    uint updatedCash;\r\n\r\n    uint newSupplyIndex;\r\n\r\n    uint startingBalance;\r\n  }\r\n\r\n  function min(uint a, uint b) internal pure returns (uint) {\r\n    if (a < b) {\r\n        return a;\r\n    } else {\r\n        return b;\r\n    }\r\n  }\r\n\r\n  //`(1 + originationFee) * borrowAmount`\r\n  function calcBorrowAmountWithFee(uint borrowAmount) public pure returns (uint) {\r\n    return borrowAmount.mul((ONE_ETH).add(originationFee)).div(ONE_ETH);\r\n  }\r\n\r\n  // 存币价值 * 质押率\r\n  function getPriceForAssetAmountMulCollatRatio(address t, uint assetAmount) public view returns (uint) {\r\n    return getPriceForAssetAmount(t, assetAmount).mul(mkts[t].minPledgeRate).div(ONE_ETH);\r\n  }\r\n\r\n  struct BorrowIR {\r\n    uint newBorrowIndex;\r\n    uint userBorrowCurrent;\r\n    uint borrowAmountWithFee;\r\n\r\n    uint userBorrowUpdated;\r\n    uint newTotalBorrows;\r\n    uint currentCash;\r\n    uint updatedCash;\r\n\r\n    uint newSupplyIndex;\r\n\r\n    uint startingBalance;\r\n\r\n    uint accountLiquidity;\r\n    uint accountShortfall;\r\n    uint usdValueOfBorrowAmountWithFee;\r\n  }\r\n\r\n  // 借钱\r\n  function BorrowPawn(address t, uint amount) external nonReentrant returns (uint) {\r\n    BorrowIR memory tmp;\r\n    Market storage market = mkts[t];\r\n    Balance storage borrowBalance = accountBorrowSnapshot[t][msg.sender];\r\n\r\n    uint lastTimestamp = mkts[t].accrualBlockNumber;\r\n    uint blockDelta = now - lastTimestamp;\r\n\r\n    // 计算借币利率并更新用户借币余额\r\n    tmp.newBorrowIndex = uint(mkts[t].irm.pert(int(mkts[t].borrowIndex), mkts[t].demondRate, int(blockDelta)));\r\n    int lastIndex = int(borrowBalance.interestIndex);\r\n    tmp.userBorrowCurrent = uint(mkts[t].irm.calculateBalance(int(borrowBalance.principal), lastIndex, int(tmp.newBorrowIndex)));\r\n    // 添加借币手续费\r\n    tmp.borrowAmountWithFee = calcBorrowAmountWithFee(amount);\r\n\r\n    tmp.userBorrowUpdated = tmp.userBorrowCurrent.add(tmp.borrowAmountWithFee);\r\n    // 更新市场借币余额\r\n    tmp.newTotalBorrows = market.totalBorrows.add(tmp.userBorrowUpdated).sub(borrowBalance.principal);\r\n\r\n    // 计算当前盈亏情况，判断是否有能力借钱\r\n    (tmp.accountLiquidity, tmp.accountShortfall) = calcAccountLiquidity(msg.sender);\r\n    require(tmp.accountLiquidity > 0 && tmp.accountShortfall == 0, \"can't borrow, shortfall\");\r\n\r\n    // 判断要借的钱是否大于用户盈亏差值\r\n    tmp.usdValueOfBorrowAmountWithFee = getPriceForAssetAmountMulCollatRatio(t, tmp.borrowAmountWithFee);\r\n    require(tmp.usdValueOfBorrowAmountWithFee <= tmp.accountLiquidity, \"can't borrow, without enough value\");\r\n\r\n    // 更新合约余额\r\n    tmp.currentCash = getCash(t);\r\n    tmp.updatedCash = tmp.currentCash.sub(amount);\r\n\r\n    // 更新存借比率\r\n    tmp.newSupplyIndex = uint(mkts[t].irm.pert(int(mkts[t].supplyIndex), int(mkts[t].supplyRate), int(blockDelta)));\r\n    market.supplyRate = mkts[t].irm.getDepositRate(int(tmp.updatedCash), int(tmp.newTotalBorrows));\r\n    market.demondRate = mkts[t].irm.getLoanRate(int(tmp.updatedCash), int(tmp.newTotalBorrows));\r\n\r\n\r\n    market.accrualBlockNumber = now;\r\n    market.totalBorrows = tmp.newTotalBorrows;\r\n    market.supplyIndex = tmp.newSupplyIndex;\r\n    market.borrowIndex = tmp.newBorrowIndex;\r\n\r\n    tmp.startingBalance = borrowBalance.principal;\r\n    borrowBalance.principal = tmp.userBorrowUpdated;\r\n    borrowBalance.interestIndex = tmp.newBorrowIndex;\r\n\r\n    // 更新币种的借币总额\r\n    // borrowBalance.totalPnl = borrowBalance.totalPnl.add(tmp.userBorrowCurrent.sub(tmp.startingBalance));\r\n\r\n    safeTransferFrom(t, address(this).make_payable(), address(this), msg.sender, amount, 0);\r\n\r\n    emit BorrowPawnLog(msg.sender, t, amount, tmp.startingBalance, tmp.userBorrowUpdated);\r\n    return 0;\r\n  }\r\n\r\n  // 还款，t: token\r\n  function repayFastBorrow(address t, uint amount) external payable nonReentrant returns (uint) {\r\n    PayBorrowIR memory tmp;\r\n    Market storage market = mkts[t];\r\n    Balance storage borrowBalance = accountBorrowSnapshot[t][msg.sender];\r\n\r\n    uint lastTimestamp = mkts[t].accrualBlockNumber;\r\n    uint blockDelta = now - lastTimestamp;\r\n\r\n    // 计算借币利率并更新用户借的 t 币种总额\r\n    tmp.newBorrowIndex = uint(mkts[t].irm.pert(int(mkts[t].borrowIndex), mkts[t].demondRate, int(blockDelta)));\r\n\r\n    int lastIndex = int(borrowBalance.interestIndex);\r\n    tmp.userBorrowCurrent = uint(mkts[t].irm.calculateBalance(int(borrowBalance.principal), lastIndex, int(tmp.newBorrowIndex)));\r\n\r\n    if (amount == uint(-1)) {\r\n        // 用户可以还款的最大量为（用户当前 t 币种的余额，用户当前借币 t 币种的量）中的较小值\r\n        tmp.repayAmount = min(getBalanceOf(t, msg.sender), tmp.userBorrowCurrent);\r\n        // 如果要还eth，用户发送的eth需要大于应还总额，多退\r\n        if (t == address(0)) {\r\n          require(msg.value > tmp.repayAmount, \"Eth value should be larger than repayAmount\");\r\n        }\r\n    } else {\r\n        tmp.repayAmount = amount;\r\n        if (t == address(0)) {\r\n          require(msg.value == tmp.repayAmount, \"Eth value should be equal to repayAmount\");\r\n        }\r\n    }\r\n\r\n    // 更新用户借币余额\r\n    tmp.userBorrowUpdated = tmp.userBorrowCurrent.sub(tmp.repayAmount);\r\n    // 更新市场借币余额\r\n    tmp.newTotalBorrows = market.totalBorrows.add(tmp.userBorrowUpdated).sub(borrowBalance.principal);\r\n    tmp.currentCash = getCash(t);\r\n    // 如果是 ERC-20 代币，加 tmp.repayAmount\r\n    // 如果是 ETH，则已经在函数调用的时候转入了，就不用加了\r\n    tmp.updatedCash = t != address(0) ? tmp.currentCash.add(tmp.repayAmount) : tmp.currentCash;\r\n\r\n    // 更新存借比率\r\n    tmp.newSupplyIndex = uint(mkts[t].irm.pert(int(mkts[t].supplyIndex), int(mkts[t].supplyRate), int(blockDelta)));\r\n    market.supplyRate = mkts[t].irm.getDepositRate(int(tmp.updatedCash), int(tmp.newTotalBorrows));\r\n    market.demondRate = mkts[t].irm.getLoanRate(int(tmp.updatedCash), int(tmp.newTotalBorrows));\r\n\r\n    market.accrualBlockNumber = now;\r\n    market.totalBorrows = tmp.newTotalBorrows;\r\n    market.supplyIndex = tmp.newSupplyIndex;\r\n    market.borrowIndex = tmp.newBorrowIndex;\r\n\r\n    tmp.startingBalance = borrowBalance.principal;\r\n    borrowBalance.principal = tmp.userBorrowUpdated;\r\n    borrowBalance.interestIndex = tmp.newBorrowIndex;\r\n\r\n    safeTransferFrom(t, msg.sender, address(this), address(this).make_payable(), tmp.repayAmount, msg.value);\r\n\r\n    emit RepayFastBorrowLog(msg.sender, t, tmp.repayAmount, tmp.startingBalance, tmp.userBorrowUpdated);\r\n\r\n    return 0;\r\n  }\r\n\r\n  //shortfall/(price*(minPledgeRate-liquidationDiscount-1))\r\n  //liquidationDiscount是清算折扣, in QIAN, 无清算折扣，但有罚金，罚金是8%，无清算折扣\r\n  //underwaterAsset is borrowAsset\r\n  function calcDiscountedRepayToEvenAmount(address targetAccount, address underwaterAsset, uint underwaterAssetPrice) public view returns (uint) {\r\n    (, uint shortfall) = calcAccountLiquidity(targetAccount);\r\n    uint minPledgeRate = mkts[underwaterAsset].minPledgeRate;\r\n    uint liquidationDiscount = mkts[underwaterAsset].liquidationDiscount;\r\n    uint gap = minPledgeRate.sub(liquidationDiscount).sub(1 ether);\r\n    return shortfall.mul(10**mkts[underwaterAsset].decimals).div(underwaterAssetPrice.mul(gap).div(ONE_ETH));//underwater asset amount\r\n  }\r\n\r\n  //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\r\n  //[supplyCurrent * (Oracle price for the collateral)] / [ (1 + liquidationDiscount) * (Oracle price for the borrow) ]\r\n  // 被清算人 supplyCurrent_TargetCollateralAsset 数量的质押资产换成可以被变卖的 underwaterAsset 资产数量\r\n  function calcDiscountedBorrowDenominatedCollateral(address underwaterAsset, address collateralAsset, uint underwaterAssetPrice, uint collateralPrice, uint supplyCurrent_TargetCollateralAsset) public view returns (uint) {\r\n    uint liquidationDiscount = mkts[underwaterAsset].liquidationDiscount;\r\n    uint onePlusLiquidationDiscount = (ONE_ETH).add(liquidationDiscount);\r\n    uint supplyCurrentTimesOracleCollateral = supplyCurrent_TargetCollateralAsset.mul(collateralPrice);//10^8*10^18, supplyCurrent_TargetCollateralAsset is IMBTC, 10^26\r\n    uint res = supplyCurrentTimesOracleCollateral.div(onePlusLiquidationDiscount.mul(underwaterAssetPrice).div(ONE_ETH));//underwaterAsset amout\r\n    res = res.mul(10 ** mkts[underwaterAsset].decimals);\r\n    res = res.div(10 ** mkts[collateralAsset].decimals);\r\n    return res;\r\n\r\n  }\r\n\r\n  //closeBorrowAmount_TargetUnderwaterAsset * (1+liquidationDiscount) * priceBorrow/priceCollateral\r\n  //underwaterAssetPrice * (1+liquidationDiscount) *closeBorrowAmount_TargetUnderwaterAsset) / collateralPrice\r\n  //underwater is borrow\r\n  // 计算清算时可用 closeBorrowAmount_TargetUnderwaterAsset 数量的 underwaterAsset 买到的 collateralAsset 资产数量\r\n  function calcAmountSeize(address underwaterAsset, address collateralAsset, uint underwaterAssetPrice, uint collateralPrice, uint closeBorrowAmount_TargetUnderwaterAsset) public view returns (uint) {\r\n    uint liquidationDiscount = mkts[underwaterAsset].liquidationDiscount;\r\n    uint onePlusLiquidationDiscount = (ONE_ETH).add(liquidationDiscount);\r\n    uint res = underwaterAssetPrice.mul(onePlusLiquidationDiscount);\r\n    res = res.mul(closeBorrowAmount_TargetUnderwaterAsset);\r\n    res = res.div(collateralPrice);\r\n    res = res.div(ONE_ETH);\r\n    res = res.mul(10**mkts[collateralAsset].decimals);\r\n    res = res.div(10**mkts[underwaterAsset].decimals);\r\n    return res;\r\n\r\n\r\n  }\r\n\r\n  struct LiquidateIR {\r\n    // we need these addresses in the struct for use with `emitLiquidationEvent` to avoid `CompilerError: Stack too deep, try removing local variables.`\r\n    address targetAccount;\r\n    address assetBorrow;\r\n    address liquidator;\r\n    address assetCollateral;\r\n\r\n    // borrow index and supply index are global to the asset, not specific to the user\r\n    uint newBorrowIndex_UnderwaterAsset;\r\n    uint newSupplyIndex_UnderwaterAsset;\r\n    uint newBorrowIndex_CollateralAsset;\r\n    uint newSupplyIndex_CollateralAsset;\r\n\r\n    // the target borrow's full balance with accumulated interest\r\n    uint currentBorrowBalance_TargetUnderwaterAsset;\r\n    // currentBorrowBalance_TargetUnderwaterAsset minus whatever gets repaid as part of the liquidation\r\n    uint updatedBorrowBalance_TargetUnderwaterAsset;\r\n\r\n    uint newTotalBorrows_ProtocolUnderwaterAsset;\r\n\r\n    uint startingBorrowBalance_TargetUnderwaterAsset;\r\n    uint startingSupplyBalance_TargetCollateralAsset;\r\n    uint startingSupplyBalance_LiquidatorCollateralAsset;\r\n\r\n    uint currentSupplyBalance_TargetCollateralAsset;\r\n    uint updatedSupplyBalance_TargetCollateralAsset;\r\n\r\n    // If liquidator already has a balance of collateralAsset, we will accumulate\r\n    // interest on it before transferring seized collateral from the borrower.\r\n    uint currentSupplyBalance_LiquidatorCollateralAsset;\r\n    // This will be the liquidator's accumulated balance of collateral asset before the liquidation (if any)\r\n    // plus the amount seized from the borrower.\r\n    uint updatedSupplyBalance_LiquidatorCollateralAsset;\r\n\r\n    uint newTotalSupply_ProtocolCollateralAsset;\r\n    uint currentCash_ProtocolUnderwaterAsset;\r\n    uint updatedCash_ProtocolUnderwaterAsset;\r\n\r\n    // cash does not change for collateral asset\r\n\r\n    //mkts[t]\r\n    uint newSupplyRateMantissa_ProtocolUnderwaterAsset;\r\n    uint newBorrowRateMantissa_ProtocolUnderwaterAsset;\r\n\r\n    // Why no variables for the interest rates for the collateral asset?\r\n    // We don't need to calculate new rates for the collateral asset since neither cash nor borrows change\r\n\r\n    uint discountedRepayToEvenAmount;\r\n\r\n    //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow) (discountedBorrowDenominatedCollateral)\r\n    uint discountedBorrowDenominatedCollateral;\r\n\r\n    uint maxCloseableBorrowAmount_TargetUnderwaterAsset;\r\n    uint closeBorrowAmount_TargetUnderwaterAsset;\r\n    uint seizeSupplyAmount_TargetCollateralAsset;\r\n\r\n    uint collateralPrice;\r\n    uint underwaterAssetPrice;\r\n  }\r\n\r\n  // 获取可清算数量最大值\r\n  function calcMaxLiquidateAmount(address targetAccount, address assetBorrow, address assetCollateral) external view returns (uint) {\r\n      require(msg.sender != targetAccount, \"can't self-liquidate\");\r\n      LiquidateIR memory tmp;\r\n\r\n      uint blockDelta = now - mkts[assetBorrow].accrualBlockNumber;\r\n\r\n      Market storage borrowMarket = mkts[assetBorrow];\r\n      Market storage collateralMarket = mkts[assetCollateral];\r\n      Balance storage borrowBalance_TargeUnderwaterAsset = accountBorrowSnapshot[assetBorrow][targetAccount];\r\n      Balance storage supplyBalance_TargetCollateralAsset = accountSupplySnapshot[assetCollateral][targetAccount];\r\n      \r\n      tmp.newSupplyIndex_CollateralAsset = uint(collateralMarket.irm.pert(int(collateralMarket.supplyIndex), collateralMarket.supplyRate, int(blockDelta)));\r\n      tmp.newBorrowIndex_UnderwaterAsset = uint(borrowMarket.irm.pert(int(borrowMarket.borrowIndex), borrowMarket.demondRate, int(blockDelta)));\r\n      tmp.currentSupplyBalance_TargetCollateralAsset = uint(collateralMarket.irm.calculateBalance(int(supplyBalance_TargetCollateralAsset.principal), int(supplyBalance_TargetCollateralAsset.interestIndex), int(tmp.newSupplyIndex_CollateralAsset)));\r\n      tmp.currentBorrowBalance_TargetUnderwaterAsset = uint(borrowMarket.irm.calculateBalance(int(borrowBalance_TargeUnderwaterAsset.principal), int(borrowBalance_TargeUnderwaterAsset.interestIndex), int(tmp.newBorrowIndex_UnderwaterAsset)));\r\n\r\n      bool ok;\r\n      (tmp.collateralPrice, ok) = fetchAssetPrice(assetCollateral);\r\n      require(ok, \"fail to get collateralPrice\");\r\n\r\n      (tmp.underwaterAssetPrice, ok) = fetchAssetPrice(assetBorrow);\r\n      require(ok, \"fail to get underwaterAssetPrice\");\r\n\r\n      tmp.discountedBorrowDenominatedCollateral = calcDiscountedBorrowDenominatedCollateral(assetBorrow, assetCollateral, tmp.underwaterAssetPrice, tmp.collateralPrice, tmp.currentSupplyBalance_TargetCollateralAsset);\r\n      tmp.discountedRepayToEvenAmount = calcDiscountedRepayToEvenAmount(targetAccount, assetBorrow, tmp.underwaterAssetPrice);\r\n      tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(tmp.currentBorrowBalance_TargetUnderwaterAsset, tmp.discountedBorrowDenominatedCollateral);\r\n      tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset, tmp.discountedRepayToEvenAmount);\r\n\r\n      return tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset;\r\n  }\r\n\r\n\r\n  // 清算\r\n  function liquidateBorrowPawn(address targetAccount, address assetBorrow, address assetCollateral, uint requestedAmountClose) external payable nonReentrant returns (uint) {\r\n        require(msg.sender != targetAccount, \"can't self-liquidate\");\r\n        LiquidateIR memory tmp;\r\n        // Copy these addresses into the struct for use with `emitLiquidationEvent`\r\n        // We'll use tmp.liquidator inside this function for clarity vs using msg.sender.\r\n        tmp.targetAccount = targetAccount;\r\n        tmp.assetBorrow = assetBorrow;\r\n        tmp.liquidator = msg.sender;\r\n        tmp.assetCollateral = assetCollateral;\r\n\r\n        uint blockDelta = now - mkts[assetBorrow].accrualBlockNumber;\r\n\r\n        Market storage borrowMarket = mkts[assetBorrow];\r\n        Market storage collateralMarket = mkts[assetCollateral];\r\n        // 被清算人的借币余额与存币余额\r\n        Balance storage borrowBalance_TargeUnderwaterAsset = accountBorrowSnapshot[assetBorrow][targetAccount];\r\n        Balance storage supplyBalance_TargetCollateralAsset = accountSupplySnapshot[assetCollateral][targetAccount];\r\n\r\n        // Liquidator might already hold some of the collateral asset\r\n        // 清算人自己的质押币资产\r\n        Balance storage supplyBalance_LiquidatorCollateralAsset = accountSupplySnapshot[assetCollateral][tmp.liquidator];\r\n\r\n        bool ok;\r\n        (tmp.collateralPrice, ok) = fetchAssetPrice(assetCollateral);\r\n        require(ok, \"fail to get collateralPrice\");\r\n\r\n        (tmp.underwaterAssetPrice, ok) = fetchAssetPrice(assetBorrow);\r\n        require(ok, \"fail to get underwaterAssetPrice\");\r\n\r\n        // 更新+被+清算人的借币余额\r\n        tmp.newBorrowIndex_UnderwaterAsset = uint(borrowMarket.irm.pert(int(borrowMarket.borrowIndex), borrowMarket.demondRate, int(blockDelta)));\r\n        tmp.currentBorrowBalance_TargetUnderwaterAsset = uint(borrowMarket.irm.calculateBalance(int(borrowBalance_TargeUnderwaterAsset.principal), int(borrowBalance_TargeUnderwaterAsset.interestIndex), int(tmp.newBorrowIndex_UnderwaterAsset)));\r\n\r\n        // 更新+被+清算人的存币余额\r\n        tmp.newSupplyIndex_CollateralAsset = uint(collateralMarket.irm.pert(int(collateralMarket.supplyIndex), collateralMarket.supplyRate, int(blockDelta)));\r\n        tmp.currentSupplyBalance_TargetCollateralAsset = uint(collateralMarket.irm.calculateBalance(int(supplyBalance_TargetCollateralAsset.principal), int(supplyBalance_TargetCollateralAsset.interestIndex), int(tmp.newSupplyIndex_CollateralAsset)));\r\n\r\n        // 更新清算人的此质押币余额\r\n        tmp.currentSupplyBalance_LiquidatorCollateralAsset = uint(collateralMarket.irm.calculateBalance(int(supplyBalance_LiquidatorCollateralAsset.principal), int(supplyBalance_LiquidatorCollateralAsset.interestIndex), int(tmp.newSupplyIndex_CollateralAsset)));\r\n\r\n        // 更新市场的此质押币余额\r\n        tmp.newTotalSupply_ProtocolCollateralAsset = collateralMarket.totalSupply.add(tmp.currentSupplyBalance_TargetCollateralAsset).sub(supplyBalance_TargetCollateralAsset.principal);\r\n        tmp.newTotalSupply_ProtocolCollateralAsset = tmp.newTotalSupply_ProtocolCollateralAsset.add(tmp.currentSupplyBalance_LiquidatorCollateralAsset).sub(supplyBalance_LiquidatorCollateralAsset.principal);\r\n\r\n        // 计算可清算最大值\r\n        tmp.discountedBorrowDenominatedCollateral = calcDiscountedBorrowDenominatedCollateral(assetBorrow, assetCollateral, tmp.underwaterAssetPrice, tmp.collateralPrice, tmp.currentSupplyBalance_TargetCollateralAsset);\r\n        tmp.discountedRepayToEvenAmount = calcDiscountedRepayToEvenAmount(targetAccount, assetBorrow, tmp.underwaterAssetPrice);\r\n        tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(tmp.currentBorrowBalance_TargetUnderwaterAsset, tmp.discountedBorrowDenominatedCollateral);\r\n        tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset, tmp.discountedRepayToEvenAmount);\r\n\r\n        // 设置实际清算量\r\n        if (requestedAmountClose == uint(-1)) {\r\n            tmp.closeBorrowAmount_TargetUnderwaterAsset = tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset;\r\n        } else {\r\n            tmp.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\r\n        }\r\n        require(tmp.closeBorrowAmount_TargetUnderwaterAsset <= tmp.maxCloseableBorrowAmount_TargetUnderwaterAsset, \"closeBorrowAmount > maxCloseableBorrowAmount err\");\r\n        if (assetBorrow == address(0)) {\r\n            // 如果是 ETH，需要保证清算人传入的 value 大于所需的量\r\n            require(msg.value >= tmp.closeBorrowAmount_TargetUnderwaterAsset, \"Not enough ETH\");\r\n        } else {\r\n            // 如果是 ERC20， 需要保证清算人要有足够的资产\r\n            require(getBalanceOf(assetBorrow, tmp.liquidator) >= tmp.closeBorrowAmount_TargetUnderwaterAsset, \"insufficient balance\");\r\n        }\r\n\r\n        // 计算清算人实际清算得到的此质押币数量\r\n        tmp.seizeSupplyAmount_TargetCollateralAsset = calcAmountSeize(assetBorrow, assetCollateral, tmp.underwaterAssetPrice, tmp.collateralPrice, tmp.closeBorrowAmount_TargetUnderwaterAsset);\r\n\r\n        // 被清算人借币余额减少\r\n        tmp.updatedBorrowBalance_TargetUnderwaterAsset = tmp.currentBorrowBalance_TargetUnderwaterAsset.sub(tmp.closeBorrowAmount_TargetUnderwaterAsset);\r\n        // 更新借币市场总量\r\n        tmp.newTotalBorrows_ProtocolUnderwaterAsset = borrowMarket.totalBorrows.add(tmp.updatedBorrowBalance_TargetUnderwaterAsset).sub(borrowBalance_TargeUnderwaterAsset.principal);\r\n\r\n        tmp.currentCash_ProtocolUnderwaterAsset = getCash(assetBorrow);\r\n        // 如果是 ERC-20 代币，加 amount\r\n        // 如果是 ETH，则已经在函数调用的时候转入了，就不用加了\r\n        tmp.updatedCash_ProtocolUnderwaterAsset = assetBorrow != address(0) ? tmp.currentCash_ProtocolUnderwaterAsset.add(tmp.closeBorrowAmount_TargetUnderwaterAsset) : tmp.currentCash_ProtocolUnderwaterAsset;\r\n\r\n        // 计算存借比率\r\n        tmp.newSupplyIndex_UnderwaterAsset = uint(borrowMarket.irm.pert(int(borrowMarket.supplyIndex), borrowMarket.demondRate, int(blockDelta)));\r\n        borrowMarket.supplyRate = borrowMarket.irm.getDepositRate(int(tmp.updatedCash_ProtocolUnderwaterAsset), int(tmp.newTotalBorrows_ProtocolUnderwaterAsset));\r\n        borrowMarket.demondRate = borrowMarket.irm.getLoanRate(int(tmp.updatedCash_ProtocolUnderwaterAsset), int(tmp.newTotalBorrows_ProtocolUnderwaterAsset));\r\n        tmp.newBorrowIndex_CollateralAsset = uint(collateralMarket.irm.pert(int(collateralMarket.supplyIndex), collateralMarket.demondRate, int(blockDelta)));\r\n\r\n        // 被清算人存币余额减少\r\n        tmp.updatedSupplyBalance_TargetCollateralAsset = tmp.currentSupplyBalance_TargetCollateralAsset.sub(tmp.seizeSupplyAmount_TargetCollateralAsset);\r\n        // 清算人存币余额增加\r\n        tmp.updatedSupplyBalance_LiquidatorCollateralAsset = tmp.currentSupplyBalance_LiquidatorCollateralAsset.add(tmp.seizeSupplyAmount_TargetCollateralAsset);\r\n\r\n        borrowMarket.accrualBlockNumber = now;\r\n        borrowMarket.totalBorrows = tmp.newTotalBorrows_ProtocolUnderwaterAsset;\r\n        borrowMarket.supplyIndex = tmp.newSupplyIndex_UnderwaterAsset;\r\n        borrowMarket.borrowIndex = tmp.newBorrowIndex_UnderwaterAsset;\r\n\r\n        collateralMarket.accrualBlockNumber = now;\r\n        collateralMarket.totalSupply = tmp.newTotalSupply_ProtocolCollateralAsset;\r\n        collateralMarket.supplyIndex = tmp.newSupplyIndex_CollateralAsset;\r\n        collateralMarket.borrowIndex = tmp.newBorrowIndex_CollateralAsset;\r\n\r\n        tmp.startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset.principal; // save for use in event\r\n        borrowBalance_TargeUnderwaterAsset.principal = tmp.updatedBorrowBalance_TargetUnderwaterAsset;\r\n        borrowBalance_TargeUnderwaterAsset.interestIndex = tmp.newBorrowIndex_UnderwaterAsset;\r\n\r\n        tmp.startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset.principal; // save for use in event\r\n        supplyBalance_TargetCollateralAsset.principal = tmp.updatedSupplyBalance_TargetCollateralAsset;\r\n        supplyBalance_TargetCollateralAsset.interestIndex = tmp.newSupplyIndex_CollateralAsset;\r\n\r\n        tmp.startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset.principal; // save for use in event\r\n        supplyBalance_LiquidatorCollateralAsset.principal = tmp.updatedSupplyBalance_LiquidatorCollateralAsset;\r\n        supplyBalance_LiquidatorCollateralAsset.interestIndex = tmp.newSupplyIndex_CollateralAsset;\r\n\r\n        setLiquidateInfoMap(tmp.targetAccount, tmp.liquidator, tmp.assetCollateral, assetBorrow, tmp.seizeSupplyAmount_TargetCollateralAsset, tmp.closeBorrowAmount_TargetUnderwaterAsset);\r\n\r\n        safeTransferFrom(assetBorrow, tmp.liquidator.make_payable(), address(this), address(this).make_payable(), tmp.closeBorrowAmount_TargetUnderwaterAsset, msg.value);\r\n\r\n        emit LiquidateBorrowPawnLog(tmp.targetAccount, assetBorrow,\r\n        tmp.updatedBorrowBalance_TargetUnderwaterAsset,\r\n        tmp.liquidator,\r\n        tmp.assetCollateral,\r\n        tmp.updatedSupplyBalance_TargetCollateralAsset\r\n        );\r\n\r\n        return 0;\r\n  }\r\n\r\n\r\nfunction safeTransferFrom(address token, address payable owner, address spender, address payable to, uint256 amount, uint256 msgValue) internal returns (uint256) {\r\n  require(amount > 0, \"invalid safeTransferFrom amount\");\r\n  // require(token != address(0), \"invalid token address!\");\r\n\r\n  if (owner != spender && token != address(0)) {\r\n      // 转入ERC20代币\r\n      require(IERC20(token).allowance(owner, spender) >= amount, \"Insufficient allowance\");\r\n  }\r\n  if (token != address(0)) {\r\n    require(IERC20(token).balanceOf(owner) >= amount, \"Insufficient balance\");\r\n  } else if (owner == spender) {\r\n    // eth， owner == spender 即转出，需要校验owner的eth余额\r\n    require(owner.balance >= amount, \"Insufficient eth balance\");\r\n  }\r\n\r\n  if (owner != spender) {\r\n    // 转入\r\n    if (token != address(0)) {\r\n      // ERC20代币 transferFrom 转入\r\n      IERC20(token).safeTransferFrom(owner, to, amount);\r\n    } else if (msgValue > 0 && msgValue > amount) {\r\n      // 还钱时，用户多还了的 eth 需要返还\r\n      owner.transfer(msgValue.sub(amount));\r\n    }\r\n    // eth 已从 payable 函数调用时转入\r\n  } else {\r\n    // 转出\r\n    if (token != address(0)) {\r\n      // ERC20转出\r\n      IERC20(token).safeTransfer(to, amount);\r\n    } else {\r\n      // 参数设置， msgValue 大于0，即还款或清算逻辑，实际还的钱大于需要还的钱，需要返回多余的钱\r\n      // msgValue 等于 0，借钱或取钱逻辑，直接转出 amount 数量的币\r\n      if (msgValue > 0 && msgValue > amount) {\r\n        to.transfer(msgValue.sub(amount));\r\n      } else if (msgValue == 0) {\r\n        to.transfer(amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n  // 管理员取钱\r\n  function withdrawPawnEquity(address t, uint amount) external nonReentrant onlyAdmin returns (uint) {\r\n    uint cash = getCash(t);\r\n    uint equity = cash.add(mkts[t].totalBorrows).sub(mkts[t].totalSupply);\r\n    require(equity >= amount, \"insufficient equity amount\");\r\n    safeTransferFrom(t, address(this).make_payable(), address(this), admin.make_payable(), amount, 0);\r\n    emit WithdrawPawnEquityLog(t, equity, amount, admin);\r\n    return 0;\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beg\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"BorrowPawnLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tBorrow\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBorrow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tCol\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endCol\",\"type\":\"uint256\"}],\"name\":\"LiquidateBorrowPawnLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beg\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"RepayFastBorrowLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beg\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"SupplyPawnLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"equityAvailableBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"WithdrawPawnEquityLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beg\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"WithdrawPawnLog\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BorrowPawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_ETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountBorrowSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPnl\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountSupplySnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPnl\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"addCollateralMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"calcAccountAllTokenValuesLeverageInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"calcAccountLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"calcAccountTokenValuesInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"calcAccountTokenValuesLeverageInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"underwaterAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underwaterAssetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeBorrowAmount_TargetUnderwaterAsset\",\"type\":\"uint256\"}],\"name\":\"calcAmountSeize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"calcBorrowAmountWithFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"underwaterAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underwaterAssetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCurrent_TargetCollateralAsset\",\"type\":\"uint256\"}],\"name\":\"calcDiscountedBorrowDenominatedCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underwaterAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underwaterAssetPrice\",\"type\":\"uint256\"}],\"name\":\"calcDiscountedRepayToEvenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetBorrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetCollateral\",\"type\":\"address\"}],\"name\":\"calcMaxLiquidateAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdministration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collateralTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultOriginationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"fetchAssetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdValue\",\"type\":\"uint256\"}],\"name\":\"getAssetAmountForValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getBorrowBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getBorrowBalanceInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getBorrowBalanceLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getBorrowPnl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getBorrowPnlInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateralMarketsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"}],\"name\":\"getPriceForAssetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"}],\"name\":\"getPriceForAssetAmountMulCollatRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getSupplyBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getSupplyBalanceInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getSupplyPnl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getSupplyPnlInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getTotalBorrowPnl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getTotalSupplyPnl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"index\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"irm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"initCollateralMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialInterestIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestRateDenomitor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetBorrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetCollateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedAmountClose\",\"type\":\"uint256\"}],\"name\":\"liquidateBorrowPawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidateIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidateInfoMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"targetAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetCollatera\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetBorrow\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidateAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"loanToDepositRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mkts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"accrualBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyRate\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"demondRate\",\"type\":\"int256\"},{\"internalType\":\"contract IInterestRateModel\",\"name\":\"irm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPledgeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationDiscount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleInstance\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"originationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"proposeNewAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayFastBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"setDecimals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setInitialTimestamp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"irm\",\"type\":\"address\"}],\"name\":\"setInterestRateModel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidationDiscount\",\"type\":\"uint256\"}],\"name\":\"setLiquidationDiscount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minPledgeRate\",\"type\":\"uint256\"}],\"name\":\"setMinPledgeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supplyPawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawPawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPawnEquity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PoolPawn","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"istanbul","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e578ec27f8da722ae7b6508dfa7b5b029365010770d88060b29a126c21d4eb6f"}]}