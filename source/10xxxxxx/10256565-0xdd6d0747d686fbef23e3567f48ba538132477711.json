{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\n/* solium-disable */\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (uint256(self) & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (uint256(self) & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (uint256(self) & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (uint256(self) & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (uint256(self) & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-terminated utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice memory self) internal pure returns (slice memory) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice memory self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice memory self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask = uint256(-1); // 0xffff...\r\n                if(shortest < 32) {\r\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint256 diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            l = 1;\r\n        } else if(b < 0xE0) {\r\n            l = 2;\r\n        } else if(b < 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice memory self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if(b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if(b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                ptr = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr <= selfptr)\r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr + needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for(uint i = 0; i < parts.length; i++)\r\n            length += parts[i]._len;\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for(uint i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ENS.sol\r\n// with few modifications.\r\n\r\n\r\n\r\n/**\r\n * ENS Registry interface.\r\n */\r\ninterface ENSRegistry {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\n\r\n/**\r\n * ENS Resolver interface.\r\n */\r\nabstract contract ENSResolver {\r\n    function addr(bytes32 _node) public view virtual returns (address);\r\n    function setAddr(bytes32 _node, address _addr) public virtual;\r\n    function name(bytes32 _node) public view virtual returns (string memory);\r\n    function setName(bytes32 _node, string memory _name) public virtual;\r\n}\r\n\r\n/**\r\n * ENS Reverse Registrar interface.\r\n */\r\nabstract contract ENSReverseRegistrar {\r\n    function claim(address _owner) public virtual returns (bytes32 _node);\r\n    function claimWithResolver(address _owner, address _resolver) public virtual returns (bytes32);\r\n    function setName(string memory _name) public virtual returns (bytes32);\r\n    function node(address _addr) public view virtual returns (bytes32);\r\n}\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title Wallet\r\n/// @dev Base contract for smart wallets.\r\n///      Sub-contracts must NOT use non-default constructor to initialize\r\n///      wallet states, instead, `init` shall be used. This is to enable\r\n///      proxies to be deployed in front of the real wallet contract for\r\n///      saving gas.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\ninterface Wallet\r\n{\r\n    function owner() external view returns (address);\r\n\r\n    /// @dev Set a new owner.\r\n    function setOwner(address newOwner) external;\r\n\r\n    /// @dev Set up this wallet by assigning an original owner and a\r\n    ///      list of initial modules. For each module, its `init` method\r\n    ///      will be called with `address(this)` as the parameter.\r\n    ///\r\n    ///      Note that calling this method more than once will throw.\r\n    ///\r\n    /// @param _controller The Controller instance.\r\n    /// @param _owner The owner of this wallet, must not be address(0).\r\n    /// @param _boostrapModule The bootstrap module.\r\n    function setup(address _controller, address _owner, address _boostrapModule) external;\r\n\r\n    /// @dev Adds a new module. The `init` method of the module\r\n    ///      will be called with `address(this)` as the parameter.\r\n    ///      This method must throw if the module has already been added.\r\n    /// @param _module The module's address.\r\n    function addModule(address _module) external;\r\n\r\n    /// @dev Removes an existing module. This method must throw if the module\r\n    ///      has NOT been added or the module is the wallet's only module.\r\n    /// @param _module The module's address.\r\n    function removeModule(address _module) external;\r\n\r\n    /// @dev Checks if a module has been added to this wallet.\r\n    /// @param _module The module to check.\r\n    /// @return True if the module exists; False otherwise.\r\n    function hasModule(address _module) external view returns (bool);\r\n\r\n    /// @dev Binds a method from the given module to this\r\n    ///      wallet so the method can be invoked using this wallet's default\r\n    ///      function.\r\n    ///      Note that this method must throw when the given module has\r\n    ///      not been added to this wallet.\r\n    /// @param _method The method's 4-byte selector.\r\n    /// @param _module The module's address. Use address(0) to unbind the method.\r\n    function bindMethod(bytes4 _method, address _module) external;\r\n\r\n    /// @dev Returns the module the given method has been bound to.\r\n    /// @param _method The method's 4-byte selector.\r\n    /// @return _module The address of the bound module. If no binding exists,\r\n    ///                 returns address(0) instead.\r\n    function boundMethodModule(bytes4 _method) external view returns (address _module);\r\n\r\n    /// @dev Performs generic transactions. Any module that has been added to this\r\n    ///      wallet can use this method to transact on any third-party contract with\r\n    ///      msg.sender as this wallet itself.\r\n    ///\r\n    ///      This method will emit `Transacted` event if it doesn't throw.\r\n    ///\r\n    ///      Note: this method must ONLY allow invocations from a module that has\r\n    ///      been added to this wallet. The wallet owner shall NOT be permitted\r\n    ///      to call this method directly.\r\n    ///\r\n    /// @param mode The transaction mode, 1 for CALL, 2 for DELEGATECALL.\r\n    /// @param to The desitination address.\r\n    /// @param value The amount of Ether to transfer.\r\n    /// @param data The data to send over using `to.call{value: value}(data)`\r\n    /// @return returnData The transaction's return value.\r\n    function transact(\r\n        uint8    mode,\r\n        address  to,\r\n        uint     value,\r\n        bytes    calldata data\r\n        )\r\n        external\r\n        returns (bytes memory returnData);\r\n}\r\n\r\n// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ENSConsumer.sol\r\n// with few modifications.\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ENSConsumer\r\n * @dev Helper contract to resolve ENS names.\r\n * @author Julien Niset - <julien@argent.im>\r\n */\r\ncontract ENSConsumer {\r\n\r\n    using strings for *;\r\n\r\n    // namehash('addr.reverse')\r\n    bytes32 constant public ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n    // the address of the ENS registry\r\n    address ensRegistry;\r\n\r\n    /**\r\n    * @dev No address should be provided when deploying on Mainnet to avoid storage cost. The\r\n    * contract will use the hardcoded value.\r\n    */\r\n    constructor(address _ensRegistry) public {\r\n        ensRegistry = _ensRegistry;\r\n    }\r\n\r\n    /**\r\n    * @dev Resolves an ENS name to an address.\r\n    * @param _node The namehash of the ENS name.\r\n    */\r\n    function resolveEns(bytes32 _node) public view returns (address) {\r\n        address resolver = getENSRegistry().resolver(_node);\r\n        return ENSResolver(resolver).addr(_node);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the official ENS registry.\r\n    */\r\n    function getENSRegistry() public view returns (ENSRegistry) {\r\n        return ENSRegistry(ensRegistry);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the official ENS reverse registrar.\r\n    */\r\n    function getENSReverseRegistrar() public view returns (ENSReverseRegistrar) {\r\n        return ENSReverseRegistrar(getENSRegistry().owner(ADDR_REVERSE_NODE));\r\n    }\r\n}\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title AddressSet\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract AddressSet\r\n{\r\n    struct Set\r\n    {\r\n        address[] addresses;\r\n        mapping (address => uint) positions;\r\n        uint count;\r\n    }\r\n    mapping (bytes32 => Set) private sets;\r\n\r\n    function addAddressToSet(\r\n        bytes32 key,\r\n        address addr,\r\n        bool maintainList\r\n        ) internal\r\n    {\r\n        Set storage set = sets[key];\r\n        require(set.positions[addr] == 0, \"ALREADY_IN_SET\");\r\n\r\n        if (maintainList) {\r\n            require(set.addresses.length == set.count, \"PREVIOUSLY_NOT_MAINTAILED\");\r\n            set.addresses.push(addr);\r\n        } else {\r\n            require(set.addresses.length == 0, \"MUST_MAINTAIN\");\r\n        }\r\n\r\n        set.count += 1;\r\n        set.positions[addr] = set.count;\r\n    }\r\n\r\n    function removeAddressFromSet(\r\n        bytes32 key,\r\n        address addr\r\n        )\r\n        internal\r\n    {\r\n        Set storage set = sets[key];\r\n        uint pos = set.positions[addr];\r\n        require(pos != 0, \"NOT_IN_SET\");\r\n\r\n        delete set.positions[addr];\r\n        set.count -= 1;\r\n\r\n        if (set.addresses.length > 0) {\r\n            address lastAddr = set.addresses[set.count];\r\n            if (lastAddr != addr) {\r\n                set.addresses[pos - 1] = lastAddr;\r\n                set.positions[lastAddr] = pos;\r\n            }\r\n            set.addresses.pop();\r\n        }\r\n    }\r\n\r\n    function removeSet(bytes32 key)\r\n        internal\r\n    {\r\n        delete sets[key];\r\n    }\r\n\r\n    function isAddressInSet(\r\n        bytes32 key,\r\n        address addr\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return sets[key].positions[addr] != 0;\r\n    }\r\n\r\n    function numAddressesInSet(bytes32 key)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        Set storage set = sets[key];\r\n        return set.count;\r\n    }\r\n\r\n    function addressesInSet(bytes32 key)\r\n        internal\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        Set storage set = sets[key];\r\n        require(set.count == set.addresses.length, \"NOT_MAINTAINED\");\r\n        return sets[key].addresses;\r\n    }\r\n}/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title ERC20 Token Interface\r\n/// @dev see https://github.com/ethereum/EIPs/issues/20\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nabstract contract ERC20\r\n{\r\n    function totalSupply()\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint);\r\n\r\n    function balanceOf(\r\n        address who\r\n        )\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n        )\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint value\r\n        )\r\n        public\r\n        virtual\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint    value\r\n        )\r\n        public\r\n        virtual\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address spender,\r\n        uint    value\r\n        )\r\n        public\r\n        virtual\r\n        returns (bool);\r\n}\r\n// Copied from https://eips.ethereum.org/EIPS/eip-1271.\r\n\r\n\r\n\r\nabstract contract ERC1271 {\r\n\r\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\r\n    bytes4 constant internal MAGICVALUE = 0x20c13b0b;\r\n\r\n    /**\r\n     * @dev Should return whether the signature provided is valid for the provided data\r\n     * @param _data Arbitrary length data signed on the behalf of address(this)\r\n     * @param _signature Signature byte array associated with _data\r\n     *\r\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\r\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n     * MUST allow external calls\r\n     */\r\n    function isValidSignature(\r\n        bytes memory _data,\r\n        bytes memory _signature)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes4 magicValue);\r\n}//Mainly taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n\r\n\r\nlibrary BytesUtil {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\r\n        require(_bytes.length >= (_start + 8));\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\r\n        require(_bytes.length >= (_start + 12));\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\r\n        require(_bytes.length >= (_start + 16));\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\r\n        require(_bytes.length >= (_start + 4));\r\n        bytes4 tempBytes4;\r\n\r\n        assembly {\r\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes4;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint\r\n{\r\n    function mul(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\r\n    }\r\n\r\n    function sub(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        require(b <= a, \"SUB_UNDERFLOW\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"ADD_OVERFLOW\");\r\n    }\r\n}\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title Utility Functions for addresses\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary AddressUtil\r\n{\r\n    using AddressUtil for *;\r\n\r\n    function isContract(\r\n        address addr\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint32 size;\r\n        assembly { size := extcodesize(addr) }\r\n        return (size > 0);\r\n    }\r\n\r\n    function toPayable(\r\n        address addr\r\n        )\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return address(uint160(addr));\r\n    }\r\n\r\n    // Works like address.send but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETH(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n        address payable recipient = to.toPayable();\r\n        /* solium-disable-next-line */\r\n        (success, ) = recipient.call{value: amount, gas: gasLimit}(\"\");\r\n    }\r\n\r\n    // Works like address.transfer but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETHAndVerify(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        success = to.sendETH(amount, gasLimit);\r\n        require(success, \"TRANSFER_FAILURE\");\r\n    }\r\n}\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/// @title DataStore\r\n/// @dev Modules share states by accessing the same storage instance.\r\n///      Using ModuleStorage will achieve better module decoupling.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\ncontract DataStore\r\n{\r\n  modifier onlyWalletModule(address wallet)\r\n    {\r\n        require(Wallet(wallet).hasModule(msg.sender), \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n}/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\nlibrary Data\r\n{\r\n    struct Guardian\r\n    {\r\n        address  addr;\r\n        uint     group;\r\n        uint     validSince;\r\n        uint     validUntil;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title SecurityStore\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\ncontract SecurityStore is DataStore\r\n{\r\n    struct Wallet\r\n    {\r\n        address    inheritor;\r\n        uint128    lastActive; // the latest timestamp the owner is considered to be active\r\n        uint128    lock;\r\n        address    lockedBy;   // the module that locked the wallet.\r\n\r\n        Data.Guardian[]            guardians;\r\n        mapping (address => uint)  guardianIdx;\r\n    }\r\n\r\n    mapping (address => Wallet) public wallets;\r\n\r\n    constructor() public DataStore() {}\r\n\r\n    function isGuardian(\r\n        address wallet,\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        Data.Guardian memory guardian = getGuardian(wallet, addr);\r\n        return guardian.addr != address(0) && isGuardianActive(guardian);\r\n    }\r\n\r\n    function isGuardianOrPendingAddition(\r\n        address wallet,\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        Data.Guardian memory guardian = getGuardian(wallet, addr);\r\n        return guardian.addr != address(0) && (isGuardianActive(guardian) || isGuardianPendingAddition(guardian));\r\n    }\r\n\r\n    function getGuardian(\r\n        address wallet,\r\n        address guardianAddr\r\n        )\r\n        public\r\n        view\r\n        returns (Data.Guardian memory)\r\n    {\r\n        uint index = wallets[wallet].guardianIdx[guardianAddr];\r\n        if (index > 0) {\r\n            return wallets[wallet].guardians[index-1];\r\n        }\r\n    }\r\n\r\n    // @dev Returns active guardians.\r\n    function guardians(address wallet)\r\n        public\r\n        view\r\n        returns (Data.Guardian[] memory _guardians)\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        _guardians = new Data.Guardian[](w.guardians.length);\r\n        uint index = 0;\r\n        for (uint i = 0; i < w.guardians.length; i++) {\r\n            Data.Guardian memory g = w.guardians[i];\r\n            if (isGuardianActive(g)) {\r\n                _guardians[index] = g;\r\n                index ++;\r\n            }\r\n        }\r\n        assembly { mstore(_guardians, index) }\r\n    }\r\n\r\n    // @dev Returns the number of active guardians.\r\n    function numGuardians(address wallet)\r\n        public\r\n        view\r\n        returns (uint count)\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        for (uint i = 0; i < w.guardians.length; i++) {\r\n            if (isGuardianActive(w.guardians[i])) {\r\n                count ++;\r\n            }\r\n        }\r\n    }\r\n\r\n    // @dev Returns guardians who are either active or pending addition.\r\n    function guardiansWithPending(address wallet)\r\n        public\r\n        view\r\n        returns (Data.Guardian[] memory _guardians)\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        _guardians = new Data.Guardian[](w.guardians.length);\r\n        uint index = 0;\r\n        for (uint i = 0; i < w.guardians.length; i++) {\r\n            Data.Guardian memory g = w.guardians[i];\r\n            if (isGuardianActive(g) || isGuardianPendingAddition(g)) {\r\n                _guardians[index] = g;\r\n                index ++;\r\n            }\r\n        }\r\n        assembly { mstore(_guardians, index) }\r\n    }\r\n\r\n    // @dev Returns the number of guardians who are active or pending addition.\r\n    function numGuardiansWithPending(address wallet)\r\n        public\r\n        view\r\n        returns (uint count)\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        for (uint i = 0; i < w.guardians.length; i++) {\r\n            Data.Guardian memory g = w.guardians[i];\r\n            if (isGuardianActive(g) || isGuardianPendingAddition(g)) {\r\n                count ++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function addGuardian(\r\n        address wallet,\r\n        address guardianAddr,\r\n        uint    group,\r\n        uint    validSince\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        cleanRemovedGuardians(wallet);\r\n\r\n        require(guardianAddr != address(0), \"ZERO_ADDRESS\");\r\n        Wallet storage w = wallets[wallet];\r\n\r\n        uint pos = w.guardianIdx[guardianAddr];\r\n        require(pos == 0, \"GUARDIAN_EXISTS\");\r\n\r\n        // Add the new guardian\r\n        Data.Guardian memory g = Data.Guardian(guardianAddr, group, validSince, 0);\r\n        w.guardians.push(g);\r\n        w.guardianIdx[guardianAddr] = w.guardians.length;\r\n    }\r\n\r\n    function cancelGuardianAddition(\r\n        address wallet,\r\n        address guardianAddr\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        cleanRemovedGuardians(wallet);\r\n\r\n        Wallet storage w = wallets[wallet];\r\n        uint idx = w.guardianIdx[guardianAddr];\r\n        require(idx > 0, \"GUARDIAN_NOT_EXISTS\");\r\n        require(\r\n            isGuardianPendingAddition(w.guardians[idx - 1]),\r\n            \"NOT_PENDING_ADDITION\"\r\n        );\r\n\r\n        Data.Guardian memory lastGuardian = w.guardians[w.guardians.length - 1];\r\n        if (guardianAddr != lastGuardian.addr) {\r\n            w.guardians[idx - 1] = lastGuardian;\r\n            w.guardianIdx[lastGuardian.addr] = idx;\r\n        }\r\n        w.guardians.pop();\r\n        delete w.guardianIdx[guardianAddr];\r\n    }\r\n\r\n    function removeGuardian(\r\n        address wallet,\r\n        address guardianAddr,\r\n        uint    validUntil\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        cleanRemovedGuardians(wallet);\r\n\r\n        Wallet storage w = wallets[wallet];\r\n        uint idx = w.guardianIdx[guardianAddr];\r\n        require(idx > 0, \"GUARDIAN_NOT_EXISTS\");\r\n\r\n        w.guardians[idx - 1].validUntil = validUntil;\r\n    }\r\n\r\n    function removeAllGuardians(address wallet)\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n         Wallet storage w = wallets[wallet];\r\n         for (uint i = 0; i < w.guardians.length; i++) {\r\n            delete w.guardianIdx[w.guardians[i].addr];\r\n         }\r\n         delete w.guardians;\r\n    }\r\n\r\n    function cancelGuardianRemoval(\r\n        address wallet,\r\n        address guardianAddr\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        cleanRemovedGuardians(wallet);\r\n\r\n        Wallet storage w = wallets[wallet];\r\n        uint idx = w.guardianIdx[guardianAddr];\r\n        require(idx > 0, \"GUARDIAN_NOT_EXISTS\");\r\n\r\n        require(\r\n            isGuardianPendingRemoval(w.guardians[idx - 1]),\r\n            \"NOT_PENDING_REMOVAL\"\r\n         );\r\n\r\n        w.guardians[idx - 1].validUntil = 0;\r\n    }\r\n\r\n    function getLock(address wallet)\r\n        public\r\n        view\r\n        returns (uint _lock, address _module)\r\n    {\r\n        _lock = uint(wallets[wallet].lock);\r\n        _module = wallets[wallet].lockedBy;\r\n    }\r\n\r\n    function setLock(\r\n        address wallet,\r\n        uint    lock\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        require(lock == 0 || lock > now, \"INVALID_LOCK_TIME\");\r\n        uint128 _lock = uint128(lock);\r\n        require(uint(_lock) == lock, \"LOCK_TOO_LARGE\");\r\n\r\n        wallets[wallet].lock = _lock;\r\n        wallets[wallet].lockedBy = msg.sender;\r\n    }\r\n\r\n    function touchLastActive(address wallet)\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        wallets[wallet].lastActive = uint128(now);\r\n    }\r\n\r\n    function inheritor(address wallet)\r\n        public\r\n        view\r\n        returns (\r\n            address who,\r\n            uint    lastActive\r\n        )\r\n    {\r\n        who = wallets[wallet].inheritor;\r\n        lastActive = uint(wallets[wallet].lastActive);\r\n    }\r\n\r\n    function setInheritor(address wallet, address who)\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        wallets[wallet].inheritor = who;\r\n        wallets[wallet].lastActive = uint128(now);\r\n    }\r\n\r\n    function cleanRemovedGuardians(address wallet)\r\n        private\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n\r\n        for (int i = int(w.guardians.length) - 1; i >= 0; i--) {\r\n            Data.Guardian memory g = w.guardians[uint(i)];\r\n            if (isGuardianExpired(g)) {\r\n                Data.Guardian memory lastGuardian = w.guardians[w.guardians.length - 1];\r\n\r\n                if (g.addr != lastGuardian.addr) {\r\n                    w.guardians[uint(i)] = lastGuardian;\r\n                    w.guardianIdx[lastGuardian.addr] = uint(i) + 1;\r\n                }\r\n                w.guardians.pop();\r\n                delete w.guardianIdx[g.addr];\r\n            }\r\n        }\r\n    }\r\n\r\n    function isGuardianActive(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.validSince > 0 && guardian.validSince <= now &&\r\n            !isGuardianExpired(guardian);\r\n    }\r\n\r\n    function isGuardianPendingAddition(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.validSince > now;\r\n    }\r\n\r\n    function isGuardianPendingRemoval(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.validUntil > now;\r\n    }\r\n\r\n    function isGuardianExpired(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.validUntil > 0 &&\r\n            guardian.validUntil <= now;\r\n    }\r\n\r\n}\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title ModuleRegistry\r\n/// @dev A registry for modules.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ninterface ModuleRegistry\r\n{\r\n    function registerModule(address module) external;\r\n    function deregisterModule(address module) external;\r\n    function isModuleRegistered(address module) external view returns (bool);\r\n    function modules() external view returns (address[] memory _modules);\r\n    function numOfModules() external view returns (uint);\r\n}\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title WalletRegistry\r\n/// @dev A registry for wallets.\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ninterface WalletRegistry\r\n{\r\n    function registerWallet(address wallet) external;\r\n    function isWalletRegistered(address addr) external view returns (bool);\r\n    function numOfWallets() external view returns (uint);\r\n}\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title QuotaStore\r\n/// @dev This store maintains daily spending quota for each wallet.\r\n///      A rolling daily limit is used.\r\ncontract QuotaStore is DataStore\r\n{\r\n    using MathUint for uint;\r\n\r\n    uint public defaultQuota;\r\n\r\n    struct Quota\r\n    {\r\n        uint    currentQuota; // 0 indicates default\r\n        uint    pendingQuota;\r\n        uint64  pendingUntil;\r\n        uint64  spentTimestamp;\r\n        uint    spentAmount;\r\n    }\r\n\r\n    mapping (address => Quota) public quotas;\r\n\r\n    event QuotaScheduled(\r\n        address indexed wallet,\r\n        uint            pendingQuota,\r\n        uint64          pendingUntil\r\n    );\r\n\r\n    constructor(uint _defaultQuota)\r\n        public\r\n        DataStore()\r\n    {\r\n        defaultQuota = _defaultQuota;\r\n    }\r\n\r\n    function changeQuota(\r\n        address wallet,\r\n        uint    newQuota,\r\n        uint    effectiveTime\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        quotas[wallet].currentQuota = currentQuota(wallet);\r\n        quotas[wallet].pendingQuota = newQuota;\r\n        quotas[wallet].pendingUntil = uint64(effectiveTime);\r\n\r\n        emit QuotaScheduled(\r\n            wallet,\r\n            newQuota,\r\n            quotas[wallet].pendingUntil\r\n        );\r\n    }\r\n\r\n    function checkAndAddToSpent(\r\n        address wallet,\r\n        uint    amount\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        require(hasEnoughQuota(wallet, amount), \"QUOTA_EXCEEDED\");\r\n        addToSpent(wallet, amount);\r\n    }\r\n\r\n    function addToSpent(\r\n        address wallet,\r\n        uint    amount\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        Quota storage q = quotas[wallet];\r\n        q.spentAmount = spentQuota(wallet).add(amount);\r\n        q.spentTimestamp = uint64(now);\r\n    }\r\n\r\n    function currentQuota(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        Quota storage q = quotas[wallet];\r\n        uint value = q.pendingUntil <= now ?\r\n            q.pendingQuota : q.currentQuota;\r\n\r\n        return value == 0 ? defaultQuota : value;\r\n    }\r\n\r\n    function pendingQuota(address wallet)\r\n        public\r\n        view\r\n        returns (\r\n            uint _pendingQuota,\r\n            uint _pendingUntil\r\n        )\r\n    {\r\n        Quota storage q = quotas[wallet];\r\n        if (q.pendingUntil > 0 && q.pendingUntil > now) {\r\n            _pendingQuota = q.pendingQuota > 0 ? q.pendingQuota : defaultQuota;\r\n            _pendingUntil = q.pendingUntil;\r\n        }\r\n    }\r\n\r\n    function spentQuota(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        Quota storage q = quotas[wallet];\r\n        uint timeSinceLastSpent = now.sub(q.spentTimestamp);\r\n        if (timeSinceLastSpent < 1 days) {\r\n            return q.spentAmount.sub(q.spentAmount.mul(timeSinceLastSpent) / 1 days);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function availableQuota(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint quota = currentQuota(wallet);\r\n        uint spent = spentQuota(wallet);\r\n        return quota > spent ? quota - spent : 0;\r\n    }\r\n\r\n    function hasEnoughQuota(\r\n        address wallet,\r\n        uint    requiredAmount\r\n        )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return availableQuota(wallet) >= requiredAmount;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract OwnerManagable is Claimable, AddressSet\r\n{\r\n    bytes32 internal constant MANAGER = keccak256(\"__MANAGED__\");\r\n\r\n    event ManagerAdded  (address indexed manager);\r\n    event ManagerRemoved(address indexed manager);\r\n\r\n    modifier onlyManager\r\n    {\r\n        require(isManager(msg.sender), \"NOT_MANAGER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrManager\r\n    {\r\n        require(msg.sender == owner || isManager(msg.sender), \"NOT_OWNER_OR_MANAGER\");\r\n        _;\r\n    }\r\n\r\n    constructor() public Claimable() {}\r\n\r\n    /// @dev Gets the managers.\r\n    /// @return The list of managers.\r\n    function managers()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return addressesInSet(MANAGER);\r\n    }\r\n\r\n    /// @dev Gets the number of managers.\r\n    /// @return The numer of managers.\r\n    function numManagers()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return numAddressesInSet(MANAGER);\r\n    }\r\n\r\n    /// @dev Checks if an address is a manger.\r\n    /// @param addr The address to check.\r\n    /// @return True if the address is a manager, False otherwise.\r\n    function isManager(address addr)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return isAddressInSet(MANAGER, addr);\r\n    }\r\n\r\n    /// @dev Adds a new manager.\r\n    /// @param manager The new address to add.\r\n    function addManager(address manager)\r\n        public\r\n        onlyOwner\r\n    {\r\n        addManagerInternal(manager);\r\n    }\r\n\r\n    /// @dev Removes a manager.\r\n    /// @param manager The manager to remove.\r\n    function removeManager(address manager)\r\n        public\r\n        onlyOwner\r\n    {\r\n        removeAddressFromSet(MANAGER, manager);\r\n        emit ManagerRemoved(manager);\r\n    }\r\n\r\n    function addManagerInternal(address manager)\r\n        internal\r\n    {\r\n        addAddressToSet(MANAGER, manager, true);\r\n        emit ManagerAdded(manager);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title DappAddressStore\r\n/// @dev This store maintains global whitelist dapps.\r\ncontract DappAddressStore is DataStore, OwnerManagable\r\n{\r\n    bytes32 internal constant DAPPS = keccak256(\"__DAPPS__\");\r\n\r\n    event Whitelisted(\r\n        address indexed addr,\r\n        bool            whitelisted\r\n    );\r\n\r\n    constructor() public DataStore() {}\r\n\r\n    function addDapp(address addr)\r\n        public\r\n        onlyManager\r\n    {\r\n        addAddressToSet(DAPPS, addr, true);\r\n        emit Whitelisted(addr, true);\r\n    }\r\n\r\n    function removeDapp(address addr)\r\n        public\r\n        onlyManager\r\n    {\r\n        removeAddressFromSet(DAPPS, addr);\r\n        emit Whitelisted(addr, false);\r\n    }\r\n\r\n    function dapps()\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory addresses\r\n        )\r\n    {\r\n        return addressesInSet(DAPPS);\r\n    }\r\n\r\n    function isDapp(\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return isAddressInSet(DAPPS, addr);\r\n    }\r\n\r\n    function numDapps()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return numAddressesInSet(DAPPS);\r\n    }\r\n}\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title WhitelistStore\r\n/// @dev This store maintains a wallet's whitelisted addresses.\r\ncontract WhitelistStore is DataStore, AddressSet\r\n{\r\n    // wallet => whitelisted_addr => effective_since\r\n    mapping(address => mapping(address => uint)) public effectiveTimeMap;\r\n\r\n    event Whitelisted(\r\n        address indexed wallet,\r\n        address indexed addr,\r\n        bool            whitelisted,\r\n        uint            effectiveTime\r\n    );\r\n\r\n    constructor() public DataStore() {}\r\n\r\n    function addToWhitelist(\r\n        address wallet,\r\n        address addr,\r\n        uint    effectiveTime\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        addAddressToSet(walletKey(wallet), addr, true);\r\n        uint effective = effectiveTime >= now ? effectiveTime : now;\r\n        effectiveTimeMap[wallet][addr] = effective;\r\n        emit Whitelisted(wallet, addr, true, effective);\r\n    }\r\n\r\n    function removeFromWhitelist(\r\n        address wallet,\r\n        address addr\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        removeAddressFromSet(walletKey(wallet), addr);\r\n        delete effectiveTimeMap[wallet][addr];\r\n        emit Whitelisted(wallet, addr, false, 0);\r\n    }\r\n\r\n    function whitelist(address wallet)\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory addresses,\r\n            uint[]    memory effectiveTimes\r\n        )\r\n    {\r\n        addresses = addressesInSet(walletKey(wallet));\r\n        effectiveTimes = new uint[](addresses.length);\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            effectiveTimes[i] = effectiveTimeMap[wallet][addresses[i]];\r\n        }\r\n    }\r\n\r\n    function isWhitelisted(\r\n        address wallet,\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (\r\n            bool isWhitelistedAndEffective,\r\n            uint effectiveTime\r\n        )\r\n    {\r\n        effectiveTime = effectiveTimeMap[wallet][addr];\r\n        isWhitelistedAndEffective = effectiveTime > 0 && effectiveTime <= now;\r\n    }\r\n\r\n    function whitelistSize(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return numAddressesInSet(walletKey(wallet));\r\n    }\r\n\r\n    function walletKey(address addr)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\"__WHITELIST__\", addr));\r\n    }\r\n}\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title PriceOracle\r\nabstract contract PriceOracle\r\n{\r\n    // @dev Return's the token's value in ETH\r\n    function tokenValue(address token, uint amount)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint value);\r\n}\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ArgentENSManager.sol\r\n// with few modifications.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface for an ENS Mananger.\r\n */\r\ninterface IENSManager {\r\n    function changeRootnodeOwner(address _newOwner) external;\r\n\r\n    function isAvailable(bytes32 _subnode) external view returns(bool);\r\n\r\n    function resolveName(address _owner) external view returns (string memory);\r\n\r\n    function register(\r\n        address _owner,\r\n        string  calldata _label,\r\n        bytes   calldata _approval\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title BaseENSManager\r\n * @dev Implementation of an ENS manager that orchestrates the complete\r\n * registration of subdomains for a single root (e.g. argent.eth).\r\n * The contract defines a manager role who is the only role that can trigger the registration of\r\n * a new subdomain.\r\n * @author Julien Niset - <julien@argent.im>\r\n */\r\ncontract BaseENSManager is IENSManager, OwnerManagable, ENSConsumer {\r\n\r\n    using strings for *;\r\n    using BytesUtil     for bytes;\r\n    using MathUint      for uint;\r\n\r\n    // The managed root name\r\n    string public rootName;\r\n    // The managed root node\r\n    bytes32 public rootNode;\r\n    // The address of the ENS resolver\r\n    address public ensResolver;\r\n\r\n    // *************** Events *************************** //\r\n\r\n    event RootnodeOwnerChange(bytes32 indexed _rootnode, address indexed _newOwner);\r\n    event ENSResolverChanged(address addr);\r\n    event Registered(address indexed _owner, string _ens);\r\n    event Unregistered(string _ens);\r\n\r\n    // *************** Constructor ********************** //\r\n\r\n    /**\r\n     * @dev Constructor that sets the ENS root name and root node to manage.\r\n     * @param _rootName The root name (e.g. argentx.eth).\r\n     * @param _rootNode The node of the root name (e.g. namehash(argentx.eth)).\r\n     */\r\n    constructor(string memory _rootName, bytes32 _rootNode, address _ensRegistry, address _ensResolver)\r\n        ENSConsumer(_ensRegistry)\r\n        public {\r\n        rootName = _rootName;\r\n        rootNode = _rootNode;\r\n        ensResolver = _ensResolver;\r\n    }\r\n\r\n    // *************** External Functions ********************* //\r\n\r\n    /**\r\n     * @dev This function must be called when the ENS Manager contract is replaced\r\n     * and the address of the new Manager should be provided.\r\n     * @param _newOwner The address of the new ENS manager that will manage the root node.\r\n     */\r\n    function changeRootnodeOwner(address _newOwner) external override onlyOwner {\r\n        getENSRegistry().setOwner(rootNode, _newOwner);\r\n        emit RootnodeOwnerChange(rootNode, _newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Lets the owner change the address of the ENS resolver contract.\r\n     * @param _ensResolver The address of the ENS resolver contract.\r\n     */\r\n    function changeENSResolver(address _ensResolver) external onlyOwner {\r\n        require(_ensResolver != address(0), \"WF: address cannot be null\");\r\n        ensResolver = _ensResolver;\r\n        emit ENSResolverChanged(_ensResolver);\r\n    }\r\n\r\n    /**\r\n    * @dev Lets the manager assign an ENS subdomain of the root node to a target address.\r\n    * Registers both the forward and reverse ENS.\r\n    * @param _owner The owner of the subdomain.\r\n    * @param _label The subdomain label.\r\n    * @param _approval The signature of _owner and _label by a manager.\r\n    */\r\n    function register(\r\n        address _owner,\r\n        string  calldata _label,\r\n        bytes   calldata _approval\r\n        )\r\n        external\r\n        override\r\n        onlyManager\r\n    {\r\n        verifyApproval(_owner, _label, _approval);\r\n\r\n        bytes32 labelNode = keccak256(abi.encodePacked(_label));\r\n        bytes32 node = keccak256(abi.encodePacked(rootNode, labelNode));\r\n        address currentOwner = getENSRegistry().owner(node);\r\n        require(currentOwner == address(0), \"AEM: _label is alrealdy owned\");\r\n\r\n        // Forward ENS\r\n        getENSRegistry().setSubnodeOwner(rootNode, labelNode, address(this));\r\n        getENSRegistry().setResolver(node, ensResolver);\r\n        getENSRegistry().setOwner(node, _owner);\r\n        ENSResolver(ensResolver).setAddr(node, _owner);\r\n\r\n        // Reverse ENS\r\n        strings.slice[] memory parts = new strings.slice[](2);\r\n        parts[0] = _label.toSlice();\r\n        parts[1] = rootName.toSlice();\r\n        string memory name = \".\".toSlice().join(parts);\r\n        bytes32 reverseNode = getENSReverseRegistrar().node(_owner);\r\n        ENSResolver(ensResolver).setName(reverseNode, name);\r\n\r\n        emit Registered(_owner, name);\r\n    }\r\n\r\n    // *************** Public Functions ********************* //\r\n\r\n    /**\r\n    * @dev Resolves an address to an ENS name\r\n    * @param _owner The ENS owner address\r\n    */\r\n    function resolveName(address _owner) public view override returns (string memory) {\r\n        bytes32 reverseNode = getENSReverseRegistrar().node(_owner);\r\n        return ENSResolver(ensResolver).name(reverseNode);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true is a given subnode is available.\r\n     * @param _subnode The target subnode.\r\n     * @return true if the subnode is available.\r\n     */\r\n    function isAvailable(bytes32 _subnode) public view override returns (bool) {\r\n        bytes32 node = keccak256(abi.encodePacked(rootNode, _subnode));\r\n        address currentOwner = getENSRegistry().owner(node);\r\n        if(currentOwner == address(0)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function verifyApproval(\r\n        address _owner,\r\n        string  memory _label,\r\n        bytes   memory _approval\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        if (numManagers() == 1) {\r\n            return;\r\n        }\r\n\r\n        bytes32 messageHash = keccak256(\r\n            abi.encodePacked(\r\n                _owner,\r\n                _label\r\n            )\r\n        );\r\n\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                messageHash\r\n            )\r\n        );\r\n\r\n        address signer = SignatureUtil.recoverECDSASigner(hash, _approval);\r\n        require(isManager(signer), \"UNAUTHORIZED\");\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title WalletENSManager\r\n/// @dev An ENS manager to interactive with ENS module.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\ncontract WalletENSManager is BaseENSManager {\r\n\r\n    constructor(\r\n        string memory _rootName,\r\n        bytes32       _rootNode,\r\n        address       _ensRegistry,\r\n        address       _ensResolver\r\n        )\r\n        public\r\n        BaseENSManager(\r\n            _rootName,\r\n            _rootNode,\r\n            _ensRegistry,\r\n            _ensResolver\r\n        )\r\n    {\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Controller\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract Controller\r\n{\r\n    // The address to which all colletable tokens/ether in modules will\r\n    // be sent to.\r\n    address public collectTo;\r\n    uint    public defaultLockPeriod;\r\n\r\n    ModuleRegistry          public moduleRegistry;\r\n    WalletRegistry          public walletRegistry;\r\n\r\n    QuotaStore              public quotaStore;\r\n    SecurityStore           public securityStore;\r\n    DappAddressStore        public dappAddressStore;\r\n    WhitelistStore          public whitelistStore;\r\n\r\n    PriceOracle             public priceOracle;\r\n    WalletENSManager        public ensManager;\r\n}\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless _requirement by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\nlibrary EIP712\r\n{\r\n    struct Domain {\r\n        string  name;\r\n        string  version;\r\n        address verifyingContract;\r\n    }\r\n\r\n    bytes32 constant internal EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\r\n\r\n    function hash(Domain memory domain)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        uint _chainid;\r\n        assembly { _chainid := chainid() }\r\n\r\n        return keccak256(\r\n            abi.encode(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(bytes(domain.name)),\r\n                keccak256(bytes(domain.version)),\r\n                _chainid,\r\n                domain.verifyingContract\r\n            )\r\n        );\r\n    }\r\n\r\n    function hashPacked(\r\n        bytes32 domainHash,\r\n        bytes32 dataHash\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                EIP191_HEADER,\r\n                domainHash,\r\n                dataHash\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title SignatureUtil\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @dev This method supports multihash standard. Each signature's first byte indicates\r\n///      the signature's type, the second byte indicates the signature's length, therefore,\r\n///      each signature will have 2 extra bytes prefix. Mulitple signatures are concatenated\r\n///      together.\r\nlibrary SignatureUtil\r\n{\r\n    using BytesUtil     for bytes;\r\n    using MathUint      for uint;\r\n\r\n    enum SignatureType {\r\n        ILLEGAL,\r\n        INVALID,\r\n        EIP_712,\r\n        ETH_SIGN,\r\n        WALLET\r\n    }\r\n\r\n    bytes4 constant private ERC1271_MAGICVALUE = 0x20c13b0b;\r\n\r\n    function verifySignatures(\r\n        bytes32   signHash,\r\n        address[] memory signers,\r\n        bytes[]   memory signatures\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(signers.length == signatures.length, \"BAD_SIGNATURE_DATA\");\r\n        address lastSigner;\r\n        for (uint i = 0; i < signers.length; i++) {\r\n            require(signers[i] > lastSigner, \"INVALID_SIGNERS_ORDER\");\r\n            lastSigner = signers[i];\r\n            if (!verifySignature(signHash, signers[i], signatures[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function verifySignature(\r\n        bytes32 signHash,\r\n        address signer,\r\n        bytes   memory signature\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint signatureTypeOffset = signature.length.sub(1);\r\n        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\r\n\r\n        bytes memory stripped = signature.slice(0, signatureTypeOffset);\r\n\r\n        if (signatureType == SignatureType.WALLET) {\r\n            return verifyERC1271Signature(signHash, signer, stripped);\r\n        } else if (signatureType == SignatureType.EIP_712) {\r\n            return recoverECDSASigner(signHash, stripped) == signer;\r\n        } else if (signatureType == SignatureType.ETH_SIGN) {\r\n            bytes32 hash = keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", signHash)\r\n            );\r\n            return recoverECDSASigner(hash, stripped) == signer;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function verifyERC1271Signature(\r\n        bytes32 signHash,\r\n        address signer,\r\n        bytes   memory signature\r\n        )\r\n        private\r\n        view\r\n        returns(bool)\r\n    {\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            ERC1271(0).isValidSignature.selector,\r\n            abi.encode(signHash),\r\n            signature\r\n        );\r\n        (bool success, bytes memory result) = signer.staticcall(callData);\r\n        return (\r\n            success &&\r\n            result.length == 32 &&\r\n            result.toBytes4(0) == ERC1271_MAGICVALUE\r\n        );\r\n    }\r\n\r\n    function recoverECDSASigner(\r\n        bytes32      signHash,\r\n        bytes memory signature\r\n        )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        if (signature.length != 65) {\r\n            return address(0);\r\n        }\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8   v;\r\n        // we jump 32 (0x20) as the first slot of bytes contains the length\r\n        // we jump 65 (0x41) per signature\r\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := and(mload(add(signature, 0x41)), 0xff)\r\n        }\r\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n        if (v == 27 || v == 28) {\r\n            return ecrecover(signHash, v, r, s);\r\n        } else {\r\n            return address(0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title ReentrancyGuard\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Exposes a modifier that guards a function against reentrancy\r\n///      Changing the value of the same storage value multiple times in a transaction\r\n///      is cheap (starting from Istanbul) so there is no need to minimize\r\n///      the number of times the value is changed\r\ncontract ReentrancyGuard\r\n{\r\n    //The default value must be 0 in order to work behind a proxy.\r\n    uint private _guardValue;\r\n\r\n    modifier nonReentrant()\r\n    {\r\n        require(_guardValue == 0, \"REENTRANCY\");\r\n        _guardValue = 1;\r\n        _;\r\n        _guardValue = 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Module\r\n/// @dev Base contract for all smart wallet modules.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\ninterface Module\r\n{\r\n    /// @dev Activates the module for the given wallet (msg.sender) after the module is added.\r\n    ///      Warning: this method shall ONLY be callable by a wallet.\r\n    function activate() external;\r\n\r\n    /// @dev Deactivates the module for the given wallet (msg.sender) before the module is removed.\r\n    ///      Warning: this method shall ONLY be callable by a wallet.\r\n    function deactivate() external;\r\n}\r\n\r\n\r\n\r\n/// @title BaseModule\r\n/// @dev This contract implements some common functions that are likely\r\n///      be useful for all modules.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\ncontract BaseModule is ReentrancyGuard, Module\r\n{\r\n    event Activated   (address indexed wallet);\r\n    event Deactivated (address indexed wallet);\r\n\r\n    modifier onlyFromWallet(address wallet) virtual\r\n    {\r\n        require(msg.sender == wallet, \"NOT_FROM_WALLET\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFromMetaTx() virtual {\r\n        require(msg.sender == address(this), \"NOT_FROM_META_TX\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFromWalletOwner(address wallet) virtual {\r\n        require(msg.sender == Wallet(wallet).owner(), \"NOT_FROM_WALLET_OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFromMetaTxOrWalletOwner(address wallet) virtual {\r\n        require(\r\n            msg.sender == address(this) || msg.sender == Wallet(wallet).owner(),\r\n            \"NOT_FROM_METATX_OR_WALLET_OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFromMetaTxOrOwner(address owner) virtual {\r\n        require(\r\n            msg.sender == address(this) || msg.sender == owner,\r\n            \"NOT_FROM_METATX_OR_OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWalletOwner(address wallet, address addr) virtual {\r\n        require(Wallet(wallet).owner() == addr, \"NOT_WALLET_OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier notWalletOwner(address wallet, address addr) virtual {\r\n        require(Wallet(wallet).owner() != addr, \"IS_WALLET_OWNER\");\r\n        _;\r\n    }\r\n\r\n    function addModule(\r\n        address wallet,\r\n        address module\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyFromMetaTxOrWalletOwner(wallet)\r\n    {\r\n        Wallet(wallet).addModule(module);\r\n    }\r\n\r\n    /// @dev This method will cause an re-entry to the same module contract.\r\n    function activate()\r\n        external\r\n        override\r\n        virtual\r\n    {\r\n        address wallet = msg.sender;\r\n        bindMethods(wallet);\r\n        emit Activated(wallet);\r\n    }\r\n\r\n    /// @dev This method will cause an re-entry to the same module contract.\r\n    function deactivate()\r\n        external\r\n        override\r\n        virtual\r\n    {\r\n        address wallet = msg.sender;\r\n        unbindMethods(wallet);\r\n        emit Deactivated(wallet);\r\n    }\r\n\r\n    ///.@dev Gets the list of methods for binding to wallets.\r\n    ///      Sub-contracts should override this method to provide methods for\r\n    ///      wallet binding.\r\n    /// @return methods A list of method selectors for binding to the wallet\r\n    ///         when this module is activated for the wallet.\r\n    function bindableMethods()\r\n        public\r\n        pure\r\n        virtual\r\n        returns (bytes4[] memory methods)\r\n    {\r\n    }\r\n\r\n    // ===== internal & private methods =====\r\n\r\n    /// @dev Binds all methods to the given wallet.\r\n    function bindMethods(address wallet)\r\n        internal\r\n    {\r\n        Wallet w = Wallet(wallet);\r\n        bytes4[] memory methods = bindableMethods();\r\n        for (uint i = 0; i < methods.length; i++) {\r\n            w.bindMethod(methods[i], address(this));\r\n        }\r\n    }\r\n\r\n    /// @dev Unbinds all methods from the given wallet.\r\n    function unbindMethods(address wallet)\r\n        internal\r\n    {\r\n        Wallet w = Wallet(wallet);\r\n        bytes4[] memory methods = bindableMethods();\r\n        for (uint i = 0; i < methods.length; i++) {\r\n            w.bindMethod(methods[i], address(0));\r\n        }\r\n    }\r\n\r\n    function transactCall(\r\n        address wallet,\r\n        address to,\r\n        uint    value,\r\n        bytes   memory data\r\n        )\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return Wallet(wallet).transact(uint8(1), to, value, data);\r\n    }\r\n\r\n    // Special case for transactCall to support transfers on \"bad\" ERC20 tokens\r\n    function transactTokenTransfer(\r\n        address wallet,\r\n        address token,\r\n        address to,\r\n        uint    amount\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        bytes memory txData = abi.encodeWithSelector(\r\n            ERC20(0).transfer.selector,\r\n            to,\r\n            amount\r\n        );\r\n        bytes memory returnData = transactCall(wallet, token, 0, txData);\r\n        // `transactCall` will revert if the call was unsuccessful.\r\n        // The only extra check we have to do is verify if the return value (if there is any) is correct.\r\n        if (returnData.length > 0) {\r\n            success = abi.decode(returnData, (bool));\r\n        } else {\r\n            // If there is no return value then a failure would have resulted in a revert\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    // Special case for transactCall to support approvals on \"bad\" ERC20 tokens\r\n    function transactTokenApprove(\r\n        address wallet,\r\n        address token,\r\n        address spender,\r\n        uint    amount\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        bytes memory txData = abi.encodeWithSelector(\r\n            ERC20(0).approve.selector,\r\n            spender,\r\n            amount\r\n        );\r\n        bytes memory returnData = transactCall(wallet, token, 0, txData);\r\n        // `transactCall` will revert if the call was unsuccessful.\r\n        // The only extra check we have to do is verify if the return value (if there is any) is correct.\r\n        if (returnData.length > 0) {\r\n            success = abi.decode(returnData, (bool));\r\n        } else {\r\n            // If there is no return value then a failure would have resulted in a revert\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    function transactDelegateCall(\r\n        address wallet,\r\n        address to,\r\n        uint    value,\r\n        bytes   memory data\r\n        )\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return Wallet(wallet).transact(uint8(2), to, value, data);\r\n    }\r\n\r\n    function transactStaticCall(\r\n        address wallet,\r\n        address to,\r\n        bytes   memory data\r\n        )\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return Wallet(wallet).transact(uint8(3), to, 0, data);\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title MetaTxModule\r\n/// @dev This is the base module for supporting meta-transactions.\r\n///      A MetaTxModule will only relay transactions on itself, and the methods\r\n///      relayed must as the target wallet address as its first argument, unless\r\n///      the `extractWalletAddress` is overridden.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\n\r\nabstract contract MetaTxModule is BaseModule\r\n{\r\n    using MathUint      for uint;\r\n    using AddressUtil   for address;\r\n    using SignatureUtil for bytes32;\r\n    using BytesUtil     for bytes;\r\n\r\n    struct WalletState\r\n    {\r\n        uint nonce;\r\n        mapping (bytes32 => bool) metaTxHash;\r\n    }\r\n\r\n    struct GasSettings\r\n    {\r\n        address token;\r\n        uint    price;\r\n        uint    limit;\r\n        uint    overhead;\r\n        address recipient;\r\n    }\r\n\r\n    struct MetaTransaction\r\n    {\r\n        address wallet;\r\n        address module;\r\n        uint    value;\r\n        bytes   data;\r\n        uint    nonce;\r\n        uint    validUntil;\r\n        address gasToken;\r\n        uint    gasPrice;\r\n        uint    gasLimit;\r\n        uint    gasOverhead;\r\n        address feeRecipient;\r\n    }\r\n\r\n    bytes32 constant public METATRANSACTION_TYPEHASH = keccak256(\r\n        \"MetaTransaction(address wallet,address module,uint256 value,bytes data,uint256 nonce,uint256 validUntil,address gasToken,uint256 gasPrice,uint256 gasLimit,uint256 gasOverhead,address feeRecipient)\"\r\n    );\r\n\r\n    bytes32    public DOMAIN_SEPARATOR;\r\n    Controller public controller;\r\n\r\n    mapping (address => WalletState) public wallets;\r\n\r\n    event MetaTxExecuted(\r\n        address indexed transactor,\r\n        address indexed wallet,\r\n        uint    nonce,\r\n        bytes32 metaTxHash,\r\n        uint    gasUsed,\r\n        bool    success,\r\n        bytes   returnData\r\n    );\r\n\r\n    modifier onlyFromMetaTx override\r\n    {\r\n        require(msg.sender == address(this), \"NOT_FROM_THIS_MODULE\");\r\n        _;\r\n    }\r\n\r\n    constructor(Controller _controller)\r\n        public\r\n        BaseModule()\r\n    {\r\n        DOMAIN_SEPARATOR = EIP712.hash(EIP712.Domain(\"Loopring Wallet MetaTxModule\", \"1.0\", address(this)));\r\n        controller = _controller;\r\n    }\r\n\r\n    function quotaStore()\r\n        internal\r\n        view\r\n        virtual\r\n        returns (address)\r\n    {\r\n        return address(0);\r\n    }\r\n\r\n    function isWalletOwnerOrGuardian(address wallet, address addr)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return Wallet(wallet).owner() == addr ||\r\n            controller.securityStore().isGuardian(wallet, addr);\r\n    }\r\n\r\n    function isWalletOwnerOrGuardian(address wallet, address[] memory addrs)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (addrs.length == 0) return false;\r\n\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            if (!isWalletOwnerOrGuardian(wallet, addrs[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Execute a signed meta transaction.\r\n    ///      This method can be called by any relayer without restriction. The relayer\r\n    ///      will pay for transaction gas in Ether and charge the wallet Ether or other\r\n    ///      ERC20 tokens as fee. If gasPrice is set to 0, then the relayer won't charge\r\n    ///      the wallet any fee.\r\n    ///\r\n    ///      Important! This function needs to be safe against re-entrancy by using\r\n    ///      the 'Checks Effects Interactions' pattern! We do not use `nonReentrant`\r\n    ///      because this function is used to call into the same contract.\r\n    ///\r\n    /// @param data The raw transaction to be performed on this module.\r\n    /// @param nonce The nonce of this meta transaction. When nonce is 0, this module will\r\n    ///              make sure the transaction's metaTxHash is unique; otherwise, the module\r\n    ///              requires the nonce is greater than the last nonce used by the same\r\n    ///              wallet, but not by more than `block.number * 2^128`.\r\n    /// @param validUntil The expiry timestamp\r\n    /// @param gasSetting A list that contains `gasToken` address, `gasPrice`, `gasLimit`,\r\n    ///                   `gasOverhead` and `feeRecipient`. To pay fee in Ether, use address(0) as gasToken.\r\n    ///                   To receive reimbursement at `msg.sender`, use address(0) as feeRecipient.\r\n    /// @param signatures The signatures of the signers.\r\n    /// @param signers The signers needed for the transaction.\r\n    function executeMetaTx(\r\n        bytes     memory data,\r\n        uint      nonce,\r\n        uint      validUntil,\r\n        uint[5]   memory gasSetting, // [gasToken address][gasPrice][gasLimit][gasOverhead][feeRecipient]\r\n        bytes[]   memory signatures,\r\n        address[] memory signers\r\n        )\r\n        public\r\n        payable\r\n    {\r\n        require(validUntil >= now, \"EXPIRED\");\r\n\r\n        GasSettings memory gasSettings = GasSettings(\r\n            address(gasSetting[0]),\r\n            gasSetting[1],\r\n            gasSetting[2],\r\n            gasSetting[3],\r\n            address(gasSetting[4])\r\n        );\r\n        require(gasSettings.limit > 0, \"INVALID_GAS_LIMIT\");\r\n\r\n        address wallet = extractWalletAddress(data);\r\n        bytes32 metaTxHash = EIP712.hashPacked(\r\n            DOMAIN_SEPARATOR,\r\n            hash(\r\n                MetaTransaction(\r\n                    wallet,\r\n                    address(this),\r\n                    msg.value,\r\n                    data,\r\n                    nonce,\r\n                    validUntil,\r\n                    gasSettings.token,\r\n                    gasSettings.price,\r\n                    gasSettings.limit,\r\n                    gasSettings.overhead,\r\n                    gasSettings.recipient\r\n                )\r\n            )\r\n        );\r\n\r\n        // Get the signers necessary for this meta transaction.\r\n        require(checkSigners(wallet, data, signers), \"METATX_UNAUTHORIZED\");\r\n        require(metaTxHash.verifySignatures(signers, signatures), \"INVALID_SIGNATURES\");\r\n\r\n        // Mark the transaction as used before doing the call to guard against re-entrancy\r\n        // (the only exploit possible here is that the transaction can be executed multiple times).\r\n        saveExecutedMetaTx(wallet, nonce, metaTxHash);\r\n\r\n        // Deposit msg.value to the wallet so it can be used from the wallet\r\n        if (msg.value > 0) {\r\n            wallet.sendETHAndVerify(msg.value, gasleft());\r\n        }\r\n\r\n        require(gasleft() >= (gasSettings.limit.mul(64) / 63).add(60000), \"INSUFFICIENT_GAS\");\r\n        uint gasUsed = gasleft();\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = address(this).call{gas: gasSettings.limit}(data);\r\n        gasUsed = gasUsed - gasleft();\r\n        // The gas amount measured could be a little bit higher because of the extra costs to do the call itself\r\n        gasUsed = gasUsed < gasSettings.limit ? gasUsed : gasSettings.limit;\r\n\r\n        emit MetaTxExecuted(msg.sender, wallet, nonce, metaTxHash, gasUsed, success, returnData);\r\n\r\n        if (gasSettings.price != 0) {\r\n            reimburseGasFee(wallet, gasSettings, gasUsed);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the last nonce used by a wallet.\r\n    /// @param wallet The wallet's address.\r\n    /// @return Last nonce used.\r\n    function lastNonce(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return wallets[wallet].nonce;\r\n    }\r\n\r\n    /// @dev Collects tokens and ether owned by this module to a controlled address.\r\n    /// @param tokens The list of tokens and ether to collect.\r\n    function collectTokens(address[] calldata tokens)\r\n        external\r\n        nonReentrant\r\n    {\r\n        address to = controller.collectTo();\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address token = tokens[i];\r\n            if (token == address(0)) {\r\n                uint amount = address(this).balance;\r\n                to.sendETHAndVerify(amount, gasleft());\r\n            } else {\r\n                uint amount = ERC20(token).balanceOf(address(this));\r\n                if (amount > 0) {\r\n                    // Do not check the return value to support \"bad\" ERC20 tokens\r\n                    ERC20(token).transfer(to, amount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // ---- internal functions -----\r\n\r\n    /// @dev Validate the list of signers for the given meta transaction.\r\n    ///      Additional validation of the signers can also be done inside this function.\r\n    /// @param wallet The wallet address.\r\n    /// @param method The method selector.\r\n    /// @param data The call data.\r\n    /// @param signers The list of addresses which have signed the meta transaction\r\n    /// @return True if the list of signers are as expected, else False\r\n    function verifySigners(\r\n        address   wallet,\r\n        bytes4    method,\r\n        bytes     memory data,\r\n        address[] memory signers\r\n        )\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool);\r\n\r\n    /// @dev Check if the specified signer is the only signer\r\n    function isOnlySigner(address signer, address[] memory signers)\r\n        internal\r\n        pure\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return (signers.length == 1 && signers[0] == signer);\r\n    }\r\n\r\n    /// @dev For all relayed method, the first parameter must be the wallet address.\r\n    function extractWalletAddress(bytes memory data)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (address wallet)\r\n    {\r\n        wallet = extractAddressFromCallData(data, 0);\r\n    }\r\n\r\n    /// @dev Returns the address stored in the call data\r\n    ///      at the specified function parameter index.\r\n    ///      Example: function bar(uint value, address signer, bytes data);\r\n    ///               To extact `signer` use parameterIdx := 1\r\n    function extractAddressFromCallData(\r\n        bytes memory data,\r\n        uint  parameterIdx\r\n        )\r\n        internal\r\n        pure\r\n        returns (address addr)\r\n    {\r\n        addr = data.toAddress(4 + 32 * parameterIdx + 12);\r\n    }\r\n\r\n    /// @dev Returns a read-only array with the addresses stored in the call data\r\n    ///      at the specified function parameter index.\r\n    ///      Example: function bar(address[] signers, uint value);\r\n    ///               To extact `signers` use parameterIdx := 0\r\n    ///      Example: function foo(address wallet, address[] signers, address[] contracts);\r\n    ///               To extact `signers` use parameterIdx := 1\r\n    ///               To extact `contracts` use parameterIdx := 2\r\n    function extractAddressesFromCallData(\r\n        bytes memory data,\r\n        uint  parameterIdx\r\n        )\r\n        internal\r\n        pure\r\n        returns (address[] memory addresses)\r\n    {\r\n        // Find the offset of the function parameter in the call data\r\n        uint dataOffset = data.toUint(4 + 32 * parameterIdx);\r\n        // Make sure enough bytes are in data to store the complete array\r\n        uint length = data.toUint(4 + dataOffset);\r\n        require(data.length >= 4 + dataOffset + 32 * (1 + length), \"INVALID_DATA\");\r\n        // Extract the signers by copying the pointer at the beginning of the array\r\n        // An extra offset of 36 is applied: 32(length) + 4(sig)\r\n        assembly { addresses := add(data, add(36, dataOffset)) }\r\n    }\r\n\r\n    function hash(MetaTransaction memory _tx)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encode(\r\n                METATRANSACTION_TYPEHASH,\r\n                _tx.wallet,\r\n                _tx.module,\r\n                _tx.value,\r\n                keccak256(_tx.data),\r\n                _tx.nonce,\r\n                _tx.validUntil,\r\n                _tx.gasToken,\r\n                _tx.gasPrice,\r\n                _tx.gasLimit,\r\n                _tx.gasOverhead,\r\n                _tx.feeRecipient\r\n            )\r\n        );\r\n    }\r\n\r\n    function extractMethod(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (bytes4 method)\r\n    {\r\n        return data.toBytes4(0);\r\n    }\r\n\r\n    function reimburseGasFee(\r\n        address     wallet,\r\n        GasSettings memory gasSettings,\r\n        uint        gasUsed\r\n        )\r\n        private\r\n    {\r\n        uint gasCost = gasUsed.add(gasSettings.overhead).mul(gasSettings.price);\r\n        updateQuota(wallet, gasSettings.token, gasCost);\r\n\r\n        address feeRecipient = (gasSettings.recipient == address(0)) ? msg.sender : gasSettings.recipient;\r\n        if (gasSettings.token == address(0)) {\r\n            transactCall(wallet, feeRecipient, gasCost, \"\");\r\n        } else {\r\n            require(\r\n                transactTokenTransfer(wallet, gasSettings.token, feeRecipient, gasCost),\r\n                \"TRANSFER_FAILED\"\r\n            );\r\n        }\r\n    }\r\n\r\n    // ---- private functions -----\r\n\r\n    function checkSigners(\r\n        address   wallet,\r\n        bytes     memory data,\r\n        address[] memory signers\r\n        )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes4 method = extractMethod(data);\r\n        if (method == this.addModule.selector) {\r\n            return isOnlySigner(Wallet(wallet).owner(), signers);\r\n        } else {\r\n            return verifySigners(wallet, method, data, signers);\r\n        }\r\n    }\r\n\r\n    /// @dev Save the meta-transaction to history.\r\n    ///      This method must throw if the transaction is not unique or the nonce is invalid.\r\n    /// @param wallet The target wallet.\r\n    /// @param nonce The nonce\r\n    /// @param metaTxHash The signed hash of the transaction\r\n    function saveExecutedMetaTx(\r\n        address wallet,\r\n        uint    nonce,\r\n        bytes32 metaTxHash\r\n        )\r\n        private\r\n    {\r\n        if (nonce == 0) {\r\n            require(!wallets[wallet].metaTxHash[metaTxHash], \"INVALID_HASH\");\r\n            wallets[wallet].metaTxHash[metaTxHash] = true;\r\n        } else {\r\n            require(nonce > wallets[wallet].nonce, \"NONCE_TOO_SMALL\");\r\n            require((nonce >> 128) <= (block.number), \"NONCE_TOO_LARGE\");\r\n            wallets[wallet].nonce = nonce;\r\n        }\r\n    }\r\n\r\n    function updateQuota(\r\n        address wallet,\r\n        address token,\r\n        uint    amount\r\n        )\r\n        internal\r\n    {\r\n        if (amount > 0 && quotaStore() != address(0)) {\r\n            uint value = controller.priceOracle().tokenValue(token, amount);\r\n            QuotaStore(quotaStore()).checkAndAddToSpent(wallet, value);\r\n        }\r\n    }\r\n\r\n    function tryToUpdateQuota(\r\n        address wallet,\r\n        address token,\r\n        uint    amount\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (quotaStore() != address(0)) {\r\n            uint value = controller.priceOracle().tokenValue(token, amount);\r\n            try QuotaStore(quotaStore()).checkAndAddToSpent(wallet, value) {\r\n                return true;\r\n            } catch Error(string memory /*reason*/) {\r\n                return false;\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title GuardianUtils\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary GuardianUtils\r\n{\r\n    uint constant public MAX_NUM_GROUPS = 16;\r\n\r\n    enum SigRequirement\r\n    {\r\n        OwnerNotAllowed,\r\n        OwnerAllowed,\r\n        OwnerRequired\r\n    }\r\n\r\n    function requireMajority(\r\n        SecurityStore   securityStore,\r\n        address         wallet,\r\n        address[]       memory signers,\r\n        SigRequirement  requirement\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // We always need at least one signer\r\n        if (signers.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        // Calculate total group sizes\r\n        Data.Guardian[] memory allGuardians = securityStore.guardians(wallet);\r\n        uint[MAX_NUM_GROUPS] memory total = countGuardians(allGuardians);\r\n\r\n        // Calculate how many signers are in each group\r\n        bool walletOwnerSigned = false;\r\n        Data.Guardian[] memory signingGuardians = new Data.Guardian[](signers.length);\r\n        address walletOwner = Wallet(wallet).owner();\r\n        uint numGuardians = 0;\r\n        address lastSigner;\r\n        for (uint i = 0; i < signers.length; i++) {\r\n            // Check for duplicates\r\n            require(signers[i] > lastSigner, \"INVALID_SIGNERS_ORDER\");\r\n            lastSigner = signers[i];\r\n\r\n            if (signers[i] == walletOwner) {\r\n                walletOwnerSigned = true;\r\n            } else {\r\n                require(securityStore.isGuardian(wallet, signers[i]), \"SIGNER_NOT_GUARDIAN\");\r\n                signingGuardians[numGuardians++] = securityStore.getGuardian(wallet, signers[i]);\r\n            }\r\n        }\r\n\r\n        // Check owner requirements\r\n        if (requirement == SigRequirement.OwnerRequired) {\r\n            require(walletOwnerSigned, \"WALLET_OWNER_SIGNATURE_REQUIRED\");\r\n        } else if (requirement == SigRequirement.OwnerNotAllowed) {\r\n            require(!walletOwnerSigned, \"WALLET_OWNER_SIGNATURE_NOT_ALLOWED\");\r\n        }\r\n\r\n        // Update the signingGuardians array with the actual number of guardians that have signed\r\n        // (could be 1 less than the length if the owner signed as well)\r\n        assembly { mstore(signingGuardians, numGuardians) }\r\n        uint[MAX_NUM_GROUPS] memory signed = countGuardians(signingGuardians);\r\n\r\n        // Count the number of votes\r\n        uint totalNumVotes = 0;\r\n        uint numVotes = 0;\r\n        if (requirement != SigRequirement.OwnerNotAllowed) {\r\n            totalNumVotes += 1;\r\n            numVotes += walletOwnerSigned ? 1 : 0;\r\n        }\r\n        if (total[0] > 0) {\r\n            // Group 0: No grouping\r\n            totalNumVotes += total[0];\r\n            numVotes += signed[0];\r\n        }\r\n        for (uint i = 1; i < MAX_NUM_GROUPS; i++) {\r\n            if (total[i] > 0) {\r\n                totalNumVotes += 1;\r\n                if (i < 6) {\r\n                    // Groups [1, 5]: Single guardian needed per group\r\n                    numVotes += signed[i] > 0 ? 1 : 0;\r\n                } else if (i < 11) {\r\n                    // Groups [6, 10]: Half the guardians needed per group\r\n                    numVotes += hasHalf(signed[i], total[i]) ? 1 : 0;\r\n                } else {\r\n                    // Groups [11, 15]: A majority of guardians needed per group\r\n                    numVotes += hasMajority(signed[i], total[i]) ? 1 : 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        // We need a majority of votes\r\n        require(hasMajority(numVotes, totalNumVotes), \"NOT_ENOUGH_SIGNERS\");\r\n\r\n        return true;\r\n    }\r\n\r\n    function hasHalf(\r\n        uint count,\r\n        uint total\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (count >= (total + 1) / 2);\r\n    }\r\n\r\n    function hasMajority(\r\n        uint count,\r\n        uint total\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (count >= (total / 2) + 1);\r\n    }\r\n\r\n    function countGuardians(\r\n        Data.Guardian[] memory guardians\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint[MAX_NUM_GROUPS] memory total)\r\n    {\r\n        for (uint i = 0; i < guardians.length; i++) {\r\n            total[guardians[i].group]++;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title SecurityStore\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\nabstract contract SecurityModule is MetaTxModule\r\n{\r\n    // The minimal number of guardians for recovery and locking.\r\n    uint constant public MIN_ACTIVE_GUARDIANS = 2;\r\n\r\n    event WalletLock(\r\n        address indexed wallet,\r\n        uint            lock\r\n    );\r\n\r\n    constructor(Controller _controller)\r\n        public\r\n        MetaTxModule(_controller)\r\n    {\r\n    }\r\n\r\n    // overriding\r\n    modifier onlyFromWalletOwner(address wallet) override {\r\n        require(\r\n            msg.sender == Wallet(wallet).owner(),\r\n            \"NOT_FROM_WALLET_OWNER\"\r\n        );\r\n        controller.securityStore().touchLastActive(wallet);\r\n        _;\r\n    }\r\n\r\n    // overridding\r\n    modifier onlyFromMetaTxOrWalletOwner(address wallet) override {\r\n        require(\r\n            msg.sender == Wallet(wallet).owner() ||\r\n            msg.sender == address(this),\r\n            \"NOT_FROM_METATX_OR_WALLET_OWNER\"\r\n        );\r\n        controller.securityStore().touchLastActive(wallet);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenWalletLocked(address wallet)\r\n    {\r\n        require(isWalletLocked(wallet), \"NOT_LOCKED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenWalletUnlocked(address wallet)\r\n    {\r\n        require(!isWalletLocked(wallet), \"LOCKED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWalletGuardian(address wallet, address guardian)\r\n    {\r\n        require(controller.securityStore().isGuardian(wallet, guardian), \"NOT_GUARDIAN\");\r\n        _;\r\n    }\r\n\r\n    modifier notWalletGuardian(address wallet, address guardian)\r\n    {\r\n        require(!controller.securityStore().isGuardian(wallet, guardian), \"IS_GUARDIAN\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFromMetaTxOr(address guardian)\r\n    {\r\n        require(\r\n            msg.sender == address(this) || msg.sender == guardian,\r\n            \"UNAUTHORIZED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyHaveEnoughGuardians(address wallet)\r\n    {\r\n        require(\r\n            controller.securityStore().numGuardians(wallet) >= MIN_ACTIVE_GUARDIANS,\r\n            \"NO_ENOUGH_ACTIVE_GUARDIANS\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ----- internal methods -----\r\n\r\n    function quotaStore()\r\n        internal\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return address(controller.quotaStore());\r\n    }\r\n\r\n    function lockWallet(address wallet)\r\n        internal\r\n    {\r\n        lockWallet(wallet, controller.defaultLockPeriod());\r\n    }\r\n\r\n    function lockWallet(address wallet, uint _lockPeriod)\r\n        internal\r\n        onlyWhenWalletUnlocked(wallet)\r\n    {\r\n        // cannot lock the wallet twice by different modules.\r\n        require(_lockPeriod > 0, \"ZERO_VALUE\");\r\n        uint lock = now + _lockPeriod;\r\n        controller.securityStore().setLock(wallet, lock);\r\n        emit WalletLock(wallet, lock);\r\n    }\r\n\r\n    function unlockWallet(address wallet, bool forceUnlock)\r\n        internal\r\n    {\r\n        (uint _lock, address _lockedBy) = controller.securityStore().getLock(wallet);\r\n        if (_lock > now) {\r\n            require(forceUnlock || _lockedBy == address(this), \"UNABLE_TO_UNLOCK\");\r\n            controller.securityStore().setLock(wallet, 0);\r\n            emit WalletLock(wallet, 0);\r\n        }\r\n    }\r\n\r\n    function getWalletLock(address wallet)\r\n        internal\r\n        view\r\n        returns (uint _lock, address _lockedBy)\r\n    {\r\n        return controller.securityStore().getLock(wallet);\r\n    }\r\n\r\n    function isWalletLocked(address wallet)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        (uint _lock,) = controller.securityStore().getLock(wallet);\r\n        return _lock > now;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title TransferModule\r\nabstract contract TransferModule is SecurityModule\r\n{\r\n    event Transfered(\r\n        address indexed wallet,\r\n        address indexed token,\r\n        address indexed to,\r\n        uint            amount,\r\n        bytes           logdata\r\n    );\r\n    event Approved(\r\n        address indexed wallet,\r\n        address indexed token,\r\n        address         spender,\r\n        uint            amount\r\n    );\r\n    event ContractCalled(\r\n        address indexed wallet,\r\n        address indexed to,\r\n        uint            value,\r\n        bytes           data\r\n    );\r\n\r\n    constructor(Controller _controller)\r\n        public\r\n        SecurityModule(_controller)\r\n    {\r\n    }\r\n\r\n    function transferInternal(\r\n        address wallet,\r\n        address token,\r\n        address to,\r\n        uint    amount,\r\n        bytes   memory logdata\r\n        )\r\n        internal\r\n    {\r\n        if (token == address(0)) {\r\n            transactCall(wallet, to, amount, \"\");\r\n        } else {\r\n            require(\r\n                transactTokenTransfer(wallet, token, to, amount),\r\n                \"TRANSFER_FAILED\"\r\n            );\r\n        }\r\n        emit Transfered(wallet, token, to, amount, logdata);\r\n    }\r\n\r\n    function approveInternal(\r\n        address wallet,\r\n        address token,\r\n        address spender,\r\n        uint    amount\r\n        )\r\n        internal\r\n        returns (uint additionalAllowance)\r\n    {\r\n        require(token != address(0), \"UNSUPPORTED\");\r\n\r\n        // Current allowance\r\n        uint allowance = ERC20(token).allowance(wallet, spender);\r\n\r\n        if (amount != allowance) {\r\n            // First reset the approved amount if needed\r\n            bytes memory txData;\r\n            if (allowance > 0) {\r\n                require(\r\n                    transactTokenApprove(wallet, token, spender, 0),\r\n                    \"APPROVAL_FAILED\"\r\n                );\r\n            }\r\n\r\n            // Now approve the requested amount\r\n            require(\r\n                transactTokenApprove(wallet, token, spender, amount),\r\n                \"APPROVAL_FAILED\"\r\n            );\r\n        }\r\n\r\n        // If we increased the allowance, calculate by how much\r\n        if (amount > allowance) {\r\n            additionalAllowance = amount.sub(allowance);\r\n        }\r\n        emit Approved(wallet, token, spender, amount);\r\n    }\r\n\r\n    function callContractInternal(\r\n        address wallet,\r\n        address to,\r\n        uint    value,\r\n        bytes   memory txData\r\n        )\r\n        internal\r\n        virtual\r\n        returns (bytes memory returnData)\r\n    {\r\n        // Calls from the wallet to itself are deemed special\r\n        // (e.g. this is used for updating the wallet implementation)\r\n        // We also disallow calls to module functions directly\r\n        // (e.g. this is used for some special wallet <-> module interaction)\r\n        require(wallet != to && !Wallet(wallet).hasModule(to), \"CALL_DISALLOWED\");\r\n        returnData = transactCall(wallet, to, value, txData);\r\n        emit ContractCalled(wallet, to, value, txData);\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title DappTransfers\r\ncontract DappTransfers is TransferModule\r\n{\r\n\r\n    constructor(Controller _controller)\r\n        public\r\n        TransferModule(_controller)\r\n    {\r\n    }\r\n\r\n    modifier onlyWhitelistedDapp(address addr)\r\n    {\r\n        require(controller.dappAddressStore().isDapp(addr), \"DISALLOWED\");\r\n        _;\r\n    }\r\n\r\n    function transferToken(\r\n        address            wallet,\r\n        address            token,\r\n        address            to,\r\n        uint               amount,\r\n        bytes     calldata logdata\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyWhitelistedDapp(to)\r\n        onlyWhenWalletUnlocked(wallet)\r\n        onlyFromMetaTxOrWalletOwner(wallet)\r\n    {\r\n        transferInternal(wallet, token, to, amount, logdata);\r\n    }\r\n\r\n    function approveToken(\r\n        address            wallet,\r\n        address            token,\r\n        address            to,\r\n        uint               amount\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyWhitelistedDapp(to)\r\n        onlyWhenWalletUnlocked(wallet)\r\n        onlyFromMetaTxOrWalletOwner(wallet)\r\n    {\r\n        approveInternal(wallet, token, to, amount);\r\n    }\r\n\r\n    function callContract(\r\n        address            wallet,\r\n        address            to,\r\n        uint               value,\r\n        bytes     calldata data\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyWhitelistedDapp(to)\r\n        onlyWhenWalletUnlocked(wallet)\r\n        onlyFromMetaTxOrWalletOwner(wallet)\r\n        returns (bytes memory returnData)\r\n    {\r\n        return callContractInternal(wallet, to, value, data);\r\n    }\r\n\r\n    function approveThenCallContract(\r\n        address            wallet,\r\n        address            token,\r\n        address            to,\r\n        uint               amount,\r\n        uint               value,\r\n        bytes     calldata data\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyWhitelistedDapp(to)\r\n        onlyWhenWalletUnlocked(wallet)\r\n        onlyFromMetaTxOrWalletOwner(wallet)\r\n        returns (bytes memory returnData)\r\n    {\r\n        approveInternal(wallet, token, to, amount);\r\n        return callContractInternal(wallet, to, value, data);\r\n    }\r\n\r\n    function verifySigners(\r\n        address   wallet,\r\n        bytes4    method,\r\n        bytes     memory /*data*/,\r\n        address[] memory signers\r\n        )\r\n        internal\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        require (\r\n            method == this.transferToken.selector ||\r\n            method == this.approveToken.selector ||\r\n            method == this.callContract.selector ||\r\n            method == this.approveThenCallContract.selector,\r\n            \"INVALID_METHOD\"\r\n        );\r\n        return isOnlySigner(Wallet(wallet).owner(), signers);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Controller\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"Activated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ContractCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"Deactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transactor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"metaTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"MetaTxExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"logdata\",\"type\":\"bytes\"}],\"name\":\"Transfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lock\",\"type\":\"uint256\"}],\"name\":\"WalletLock\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"METATRANSACTION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_ACTIVE_GUARDIANS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"addModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveThenCallContract\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bindableMethods\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"methods\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callContract\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"collectTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract Controller\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"uint256[5]\",\"name\":\"gasSetting\",\"type\":\"uint256[5]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"}],\"name\":\"executeMetaTx\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"lastNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"logdata\",\"type\":\"bytes\"}],\"name\":\"transferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DappTransfers","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000728348a947b808483365bf24f5f7886f0a9786bf","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0d0ac25980df9186d0814104ee4be54a61b6a4ced45d759c34b9a6c6865f71c7"}]}