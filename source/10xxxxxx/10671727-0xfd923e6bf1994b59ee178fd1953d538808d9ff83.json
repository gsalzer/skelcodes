{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n/**\r\n*英文名字，FSC\r\n*🇨🇳中文名:【公平的智能合约】\r\n*🏧游戏规则:游戏每轮投注统一使用ETH以太坊进出，币本位。（5天为一个周期）\r\n */\r\ncontract UtilFSC {\r\n\r\n    uint ethWei = 1 ether;\r\n    //    📶游戏分三个级别，投注金额分红和推广收益不同。\r\n    //◾ V1级别(投注1-3个以太坊)\r\n    //◾ V2级别(投注4-6个以太坊)\r\n    //◾ V3级别(投注7-10个以太坊)\r\n    function getLevel(uint value, uint _type) public view returns (uint) {\r\n        if (value >= 1 * ethWei && value <= 3 * ethWei) return 1;\r\n        if (value >= 4 * ethWei && value <= 6 * ethWei) return 2;\r\n        if (_type == 1 && value >= 7 * ethWei) return 3;\r\n        else if (_type == 2 && value >= 7 * ethWei && value <= 10 * ethWei) return 3;\r\n        return 0;\r\n    }\r\n    //Ⓜ️每日分红\r\n    //V1每天收益为1%\r\n    //V2每天收益为1.1%\r\n    //V3每天收益为1.2%\r\n    function getScByLevel(uint level) public pure returns (uint) {\r\n        if (level == 1) return 10;\r\n        if (level == 2) return 11;\r\n        if (level == 3) return 12;\r\n        return 0;\r\n    }\r\n    //❶完美的小推大烧伤机制。\r\n    //奖励烧伤：自己账户金额除以15为烧伤基数。\r\n    //不同等级有不同烧伤系数，\r\n    //V1为30%，\r\n    //V2为60%，\r\n    //V3为100%，\r\n    //例如：A推荐B，A入股 5ETH，B入股15ETH，则A每日得到的奖金为（15*1/100）*50%*5/15*30% 。\r\n    //如果B先投注，则A在未来7天奖励发放时都得不到B的推 荐奖励。\r\n    function getFireScByLevel(uint level) public pure returns (uint) {\r\n        if (level == 1) return 3;\r\n        if (level == 2) return 6;\r\n        if (level == 3) return 10;\r\n        return 0;\r\n    }\r\n\r\n    //Ⓜ️ 推广奖励\r\n    //  🔘 V1拿第1代收益的50%\r\n    //第2代收益的30%\r\n    //第3代收益的20%\r\n    //第4代收益的10%\r\n    //第5代收益的10%\r\n    //    🔘 V2拿第1代收益的50%\r\n    //        拿第2代收益的30%\r\n    //        第3代收益的20%\r\n    //        第4—10代收益的10%\r\n    //🔘 V3拿第1代收益的70%\r\n    //          拿第2代收益的30%\r\n    //          拿第3代收益的20%\r\n    //          拿第4-10代收益的10%\r\n    //          拿第11-20代收益15%\r\n    //          拿第21到-无限代1%\r\n\r\n    //            V1推荐3人拿5代。\r\n    //           V2 推荐5人拿10代。\r\n    //           V3 推荐1人拿1代 。\r\n    //            推荐5人拿5代。\r\n    //                 以此类推……\r\n    //            推荐9人拿9代。\r\n    //            推荐10人即可拿无限代。\r\n    //        投资级别和直推人数决定了自己动态奖金的深度。\r\n    function getRecommendScaleByLevelAndTim(uint level, uint times) public pure returns (uint){\r\n        if (level == 1) {\r\n            if (times == 1) return 50;\r\n            if (times == 2) return 30;\r\n            if (times == 3) return 20;\r\n            if (times == 4) return 10;\r\n            if (times == 5) return 10;\r\n        }\r\n        if (level == 2) {\r\n            if (times == 1) return 50;\r\n            if (times == 2) return 30;\r\n            if (times == 3) return 20;\r\n            if (times >= 4 && times <= 10) return 10;\r\n        }\r\n        if (level == 3) {\r\n            if (times == 1) return 70;\r\n            if (times == 2) return 30;\r\n            if (times == 3) return 20;\r\n            if (times >= 4 && times <= 10) return 10;\r\n            if (times >= 11 && times <= 20) return 15;\r\n            //            > 10 代  1%\r\n            if (times >= 21) return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function compareStr(string memory _str, string memory str) public pure returns (bool) {\r\n        if (keccak256(abi.encodePacked(_str)) == keccak256(abi.encodePacked(str))) return true;\r\n        return false;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor() internal {}\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n\r\n    struct Role {\r\n        mapping(address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole is Context, Ownable {\r\n\r\n    using Roles for Roles.Role;\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(_msgSender()) || isOwner(), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account) || isOwner();\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyOwner {\r\n        _whitelistAdmins.add(account);\r\n    }\r\n\r\n    function removeWhitelistAdmin(address account) public onlyOwner {\r\n        _whitelistAdmins.remove(account);\r\n    }\r\n}\r\n\r\ncontract FSC is UtilFSC, WhitelistAdminRole {\r\n\r\n    using SafeMath for *;\r\n    uint ethWei = 1 ether;\r\n    //    FSC合约收益地址\r\n    address payable private devAddr = address(0x445042C0e21855cC7A32299302f7F1085a5d447C);\r\n    //    address payable private devAddr = address(0x6A70363e19A0301D42698159b985bA91C7f6f802);\r\n    //    FSC合约慈善基金10%\r\n    address payable private comfortAddr = address(0xe0d2beD8fddcFC27962baa3450e77430163f37E7);\r\n    //    address payable private comfortAddr = address(0x849f948Fbb1D7B8791acF8638724679fcF8B21Ef);\r\n    //    前提现有个10%\r\n    //的手续费扣除\r\n    address payable private feeAddr = address(0x68D1219A571466e2ab346A43A1dcA986201b4584);\r\n    //    address payable private feeAddr = address(0xf199378b6026b8141e77964A9e57cA35597ffB84);\r\n    //   当前账户余额,每天结算时候,清算一次,\r\n    uint public currBalance = 0 ether;\r\n    uint curr = 0 ether;\r\n    uint _time = now;\r\n\r\n    struct User {\r\n        uint id;\r\n        address userAddress;\r\n        uint freeAmount;\r\n        uint freezeAmount;\r\n        uint lineAmount;\r\n        uint inviteAmonut;\r\n        uint dayBonusAmount;\r\n        uint bonusAmount;\r\n        uint level;\r\n        uint lineLevel;\r\n        uint resTime;\r\n        uint investTimes;\r\n        string inviteCode;\r\n        string beCode;\r\n        uint rewardIndex;\r\n        uint lastRwTime;\r\n        //        大周期\r\n        uint bigCycle;\r\n    }\r\n\r\n    struct UserGlobal {\r\n        uint id;\r\n        address userAddress;\r\n        string inviteCode;\r\n        string beCode;\r\n        uint status;\r\n    }\r\n\r\n    struct AwardData {\r\n        uint oneInvAmount;\r\n        uint twoInvAmount;\r\n        uint threeInvAmount;\r\n    }\r\n\r\n    uint lineStatus = 0;\r\n    mapping(uint => uint) rInvestCount;\r\n    mapping(uint => uint) rInvestMoney;\r\n    uint period = 1 days;\r\n    uint uid = 0;\r\n    uint rid = 1;\r\n    mapping(uint => uint[]) lineArrayMapping;\r\n    mapping(uint => mapping(address => User)) userRoundMapping;\r\n    mapping(address => UserGlobal) userMapping;\r\n    mapping(string => address) addressMapping;\r\n    mapping(uint => address) indexMapping;\r\n    mapping(uint => mapping(address => mapping(uint => AwardData))) userAwardDataMapping;\r\n    uint bonuslimit = 10 ether;\r\n    uint sendLimit = 100 ether;\r\n    uint withdrawLimit = 10 ether;\r\n    uint canImport = 1;\r\n    //    小周期 天数\r\n    uint smallCycle = 5;\r\n    //    uint smallCycle = 2;\r\n\r\n    uint jiangeTime = 12 hours;\r\n    //    uint jiangeTime = 12 seconds;\r\n\r\n    modifier isHuman() {\r\n        address addr = msg.sender;\r\n        uint codeLength;\r\n        assembly {codeLength := extcodesize(addr)}\r\n        require(codeLength == 0, \"sorry humans only\");\r\n        require(tx.origin == msg.sender, \"sorry, humans only\");\r\n        _;\r\n    }\r\n\r\n    constructor () public {\r\n    }\r\n\r\n    function() external payable {\r\n    }\r\n\r\n    function updateLine(uint line, uint small) external onlyWhitelistAdmin {\r\n        lineStatus = line;\r\n        smallCycle = small;\r\n    }\r\n\r\n    function isLine() private view returns (bool) {\r\n        return lineStatus != 0;\r\n    }\r\n\r\n    //    del\r\n    function actAllLimit(uint bonusLi, uint sendLi, uint withdrawLi) external onlyOwner {\r\n        require(bonusLi >= 15 ether && sendLi >= 100 ether && withdrawLi >= 15 ether, \"invalid amount\");\r\n        bonuslimit = bonusLi;\r\n        sendLimit = sendLi;\r\n        withdrawLimit = withdrawLi;\r\n    }\r\n\r\n    function stopImport() external onlyOwner {\r\n        canImport = 0;\r\n    }\r\n\r\n    function actUserStatus(address addr, uint status) external onlyWhitelistAdmin {\r\n        require(status == 0 || status == 1 || status == 2, \"bad parameter status\");\r\n        UserGlobal storage userGlobal = userMapping[addr];\r\n        userGlobal.status = status;\r\n    }\r\n    //   加权\r\n    function repeatPldge() public {\r\n\r\n        User storage user = userRoundMapping[rid][msg.sender];\r\n        require(user.investTimes >= smallCycle, \"investTimes must more than 5\");\r\n        user.bigCycle += 1;\r\n        require(user.id != 0, \"user not exist\");\r\n        uint resultMoney = user.freeAmount + user.lineAmount;\r\n\r\n        user.freeAmount = 0;\r\n        user.lineAmount = 0;\r\n        user.lineLevel = getLevel(user.freezeAmount, 1);\r\n\r\n        require(resultMoney >= 1 * ethWei && resultMoney <= 10 * ethWei, \"between 1 and 10\");\r\n\r\n        uint investAmout;\r\n        uint lineAmount;\r\n        if (isLine()) lineAmount = resultMoney;\r\n        else investAmout = resultMoney;\r\n        require(user.freezeAmount.add(user.lineAmount) == 0, \"only once invest\");\r\n        user.freezeAmount = investAmout;\r\n        user.lineAmount = lineAmount;\r\n        user.level = getLevel(user.freezeAmount, 2);\r\n        user.lineLevel = getLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount), 1);\r\n\r\n        rInvestCount[rid] = rInvestCount[rid].add(1);\r\n        rInvestMoney[rid] = rInvestMoney[rid].add(resultMoney);\r\n        if (!isLine()) {\r\n            sendFeetoAdmin(resultMoney);\r\n            countBonus(user.userAddress);\r\n        } else lineArrayMapping[rid].push(user.id);\r\n\r\n\r\n    }\r\n\r\n    function exit(string memory inviteCode, string memory beCode) public isHuman() payable {\r\n\r\n        require(msg.value >= 1 * ethWei && msg.value <= 10 * ethWei, \"between 1 and 10\");\r\n        require(msg.value == msg.value.div(ethWei).mul(ethWei), \"invalid msg value\");\r\n\r\n        UserGlobal storage userGlobal = userMapping[msg.sender];\r\n        if (userGlobal.id == 0) {\r\n            require(!compareStr(inviteCode, \"\") && bytes(inviteCode).length == 6, \"invalid invite code\");\r\n            address beCodeAddr = addressMapping[beCode];\r\n            require(isUsed(beCode), \"beCode not exist\");\r\n            require(beCodeAddr != msg.sender, \"beCodeAddr can't be self\");\r\n            require(!isUsed(inviteCode), \"invite code is used\");\r\n            registerUser(msg.sender, inviteCode, beCode);\r\n        }\r\n        uint investAmout;\r\n        uint lineAmount;\r\n        if (isLine()) lineAmount = msg.value;\r\n        else investAmout = msg.value;\r\n        User storage user = userRoundMapping[rid][msg.sender];\r\n        if (user.id != 0) {\r\n            require(user.freezeAmount.add(user.lineAmount) == 0, \"only once invest\");\r\n            user.freezeAmount = investAmout;\r\n            user.lineAmount = lineAmount;\r\n            user.level = getLevel(user.freezeAmount, 2);\r\n            user.lineLevel = getLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount), 1);\r\n        } else {\r\n            user.id = userGlobal.id;\r\n            user.userAddress = msg.sender;\r\n            user.freezeAmount = investAmout;\r\n            user.level = getLevel(investAmout, 2);\r\n            user.lineAmount = lineAmount;\r\n            user.lineLevel = getLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount), 1);\r\n            user.inviteCode = userGlobal.inviteCode;\r\n            user.beCode = userGlobal.beCode;\r\n        }\r\n\r\n        rInvestCount[rid] = rInvestCount[rid].add(1);\r\n        rInvestMoney[rid] = rInvestMoney[rid].add(msg.value);\r\n        if (!isLine()) {\r\n            sendFeetoAdmin(msg.value);\r\n            countBonus(user.userAddress);\r\n        } else lineArrayMapping[rid].push(user.id);\r\n    }\r\n\r\n    function importGlobal(address addr, string calldata inviteCode, string calldata beCode) external onlyWhitelistAdmin {\r\n        require(canImport == 1, \"import stopped\");\r\n        UserGlobal storage user = userMapping[addr];\r\n        require(user.id == 0, \"user already exists\");\r\n        require(!compareStr(inviteCode, \"\"), \"empty invite code\");\r\n        if (uid != 0) require(!compareStr(beCode, \"\"), \"empty beCode\");\r\n        address beCodeAddr = addressMapping[beCode];\r\n        require(beCodeAddr != addr, \"beCodeAddr can't be self\");\r\n        require(!isUsed(inviteCode), \"invite code is used\");\r\n\r\n        registerUser(addr, inviteCode, beCode);\r\n    }\r\n\r\n    //    del\r\n    function helloworld(uint start, uint end, uint isUser) external onlyWhitelistAdmin {\r\n        for (uint i = start; i <= end; i++) {\r\n            uint userId = 0;\r\n            if (isUser == 0) userId = lineArrayMapping[rid][i];\r\n            else userId = i;\r\n            address userAddr = indexMapping[userId];\r\n            User storage user = userRoundMapping[rid][userAddr];\r\n            if (user.freezeAmount == 0 && user.lineAmount >= 1 ether && user.lineAmount <= 10 ether) {\r\n                user.freezeAmount = user.lineAmount;\r\n                user.level = getLevel(user.freezeAmount, 2);\r\n                user.lineAmount = 0;\r\n                sendFeetoAdmin(user.freezeAmount);\r\n                countBonus(user.userAddress);\r\n            }\r\n        }\r\n    }\r\n\r\n    function countBonus(address userAddr) private {\r\n        User storage user = userRoundMapping[rid][userAddr];\r\n        if (user.id == 0) return;\r\n        uint scale = getScByLevel(user.level);\r\n        user.dayBonusAmount = user.freezeAmount.mul(scale).div(1000);\r\n        user.investTimes = 0;\r\n        UserGlobal memory userGlobal = userMapping[userAddr];\r\n        if (user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit && userGlobal.status == 0) getaway(user.beCode, user.freezeAmount, scale);\r\n\r\n    }\r\n\r\n    function getaway(string memory beCode, uint money, uint shareSc) private {\r\n        string memory tmpReferrer = beCode;\r\n\r\n        for (uint i = 1; i <= 25; i++) {\r\n            if (compareStr(tmpReferrer, \"\")) break;\r\n            address tmpUserAddr = addressMapping[tmpReferrer];\r\n            UserGlobal storage userGlobal = userMapping[tmpUserAddr];\r\n            User storage calUser = userRoundMapping[rid][tmpUserAddr];\r\n\r\n            if (calUser.freezeAmount.add(calUser.freeAmount).add(calUser.lineAmount) == 0) {\r\n                tmpReferrer = userGlobal.beCode;\r\n                continue;\r\n            }\r\n\r\n            uint recommendSc = getRecommendScaleByLevelAndTim(3, i);\r\n            uint moneyResult = 0;\r\n            if (money <= 10 ether) moneyResult = money;\r\n            else moneyResult = 10 ether;\r\n\r\n            if (recommendSc != 0) {\r\n                uint tmpDynamicAmount = moneyResult.mul(shareSc).mul(recommendSc);\r\n                tmpDynamicAmount = tmpDynamicAmount.div(1000).div(100);\r\n                earneth(userGlobal.userAddress, tmpDynamicAmount, calUser.rewardIndex, i);\r\n            }\r\n            tmpReferrer = userGlobal.beCode;\r\n        }\r\n    }\r\n\r\n    function earneth(address userAddr, uint dayInvAmount, uint rewardIndex, uint times) private {\r\n        for (uint i = 0; i < smallCycle; i++) {\r\n            AwardData storage awData = userAwardDataMapping[rid][userAddr][rewardIndex.add(i)];\r\n            if (times == 1) awData.oneInvAmount += dayInvAmount;\r\n            if (times == 2) awData.twoInvAmount += dayInvAmount;\r\n            awData.threeInvAmount += dayInvAmount;\r\n        }\r\n    }\r\n\r\n    function happy() public isHuman() {\r\n\r\n        User storage user = userRoundMapping[rid][msg.sender];\r\n        require(user.id != 0, \"user not exist\");\r\n        uint sendMoney = user.freeAmount + user.lineAmount;\r\n\r\n        bool isEnough = false;\r\n        uint resultMoney = 0;\r\n        uint resultMoney1 = 0;\r\n        (isEnough, resultMoney) = isEnoughBalance(sendMoney);\r\n        //❷5天一轮结束后，自由选择，可以选择复投，可以选择离开，离开扣10%手续费，10轮后离开不扣手续费\r\n        if (user.bigCycle < 10) resultMoney1 = resultMoney.mul(9).div(10);\r\n        if (resultMoney1 > 0 && resultMoney1 <= withdrawLimit) {\r\n            sendMoneyToUser(msg.sender, resultMoney1);\r\n            user.freeAmount = 0;\r\n            user.lineAmount = 0;\r\n            user.bigCycle = 0;\r\n            user.lineLevel = getLevel(user.freezeAmount, 1);\r\n        }\r\n        //        手续费15/100扣除\r\n        if (user.bigCycle < 10) sendMoneyToUser(feeAddr, resultMoney.mul(15).div(100));\r\n    }\r\n\r\n    function christmas(uint start, uint end) external onlyWhitelistAdmin {\r\n\r\n        if (_time - now > jiangeTime) {\r\n            if (address(this).balance > curr) currBalance = address(this).balance.sub(curr);\r\n            else currBalance = 0 ether;\r\n            curr = address(this).balance;\r\n        }\r\n        for (uint i = start; i <= end; i++) {\r\n            address userAddr = indexMapping[i];\r\n            User storage user = userRoundMapping[rid][userAddr];\r\n            UserGlobal memory userGlobal = userMapping[userAddr];\r\n            if (now.sub(user.lastRwTime) <= jiangeTime) {\r\n                continue;\r\n            }\r\n            uint bonusSend = 0;\r\n            //              为了奖励全球忠实粉丝，对于V2级别以上玩家，做出如下奖励：\r\n            //▪️ 凡参与11轮(含11轮)以上的拿全球当日新增业绩的1%加权分红。\r\n            //▪️ 凡参与20轮以上的拿全球当日新增存币的2%加权分红。\r\n            //▪️ 凡参与30轮以上的拿全球当日新增业绩的3%的加权分红。\r\n            if (user.level >= 2) {\r\n                uint inviteSendQ = 0;\r\n                if (user.bigCycle >= 10 && user.bigCycle < 20) inviteSendQ = currBalance.div(100);\r\n                else if (user.bigCycle >= 20 && user.bigCycle < 30) inviteSendQ = currBalance.div(50);\r\n                else if (user.bigCycle >= 30) inviteSendQ = currBalance.div(100).mul(3);\r\n\r\n\r\n                bool isEnough = false;\r\n                uint resultMoneyQ = 0;\r\n                (isEnough, resultMoneyQ) = isEnoughBalance(bonusSend.add(inviteSendQ));\r\n                if (resultMoneyQ > 0) {\r\n                    address payable sendAddr = address(uint160(userAddr));\r\n                    sendMoneyToUser(sendAddr, resultMoneyQ);\r\n                }\r\n            }\r\n            user.lastRwTime = now;\r\n            if (userGlobal.status == 1) {\r\n                user.rewardIndex = user.rewardIndex.add(1);\r\n                continue;\r\n            }\r\n\r\n            if (user.id != 0 && user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit) {\r\n                if (user.investTimes < smallCycle) {\r\n                    bonusSend += user.dayBonusAmount;\r\n                    user.bonusAmount = user.bonusAmount.add(bonusSend);\r\n                    user.investTimes = user.investTimes.add(1);\r\n                } else {\r\n                    user.freeAmount = user.freeAmount.add(user.freezeAmount);\r\n                    user.freezeAmount = 0;\r\n                    user.dayBonusAmount = 0;\r\n                    user.level = 0;\r\n                }\r\n            }\r\n            uint lineAmount = user.freezeAmount.add(user.freeAmount).add(user.lineAmount);\r\n            if (lineAmount < 1 ether || lineAmount > withdrawLimit) {\r\n                user.rewardIndex = user.rewardIndex.add(1);\r\n                continue;\r\n            }\r\n            uint inviteSend = 0;\r\n            if (userGlobal.status == 0) {\r\n                AwardData memory awData = userAwardDataMapping[rid][userAddr][user.rewardIndex];\r\n                user.rewardIndex = user.rewardIndex.add(1);\r\n                uint lineValue = lineAmount.div(ethWei);\r\n                if (lineValue >= 15) {\r\n                    inviteSend += awData.threeInvAmount;\r\n                } else {\r\n                    if (user.lineLevel == 1 && lineAmount >= 1 ether && awData.oneInvAmount > 0) inviteSend += awData.oneInvAmount.div(15).mul(lineValue).div(2);\r\n\r\n                    if (user.lineLevel == 2 && lineAmount >= 6 ether && (awData.oneInvAmount > 0 || awData.twoInvAmount > 0)) {\r\n                        inviteSend += awData.oneInvAmount.div(15).mul(lineValue).mul(7).div(10);\r\n                        inviteSend += awData.twoInvAmount.div(15).mul(lineValue).mul(5).div(7);\r\n                    }\r\n                    if (user.lineLevel == 3 && lineAmount >= 11 ether && awData.threeInvAmount > 0) inviteSend += awData.threeInvAmount.div(15).mul(lineValue);\r\n\r\n                    if (user.lineLevel < 3) {\r\n                        uint fireSc = getFireScByLevel(user.lineLevel);\r\n                        inviteSend = inviteSend.mul(fireSc).div(10);\r\n                    }\r\n                }\r\n            } else if (userGlobal.status == 2) user.rewardIndex = user.rewardIndex.add(1);\r\n\r\n            if (bonusSend.add(inviteSend) <= sendLimit) {\r\n                user.inviteAmonut = user.inviteAmonut.add(inviteSend);\r\n                bool isEnough = false;\r\n                uint resultMoney = 0;\r\n                (isEnough, resultMoney) = isEnoughBalance(bonusSend.add(inviteSend));\r\n                if (resultMoney > 0) {\r\n                    uint confortMoney = resultMoney.div(10);\r\n                    sendMoneyToUser(comfortAddr, confortMoney);\r\n                    resultMoney = resultMoney.sub(confortMoney);\r\n                    address payable sendAddr = address(uint160(userAddr));\r\n                    sendMoneyToUser(sendAddr, resultMoney);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        _time = now;\r\n    }\r\n\r\n    function isEnoughBalance(uint sendMoney) private view returns (bool, uint){\r\n        if (sendMoney >= address(this).balance) return (false, address(this).balance);\r\n        else return (true, sendMoney);\r\n    }\r\n    //    📌技术开发及维护费\r\n    //      投注金额的5%，会自动划拨到专用账户，3%用于技术开发和维护，1% 用于生态发展与基础建设，1%用于创始团队开发市场。95%返补市场进入游戏分红。分红按实际投资金额分红。\r\n    // 投注金额的5%，会自动划拨到专用账户\r\n    function sendFeetoAdmin(uint amount) private {\r\n        //        5% 专用账户\r\n        devAddr.transfer(amount.div(20));\r\n    }\r\n    //1%用于创始团队开发市场\r\n    function sendMoneyToUser(address payable userAddress, uint money) private {\r\n        if (money > 0) userAddress.transfer(money);\r\n    }\r\n\r\n    function isUsed(string memory code) public view returns (bool) {\r\n        address addr = addressMapping[code];\r\n        return uint(addr) != 0;\r\n    }\r\n\r\n    function getUserAddressByCode(string memory code) public view returns (address) {\r\n        require(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n        return addressMapping[code];\r\n    }\r\n\r\n    function registerUser(address addr, string memory inviteCode, string memory beCode) private {\r\n        UserGlobal storage userGlobal = userMapping[addr];\r\n        uid++;\r\n        userGlobal.id = uid;\r\n        userGlobal.userAddress = addr;\r\n        userGlobal.inviteCode = inviteCode;\r\n        userGlobal.beCode = beCode;\r\n\r\n        addressMapping[inviteCode] = addr;\r\n        indexMapping[uid] = addr;\r\n    }\r\n\r\n    function donnottouch() public view returns (uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n        return (\r\n        rid,\r\n        uid,\r\n        now,\r\n        rInvestCount[rid],\r\n        rInvestMoney[rid],\r\n        bonuslimit,\r\n        sendLimit,\r\n        withdrawLimit,\r\n        canImport,\r\n        lineStatus,\r\n        lineArrayMapping[rid].length,\r\n        1\r\n        );\r\n    }\r\n\r\n    function getUserByAddress(address addr, uint roundId) public view returns (uint[15] memory info, string memory inviteCode, string memory beCode) {\r\n        require(isWhitelistAdmin(msg.sender) || msg.sender == addr, \"Permission denied for view user's privacy\");\r\n\r\n        if (roundId == 0) roundId = rid;\r\n\r\n        UserGlobal memory userGlobal = userMapping[addr];\r\n        User memory user = userRoundMapping[roundId][addr];\r\n        info[0] = userGlobal.id;\r\n        info[1] = user.lineAmount;\r\n        info[2] = user.freeAmount;\r\n        info[3] = user.freezeAmount;\r\n        info[4] = user.inviteAmonut;\r\n        info[5] = user.bonusAmount;\r\n        info[6] = user.lineLevel;\r\n        info[7] = user.dayBonusAmount;\r\n        info[8] = user.rewardIndex;\r\n        info[9] = user.investTimes;\r\n        info[10] = user.level;\r\n        uint grantAmount = 0;\r\n        if (user.id > 0 && user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit && user.investTimes < 7 && userGlobal.status != 1) grantAmount += user.dayBonusAmount;\r\n\r\n        if (userGlobal.status == 0) {\r\n            uint inviteSend = 0;\r\n            AwardData memory awData = userAwardDataMapping[rid][user.userAddress][user.rewardIndex];\r\n            uint lineAmount = user.freezeAmount.add(user.freeAmount).add(user.lineAmount);\r\n            if (lineAmount >= 1 ether) {\r\n                uint lineValue = lineAmount.div(ethWei);\r\n                if (lineValue >= 15) inviteSend += awData.threeInvAmount;\r\n                else {\r\n                    if (user.lineLevel == 1 && lineAmount >= 1 ether && awData.oneInvAmount > 0) inviteSend += awData.oneInvAmount.div(15).mul(lineValue).div(2);\r\n\r\n                    if (user.lineLevel == 2 && lineAmount >= 1 ether && (awData.oneInvAmount > 0 || awData.twoInvAmount > 0)) {\r\n                        inviteSend += awData.oneInvAmount.div(15).mul(lineValue).mul(7).div(10);\r\n                        inviteSend += awData.twoInvAmount.div(15).mul(lineValue).mul(5).div(7);\r\n                    }\r\n                    if (user.lineLevel == 3 && lineAmount >= 1 ether && awData.threeInvAmount > 0) inviteSend += awData.threeInvAmount.div(15).mul(lineValue);\r\n\r\n                    if (user.lineLevel < 3) {\r\n                        uint fireSc = getFireScByLevel(user.lineLevel);\r\n                        inviteSend = inviteSend.mul(fireSc).div(10);\r\n                    }\r\n                }\r\n                grantAmount += inviteSend;\r\n            }\r\n        }\r\n        info[11] = grantAmount;\r\n        info[12] = user.lastRwTime;\r\n        info[13] = userGlobal.status;\r\n        info[14] = user.bigCycle;\r\n\r\n        return (info, userGlobal.inviteCode, userGlobal.beCode);\r\n    }\r\n\r\n    function getUserAddressById(uint id) public view returns (address) {\r\n        require(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n        return indexMapping[id];\r\n    }\r\n\r\n    function getLineUserId(uint index, uint rouId) public view returns (uint) {\r\n        require(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n        if (rouId == 0) rouId = rid;\r\n        return lineArrayMapping[rid][index];\r\n    }\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) return 0;\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"mul overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"div zero\");\r\n        // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"lower sub bigger\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"mod zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n    * @dev compare two numbers and returns the smaller one.\r\n    */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? b : a;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"getRecommendScaleByLevelAndTim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inviteCode\",\"type\":\"string\"},{\"name\":\"beCode\",\"type\":\"string\"}],\"name\":\"exit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopImport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getUserByAddress\",\"outputs\":[{\"name\":\"info\",\"type\":\"uint256[15]\"},{\"name\":\"inviteCode\",\"type\":\"string\"},{\"name\":\"beCode\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"rouId\",\"type\":\"uint256\"}],\"name\":\"getLineUserId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"line\",\"type\":\"uint256\"},{\"name\":\"small\",\"type\":\"uint256\"}],\"name\":\"updateLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"isUsed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"christmas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donnottouch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_str\",\"type\":\"string\"},{\"name\":\"str\",\"type\":\"string\"}],\"name\":\"compareStr\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserAddressById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"actUserStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"repeatPldge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"getUserAddressByCode\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"isUser\",\"type\":\"uint256\"}],\"name\":\"helloworld\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bonusLi\",\"type\":\"uint256\"},{\"name\":\"sendLi\",\"type\":\"uint256\"},{\"name\":\"withdrawLi\",\"type\":\"uint256\"}],\"name\":\"actAllLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"inviteCode\",\"type\":\"string\"},{\"name\":\"beCode\",\"type\":\"string\"}],\"name\":\"importGlobal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getFireScByLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"happy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getScByLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"FSC","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9fd8d20500f910643c28b7edd60121d534094a0acdf910614a7857bc037249e0"}]}