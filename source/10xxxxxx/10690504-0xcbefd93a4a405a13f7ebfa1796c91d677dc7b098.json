{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: solidity/contracts/converter/interfaces/ITypedConverterCustomFactory.sol\n\npragma solidity 0.4.26;\n\n/*\n    Typed Converter Custom Factory interface\n*/\ncontract ITypedConverterCustomFactory {\n    function converterType() public pure returns (uint16);\n}\n\n// File: solidity/contracts/utility/Utils.sol\n\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\n\n// File: solidity/contracts/utility/SafeMath.sol\n\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   value 1\r\n      * @param _y   value 2\r\n      *\r\n      * @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n      *\r\n      * @param _x   minuend\r\n      * @param _y   subtrahend\r\n      *\r\n      * @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   factor 1\r\n      * @param _y   factor 2\r\n      *\r\n      * @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n      *\r\n      * @param _x   dividend\r\n      * @param _y   divisor\r\n      *\r\n      * @return quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\n\n// File: solidity/contracts/utility/interfaces/IChainlinkPriceOracle.sol\n\npragma solidity 0.4.26;\n\n/*\n    Chainlink Price Oracle interface\n*/\ninterface IChainlinkPriceOracle {\n    function latestAnswer() external view returns (int256);\n    function latestTimestamp() external view returns (uint256);\n}\n\n// File: solidity/contracts/token/interfaces/IERC20Token.sol\n\npragma solidity 0.4.26;\n\n/*\n    ERC20 Standard Token interface\n*/\ncontract IERC20Token {\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n    function name() public view returns (string) {this;}\n    function symbol() public view returns (string) {this;}\n    function decimals() public view returns (uint8) {this;}\n    function totalSupply() public view returns (uint256) {this;}\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n// File: solidity/contracts/utility/interfaces/IPriceOracle.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Price Oracle interface\n*/\ncontract IPriceOracle {\n    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB) public view returns (uint256, uint256);\n    function lastUpdateTime() public view returns (uint256);\n    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB) public view returns (uint256, uint256, uint256);\n\n    function tokenAOracle() public view returns (IChainlinkPriceOracle) {this;}\n    function tokenBOracle() public view returns (IChainlinkPriceOracle) {this;}\n}\n\n// File: solidity/contracts/utility/PriceOracle.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\n\r\n/**\r\n  * @dev Provides the off-chain rate between two tokens\r\n  *\r\n  * The price oracle uses chainlink oracles internally to get the rates of the two tokens\r\n  * with respect to a common denominator, and then returns the rate between them, which\r\n  * is equivalent to the rate of TokenA / TokenB\r\n*/\r\ncontract PriceOracle is IPriceOracle, Utils {\r\n    using SafeMath for uint256;\r\n\r\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    uint8 private constant ETH_DECIMALS = 18;\r\n\r\n    IERC20Token public tokenA;                  // token A the oracle supports\r\n    IERC20Token public tokenB;                  // token B the oracle supports\r\n    mapping (address => uint8) public tokenDecimals; // token -> token decimals\r\n\r\n    IChainlinkPriceOracle public tokenAOracle;  // token A chainlink price oracle\r\n    IChainlinkPriceOracle public tokenBOracle;  // token B chainlink price oracle\r\n    mapping (address => IChainlinkPriceOracle) public tokensToOracles;  // token -> price oracle for easier access\r\n\r\n    /**\r\n      * @dev initializes a new PriceOracle instance\r\n      * note that the oracles must have the same common denominator (USD, ETH etc.)\r\n      *\r\n      * @param  _tokenA         first token to support\r\n      * @param  _tokenB         second token to support\r\n      * @param  _tokenAOracle   first token price oracle\r\n      * @param  _tokenBOracle   second token price oracle\r\n    */\r\n    constructor(IERC20Token _tokenA, IERC20Token _tokenB, IChainlinkPriceOracle _tokenAOracle, IChainlinkPriceOracle _tokenBOracle)\r\n        public\r\n        validUniqueAddresses(_tokenA, _tokenB)\r\n        validUniqueAddresses(_tokenAOracle, _tokenBOracle)\r\n    {\r\n        tokenA = _tokenA;\r\n        tokenB = _tokenB;\r\n        tokenDecimals[_tokenA] = decimals(_tokenA);\r\n        tokenDecimals[_tokenB] = decimals(_tokenB);\r\n\r\n        tokenAOracle = _tokenAOracle;\r\n        tokenBOracle = _tokenBOracle;\r\n        tokensToOracles[_tokenA] = _tokenAOracle;\r\n        tokensToOracles[_tokenB] = _tokenBOracle;\r\n    }\r\n\r\n    // ensures that the provided addresses are unique valid\r\n    modifier validUniqueAddresses(address _address1, address _address2) {\r\n        _validUniqueAddresses(_address1, _address2);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validUniqueAddresses(address _address1, address _address2) internal pure {\r\n        _validAddress(_address1);\r\n        _validAddress(_address2);\r\n        require(_address1 != _address2, \"ERR_SAME_ADDRESS\");\r\n    }\r\n\r\n    // ensures that the provides tokens are supported by the oracle\r\n    modifier supportedTokens(IERC20Token _tokenA, IERC20Token _tokenB) {\r\n        _supportedTokens(_tokenA, _tokenB);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _supportedTokens(IERC20Token _tokenA, IERC20Token _tokenB) internal view {\r\n        _validUniqueAddresses(_tokenA, _tokenB);\r\n        require(tokensToOracles[_tokenA] != address(0) && tokensToOracles[_tokenB] != address(0), \"ERR_UNSUPPORTED_TOKEN\");\r\n    }\r\n\r\n    /**\r\n      * @dev returns the latest known rate between the two given tokens\r\n      * for a given pair of tokens A and B, returns the rate of A / B\r\n      * (the number of B units equivalent to a single A unit)\r\n      * the rate is returned as a fraction (numerator / denominator) for accuracy\r\n      *\r\n      * @param  _tokenA token to get the rate of 1 unit of\r\n      * @param  _tokenB token to get the rate of 1 `_tokenA` against\r\n      *\r\n      * @return numerator\r\n      * @return denominator\r\n    */\r\n    function latestRate(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        supportedTokens(_tokenA, _tokenB)\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 rateTokenA = uint256(tokensToOracles[_tokenA].latestAnswer());\r\n        uint256 rateTokenB = uint256(tokensToOracles[_tokenB].latestAnswer());\r\n        uint8 decimalsTokenA = tokenDecimals[_tokenA];\r\n        uint8 decimalsTokenB = tokenDecimals[_tokenB];\r\n\r\n        // the normalization works as follows:\r\n        //   - token A with decimals of dA and price of rateA per one token (e.g., for 10^dA weiA)\r\n        //   - token B with decimals of dB < dA and price of rateB per one token (e.g., for 10^dB weiB)\r\n        // then the normalized rate, representing the rate between 1 weiA and 1 weiB is rateA / (rateB * 10^(dA - dB)).\r\n        //\r\n        // for example:\r\n        //   - token A with decimals of 5 and price of $10 per one token (e.g., for 100,000 weiA)\r\n        //   - token B with decimals of 2 and price of $2 per one token (e.g., for 100 weiB)\r\n        // then the normalized rate would be: 5 / (2 * 10^3) = 0.0025, which is the correct rate since\r\n        // 1 weiA costs $0.00005, 1 weiB costs $0.02, and weiA / weiB is 0.0025.\r\n\r\n        if (decimalsTokenA > decimalsTokenB) {\r\n            rateTokenB = rateTokenB.mul(uint256(10) ** (decimalsTokenA - decimalsTokenB));\r\n        }\r\n        else if (decimalsTokenA < decimalsTokenB) {\r\n            rateTokenA = rateTokenA.mul(uint256(10) ** (decimalsTokenB - decimalsTokenA));\r\n        }\r\n\r\n        return (rateTokenA, rateTokenB);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the timestamp of the last price update\r\n      *\r\n      * @return timestamp\r\n    */\r\n    function lastUpdateTime()\r\n        public\r\n        view\r\n        returns (uint256) {\r\n        // returns the oldest timestamp between the two\r\n        uint256 timestampA = tokenAOracle.latestTimestamp();\r\n        uint256 timestampB = tokenBOracle.latestTimestamp();\r\n\r\n        return  timestampA > timestampB ? timestampA : timestampB;\r\n    }\r\n\r\n    /**\r\n      * @dev returns both the rate and the timestamp of the last update in a single call (gas optimization)\r\n      *\r\n      * @param  _tokenA token to get the rate of 1 unit of\r\n      * @param  _tokenB token to get the rate of 1 `_tokenA` against\r\n      *\r\n      * @return numerator\r\n      * @return denominator\r\n      * @return timestamp of the last update\r\n    */\r\n    function latestRateAndUpdateTime(IERC20Token _tokenA, IERC20Token _tokenB)\r\n        public\r\n        view\r\n        returns (uint256, uint256, uint256)\r\n    {\r\n        (uint256 numerator, uint256 denominator) = latestRate(_tokenA, _tokenB);\r\n\r\n        return (numerator, denominator, lastUpdateTime());\r\n    }\r\n\r\n    /** @dev returns the decimals of a given token */\r\n    function decimals(IERC20Token _token) private view returns (uint8) {\r\n        if (_token == ETH_ADDRESS) {\r\n            return ETH_DECIMALS;\r\n        }\r\n\r\n        return _token.decimals();\r\n    }\r\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/LiquidityPoolV2ConverterCustomFactory.sol\n\npragma solidity 0.4.26;\r\r\r\n\r\n/*\r\n    LiquidityPoolV2ConverterCustomFactory Factory\r\n*/\r\ncontract LiquidityPoolV2ConverterCustomFactory is ITypedConverterCustomFactory {\r\n    /**\r\n      * @dev returns the converter type the factory is associated with\r\n      *\r\n      * @return converter type\r\n    */\r\n    function converterType() public pure returns (uint16) {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n      * @dev creates a new price oracle\r\n      * note that the oracles must have the same common denominator (USD, ETH etc.)\r\n      *\r\n      * @param  _primaryReserveToken    primary reserve token address\r\n      * @param  _secondaryReserveToken  secondary reserve token address\r\n      * @param  _primaryReserveOracle   primary reserve oracle address\r\n      * @param  _secondaryReserveOracle secondary reserve oracle address\r\n    */\r\n    function createPriceOracle(\r\n        IERC20Token _primaryReserveToken,\r\n        IERC20Token _secondaryReserveToken,\r\n        IChainlinkPriceOracle _primaryReserveOracle,\r\n        IChainlinkPriceOracle _secondaryReserveOracle)\r\n        public\r\n        returns (IPriceOracle)\r\n    {\r\n        return new PriceOracle(_primaryReserveToken, _secondaryReserveToken, _primaryReserveOracle, _secondaryReserveOracle);\r\n    }\r\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_primaryReserveToken\",\"type\":\"address\"},{\"name\":\"_secondaryReserveToken\",\"type\":\"address\"},{\"name\":\"_primaryReserveOracle\",\"type\":\"address\"},{\"name\":\"_secondaryReserveOracle\",\"type\":\"address\"}],\"name\":\"createPriceOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"converterType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"LiquidityPoolV2ConverterCustomFactory","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}