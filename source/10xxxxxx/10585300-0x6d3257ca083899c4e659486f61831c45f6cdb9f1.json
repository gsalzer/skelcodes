{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract AntiScamCourtDapp{\r\n\r\n    //--State variables\r\n    IERC20 contractAST;\r\n    uint rewardPool;\r\n    address owner;\r\n    uint decimals;\r\n\r\n    // address public  activeCurator;\r\n    mapping (address=>bool) internal activeCurators;\r\n    uint public  dappCounter;\r\n    uint stakedSTT;\r\n\r\n    //-- custom data type\r\n    enum  status{inconclusive,scammed,Legit, inRevote}\r\n    struct dapp{\r\n        string name;\r\n        address contractAddress;\r\n        string uri;\r\n        uint id;\r\n        status dappStatus;\r\n        address representative;\r\n        uint upVotes;\r\n        uint downVotes;\r\n        bool isActive;\r\n        bool isLegit;\r\n        uint starTime;\r\n        string remarks;\r\n        address[] upvoters;\r\n        address[] downvoters;\r\n        mapping(address=>bool)hasVoted;\r\n    }\r\n\r\n    // Fees\r\n    uint listingFees;\r\n    uint votingFees;\r\n    uint defenderTostake;\r\n    uint exchangeRate;\r\n\r\n    //Eligibility and Constraints\r\n    uint listingEligibility;\r\n    uint votingEligibility;\r\n    uint curatorEligibility;\r\n    uint defenderEligibility;\r\n    uint sessionDuration;   // 2 hours converted into miliseconds\r\n    uint dailyCondtraint;\r\n\r\n    //--Data Structures------\r\n    mapping  (uint=>dapp) internal dappsById;\r\n    //mapping(address=>uint)public _ASTBalance;\r\n    mapping(address=>uint)public _STTstakeBalance;\r\n    mapping (address=>uint[])public JurorsList;\r\n    mapping (address=>uint[])public defenderList;\r\n    mapping (address=>uint)public spendingSTT;\r\n    mapping (address=>uint)public listingTime;\r\n    mapping (uint=>uint) public rewardPoolbyDappId;\r\n    address[] stakers;\r\n    address[] jurors;\r\n    address[]curators;\r\n    //dapp[] dapps;\r\n\r\n     /*\r\n     constructor to set basic parameters\r\n     */\r\n\r\n   constructor(address ast)public{\r\n       activeCurators[msg.sender]=true;\r\n       owner=msg.sender;\r\n       decimals= 18;\r\n\r\n       contractAST = IERC20(ast);// Get instance of the AST token contract\r\n        listingFees=40000000000000000000;  // 40 AST: Fee to list projects on the dapp\r\n        votingFees=30000000000000000000;  // 30 AST: Fee to vote on projects on the dapp\r\n        defenderTostake=100000000000000000000;  //\r\n        exchangeRate=5;  // 5%: Staking fee when staking/unstaking.\r\n\r\n        listingEligibility =1;  //UNUSED 1%: Minimum % of TotalSupply needed to list projects on the dapp\r\n        votingEligibility=1;  //UNUSED 1%: Minimum % of TotalSupply needed to vote on projects on the dapp\r\n        curatorEligibility=5; //UNUSED 5%: Minimum % of TotalSupply needed to be a curator on the dapp\r\n        sessionDuration= 7200000;// 2 hours converted into miliseconds\r\n        dailyCondtraint=24*60*60*1000;\r\n   }\r\n\r\n\r\n    // **************************** //\r\n    // *         Modifiers        * //\r\n    // **************************** //\r\n\r\n   modifier onlyOwner(address user){\r\n       require (user==owner,\"Only owner can access\");\r\n       _;\r\n   }\r\n\r\n    modifier onlyCurator(address user){\r\n       require(activeCurators[user],\"Only curator can access\");\r\n       _;\r\n   }\r\n\r\n   //UNUSED CURRENTLY\r\n    modifier onlyJuror(address juror) {\r\n        // bool result = false;\r\n        // for(uint i=0; i<jurors.length;i++){\r\n        //     if(jurors[i]==juror){\r\n        //         result=true;\r\n        //     }\r\n\r\n        // }\r\n        //  require(result,\"Not a Juror\");\r\n         _;\r\n    }\r\n\r\n    modifier votingeligibility(uint _id, address voter){\r\n        require(!dappsById[_id].hasVoted[voter],\"You have already voted on this token\");\r\n        require(netBalanceSTT(voter)>=votingFees);\r\n        uint time= now- dappsById[ _id].starTime;\r\n        require(time<sessionDuration,\"Voting session has ended\");\r\n        _;\r\n    }\r\n\r\n    //DEACTIVATED/UNUSED\r\n    modifier curatorEligiblity(address curator, uint tokens) {\r\n    //   uint tokenBalance = contractAST.balanceOf(curator);\r\n    //   uint tokenSupply = contractAST.totalSupply();\r\n    //   uint requiredTokens= (5 * tokenSupply)/100;\r\n    //      require(tokenBalance>=requiredTokens,\"donot have enough Tokens, please buy more tokens\");\r\n          _;\r\n    }\r\n\r\n    modifier listerEligiblity(address lister) {\r\n        uint time = now - listingTime[lister];\r\n        // require( time>dailyCondtraint,\"only one listing per day allopwed\");  //DEACTIVATED/UNUSED\r\n        uint balanceSTT=  netBalanceSTT(lister);\r\n        require(balanceSTT>=listingFees,\"Do not have enough STT, please swap and stake more\");\r\n         _;\r\n    }\r\n\r\n    modifier canVote(address user){\r\n        uint tokenBalance=netBalanceSTT(user);\r\n        require(tokenBalance>=votingFees);\r\n        _;\r\n    }\r\n\r\n    modifier eligibleToRevote(address defender, uint id) {\r\n        uint tokenBalance = netBalanceSTT(defender);\r\n        require(tokenBalance>=defenderEligibility, \"You dont have enough tokens (100STT) to be able to apply for a revote\");\r\n        uint tokenSupply = contractAST.totalSupply();\r\n         _;\r\n    }\r\n\r\n\r\n    // **************************** //\r\n    // *         Functions        * //\r\n    // **************************** //\r\n\r\n    function upvote(uint  _id)canVote(msg.sender)onlyJuror(msg.sender)votingeligibility(_id,msg.sender) public{\r\n        address _juror=msg.sender;\r\n        dappsById[_id].upVotes++;\r\n        dappsById[_id].upvoters.push(_juror);\r\n        spendingSTT[_juror]+= votingFees;\r\n        dappsById[_id].hasVoted[_juror]=true;\r\n    }\r\n\r\n    function downVote(uint  _id)canVote(msg.sender)onlyJuror(msg.sender)votingeligibility(_id,msg.sender) public{\r\n        address _juror=msg.sender;\r\n        dappsById[_id].downVotes++;\r\n        dappsById[_id].downvoters.push(_juror);\r\n        spendingSTT[_juror]+= votingFees;\r\n        dappsById[_id].hasVoted[_juror]=true;\r\n    }\r\n\r\n    function registerDapp(string memory _name,address _contractAddress,string memory _uri)listerEligiblity(msg.sender)public {\r\n        address lister= msg.sender;\r\n        dapp memory regDapp;\r\n        regDapp.name=_name;\r\n        regDapp.contractAddress=_contractAddress;\r\n        regDapp.uri=_uri;\r\n        regDapp.dappStatus=status.inconclusive;\r\n        regDapp.representative= lister;\r\n        regDapp.id= dappCounter;\r\n        regDapp.starTime=now; // added timestamp\r\n        dappsById[dappCounter]=regDapp;\r\n\r\n        _STTstakeBalance[lister]-= listingFees;// deduct fees from stake and credit to reward pool\r\n        rewardPoolbyDappId[dappCounter]+= listingFees;\r\n        dappCounter++;// increment the counter\r\n        listingTime[lister]= now;\r\n    }\r\n\r\n    /*\r\n    curator to approve Dapp for listing and assign jurors\r\n    */\r\n    function enlistForVoting(uint _id)onlyCurator(msg.sender) public{\r\n        dappsById[_id].isActive=true;\r\n    }\r\n\r\n     /*\r\n    curator to mark Dapp as scammed\r\n    */\r\n    function markScam(uint _id)onlyCurator(msg.sender)  public {\r\n        address curator=msg.sender;\r\n        require(dappsById[_id].dappStatus==status.inconclusive,\"You can only use MarkScam on an inconclusive project\");\r\n        dappsById[_id].dappStatus=status.scammed;\r\n        dappsById[_id].isActive=false;\r\n        dappsById[_id].remarks=\"Marked Scam by a Curator\";\r\n        rewardPoolbyDappId[_id]-=listingFees;\r\n        _STTstakeBalance[curator]+=listingFees;\r\n    }\r\n\r\n\r\n    function viewDAppById(uint _id) public view returns(uint id,string memory ,address ,string memory  uri,uint dappstatus,bool isActive, uint upVotes , uint downVotes,bool isLegit,string memory remarks, uint timestamp )  {\r\n        dapp memory getDapp= dappsById[_id];\r\n        return (getDapp.id,getDapp.name,getDapp.contractAddress,getDapp.uri,uint(getDapp.dappStatus),getDapp.isActive,getDapp.upVotes,getDapp.downVotes,getDapp.isLegit, getDapp.remarks, getDapp.starTime);\r\n    }\r\n\r\n    /*\r\n    Swap AST with STT and stake the same.\r\n    */\r\n    function  swapAndstakeSTT(uint tokens)public {\r\n        address staker =msg.sender;\r\n        contractAST.transferFrom(staker,address(this),tokens);\r\n        uint commission =(tokens*96/100*exchangeRate)/100;\r\n        uint sttToStake = (tokens*96/100-commission);\r\n        _STTstakeBalance[staker] +=(tokens*96/100-commission);\r\n        stakedSTT +=sttToStake;\r\n\r\n        if (isunique(staker)){\r\n        stakers.push(staker);}\r\n\r\n        stakersReward(staker,commission);\r\n    }\r\n\r\n    /*\r\n    Redeem the STT tokens for AST.\r\n    */\r\n     function  redeem(uint tokens)public {\r\n        address staker =msg.sender;\r\n        uint netBalance= netBalanceSTT(staker);\r\n        require(netBalance>=tokens, \"You dont have enough STT, try a lower amount.\");\r\n        uint commission =(tokens * exchangeRate)/100;\r\n        uint trasferableToken= (tokens-commission);\r\n\r\n        _STTstakeBalance[staker] -=tokens;\r\n        stakedSTT -=tokens;\r\n        contractAST.transfer(staker,trasferableToken);\r\n        stakersReward(staker,commission);\r\n    }\r\n\r\n    function stopVotingSession(uint  _id )onlyCurator(msg.sender) public{\r\n        bool isScam = (dappsById[_id].upVotes<dappsById[_id].downVotes)?true:false;\r\n\r\n        if(dappsById[_id].dappStatus==status.inRevote){\r\n        defendantSettlement(_id,isScam);\r\n        }\r\n\r\n        jurorSettlement(_id,isScam);\r\n        dappsById[_id].isActive =false;\r\n        dappsById[_id].dappStatus=isScam?status.scammed:status.Legit;\r\n    }\r\n\r\n    function  requestRevote(uint _id, string memory _remarks)public  eligibleToRevote(msg.sender,_id){\r\n        require(dappsById[_id].isActive==false, \"Cant revote while voting is still in progress\");\r\n        require(dappsById[_id].dappStatus==status.scammed,\"You can only request a revote on projects declared a scam\");\r\n        address defender= msg.sender;\r\n\taddress[] memory  blank;\r\n\r\n        dappsById[_id].isActive=true;\r\n        dappsById[_id].dappStatus=status.inRevote;\r\n        dappsById[_id].remarks=_remarks;\r\n        dappsById[_id].representative= defender;\r\n        dappsById[_id].starTime= now;\r\n        dappsById[_id].upvoters=blank;\r\n        dappsById[_id].downvoters=blank;\r\n        dappsById[_id].upVotes=0;\r\n        dappsById[_id].downVotes=0;\r\n\r\n\r\n        spendingSTT[defender]+=defenderTostake;\r\n        rewardPoolbyDappId[_id]=0;\r\n    }\r\n\r\n    function stakersReward(address staker, uint commission) internal{\r\n        for(uint i=0;i<stakers.length;i++){\r\n        uint reward= commission *netBalanceSTT(stakers[i])/stakedSTT;\r\n        _STTstakeBalance[stakers[i]]+=reward;\r\n        }\r\n        stakedSTT+=commission;\r\n    }\r\n\r\n    function defendantSettlement(uint _id, bool isScam)internal {\r\n        address defender =dappsById[_id].representative;\r\n        if(isScam){\r\n            spendingSTT[defender]-=defenderTostake;   // If the Defender loses appeal, they lose their Defending Fee.\r\n            _STTstakeBalance[defender]-=defenderTostake;  // The Defenders lost appeal fees are taken from their staked STT.\r\n            rewardPoolbyDappId[_id]+=defenderTostake;   // The Defending Fee is transferred to the reward pool.\r\n        }else{\r\n            spendingSTT[defender]-=defenderTostake;   // If the Defender wins the appeal, the Defending Fee is returned.\r\n            }\r\n    }\r\n\r\n   function addCurator(address curator) onlyOwner(msg.sender)public{\r\n        activeCurators[curator]= true;\r\n    }\r\n\r\n    function removeCurator(address curator) onlyOwner(msg.sender)public{\r\n        activeCurators[curator]= false;\r\n    }\r\n\r\n    function jurorSettlement(uint _id, bool isScam)internal{\r\n        // If project is a scam then winner is downvoters and losers are upvoters\r\n        address[] memory winners= isScam?dappsById[_id].downvoters:dappsById[_id].upvoters ;\r\n        address[] memory losers= isScam?dappsById[_id].upvoters:dappsById[_id].downvoters ;\r\n\r\n        //-- settlement of loosing side(half voting is refunded half is penalized)\r\n        uint returnedvoting =votingFees/2;\r\n\r\n        for(uint i=0;i<losers.length;i++){\r\n          spendingSTT[losers[i]] -=returnedvoting;\r\n          _STTstakeBalance[losers[i]]-= (votingFees-returnedvoting);\r\n          _STTstakeBalance[losers[i]]+= returnedvoting;\r\n          rewardPoolbyDappId[_id]+= (votingFees-returnedvoting);\r\n        }\r\n\r\n        //-- settlement of winning side(if won, no voting fees charged)\r\n        uint rewardperJuror= rewardPoolbyDappId[_id]/winners.length;\r\n        returnedvoting =votingFees;\r\n\r\n        for(uint i=0;i<winners.length;i++){\r\n          spendingSTT[winners[i]] -=returnedvoting;\r\n          _STTstakeBalance[winners[i]]-= (votingFees-returnedvoting);// no net fees is being charged from the staked STT\r\n          _STTstakeBalance[winners[i]]+= rewardperJuror;// rewarding the winning jurors, by distributing STT to jurors who voted correctly\r\n        }\r\n    }\r\n\r\n    function netBalanceSTT(address user)public view returns(uint){\r\n        uint balance =_STTstakeBalance[user] - spendingSTT[user];\r\n        return balance;\r\n    }\r\n\r\n    function isunique(address staker)view internal returns(bool){\r\n        bool result=true;\r\n        for(uint i=0; i<stakers.length;i++){\r\n            if (stakers[i]==staker){\r\n                result=false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ast\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"JurorsList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_STTstakeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"addCurator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dappCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"defenderList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"downVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"enlistForVoting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"listingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"markScam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"netBalanceSTT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"registerDapp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"removeCurator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_remarks\",\"type\":\"string\"}],\"name\":\"requestRevote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardPoolbyDappId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"spendingSTT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"stopVotingSession\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"swapAndstakeSTT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"upvote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"viewDAppById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"dappstatus\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"upVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"downVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLegit\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"remarks\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AntiScamCourtDapp","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a872e0a44bbd66c1486a756cb5bd3f0beec4e32e","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://840d11794fde032efbb3e1d62305bea70548a8e376adc82b8e03de09515f0ca3"}]}