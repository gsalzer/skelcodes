{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.0;\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\n//======================================================================\r\n\r\n//  ######  ######  ######  ########\r\n//  ##      ##  ##  ##         ##\r\n//  #####   ##  ##  ##         ##\r\n//  ##      ##  ##  ##  ##     ##\r\n//  ######  ######  ######     ##\r\n//              ##\r\n\r\n\r\n//      The EQUUSMiningToken (EQMT) is a ERC20, this token has 100000000**18 as the total supply its use is key towards\r\n//  staking as the staking is done by pooling ETH / EQMT on UniswapV2 giving the process a proof-of-stake, the token has no\r\n//  burning (deflamatory) capabilities to maximize the pooling and staking on the token.\r\n\r\n//      The EQUUSGovernanceToken is a ERC777 and ERC20 with staking capabilities and implementation of ERC1820Registry, \r\n//  this token has 0 as the total supply as it's gonna be mined by staking, the staking is done by staking the UniswapV2 \r\n//  tokens from the pool shares of the pair ETH / EQMT, these UniswapV2 tokens are sent to EQUUSGovernanceToken's address, \r\n//  then an authorized Operator set by the owner address can verify the transaction externally to then allowing the holders \r\n//  stake their UniswapV2 coins on the EQUUSGovernanceToken network, depending on the time of staking and the amount staked \r\n//  the following operations are run to mint EQUUSGovernanceToken, the EQUUSGovernanceToken has a deflamatory burning \r\n//  process as a mining multiplier, the total supply will depend on the holders staking and mining functions.\r\n\r\n//  FORMULA to mint\r\n//  ((( totalStaked * hoursStaked) * ( 7.13 / 744 )) * rankMultiplier) * BurnBonusMultiplier\r\n\r\n\r\n//  BurnBonusMultiplier\r\n//  5   *   (burnAmount / (((( totalStaked * 744 ) * ( 7.13 / 744 )) / 1000) * 5000))\r\n\r\n\r\n//  BurnBonusMultiplier Max Amount to Burn\r\n//  (((( totalStaked * 744 ) * ( 7.13 / 744 )) / 1000) * 5000)\r\n\r\n//  This process only burns the above max to give a x1, there is a max to do it till x5\r\n\r\n\r\n//  RankMultiplier\r\n//  Multiplier (x2) given after 744 hours (31 days) staked\r\n\r\n//  The burnAmount is the amount of EQUUSGovernanceToken tokens that they for want to burn.\r\n\r\n// To simulate this token on a testnet deploy ERC1820Registry, and a TEST UniswapV2 Token to set the constructor to recognise and interact the token in the code\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/* IERC20 Standards followed by OpenZeppelin Group libraries on Github */\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    \r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* ERC777 Standards followed by OpenZeppelin Group libraries on Github */\r\n\r\n/**\r\n * @dev Interface of the ERC777Token standard as defined in the EIP.\r\n *\r\n * This contract uses the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\r\n * token holders and recipients react to token movements by using setting implementers\r\n * for the associated interfaces in said registry. See {IERC1820Registry} and\r\n * {ERC1820Implementer}.\r\n */\r\ninterface IERC777 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the smallest part of the token that is not divisible. This\r\n     * means all token operations (creation, movement and destruction) must have\r\n     * amounts that are a multiple of this number.\r\n     *\r\n     * For most token contracts, this value will equal 1.\r\n     */\r\n    function granularity() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (`owner`).\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * If send or receive hooks are registered for the caller and `recipient`,\r\n     * the corresponding functions will be called with `data` and empty\r\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits a {Sent} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function send(address recipient, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Returns true if an account is an operator of `tokenHolder`.\r\n     * Operators can send and burn tokens on behalf of their owners. All\r\n     * accounts are their own operator.\r\n     *\r\n     * See {operatorSend} and {operatorBurn}.\r\n     */\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See {isOperatorFor}.\r\n     *\r\n     * Emits an {AuthorizedOperator} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function authorizeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Revoke an account's operator status for the caller.\r\n     *\r\n     * See {isOperatorFor} and {defaultOperators}.\r\n     *\r\n     * Emits a {RevokedOperator} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function revokeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Returns the list of default operators. These accounts are operators\r\n     * for all token holders, even if {authorizeOperator} was never called on\r\n     * them.\r\n     *\r\n     * This list is immutable, but individual holders may revoke these via\r\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\r\n     */\r\n    //function defaultOperators() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\r\n     * be an operator of `sender`.\r\n     *\r\n     * If send or receive hooks are registered for `sender` and `recipient`,\r\n     * the corresponding functions will be called with `data` and\r\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits a {Sent} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `sender` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `sender`.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\r\n     * The caller must be an operator of `account`.\r\n     *\r\n     * If a send hook is registered for `account`, the corresponding function\r\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `account`.\r\n     */\r\n    function operatorBurn(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\n\r\n\r\n\r\n//ERC1820Registry And Client to interact with registry\r\n\r\ninterface ERC1820Registry {\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\r\n    function setManager(address _addr, address _newManager) external;\r\n    function getManager(address _addr) external view returns (address);\r\n}\r\n\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC1820Client {\r\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n    \r\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC1820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\n//ERC777TokensSender - https://eips.ethereum.org/EIPS/eip-777\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\r\n *\r\n * {IERC777} Token holders can be notified of operations performed on their\r\n * tokens by having a contract implement this interface (contract holders can be\r\n *  their own implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n */\r\ninterface IERC777Sender {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\r\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\r\n     * is conveyed by `to` being the zero address or not.\r\n     *\r\n     * This call occurs _before_ the token contract's state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n//IERC777Recipient - https://eips.ethereum.org/EIPS/eip-777\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\r\n *\r\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\r\n * contract implement this interface (contract holders can be their own\r\n * implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n */\r\ninterface IERC777Recipient {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever tokens are being\r\n     * moved or created into a registered account (`to`). The type of operation\r\n     * is conveyed by `from` being the zero address or not.\r\n     *\r\n     * This call occurs _after_ the token contract's state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n/* Staking process is followed according to the ERC900: Simple Staking Interface #900 issue on Github */\r\n\r\ninterface Staking {\r\n    \r\n    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    \r\n    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n\r\n    function stake(uint256 amount, bytes calldata data) external returns (bool);\r\n    \r\n    function unstake(uint256 amount, bytes calldata data) external returns (bool);\r\n    \r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n    \r\n    function totalStaked() external view returns (uint256);\r\n    \r\n    function supportsHistory() external pure returns (bool);\r\n\r\n}\r\n\r\n/*EQUUS Protocol being created with the help of the above interfaces for compatibility*/\r\n\r\ncontract EQUUSGovernanceToken is IERC20, Staking, IERC777, ERC1820Client {\r\n    \r\n    /* Constant variables created for the ERC20 requirements*/\r\n    \r\n    string public override constant name = \"EQUUSGovernanceToken\";\r\n    string public override constant symbol = \"EQGT\";\r\n    uint8 public constant decimals = 18;\r\n    \r\n    //Burn address saved as constant for future burning processes\r\n    address public constant burnaddress = 0x0000000000000000000000000000000000000000;\r\n    IERC20 public uniaddress;\r\n\r\n    mapping(address => uint256) balances; //EQUUS balance for all network participants\r\n    \r\n    mapping(address => uint256) public stakedbalances; //EQUUS stake balance to lock stakes\r\n    \r\n    mapping(address => uint256) public stakeMultipliers; //EQUUS stake multiplier per user staking\r\n    \r\n    mapping(address => uint256) public stakeMultipliersMax; //EQUUS stake multiplier per user staking\r\n    \r\n    mapping(address => uint) public staketimestamps; //EQUUS stake timestamp to record updates on staking for multipliers, this involves the idea that multipliers will reset upon staking\r\n\r\n    mapping(address => mapping (address => uint256)) allowed; //Approval array to record delegation of thrid-party accounts to handle transaction per allowance\r\n    \r\n    \r\n    /* Total variables created to record information */\r\n    uint256 totalSupply_ = 0;\r\n    uint256 totalstaked = 0;\r\n    uint256 granularity_ = 1;\r\n    \r\n    // Set of arrays to hold operator authorization\r\n    //address[] internal defaultOperators_;\r\n    mapping(address => bool) internal isDefaultOperator_;\r\n    mapping(address => mapping(address => bool)) internal revokedDefaultOperator_;\r\n    mapping(address => mapping(address => bool)) authorizedOperator_;\r\n    \r\n\r\n    address theowner; //Owner address saved to recognise on future processes\r\n    \r\n    using SafeMath for uint256; //Important*** as this library provides security to handle maths without overflow attacks\r\n    \r\n    constructor(IERC20 tokenaddress) public {\r\n        uniaddress = tokenaddress;\r\n        theowner = msg.sender;\r\n        setInterfaceImplementation(\"ERC777Token\", address(this));\r\n   } //Constructor stating the total supply as well as saving owner address\r\n   \r\n   \r\n   \r\n   //ERC777 functions ========================\r\n   \r\n   function granularity() public override view returns (uint256) {\r\n       return granularity_;\r\n   }\r\n   \r\n   //function defaultOperators() public override view returns (address[] memory) {\r\n   //    return defaultOperators_;\r\n   //}\r\n   \r\n   function setDefaultOperators(address addr) public returns (bool) {\r\n       require(theowner != addr, \"Owner address cannot be handled\");\r\n       require(theowner == msg.sender, \"Only theowner can set default operators\");\r\n       \r\n        isDefaultOperator_[addr] = true;\r\n        emit AuthorizedOperator(addr, msg.sender);\r\n   }\r\n   \r\n   function revokeDefaultOperators(address addr) public returns (bool) {\r\n        require(theowner != addr, \"Owner address cannot be revoked\");\r\n        \r\n        isDefaultOperator_[addr] = false;\r\n        emit RevokedOperator(addr, msg.sender);\r\n   }\r\n   \r\n   function isOperatorFor( address operator_, address holder_) public override view returns (bool) {\r\n        return (operator_ == holder_ || \r\n        authorizedOperator_[operator_][holder_] ||\r\n        (isDefaultOperator_[operator_] &&\r\n        !revokedDefaultOperator_[operator_][holder_]));\r\n    }\r\n    \r\n    function authorizeOperator(address operator) public override {\r\n        require(operator != msg.sender, \"You can't authorize yourself\");\r\n        if (isDefaultOperator_[operator]) {\r\n            revokedDefaultOperator_[operator][msg.sender] = false;\r\n        } else {\r\n            authorizedOperator_[operator][msg.sender] = true;\r\n        }\r\n        emit AuthorizedOperator(operator, msg.sender);\r\n    }\r\n    \r\n    function revokeOperator(address operator) public override {\r\n        require(operator != msg.sender, \"You can't revoke yourself\");\r\n        if (isDefaultOperator_[operator]) {\r\n            revokedDefaultOperator_[operator][msg.sender] = true;\r\n        } else {\r\n            authorizedOperator_[operator][msg.sender] = false;\r\n        }\r\n        emit RevokedOperator(operator, msg.sender);\r\n    }\r\n    \r\n    function burn(uint256 amount, bytes memory data) public override {\r\n        burning(msg.sender, msg.sender, amount, data, \"\");\r\n    }\r\n    \r\n    function operatorBurn(\r\n        address from,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    ) public override {\r\n        require(isOperatorFor(msg.sender, from), \"Not an Operator\");\r\n        burning(msg.sender, from, amount, data, operatorData);\r\n    }\r\n    \r\n    function burning(address operator, address from, uint256 amount, bytes memory data, bytes memory operatorData) internal {\r\n        require(balances[from] >= amount, \"Not enought funds\");\r\n        require(stakedbalances[from] != 0, \"Nothing staked to mine for\");\r\n        require(stakeMultipliers[from] <= 500, \"Max burn multiplier reached\");\r\n        require( getPercentageWithFive( stakeMultipliers[from] ) .add( getPercentageFromMax( amount, stakeMultipliersMax[from] ) ) <= 100 , \"Too much to burn\");\r\n        \r\n        balances[from] = balances[from].sub(amount);\r\n        \r\n        totalSupply_ = totalSupply_.sub(amount);\r\n        \r\n        \r\n        uint256 multiplier = getPercentageFromMax(amount, stakeMultipliersMax[from]).mul(5);\r\n        \r\n        stakeMultipliers[from] = stakeMultipliers[from].add(multiplier);\r\n        \r\n        emit Burned(operator, from, amount, data, operatorData);\r\n        emit Sent(operator, from, burnaddress, amount, data, operatorData);\r\n    }\r\n    \r\n    \r\n    \r\n    function getPercentageFromMax(uint256 amount, uint256 maxForFuntion) public pure returns (uint256) {\r\n        uint256 onePercent = maxForFuntion.div(100);\r\n        return amount.div(onePercent);\r\n    }\r\n    \r\n    function getPercentageWithFive(uint256 amount) public pure returns (uint256) {\r\n        return amount.div(5);\r\n    }\r\n    \r\n    \r\n    function send(address to, uint256 amount, bytes memory data) public override {\r\n        sending(msg.sender, msg.sender, to, amount, data, \"\", true);\r\n    }\r\n    \r\n    function operatorSend(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    ) public override {\r\n        require(isOperatorFor(msg.sender, from), \"Not an operator.\");\r\n        sending(msg.sender, from, to, amount, data, operatorData, true);\r\n    }\r\n    \r\n    // ERC1820 implementer and send function ========================\r\n    \r\n    function sending(address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData,\r\n        bool preventLocking) internal {\r\n        \r\n        \r\n        checkSender(operator, from, to, amount, data, operatorData);\r\n        \r\n        require(to != burnaddress, \"Can't send to 0x0\");\r\n        require(balances[from] >= amount, \"Insufficient funds\");\r\n        \r\n        balances[from] = balances[from].sub(amount);\r\n        balances[to] = balances[to].add(amount);\r\n        \r\n        checkReceiver(operator, from, to, amount, data, operatorData, preventLocking);\r\n        \r\n        emit Sent(operator, from, to, amount, data, operatorData);\r\n        \r\n    }\r\n    \r\n    function checkSender(address operator, address from, address to, uint256 amount, bytes memory data, bytes memory operatorData) internal {\r\n        address sender = interfaceAddr(from, \"ERC777TokensSender\");\r\n        require(sender != burnaddress);\r\n        IERC777Sender(sender).tokensToSend(\r\n            operator, from, to, amount, data, operatorData);\r\n    }\r\n    \r\n    function checkReceiver(address operator, address from, address to, uint256 amount, bytes memory data, bytes memory operatorData, bool preventLocking) internal {\r\n        address recipient = interfaceAddr(to, \"ERC777TokensRecipient\");\r\n        if (recipient != burnaddress) {\r\n            IERC777Recipient(recipient).tokensReceived(\r\n                operator, from, to, amount, data, operatorData);\r\n        } else if (preventLocking) {\r\n            require(isNormalAddress(to), \"Cannot send to contract without ERC777TokensRecipient\");\r\n        }\r\n    }\r\n    \r\n    function isNormalAddress(address addr) internal view returns(bool) {\r\n        if (addr == burnaddress) { return false; }\r\n        uint size;\r\n        assembly { size := extcodesize(addr) } // solium-disable-line security/no-inline-assembly\r\n        return size == 0;\r\n    }\r\n    \r\n    //ERC20 implementation ========================\r\n   \r\n   //Function to report on totalsupply following ERC20 Standard\r\n   function totalSupply() public override(IERC20, IERC777) view returns (uint256) {\r\n       return totalSupply_;\r\n   }\r\n   \r\n   //Function to report on account balance following ERC20 Standard\r\n   function balanceOf(address tokenOwner) public override(IERC20, IERC777) view returns (uint) {\r\n       return balances[tokenOwner];\r\n   }\r\n   \r\n   //Function to report on account balance following ERC20 Standard\r\n   function uniBalance(address tokenOwner) public view returns (uint) {\r\n       return uniaddress.balanceOf(tokenOwner);\r\n   }\r\n   \r\n   //Straight forward transfer following ERC20 Standard\r\n   function transfer(address receiver, uint256 numTokens) public override returns (bool) {\r\n       require(numTokens <= balances[msg.sender], 'Amount exceeds balance.');\r\n       balances[msg.sender] = balances[msg.sender].sub(numTokens);\r\n       \r\n       balances[receiver] = balances[receiver].add(numTokens);\r\n       emit Transfer(msg.sender, receiver, numTokens);\r\n       return true;\r\n   }\r\n   \r\n   //Approve function following ERC20 Standard\r\n   function approve(address delegate, uint256 numTokens) public override returns (bool) {\r\n       require(numTokens <= balances[msg.sender], 'Amount exceeds balance.');\r\n       allowed[msg.sender][delegate] = numTokens;\r\n       emit Approval(msg.sender, delegate, numTokens);\r\n       return true;\r\n   }\r\n   \r\n   //Allowance function to verify allowance allowed on delegate address following ERC20 Standard\r\n   function allowance(address owner, address delegate) public override view returns (uint) {\r\n       return allowed[owner][delegate];\r\n   }\r\n   \r\n   //The following function is added to mitigate ERC20 API: An Attack Vector on Approve/TransferFrom Methods\r\n   function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n       require(addedValue <= balances[msg.sender].sub(allowed[msg.sender][spender]), 'Amount exceeds balance.');\r\n       \r\n       allowed[msg.sender][spender] = allowed[msg.sender][spender].add(addedValue);\r\n       \r\n       emit Approval(msg.sender, spender, allowed[msg.sender][spender].add(addedValue));\r\n       return true;\r\n   }\r\n   \r\n   //The following function is added to mitigate ERC20 API: An Attack Vector on Approve/TransferFrom Methods\r\n   function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n       require(subtractedValue <= allowed[msg.sender][spender], 'Amount exceeds balance.');\r\n       \r\n       allowed[msg.sender][spender] = allowed[msg.sender][spender].sub(subtractedValue);\r\n       \r\n       emit Approval(msg.sender, spender, allowed[msg.sender][spender].sub(subtractedValue));\r\n       return true;\r\n   }\r\n   \r\n   //Transfer For function for allowed accounts to allow tranfers\r\n   function transferFrom(address owner, address buyer, uint numTokens) public override returns (bool) {\r\n       require(numTokens <= balances[owner], 'Amount exceeds balance.');\r\n       require(numTokens <= allowed[owner][msg.sender], 'Amount exceeds allowance.');\r\n       \r\n       balances[owner] = balances[owner].sub(numTokens);\r\n       allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\r\n       balances[buyer] = balances[buyer].add(numTokens);\r\n       emit Transfer(msg.sender, buyer, numTokens);\r\n       return true;\r\n   }\r\n   \r\n   //Staking processes ========================\r\n   \r\n   \r\n   \r\n   //Stake process created updating balances, stakebalances and also recording time on process run,\r\n   function stake(uint256 amount, bytes memory data) public override returns (bool) {\r\n       require(amount >= 105000);\r\n       require(amount <= uniBalance(msg.sender));\r\n       require(amount <= uniaddress.allowance(msg.sender, address(this)));\r\n       \r\n       //So add the user stake process into the data base\r\n       \r\n       uniaddress.transferFrom(msg.sender, address(this), amount);\r\n       \r\n       stakedbalances[msg.sender] = stakedbalances[msg.sender].add(amount);\r\n       totalstaked = totalstaked.add(amount);\r\n       staketimestamps[msg.sender] = block.timestamp;\r\n       stakeMultipliers[msg.sender] = 100;\r\n       \r\n       //operation = = = ((((staked*744)*(7.13/744))/1000)*5000)\r\n       uint256 max = amount;\r\n       max = max.mul(744);\r\n       max = max.mul(9583).div(1000000);\r\n       \r\n       max = max.div(1000);\r\n       max = max.mul(5000);\r\n       \r\n       stakeMultipliersMax[msg.sender] = max; //Max amount of tokens to calculate the multiplier from\r\n       \r\n       uint256 total = stakedbalances[msg.sender];\r\n       \r\n       emit Staked(msg.sender, amount, total, data);\r\n       return true;\r\n   }\r\n   \r\n   //This function unstakes locked in amount, this also updates amounts on total supply\r\n   function unstake(uint256 amount, bytes memory data) public override returns (bool) {\r\n       require(amount <= stakedbalances[msg.sender]);\r\n       require(amount <= totalstaked);\r\n       \r\n       stakedbalances[msg.sender] = stakedbalances[msg.sender].sub(amount);\r\n       totalstaked = totalstaked.sub(amount);\r\n       staketimestamps[msg.sender] = block.timestamp;\r\n       stakeMultipliers[msg.sender] = 100;\r\n       stakeMultipliersMax[msg.sender] = 0;\r\n       \r\n       uniaddress.transfer(msg.sender, amount);// Send tokens back to the holder\r\n       \r\n       emit Unstaked(msg.sender, amount, stakedbalances[msg.sender], data);\r\n       return true;\r\n   }\r\n    \r\n    \r\n    // Minting operation\r\n    \r\n    //(((staked*hoursStaked)*(7.13/744))*rankMultiplier)*BBM =================\r\n    \r\n    \r\n    function _mint(bytes memory data) public {\r\n        require(stakedbalances[msg.sender] != 0, \"Nothing staked to mine for\");\r\n        \r\n        \r\n        uint256 amount = operate(stakedbalances[msg.sender]);\r\n        \r\n        stakeMultipliers[msg.sender] = 100;\r\n        staketimestamps[msg.sender] = block.timestamp;\r\n        balances[msg.sender] = balances[msg.sender].add(amount);\r\n        totalSupply_ = totalSupply_.add(amount);\r\n        \r\n        emit Minted(burnaddress, msg.sender, amount, data, data);\r\n        emit Sent(burnaddress, burnaddress, msg.sender, amount, data, data);\r\n        \r\n    }\r\n    \r\n    function operate(uint256 number) public view returns (uint256) {\r\n        uint256 amount = number;\r\n        \r\n        amount = amount.mul((stakeTimeFor(msg.sender).div(60)).div(60));\r\n        \r\n        require(amount > 104400, \"Not enough time to mine tokens\");\r\n        \r\n        //Sets a minimun to mine after the next operation to 1000 tokens\r\n        \r\n        amount = amount.mul(9583).div(1000000);\r\n        \r\n        if ((stakeTimeFor(msg.sender).div(60)).div(60) > 744) {\r\n            amount = amount.mul(2);\r\n        }\r\n        uint256 multiplier = stakeMultipliers[msg.sender];\r\n        amount = (amount.mul(multiplier)).div(100);\r\n        return amount;\r\n    }\r\n   \r\n   //Function to return multipliers\r\n   function stakeMultiplierFor(address addr) public view returns (uint256) {\r\n       return stakeMultipliers[addr];\r\n   }\r\n   \r\n   //Function to return total staked on a single address\r\n   function totalStakedFor(address addr) public override view returns (uint256) {\r\n       return stakedbalances[addr];\r\n   }\r\n   \r\n   //Function to shows timestamp on stake processes\r\n   function stakeTimestampFor(address addr) public view returns (uint256) {\r\n       return staketimestamps[addr];\r\n   }\r\n   \r\n   //Function to find out time passed since last timestamp on address\r\n   function stakeTimeFor(address addr) public view returns (uint256) {\r\n       return block.timestamp.sub(staketimestamps[addr]);\r\n   }\r\n   \r\n   //Total staked on all addresses\r\n   function totalStaked() public override view returns (uint256) {\r\n       return totalstaked;\r\n   }\r\n   \r\n   //Support History variable to show support on optional stake details\r\n   function supportsHistory() public override pure returns (bool) {\r\n       return false;\r\n   }\r\n   \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenaddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"_mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxForFuntion\",\"type\":\"uint256\"}],\"name\":\"getPercentageFromMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPercentageWithFive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holder_\",\"type\":\"address\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"operate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"revokeDefaultOperators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setDefaultOperators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"stakeMultiplierFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeMultipliers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeMultipliersMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"stakeTimeFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"stakeTimestampFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedbalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staketimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportsHistory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"totalStakedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"uniBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniaddress\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EQUUSGovernanceToken","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000022fc445fd3ec66cc48e0975265ec825245cd7a9","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://79082e142d80fd3c3647501ba2873a9854e4f161b705eb2a8f869c514df18da5"}]}