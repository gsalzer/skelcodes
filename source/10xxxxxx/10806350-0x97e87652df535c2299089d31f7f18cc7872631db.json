{"status":"1","message":"OK","result":[{"SourceCode":"// File: @daostack/upgrades/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.6.0;\r\n// : MIT\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\r\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\r\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\r\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\r\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\r\n */\r\ncontract OpenZeppelinUpgradesOwnable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/registry/Package.sol\r\n\r\npragma solidity ^0.6.10;\r\n// : GPL-3.0\r\n\r\n\r\n\r\n/**\r\n * @title Package\r\n * @dev A package is composed by a set of versions, identified via semantic versioning,\r\n * where each version has a contract address that refers to a reusable implementation,\r\n * plus an optional content URI with metadata. Note that the semver identifier is restricted\r\n * to major, minor, and patch, as prerelease tags are not supported.\r\n */\r\ncontract Package is OpenZeppelinUpgradesOwnable {\r\n  /**\r\n   * @dev Emitted when a version is added to the package.\r\n   * @param semanticVersion Name of the added version.\r\n   * @param contractAddress Contract associated with the version.\r\n   * @param contentURI Optional content URI with metadata of the version.\r\n   */\r\n    event VersionAdded(uint64[3] semanticVersion, address contractAddress, bytes contentURI);\r\n\r\n    struct Version {\r\n        uint64[3] semanticVersion;\r\n        address contractAddress;\r\n        bytes contentURI;\r\n    }\r\n\r\n    mapping (bytes32 => Version) internal versions;\r\n    mapping (uint64 => bytes32) internal majorToLatestVersion;\r\n    uint64 internal latestMajor;\r\n\r\n  /**\r\n   * @dev Adds a new version to the package. Only the Owner can add new versions.\r\n   * Reverts if the specified semver identifier already exists.\r\n   * Emits a `VersionAdded` event if successful.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @param contractAddress Contract address for the version, must be non-zero.\r\n   * @param contentURI Optional content URI for the version.\r\n   */\r\n    function addVersion(uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI)\r\n    public\r\n    onlyOwner {\r\n        require(contractAddress != address(0), \"Contract address is required\");\r\n        require(!hasVersion(semanticVersion), \"Given version is already registered in package\");\r\n        require(!semanticVersionIsZero(semanticVersion), \"Version must be non zero\");\r\n\r\n        // Register version\r\n        bytes32 versionId = semanticVersionHash(semanticVersion);\r\n        versions[versionId] = Version(semanticVersion, contractAddress, contentURI);\r\n\r\n        // Update latest major\r\n        uint64 major = semanticVersion[0];\r\n        if (major > latestMajor) {\r\n            latestMajor = semanticVersion[0];\r\n        }\r\n\r\n        // Update latest version for this major\r\n        uint64 minor = semanticVersion[1];\r\n        uint64 patch = semanticVersion[2];\r\n        uint64[3] storage latestVersionForMajor = versions[majorToLatestVersion[major]].semanticVersion;\r\n        if (semanticVersionIsZero(latestVersionForMajor) // No latest was set for this major\r\n            || (minor > latestVersionForMajor[1]) // Or current minor is greater\r\n            || (minor == latestVersionForMajor[1] && patch > latestVersionForMajor[2]) // Or current patch is greater\r\n        ) {\r\n            majorToLatestVersion[major] = versionId;\r\n        }\r\n\r\n        emit VersionAdded(semanticVersion, contractAddress, contentURI);\r\n    }\r\n\r\n  /**\r\n   * @dev Checks whether a version is present in the package.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @return true if the version is registered in this package, false otherwise.\r\n   */\r\n    function hasVersion(uint64[3] memory semanticVersion) public view returns (bool) {\r\n        Version storage version = versions[semanticVersionHash(semanticVersion)];\r\n        return address(version.contractAddress) != address(0);\r\n    }\r\n\r\n  /**\r\n   * @dev Returns the version with the highest semver identifier registered in the package.\r\n   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will always return `2.0.0`, regardless\r\n   * of the order in which they were registered. Returns zero if no versions are registered.\r\n   * @return semanticVersion Semver identifier, contract address,\r\n   * and content URI for the version, or zero if not exists.\r\n   */\r\n    function getLatest()\r\n    public\r\n    view\r\n    returns (uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) {\r\n        return getLatestByMajor(latestMajor);\r\n    }\r\n\r\n  /**\r\n   * @dev Returns the version with the highest semver identifier for the given major.\r\n   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will return `1.3.0` for major `1`,\r\n   * regardless of the order in which they were registered. Returns zero if no versions are registered\r\n   * for the specified major.\r\n   * @param major Major identifier to query\r\n   * @return semanticVersion Semver identifier, contract address,\r\n   * and content URI for the version, or zero if not exists.\r\n   */\r\n    function getLatestByMajor(uint64 major)\r\n    public\r\n    view\r\n    returns (uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) {\r\n        Version storage version = versions[majorToLatestVersion[major]];\r\n        return (version.semanticVersion, version.contractAddress, version.contentURI);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a version given its semver identifier.\r\n     * @param semanticVersion Semver identifier of the version.\r\n     * @return contractAddress Contract address and content URI for the version,\r\n     * or zero if not exists.\r\n     */\r\n    function getVersion(uint64[3] memory semanticVersion)\r\n    public\r\n    view\r\n    returns (address contractAddress, bytes memory contentURI) {\r\n        Version storage version = versions[semanticVersionHash(semanticVersion)];\r\n        return (version.contractAddress, version.contentURI);\r\n    }\r\n\r\n  /**\r\n   * @dev Returns a contract for a version given its semver identifier.\r\n   * This method is equivalent to `getVersion`, but returns only the contract address.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @return contractAddress address for the version, or zero if not exists.\r\n   */\r\n    function getContract(uint64[3] memory semanticVersion) public view returns (address contractAddress) {\r\n        Version storage version = versions[semanticVersionHash(semanticVersion)];\r\n        return version.contractAddress;\r\n    }\r\n\r\n    function semanticVersionHash(uint64[3] memory version) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(version[0], version[1], version[2]));\r\n    }\r\n\r\n    function semanticVersionIsZero(uint64[3] memory version) internal pure returns (bool) {\r\n        return version[0] == 0 && version[1] == 0 && version[2] == 0;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64[3]\",\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"contentURI\",\"type\":\"bytes\"}],\"name\":\"VersionAdded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64[3]\",\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"contentURI\",\"type\":\"bytes\"}],\"name\":\"addVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[3]\",\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"}],\"name\":\"getContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatest\",\"outputs\":[{\"internalType\":\"uint64[3]\",\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"contentURI\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"major\",\"type\":\"uint64\"}],\"name\":\"getLatestByMajor\",\"outputs\":[{\"internalType\":\"uint64[3]\",\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"contentURI\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[3]\",\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"}],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"contentURI\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[3]\",\"name\":\"semanticVersion\",\"type\":\"uint64[3]\"}],\"name\":\"hasVersion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Package","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b5a20edf92c48a3a8fb2af9b6a08e21b92c5ffd2c270494b6e8b1502075e9c33"}]}