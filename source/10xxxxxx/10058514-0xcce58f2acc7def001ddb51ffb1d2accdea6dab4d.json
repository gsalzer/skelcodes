{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >= 0.5.12;\r\n\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >0.4.13;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract TokenLike {\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n}\r\n\r\ncontract VatLike {\r\n    function gem(bytes32 ilk, address owner) public view returns (uint gem_);\r\n    function dai(address owner) public view returns (uint dai_);\r\n    function urns(bytes32 ilk, address owner) public view returns (uint ink, uint art);\r\n    function ilks(bytes32 ilk) public view returns (uint Art, uint rate, uint spot, uint line, uint dust);\r\n    function hope(address usr) public;\r\n    function frob(bytes32 i, address u, address v, address w, int dink, int dart) public;\r\n    function live() public view returns (uint live_);\r\n}\r\n\r\ncontract GemJoinLike {\r\n    function join(address urn, uint wad) public;\r\n    function exit(address guy, uint wad) public;\r\n}\r\n\r\ncontract SpotLike {\r\n    function ilks(bytes32 ilk) public view returns (address pip, uint mat);\r\n}\r\n\r\ncontract JugLike {\r\n    function ilks(bytes32 ilk) public view returns (uint duty, uint rho);\r\n    function base() public view returns (uint base_);\r\n    function drip(bytes32) public returns (uint);\r\n}\r\n\r\ncontract EndLike {\r\n    function free(bytes32 ilk) public;\r\n}\r\n\r\ncontract CatLike {\r\n    function ilks(bytes32 ilk) public view returns (address flip, uint chop, uint lump);\r\n}\r\n\r\ncontract OtcLike {\r\n    function buyAllAmount(address buyGem, uint buyAmt, address sellGem, uint maxFillAmt) public returns (uint fillAmt);\r\n    function sellAllAmount(address sellGem, uint sellAmt, address buyGem, uint minFillAmount) public returns (uint fillAmt);\r\n    function getPayAmount(address pay_gem, address buy_gem, uint buy_amt) public view returns (uint fill_amt);\r\n}\r\n\r\n// OCM := OasisCdpManager\r\ncontract OCMLike {\r\n    function urns(address usr, bytes32 ilk) public view returns (address urn);\r\n    function open(bytes32 ilk) public returns (address urn);\r\n    function frob(bytes32 ilk, int dink, int dart) public;\r\n    function flux(bytes32 ilk, address dst, uint wad) public;\r\n    function move(bytes32 ilk, address dst, uint rad) public;\r\n    function quit(bytes32 ilk) public;\r\n}\r\n\r\n// DCM := DssCdpManager\r\ncontract DCMLike {\r\n    function open(bytes32 ilk, address usr) public returns (uint);\r\n    function enter(address src, uint cdp) public;\r\n}\r\n\r\ncontract OMPAEvents {\r\n    event FundGem(bytes32 indexed ilk, uint amount);\r\n    event FundDai(bytes32 indexed ilk, uint amount);\r\n    event DrawGem(bytes32 indexed ilk, uint amount);\r\n    event DrawDai(bytes32 indexed ilk, uint amount);\r\n    event Buy(bytes32 indexed ilk, uint amount, uint maxPayAmount, uint payAmount);\r\n    event Sell(bytes32 indexed ilk, uint amount, uint minPayAmount, uint payAmount);\r\n    event Redeem(bytes32 indexed ilk, uint amount);\r\n    event Free(bytes32 indexed ilk, uint amount, uint daiAmount);\r\n    event Export(bytes32 indexed ilk, uint amount, uint daiAmount);\r\n}\r\n\r\ncontract OasisMultiplyProxyActions is DSMath, OMPAEvents {\r\n    uint constant UV_INK   = 0;\r\n    uint constant UV_TAB   = 1;\r\n    uint constant UV_SPOT  = 2;\r\n    uint constant UV_RATE  = 3;\r\n    uint constant UV_DUST  = 4;\r\n    uint constant UV_COUNT = 5;\r\n\r\n    // This function returns an urn's ink, tab (:= art*rate), spot, and rate as a memory array.\r\n    function urnValues(\r\n        bytes32 ilk,\r\n        address owner,\r\n        address vat\r\n    ) internal view returns (uint[UV_COUNT] memory values) {\r\n        (, uint rate, uint spot, , uint dust) = VatLike(vat).ilks(ilk);\r\n        (uint ink, uint art) = VatLike(vat).urns(ilk, owner);\r\n        values[UV_INK]  = ink;\r\n        values[UV_TAB]  = mul(art, rate);\r\n        values[UV_SPOT] = spot;\r\n        values[UV_RATE] = rate;\r\n        values[UV_DUST] = dust;\r\n    }\r\n\r\n    // conversion factor; RAY / ROW = WAD\r\n    // actual value: 10 ** 9\r\n    uint constant ROW = RAY / WAD;\r\n\r\n    uint constant BO_WALLET_BALANCE = 0;\r\n    uint constant BO_MARGIN_BALANCE = 1;\r\n    uint constant BO_URN_BALANCE = 2;\r\n    uint constant BO_DEBT = 3;\r\n    uint constant BO_DAI_BALANCE = 4;\r\n    uint constant BO_PRICE = 5;\r\n    uint constant BO_MIN_COLL_RATIO = 6;\r\n    uint constant BO_ALLOWANCE = 7;\r\n    uint constant BO_STABILITY_FEE = 8;\r\n    uint constant BO_LIQUIDATION_PENALTY = 9;\r\n    uint constant BO_DUST = 10;\r\n    uint constant BO_COUNT = 11;\r\n\r\n    function balance(\r\n        address margin,\r\n        bytes32[] memory ilks,\r\n        address[] memory tokens,\r\n        address vat,\r\n        address spotter,\r\n        address jug,\r\n        address cat,\r\n        address ocm\r\n    ) public view returns (uint[] memory data, uint live) {\r\n        data = new uint[](BO_COUNT * ilks.length);\r\n        live = VatLike(vat).live();\r\n        for (uint i = 0; i < ilks.length; i++) {\r\n            if (uint(ilks[i]) == 0) break;\r\n            uint row = BO_COUNT * i;\r\n            data[row+BO_WALLET_BALANCE] = TokenLike(tokens[i]).balanceOf(msg.sender);\r\n            data[row+BO_ALLOWANCE] = TokenLike(tokens[i]).allowance(msg.sender, margin);\r\n            address urn = OCMLike(ocm).urns(margin, ilks[i]);\r\n            uint spot;\r\n            uint dust_mat_duty;\r\n            if (urn != address(0)) {\r\n                data[row+BO_MARGIN_BALANCE] = VatLike(vat).gem(ilks[i], urn);\r\n                uint[UV_COUNT] memory urnVals = urnValues(ilks[i], urn, vat);\r\n                data[row+BO_URN_BALANCE] = urnVals[UV_INK];\r\n                data[row+BO_DEBT] = urnVals[UV_TAB] / RAY;\r\n                spot = urnVals[UV_SPOT];\r\n                dust_mat_duty  = urnVals[UV_DUST];\r\n                data[row+BO_DAI_BALANCE] = VatLike(vat).dai(urn) / RAY;\r\n            } else {\r\n                (, , spot, , dust_mat_duty) = VatLike(vat).ilks(ilks[i]);\r\n            }\r\n            data[row+BO_DUST] = dust_mat_duty / RAY;\r\n            (, dust_mat_duty) = SpotLike(spotter).ilks(ilks[i]);\r\n            data[row+BO_PRICE] = mul(spot, dust_mat_duty) / (RAY * ROW);\r\n            data[row+BO_MIN_COLL_RATIO] = dust_mat_duty / ROW;\r\n            (dust_mat_duty, ) = JugLike(jug).ilks(ilks[i]);\r\n            data[row+BO_STABILITY_FEE] = dust_mat_duty + JugLike(jug).base();\r\n            (, data[row+BO_LIQUIDATION_PENALTY], ) = CatLike(cat).ilks(ilks[i]);\r\n        }\r\n    }\r\n\r\n    function init(\r\n        address ocm,\r\n        bytes32 ilk\r\n    ) internal returns (address urn) {\r\n        urn = OCMLike(ocm).urns(address(this), ilk);\r\n        if (urn == address(0)) urn = OCMLike(ocm).open(ilk);\r\n    }\r\n\r\n    function approve(\r\n        address token,\r\n        address usr\r\n    ) internal {\r\n        if (TokenLike(token).allowance(address(this), usr) != uint(-1)) {\r\n            require(\r\n                TokenLike(token).approve(usr, uint(-1)),\r\n                \"ompa/cannot-approve\"\r\n            );\r\n        }\r\n    }\r\n\r\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n    // WARNING:                                                              //\r\n    //   These functions are meant to be used as a library for a DSProxy.    //\r\n    //   Some are unsafe if called directly.                                 //\r\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n\r\n    function fundGem(\r\n        address ocm,\r\n        bytes32 ilk,\r\n        uint amount,\r\n        address token,\r\n        address adapter\r\n    ) public {\r\n        require(\r\n            TokenLike(token).transferFrom(msg.sender, address(this), amount),\r\n            \"ompa/fund-cannot-transfer\"\r\n        );\r\n        address urn = init(ocm, ilk);\r\n        approve(token, adapter);\r\n        GemJoinLike(adapter).join(urn, amount);\r\n        require(amount < 2**255, \"ompa/fundGem-overflow\");\r\n        OCMLike(ocm).frob(ilk, int(amount), 0);\r\n        emit FundGem(ilk, amount);\r\n    }\r\n\r\n    function fundDai(\r\n        address ocm,\r\n        bytes32 ilk,\r\n        uint amount,\r\n        address token,\r\n        address adapter,\r\n        address vat\r\n    ) public {\r\n        require(\r\n            TokenLike(token).transferFrom(msg.sender, address(this), amount),\r\n            \"ompa/fund-cannot-transfer\"\r\n        );\r\n        emit FundDai(ilk, amount);\r\n        address urn = init(ocm, ilk);\r\n        approve(token, adapter);\r\n        GemJoinLike(adapter).join(urn, amount);\r\n        // join will have created the OCM urn if it did not already exist\r\n        (, uint art) = VatLike(vat).urns(ilk, urn);\r\n        if (art == 0) return;\r\n        (, uint rate,,,) = VatLike(vat).ilks(ilk);\r\n        uint tab = mul(art, rate);\r\n        uint dai = mul(amount, RAY);\r\n        uint dart;\r\n        if (dai >= tab) {\r\n          // wipe all debt\r\n          dart = art;\r\n        } else {\r\n          // use (approximately) all free dai to wipe debt\r\n          // if this makes the urn dusty, the tx will revert--UI must handle this\r\n          dart = dai / rate;\r\n          require(dart <= 2**255, \"ompa/fundDai-overflow\");\r\n        }\r\n        OCMLike(ocm).frob(ilk, 0, -int(dart));\r\n\r\n    }\r\n\r\n    function drawGem(\r\n        address ocm,\r\n        bytes32 ilk,\r\n        uint amount,\r\n        address adapter\r\n    ) public {\r\n        emit DrawGem(ilk, amount);\r\n        require(amount <= 2**255, \"ompa/fundGem-overflow\");\r\n        OCMLike(ocm).frob(ilk, -int(amount), 0);\r\n        OCMLike(ocm).flux(ilk, address(this), amount);\r\n        GemJoinLike(adapter).exit(msg.sender, amount);\r\n    }\r\n\r\n    function drawDai(\r\n        address ocm,\r\n        bytes32 ilk,\r\n        uint amount,\r\n        address adapter,\r\n        address vat,\r\n        address jug\r\n    ) public {\r\n        emit DrawDai(ilk, amount);\r\n        address urn = init(ocm, ilk);\r\n        uint dai = VatLike(vat).dai(urn) / RAY;\r\n        if (amount > dai) {\r\n            uint rate = JugLike(jug).drip(ilk);\r\n            // add 1 to ensure we generate at least (amount - dai) new debt\r\n            uint dart = add(1, mul(amount - dai, RAY) / rate);\r\n            require(dart < 2**255, \"ompa/drawDai-overflow\");\r\n            OCMLike(ocm).frob(ilk, 0, int(dart));\r\n        }\r\n        OCMLike(ocm).move(ilk, address(this), amount * RAY);\r\n        VatLike(vat).hope(adapter);\r\n        GemJoinLike(adapter).exit(msg.sender, amount);\r\n    }\r\n\r\n    uint constant ADDR_TOKEN = 0;\r\n    uint constant ADDR_ADAPTER = 1;\r\n    uint constant ADDR_PAY_TOKEN = 2;\r\n    uint constant ADDR_PAY_ADAPTER = 3;\r\n    uint constant ADDR_OCM = 4;\r\n    uint constant ADDR_OTC = 5;\r\n    uint constant ADDR_VAT = 6;\r\n    uint constant ADDR_JUG = 7;\r\n    uint constant ADDR_BUY_COUNT = 8;\r\n    uint constant ADDR_SELL_COUNT = 7;\r\n\r\n    function buy(\r\n        address[ADDR_BUY_COUNT] memory contracts,\r\n        bytes32 ilk,\r\n        uint amount,\r\n        uint maxPayAmount\r\n    ) public {\r\n        uint payAmount = OtcLike(contracts[ADDR_OTC]).getPayAmount(\r\n            contracts[ADDR_PAY_TOKEN],\r\n            contracts[ADDR_TOKEN],\r\n            amount\r\n        );\r\n        require(payAmount <= maxPayAmount, \"ompa/buy-excessive-total-amount\");\r\n\r\n        approve(contracts[ADDR_PAY_TOKEN], contracts[ADDR_OTC]);\r\n        approve(contracts[ADDR_TOKEN], contracts[ADDR_ADAPTER]);\r\n\r\n        VatLike(contracts[ADDR_VAT]).hope(contracts[ADDR_PAY_ADAPTER]);\r\n\r\n        address urn = OCMLike(contracts[ADDR_OCM]).urns(address(this), ilk);\r\n        uint daiBalance = VatLike(contracts[ADDR_VAT]).dai(urn) / RAY;\r\n\r\n        if (payAmount <= daiBalance) {\r\n            OCMLike(contracts[ADDR_OCM]).move(ilk, address(this), payAmount * RAY);\r\n            GemJoinLike(contracts[ADDR_PAY_ADAPTER]).exit(address(this), payAmount);\r\n\r\n            payAmount = OtcLike(contracts[ADDR_OTC]).buyAllAmount(\r\n                contracts[ADDR_TOKEN],\r\n                amount,\r\n                contracts[ADDR_PAY_TOKEN],\r\n                payAmount\r\n            );\r\n\r\n            GemJoinLike(contracts[ADDR_ADAPTER]).join(urn, amount);\r\n            OCMLike(contracts[ADDR_OCM]).frob(ilk, int(amount), 0);\r\n        } else {\r\n            uint daiLeft = payAmount;\r\n            payAmount = add(payAmount, TokenLike(contracts[ADDR_PAY_TOKEN]).balanceOf(address(this)));\r\n            amount = 0;\r\n            JugLike(contracts[ADDR_JUG]).drip(ilk);\r\n            uint[UV_COUNT] memory urnVals = urnValues(ilk, urn, contracts[ADDR_VAT]);\r\n            while (daiLeft > 0) {\r\n                uint drawableDai = mul(urnVals[UV_INK], urnVals[UV_SPOT]);\r\n                drawableDai = drawableDai > urnVals[UV_TAB] ? drawableDai - urnVals[UV_TAB] : 0;\r\n\r\n                // daiLeft > daiBalance, so subtraction can be unchecked\r\n                uint dart = min(mul(daiLeft - daiBalance, RAY), drawableDai) / urnVals[UV_RATE];\r\n\r\n                // dart should be non-zero and the resulting position should be non-dusty\r\n                // math is guaranteed to be safe by prior logic; cache new tab in drawableDai variable\r\n                if (dart > 0 && (drawableDai = dart * urnVals[UV_RATE] + urnVals[UV_TAB]) >= urnVals[UV_DUST]) {\r\n                    require(dart < 2**255, \"ompa/buy-overflow\");\r\n                    OCMLike(contracts[ADDR_OCM]).frob(ilk, 0, int(dart));\r\n                    urnVals[UV_TAB] = drawableDai;\r\n                } else if (daiBalance == 0) {\r\n                    // two cases:\r\n                    //   1) need to draw a dusty amount\r\n                    //   2) need to draw less than minimum possible amount of dai (dart == 0)\r\n\r\n                    // Case (1) -- must revert\r\n                    if (dart > 0) revert(\"ompa/buy-unfillable-dusty\");\r\n\r\n                    // Case (2) -- try to fill order\r\n                    // This may revert due to being unsafe; if this happens, it is the correct behavior.\r\n                    // If successful, we may buy slightly more than <amount> of <ilk>.\r\n                    OCMLike(contracts[ADDR_OCM]).frob(ilk, 0, 1);\r\n                    urnVals[UV_TAB] += urnVals[UV_RATE];\r\n                }\r\n\r\n                daiBalance = VatLike(contracts[ADDR_VAT]).dai(urn) / RAY;\r\n\r\n                OCMLike(contracts[ADDR_OCM]).move(ilk, address(this), daiBalance * RAY);\r\n                GemJoinLike(contracts[ADDR_PAY_ADAPTER]).exit(address(this), daiBalance);\r\n\r\n                uint buyAmount = OtcLike(contracts[ADDR_OTC]).sellAllAmount(\r\n                    contracts[ADDR_PAY_TOKEN],\r\n                    daiBalance,\r\n                    contracts[ADDR_TOKEN],\r\n                    0\r\n                );\r\n                amount = add(amount, buyAmount);\r\n                daiLeft = daiLeft <= daiBalance ? 0 : daiLeft - daiBalance;\r\n                daiBalance = 0;\r\n\r\n                GemJoinLike(contracts[ADDR_ADAPTER]).join(urn, buyAmount);\r\n\r\n                require(buyAmount < 2**255, \"ompa/buy-overflow\");\r\n                OCMLike(contracts[ADDR_OCM]).frob(ilk, int(buyAmount), 0);\r\n                urnVals[UV_INK] = add(urnVals[UV_INK], buyAmount);\r\n            }\r\n            payAmount = sub(payAmount, TokenLike(contracts[ADDR_PAY_TOKEN]).balanceOf(address(this)));\r\n        }\r\n        emit Buy(ilk, amount, maxPayAmount, payAmount);\r\n    }\r\n\r\n    function sell(\r\n        address[ADDR_SELL_COUNT] memory contracts,\r\n        bytes32 ilk,\r\n        uint origSellAmount,\r\n        uint minDaiAmount\r\n    ) public {\r\n        approve(contracts[ADDR_TOKEN], contracts[ADDR_OTC]);\r\n        approve(contracts[ADDR_PAY_TOKEN], contracts[ADDR_PAY_ADAPTER]);\r\n\r\n        uint totalDaiAmount = 0;\r\n\r\n        address urn = OCMLike(contracts[ADDR_OCM]).urns(address(this), ilk);\r\n        uint[UV_COUNT] memory urnVals = urnValues(ilk, urn, contracts[ADDR_VAT]);\r\n\r\n        uint amount = origSellAmount;\r\n\r\n        while (amount > 0) {\r\n            // truncating division ensures that sellAmount will not be too large\r\n            uint sellAmount = sub(mul(urnVals[UV_INK], urnVals[UV_SPOT]), urnVals[UV_TAB]) / urnVals[UV_SPOT];\r\n            require(sellAmount > 0, \"ompa/sell-cannot-sell\");\r\n            if (sellAmount > amount) {\r\n                sellAmount = amount;\r\n                amount = 0;\r\n            } else {\r\n                amount = sub(amount, sellAmount);\r\n            }\r\n            require(sellAmount <= 2**255, \"ompa/sell-overflow\");\r\n            OCMLike(contracts[ADDR_OCM]).frob(ilk, -int(sellAmount), 0);\r\n\r\n            OCMLike(contracts[ADDR_OCM]).flux(ilk, address(this), sellAmount);\r\n            GemJoinLike(contracts[ADDR_ADAPTER]).exit(address(this), sellAmount);\r\n\r\n            urnVals[UV_INK] = sub(urnVals[UV_INK], sellAmount);\r\n            uint daiAmount = OtcLike(contracts[ADDR_OTC]).sellAllAmount(\r\n                contracts[ADDR_TOKEN],\r\n                sellAmount,\r\n                contracts[ADDR_PAY_TOKEN],\r\n                0\r\n            );\r\n\r\n            totalDaiAmount = add(totalDaiAmount, daiAmount);\r\n\r\n            GemJoinLike(contracts[ADDR_PAY_ADAPTER]).join(urn, daiAmount);\r\n\r\n            daiAmount = mul(daiAmount, RAY);\r\n            uint dart = daiAmount >= urnVals[UV_TAB]\r\n                            ? urnVals[UV_TAB]\r\n                            : min(daiAmount, urnVals[UV_TAB] - urnVals[UV_DUST]);\r\n            dart = dart / urnVals[UV_RATE];\r\n            require(dart <= 2**255, \"ompa/sell-overflow\");\r\n            OCMLike(contracts[ADDR_OCM]).frob(ilk, 0, -int(dart));\r\n\r\n            // frob succeeded, so this math must be safe\r\n            urnVals[UV_TAB] = urnVals[UV_TAB] - dart * urnVals[UV_RATE];\r\n        }\r\n        require(\r\n            totalDaiAmount >= minDaiAmount, \"ompa/sell-insufficient-total-amount\"\r\n        );\r\n        emit Sell(ilk, origSellAmount, minDaiAmount, totalDaiAmount);\r\n    }\r\n\r\n    function redeem(\r\n        address ocm,\r\n        bytes32 ilk,\r\n        uint amount\r\n    ) public {\r\n        emit Redeem(ilk, amount);\r\n        require(amount < 2**255, \"ompa/redeem-overflow\");\r\n        OCMLike(ocm).frob(ilk, int(amount), 0);\r\n    }\r\n\r\n    function free(\r\n        address ocm,\r\n        bytes32 ilk,\r\n        address vat,\r\n        address end,\r\n        address adapter,\r\n        address daiAdapter\r\n    ) public {\r\n        VatLike(vat).hope(address(ocm));\r\n        OCMLike(ocm).quit(ilk);\r\n        EndLike(end).free(ilk);\r\n        uint gem = VatLike(vat).gem(ilk, OCMLike(ocm).urns(address(this), ilk));\r\n        OCMLike(ocm).flux(ilk, address(this), gem);\r\n        uint amount = VatLike(vat).gem(ilk, address(this));\r\n        GemJoinLike(adapter).exit(msg.sender, amount);\r\n        uint dai = VatLike(vat).dai(OCMLike(ocm).urns(address(this), ilk)) / RAY;\r\n\r\n        OCMLike(ocm).move(ilk, address(this), dai * RAY);\r\n        VatLike(vat).hope(daiAdapter);\r\n        GemJoinLike(daiAdapter).exit(msg.sender, dai);\r\n\r\n        emit Free(ilk, amount, dai);\r\n    }\r\n\r\n    function export(\r\n        address ocm,\r\n        bytes32 ilk,\r\n        address vat,\r\n        address dcm\r\n    ) public returns (uint cdpId) {\r\n        uint[UV_COUNT] memory urnVals = urnValues(ilk, OCMLike(ocm).urns(address(this), ilk), vat);\r\n        emit Export(ilk, urnVals[UV_INK], urnVals[UV_TAB] / RAY);\r\n\r\n        VatLike(vat).hope(ocm);\r\n        OCMLike(ocm).quit(ilk);\r\n\r\n        cdpId = DCMLike(dcm).open(ilk, address(this));\r\n        VatLike(vat).hope(address(dcm));\r\n        DCMLike(dcm).enter(address(this), cdpId);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxPayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DrawDai\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DrawGem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"Export\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"Free\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundDai\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundGem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"margin\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"ilks\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"vat\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spotter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cat\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ocm\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"live\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[8]\",\"name\":\"contracts\",\"type\":\"address[8]\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayAmount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ocm\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vat\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"}],\"name\":\"drawDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ocm\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"drawGem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ocm\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"vat\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dcm\",\"type\":\"address\"}],\"name\":\"export\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ocm\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"vat\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"end\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"daiAdapter\",\"type\":\"address\"}],\"name\":\"free\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ocm\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vat\",\"type\":\"address\"}],\"name\":\"fundDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ocm\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"fundGem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ocm\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[7]\",\"name\":\"contracts\",\"type\":\"address[7]\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"origSellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDaiAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OasisMultiplyProxyActions","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8a17d9b549cadba28333e2e3e7bd7abad1983ee36674fbd5595d1ec575d1fa4d"}]}