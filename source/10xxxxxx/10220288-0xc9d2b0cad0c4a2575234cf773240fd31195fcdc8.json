{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\ncontract FlipCoin {\r\n    uint constant private PERIOD_EXPIRED = 1 days;\r\n    uint internal platformFeeAccumulated;\r\n    address payable private creator;\r\n    mapping (uint => uint) internal CHALLENGES;\r\n    mapping (address  => mapping (uint  => uint)) internal currentGames;\r\n\r\n    constructor(address payable _creator) public {\r\n        CHALLENGES[1] = 0.01 ether;\r\n        CHALLENGES[2] = 0.05 ether;\r\n        CHALLENGES[3] = 0.1 ether;\r\n        CHALLENGES[4] = 0.5 ether;\r\n        CHALLENGES[5] = 1 ether;\r\n        CHALLENGES[6] = 2 ether;\r\n        CHALLENGES[7] = 5 ether;\r\n        CHALLENGES[8] = 10 ether;\r\n        creator = _creator;\r\n        platformFeeAccumulated = 0;\r\n    }\r\n\r\n    event GameResult(\r\n        address indexed betMaker,\r\n        uint256 bet,\r\n        address indexed winner,\r\n        address indexed loser,\r\n        uint256 prize,\r\n        uint timestamp\r\n    );\r\n\r\n    event BetMade(\r\n        address indexed player,\r\n        uint256 amount,\r\n        uint timestamp\r\n    );\r\n\r\n    event Withdrawn(\r\n        address indexed player,\r\n        uint256 amount,\r\n        uint timestamp\r\n    );\r\n\r\n    modifier onlyCreator() {\r\n        require(msg.sender == creator, \"Caller is not the creator\");\r\n        _;\r\n    }\r\n\r\n    function destroy() external onlyCreator {\r\n        selfdestruct(creator);\r\n    }\r\n\r\n    function getMyBets() external view returns (uint[] memory) {\r\n        uint[] memory bets = new uint[](9);\r\n        for (uint i = 1; i <= 8; i++) {\r\n            if (currentGames[msg.sender][i] > 0) {\r\n                bets[i] = currentGames[msg.sender][i];\r\n            }\r\n        }\r\n        return bets;\r\n    }\r\n\r\n    function WithdrawPlatformFee () external onlyCreator {\r\n        require(platformFeeAccumulated > 0, \"Not enought balance\");\r\n        uint balance = address(this).balance;\r\n        uint valueToWithdraw = balance > platformFeeAccumulated ? platformFeeAccumulated : balance;\r\n        assert(valueToWithdraw > 0);\r\n        creator.transfer(valueToWithdraw);\r\n        platformFeeAccumulated -= valueToWithdraw;\r\n    }\r\n\r\n    function () external payable {\r\n        require(msg.value != 0, \"Bet cannot be zero\");\r\n        require(msg.sender != address(0), \"This wallet is not allowed\");\r\n\r\n        address opponent = bytesToAddress(msg.data);\r\n        require(msg.sender != opponent, \"bet maker and opponent cannot be the same\");\r\n\r\n        uint betIndex = 0;\r\n        for (uint i = 1; i <= 8; i++) {\r\n            if (CHALLENGES[i] == msg.value) {\r\n                betIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(betIndex > 0, \"bet must be one of the predefined\");\r\n\r\n        if(opponent == address(0)) {\r\n            makeBet(betIndex);\r\n        } else {\r\n            if(!closeBet(betIndex, Address.toPayable(opponent))) {\r\n                makeBet(betIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdrawMyBets() external {\r\n        uint amountToWithdraw = 0;\r\n        uint8[9] memory bets = [0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n        for (uint i = 1; i <= 8; i++) {\r\n            if(currentGames[msg.sender][i] > 0 && now > currentGames[msg.sender][i]) {\r\n                amountToWithdraw += CHALLENGES[i];\r\n                delete currentGames[msg.sender][i];\r\n                bets[i] = 1;\r\n            }\r\n        }\r\n\r\n        require(amountToWithdraw > 0, \"At least one bet should be expired\");\r\n        msg.sender.transfer(amountToWithdraw);\r\n\r\n        for (uint i = 1; i <= 8; i++) {\r\n            if(bets[i] != 0) {\r\n                emit Withdrawn(msg.sender, CHALLENGES[i], now);\r\n            }\r\n        }\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address payable  addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n\r\n    function random() private view returns (bool) {\r\n        require(!Address.isContract(msg.sender), \"Game cannot be executed by contract address\");\r\n        uint blockNumberOffset = uint(keccak256(abi.encodePacked(address(this).balance))) % 100;\r\n        return uint(blockhash(block.number - 10 - blockNumberOffset)) % 2 == 0 ? true : false;\r\n    }\r\n\r\n    function closeBet(uint betIndex, address payable opponent) private returns (bool) {\r\n        if(currentGames[opponent][betIndex] == 0)\r\n            return false;\r\n        if (now > currentGames[opponent][betIndex])\r\n            return false;\r\n        uint full = mul256(CHALLENGES[betIndex], 2); // 2% comission.\r\n        uint percent = div256(full, 100);\r\n        platformFeeAccumulated += mul256(percent, 2);\r\n        uint prize = mul256(percent, 98); // 98% is prize.\r\n        if(random()) {\r\n            msg.sender.transfer(prize);\r\n            emit GameResult(opponent, CHALLENGES[betIndex], msg.sender, opponent, prize, now);\r\n        } else {\r\n            opponent.transfer(prize);\r\n            emit GameResult(opponent, CHALLENGES[betIndex], opponent, msg.sender, prize, now);\r\n        }\r\n        delete currentGames[opponent][betIndex];\r\n        return true;\r\n    }\r\n\r\n    function makeBet(uint betIndex) private {\r\n        require (currentGames[msg.sender][betIndex] == 0, \"Bet with this value already exists\");\r\n        currentGames[msg.sender][betIndex] = now + PERIOD_EXPIRED;\r\n        emit BetMade(msg.sender, CHALLENGES[betIndex], now);\r\n    }\r\n\r\n    function mul256(uint a, uint b) private pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"Multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div256(uint a, uint b) private pure returns (uint) {\r\n        require(b > 0, \"Division by zero\");\r\n        return a / b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawMyBets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawPlatformFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"betMaker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"loser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"GameResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BetMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"}]","ContractName":"FlipCoin","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000015d0bdfd209f3e3828c5e0b3f50470b089e48d7b","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"bzzr://627899cf8204167aecc429e138abd1a0af33c3a6c48aa8aed48ead71b1f88789"}]}