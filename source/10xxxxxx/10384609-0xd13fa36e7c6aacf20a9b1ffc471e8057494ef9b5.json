{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint256           wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSProxy is DSAuth, DSNote {\r\n    DSProxyCache public cache;  // global cache for contracts\r\n\r\n    function DSProxy(address _cacheAddr) public {\r\n        require(setCache(_cacheAddr));\r\n    }\r\n\r\n    function() public payable {\r\n    }\r\n\r\n    // use the proxy to execute calldata _data on contract _code\r\n    function execute(bytes _code, bytes _data)\r\n        public\r\n        payable\r\n        returns (address target, bytes32 response)\r\n    {\r\n        target = cache.read(_code);\r\n        if (target == 0x0) {\r\n            // deploy contract & store its address in cache\r\n            target = cache.write(_code);\r\n        }\r\n\r\n        response = execute(target, _data);\r\n    }\r\n\r\n    function execute(address _target, bytes _data)\r\n        public\r\n        auth\r\n        note\r\n        payable\r\n        returns (bytes32 response)\r\n    {\r\n        require(_target != 0x0);\r\n\r\n        // call contract in current context\r\n        assembly {\r\n            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 32)\r\n            response := mload(0)      // load delegatecall output\r\n            switch iszero(succeeded)\r\n            case 1 {\r\n                // throw if delegatecall failed\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    //set new cache\r\n    function setCache(address _cacheAddr)\r\n        public\r\n        auth\r\n        note\r\n        returns (bool)\r\n    {\r\n        require(_cacheAddr != 0x0);        // invalid cache address\r\n        cache = DSProxyCache(_cacheAddr);  // overwrite cache\r\n        return true;\r\n    }\r\n}\r\n\r\n// DSProxyFactory\r\n// This factory deploys new proxy instances through build()\r\n// Deployed proxy addresses are logged\r\ncontract DSProxyFactory {\r\n    event Created(address indexed sender, address proxy, address cache);\r\n    mapping(address=>bool) public isProxy;\r\n    DSProxyCache public cache = new DSProxyCache();\r\n\r\n    // deploys a new proxy instance\r\n    // sets owner of proxy to caller\r\n    function build() public returns (DSProxy proxy) {\r\n        proxy = build(msg.sender);\r\n    }\r\n\r\n    // deploys a new proxy instance\r\n    // sets custom owner of proxy\r\n    function build(address owner) public returns (DSProxy proxy) {\r\n        proxy = new DSProxy(cache);\r\n        Created(owner, address(proxy), address(cache));\r\n        proxy.setOwner(owner);\r\n        isProxy[proxy] = true;\r\n    }\r\n}\r\n\r\n// DSProxyCache\r\n// This global cache stores addresses of contracts previously deployed\r\n// by a proxy. This saves gas from repeat deployment of the same\r\n// contracts and eliminates blockchain bloat.\r\n\r\n// By default, all proxies deployed from the same factory store\r\n// contracts in the same cache. The cache a proxy instance uses can be\r\n// changed.  The cache uses the sha3 hash of a contract's bytecode to\r\n// lookup the address\r\ncontract DSProxyCache {\r\n    mapping(bytes32 => address) cache;\r\n\r\n    function read(bytes _code) public view returns (address) {\r\n        bytes32 hash = keccak256(_code);\r\n        return cache[hash];\r\n    }\r\n\r\n    function write(bytes _code) public returns (address target) {\r\n        assembly {\r\n            target := create(0, add(_code, 0x20), mload(_code))\r\n            switch iszero(extcodesize(target))\r\n            case 1 {\r\n                // throw if contract failed to deploy\r\n                revert(0, 0)\r\n            }\r\n        }\r\n        bytes32 hash = keccak256(_code);\r\n        cache[hash] = target;\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract OtcInterface {\r\n    function sellAllAmount(address, uint, address, uint) public returns (uint);\r\n    function buyAllAmount(address, uint, address, uint) public returns (uint);\r\n    function getPayAmount(address, address, uint) public constant returns (uint);\r\n}\r\n\r\ncontract TokenInterface {\r\n    function balanceOf(address) public returns (uint);\r\n    function allowance(address, address) public returns (uint);\r\n    function transfer(address,uint) public;\r\n    function approve(address, uint) public;\r\n    function transferFrom(address, address, uint) public;\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n}\r\n\r\ncontract OasisDirectProxy is DSMath {\r\n    function withdrawAndSend(TokenInterface wethToken, uint wethAmt) internal {\r\n        wethToken.withdraw(wethAmt);\r\n        require(msg.sender.call.value(wethAmt)());\r\n    }\r\n\r\n    function sellAllAmount(OtcInterface otc, TokenInterface payToken, uint payAmt, TokenInterface buyToken, uint minBuyAmt) public returns (uint buyAmt) {\r\n        payToken.transferFrom(msg.sender, this, payAmt);\r\n        if (payToken.allowance(this, otc) < payAmt) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        buyAmt = otc.sellAllAmount(payToken, payAmt, buyToken, minBuyAmt);\r\n        buyToken.transfer(msg.sender, buyAmt);\r\n    }\r\n\r\n    function sellAllAmountPayEth(OtcInterface otc, TokenInterface wethToken, TokenInterface buyToken, uint minBuyAmt) public payable returns (uint buyAmt) {\r\n        wethToken.deposit.value(msg.value)();\r\n        if (wethToken.allowance(this, otc) < msg.value) {\r\n            wethToken.approve(otc, uint(-1));\r\n        }\r\n        buyAmt = otc.sellAllAmount(wethToken, msg.value, buyToken, minBuyAmt);\r\n        buyToken.transfer(msg.sender, buyAmt);\r\n    }\r\n\r\n    function sellAllAmountBuyEth(OtcInterface otc, TokenInterface payToken, uint payAmt, TokenInterface wethToken, uint minBuyAmt) public returns (uint wethAmt) {\r\n        payToken.transferFrom(msg.sender, this, payAmt);\r\n        if (payToken.allowance(this, otc) < payAmt) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        wethAmt = otc.sellAllAmount(payToken, payAmt, wethToken, minBuyAmt);\r\n        withdrawAndSend(wethToken, wethAmt);\r\n    }\r\n\r\n    function buyAllAmount(OtcInterface otc, TokenInterface buyToken, uint buyAmt, TokenInterface payToken, uint maxPayAmt) public returns (uint payAmt) {\r\n        uint payAmtNow = otc.getPayAmount(payToken, buyToken, buyAmt);\r\n        require(payAmtNow <= maxPayAmt);\r\n        payToken.transferFrom(msg.sender, this, payAmtNow);\r\n        if (payToken.allowance(this, otc) < payAmtNow) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        payAmt = otc.buyAllAmount(buyToken, buyAmt, payToken, payAmtNow);\r\n        buyToken.transfer(msg.sender, min(buyAmt, buyToken.balanceOf(this))); // To avoid rounding issues we check the minimum value\r\n    }\r\n\r\n    function buyAllAmountPayEth(OtcInterface otc, TokenInterface buyToken, uint buyAmt, TokenInterface wethToken) public payable returns (uint wethAmt) {\r\n        // In this case user needs to send more ETH than a estimated value, then contract will send back the rest\r\n        wethToken.deposit.value(msg.value)();\r\n        if (wethToken.allowance(this, otc) < msg.value) {\r\n            wethToken.approve(otc, uint(-1));\r\n        }\r\n        wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value);\r\n        buyToken.transfer(msg.sender, min(buyAmt, buyToken.balanceOf(this))); // To avoid rounding issues we check the minimum value\r\n        withdrawAndSend(wethToken, sub(msg.value, wethAmt));\r\n    }\r\n\r\n    function buyAllAmountBuyEth(OtcInterface otc, TokenInterface wethToken, uint wethAmt, TokenInterface payToken, uint maxPayAmt) public returns (uint payAmt) {\r\n        uint payAmtNow = otc.getPayAmount(payToken, wethToken, wethAmt);\r\n        require(payAmtNow <= maxPayAmt);\r\n        payToken.transferFrom(msg.sender, this, payAmtNow);\r\n        if (payToken.allowance(this, otc) < payAmtNow) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        payAmt = otc.buyAllAmount(wethToken, wethAmt, payToken, payAmtNow);\r\n        withdrawAndSend(wethToken, wethAmt);\r\n    }\r\n\r\n    function() public payable {}\r\n}\r\n\r\ncontract ProxyCreationAndExecute is OasisDirectProxy {\r\n    TokenInterface wethToken;\r\n\r\n    function ProxyCreationAndExecute(address wethToken_) {\r\n        wethToken = TokenInterface(wethToken_);\r\n    }\r\n\r\n    function createAndSellAllAmount(DSProxyFactory factory, OtcInterface otc, TokenInterface payToken, uint payAmt, TokenInterface buyToken, uint minBuyAmt) public returns (DSProxy proxy, uint buyAmt) {\r\n        proxy = factory.build(msg.sender);\r\n        buyAmt = sellAllAmount(otc, payToken, payAmt, buyToken, minBuyAmt);\r\n    }\r\n\r\n    function createAndSellAllAmountPayEth(DSProxyFactory factory, OtcInterface otc, TokenInterface buyToken, uint minBuyAmt) public payable returns (DSProxy proxy, uint buyAmt) {\r\n        proxy = factory.build(msg.sender);\r\n        buyAmt = sellAllAmountPayEth(otc, wethToken, buyToken, minBuyAmt);\r\n    }\r\n\r\n    function createAndSellAllAmountBuyEth(DSProxyFactory factory, OtcInterface otc, TokenInterface payToken, uint payAmt, uint minBuyAmt) public returns (DSProxy proxy, uint wethAmt) {\r\n        proxy = factory.build(msg.sender);\r\n        wethAmt = sellAllAmountBuyEth(otc, payToken, payAmt, wethToken, minBuyAmt);\r\n    }\r\n\r\n    function createAndBuyAllAmount(DSProxyFactory factory, OtcInterface otc, TokenInterface buyToken, uint buyAmt, TokenInterface payToken, uint maxPayAmt) public returns (DSProxy proxy, uint payAmt) {\r\n        proxy = factory.build(msg.sender);\r\n        payAmt = buyAllAmount(otc, buyToken, buyAmt, payToken, maxPayAmt);\r\n    }\r\n\r\n    function createAndBuyAllAmountPayEth(DSProxyFactory factory, OtcInterface otc, TokenInterface buyToken, uint buyAmt) public payable returns (DSProxy proxy, uint wethAmt) {\r\n        proxy = factory.build(msg.sender);\r\n        wethAmt = buyAllAmountPayEth(otc, buyToken, buyAmt, wethToken);\r\n    }\r\n\r\n    function createAndBuyAllAmountBuyEth(DSProxyFactory factory, OtcInterface otc, uint wethAmt, TokenInterface payToken, uint maxPayAmt) public returns (DSProxy proxy, uint payAmt) {\r\n        proxy = factory.build(msg.sender);\r\n        payAmt = buyAllAmountBuyEth(otc, wethToken, wethAmt, payToken, maxPayAmt);\r\n    }\r\n\r\n    function() public payable {\r\n        require(msg.sender == address(wethToken));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"payAmt\",\"type\":\"uint256\"},{\"name\":\"wethToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"sellAllAmountBuyEth\",\"outputs\":[{\"name\":\"wethAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"payAmt\",\"type\":\"uint256\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"sellAllAmount\",\"outputs\":[{\"name\":\"buyAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"buyAmt\",\"type\":\"uint256\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"buyAllAmount\",\"outputs\":[{\"name\":\"payAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factory\",\"type\":\"address\"},{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"wethAmt\",\"type\":\"uint256\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"createAndBuyAllAmountBuyEth\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"payAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factory\",\"type\":\"address\"},{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"payAmt\",\"type\":\"uint256\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"createAndSellAllAmountBuyEth\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"wethAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factory\",\"type\":\"address\"},{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"buyAmt\",\"type\":\"uint256\"}],\"name\":\"createAndBuyAllAmountPayEth\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"wethAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factory\",\"type\":\"address\"},{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"createAndSellAllAmountPayEth\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"buyAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factory\",\"type\":\"address\"},{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"buyAmt\",\"type\":\"uint256\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"createAndBuyAllAmount\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"payAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"buyAmt\",\"type\":\"uint256\"},{\"name\":\"wethToken\",\"type\":\"address\"}],\"name\":\"buyAllAmountPayEth\",\"outputs\":[{\"name\":\"wethAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factory\",\"type\":\"address\"},{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"payAmt\",\"type\":\"uint256\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"createAndSellAllAmount\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"buyAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"wethToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"sellAllAmountPayEth\",\"outputs\":[{\"name\":\"buyAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"wethToken\",\"type\":\"address\"},{\"name\":\"wethAmt\",\"type\":\"uint256\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"buyAllAmountBuyEth\",\"outputs\":[{\"name\":\"payAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"wethToken_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ProxyCreationAndExecute","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0a80242e5e6b68af42245ac9340780640701d9f860ded29b3d80bd395d658f6d"}]}