{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.12;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface IMerkleTreeTokensVerification {\r\n  function verify(\r\n    address _leaf,\r\n    bytes32 [] calldata proof,\r\n    uint256 [] calldata positions\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\ninterface ITokensTypeStorage {\r\n  function isRegistred(address _address) external view returns(bool);\r\n\r\n  function getType(address _address) external view returns(bytes32);\r\n\r\n  function isPermittedAddress(address _address) external view returns(bool);\r\n\r\n  function owner() external view returns(address);\r\n\r\n  function addNewTokenType(address _token, string calldata _type) external;\r\n\r\n  function setTokenTypeAsOwner(address _token, string calldata _type) external;\r\n}\r\n// Contains view methods for exchange\r\n// We have separated the methods for the fund and for the exchange because they contain different methods.\r\n\r\n\r\n\r\ninterface PoolPortalViewInterface {\r\n  function getDataForBuyingPool(IERC20 _poolToken, uint _type, uint256 _amount)\r\n    external\r\n    view\r\n    returns(\r\n      address[] memory connectorsAddress,\r\n      uint256[] memory connectorsAmount\r\n  );\r\n\r\n  function getBacorConverterAddressByRelay(address relay)\r\n  external\r\n  view\r\n  returns(address converter);\r\n\r\n  function getBancorConnectorsAmountByRelayAmount\r\n  (\r\n    uint256 _amount,\r\n    IERC20 _relay\r\n  )\r\n  external view returns(uint256 bancorAmount, uint256 connectorAmount);\r\n\r\n  function getBancorConnectorsByRelay(address relay)\r\n  external\r\n  view\r\n  returns(address[] memory connectorsAddress);\r\n\r\n  function getBancorRatio(address _from, address _to, uint256 _amount)\r\n  external\r\n  view\r\n  returns(uint256);\r\n\r\n  function getUniswapConnectorsAmountByPoolAmount(\r\n    uint256 _amount,\r\n    address _exchange\r\n  )\r\n  external\r\n  view\r\n  returns(uint256 ethAmount, uint256 ercAmount);\r\n\r\n  function getUniswapV2ConnectorsAmountByPoolAmount(\r\n    uint256 _amount,\r\n    address _exchange\r\n  )\r\n  external\r\n  view\r\n  returns(\r\n    uint256 tokenAmountOne,\r\n    uint256 tokenAmountTwo,\r\n    address tokenAddressOne,\r\n    address tokenAddressTwo\r\n  );\r\n\r\n  function getBalancerConnectorsAmountByPoolAmount(\r\n    uint256 _amount,\r\n    address _pool\r\n  )\r\n  external\r\n  view\r\n  returns(\r\n    address[] memory tokens,\r\n    uint256[] memory tokensAmount\r\n  );\r\n\r\n  function getUniswapTokenAmountByETH(address _token, uint256 _amount)\r\n  external\r\n  view\r\n  returns(uint256);\r\n\r\n  function getTokenByUniswapExchange(address _exchange)\r\n  external\r\n  view\r\n  returns(address);\r\n}\r\ninterface DefiPortalInterface {\r\n  function callPayableProtocol(\r\n    address[] memory tokensToSend,\r\n    uint256[] memory amountsToSend,\r\n    bytes calldata _additionalData,\r\n    bytes32[] calldata _additionalArgs\r\n  )\r\n    external\r\n    payable\r\n    returns(\r\n      string memory eventType,\r\n      address[] memory tokensToReceive,\r\n      uint256[] memory amountsToReceive\r\n    );\r\n\r\n  function callNonPayableProtocol(\r\n    address[] memory tokensToSend,\r\n    uint256[] memory amountsToSend,\r\n    bytes calldata _additionalData,\r\n    bytes32[] calldata _additionalArgs\r\n  )\r\n    external\r\n    returns(\r\n      string memory eventType,\r\n      address[] memory tokensToReceive,\r\n      uint256[] memory amountsToReceive\r\n    );\r\n\r\n  function getValue(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n   external\r\n   view\r\n   returns(uint256);\r\n}\r\n\r\n\r\ninterface ExchangePortalInterface {\r\n  function trade(\r\n    IERC20 _source,\r\n    uint256 _sourceAmount,\r\n    IERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] calldata _proof,\r\n    uint256[] calldata _positions,\r\n    bytes calldata _additionalData,\r\n    bool _verifyDestanation\r\n  )\r\n    external\r\n    payable\r\n    returns (uint256);\r\n\r\n\r\n  function getValue(address _from, address _to, uint256 _amount) external view returns (uint256);\r\n\r\n  function getTotalValue(\r\n    address[] calldata _fromAddresses,\r\n    uint256[] calldata _amounts,\r\n    address _to\r\n    )\r\n    external\r\n    view\r\n   returns (uint256);\r\n}\r\n\r\n\r\ninterface IOneSplitAudit {\r\n  function swap(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 amount,\r\n        uint256 minReturn,\r\n        uint256[] calldata distribution,\r\n        uint256 disableFlags\r\n    ) external payable;\r\n\r\n  function getExpectedReturn(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 amount,\r\n        uint256 parts,\r\n        uint256 featureFlags // See contants in IOneSplit.sol\r\n    )\r\n      external\r\n      view\r\n      returns(\r\n          uint256 returnAmount,\r\n          uint256[] memory distribution\r\n      );\r\n}\r\n\r\n/*\r\n    Bancor Network interface\r\n*/\r\ninterface BancorNetworkInterface {\r\n   function getReturnByPath(\r\n     IERC20[] calldata _path,\r\n     uint256 _amount)\r\n     external\r\n     view\r\n     returns (uint256, uint256);\r\n\r\n    function convert(\r\n        IERC20[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) external payable returns (uint256);\r\n\r\n    function claimAndConvert(\r\n        IERC20[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) external returns (uint256);\r\n\r\n    function convertFor(\r\n        IERC20[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) external payable returns (uint256);\r\n\r\n    function claimAndConvertFor(\r\n        IERC20[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) external returns (uint256);\r\n\r\n    function conversionPath(\r\n        IERC20 _sourceToken,\r\n        IERC20 _targetToken\r\n    ) external view returns (address[] memory);\r\n}\r\n\r\n\r\ninterface IGetBancorData {\r\n  function getBancorContractAddresByName(string calldata _name) external view returns (address result);\r\n  function getBancorRatioForAssets(IERC20 _from, IERC20 _to, uint256 _amount) external view returns(uint256 result);\r\n  function getBancorPathForAssets(IERC20 _from, IERC20 _to) external view returns(address[] memory);\r\n}\r\n\r\n\r\n/*\r\n* This contract do swap for ERC20 via 1inch\r\n\r\n  Also this contract allow get ratio between crypto curency assets\r\n  Also get ratio for Bancor and Uniswap pools\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ExchangePortal is ExchangePortalInterface, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  uint public version = 4;\r\n\r\n  // Contract for handle tokens types\r\n  ITokensTypeStorage public tokensTypes;\r\n\r\n  // Contract for merkle tree white list verification\r\n  IMerkleTreeTokensVerification public merkleTreeWhiteList;\r\n\r\n  // 1INCH\r\n  IOneSplitAudit public oneInch;\r\n\r\n  // BANCOR\r\n  IGetBancorData public bancorData;\r\n\r\n  // CoTrader portals\r\n  PoolPortalViewInterface public poolPortal;\r\n  DefiPortalInterface public defiPortal;\r\n\r\n  // 1 inch flags\r\n  // By default support Bancor + Uniswap + Uniswap v2\r\n  uint256 oneInchFlags = 570425349;\r\n\r\n  // Enum\r\n  // NOTE: You can add a new type at the end, but DO NOT CHANGE this order,\r\n  // because order has dependency in other contracts like ConvertPortal\r\n  enum ExchangeType { Paraswap, Bancor, OneInch }\r\n\r\n  // This contract recognizes ETH by this address\r\n  IERC20 constant private ETH_TOKEN_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n  // Trade event\r\n  event Trade(\r\n     address trader,\r\n     address src,\r\n     uint256 srcAmount,\r\n     address dest,\r\n     uint256 destReceived,\r\n     uint8 exchangeType\r\n  );\r\n\r\n  // black list for non trade able tokens\r\n  mapping (address => bool) disabledTokens;\r\n\r\n  // Modifier to check that trading this token is not disabled\r\n  modifier tokenEnabled(IERC20 _token) {\r\n    require(!disabledTokens[address(_token)]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev contructor\r\n  *\r\n  * @param _defiPortal             address of defiPortal contract\r\n  * @param _bancorData             address of GetBancorData helper\r\n  * @param _poolPortal             address of pool portal\r\n  * @param _oneInch                address of 1inch OneSplitAudit contract\r\n  * @param _tokensTypes            address of the ITokensTypeStorage\r\n  * @param _merkleTreeWhiteList    address of the IMerkleTreeWhiteList\r\n  */\r\n  constructor(\r\n    address _defiPortal,\r\n    address _bancorData,\r\n    address _poolPortal,\r\n    address _oneInch,\r\n    address _tokensTypes,\r\n    address _merkleTreeWhiteList\r\n    )\r\n    public\r\n  {\r\n    defiPortal = DefiPortalInterface(_defiPortal);\r\n    bancorData = IGetBancorData(_bancorData);\r\n    poolPortal = PoolPortalViewInterface(_poolPortal);\r\n    oneInch = IOneSplitAudit(_oneInch);\r\n    tokensTypes = ITokensTypeStorage(_tokensTypes);\r\n    merkleTreeWhiteList = IMerkleTreeTokensVerification(_merkleTreeWhiteList);\r\n  }\r\n\r\n\r\n  // EXCHANGE Functions\r\n\r\n  /**\r\n  * @dev Facilitates a trade for a SmartFund\r\n  *\r\n  * @param _source            ERC20 token to convert from\r\n  * @param _sourceAmount      Amount to convert from (in _source token)\r\n  * @param _destination       ERC20 token to convert to\r\n  * @param _type              The type of exchange to trade with\r\n  * @param _proof             Merkle tree proof (if not used just set [])\r\n  * @param _positions         Merkle tree positions (if not used just set [])\r\n  * @param _additionalData    For additional data (if not used just set 0x0)\r\n  * @param _verifyDestanation For additional check if token in list or not\r\n  *\r\n  * @return receivedAmount    The amount of _destination received from the trade\r\n  */\r\n  function trade(\r\n    IERC20 _source,\r\n    uint256 _sourceAmount,\r\n    IERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] calldata _proof,\r\n    uint256[] calldata _positions,\r\n    bytes calldata _additionalData,\r\n    bool _verifyDestanation\r\n  )\r\n    external\r\n    override\r\n    payable\r\n    tokenEnabled(_destination)\r\n    returns (uint256 receivedAmount)\r\n  {\r\n    // throw if destanation token not in white list\r\n    if(_verifyDestanation)\r\n      _verifyToken(address(_destination), _proof, _positions);\r\n\r\n    require(_source != _destination, \"source can not be destination\");\r\n\r\n    // check ETH payable case\r\n    if (_source == ETH_TOKEN_ADDRESS) {\r\n      require(msg.value == _sourceAmount);\r\n    } else {\r\n      require(msg.value == 0);\r\n    }\r\n\r\n    // SHOULD TRADE PARASWAP HERE\r\n    if (_type == uint(ExchangeType.Paraswap)) {\r\n      revert(\"PARASWAP not supported\");\r\n    }\r\n    // SHOULD TRADE BANCOR HERE\r\n    else if (_type == uint(ExchangeType.Bancor)){\r\n      receivedAmount = _tradeViaBancorNewtork(\r\n          address(_source),\r\n          address(_destination),\r\n          _sourceAmount\r\n      );\r\n    }\r\n    // SHOULD TRADE 1INCH HERE\r\n    else if (_type == uint(ExchangeType.OneInch)){\r\n      receivedAmount = _tradeViaOneInch(\r\n          address(_source),\r\n          address(_destination),\r\n          _sourceAmount,\r\n          _additionalData\r\n      );\r\n    }\r\n\r\n    else {\r\n      // unknown exchange type\r\n      revert();\r\n    }\r\n\r\n    // Additional check\r\n    require(receivedAmount > 0, \"received amount can not be zerro\");\r\n\r\n    // Send destination\r\n    if (_destination == ETH_TOKEN_ADDRESS) {\r\n      (msg.sender).transfer(receivedAmount);\r\n    } else {\r\n      // transfer tokens received to sender\r\n      _destination.transfer(msg.sender, receivedAmount);\r\n    }\r\n\r\n    // Send remains\r\n    _sendRemains(_source, msg.sender);\r\n\r\n    // Trigger event\r\n    emit Trade(\r\n      msg.sender,\r\n      address(_source),\r\n      _sourceAmount,\r\n      address(_destination),\r\n      receivedAmount,\r\n      uint8(_type)\r\n    );\r\n  }\r\n\r\n  // Facilitates for send source remains\r\n  function _sendRemains(IERC20 _source, address _receiver) private {\r\n    // After the trade, any _source that exchangePortal holds will be sent back to msg.sender\r\n    uint256 endAmount = (_source == ETH_TOKEN_ADDRESS)\r\n    ? address(this).balance\r\n    : _source.balanceOf(address(this));\r\n\r\n    // Check if we hold a positive amount of _source\r\n    if (endAmount > 0) {\r\n      if (_source == ETH_TOKEN_ADDRESS) {\r\n        payable(_receiver).transfer(endAmount);\r\n      } else {\r\n        _source.transfer(_receiver, endAmount);\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  // Facilitates for verify destanation token input (check if token in merkle list or not)\r\n  // revert transaction if token not in list\r\n  function _verifyToken(\r\n    address _destination,\r\n    bytes32 [] memory proof,\r\n    uint256 [] memory positions)\r\n    private\r\n    view\r\n  {\r\n    bool status = merkleTreeWhiteList.verify(_destination, proof, positions);\r\n\r\n    if(!status)\r\n      revert(\"Dest not in white list\");\r\n  }\r\n\r\n // Facilitates trade with 1inch\r\n function _tradeViaOneInch(\r\n   address sourceToken,\r\n   address destinationToken,\r\n   uint256 sourceAmount,\r\n   bytes memory _additionalData\r\n   )\r\n   private\r\n   returns(uint256 destinationReceived)\r\n {\r\n    (uint256 flags,\r\n     uint256[] memory _distribution) = abi.decode(_additionalData, (uint256, uint256[]));\r\n\r\n    if(IERC20(sourceToken) == ETH_TOKEN_ADDRESS) {\r\n      oneInch.swap.value(sourceAmount)(\r\n        IERC20(sourceToken),\r\n        IERC20(destinationToken),\r\n        sourceAmount,\r\n        1,\r\n        _distribution,\r\n        flags\r\n        );\r\n    } else {\r\n      _transferFromSenderAndApproveTo(IERC20(sourceToken), sourceAmount, address(oneInch));\r\n      oneInch.swap(\r\n        IERC20(sourceToken),\r\n        IERC20(destinationToken),\r\n        sourceAmount,\r\n        1,\r\n        _distribution,\r\n        flags\r\n        );\r\n    }\r\n\r\n    destinationReceived = tokenBalance(IERC20(destinationToken));\r\n    tokensTypes.addNewTokenType(destinationToken, \"CRYPTOCURRENCY\");\r\n }\r\n\r\n\r\n // Facilitates trade with Bancor\r\n function _tradeViaBancorNewtork(\r\n   address sourceToken,\r\n   address destinationToken,\r\n   uint256 sourceAmount\r\n   )\r\n   private\r\n   returns(uint256 returnAmount)\r\n {\r\n    // get latest bancor contracts\r\n    BancorNetworkInterface bancorNetwork = BancorNetworkInterface(\r\n      bancorData.getBancorContractAddresByName(\"BancorNetwork\")\r\n    );\r\n\r\n    // Get Bancor tokens path\r\n    address[] memory path = bancorData.getBancorPathForAssets(IERC20(sourceToken), IERC20(destinationToken));\r\n\r\n    // Convert addresses to ERC20\r\n    IERC20[] memory pathInERC20 = new IERC20[](path.length);\r\n    for(uint i=0; i<path.length; i++){\r\n        pathInERC20[i] = IERC20(path[i]);\r\n    }\r\n\r\n    // trade\r\n    if (IERC20(sourceToken) == ETH_TOKEN_ADDRESS) {\r\n      returnAmount = bancorNetwork.convert.value(sourceAmount)(pathInERC20, sourceAmount, 1);\r\n    }\r\n    else {\r\n      _transferFromSenderAndApproveTo(IERC20(sourceToken), sourceAmount, address(bancorNetwork));\r\n      returnAmount = bancorNetwork.claimAndConvert(pathInERC20, sourceAmount, 1);\r\n    }\r\n\r\n    tokensTypes.addNewTokenType(destinationToken, \"BANCOR_ASSET\");\r\n }\r\n\r\n\r\n  /**\r\n  * @dev Transfers tokens to this contract and approves them to another address\r\n  *\r\n  * @param _source          Token to transfer and approve\r\n  * @param _sourceAmount    The amount to transfer and approve (in _source token)\r\n  * @param _to              Address to approve to\r\n  */\r\n  function _transferFromSenderAndApproveTo(IERC20 _source, uint256 _sourceAmount, address _to) private {\r\n    require(_source.transferFrom(msg.sender, address(this), _sourceAmount));\r\n    // reset previos approve because some tokens require allowance 0\r\n    _source.approve(_to, 0);\r\n    // approve\r\n    _source.approve(_to, _sourceAmount);\r\n  }\r\n\r\n\r\n\r\n  // VIEW Functions\r\n\r\n  function tokenBalance(IERC20 _token) private view returns (uint256) {\r\n    if (_token == ETH_TOKEN_ADDRESS)\r\n      return address(this).balance;\r\n    return _token.balanceOf(address(this));\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the ratio by amount of token _from in token _to by totekn type\r\n  *\r\n  * @param _from      Address of token we're converting from\r\n  * @param _to        Address of token we're getting the value in\r\n  * @param _amount    The amount of _from\r\n  *\r\n  * @return best price from 1inch for ERC20, or ratio for Uniswap and Bancor pools\r\n  */\r\n  function getValue(address _from, address _to, uint256 _amount)\r\n    public\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    if(_amount > 0){\r\n      // get asset type\r\n      bytes32 assetType = tokensTypes.getType(_from);\r\n\r\n      // get value by asset type\r\n      if(assetType == bytes32(\"CRYPTOCURRENCY\")){\r\n        return getValueViaDEXsAgregators(_from, _to, _amount);\r\n      }\r\n      else if (assetType == bytes32(\"BANCOR_ASSET\")){\r\n        return getValueViaBancor(_from, _to, _amount);\r\n      }\r\n      else if (assetType == bytes32(\"UNISWAP_POOL\")){\r\n        return getValueForUniswapPools(_from, _to, _amount);\r\n      }\r\n      else if (assetType == bytes32(\"UNISWAP_POOL_V2\")){\r\n        return getValueForUniswapV2Pools(_from, _to, _amount);\r\n      }\r\n      else if (assetType == bytes32(\"BALANCER_POOL\")){\r\n        return getValueForBalancerPool(_from, _to, _amount);\r\n      }\r\n      else{\r\n        // Unmarked type, try find value\r\n        return findValue(_from, _to, _amount);\r\n      }\r\n    }\r\n    else{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev find the ratio by amount of token _from in token _to trying all available methods\r\n  *\r\n  * @param _from      Address of token we're converting from\r\n  * @param _to        Address of token we're getting the value in\r\n  * @param _amount    The amount of _from\r\n  *\r\n  * @return best price from 1inch for ERC20, or ratio for Uniswap and Bancor pools\r\n  */\r\n  function findValue(address _from, address _to, uint256 _amount) private view returns (uint256) {\r\n     if(_amount > 0){\r\n       // Check at first value from defi portal, maybe there are new defi protocols\r\n       // If defiValue return 0 continue check from another sources\r\n       uint256 defiValue = defiPortal.getValue(_from, _to, _amount);\r\n       if(defiValue > 0)\r\n          return defiValue;\r\n\r\n       // If 1inch return 0, check from Bancor network for ensure this is not a Bancor pool\r\n       uint256 oneInchResult = getValueViaDEXsAgregators(_from, _to, _amount);\r\n       if(oneInchResult > 0)\r\n         return oneInchResult;\r\n\r\n       // If Bancor return 0, check from Balancer network for ensure this is not Balancer asset\r\n       uint256 bancorResult = getValueViaBancor(_from, _to, _amount);\r\n       if(bancorResult > 0)\r\n          return bancorResult;\r\n\r\n       // If Balancer return 0, check from Uniswap pools for ensure this is not Uniswap pool\r\n       uint256 balancerResult = getValueForBalancerPool(_from, _to, _amount);\r\n       if(balancerResult > 0)\r\n          return balancerResult;\r\n\r\n       // If Uniswap return 0, check from Uniswap version 2 pools for ensure this is not Uniswap V2 pool\r\n       uint256 uniswapResult = getValueForUniswapPools(_from, _to, _amount);\r\n       if(uniswapResult > 0)\r\n          return uniswapResult;\r\n\r\n       // Uniswap V2 pools return 0 if these is not a Uniswap V2 pool\r\n       return getValueForUniswapV2Pools(_from, _to, _amount);\r\n     }\r\n     else{\r\n       return 0;\r\n     }\r\n  }\r\n\r\n\r\n  // helper for get value via 1inch\r\n  // in this interface can be added more DEXs aggregators\r\n  function getValueViaDEXsAgregators(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n  public view returns (uint256){\r\n    // if direction the same, just return amount\r\n    if(_from == _to)\r\n       return _amount;\r\n\r\n    // try get value via 1inch\r\n    if(_amount > 0){\r\n      // try get value from 1inch aggregator\r\n      return getValueViaOneInch(_from, _to, _amount);\r\n    }\r\n    else{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n\r\n  // helper for get ratio between assets in 1inch aggregator\r\n  function getValueViaOneInch(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 value)\r\n  {\r\n    // if direction the same, just return amount\r\n    if(_from == _to)\r\n       return _amount;\r\n\r\n    // try get rate\r\n    try oneInch.getExpectedReturn(\r\n       IERC20(_from),\r\n       IERC20(_to),\r\n       _amount,\r\n       10,\r\n       oneInchFlags)\r\n      returns(uint256 returnAmount, uint256[] memory distribution)\r\n     {\r\n       value = returnAmount;\r\n     }\r\n     catch{\r\n       value = 0;\r\n     }\r\n  }\r\n\r\n\r\n  // helper for get ratio between assets in Bancor network\r\n  function getValueViaBancor(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 value)\r\n  {\r\n    // if direction the same, just return amount\r\n    if(_from == _to)\r\n       return _amount;\r\n\r\n    // try get rate\r\n    if(_amount > 0){\r\n      try poolPortal.getBancorRatio(_from, _to, _amount) returns(uint256 result){\r\n        value = result;\r\n      }catch{\r\n        value = 0;\r\n      }\r\n    }else{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n\r\n  // helper for get value via Balancer\r\n  function getValueForBalancerPool(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 value)\r\n  {\r\n    // get value for each pool share\r\n    try poolPortal.getBalancerConnectorsAmountByPoolAmount(_amount, _from)\r\n    returns(\r\n      address[] memory tokens,\r\n      uint256[] memory tokensAmount\r\n    )\r\n    {\r\n     // convert and sum value via DEX aggregator\r\n     for(uint i = 0; i < tokens.length; i++){\r\n       value += getValueViaDEXsAgregators(tokens[i], _to, tokensAmount[i]);\r\n     }\r\n    }\r\n    catch{\r\n      value = 0;\r\n    }\r\n  }\r\n\r\n\r\n  // helper for get ratio between pools in Uniswap network\r\n  // _from - should be uniswap pool address\r\n  function getValueForUniswapPools(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n  public\r\n  view\r\n  returns (uint256)\r\n  {\r\n    // get connectors amount\r\n    try poolPortal.getUniswapConnectorsAmountByPoolAmount(\r\n      _amount,\r\n      _from\r\n    ) returns (uint256 ethAmount, uint256 ercAmount)\r\n    {\r\n      // get ERC amount in ETH\r\n      address token = poolPortal.getTokenByUniswapExchange(_from);\r\n      uint256 ercAmountInETH = getValueViaDEXsAgregators(token, address(ETH_TOKEN_ADDRESS), ercAmount);\r\n      // sum ETH with ERC amount in ETH\r\n      uint256 totalETH = ethAmount.add(ercAmountInETH);\r\n\r\n      // if _to == ETH no need additional convert, just return ETH amount\r\n      if(_to == address(ETH_TOKEN_ADDRESS)){\r\n        return totalETH;\r\n      }\r\n      // convert ETH into _to asset via 1inch\r\n      else{\r\n        return getValueViaDEXsAgregators(address(ETH_TOKEN_ADDRESS), _to, totalETH);\r\n      }\r\n    }catch{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n\r\n  // helper for get ratio between pools in Uniswap network version 2\r\n  // _from - should be uniswap pool address\r\n  function getValueForUniswapV2Pools(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n  public\r\n  view\r\n  returns (uint256)\r\n  {\r\n    // get connectors amount by pool share\r\n    try poolPortal.getUniswapV2ConnectorsAmountByPoolAmount(\r\n      _amount,\r\n      _from\r\n    ) returns (\r\n      uint256 tokenAmountOne,\r\n      uint256 tokenAmountTwo,\r\n      address tokenAddressOne,\r\n      address tokenAddressTwo\r\n      )\r\n    {\r\n      // convert connectors amount via DEX aggregator\r\n      uint256 amountOne = getValueViaDEXsAgregators(tokenAddressOne, _to, tokenAmountOne);\r\n      uint256 amountTwo = getValueViaDEXsAgregators(tokenAddressTwo, _to, tokenAmountTwo);\r\n      // return value\r\n      return amountOne + amountTwo;\r\n    }catch{\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the total value of array of tokens and amounts\r\n  *\r\n  * @param _fromAddresses    Addresses of all the tokens we're converting from\r\n  * @param _amounts          The amounts of all the tokens\r\n  * @param _to               The token who's value we're converting to\r\n  *\r\n  * @return The total value of _fromAddresses and _amounts in terms of _to\r\n  */\r\n  function getTotalValue(\r\n    address[] calldata _fromAddresses,\r\n    uint256[] calldata _amounts,\r\n    address _to)\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint256 sum = 0;\r\n    for (uint256 i = 0; i < _fromAddresses.length; i++) {\r\n      sum = sum.add(getValue(_fromAddresses[i], _to, _amounts[i]));\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  // SETTERS Functions\r\n\r\n  /**\r\n  * @dev Allows the owner to disable/enable the buying of a token\r\n  *\r\n  * @param _token      Token address whos trading permission is to be set\r\n  * @param _enabled    New token permission\r\n  */\r\n  function setToken(address _token, bool _enabled) external onlyOwner {\r\n    disabledTokens[_token] = _enabled;\r\n  }\r\n\r\n  // owner can change oneInch\r\n  function setNewOneInch(address _oneInch) external onlyOwner {\r\n    oneInch = IOneSplitAudit(_oneInch);\r\n  }\r\n\r\n  // owner can set new pool portal\r\n  function setNewPoolPortal(address _poolPortal) external onlyOwner {\r\n    poolPortal = PoolPortalViewInterface(_poolPortal);\r\n  }\r\n\r\n  // owner can set new defi portal\r\n  function setNewDefiPortal(address _defiPortal) external onlyOwner {\r\n    defiPortal = DefiPortalInterface(_defiPortal);\r\n  }\r\n\r\n  // owner of portal can update 1 incg DEXs sources\r\n  function setOneInchFlags(uint256 _oneInchFlags) external onlyOwner {\r\n    oneInchFlags = _oneInchFlags;\r\n  }\r\n\r\n  // owner of portal can change getBancorData helper, for case if Bancor do some major updates\r\n  function setNewGetBancorData(address _bancorData) external onlyOwner {\r\n    bancorData = IGetBancorData(_bancorData);\r\n  }\r\n\r\n  // fallback payable function to receive ether from other contract addresses\r\n  fallback() external payable {}\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defiPortal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bancorData\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolPortal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oneInch\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokensTypes\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_merkleTreeWhiteList\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"exchangeType\",\"type\":\"uint8\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"bancorData\",\"outputs\":[{\"internalType\":\"contract IGetBancorData\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defiPortal\",\"outputs\":[{\"internalType\":\"contract DefiPortalInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_fromAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"getTotalValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueForBalancerPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueForUniswapPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueForUniswapV2Pools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueViaBancor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueViaDEXsAgregators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getValueViaOneInch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleTreeWhiteList\",\"outputs\":[{\"internalType\":\"contract IMerkleTreeTokensVerification\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneInch\",\"outputs\":[{\"internalType\":\"contract IOneSplitAudit\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPortal\",\"outputs\":[{\"internalType\":\"contract PoolPortalViewInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defiPortal\",\"type\":\"address\"}],\"name\":\"setNewDefiPortal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bancorData\",\"type\":\"address\"}],\"name\":\"setNewGetBancorData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oneInch\",\"type\":\"address\"}],\"name\":\"setNewOneInch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolPortal\",\"type\":\"address\"}],\"name\":\"setNewPoolPortal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_oneInchFlags\",\"type\":\"uint256\"}],\"name\":\"setOneInchFlags\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensTypes\",\"outputs\":[{\"internalType\":\"contract ITokensTypeStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_positions\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_additionalData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_verifyDestanation\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ExchangePortal","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c8a2ba3e9ce03f78551d7de5706cc275d4d3130f0000000000000000000000003ae392a4c6a99fcb991e208f9d74618fff5138340000000000000000000000006f553184c04a4ad0b3551a4ff60fb73bb6e9040800000000000000000000000050fda034c0ce7a8f7efdaebda7aa7ca21cc1267e00000000000000000000000037ff4bc9a425f37d3af95662c9d88a88d05f3417000000000000000000000000992f6c414a6da6a7470dfb9d61efc6639e9fbb0e","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://85d58cc2f56c5921b77c36923f7a6b6ae976736cda1a83357e9c35eaa4ea60ea"}]}