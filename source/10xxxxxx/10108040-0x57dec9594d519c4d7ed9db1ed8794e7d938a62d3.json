{"status":"1","message":"OK","result":[{"SourceCode":"// hevm: flattened sources of src/LoihiExchange.sol\r\npragma solidity >0.4.13 >=0.4.23 >=0.5.0 <0.6.0 >=0.5.6 <0.6.0 >=0.5.12 <0.6.0 >=0.5.15 <0.6.0;\r\n\r\n////// lib/openzeppelin-contracts/src/contracts/token/ERC20/IERC20.sol\r\n/* pragma solidity ^0.5.0; */\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n////// src/LoihiDelegators.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.5.15; */\r\n\r\ncontract LoihiDelegators {\r\n\r\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n\r\n    function staticTo(address callee, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = callee.staticcall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n\r\n    function dViewRawAmount (address addr, uint256 amount) internal view returns (uint256) {\r\n        bytes memory result = staticTo(addr, abi.encodeWithSignature(\"viewRawAmount(uint256)\", amount)); // encoded selector of \"getNumeraireAmount(uint256\");\r\n        return abi.decode(result, (uint256));\r\n    }\r\n\r\n    function dViewNumeraireAmount (address addr, uint256 amount) internal view returns (uint256) {\r\n        bytes memory result = staticTo(addr, abi.encodeWithSignature(\"viewNumeraireAmount(uint256)\", amount)); // encoded selector of \"getNumeraireAmount(uint256\");\r\n        return abi.decode(result, (uint256));\r\n    }\r\n\r\n    function dViewNumeraireBalance (address addr, address _this) internal view returns (uint256) {\r\n        bytes memory result = staticTo(addr, abi.encodeWithSignature(\"viewNumeraireBalance(address)\", _this)); // encoded selector of \"getNumeraireAmount(uint256\");\r\n        return abi.decode(result, (uint256));\r\n    }\r\n\r\n    function dIntakeRaw (address addr, uint256 amount) internal returns (uint256) {\r\n        bytes memory result = delegateTo(addr, abi.encodeWithSignature(\"intakeRaw(uint256)\", amount)); // encoded selector of \"intakeRaw(uint256)\";\r\n        return abi.decode(result, (uint256));\r\n    }\r\n\r\n    function dIntakeNumeraire (address addr, uint256 amount) internal returns (uint256) {\r\n        bytes memory result = delegateTo(addr, abi.encodeWithSignature(\"intakeNumeraire(uint256)\", amount)); // encoded selector of \"intakeNumeraire(uint256)\";\r\n        return abi.decode(result, (uint256));\r\n    }\r\n\r\n    function dOutputRaw (address addr, address dst, uint256 amount) internal returns (uint256) {\r\n        bytes memory result = delegateTo(addr, abi.encodeWithSignature(\"outputRaw(address,uint256)\", dst, amount)); // encoded selector of \"outputRaw(address,uint256)\";\r\n        return abi.decode(result, (uint256));\r\n    }\r\n\r\n    function dOutputNumeraire (address addr, address dst, uint256 amount) internal returns (uint256) {\r\n        bytes memory result = delegateTo(addr, abi.encodeWithSignature(\"outputNumeraire(address,uint256)\", dst, amount)); // encoded selector of \"outputNumeraire(address,uint256)\";\r\n        return abi.decode(result, (uint256));\r\n    }\r\n}\r\n////// src/LoihiMath.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >0.4.13; */\r\n\r\ncontract LoihiMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"loihi-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"loihi-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"loihi-math-mul-overflow\");\r\n    }\r\n\r\n    uint constant OCTOPUS = 10 ** 18;\r\n\r\n    function omul(uint x, uint y) internal pure returns (uint z) {\r\n        z = ((x*y) + (OCTOPUS/2)) / OCTOPUS;\r\n    }\r\n\r\n    function odiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = ((x*OCTOPUS) + (y/2)) / y;\r\n    }\r\n\r\n    function somul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), OCTOPUS / 2) / OCTOPUS;\r\n    }\r\n\r\n    function sodiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, OCTOPUS), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\n////// src/interfaces/IAToken.sol\r\n/* pragma solidity ^0.5.15; */\r\n\r\ninterface IAToken {\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function redirectInterestStream(address _to) external;\r\n    function redirectInterestStreamOf(address _from, address _to) external;\r\n    function allowInterestRedirectionTo(address _to) external;\r\n    function redeem(uint256 _amount) external;\r\n    function balanceOf(address _user) external view returns(uint256);\r\n    function principalBalanceOf(address _user) external view returns(uint256);\r\n    function totalSupply() external view returns(uint256);\r\n    function isTransferAllowed(address _user, uint256 _amount) external view returns (bool);\r\n    function getUserIndex(address _user) external view returns(uint256);\r\n    function getInterestRedirectionAddress(address _user) external view returns(address);\r\n    function getRedirectedBalance(address _user) external view returns(uint256);\r\n    function decimals () external view returns (uint256);\r\n    function deposit(uint256 _amount) external;\r\n\r\n}\r\n////// src/interfaces/ICToken.sol\r\n/* pragma solidity ^0.5.15; */\r\n\r\ninterface ICToken {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function balanceOfUnderlying(address account) external returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Mint(address minter, uint mintAmount, uint mintTokens);\r\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\r\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\r\n\r\n\r\n}\r\n////// src/interfaces/IChai.sol\r\n/* pragma solidity ^0.5.12; */\r\n\r\ninterface IChai {\r\n    function draw(address src, uint wad) external;\r\n    function exit(address src, uint wad) external;\r\n    function join(address dst, uint wad) external;\r\n    function dai(address usr) external returns (uint wad);\r\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\r\n    function approve(address usr, uint wad) external returns (bool);\r\n    function move(address src, address dst, uint wad) external returns (bool);\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n    function transferFrom(address src, address dst, uint wad) external;\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n////// src/interfaces/IPot.sol\r\n/* pragma solidity ^0.5.15; */\r\n\r\ninterface IPot {\r\n    function rho () external returns (uint256);\r\n    function drip () external returns (uint256);\r\n    function chi () external view returns (uint256);\r\n}\r\n////// src/LoihiRoot.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.5.15; */\r\n\r\n\r\n/* import \"./LoihiMath.sol\"; */\r\n/* import \"./interfaces/ICToken.sol\"; */\r\n/* import \"./interfaces/IAToken.sol\"; */\r\n/* import \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\"; */\r\n/* import \"./interfaces/IChai.sol\"; */\r\n/* import \"./interfaces/IPot.sol\"; */\r\n\r\ncontract LoihiRoot is LoihiMath {\r\n\r\n    string  public constant name = \"Shells\";\r\n    string  public constant symbol = \"SHL\";\r\n    uint8   public constant decimals = 18;\r\n\r\n    mapping (address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowances;\r\n    uint256 public totalSupply;\r\n\r\n    struct Flavor { address adapter; address reserve; }\r\n    mapping(address => Flavor) public flavors;\r\n\r\n    address[] public reserves;\r\n    address[] public numeraires;\r\n    uint256[] public weights;\r\n\r\n    address public owner;\r\n    bool internal notEntered = true;\r\n    bool public frozen = false;\r\n\r\n    uint256 public alpha;\r\n    uint256 public beta;\r\n    uint256 public delta;\r\n    uint256 public epsilon;\r\n    uint256 public lambda;\r\n    uint256 internal omega;\r\n\r\n    bytes4 constant internal ERC20ID = 0x36372b07;\r\n    bytes4 constant internal ERC165ID = 0x01ffc9a7;\r\n\r\n    // mainnet\r\n    address constant exchange = 0xfb8443545771E2BB15bB7cAdDa43A16a1Ab69c0B;\r\n    address constant liquidity = 0xA3f4A860eFa4a60279E6E50f2169FDD080aAb655;\r\n    address constant views = 0x81dBd2ec823cB2691f34c7b5391c9439ec5c80E3;\r\n    address constant erc20 = 0x7DB32869056647532f80f482E5bB1fcb311493cD;\r\n\r\n    // kovan\r\n    // address constant exchange = 0xcF90c859b5cD63bfac65A34016ab6da442C74433;\r\n    // address constant liquidity = 0x1F2d802b10bc8226aEf4433E02D60876446AFB86;\r\n    // address constant views = 0xfA923BC1D005dbF1A3C9E377ac02Ba65D3994054;\r\n    // address constant erc20 = 0x5194f53237beF18741A0dD6B0D0049CBA581C5FD;\r\n\r\n    event ShellsMinted(address indexed minter, uint256 amount, address[] indexed coins, uint256[] amounts);\r\n    event ShellsBurned(address indexed burner, uint256 amount, address[] indexed coins, uint256[] amounts);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Trade(address indexed trader, address indexed origin, address indexed target, uint256 originAmount, uint256 targetAmount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(notEntered, \"re-entered\");\r\n        notEntered = false;\r\n        _;\r\n        notEntered = true;\r\n    }\r\n\r\n    modifier notFrozen () {\r\n        require(!frozen, \"swaps, selective deposits and selective withdraws have been frozen.\");\r\n        _;\r\n    }\r\n\r\n}\r\n////// src/LoihiExchange.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.5.15; */\r\n\r\n/* import \"./LoihiRoot.sol\"; */\r\n/* import \"./LoihiDelegators.sol\"; */\r\n\r\ncontract LoihiExchange is LoihiRoot, LoihiDelegators {\r\n\r\n    /// @dev executes the origin trade. refer to Loihi.bin swapByOrigin and transferByOrigin for detailed explanation of paramters\r\n    /// @return tAmt_ the target amount\r\n    function executeOriginTrade (uint256 _deadline, uint256 _minTAmt, address _recipient, address _origin, address _target, uint256 _oAmt) external returns (uint256) {\r\n        require(_deadline >= now, \"deadline has passed for this trade\");\r\n\r\n        Flavor memory _o = flavors[_origin];\r\n        Flavor memory _t = flavors[_target];\r\n\r\n        require(_o.adapter != address(0), \"origin flavor not supported\");\r\n        require(_t.adapter != address(0), \"target flavor not supported\");\r\n\r\n        if (_o.reserve == _t.reserve) {\r\n            uint256 _oNAmt = dIntakeRaw(_o.adapter, _oAmt);\r\n            uint256 tAmt_ = dOutputNumeraire(_t.adapter, _recipient, _oNAmt);\r\n            emit Trade(msg.sender, _origin, _target, _oAmt, tAmt_);\r\n            return tAmt_;\r\n        }\r\n\r\n        uint256[] memory _weights = weights;\r\n        address[] memory _reserves = reserves;\r\n\r\n        (uint256[] memory _balances, uint256 _grossLiq) = getBalancesAndGrossLiq(_reserves);\r\n\r\n        uint256 _oNAmt = dViewNumeraireAmount(_o.adapter, _oAmt);\r\n        uint256 _tNAmt = getTargetAmount(_grossLiq, _o.reserve, _t.reserve, _oNAmt, _balances, _weights, _reserves);\r\n\r\n        require(dViewRawAmount(_t.adapter, _tNAmt) >= _minTAmt, \"target amount is less than min target amount\");\r\n\r\n        dIntakeRaw(_o.adapter, _oAmt);\r\n        uint256 tAmt_ = dOutputNumeraire(_t.adapter, _recipient, _tNAmt);\r\n        emit Trade(msg.sender, _origin, _target, _oAmt, tAmt_);\r\n\r\n        return tAmt_;\r\n\r\n    }\r\n\r\n    /// @dev executes the target trade. refer to Loihi.bin swapByTarget and transferByTarget for detailed explanation of parameters\r\n    /// @return oAmt_ origin amount\r\n    function executeTargetTrade (uint256 _deadline, address _origin, address _target, uint256 _maxOAmt, uint256 _tAmt, address _recipient) external returns (uint256) {\r\n        require(_deadline >= now, \"deadline has passed for this trade\");\r\n\r\n        Flavor memory _o = flavors[_origin];\r\n        Flavor memory _t = flavors[_target];\r\n\r\n        require(_o.adapter != address(0), \"origin flavor not supported\");\r\n        require(_t.adapter != address(0), \"target flavor not supported\");\r\n\r\n        if (_o.reserve == _t.reserve) {\r\n            uint256 _tNAmt = dOutputRaw(_t.adapter, _recipient, _tAmt);\r\n            uint256 oAmt_ = dIntakeNumeraire(_o.adapter, _tNAmt);\r\n            emit Trade(msg.sender, _origin, _target, oAmt_, _tAmt);\r\n            return oAmt_;\r\n        }\r\n\r\n        uint256 _tNAmt;\r\n        uint256 _oNAmt;\r\n\r\n        {\r\n            uint256[] memory _weights = weights;\r\n            address[] memory _reserves = reserves;\r\n\r\n            (uint256[] memory _balances, uint256 _grossLiq) = getBalancesAndGrossLiq(_reserves);\r\n\r\n            _tNAmt = dViewNumeraireAmount(_t.adapter, _tAmt);\r\n            _oNAmt = getOriginAmount(_grossLiq, _o.reserve, _t.reserve, _tNAmt, _balances, _weights, _reserves);\r\n        }\r\n\r\n        require(dViewRawAmount(_o.adapter, _oNAmt) <= _maxOAmt, \"origin amount is greater than max origin amount\");\r\n\r\n        dOutputRaw(_t.adapter, _recipient, _tAmt);\r\n        uint256 oAmt_ = dIntakeNumeraire(_o.adapter, _oNAmt);\r\n\r\n        emit Trade(msg.sender, _origin, _target, oAmt_, _tAmt);\r\n\r\n        return oAmt_;\r\n\r\n    }\r\n\r\n    /// @dev this function figures out the origin amount\r\n    /// @return tNAmt_ target amount\r\n    function getTargetAmount (uint256 _grossLiq, address _oRsrv, address _tRsrv, uint256 _oNAmt, uint256[] memory _balances, uint256[] memory _weights, address[] memory _reserves) internal returns (uint256 tNAmt_) {\r\n\r\n        tNAmt_ = somul(_oNAmt, OCTOPUS-epsilon);\r\n        \r\n        uint256 _oNFAmt = tNAmt_;\r\n        uint256 _psi;\r\n        uint256 _nGLiq;\r\n        uint256 _omega = omega; // 1787 gas savings\r\n        uint256 _lambda = lambda;\r\n        for (uint j = 0; j < 10; j++) {\r\n\r\n            _psi = 0;\r\n            _nGLiq = sub(add(_grossLiq, _oNAmt), tNAmt_);\r\n\r\n            for (uint i = 0; i < _reserves.length; i++) {\r\n                address _rsrv = _reserves[i];\r\n                if (_rsrv == _oRsrv) {\r\n                    uint256 _nBal = add(_balances[i], _oNAmt);\r\n                    _psi += makeFee(_nBal, somul(_nGLiq, _weights[i]));\r\n                } else if (_rsrv == _tRsrv) {\r\n                    uint256 _nBal = sub(_balances[i], tNAmt_);\r\n                    _psi += makeFee(_nBal, somul(_nGLiq, _weights[i]));\r\n                } else _psi += makeFee(_balances[i], somul(_nGLiq, _weights[i]));\r\n            }\r\n\r\n            if (_omega < _psi) { // 32.7k gas savings against 10^13/10^14 vs 10^10\r\n                if ((tNAmt_ = sub(add(_oNFAmt,  _omega), _psi)) / 100000000000000 == tNAmt_ / 100000000000000) break;\r\n            } else {\r\n                if ((tNAmt_ = add(_oNFAmt, somul(_lambda, sub(_omega, _psi)))) / 100000000000000 == tNAmt_ / 100000000000000) break;\r\n            }\r\n        }\r\n\r\n        omega = _psi;\r\n\r\n        {\r\n            uint256 _alpha = alpha; // 400-800 gas savings\r\n            for (uint i = 0; i < _balances.length; i++) {\r\n                uint256 _nIdeal = somul(_nGLiq, _weights[i]);\r\n                if (_reserves[i] == _oRsrv) {\r\n                    require(add(_balances[i], _oNAmt) < somul(_nIdeal, OCTOPUS + _alpha), \"origin halt check\");\r\n                } else if (_reserves[i] == _tRsrv) {\r\n                    require(sub(_balances[i], tNAmt_) > somul(_nIdeal, OCTOPUS - _alpha), \"target halt check\");\r\n                } else if (_balances[i] < _nIdeal) {\r\n                    require(_balances[i] > somul(_nIdeal, OCTOPUS - _alpha), \"lower-halt-check\");\r\n                } else {\r\n                    require(_balances[i] < somul(_nIdeal, OCTOPUS + _alpha), \"upper-halt-check\");\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        tNAmt_ = somul(tNAmt_, OCTOPUS-epsilon);\r\n\r\n    }\r\n\r\n    /// @dev this function figures out the origin amount\r\n    /// @return oNAmt_ origin amount\r\n    function getOriginAmount (uint256 _grossLiq, address _oRsrv, address _tRsrv, uint256 _tNAmt, uint256[] memory _balances, uint256[] memory _weights, address[] memory _reserves) internal returns (uint256 oNAmt_) {\r\n\r\n        oNAmt_ = somul(_tNAmt, OCTOPUS+epsilon);\r\n\r\n        uint256 _tNFAmt = oNAmt_;\r\n        uint256 _psi;\r\n        uint256 _nGLiq;\r\n        uint256 _omega = omega;\r\n        uint256 _lambda = lambda;\r\n        for (uint j = 0; j < 10; j++) {\r\n\r\n            _psi = 0;\r\n            _nGLiq = sub(add(_grossLiq, oNAmt_), _tNAmt);\r\n\r\n            for (uint i = 0; i < _reserves.length; i++) {\r\n                address _rsrv = _reserves[i];\r\n                if (_rsrv == _oRsrv) {\r\n                    uint256 _nBal = add(_balances[i], oNAmt_);\r\n                    _psi += makeFee(_nBal, somul(_nGLiq, _weights[i]));\r\n                }\r\n                else if (_rsrv == _tRsrv) {\r\n                    uint256 _nBal = sub(_balances[i], _tNAmt);\r\n                    _psi += makeFee(_nBal, somul(_nGLiq, _weights[i]));\r\n                }\r\n                else {\r\n                    _psi += makeFee(_balances[i], somul(_nGLiq, _weights[i]));\r\n                }\r\n            }\r\n\r\n            if (_omega < _psi) {\r\n                if ((oNAmt_ = sub(add(_tNFAmt, _psi), _omega)) / 100000000000000 == oNAmt_ / 100000000000000) break;\r\n            } else {\r\n                if ((oNAmt_ = sub(_tNFAmt, somul(_lambda, sub(_omega, _psi)))) / 100000000000000 == oNAmt_ / 100000000000000) break;\r\n            }\r\n        }\r\n\r\n        omega = _psi;\r\n\r\n        uint256 _alpha = alpha;\r\n        for (uint i = 0; i < _balances.length; i++) {\r\n\r\n            uint256 _nIdeal = somul(_nGLiq, _weights[i]);\r\n            if (_reserves[i] == _oRsrv) {\r\n                require(add(_balances[i], oNAmt_) < somul(_nIdeal, OCTOPUS + _alpha), \"origin-halt-check\");\r\n            } else if (_reserves[i] == _tRsrv) {\r\n                require(sub(_balances[i], _tNAmt) > somul(_nIdeal, OCTOPUS - _alpha), \"target-halt-check\");\r\n            } else if (_balances[i] > _nIdeal) {\r\n                require(_balances[i] < somul(_nIdeal, OCTOPUS + _alpha), \"upper-halt-check\");\r\n            } else {\r\n                require(_balances[i] > somul(_nIdeal, OCTOPUS - _alpha), \"lower-halt-check\");\r\n            }\r\n\r\n        }\r\n\r\n        oNAmt_ = somul(oNAmt_, OCTOPUS+epsilon);\r\n\r\n    }\r\n\r\n    /// @notice this function makes our fees!\r\n    /// @return fee_ the fee.\r\n    function makeFee (uint256 _bal, uint256 _ideal) internal view returns (uint256 fee_) {\r\n\r\n        uint256 _threshold;\r\n        uint256 _beta = beta;\r\n        uint256 _delta = delta;\r\n        if (_bal < (_threshold = somul(_ideal, OCTOPUS-_beta))) {\r\n            fee_ = sodiv(_delta, _ideal);\r\n            fee_ = somul(fee_, (_threshold = sub(_threshold, _bal)));\r\n            fee_ = somul(fee_, _threshold);\r\n        } else if (_bal > (_threshold = somul(_ideal, OCTOPUS+_beta))) {\r\n            fee_ = sodiv(_delta, _ideal);\r\n            fee_ = somul(fee_, (_threshold = sub(_bal, _threshold)));\r\n            fee_ = somul(fee_, _threshold);\r\n        } else fee_ = 0;\r\n\r\n    }\r\n\r\n    function getBalancesAndGrossLiq (address[] memory _reserves) internal returns (uint256[] memory, uint256 grossLiq_) {\r\n        uint256[] memory balances_ = new uint256[](_reserves.length);\r\n        for (uint i = 0; i < _reserves.length; i++) {\r\n            address _rsrv = _reserves[i];\r\n            balances_[i] = dViewNumeraireBalance(_rsrv, address(this));\r\n            grossLiq_ = add(grossLiq_, balances_[i]);\r\n        }\r\n        return (balances_, grossLiq_);\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"coins\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ShellsBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"coins\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ShellsMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetAmount\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"alpha\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epsilon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTAmt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_oAmt\",\"type\":\"uint256\"}],\"name\":\"executeOriginTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxOAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tAmt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"executeTargetTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"flavors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lambda\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numeraires\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserves\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"weights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LoihiExchange","CompilerVersion":"v0.5.15+commit.6a57276f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8a2c9bd1dd2c8db2de7cc9fcc2faffd1853958f068d2c5328f3cd193e24a8ce5"}]}