{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\ninterface Pool1  {\r\n    function changeDependentContractAddress() external;\r\n    function makeCoverBegin(\r\n        address smartCAdd,\r\n        bytes4 coverCurr,\r\n        uint[] calldata coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n        payable;\r\n    function makeCoverUsingCA(\r\n        address smartCAdd,\r\n        bytes4 coverCurr,\r\n        uint[] calldata coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external;\r\n    function getWei(uint amount) external view returns(uint);\r\n    function sellNXMTokens(uint _amount) external  returns (bool);\r\n}\r\n\r\ncontract INXMMaster {\r\n    address public tokenAddress;\r\n    address public owner;\r\n    uint public pauseTime;\r\n    function masterInitialized() external view returns(bool);\r\n    function isPause() external view returns(bool check);\r\n    function isMember(address _add) external view returns(bool);\r\n    function getLatestAddress(bytes2 _contractName) external view returns(address payable contractAddress);\r\n}\r\n\r\ninterface DSValue {\r\n    function peek() external view returns (bytes32, bool);\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ninterface PoolData {\r\n\r\n    struct ApiId {\r\n        bytes4 typeOf;\r\n        bytes4 currency;\r\n        uint id;\r\n        uint64 dateAdd;\r\n        uint64 dateUpd;\r\n    }\r\n\r\n    struct CurrencyAssets {\r\n        address currAddress;\r\n        uint baseMin;\r\n        uint varMin;\r\n    }\r\n\r\n    struct InvestmentAssets {\r\n        address currAddress;\r\n        bool status;\r\n        uint64 minHoldingPercX100;\r\n        uint64 maxHoldingPercX100;\r\n        uint8 decimals;\r\n    }\r\n\r\n    struct IARankDetails {\r\n        bytes4 maxIACurr;\r\n        uint64 maxRate;\r\n        bytes4 minIACurr;\r\n        uint64 minRate;\r\n    }\r\n\r\n    struct McrData {\r\n        uint mcrPercx100;\r\n        uint mcrEther;\r\n        uint vFull; //Pool funds\r\n        uint64 date;\r\n    }\r\n\r\n    function setCapReached(uint val) external;\r\n    function getInvestmentAssetDecimals(bytes4 curr) external returns(uint8 decimal);\r\n    function getCurrencyAssetAddress(bytes4 curr) external view returns(address);\r\n    function getInvestmentAssetAddress(bytes4 curr) external view returns(address);\r\n    function getInvestmentAssetStatus(bytes4 curr) external view returns(bool status);\r\n\r\n}\r\n\r\ninterface QuotationData {\r\n\r\n    enum HCIDStatus { NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover }\r\n    enum CoverStatus { Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested }\r\n\r\n    struct Cover {\r\n        address payable memberAddress;\r\n        bytes4 currencyCode;\r\n        uint sumAssured;\r\n        uint16 coverPeriod;\r\n        uint validUntil;\r\n        address scAddress;\r\n        uint premiumNXM;\r\n    }\r\n\r\n    struct HoldCover {\r\n        uint holdCoverId;\r\n        address payable userAddress;\r\n        address scAddress;\r\n        bytes4 coverCurr;\r\n        uint[] coverDetails;\r\n        uint16 coverPeriod;\r\n    }\r\n\r\n    function getCoverLength() external returns(uint len);\r\n    function getAuthQuoteEngine() external returns(address _add);\r\n    function getAllCoversOfUser(address _add) external returns(uint[] memory allCover);\r\n    function getUserCoverLength(address _add) external returns(uint len);\r\n    function getCoverStatusNo(uint _cid) external returns(uint8);\r\n    function getCoverPeriod(uint _cid) external returns(uint32 cp);\r\n    function getCoverSumAssured(uint _cid) external returns(uint sa);\r\n    function getCurrencyOfCover(uint _cid) external returns(bytes4 curr);\r\n    function getValidityOfCover(uint _cid) external returns(uint date);\r\n    function getscAddressOfCover(uint _cid) external view returns(uint, address);\r\n    function getCoverMemberAddress(uint _cid) external returns(address payable _add);\r\n    function getCoverPremiumNXM(uint _cid) external returns(uint _premiumNXM);\r\n    function getCoverDetailsByCoverID1(\r\n        uint _cid\r\n    )\r\n        external\r\n        returns (\r\n            uint cid,\r\n            address _memberAddress,\r\n            address _scAddress,\r\n            bytes4 _currencyCode,\r\n            uint _sumAssured,\r\n            uint premiumNXM\r\n        );\r\n    function getCoverDetailsByCoverID2(\r\n        uint _cid\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint cid,\r\n            uint8 status,\r\n            uint sumAssured,\r\n            uint16 coverPeriod,\r\n            uint validUntil\r\n        );\r\n    function getHoldedCoverDetailsByID1(\r\n        uint _hcid\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint hcid,\r\n            address scAddress,\r\n            bytes4 coverCurr,\r\n            uint16 coverPeriod\r\n        );\r\n    function getUserHoldedCoverLength(address _add) external returns (uint);\r\n    function getUserHoldedCoverByIndex(address _add, uint index) external returns (uint);\r\n    function getHoldedCoverDetailsByID2(\r\n        uint _hcid\r\n    )\r\n        external\r\n        returns (\r\n            uint hcid,\r\n            address payable memberAddress,\r\n            uint[] memory coverDetails\r\n        );\r\n    function getTotalSumAssuredSC(address _add, bytes4 _curr) external returns(uint amount);\r\n\r\n}\r\n\r\ncontract TokenData {\r\n    function lockTokenTimeAfterCoverExp() external returns (uint);\r\n}\r\n\r\ninterface Claims {\r\n    function getClaimbyIndex(uint _claimId) external view returns (\r\n        uint claimId,\r\n        uint status,\r\n        int8 finalVerdict,\r\n        address claimOwner,\r\n        uint coverId\r\n    );\r\n    function submitClaim(uint coverId) external;\r\n}\r\n\r\ncontract ClaimsData {\r\n    function actualClaimLength() external view returns(uint);\r\n}\r\n\r\ninterface NXMToken {\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n}\r\n\r\ninterface MemberRoles {\r\n    function switchMembership(address) external;\r\n}\r\n\r\ninterface yInsure {\r\n    \r\n    function tokens(uint) external view returns (uint expirationTimestamp,\r\n        bytes4 coverCurrency,\r\n        uint coverAmount,\r\n        uint coverPrice,\r\n        uint coverPriceNXM,\r\n        uint expireTime,\r\n        uint generationTime,\r\n        uint coverId,\r\n        bool claimInProgress,\r\n        uint claimId);\r\n}\r\n\r\ncontract yInsureView  {\r\n    \r\n    event ClaimRedeemed (\r\n        address receiver,\r\n        uint value,\r\n        bytes4 currency\r\n    );\r\n    \r\n    using SafeMath for uint;\r\n\r\n    INXMMaster constant public nxMaster = INXMMaster(0x01BFd82675DBCc7762C84019cA518e701C0cD07e);\r\n    yInsure constant public yIns = yInsure(0x181Aea6936B407514ebFC0754A37704eB8d98F91);\r\n    \r\n    enum CoverStatus {\r\n        Active,\r\n        ClaimAccepted,\r\n        ClaimDenied,\r\n        CoverExpired,\r\n        ClaimSubmitted,\r\n        Requested\r\n    }\r\n    \r\n    enum ClaimStatus {\r\n        PendingClaimAssessorVote, // 0\r\n        PendingClaimAssessorVoteDenied, // 1\r\n        PendingClaimAssessorVoteThresholdNotReachedAccept, // 2\r\n        PendingClaimAssessorVoteThresholdNotReachedDeny, // 3\r\n        PendingClaimAssessorConsensusNotReachedAccept, // 4\r\n        PendingClaimAssessorConsensusNotReachedDeny, // 5\r\n        FinalClaimAssessorVoteDenied, // 6\r\n        FinalClaimAssessorVoteAccepted, // 7\r\n        FinalClaimAssessorVoteDeniedMVAccepted, // 8\r\n        FinalClaimAssessorVoteDeniedMVDenied, // 9\r\n        FinalClaimAssessorVotAcceptedMVNoDecision, // 10\r\n        FinalClaimAssessorVoteDeniedMVNoDecision, // 11\r\n        ClaimAcceptedPayoutPending, // 12\r\n        ClaimAcceptedNoPayout, // 13\r\n        ClaimAcceptedPayoutDone // 14\r\n    }\r\n    \r\n    function getMemberRoles() external view returns (address) {\r\n        return nxMaster.getLatestAddress(\"MR\");\r\n    }\r\n    \r\n    function getCover(\r\n        uint coverId\r\n    ) public view returns (\r\n        uint cid,\r\n        uint8 status,\r\n        uint sumAssured,\r\n        uint16 coverPeriod,\r\n        uint validUntil\r\n    ) {\r\n        QuotationData quotationData = QuotationData(nxMaster.getLatestAddress(\"QD\"));\r\n        return quotationData.getCoverDetailsByCoverID2(coverId);\r\n    }\r\n    \r\n    function getscAddressOfCover(\r\n        uint _coverId\r\n    ) public view returns (\r\n        uint coverId,\r\n        address coverAddress\r\n    ) {\r\n        QuotationData quotationData = QuotationData(nxMaster.getLatestAddress(\"QD\"));\r\n        return quotationData.getscAddressOfCover(_coverId);\r\n    }\r\n    \r\n    function getCurrencyAssetAddress(bytes4 currency) external view returns (address) {\r\n        PoolData pd = PoolData(nxMaster.getLatestAddress(\"PD\"));\r\n        return pd.getCurrencyAssetAddress(currency);\r\n    }\r\n    \r\n    function getLockTokenTimeAfterCoverExpiry() external returns (uint) {\r\n        TokenData tokenData = TokenData(nxMaster.getLatestAddress(\"TD\"));\r\n        return tokenData.lockTokenTimeAfterCoverExp();\r\n    }\r\n    \r\n    function getTokenAddress() external view returns (address) {\r\n        return nxMaster.tokenAddress();\r\n    }\r\n    \r\n    function payoutIsCompleted(uint claimId) public view returns (bool) {\r\n        uint256 status;\r\n        Claims claims = Claims(nxMaster.getLatestAddress(\"CL\"));\r\n        (, status, , , ) = claims.getClaimbyIndex(claimId);\r\n        return status == uint(ClaimStatus.FinalClaimAssessorVoteAccepted)\r\n            || status == uint(ClaimStatus.ClaimAcceptedPayoutDone);\r\n    }\r\n    \r\n    uint public distributorFeePercentage;\r\n    uint256 internal issuedTokensCount;\r\n    \r\n    struct Token {\r\n        address coverContract;\r\n        uint expirationTimestamp;\r\n        bytes4 coverCurrency;\r\n        uint coverAmount;\r\n        uint expireTime;\r\n        uint generationTime;\r\n        uint coverId;\r\n        bool claimInProgress;\r\n        uint claimId;\r\n        uint8 coverStatus;\r\n        bool payoutCompleted;\r\n    }\r\n    \r\n    function getToken(uint tokenId) public view returns (Token memory) {\r\n        Token memory tkn;\r\n        (\r\n            tkn.expirationTimestamp, \r\n            tkn.coverCurrency, \r\n            tkn.coverAmount, \r\n            , \r\n            , \r\n            tkn.expireTime, \r\n            tkn.generationTime, \r\n            tkn.coverId, \r\n            tkn.claimInProgress, \r\n            tkn.claimId) = yIns.tokens(tokenId);\r\n    }\r\n    \r\n    function tokens(uint tokenId) public view returns (Token memory) {\r\n        Token memory tkn = getToken(tokenId);\r\n        (, tkn.coverContract) = getscAddressOfCover(tkn.coverId);\r\n        (, tkn.coverStatus, , , ) = getCover(tkn.coverId);\r\n        tkn.payoutCompleted = payoutIsCompleted(tkn.claimId);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"currency\",\"type\":\"bytes4\"}],\"name\":\"ClaimRedeemed\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributorFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"getCover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cid\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sumAssured\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"currency\",\"type\":\"bytes4\"}],\"name\":\"getCurrencyAssetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getLockTokenTimeAfterCoverExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMemberRoles\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"coverContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"coverCurrency\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"coverAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimInProgress\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"coverStatus\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"payoutCompleted\",\"type\":\"bool\"}],\"internalType\":\"struct yInsureView.Token\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coverId\",\"type\":\"uint256\"}],\"name\":\"getscAddressOfCover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coverAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nxMaster\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"}],\"name\":\"payoutIsCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"coverContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"coverCurrency\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"coverAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimInProgress\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"coverStatus\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"payoutCompleted\",\"type\":\"bool\"}],\"internalType\":\"struct yInsureView.Token\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"yIns\",\"outputs\":[{\"internalType\":\"contract yInsure\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"yInsureView","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://60ed386945cb58dedeca9c05123617860d1405dc624ccfd71ab73538345e5c9b"}]}