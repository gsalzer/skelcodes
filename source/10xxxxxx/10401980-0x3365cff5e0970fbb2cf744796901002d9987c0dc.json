{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\r\n\r\n\r\ncontract Ownable {\r\n  address payable public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  \r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  \r\n  function transferOwnership(address payable newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Destructible is Ownable {\r\n\r\n  constructor() public payable { }\r\n\r\n  \r\n  function destroy() public onlyOwner {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address payable _recipient) public onlyOwner {\r\n    selfdestruct(_recipient);\r\n  }\r\n}\r\n\r\ninterface FundingContract {\r\n  \r\n  event PayoutWithdrawed(address toAddress, uint256 amount, address triggered);\r\n  event NewDeposit(address from, uint256 amount);\r\n\r\n  \r\n  \r\n  function owner() external view returns (address);\r\n  \r\n  function withdrawLimit() external view returns(uint256);\r\n  function withdrawPeriod() external view returns(uint256);\r\n  function lastWithdraw() external view returns(uint256);\r\n  function canWithdraw() external view returns(bool);\r\n  function cancelled() external view returns (bool);\r\n  function totalNumberOfPayoutsLeft() external view returns (uint256);\r\n\r\n  \r\n  \r\n  function withdraw() external;\r\n  function deposit(address donator, uint256 amount) external;\r\n  function paybackTokens(address payable originalPayee, uint256 amount) external;\r\n  function toggleCancellation() external returns(bool);\r\n}\r\n\r\ninterface Deployer {\r\n    function deploy(\r\n        uint256 _numberOfPlannedPayouts,\r\n        uint256 _withdrawPeriod,\r\n        uint256 _campaignEndTime,\r\n        uint256 _amountPerPayment,\r\n        address payable __owner,\r\n        address _tokenAddress,\r\n        address _adminAddress\r\n    ) external returns (FundingContract c);\r\n}\r\n\r\ncontract DeploymentManager is Destructible {\r\n    struct DeployedContract {\r\n        address deployer;\r\n        address contractAddress;\r\n    }\r\n\r\n    modifier isAllowedUser() {\r\n        require(\r\n            allowedUsers[msg.sender] == true,\r\n            \"You are not allowed to deploy a campaign.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    Deployer erc20Deployer;\r\n    \r\n\r\n    mapping(address => bool) public allowedUsers;\r\n    mapping(address => DeployedContract[]) public deployedContracts;\r\n    mapping(address => uint256) public contractsCount;\r\n\r\n    constructor(address _erc20Deployer) public {\r\n        erc20Deployer = Deployer(_erc20Deployer);\r\n        allowedUsers[msg.sender] = true;\r\n    }\r\n\r\n    event NewFundingContract(\r\n        address indexed deployedAddress,\r\n        address indexed deployer\r\n    );\r\n\r\n    function updateERC20Deployer(address _erc20Deployer) external onlyOwner {\r\n        erc20Deployer = Deployer(_erc20Deployer);\r\n    }\r\n\r\n    function updateAllowedUserPermission(address _user, bool _isAllowed)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_user != address(0), \"User must be a valid address\");\r\n        allowedUsers[_user] = _isAllowed;\r\n    }\r\n\r\n    function deploy(\r\n        uint256 _numberOfPlannedPayouts,\r\n        uint256 _withdrawPeriod,\r\n        uint256 _campaignEndTime,\r\n        uint256 _amountPerPayment,\r\n        address payable __owner,\r\n        address _tokenAddress\r\n    ) external isAllowedUser {\r\n        if (_tokenAddress == address(0)) {\r\n            revert(\"Can only deploy ERC20 Funding Campaign Contract\");\r\n        }\r\n\r\n        FundingContract c = erc20Deployer.deploy(\r\n            _numberOfPlannedPayouts,\r\n            _withdrawPeriod,\r\n            _campaignEndTime,\r\n            _amountPerPayment,\r\n            __owner,\r\n            _tokenAddress,\r\n            msg.sender\r\n        );\r\n        deployedContracts[msg.sender].push(\r\n            DeployedContract(msg.sender, address(c))\r\n        );\r\n        contractsCount[msg.sender] += 1;\r\n        emit NewFundingContract(address(c), msg.sender);\r\n    }\r\n\r\n    function withdrawFromAllContracts() public {\r\n        DeployedContract[] storage contracts = deployedContracts[msg.sender];\r\n        uint256 totalContracts = contracts.length;\r\n        require(totalContracts > 0, \"No contract deployed\");\r\n\r\n        for (uint256 index = 0; index < contracts.length; index++) {\r\n            FundingContract fundingContract = FundingContract(\r\n                contracts[index].contractAddress\r\n            );\r\n            fundingContract.withdraw();\r\n        }\r\n    }\r\n}\r\n\r\ncontract FundingManagerContract is Ownable {\r\n    event SplitSharedFunds(\r\n        address[] indexed addresses,\r\n        uint256 indexed totalSpent\r\n    );\r\n\r\n    struct FundingLevel {\r\n        address campaign;\r\n        uint256 requiredBalance;\r\n    }\r\n\r\n    address public deploymentManager;\r\n    address public tokenAddress;\r\n\r\n    constructor(address _deploymentManager, address _tokenAddress) public {\r\n        owner = msg.sender;\r\n        deploymentManager = _deploymentManager;\r\n        tokenAddress = _tokenAddress;\r\n    }\r\n\r\n    function updateDeploymentManager(address _deploymentManager)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_deploymentManager != address(0), \"AddressNotNull\");\r\n        deploymentManager = _deploymentManager;\r\n    }\r\n\r\n    function payoutToCampaigns() external {\r\n        DeploymentManager manager = DeploymentManager(deploymentManager);\r\n        uint256 campaignsCount = manager.contractsCount(msg.sender);\r\n        require(campaignsCount > 0, \"NoContracts\");\r\n        IERC20 token = IERC20(tokenAddress);\r\n\r\n        for (uint256 index = 0; index < campaignsCount; index += 1) {\r\n            (, address currentContractAddress) = getCampaign(index);\r\n            FundingContract campaign = FundingContract(currentContractAddress);\r\n            uint256 campaignBalance = token.balanceOf(currentContractAddress);\r\n            if (\r\n                campaign.canWithdraw() &&\r\n                !campaign.cancelled() &&\r\n                campaignBalance > 0 &&\r\n                campaign.totalNumberOfPayoutsLeft() > 0\r\n            ) {\r\n                campaign.withdraw();\r\n            }\r\n        }\r\n    }\r\n\r\n    function splitShareCampaigns(\r\n        uint256 _campaignTopLimit,\r\n        address[] calldata _campaigns\r\n    ) external {\r\n        uint256 campaignsCount = _campaigns.length;\r\n        require(campaignsCount > 0, \"NoContracts\");\r\n\r\n        IERC20 token = IERC20(tokenAddress);\r\n\r\n        FundingLevel[25] memory fundings;\r\n        uint256 counter = 0;\r\n        uint256 totalBalanceNeed;\r\n        for (uint256 index = 0; index < campaignsCount; index += 1) {\r\n            address currentContractAddress = _campaigns[index];\r\n            uint256 balanceOfContract = token.balanceOf(currentContractAddress);\r\n            if (\r\n                currentContractAddress != address(0) &&\r\n                _campaignTopLimit > balanceOfContract\r\n            ) {\r\n                FundingContract campaign = FundingContract(\r\n                    currentContractAddress\r\n                );\r\n                if (\r\n                    !campaign.cancelled() &&\r\n                    campaign.totalNumberOfPayoutsLeft() > 0\r\n                ) {\r\n                    fundings[counter] = FundingLevel(\r\n                        currentContractAddress,\r\n                        _campaignTopLimit - balanceOfContract\r\n                    );\r\n                    counter += 1;\r\n                    totalBalanceNeed += _campaignTopLimit - balanceOfContract;\r\n                }\r\n            }\r\n        }\r\n        uint256 totalBalanceInContract = token.balanceOf(address(this));\r\n        require(totalBalanceInContract > 0, \"NoMoneyLeft\");\r\n        uint256 spentAmount = 0;\r\n        for (\r\n            uint256 fundingIndex = 0;\r\n            fundingIndex < counter;\r\n            fundingIndex += 1\r\n        ) {\r\n            FundingLevel memory level = fundings[fundingIndex];\r\n            uint256 amountToPay = (totalBalanceInContract *\r\n                level.requiredBalance) / totalBalanceNeed;\r\n            if (amountToPay > level.requiredBalance) {\r\n                amountToPay = level.requiredBalance;\r\n            }\r\n            token.transfer(fundings[fundingIndex].campaign, amountToPay);\r\n            spentAmount += amountToPay;\r\n        }\r\n        emit SplitSharedFunds(_campaigns, spentAmount);\r\n    }\r\n\r\n    function destroyAndSend() external onlyOwner {\r\n        destroyAndSend(tokenAddress);\r\n    }\r\n\r\n    function sendTokens(address _tokenAddress, address _toAddress)\r\n        public\r\n        onlyOwner\r\n    {\r\n        IERC20 token = IERC20(_tokenAddress);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance > 0, \"InsufficientBalance\");\r\n        token.transfer(_toAddress, balance);\r\n    }\r\n\r\n    function destroyAndSend(address _tokenAddress) public onlyOwner {\r\n        sendTokens(_tokenAddress, owner);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function getCampaign(uint256 num)\r\n        public\r\n        view\r\n        returns (address deployer, address currentContractAddress)\r\n    {\r\n        DeploymentManager manager = DeploymentManager(deploymentManager);\r\n        return (manager.deployedContracts(msg.sender, num));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_deploymentManager\",\"type\":\"address\"}],\"name\":\"updateDeploymentManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"getCampaign\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currentContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_campaignTopLimit\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_campaigns\",\"type\":\"address[]\"}],\"name\":\"splitShareCampaigns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deploymentManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payoutToCampaigns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"}],\"name\":\"sendTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_deploymentManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"totalSpent\",\"type\":\"uint256\"}],\"name\":\"SplitSharedFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FundingManagerContract","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000199ad7236d82085ef8eefda48984786272cfe96a0000000000000000000000002c537e5624e4af88a7ae4060c022609376c8d0eb","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://39839eca9723bf79e870bc12d18da9476488bde171404bff225346024f209e79"}]}