{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://eips.ethereum.org/EIPS/eip-20\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n    }\r\n}\r\n\r\n// File: contracts/common/governance/IGovernance.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ninterface IGovernance {\r\n    function update(address target, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/common/governance/Governable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Governable {\r\n    IGovernance public governance;\r\n\r\n    constructor(address _governance) public {\r\n        governance = IGovernance(_governance);\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        require(msg.sender == address(governance), \"Only governance contract is authorized\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/IWithdrawManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract IWithdrawManager {\r\n    function createExitQueue(address token) external;\r\n\r\n    function verifyInclusion(\r\n        bytes calldata data,\r\n        uint8 offset,\r\n        bool verifyTxInclusion\r\n    ) external view returns (uint256 age);\r\n\r\n    function addExitToQueue(\r\n        address exitor,\r\n        address childToken,\r\n        address rootToken,\r\n        uint256 exitAmountOrTokenId,\r\n        bytes32 txHash,\r\n        bool isRegularExit,\r\n        uint256 priority\r\n    ) external;\r\n\r\n    function addInput(\r\n        uint256 exitId,\r\n        uint256 age,\r\n        address utxoOwner,\r\n        address token\r\n    ) external;\r\n\r\n    function challengeExit(\r\n        uint256 exitId,\r\n        uint256 inputId,\r\n        bytes calldata challengeData,\r\n        address adjudicatorPredicate\r\n    ) external;\r\n}\r\n\r\n// File: contracts/common/Registry.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Registry is Governable {\r\n    // @todo hardcode constants\r\n    bytes32 private constant WETH_TOKEN = keccak256(\"wethToken\");\r\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\"depositManager\");\r\n    bytes32 private constant STAKE_MANAGER = keccak256(\"stakeManager\");\r\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\"validatorShare\");\r\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\"withdrawManager\");\r\n    bytes32 private constant CHILD_CHAIN = keccak256(\"childChain\");\r\n    bytes32 private constant STATE_SENDER = keccak256(\"stateSender\");\r\n    bytes32 private constant SLASHING_MANAGER = keccak256(\"slashingManager\");\r\n\r\n    address public erc20Predicate;\r\n    address public erc721Predicate;\r\n\r\n    mapping(bytes32 => address) public contractMap;\r\n    mapping(address => address) public rootToChildToken;\r\n    mapping(address => address) public childToRootToken;\r\n    mapping(address => bool) public proofValidatorContracts;\r\n    mapping(address => bool) public isERC721;\r\n\r\n    enum Type {Invalid, ERC20, ERC721, Custom}\r\n    struct Predicate {\r\n        Type _type;\r\n    }\r\n    mapping(address => Predicate) public predicates;\r\n\r\n    event TokenMapped(address indexed rootToken, address indexed childToken);\r\n    event ProofValidatorAdded(address indexed validator, address indexed from);\r\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\r\n    event PredicateAdded(address indexed predicate, address indexed from);\r\n    event PredicateRemoved(address indexed predicate, address indexed from);\r\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\r\n\r\n    constructor(address _governance) public Governable(_governance) {}\r\n\r\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\r\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\r\n        contractMap[_key] = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Map root token to child token\r\n     * @param _rootToken Token address on the root chain\r\n     * @param _childToken Token address on the child chain\r\n     * @param _isERC721 Is the token being mapped ERC721\r\n     */\r\n    function mapToken(\r\n        address _rootToken,\r\n        address _childToken,\r\n        bool _isERC721\r\n    ) external onlyGovernance {\r\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \"INVALID_TOKEN_ADDRESS\");\r\n        rootToChildToken[_rootToken] = _childToken;\r\n        childToRootToken[_childToken] = _rootToken;\r\n        isERC721[_rootToken] = _isERC721;\r\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\r\n        emit TokenMapped(_rootToken, _childToken);\r\n    }\r\n\r\n    function addErc20Predicate(address predicate) public onlyGovernance {\r\n        require(predicate != address(0x0), \"Can not add null address as predicate\");\r\n        erc20Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC20);\r\n    }\r\n\r\n    function addErc721Predicate(address predicate) public onlyGovernance {\r\n        erc721Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC721);\r\n    }\r\n\r\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\r\n        require(predicates[predicate]._type == Type.Invalid, \"Predicate already added\");\r\n        predicates[predicate]._type = _type;\r\n        emit PredicateAdded(predicate, msg.sender);\r\n    }\r\n\r\n    function removePredicate(address predicate) public onlyGovernance {\r\n        require(predicates[predicate]._type != Type.Invalid, \"Predicate does not exist\");\r\n        delete predicates[predicate];\r\n        emit PredicateRemoved(predicate, msg.sender);\r\n    }\r\n\r\n    function getValidatorShareAddress() public view returns (address) {\r\n        return contractMap[VALIDATOR_SHARE];\r\n    }\r\n\r\n    function getWethTokenAddress() public view returns (address) {\r\n        return contractMap[WETH_TOKEN];\r\n    }\r\n\r\n    function getDepositManagerAddress() public view returns (address) {\r\n        return contractMap[DEPOSIT_MANAGER];\r\n    }\r\n\r\n    function getStakeManagerAddress() public view returns (address) {\r\n        return contractMap[STAKE_MANAGER];\r\n    }\r\n\r\n    function getSlashingManagerAddress() public view returns (address) {\r\n        return contractMap[SLASHING_MANAGER];\r\n    }\r\n\r\n    function getWithdrawManagerAddress() public view returns (address) {\r\n        return contractMap[WITHDRAW_MANAGER];\r\n    }\r\n\r\n    function getChildChainAndStateSender() public view returns (address, address) {\r\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\r\n    }\r\n\r\n    function isTokenMapped(address _token) public view returns (bool) {\r\n        return rootToChildToken[_token] != address(0x0);\r\n    }\r\n\r\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\r\n        require(isTokenMapped(_token), \"TOKEN_NOT_MAPPED\");\r\n        return isERC721[_token];\r\n    }\r\n\r\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\r\n        if (isTokenMappedAndIsErc721(_token)) {\r\n            return erc721Predicate;\r\n        }\r\n        return erc20Predicate;\r\n    }\r\n\r\n    function isChildTokenErc721(address childToken) public view returns (bool) {\r\n        address rootToken = childToRootToken[childToken];\r\n        require(rootToken != address(0x0), \"Child token is not mapped\");\r\n        return isERC721[rootToken];\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/Lockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Lockable is Governable {\r\n    bool public locked;\r\n\r\n    modifier onlyWhenUnlocked() {\r\n        require(!locked, \"Is Locked\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _governance) public Governable(_governance) {}\r\n\r\n    function lock() external onlyGovernance {\r\n        locked = true;\r\n    }\r\n\r\n    function unlock() external onlyGovernance {\r\n        locked = false;\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/BytesLib.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(\r\n                0x40,\r\n                and(\r\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n                    not(31) // Round down to the nearest 32 bytes.\r\n                )\r\n            )\r\n        }\r\n        return tempBytes;\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_bytes.length >= (_start + _length));\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            switch iszero(_length)\r\n                case 0 {\r\n                    // Get a location of some free memory and store it in tempBytes as\r\n                    // Solidity does for memory variables.\r\n                    tempBytes := mload(0x40)\r\n\r\n                    // The first word of the slice result is potentially a partial\r\n                    // word read from the original array. To read it, we calculate\r\n                    // the length of that partial word and start copying that many\r\n                    // bytes into the array. The first word we copy will start with\r\n                    // data we don't care about, but the last `lengthmod` bytes will\r\n                    // land at the beginning of the contents of the new array. When\r\n                    // we're done copying, we overwrite the full first word with\r\n                    // the actual length of the slice.\r\n                    let lengthmod := and(_length, 31)\r\n\r\n                    // The multiplication in the next line is necessary\r\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                    // the following copy loop was copying the origin's length\r\n                    // and then ending prematurely not copying everything it should.\r\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                    let end := add(mc, _length)\r\n\r\n                    for {\r\n                        // The multiplication in the next line has the same exact purpose\r\n                        // as the one above.\r\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                    } lt(mc, end) {\r\n                        mc := add(mc, 0x20)\r\n                        cc := add(cc, 0x20)\r\n                    } {\r\n                        mstore(mc, mload(cc))\r\n                    }\r\n\r\n                    mstore(tempBytes, _length)\r\n\r\n                    //update free-memory pointer\r\n                    //allocating the array padded to 32 bytes like the compiler does now\r\n                    mstore(0x40, and(add(mc, 31), not(31)))\r\n                }\r\n                //if we want a zero-length slice let's just return a zero-length array\r\n                default {\r\n                    tempBytes := mload(0x40)\r\n                    mstore(0x40, add(tempBytes, 0x20))\r\n                }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    // Pad a bytes array to 32 bytes\r\n    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {\r\n        // may underflow if bytes.length < 32. Hence using SafeMath.sub\r\n        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));\r\n        return concat(newBytes, _bytes);\r\n    }\r\n\r\n    function toBytes32(bytes memory b) internal pure returns (bytes32) {\r\n        require(b.length >= 32, \"Bytes array should atleast be 32 bytes\");\r\n        bytes32 out;\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            out |= bytes32(b[i] & 0xFF) >> (i * 8);\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {\r\n        assembly {\r\n            result := mload(add(b, 32))\r\n        }\r\n    }\r\n\r\n    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {\r\n        bytes memory b = new bytes(32);\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));\r\n        }\r\n        return b;\r\n    }\r\n\r\n    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {\r\n        _ret = new bytes(32);\r\n        assembly {\r\n            mstore(add(_ret, 32), _num)\r\n        }\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/ECVerify.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary ECVerify {\r\n    function ecrecovery(bytes32 hash, bytes memory sig) public pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (sig.length != 65) {\r\n            return address(0x0);\r\n        }\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := and(mload(add(sig, 65)), 255)\r\n        }\r\n\r\n        // https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0x0);\r\n        }\r\n\r\n        // get address out of hash and signature\r\n        address result = ecrecover(hash, v, r, s);\r\n\r\n        // ecrecover returns zero on error\r\n        require(result != address(0x0));\r\n\r\n        return result;\r\n    }\r\n\r\n    function ecrecovery(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public pure returns (address) {\r\n        // get address out of hash and signature\r\n        address result = ecrecover(hash, v, r, s);\r\n\r\n        // ecrecover returns zero on error\r\n        require(result != address(0x0), \"signature verification failed\");\r\n\r\n        return result;\r\n    }\r\n\r\n    function ecverify(\r\n        bytes32 hash,\r\n        bytes memory sig,\r\n        address signer\r\n    ) public pure returns (bool) {\r\n        return signer == ecrecovery(hash, sig);\r\n    }\r\n}\r\n\r\n// File: contracts/staking/StakingInfo.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n// dummy interface to avoid cyclic dependency\r\ncontract IStakeManager1 {\r\n    enum Status {Inactive, Active, Locked, Unstaked}\r\n\r\n    struct Validator {\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 activationEpoch;\r\n        uint256 deactivationEpoch;\r\n        uint256 jailTime;\r\n        address signer;\r\n        address contractAddress;\r\n        Status status;\r\n    }\r\n\r\n    mapping(uint256 => Validator) public validators;\r\n    bytes32 public accountStateRoot;\r\n    uint256 public activeAmount; // delegation amount from validator contract\r\n    uint256 public validatorRewards;\r\n\r\n    function currentValidatorSetTotalStake() public view returns (uint256);\r\n\r\n    // signer to Validator mapping\r\n    function signerToValidator(address validatorAddress) public view returns (uint256);\r\n\r\n    function isValidator(uint256 validatorId) public view returns (bool);\r\n}\r\n\r\n\r\ncontract StakingInfo {\r\n    using SafeMath for uint256;\r\n    mapping(uint256 => uint256) public validatorNonce;\r\n\r\n    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.\r\n    /// @param signer validator address.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param activationEpoch validator's first epoch as proposer.\r\n    /// @param amount staking amount.\r\n    /// @param total total staking amount.\r\n    /// @param signerPubkey public key of the validator\r\n    event Staked(\r\n        address indexed signer,\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        uint256 indexed activationEpoch,\r\n        uint256 amount,\r\n        uint256 total,\r\n        bytes signerPubkey\r\n    );\r\n\r\n    /// @dev Emitted when validator unstakes in 'unstakeClaim()'\r\n    /// @param user address of the validator.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param amount staking amount.\r\n    /// @param total total staking amount.\r\n    event Unstaked(address indexed user, uint256 indexed validatorId, uint256 amount, uint256 total);\r\n\r\n    /// @dev Emitted when validator unstakes in '_unstake()'.\r\n    /// @param user address of the validator.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param deactivationEpoch last epoch for validator.\r\n    /// @param amount staking amount.\r\n    event UnstakeInit(\r\n        address indexed user,\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        uint256 deactivationEpoch,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param oldSigner old address of the validator.\r\n    /// @param newSigner new address of the validator.\r\n    /// @param signerPubkey public key of the validator.\r\n    event SignerChange(\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        address indexed oldSigner,\r\n        address indexed newSigner,\r\n        bytes signerPubkey\r\n    );\r\n    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);\r\n    event Jailed(uint256 indexed validatorId, uint256 indexed exitEpoch, address indexed signer);\r\n    event UnJailed(uint256 indexed validatorId, address indexed signer);\r\n    event Slashed(uint256 indexed nonce, uint256 indexed amount);\r\n    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);\r\n    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);\r\n    event ProposerBonusChange(uint256 newProposerBonus, uint256 oldProposerBonus);\r\n\r\n    event RewardUpdate(uint256 newReward, uint256 oldReward);\r\n\r\n    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param newAmount the updated stake amount.\r\n    event StakeUpdate(uint256 indexed validatorId, uint256 indexed nonce, uint256 indexed newAmount);\r\n    event ClaimRewards(uint256 indexed validatorId, uint256 indexed amount, uint256 indexed totalAmount);\r\n    event StartAuction(uint256 indexed validatorId, uint256 indexed amount, uint256 indexed auctionAmount);\r\n    event ConfirmAuction(uint256 indexed newValidatorId, uint256 indexed oldValidatorId, uint256 indexed amount);\r\n    event TopUpFee(address indexed user, uint256 indexed fee);\r\n    event ClaimFee(address indexed user, uint256 indexed fee);\r\n    // Delegator events\r\n    event ShareMinted(uint256 indexed validatorId, address indexed user, uint256 indexed amount, uint256 tokens);\r\n    event ShareBurned(uint256 indexed validatorId, address indexed user, uint256 indexed amount, uint256 tokens);\r\n    event DelegatorClaimedRewards(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed rewards,\r\n        uint256 tokens\r\n    );\r\n    event DelegatorRestaked(uint256 indexed validatorId, address indexed user, uint256 indexed totalStaked);\r\n    event DelegatorUnstaked(uint256 indexed validatorId, address indexed user, uint256 amount);\r\n    event UpdateCommissionRate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed newCommissionRate,\r\n        uint256 indexed oldCommissionRate\r\n    );\r\n\r\n    Registry public registry;\r\n\r\n    modifier onlyValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        (, , , , , , _contract, ) = IStakeManager1(registry.getStakeManagerAddress()).validators(validatorId);\r\n        require(_contract == msg.sender, \"Invalid sender, not validator\");\r\n        _;\r\n    }\r\n\r\n    modifier StakeManagerOrValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        address _stakeManager = registry.getStakeManagerAddress();\r\n        (, , , , , , _contract, ) = IStakeManager1(_stakeManager).validators(validatorId);\r\n        require(\r\n            _contract == msg.sender || _stakeManager == msg.sender,\r\n            \"Invalid sender, not stake manager or validator contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyStakeManager() {\r\n        require(registry.getStakeManagerAddress() == msg.sender, \"Invalid sender, not stake manager\");\r\n        _;\r\n    }\r\n    modifier onlySlashingManager() {\r\n        require(registry.getSlashingManagerAddress() == msg.sender, \"Invalid sender, not slashing manager\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _registry) public {\r\n        registry = Registry(_registry);\r\n    }\r\n\r\n    function logStaked(\r\n        address signer,\r\n        bytes memory signerPubkey,\r\n        uint256 validatorId,\r\n        uint256 activationEpoch,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit Staked(signer, validatorId, validatorNonce[validatorId], activationEpoch, amount, total, signerPubkey);\r\n    }\r\n\r\n    function logUnstaked(\r\n        address user,\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        emit Unstaked(user, validatorId, amount, total);\r\n    }\r\n\r\n    function logUnstakeInit(\r\n        address user,\r\n        uint256 validatorId,\r\n        uint256 deactivationEpoch,\r\n        uint256 amount\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit UnstakeInit(user, validatorId, validatorNonce[validatorId], deactivationEpoch, amount);\r\n    }\r\n\r\n    function logSignerChange(\r\n        uint256 validatorId,\r\n        address oldSigner,\r\n        address newSigner,\r\n        bytes memory signerPubkey\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit SignerChange(validatorId, validatorNonce[validatorId], oldSigner, newSigner, signerPubkey);\r\n    }\r\n\r\n    function logRestaked(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        emit Restaked(validatorId, amount, total);\r\n    }\r\n\r\n    function logJailed(\r\n        uint256 validatorId,\r\n        uint256 exitEpoch,\r\n        address signer\r\n    ) public onlyStakeManager {\r\n        emit Jailed(validatorId, exitEpoch, signer);\r\n    }\r\n\r\n    function logUnjailed(uint256 validatorId, address signer) public onlyStakeManager {\r\n        emit UnJailed(validatorId, signer);\r\n    }\r\n\r\n    function logSlashed(uint256 nonce, uint256 amount) public onlySlashingManager {\r\n        emit Slashed(nonce, amount);\r\n    }\r\n\r\n    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold) public onlyStakeManager {\r\n        emit ThresholdChange(newThreshold, oldThreshold);\r\n    }\r\n\r\n    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty) public onlyStakeManager {\r\n        emit DynastyValueChange(newDynasty, oldDynasty);\r\n    }\r\n\r\n    function logProposerBonusChange(uint256 newProposerBonus, uint256 oldProposerBonus) public onlyStakeManager {\r\n        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);\r\n    }\r\n\r\n    function logRewardUpdate(uint256 newReward, uint256 oldReward) public onlyStakeManager {\r\n        emit RewardUpdate(newReward, oldReward);\r\n    }\r\n\r\n    function logStakeUpdate(uint256 validatorId) public StakeManagerOrValidatorContract(validatorId) {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit StakeUpdate(validatorId, validatorNonce[validatorId], totalValidatorStake(validatorId));\r\n    }\r\n\r\n    function logClaimRewards(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 totalAmount\r\n    ) public onlyStakeManager {\r\n        emit ClaimRewards(validatorId, amount, totalAmount);\r\n    }\r\n\r\n    function logStartAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 auctionAmount\r\n    ) public onlyStakeManager {\r\n        emit StartAuction(validatorId, amount, auctionAmount);\r\n    }\r\n\r\n    function logConfirmAuction(\r\n        uint256 newValidatorId,\r\n        uint256 oldValidatorId,\r\n        uint256 amount\r\n    ) public onlyStakeManager {\r\n        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);\r\n    }\r\n\r\n    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {\r\n        emit TopUpFee(user, fee);\r\n    }\r\n\r\n    function logClaimFee(address user, uint256 fee) public onlyStakeManager {\r\n        emit ClaimFee(user, fee);\r\n    }\r\n\r\n    function getStakerDetails(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 amount,\r\n            uint256 reward,\r\n            uint256 activationEpoch,\r\n            uint256 deactivationEpoch,\r\n            address signer,\r\n            uint256 _status\r\n        )\r\n    {\r\n        IStakeManager1 stakeManager = IStakeManager1(registry.getStakeManagerAddress());\r\n        address _contract;\r\n        IStakeManager1.Status status;\r\n        (amount, reward, activationEpoch, deactivationEpoch, , signer, _contract, status) = stakeManager.validators(\r\n            validatorId\r\n        );\r\n        reward += IStakeManager1(_contract).validatorRewards();\r\n        _status = uint256(status);\r\n    }\r\n\r\n    function totalValidatorStake(uint256 validatorId) public view returns (uint256 validatorStake) {\r\n        address contractAddress;\r\n        (validatorStake, , , , , , contractAddress, ) = IStakeManager1(registry.getStakeManagerAddress()).validators(\r\n            validatorId\r\n        );\r\n        if (contractAddress != address(0x0)) {\r\n            validatorStake += IStakeManager1(contractAddress).activeAmount();\r\n        }\r\n    }\r\n\r\n    function getAccountStateRoot() public view returns (bytes32 accountStateRoot) {\r\n        accountStateRoot = IStakeManager1(registry.getStakeManagerAddress()).accountStateRoot();\r\n    }\r\n\r\n    function getValidatorContractAddress(uint256 validatorId) public view returns (address ValidatorContract) {\r\n        (, , , , , , ValidatorContract, ) = IStakeManager1(registry.getStakeManagerAddress()).validators(validatorId);\r\n    }\r\n\r\n    // validator Share contract logging func\r\n    function logShareMinted(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareMinted(validatorId, user, amount, tokens);\r\n    }\r\n\r\n    function logShareBurned(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareBurned(validatorId, user, amount, tokens);\r\n    }\r\n\r\n    function logDelegatorClaimRewards(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 rewards,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorClaimedRewards(validatorId, user, rewards, tokens);\r\n    }\r\n\r\n    function logDelegatorRestaked(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 totalStaked\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorRestaked(validatorId, user, totalStaked);\r\n    }\r\n\r\n    function logDelegatorUnstaked(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorUnstaked(validatorId, user, amount);\r\n    }\r\n\r\n    function logUpdateCommissionRate(\r\n        uint256 validatorId,\r\n        uint256 newCommissionRate,\r\n        uint256 oldCommissionRate\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit UpdateCommissionRate(validatorId, newCommissionRate, oldCommissionRate);\r\n    }\r\n}\r\n\r\n// File: contracts/staking/stakeManager/IStakeManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract IStakeManager {\r\n    // validator replacement\r\n    function startAuction(uint256 validatorId, uint256 amount) external;\r\n\r\n    function confirmAuctionBid(\r\n        uint256 validatorId,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function transferFunds(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function delegationDeposit(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function stake(\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function unstake(uint256 validatorId) external;\r\n\r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n\r\n    function supportsHistory() external pure returns (bool);\r\n\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes memory signerPubkey\r\n    ) public;\r\n\r\n    function checkSignatures(\r\n        uint256 blockInterval,\r\n        bytes32 voteHash,\r\n        bytes32 stateRoot,\r\n        address proposer,\r\n        bytes memory sigs\r\n    ) public returns (uint256);\r\n\r\n    function updateValidatorState(uint256 validatorId, int256 amount) public;\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n\r\n    function slash(bytes memory slashingInfoList) public returns (uint256);\r\n\r\n    function validatorStake(uint256 validatorId) public view returns (uint256);\r\n\r\n    function epoch() public view returns (uint256);\r\n\r\n    function withdrawalDelay() public view returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/common/misc/ProxyStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ProxyStorage is Ownable {\r\n    address internal proxyTo;\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShareStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ValidatorShareHeader {\r\n    struct Delegator {\r\n        uint256 share;\r\n        uint256 withdrawEpoch;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20Disabled is ERC20 {\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        revert(\"Disabled\");\r\n    }\r\n}\r\n\r\n\r\ncontract ValidatorShareStorage is ProxyStorage, ERC20Disabled, Lockable, ValidatorShareHeader {\r\n    StakingInfo public stakingLogger;\r\n    IStakeManager public stakeManager;\r\n    uint256 public validatorId;\r\n    uint256 public validatorRewards;\r\n    uint256 public commissionRate;\r\n    //last checkpoint where validator updated commission rate\r\n    uint256 public lastCommissionUpdate;\r\n    uint256 public minAmount = 10**18;\r\n\r\n    uint256 public totalStake;\r\n    uint256 public rewards;\r\n    uint256 public activeAmount;\r\n    bool public delegation = true;\r\n\r\n    uint256 public withdrawPool;\r\n    uint256 public withdrawShares;\r\n\r\n    mapping(address => uint256) public amountStaked;\r\n    mapping(address => Delegator) public delegators;\r\n\r\n    uint256 constant EXCHANGE_RATE_PRECISION = 100;\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShare.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ValidatorShare is ValidatorShareStorage {\r\n    modifier onlyValidator() {\r\n        require(stakeManager.ownerOf(validatorId) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _registry,\r\n        uint256 _validatorId,\r\n        address _stakingLogger,\r\n        address _stakeManager\r\n    ) public Lockable(_stakeManager) {} // dummy constructor\r\n\r\n    function updateCommissionRate(uint256 newCommissionRate) external onlyValidator {\r\n        uint256 epoch = stakeManager.epoch();\r\n        uint256 _lastCommissionUpdate = lastCommissionUpdate;\r\n\r\n        require( // withdrawalDelay == dynasty\r\n            (_lastCommissionUpdate.add(stakeManager.withdrawalDelay()) <= epoch) || _lastCommissionUpdate == 0, // For initial setting of commission rate\r\n            \"Commission rate update cooldown period\"\r\n        );\r\n\r\n        require(newCommissionRate <= 100, \"Commission rate should be in range of 0-100\");\r\n        stakingLogger.logUpdateCommissionRate(validatorId, newCommissionRate, commissionRate);\r\n        commissionRate = newCommissionRate;\r\n        lastCommissionUpdate = epoch;\r\n    }\r\n\r\n    function withdrawRewardsValidator() external onlyOwner returns (uint256) {\r\n        uint256 _validatorRewards = validatorRewards;\r\n        validatorRewards = 0;\r\n        return _validatorRewards;\r\n    }\r\n\r\n    function exchangeRate() public view returns (uint256) {\r\n        uint256 totalStaked = totalSupply();\r\n        return\r\n            totalStaked == 0\r\n                ? EXCHANGE_RATE_PRECISION\r\n                : activeAmount.add(rewards).mul(EXCHANGE_RATE_PRECISION).div(totalStaked);\r\n    }\r\n\r\n    function withdrawExchangeRate() public view returns (uint256) {\r\n        uint256 _withdrawShares = withdrawShares;\r\n        return\r\n            _withdrawShares == 0\r\n                ? EXCHANGE_RATE_PRECISION\r\n                : withdrawPool.mul(EXCHANGE_RATE_PRECISION).div(_withdrawShares);\r\n    }\r\n\r\n    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public onlyWhenUnlocked {\r\n        uint256 rate = exchangeRate();\r\n        uint256 share = _amount.mul(EXCHANGE_RATE_PRECISION).div(rate);\r\n        require(share >= _minSharesToMint, \"Too much slippage\");\r\n\r\n        require(delegators[msg.sender].share == 0, \"Ongoing exit\");\r\n\r\n        _mint(msg.sender, share);\r\n        _amount = _amount.sub(_amount % rate.mul(share).div(EXCHANGE_RATE_PRECISION));\r\n\r\n        totalStake = totalStake.add(_amount);\r\n        amountStaked[msg.sender] = amountStaked[msg.sender].add(_amount);\r\n        require(stakeManager.delegationDeposit(validatorId, _amount, msg.sender), \"deposit failed\");\r\n\r\n        activeAmount = activeAmount.add(_amount);\r\n        stakeManager.updateValidatorState(validatorId, int256(_amount));\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logShareMinted(validatorId, msg.sender, _amount, share);\r\n        logger.logStakeUpdate(validatorId);\r\n    }\r\n\r\n    function sellVoucher(uint256 _minClaimAmount) public {\r\n        uint256 share = balanceOf(msg.sender);\r\n        require(share > 0, \"Zero balance\");\r\n        uint256 rate = exchangeRate();\r\n        uint256 _amount = rate.mul(share).div(EXCHANGE_RATE_PRECISION);\r\n        require(_amount >= _minClaimAmount, \"Too much slippage\");\r\n        _burn(msg.sender, share);\r\n        stakeManager.updateValidatorState(validatorId, -int256(_amount));\r\n\r\n        uint256 userStake = amountStaked[msg.sender];\r\n\r\n        if (_amount > userStake) {\r\n            uint256 _rewards = _amount.sub(userStake);\r\n            //withdrawTransfer\r\n            require(stakeManager.transferFunds(validatorId, _rewards, msg.sender), \"Insufficent rewards\");\r\n            _amount = userStake;\r\n        }\r\n\r\n        activeAmount = activeAmount.sub(_amount);\r\n        uint256 _withdrawPoolShare = _amount.mul(EXCHANGE_RATE_PRECISION).div(withdrawExchangeRate());\r\n\r\n        withdrawPool = withdrawPool.add(_amount);\r\n        withdrawShares = withdrawShares.add(_withdrawPoolShare);\r\n        delegators[msg.sender] = Delegator({share: _withdrawPoolShare, withdrawEpoch: stakeManager.epoch()});\r\n        amountStaked[msg.sender] = 0;\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logShareBurned(validatorId, msg.sender, _amount, share);\r\n        logger.logStakeUpdate(validatorId);\r\n    }\r\n\r\n    function withdrawRewards() public {\r\n        uint256 liquidRewards = getLiquidRewards(msg.sender);\r\n        require(liquidRewards >= minAmount, \"Too small rewards amount\");\r\n        uint256 sharesToBurn = liquidRewards.mul(EXCHANGE_RATE_PRECISION).div(exchangeRate());\r\n        _burn(msg.sender, sharesToBurn);\r\n        rewards = rewards.sub(liquidRewards);\r\n        require(stakeManager.transferFunds(validatorId, liquidRewards, msg.sender), \"Insufficent rewards\");\r\n        stakingLogger.logDelegatorClaimRewards(validatorId, msg.sender, liquidRewards, sharesToBurn);\r\n    }\r\n\r\n    function restake() public {\r\n        /**\r\n        restaking is simply buying more shares of pool\r\n        but those needs to be nonswapable/transferrable to prevent https://en.wikipedia.org/wiki/Tragedy_of_the_commons\r\n\r\n        - only active amount is considers as active stake\r\n        - move reward amount to active stake pool\r\n        - no shares are minted\r\n        */\r\n        uint256 liquidRewards = getLiquidRewards(msg.sender);\r\n        require(liquidRewards >= minAmount, \"Too small rewards to restake\");\r\n\r\n        amountStaked[msg.sender] = amountStaked[msg.sender].add(liquidRewards);\r\n        totalStake = totalStake.add(liquidRewards);\r\n        activeAmount = activeAmount.add(liquidRewards);\r\n        stakeManager.updateValidatorState(validatorId, int256(liquidRewards));\r\n        rewards = rewards.sub(liquidRewards);\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logStakeUpdate(validatorId);\r\n        logger.logDelegatorRestaked(validatorId, msg.sender, amountStaked[msg.sender]);\r\n    }\r\n\r\n    function getLiquidRewards(address user) public view returns (uint256) {\r\n        uint256 share = balanceOf(user);\r\n        if (share == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 liquidRewards;\r\n        uint256 totalTokens = exchangeRate().mul(share).div(EXCHANGE_RATE_PRECISION);\r\n        uint256 stake = amountStaked[user];\r\n        if (totalTokens >= stake) {\r\n            liquidRewards = totalTokens.sub(stake);\r\n        }\r\n\r\n        return liquidRewards;\r\n    }\r\n\r\n    function unstakeClaimTokens() public {\r\n        Delegator storage delegator = delegators[msg.sender];\r\n\r\n        uint256 share = delegator.share;\r\n        require(\r\n            delegator.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && share > 0,\r\n            \"Incomplete withdrawal period\"\r\n        );\r\n\r\n        uint256 _amount = withdrawExchangeRate().mul(share).div(EXCHANGE_RATE_PRECISION);\r\n        withdrawShares = withdrawShares.sub(share);\r\n        withdrawPool = withdrawPool.sub(_amount);\r\n\r\n        totalStake = totalStake.sub(_amount);\r\n\r\n        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), \"Insufficent rewards\");\r\n        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, _amount);\r\n        delete delegators[msg.sender];\r\n    }\r\n\r\n    function slash(uint256 valPow, uint256 totalAmountToSlash) external onlyOwner returns (uint256) {\r\n        uint256 _withdrawPool = withdrawPool;\r\n        uint256 delegationAmount = activeAmount.add(_withdrawPool);\r\n        if (delegationAmount == 0) {\r\n            return 0;\r\n        }\r\n        // total amount to be slashed from delegation pool (active + inactive)\r\n        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(valPow.add(delegationAmount));\r\n        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);\r\n\r\n        // slash inactive pool\r\n        withdrawPool = _withdrawPool.sub(_amountToSlashWithdrawalPool);\r\n        activeAmount = activeAmount.sub(_amountToSlash.sub(_amountToSlashWithdrawalPool));\r\n        return _amountToSlash;\r\n    }\r\n\r\n    function drain(\r\n        address token,\r\n        address payable destination,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        if (token == address(0x0)) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(ERC20(token).transfer(destination, amount), \"Drain failed\");\r\n        }\r\n    }\r\n\r\n    function unlockContract() external onlyOwner returns (uint256) {\r\n        locked = false;\r\n        return activeAmount;\r\n    }\r\n\r\n    function lockContract() external onlyOwner returns (uint256) {\r\n        locked = true;\r\n        return activeAmount;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCommissionRate\",\"type\":\"uint256\"}],\"name\":\"updateCommissionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCommissionUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRewardsValidator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingLogger\",\"outputs\":[{\"internalType\":\"contract StakingInfo\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract IGovernance\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLiquidRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minSharesToMint\",\"type\":\"uint256\"}],\"name\":\"buyVoucher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minClaimAmount\",\"type\":\"uint256\"}],\"name\":\"sellVoucher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeManager\",\"outputs\":[{\"internalType\":\"contract IStakeManager\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstakeClaimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawEpoch\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"valPow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountToSlash\",\"type\":\"uint256\"}],\"name\":\"slash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_stakingLogger\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ValidatorShare","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000033a02e6cc863d393d6bf231b697b82f6e499ca7100000000000000000000000000000000000000000000000000000000000000000000000000000000000000008e31cf45a30269d9a6115ab76f56eefb559cffc300000000000000000000000088f65097ba6e10f25e93bf41987f9416bbb303eb","EVMVersion":"constantinople","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a43fe03809aad68a8668d878b0cefe86f317023b186b11c1c26d840000d99ad9"}]}