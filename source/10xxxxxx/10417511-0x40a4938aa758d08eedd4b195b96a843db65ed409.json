{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/*\r\n         _     _                                               _         \r\n   ___  | |_  | |__     ___   _ __   _ __     ___  __  __     (_)   ___  \r\n  / _ \\ | __| | '_ \\   / _ \\ | '__| | '_ \\   / _ \\ \\ \\/ /     | |  / _ \\ \r\n |  __/ | |_  | | | | |  __/ | |    | | | | |  __/  >  <   _  | | | (_) |\r\n  \\___|  \\__| |_| |_|  \\___| |_|    |_| |_|  \\___| /_/\\_\\ (_) |_|  \\___/ \r\n\r\nhttps://ethernex.io/\r\n*/\r\n\r\ncontract ethernex {\r\n    using SafeMath for uint256;\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    struct MemberInfo { uint userID; uint activeEntry; address referrer; uint[] entriesId; address[] referrals; }\r\n    struct RegInfo { bool isActive; uint amount; uint totalIncome; uint startDate; uint maturityDays; uint withdrawnAmount; }\r\n    mapping (address => MemberInfo)  memberInfos;\r\n    mapping(uint => mapping(uint => RegInfo))  RegistrationInfo;\r\n    mapping(address => uint) public balance;\r\n    uint256 public totalEntries;\r\n    address owner;\r\n    uint public lastMemberID = 2;\r\n    uint public lastEntryID = 2;\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n        MemberInfo storage _memberInfo = memberInfos[owner];\r\n        _memberInfo.userID = 1;\r\n    }\r\n\r\n    function register(address uplineAddress) external payable {\r\n        require(msg.value >= 0.1 ether, \"registration starts at 0.1\");\r\n        uint _totalDays = getMaturityDays(msg.value);\r\n        require(_totalDays > 0, \"invalid entry amount.\");\r\n        uint uplineUserId = getUserId(uplineAddress);\r\n        require(uplineUserId > 0, \"upline address not found\");\r\n         uint memberId = getUserId(msg.sender);\r\n         require(memberId == 0,\"address already registered.\");\r\n        memberId = lastMemberID++;   \r\n        MemberInfo storage _memberInfo = memberInfos[msg.sender]; \r\n        _memberInfo.referrer = uplineAddress;\r\n        _memberInfo.userID = memberId;\r\n        uint newEntryId = lastEntryID++;\r\n        _memberInfo.activeEntry += 1;\r\n        _memberInfo.entriesId.push(newEntryId);\r\n        RegInfo storage _regInfo = RegistrationInfo[memberId][newEntryId];\r\n        _regInfo.isActive = true;\r\n        _regInfo.amount = msg.value;\r\n        _regInfo.totalIncome = msg.value.mul(10).mul(_totalDays).div(100);\r\n        _regInfo.startDate = now;\r\n        _regInfo.maturityDays = _totalDays;\r\n        MemberInfo storage _uplineInfo = memberInfos[uplineAddress];\r\n        _uplineInfo.referrals.push(msg.sender);\r\n        uint _directIncome = msg.value.mul(10).div(100);\r\n        if(uplineAddress != address(0)){\r\n            uplineAddress.transfer(_directIncome);\r\n            balance[uplineAddress] += _directIncome;\r\n        }\r\n        owner.transfer(msg.value.mul(8).div(100));\r\n        totalEntries += msg.value;\r\n    }\r\n    \r\n    function addentry() external payable {\r\n        require(msg.value >= 0.1 ether, \"registration starts at 0.1\");\r\n        uint _totalDays = getMaturityDays(msg.value);\r\n        require(_totalDays > 0, \"invalid entry amount.\");\r\n        uint memberId = getUserId(msg.sender);\r\n        require(memberId > 0, \"address is not yet registered.\");\r\n        address uplineAddress = getUpline(msg.sender);\r\n        MemberInfo storage _memberInfo = memberInfos[msg.sender]; \r\n        uint newEntryId = lastEntryID++;\r\n        _memberInfo.activeEntry += 1;\r\n        _memberInfo.entriesId.push(newEntryId);\r\n        RegInfo storage _regInfo = RegistrationInfo[memberId][newEntryId];\r\n        _regInfo.isActive = true;\r\n        _regInfo.amount = msg.value;\r\n        _regInfo.totalIncome = msg.value.mul(10).mul(_totalDays).div(100);\r\n        _regInfo.startDate = now;\r\n        _regInfo.maturityDays = _totalDays;\r\n        uint _directIncome = msg.value.mul(10).div(100);\r\n        if(uplineAddress != address(0)){\r\n            uplineAddress.transfer(_directIncome);\r\n            balance[uplineAddress] += _directIncome;\r\n        }\r\n        owner.transfer(msg.value.mul(8).div(100));\r\n        totalEntries += msg.value;\r\n    }\r\n    \r\n    function withdrawincome(uint amount, uint entryId) public{\r\n        uint _userId = getUserId(msg.sender);\r\n        require(_userId > 0, \"invalid account address\");\r\n        uint _balance = getAvailableIncome(_userId, entryId);\r\n        require(_balance >= amount, \"you don't have enough balance\");\r\n        require(address(this).balance >= amount, \"source has insufficient fund, try again later.\");\r\n        RegInfo storage _regInfo =  RegistrationInfo[_userId][entryId];\r\n        _regInfo.withdrawnAmount += amount;\r\n        balance[msg.sender] += amount;\r\n        if(_regInfo.withdrawnAmount >= _regInfo.totalIncome){\r\n            _regInfo.isActive = false;\r\n        }\r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    \r\n    function getMaturityDays(uint amount) pure internal  returns (uint) {\r\n        uint _days = 20;\r\n        if(amount == 1 ether){\r\n            _days = 22;\r\n        }else if(amount == 10 ether){\r\n            _days = 25;\r\n        }\r\n        return _days;\r\n    }\r\n    \r\n    function getAvailableIncome(uint _userId, uint _entryId) view public returns (uint AvailableBalance) { \r\n        RegInfo storage _regInfo =  RegistrationInfo[_userId][_entryId];\r\n        if(_regInfo.isActive){\r\n            \r\n            uint _totalDays = (now - _regInfo.startDate).div(60).div(60).div(24);\r\n            if(_totalDays > _regInfo.maturityDays){\r\n                _totalDays = _regInfo.maturityDays;\r\n            }\r\n            uint _dailyIncome = _regInfo.amount.mul(10).div(100);\r\n            uint _totalIncome = _dailyIncome.mul(_totalDays);\r\n            uint _balance = _totalIncome.sub(_regInfo.withdrawnAmount);\r\n            return _balance;\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n    \r\n    function getGrowthDays(uint _userId, uint _entryId) view public returns (uint TotalDays) { \r\n        RegInfo storage _regInfo =  RegistrationInfo[_userId][_entryId];\r\n        if(_regInfo.isActive){\r\n            \r\n            uint _totalDays = (now - _regInfo.startDate).div(60).div(60).div(24);\r\n            if(_totalDays > _regInfo.maturityDays){\r\n                _totalDays = _regInfo.maturityDays;\r\n            }\r\n            \r\n            return _totalDays;\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n    \r\n    function getUserId(address _address) view public returns (uint UserId) { \r\n        return (memberInfos[_address].userID);\r\n    }\r\n    function getEntriesId(address _address) view public returns (uint[] Entries) { \r\n        return (memberInfos[_address].entriesId);\r\n    }\r\n    \r\n    function getUpline(address _address) view public returns (address UplineAddress) { \r\n        return (memberInfos[_address].referrer);\r\n    }\r\n    \r\n    function getEntryDetails(uint userId, uint entryId) view public returns (bool isActive, uint amountEntry, uint expectedIncome, uint dateStarted, uint maturityDays,  uint withdrawnAmount) {\r\n        RegInfo storage _regInfo = RegistrationInfo[userId][entryId];\r\n        return (_regInfo.isActive, _regInfo.amount, _regInfo.totalIncome, _regInfo.startDate,  _regInfo.maturityDays, _regInfo.withdrawnAmount);\r\n    }\r\n    \r\n    function getAllReferrals(address _address) view public returns (address[] Referrals) {\r\n        return (memberInfos[_address].referrals);\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n \r\n  function div(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n \r\n  function sub(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n \r\n  function add(uint256 a, uint256 b) pure internal  returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"addentry\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"entryId\",\"type\":\"uint256\"}],\"name\":\"withdrawincome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserId\",\"outputs\":[{\"name\":\"UserId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uplineAddress\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getEntriesId\",\"outputs\":[{\"name\":\"Entries\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastEntryID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userId\",\"type\":\"uint256\"},{\"name\":\"entryId\",\"type\":\"uint256\"}],\"name\":\"getEntryDetails\",\"outputs\":[{\"name\":\"isActive\",\"type\":\"bool\"},{\"name\":\"amountEntry\",\"type\":\"uint256\"},{\"name\":\"expectedIncome\",\"type\":\"uint256\"},{\"name\":\"dateStarted\",\"type\":\"uint256\"},{\"name\":\"maturityDays\",\"type\":\"uint256\"},{\"name\":\"withdrawnAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEntries\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userId\",\"type\":\"uint256\"},{\"name\":\"_entryId\",\"type\":\"uint256\"}],\"name\":\"getAvailableIncome\",\"outputs\":[{\"name\":\"AvailableBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastMemberID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userId\",\"type\":\"uint256\"},{\"name\":\"_entryId\",\"type\":\"uint256\"}],\"name\":\"getGrowthDays\",\"outputs\":[{\"name\":\"TotalDays\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAllReferrals\",\"outputs\":[{\"name\":\"Referrals\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUpline\",\"outputs\":[{\"name\":\"UplineAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ethernex","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2588915741ac4d35be8faa21e3da34689ca5092dc1dd8358cd1c43b627f34f9f"}]}