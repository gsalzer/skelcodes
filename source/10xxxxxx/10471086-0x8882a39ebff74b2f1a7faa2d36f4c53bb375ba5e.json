{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: contracts/MultisigVaultETH.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract MultisigVaultETH {\n\n    using SafeMath for uint256;\n\n    struct Approval {\n        uint32 nonce;\n        uint8  coincieded;\n        bool   skipFee;\n        address[] coinciedeParties;\n    }\n\n    uint8 private participantsAmount;\n    uint8 private signatureMinThreshold;\n    uint32 private nonce;\n    address public currencyAddress;\n    uint16 private serviceFeeMicro;\n    address private _owner;\n\n    mapping(address => bool) public parties;\n\n    mapping(\n        // Destination\n        address => mapping(\n            // Amount\n            uint256 => Approval\n        )\n    ) public approvals;\n\n    mapping(uint256 => bool) public finished;\n\n    event ConfirmationReceived(address indexed from, address indexed destination, address currency, uint256 amount);\n    event ConsensusAchived(address indexed destination, address currency, uint256 amount);\n\n    /**\n      * @dev Construcor.\n      *\n      * Requirements:\n      * - `_signatureMinThreshold` .\n      * - `_parties`.\n      */\n    constructor(\n        uint8 _signatureMinThreshold,\n        address[] memory _parties\n    ) public {\n        require(_parties.length > 0 && _parties.length <= 10);\n        require(_signatureMinThreshold > 0 && _signatureMinThreshold <= _parties.length);\n\n        _owner = msg.sender;\n\n        signatureMinThreshold = _signatureMinThreshold;\n\n        for (uint256 i = 0; i < _parties.length; i++) parties[_parties[i]] = true;\n\n        serviceFeeMicro = 5000; // Of a million or 0.5%\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Returns the nonce number of releasing transaction by destination and amount.\n     */\n    function getNonce(\n        address _destination,\n        uint256 _amount\n    ) public view returns (uint256) {\n        Approval storage approval = approvals[_destination][_amount];\n\n        return approval.nonce;\n    }\n\n\n    /**\n     * @dev Returns boolean id party provided its approval.\n     */\n    function partyCoincieded(\n        address _destination,\n        uint256 _amount,\n        uint256 _nonce,\n        address _partyAddress\n    ) public view returns (bool) {\n        if ( finished[_nonce] ) {\n          return true;\n        } else {\n          Approval storage approval = approvals[_destination][_amount];\n\n          for (uint i=0; i<approval.coinciedeParties.length; i++) {\n             if (approval.coinciedeParties[i] == _partyAddress) return true;\n          }\n\n          return false;\n        }\n    }\n\n    function approve(\n        address payable _destination,\n        uint256 _amount\n    ) public returns (bool) {\n        approveAndRelease( _destination, _amount, false);\n    }\n\n\n    function regress(\n        address payable _destination,\n        uint256 _amount\n    ) public onlyOwner() returns (bool) {\n        approveAndRelease( _destination, _amount, true);\n    }\n\n\n    function approveAndRelease(\n        address payable _destination,\n        uint256 _amount,\n        bool    _skipServiceFee\n    ) internal returns (bool) {\n       require(parties[msg.sender], \"Release: not a member\");\n       address multisig = address(this);  // https://biboknow.com/page-ethereum/78597/solidity-0-6-0-addressthis-balance-throws-error-invalid-opcode\n       require(multisig.balance >= _amount, \"Release:  insufficient balance\");\n\n       Approval storage approval = approvals[_destination][_amount]; // Create new project\n\n       bool coinciedeParties = false;\n       for (uint i=0; i<approval.coinciedeParties.length; i++) {\n          if (approval.coinciedeParties[i] == msg.sender) coinciedeParties = true;\n       }\n\n       require(!coinciedeParties, \"Release: party already approved\");\n\n       if (approval.coincieded == 0) {\n           nonce += 1;\n           approval.nonce = nonce;\n       }\n\n       approval.coinciedeParties.push(msg.sender);\n       approval.coincieded += 1;\n\n       if (_skipServiceFee) {\n           approval.skipFee = true;\n       }\n\n       emit ConfirmationReceived(msg.sender, _destination, currencyAddress, _amount);\n\n       if ( approval.coincieded >= signatureMinThreshold ) {\n           releaseFunds(_destination, _amount, approval.skipFee);\n           finished[approval.nonce] = true;\n           delete approvals[_destination][_amount];\n\n           emit ConsensusAchived(_destination, currencyAddress, _amount);\n       }\n\n      return false;\n    }\n\n    function releaseFunds(\n      address payable _destination,\n      uint256 _amount,\n      bool    _skipServiceFee\n    ) internal {\n        if (_skipServiceFee) {\n            _destination.transfer(_amount); // Release funds\n        } else {\n            uint256 _amountToWithhold = _amount.mul(serviceFeeMicro).div(1000000);\n            uint256 _amountToRelease = _amount.sub(_amountToWithhold);\n\n            _destination.transfer(_amountToRelease); // Release funds\n            address payable _serviceAddress = address(uint160(serviceAddress())); // convert service address to payable\n            _serviceAddress.transfer(_amountToWithhold);   // Take service margin\n        }\n    }\n\n    function etherAddress() public pure returns (address) {\n        return address(0x1);\n    }\n\n    function serviceAddress() public pure returns (address) {\n        return address(0x0A67A2cdC35D7Db352CfBd84fFF5e5F531dF62d1);\n    }\n\n    function () external payable {}\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_signatureMinThreshold\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"_parties\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConfirmationReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConsensusAchived\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvals\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"coincieded\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"skipFee\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currencyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"finished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"parties\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_partyAddress\",\"type\":\"address\"}],\"name\":\"partyCoincieded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"regress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MultisigVaultETH","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000e77a1c4C2Dc90C39C0e9ACe410aB408d5d7235520000000000000000000000001f37b4c409b36b9e5cc03e29e82f27b927b20c09","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}