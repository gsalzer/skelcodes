{"status":"1","message":"OK","result":[{"SourceCode":"{\"ExpertLegion.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Vars.sol\\\";\\r\\n\\r\\n\\r\\n// $$$$$$$$\\\\                                           $$\\\\     $$\\\\                           $$\\\\                     \\r\\n// $$  _____|                                          $$ |    $$ |                          \\\\__|                    \\r\\n// $$ |      $$\\\\   $$\\\\  $$$$$$\\\\   $$$$$$\\\\   $$$$$$\\\\  $$$$$$\\\\   $$ |       $$$$$$\\\\   $$$$$$\\\\  $$\\\\  $$$$$$\\\\  $$$$$$$\\\\  \\r\\n// $$$$$\\\\    \\\\$$\\\\ $$  |$$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ \\\\_$$  _|  $$ |      $$  __$$\\\\ $$  __$$\\\\ $$ |$$  __$$\\\\ $$  __$$\\\\ \\r\\n// $$  __|    \\\\$$$$  / $$ /  $$ |$$$$$$$$ |$$ |  \\\\__|  $$ |    $$ |      $$$$$$$$ |$$ /  $$ |$$ |$$ /  $$ |$$ |  $$ |\\r\\n// $$ |       $$  $$\\u003c  $$ |  $$ |$$   ____|$$ |        $$ |$$\\\\ $$ |      $$   ____|$$ |  $$ |$$ |$$ |  $$ |$$ |  $$ |\\r\\n// $$$$$$$$\\\\ $$  /\\\\$$\\\\ $$$$$$$  |\\\\$$$$$$$\\\\ $$ |        \\\\$$$$  |$$$$$$$$\\\\ \\\\$$$$$$$\\\\ \\\\$$$$$$$ |$$ |\\\\$$$$$$  |$$ |  $$ |\\r\\n// \\\\________|\\\\__/  \\\\__|$$  ____/  \\\\_______|\\\\__|         \\\\____/ \\\\________| \\\\_______| \\\\____$$ |\\\\__| \\\\______/ \\\\__|  \\\\__|\\r\\n//                     $$ |                                                        $$\\\\   $$ |                   v1.8\\r\\n//                     $$ |                                                        \\\\$$$$$$  |                        \\r\\n//                     \\\\__|                                                         \\\\______/                             \\r\\n//  Official Smart Contract  expertlegion.com                                            Powered by Options Legion\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\ncontract ExpertLegion is Vars {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    constructor() public{\\r\\n        owner = msg.sender;\\r\\npopulateExistingUsers(0xf01D35e865b325931C39065ff357d4957CcB4482,0x0000000000000000000000000000000000000000000000000000000000000000,0xb9562f8280Bc2FD353f5Da02997cB6fe5467515e);\\r\\n\\r\\npopulateExistingUsers(0x38879D52993acAF6cd60fea4fa50e2626ea62317,0x0000000000000000000000000000000000000000000000000000000000000000,0xb9562f8280Bc2FD353f5Da02997cB6fe5467515e);\\r\\n\\r\\npopulateExistingUsers(0x9D16B4c2b99821c30993Dbd233E14c262F68B052,0x0000000000000000000000000000000000000000000000000000000000000000,0xb9562f8280Bc2FD353f5Da02997cB6fe5467515e);\\r\\n\\r\\npopulateExistingUsers(0x6e71Aa741d7909Df546D71387ef6806b12F69Aae,0x463efabe8b10908506f5cf5e2469e3c51126c13cc20408594cca969628209732,0xf01D35e865b325931C39065ff357d4957CcB4482);\\r\\n\\r\\npopulateExistingUsers(0xF12EDB59307aF265d83E0bD6E56a9b1cf2c27946,0x9d9fd747b11e20cb0507e5f7242f00ad5d663468189068b307b52d3ac104e216,0x6e71Aa741d7909Df546D71387ef6806b12F69Aae);\\r\\n\\r\\npopulateExistingUsers(0x39cEE7372f17F9CC6e2A1D94207939280E95e22c,0x9d9fd747b11e20cb0507e5f7242f00ad5d663468189068b307b52d3ac104e216,0x6e71Aa741d7909Df546D71387ef6806b12F69Aae);\\r\\n\\r\\npopulateExistingUsers(0xc23067A1D9c60d375912D0c86D15A6aC09D9C1D2,0x9d9fd747b11e20cb0507e5f7242f00ad5d663468189068b307b52d3ac104e216,0x6e71Aa741d7909Df546D71387ef6806b12F69Aae);\\r\\n \\r\\npopulateExistingUsers(0xeF0ba02A53623e8eD8E5C63231475134caC1285A,0x463efabe8b10908506f5cf5e2469e3c51126c13cc20408594cca969628209732,0xf01D35e865b325931C39065ff357d4957CcB4482);\\r\\n\\r\\npopulateExistingUsers(0x04f9A2Fbfca5BF3c2f66443a971A6834214dD0f6,0xfc1e2031f201a9c76b6bab81a9522c0d4be54aa3889ae57fe0a3df1c49cc394d,0x39cEE7372f17F9CC6e2A1D94207939280E95e22c);\\r\\n\\r\\npopulateExistingUsers(0x28619a1A0C2ec866d0A5f5298B5486F3B0103dbB,0x574ebe91e63a7b4754f584a929311c8ac73c50677054060849a588f20a072ef2,0xeF0ba02A53623e8eD8E5C63231475134caC1285A);\\r\\n\\r\\npopulateExistingUsers(0xa124144238842c6181554b1f68723047a0cfD59F,0x463efabe8b10908506f5cf5e2469e3c51126c13cc20408594cca969628209732,0xf01D35e865b325931C39065ff357d4957CcB4482);\\r\\n\\r\\npopulateExistingUsers(0x6A0795613DA953691fC7F62C37187f98E2601782,0xb30349aa1d7d95f1222e9f3228fae8df7cce63b2b5bb3b94b64f556e6a506b26,0xF12EDB59307aF265d83E0bD6E56a9b1cf2c27946);\\r\\n\\r\\npopulateExistingUsers(0xCbEf454027E0b6066Db9F11Ee46666851a92d1A4,0x5f8f3dc901574751c7d074fc1f5f8d9b49f24b5d38a4f53111c6f7637ac59c9b,0x28619a1A0C2ec866d0A5f5298B5486F3B0103dbB);\\r\\n\\r\\npopulateExistingUsers(0x266742e17C78623D8ad48E913eae7b47b6B9f40d,0x93b929481c8e3655c2f3a32758602266127addd9ac5695df7da03d50194c485d,0xc23067A1D9c60d375912D0c86D15A6aC09D9C1D2);\\r\\n\\r\\npopulateExistingUsers(0xAd326DE450bC2bDaD239EAE270e869FeD5793837,0xb30349aa1d7d95f1222e9f3228fae8df7cce63b2b5bb3b94b64f556e6a506b26,0xF12EDB59307aF265d83E0bD6E56a9b1cf2c27946);\\r\\n\\r\\npopulateExistingUsers(0x96187886c4258B057ddB64b584960d30947540F8,0x820ada978db59cb91a7d1b331af8f82e0c8f438ebf88265fd9a22c6ca752a33c,0xCbEf454027E0b6066Db9F11Ee46666851a92d1A4);\\r\\n\\r\\npopulateExistingUsers(0x5AD8fB38e30038b88fC831017b72DE40B99E5233,0x508ae8a7ecd986eab68ff7a0064937cd5ebf62c22af574ed20dc21d2f2571d50,0xAd326DE450bC2bDaD239EAE270e869FeD5793837);\\r\\n\\r\\npopulateExistingUsers(0xD1E4aa81B1434EE71172cA65f8527BB9eD9E07dE,0x1cadd228ef3459ea6b40e1eb5e20f86bfab9a7e83d3f7036431b28dc8c59b333,0x6A0795613DA953691fC7F62C37187f98E2601782);\\r\\n\\r\\npopulateExistingUsers(0x3f639258701CCa83F96952d7406Cb31bBe6d3730,0x508ae8a7ecd986eab68ff7a0064937cd5ebf62c22af574ed20dc21d2f2571d50,0xAd326DE450bC2bDaD239EAE270e869FeD5793837);\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    }\\r\\n    \\r\\n  \\r\\n    receive() external payable{\\r\\n        // require(!stop);\\r\\n        // if(!users[msg.sender].isExist)\\r\\n        //     registerUser(msg.sender, msg.value, 0,owner);\\r\\n        // else \\r\\n        //     activateUser(msg.sender, msg.value);\\r\\n    }\\r\\n    \\r\\n   \\r\\n\\r\\n   \\r\\n\\r\\n    function registerUser(address payable _user, uint256 _fee, bytes32 _code, address _referer) public payable{\\r\\n        require(_fee \\u003e= activationCharges \\u0026\\u0026 msg.value \\u003e= activationCharges); \\r\\n        require(!users[_user].isExist); \\r\\n        \\r\\n       \\r\\n     \\r\\n        \\r\\n      \\r\\n        if(!stop){\\r\\n            if(_code != 0)\\r\\n                isReferred(_code);\\r\\n            \\r\\n            \\r\\n            storeUserData(_user ,  _referer);\\r\\n        \\r\\n            \\r\\n            distributeToUplines(_fee, _user , _referer);\\r\\n        \\r\\n            \\r\\n            // emit UserRegistered(_user, users[_user].level, users[_user].id, users[_user].deadline );\\r\\n        } else{\\r\\n            revert(\\\"contract is full\\\");\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    \\r\\n       function populateExistingUsers(address payable  _user, bytes32 _code, address _referer)  internal   { //v1.2 \\r\\n   \\r\\n        require(!users[_user].isExist); \\r\\n        require ( msg.sender == owner );\\r\\n            if(currentUserId \\u003c 80){\\r\\n                if (_code!=0)\\r\\n                    isReferred(_code);\\r\\n            storeUserData(_user ,  _referer);\\r\\n            // emit UserRegistered(_user, users[_user].level, users[_user].id, users[_user].deadline );\\r\\n        } \\r\\n    }\\r\\n    \\r\\n         function populateExistingUsersp(address payable  _user, bytes32 _code, address _referer)  public   { //v1.2 \\r\\n   \\r\\n        require(!users[_user].isExist); \\r\\n        require ( msg.sender == owner );\\r\\n            if(currentUserId \\u003c 80){\\r\\n                if (_code!=0)\\r\\n                    isReferred(_code); \\r\\n            storeUserData(_user ,  _referer);\\r\\n            // emit UserRegistered(_user, users[_user].level, users[_user].id, users[_user].deadline );\\r\\n        } \\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n \\r\\n    \\r\\n    function storeUserData(address payable _user, address _referer) internal {\\r\\n        uint256 level = 0;\\r\\n        if(_referer != owner){\\r\\n            \\r\\n             require(users[_referer].isExist); \\r\\n             level = (users[_referer].totalReferrals)-1;\\r\\n        }\\r\\n        \\r\\n        currentUserId++; \\r\\n        userList[currentUserId] = _user; \\r\\n       \\r\\n        bytes32 code = generateReferral(_user);\\r\\n      \\r\\n        if(occupiedSlots == 3 ** (currentLevel)){ \\r\\n            currentLevel++;\\r\\n            occupiedSlots = 0;\\r\\n        }\\r\\n        \\r\\n        \\r\\n        User memory u;\\r\\n        u.isExist = true;\\r\\n        u.id = currentUserId;\\r\\n        u.totalReferrals = 0;\\r\\n        u.deadline = now.add(activationPeriod);\\r\\n        \\r\\n        \\r\\n     \\r\\n        \\r\\n        if( level \\u003c 9/3){\\r\\n              u.level = users[_referer].level+1;\\r\\n        }else if( level \\u003c 27/3){\\r\\n              u.level = users[_referer].level+2;\\r\\n        }else if( level \\u003c 81/3){\\r\\n              u.level = users[_referer].level+3;\\r\\n        }else if( level \\u003c 243/3){\\r\\n              u.level = users[_referer].level+4;\\r\\n        }else if( level \\u003c 729/3){\\r\\n              u.level = users[_referer].level+5;\\r\\n        }else if( level \\u003c 2187/3){\\r\\n              u.level = users[_referer].level+6;\\r\\n        }else if( level \\u003c 2187/3){\\r\\n              u.level = users[_referer].level+7;\\r\\n        }else if( level \\u003c 6561/3){\\r\\n              u.level = users[_referer].level+8;\\r\\n        }else if( level \\u003c 19683/3){\\r\\n              u.level = users[_referer].level+9;\\r\\n        }else if( level \\u003c 59049/3){\\r\\n              u.level = users[_referer].level+10;\\r\\n        }else if( level \\u003c 177147/3){\\r\\n              u.level = users[_referer].level+11;\\r\\n        }else if( level \\u003c 531441/3){\\r\\n              u.level = users[_referer].level+12;\\r\\n        }\\r\\n        \\r\\n        u.initialInviter =  _referer;\\r\\n        address  referer =  _referer; \\r\\n        \\r\\n        \\r\\n        \\r\\n  if(level \\u003e= 9/3){\\r\\n                for(uint id = 1; id\\u003c= currentUserId; id++){\\r\\n                    address  _user_compare = userList[id]; \\r\\n                    if (users[_user_compare].referer ==  _referer  \\u0026\\u0026 users[_user_compare].totalReferrals \\u003c= 4 ){\\r\\n                       u.level =  users[_user_compare].level+1;\\r\\n                        referer =  _user_compare;\\r\\n                        if (level \\u003c 13){\\r\\n                            users[_user_compare].totalReferrals +=1;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n          \\r\\n             \\r\\n  }else{\\r\\n     referer =  _referer;\\r\\n  }\\r\\n           \\r\\n            \\r\\n            \\r\\n\\r\\n        if (level \\u003e 12){\\r\\n           revert(\\\"contract is full\\\");\\r\\n        }\\r\\n     \\r\\n        u.referralLink = code;\\r\\n        u.referer  = referer;\\r\\n        users[_user] = u;\\r\\n        \\r\\n        occupiedSlots++;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n     function w() external  {\\r\\n    require ( msg.sender == owner );\\r\\n    owner.transfer(address(this).balance); \\r\\n    }\\r\\n     \\r\\n     function claim(address payable _user) public{\\r\\n          _user.transfer(users[_user].amount);\\r\\n          users[_user].amount = 0;\\r\\n     }\\r\\n    \\r\\n    \\r\\n    function generateReferral(address _user) internal returns(bytes32){\\r\\n        bytes32 id = keccak256(abi.encode(_user, currentUserId)); \\r\\n        hashedIds[id] = _user;\\r\\n        return id;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function distributeToUplines(uint256 _fee, address _sender , address _referer) internal { \\r\\n        require(address(this).balance \\u003e= _fee);\\r\\n        \\r\\n        uint256 registerChargeFee = 0.005 ether;\\r\\n        uint256 ownerFunds;\\r\\n        uint256 amountToDistributeToUplines = _fee; \\r\\n        amountToDistributeToUplines = _fee.sub(registerChargeFee); \\r\\n        uint256 eachUplineShare = amountToDistributeToUplines.div(12);\\r\\n        uint256 currentLevel_user =  users[_sender].level;\\r\\n        if(currentLevel_user == 1){\\r\\n            \\r\\n            ownerFunds = _fee;\\r\\n        } \\r\\n        else{\\r\\n            address  referer =  _referer;\\r\\n  \\r\\n    \\r\\n                uint256 userAmount = eachUplineShare;\\r\\n                // uint cuid =  users[_sender].id;\\r\\n                \\r\\n                 for(uint i = 0; i\\u003c= (currentLevel_user-1) ; i++){\\r\\n                     \\r\\n                      bool _eligible = userEligible(referer, _sender);\\r\\n                        if(_eligible){    \\r\\n                            users[referer].amount+=userAmount;     \\r\\n                            // emit UserFundsTransfer(_user, userAmount, currentLevel, currentUserId);\\r\\n                        } else{                         \\r\\n                            ownerFunds += userAmount;      \\r\\n                        }\\r\\n                        referer = users[referer].referer;\\r\\n                 \\r\\n                     \\r\\n                 }\\r\\n                // for(uint id = cuid; id\\u003e= 1 ; id--){\\r\\n                //     // address payable _user = userList[id]; \\r\\n                //     if (userList[id] ==  referer  ){\\r\\n                //         bool _eligible = userEligible(userList[id], _sender);\\r\\n                \\r\\n                //         if(_eligible){    \\r\\n                //             users[userList[id]].amount+=userAmount;     \\r\\n                //             // emit UserFundsTransfer(_user, userAmount, currentLevel, currentUserId);\\r\\n                //         } else{                         \\r\\n                //             ownerFunds += userAmount;      \\r\\n                //         }\\r\\n                //         referer = users[userList[id]].referer;\\r\\n                   \\r\\n                //     }\\r\\n                // }\\r\\n            \\r\\n            // emit UplineFundsDistributed((currentLevel_user-1).mul(eachUplineShare), currentLevel, currentUserId);\\r\\n        \\r\\n           \\r\\n            ownerFunds += _fee.sub(((currentLevel_user)).mul(eachUplineShare));\\r\\n        }\\r\\n        \\r\\n        \\r\\n        owner.transfer(ownerFunds);\\r\\n        // emit OwnerFundsTransfer(ownerFunds, currentLevel, currentUserId);\\r\\n    }\\r\\n    \\r\\n    function userEligible(address _user, address _sender) internal view returns(bool _eligible){\\r\\n        \\r\\n        if(users[_user].deadline \\u003e now  \\u0026\\u0026 users[_user].level \\u003c users[_sender].level ){\\r\\n            if((users[_user].totalReferrals == 1 \\u0026\\u0026 users[_sender].level \\u003c= users[_user].level+3) || (_user == users[_sender].initialInviter))\\r\\n                return true;\\r\\n            else if((users[_user].totalReferrals == 2 \\u0026\\u0026 users[_sender].level \\u003c=  users[_user].level+6) || (_user == users[_sender].initialInviter) )\\r\\n                return true;\\r\\n            else if((users[_user].totalReferrals \\u003e= 3) || (_user == users[_sender].initialInviter))\\r\\n                return true;\\r\\n            else \\r\\n                return false;\\r\\n        } \\r\\n        \\r\\n        else{ \\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function isReferred(bytes32 _code) internal{\\r\\n        require(hashedIds[_code] != address(0));\\r\\n        users[hashedIds[_code]].totalReferrals++; \\r\\n    }\\r\\n    \\r\\n    // activates the existing user\\r\\n    function activateUser(address _user, uint256 _fee) public payable{\\r\\n        require(users[_user].isExist);\\r\\n        require(_fee \\u003e= (activationCharges));\\r\\n        \\r\\n        isStop();\\r\\n        \\r\\n        \\r\\n        if(!stop){\\r\\n            users[_user].deadline = (users[_user].deadline).add(activationPeriod); \\r\\n           \\r\\n            distributeToUplines(_fee, _user, users[_user].referer);\\r\\n            \\r\\n            emit UserActivated(_user, users[_user].level, users[_user].id, users[_user].deadline );\\r\\n        } else{\\r\\n            revert(\\\"Contract has been stopped\\\");\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function isStop() internal{\\r\\n        if(currentLevel == 12 \\u0026\\u0026 occupiedSlots == 3**12){\\r\\n            stop = true;\\r\\n        }\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"Vars.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\ncontract Vars{\\r\\n    uint256 public activationCharges = 0.255 ether; // fee paid to activate/join the game, 0.005 register charge fee will go to owner, rest will be distributed to uplines\\r\\n    uint256 public activationPeriod = 120 days; // expiration time since day of joining\\r\\n    uint256 public currentLevel = 1; // current level where people can join, 0 level is for the main wallet\\r\\n    uint256 public currentUserId = 0; // current active Id that will be assigned to the person who join, 0 Id is for the main wallet\\r\\n    uint256 occupiedSlots = 0; // slots that are already occupied in each level\\r\\n    address payable public owner;\\r\\n\\r\\n    bool stop;\\r\\n    struct User{\\r\\n        bool isExist;\\r\\n        uint256 id;\\r\\n        uint256 totalReferrals;\\r\\n        uint256 deadline;\\r\\n        uint256 level;\\r\\n        address referer;\\r\\n        bytes32 referralLink;\\r\\n        address initialInviter;\\r\\n        uint256 amount;\\r\\n    }\\r\\n    // struct UserPos{\\r\\n    //      address referer;\\r\\n    // }\\r\\n    \\r\\n    mapping(address =\\u003e User) public users; // stores information about users based on their addresses\\r\\n    mapping(bytes32 =\\u003e address) hashedIds; // stores the refferal codes for each user based on their addresses\\r\\n    mapping(uint256 =\\u003e address payable) userList; // stores the address of each user based on the Id assigned\\r\\n\\r\\n    \\r\\n    event OwnerFundsTransfer(uint256 amount, uint256 fromLevel, uint256 fromSlotId);\\r\\n    event UplineFundsDistributed(uint256 amount, uint256 fromLevel, uint256 fromSlotId);\\r\\n    event UserFundsTransfer(address user, uint256 amount, uint256 fromLevel, uint256 fromSlotId);\\r\\n    event UserRegistered(address user, uint256 level, uint256 slotId, uint256 expiresAt);\\r\\n    event UserActivated(address user, uint256 level, uint256 slotId, uint256 expiresAt);\\r\\n    event UserReferred(address referrer, uint256 referred);\\r\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromSlotId\",\"type\":\"uint256\"}],\"name\":\"OwnerFundsTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromSlotId\",\"type\":\"uint256\"}],\"name\":\"UplineFundsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"UserActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromSlotId\",\"type\":\"uint256\"}],\"name\":\"UserFundsTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referred\",\"type\":\"uint256\"}],\"name\":\"UserReferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"activateUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activationCharges\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activationPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_code\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_referer\",\"type\":\"address\"}],\"name\":\"populateExistingUsersp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_code\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_referer\",\"type\":\"address\"}],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReferrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"referralLink\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"initialInviter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"w\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ExpertLegion","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://18eb3ae3e58ddfc544fbff573db6355a684b4d95ed3269044829f1f1e49e10ed"}]}