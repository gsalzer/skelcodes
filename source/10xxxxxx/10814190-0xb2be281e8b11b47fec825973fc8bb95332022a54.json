{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/core/Router.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n    TransactionData,\\n    Action,\\n    TokenAmount,\\n    Fee,\\n    AbsoluteTokenAmount,\\n    AmountType\\n} from \\\"../shared/Structs.sol\\\";\\nimport { ERC20 } from \\\"../shared/ERC20.sol\\\";\\nimport { SafeERC20 } from \\\"../shared/SafeERC20.sol\\\";\\nimport { SignatureVerifier } from \\\"./SignatureVerifier.sol\\\";\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\nimport { Core } from \\\"./Core.sol\\\";\\n\\n\\ninterface Chi {\\n    function freeUpTo(uint256) external;\\n}\\n\\n\\ncontract Router is SignatureVerifier(\\\"Zerion Router\\\"), Ownable {\\n    using SafeERC20 for ERC20;\\n\\n    address internal immutable core_;\\n\\n    address internal constant CHI = 0x0000000000004946c0e9F43F4Dee607b0eF1fA1c;\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    uint256 internal constant DELIMITER = 1e18; // 100%\\n    uint256 internal constant FEE_LIMIT = 1e16; // 1%\\n\\n    constructor(address payable core) public {\\n        require(core != address(0), \\\"R: empty core\\\");\\n        core_ = core;\\n    }\\n\\n    function returnLostTokens(\\n        address token,\\n        address payable beneficiary\\n    )\\n        external\\n        onlyOwner\\n    {\\n        if (token == ETH) {\\n            (bool success, ) = beneficiary.call{value: address(this).balance}(new bytes(0));\\n            require(success, \\\"R: bad beneficiary\\\");\\n        } else {\\n            ERC20(token).safeTransfer(beneficiary, ERC20(token).balanceOf(address(this)), \\\"R\\\");\\n        }\\n    }\\n\\n    function getRequiredAllowances(\\n        TokenAmount[] calldata inputs,\\n        address account\\n    )\\n        external\\n        view\\n        returns (AbsoluteTokenAmount[] memory)\\n    {\\n        uint256 length = inputs.length;\\n        AbsoluteTokenAmount[] memory requiredAllowances = new AbsoluteTokenAmount[](length);\\n        uint256 required;\\n        uint256 current;\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            required = getAbsoluteAmount(inputs[i], account);\\n            current = ERC20(inputs[i].token).allowance(account, address(this));\\n\\n            requiredAllowances[i] = AbsoluteTokenAmount({\\n                token: inputs[i].token,\\n                amount: required > current ? required - current : 0\\n            });\\n        }\\n\\n        return requiredAllowances;\\n    }\\n\\n    function getRequiredBalances(\\n        TokenAmount[] calldata inputs,\\n        address account\\n    )\\n        external\\n        view\\n        returns (AbsoluteTokenAmount[] memory)\\n    {\\n        uint256 length = inputs.length;\\n        AbsoluteTokenAmount[] memory requiredBalances = new AbsoluteTokenAmount[](length);\\n        uint256 required;\\n        uint256 current;\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            required = getAbsoluteAmount(inputs[i], account);\\n            current = ERC20(inputs[i].token).balanceOf(account);\\n\\n            requiredBalances[i] = AbsoluteTokenAmount({\\n                token: inputs[i].token,\\n                amount: required > current ? required - current : 0\\n            });\\n        }\\n\\n        return requiredBalances;\\n    }\\n\\n    /**\\n     * @return Address of the Core contract used.\\n     */\\n    function core()\\n        external\\n        view\\n        returns (address)\\n    {\\n        return core_;\\n    }\\n\\n    function startExecution(\\n        TransactionData memory data,\\n        bytes memory signature\\n    )\\n        public\\n        payable\\n        returns (AbsoluteTokenAmount[] memory)\\n    {\\n        address payable account = getAccountFromSignature(data, signature);\\n\\n        updateNonce(account);\\n\\n        return startExecution(\\n            data.actions,\\n            data.inputs,\\n            data.fee,\\n            data.requiredOutputs,\\n            account\\n        );\\n    }\\n\\n    function startExecution(\\n        Action[] memory actions,\\n        TokenAmount[] memory inputs,\\n        Fee memory fee,\\n        AbsoluteTokenAmount[] memory requiredOutputs\\n    )\\n        public\\n        payable\\n        returns (AbsoluteTokenAmount[] memory)\\n    {\\n        return startExecution(\\n            actions,\\n            inputs,\\n            fee,\\n            requiredOutputs,\\n            msg.sender\\n        );\\n    }\\n\\n    function startExecution(\\n        Action[] memory actions,\\n        TokenAmount[] memory inputs,\\n        Fee memory fee,\\n        AbsoluteTokenAmount[] memory requiredOutputs,\\n        address payable account\\n    )\\n        internal\\n        returns (AbsoluteTokenAmount[] memory)\\n    {\\n        // save initial gas to burn gas token later\\n        uint256 gas = gasleft();\\n        // transfer tokens to core_, handle fees (if any), and add these tokens to outputs\\n        transferTokens(inputs, fee, account);\\n        AbsoluteTokenAmount[] memory modifiedOutputs = modifyOutputs(requiredOutputs, inputs);\\n        // call Core contract with all provided ETH, actions, expected outputs and account address\\n        AbsoluteTokenAmount[] memory actualOutputs = Core(payable(core_)).executeActions(\\n            actions,\\n            modifiedOutputs,\\n            account\\n        );\\n        // try to burn gas token to save some gas\\n        uint256 gasSpent = 21000 + gas - gasleft() + 16 * msg.data.length;\\n        Chi(CHI).freeUpTo((gasSpent + 14154) / 41130);\\n        // return tokens that were returned to the account address\\n        return actualOutputs;\\n    }\\n\\n    function transferTokens(\\n        TokenAmount[] memory inputs,\\n        Fee memory fee,\\n        address account\\n    )\\n        internal\\n    {\\n        address token;\\n        uint256 absoluteAmount;\\n        uint256 feeAmount;\\n        uint256 length = inputs.length;\\n\\n        if (fee.share > 0) {\\n            require(fee.beneficiary != address(0), \\\"R: bad beneficiary\\\");\\n            require(fee.share <= FEE_LIMIT, \\\"R: bad fee\\\");\\n        }\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            token = inputs[i].token;\\n            absoluteAmount = getAbsoluteAmount(inputs[i], account);\\n            require(absoluteAmount > 0, \\\"R: zero amount\\\");\\n\\n            feeAmount = mul(absoluteAmount, fee.share) / DELIMITER;\\n\\n            if (feeAmount > 0) {\\n                ERC20(token).safeTransferFrom(\\n                    account,\\n                    fee.beneficiary,\\n                    feeAmount,\\n                    \\\"R[1]\\\"\\n                );\\n            }\\n\\n            ERC20(token).safeTransferFrom(\\n                account,\\n                core_,\\n                absoluteAmount - feeAmount,\\n                \\\"R[2]\\\"\\n            );\\n        }\\n\\n        if (msg.value > 0) {\\n            feeAmount = mul(msg.value, fee.share) / DELIMITER;\\n\\n            if (feeAmount > 0) {\\n                // solhint-disable-next-line avoid-low-level-calls\\n                (bool success, ) = fee.beneficiary.call{value: feeAmount}(new bytes(0));\\n                require(success, \\\"ETH transfer to beneficiary failed\\\");\\n            }\\n\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = core_.call{value: msg.value - feeAmount}(new bytes(0));\\n            require(success, \\\"ETH transfer to Core failed\\\");\\n        }\\n    }\\n\\n    function getAbsoluteAmount(\\n        TokenAmount memory tokenAmount,\\n        address account\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        address token = tokenAmount.token;\\n        AmountType amountType = tokenAmount.amountType;\\n        uint256 amount = tokenAmount.amount;\\n\\n        require(\\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\\n            \\\"R: bad amount type\\\"\\n        );\\n\\n        if (amountType == AmountType.Relative) {\\n            require(amount <= DELIMITER, \\\"R: bad amount\\\");\\n            if (amount == DELIMITER) {\\n                return ERC20(token).balanceOf(account);\\n            } else {\\n                return mul(ERC20(token).balanceOf(account), amount) / DELIMITER;\\n            }\\n        } else {\\n            return amount;\\n        }\\n    }\\n\\n    function modifyOutputs(\\n        AbsoluteTokenAmount[] memory requiredOutputs,\\n        TokenAmount[] memory inputs\\n    )\\n        internal\\n        view\\n        returns (AbsoluteTokenAmount[] memory)\\n    {\\n        uint256 ethInput = msg.value > 0 ? 1 : 0;\\n        AbsoluteTokenAmount[] memory modifiedOutputs = new AbsoluteTokenAmount[](\\n            requiredOutputs.length + inputs.length + ethInput\\n        );\\n\\n        for (uint256 i = 0; i < requiredOutputs.length; i++) {\\n            modifiedOutputs[i] = requiredOutputs[i];\\n        }\\n\\n        for (uint256 i = 0; i < inputs.length; i++) {\\n            modifiedOutputs[requiredOutputs.length + i] = AbsoluteTokenAmount({\\n                token: inputs[i].token,\\n                amount: 0\\n            });\\n        }\\n\\n        if (ethInput > 0) {\\n            modifiedOutputs[requiredOutputs.length + inputs.length] = AbsoluteTokenAmount({\\n                token: ETH,\\n                amount: 0\\n            });\\n        }\\n\\n        return modifiedOutputs;\\n    }\\n\\n    function mul(\\n        uint256 a,\\n        uint256 b\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"R: mul overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/shared/ERC20.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface ERC20 {\\n    function approve(address, uint256) external returns (bool);\\n    function transfer(address, uint256) external returns (bool);\\n    function transferFrom(address, address, uint256) external returns (bool);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address) external view returns (uint256);\\n    function allowance(address, address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/shared/SafeERC20.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token contract\\n * returns false). Tokens that return no value (and instead revert or throw on failure)\\n * are also supported, non-reverting calls are assumed to be successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 value,\\n        string memory location\\n    )\\n        internal\\n    {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.transfer.selector,\\n                to,\\n                value\\n            ),\\n            \\\"transfer\\\",\\n            location\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        string memory location\\n    )\\n        internal\\n    {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.transferFrom.selector,\\n                from,\\n                to,\\n                value\\n            ),\\n            \\\"transferFrom\\\",\\n            location\\n        );\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address spender,\\n        uint256 value,\\n        string memory location\\n    )\\n        internal\\n    {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: bad approve call\\\"\\n        );\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                value\\n            ),\\n            \\\"approve\\\",\\n            location\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\\n     * relaxing the requirement on the return value: the return value is optional\\n     * (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     * @param location Location of the call (for debug).\\n     */\\n    function callOptionalReturn(\\n        ERC20 token,\\n        bytes memory data,\\n        string memory functionName,\\n        string memory location\\n    )\\n        private\\n    {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking\\n        // mechanism, since we're implementing it ourselves.\\n\\n        // We implement two-steps call as callee is a contract is a responsibility of a caller.\\n        //  1. The call itself is made, and success asserted\\n        //  2. The return value is decoded, which in turn checks the size of the returned data.\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(\\n            success,\\n            string(\\n                abi.encodePacked(\\n                    \\\"SafeERC20: \\\",\\n                    functionName,\\n                    \\\" failed in \\\",\\n                    location\\n                )\\n            )\\n        );\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            require(\\n                abi.decode(returndata, (bool)),\\n                string(\\n                    abi.encodePacked(\\n                        \\\"SafeERC20: \\\",\\n                        functionName,\\n                        \\\" returned false in \\\",\\n                        location\\n                    )\\n                )\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/core/SignatureVerifier.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport { TransactionData, Action, AbsoluteTokenAmount, Fee, TokenAmount } from \\\"../shared/Structs.sol\\\";\\n\\n\\ncontract SignatureVerifier {\\n\\n    mapping (address => uint256) internal nonce_;\\n\\n    bytes32 internal immutable domainSeparator_;\\n\\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            \\\"EIP712Domain(\\\",\\n            \\\"string name,\\\",\\n            \\\"address verifyingContract\\\",\\n            \\\")\\\"\\n        )\\n    );\\n    bytes32 internal constant TX_DATA_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            TX_DATA_ENCODED_TYPE,\\n            ABSOLUTE_TOKEN_AMOUNT_ENCODED_TYPE,\\n            ACTION_ENCODED_TYPE,\\n            FEE_ENCODED_TYPE,\\n            TOKEN_AMOUNT_ENCODED_TYPE\\n        )\\n    );\\n    bytes32 internal constant ABSOLUTE_TOKEN_AMOUNT_TYPEHASH =\\n        keccak256(ABSOLUTE_TOKEN_AMOUNT_ENCODED_TYPE);\\n    bytes32 internal constant ACTION_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            ACTION_ENCODED_TYPE,\\n            TOKEN_AMOUNT_ENCODED_TYPE\\n        )\\n    );\\n    bytes32 internal constant FEE_TYPEHASH = keccak256(FEE_ENCODED_TYPE);\\n    bytes32 internal constant TOKEN_AMOUNT_TYPEHASH = keccak256(TOKEN_AMOUNT_ENCODED_TYPE);\\n\\n    bytes internal constant TX_DATA_ENCODED_TYPE = abi.encodePacked(\\n        \\\"TransactionData(\\\",\\n        \\\"Action[] actions,\\\",\\n        \\\"TokenAmount[] inputs,\\\",\\n        \\\"Fee fee,\\\",\\n        \\\"AbsoluteTokenAmount[] requiredOutputs,\\\",\\n        \\\"uint256 nonce\\\",\\n        \\\")\\\"\\n    );\\n    bytes internal constant ABSOLUTE_TOKEN_AMOUNT_ENCODED_TYPE = abi.encodePacked(\\n        \\\"AbsoluteTokenAmount(\\\",\\n        \\\"address token,\\\",\\n        \\\"uint256 amount\\\",\\n        \\\")\\\"\\n    );\\n    bytes internal constant ACTION_ENCODED_TYPE = abi.encodePacked(\\n        \\\"Action(\\\",\\n        \\\"bytes32 protocolAdapterName,\\\",\\n        \\\"uint8 actionType,\\\",\\n        \\\"TokenAmount[] tokenAmounts,\\\",\\n        \\\"bytes data\\\",\\n        \\\")\\\"\\n    );\\n    bytes internal constant FEE_ENCODED_TYPE = abi.encodePacked(\\n        \\\"Fee(\\\",\\n        \\\"uint256 share,\\\",\\n        \\\"address beneficiary\\\",\\n        \\\")\\\"\\n    );\\n    bytes internal constant TOKEN_AMOUNT_ENCODED_TYPE = abi.encodePacked(\\n        \\\"TokenAmount(\\\",\\n        \\\"address token,\\\",\\n        \\\"uint256 amount,\\\",\\n        \\\"uint8 amountType\\\",\\n        \\\")\\\"\\n    );\\n\\n    constructor(string memory name) public {\\n        domainSeparator_ = keccak256(\\n            abi.encode(\\n                DOMAIN_SEPARATOR_TYPEHASH,\\n                keccak256(abi.encodePacked(name)),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @return Address of the Core contract used.\\n     */\\n    function nonce(\\n        address account\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return nonce_[account];\\n    }\\n\\n    function updateNonce(\\n        address account\\n    )\\n        internal\\n    {\\n        nonce_[account]++;\\n    }\\n\\n    function getAccountFromSignature(\\n        TransactionData memory data,\\n        bytes memory signature\\n    )\\n        public\\n        view\\n        returns (address payable)\\n    {\\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);\\n\\n        bytes32 hashedData = keccak256(\\n            abi.encodePacked(\\n                bytes1(0x19),\\n                bytes1(0x01),\\n                domainSeparator_,\\n                hash(data)\\n            )\\n        );\\n\\n        address signer = ecrecover(hashedData, v, r, s);\\n\\n        require(signer != address(0), \\\"SV: bad signature\\\");\\n        require(nonce_[signer] == data.nonce, \\\"SV: bad nonce\\\");\\n\\n        return payable(signer);\\n    }\\n\\n    /// @return Hash to be signed by tokens supplier.\\n    function hash(\\n        TransactionData memory data\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encode(\\n                TX_DATA_TYPEHASH,\\n                hash(data.actions),\\n                hash(data.inputs),\\n                hash(data.fee),\\n                hash(data.requiredOutputs),\\n                data.nonce\\n            )\\n        );\\n    }\\n\\n    function hash(\\n        Action[] memory actions\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory actionsData = new bytes(0);\\n\\n        uint256 length = actions.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            actionsData = abi.encodePacked(\\n                actionsData,\\n                keccak256(\\n                    abi.encode(\\n                        ACTION_TYPEHASH,\\n                        actions[i].protocolAdapterName,\\n                        actions[i].actionType,\\n                        hash(actions[i].tokenAmounts),\\n                        keccak256(actions[i].data)\\n                    )\\n                )\\n            );\\n        }\\n\\n        return keccak256(actionsData);\\n    }\\n\\n    function hash(\\n        TokenAmount[] memory tokenAmounts\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory tokenAmountsData = new bytes(0);\\n\\n        uint256 length = tokenAmounts.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            tokenAmountsData = abi.encodePacked(\\n                tokenAmountsData,\\n                keccak256(\\n                    abi.encode(\\n                        TOKEN_AMOUNT_TYPEHASH,\\n                        tokenAmounts[i].token,\\n                        tokenAmounts[i].amount,\\n                        tokenAmounts[i].amountType\\n                    )\\n                )\\n            );\\n        }\\n\\n        return keccak256(tokenAmountsData);\\n    }\\n\\n    function hash(\\n        Fee memory fee\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encode(\\n                FEE_TYPEHASH,\\n                fee.share,\\n                fee.beneficiary\\n            )\\n        );\\n    }\\n\\n    function hash(\\n        AbsoluteTokenAmount[] memory absoluteTokenAmounts\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory absoluteTokenAmountsData = new bytes(0);\\n\\n        uint256 length = absoluteTokenAmounts.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            absoluteTokenAmountsData = abi.encodePacked(\\n                absoluteTokenAmountsData,\\n                keccak256(\\n                    abi.encode(\\n                        ABSOLUTE_TOKEN_AMOUNT_TYPEHASH,\\n                        absoluteTokenAmounts[i].token,\\n                        absoluteTokenAmounts[i].amount\\n                    )\\n                )\\n            );\\n        }\\n\\n        return keccak256(absoluteTokenAmountsData);\\n    }\\n\\n    function splitSignature(\\n        bytes memory signature\\n    )\\n        internal\\n        pure\\n        returns (uint8 v, bytes32 r, bytes32 s)\\n    {\\n        require(signature.length == 65, \\\"SV: bad signature\\\");\\n\\n        assembly {\\n            // first 32 bytes, after the length prefix.\\n            r := mload(add(signature, 32))\\n            // second 32 bytes.\\n            s := mload(add(signature, 64))\\n            // final byte (first byte of the next 32 bytes).\\n            v := byte(0, mload(add(signature, 96)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        // Reference: github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert(\\\"SV: bad 's'\\\");\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert(\\\"SV: bad 'v'\\\");\\n        }\\n\\n        return (v, r, s);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/shared/Structs.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\n\\n// The struct consists of AbsoluteTokenAmount structs for\\n// (base) token and its underlying tokens (if any).\\nstruct FullAbsoluteTokenAmount {\\n    AbsoluteTokenAmountMeta base;\\n    AbsoluteTokenAmountMeta[] underlying;\\n}\\n\\n\\n// The struct consists of AbsoluteTokenAmount struct\\n// with token address and absolute amount\\n// and ERC20Metadata struct with ERC20-style metadata.\\n// NOTE: 0xEeee...EEeE address is used for ETH.\\nstruct AbsoluteTokenAmountMeta {\\n    AbsoluteTokenAmount absoluteTokenAmount;\\n    ERC20Metadata erc20metadata;\\n}\\n\\n\\n// The struct consists of ERC20-style token metadata.\\nstruct ERC20Metadata {\\n    string name;\\n    string symbol;\\n    uint8 decimals;\\n}\\n\\n\\n// The struct consists of protocol adapter's name\\n// and array of AbsoluteTokenAmount structs\\n// with token addresses and absolute amounts.\\nstruct AdapterBalance {\\n    bytes32 protocolAdapterName;\\n    AbsoluteTokenAmount[] absoluteTokenAmounts;\\n}\\n\\n\\n// The struct consists of token address\\n// and its absolute amount.\\nstruct AbsoluteTokenAmount {\\n    address token;\\n    uint256 amount;\\n}\\n\\n\\n// The struct consists of token address,\\n// and price per full share (1e18).\\nstruct Component {\\n    address token;\\n    uint256 rate;\\n}\\n\\n\\n//=============================== Interactive Adapters Structs ====================================\\n\\n\\nstruct TransactionData {\\n    Action[] actions;\\n    TokenAmount[] inputs;\\n    Fee fee;\\n    AbsoluteTokenAmount[] requiredOutputs;\\n    uint256 nonce;\\n}\\n\\n\\nstruct Action {\\n    bytes32 protocolAdapterName;\\n    ActionType actionType;\\n    TokenAmount[] tokenAmounts;\\n    bytes data;\\n}\\n\\n\\nstruct TokenAmount {\\n    address token;\\n    uint256 amount;\\n    AmountType amountType;\\n}\\n\\n\\nstruct Fee {\\n    uint256 share;\\n    address beneficiary;\\n}\\n\\n\\nenum ActionType { None, Deposit, Withdraw }\\n\\n\\nenum AmountType { None, Relative, Absolute }\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/core/Ownable.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\n\\nabstract contract Ownable {\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner_, \\\"O: only owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyPendingOwner {\\n        require(msg.sender == pendingOwner_, \\\"O: only pending owner\\\");\\n        _;\\n    }\\n\\n    address private owner_;\\n    address private pendingOwner_;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @notice Initializes owner variable with msg.sender address.\\n     */\\n    constructor() internal {\\n        owner_ = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @notice Sets pending owner to the desired address.\\n     * The function is callable only by the owner.\\n     */\\n    function proposeOwnership(address newOwner) external onlyOwner {\\n        require(newOwner != address(0), \\\"O: empty newOwner\\\");\\n        require(newOwner != owner_, \\\"O: equal to owner_\\\");\\n        require(newOwner != pendingOwner_, \\\"O: equal to pendingOwner_\\\");\\n        pendingOwner_ = newOwner;\\n    }\\n\\n    /**\\n     * @notice Transfers ownership to the pending owner.\\n     * The function is callable only by the pending owner.\\n     */\\n    function acceptOwnership() external onlyPendingOwner {\\n        emit OwnershipTransferred(owner_, msg.sender);\\n        owner_ = msg.sender;\\n        delete pendingOwner_;\\n    }\\n\\n    /**\\n     * @return Owner of the contract.\\n     */\\n    function owner() external view returns (address) {\\n        return owner_;\\n    }\\n\\n    /**\\n     * @return Pending owner of the contract.\\n     */\\n    function pendingOwner() external view returns (address) {\\n        return pendingOwner_;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/core/Core.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport { Action, AbsoluteTokenAmount, ActionType, AmountType } from \\\"../shared/Structs.sol\\\";\\nimport { InteractiveAdapter } from \\\"../interactiveAdapters/InteractiveAdapter.sol\\\";\\nimport { ERC20 } from \\\"../shared/ERC20.sol\\\";\\nimport { ProtocolAdapterRegistry } from \\\"./ProtocolAdapterRegistry.sol\\\";\\nimport { SafeERC20 } from \\\"../shared/SafeERC20.sol\\\";\\nimport { Helpers } from \\\"../shared/Helpers.sol\\\";\\nimport { ReentrancyGuard } from \\\"./ReentrancyGuard.sol\\\";\\n\\n\\n/**\\n * @title Main contract executing actions.\\n */\\ncontract Core is ReentrancyGuard {\\n    using SafeERC20 for ERC20;\\n\\n    address internal immutable protocolAdapterRegistry_;\\n\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    event ExecutedAction(Action action);\\n\\n    constructor(\\n        address protocolAdapterRegistry\\n    )\\n        public\\n    {\\n        require(protocolAdapterRegistry != address(0), \\\"C: empty protocolAdapterRegistry\\\");\\n        protocolAdapterRegistry_ = protocolAdapterRegistry;\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {}\\n\\n    /**\\n     * @notice Executes actions and returns tokens to account.\\n     * @param actions Array with actions to be executed.\\n     * @param requiredOutputs Array with required amounts for the returned tokens.\\n     * @param account Address that will receive all the resulting funds.\\n     * @return actualOutputs Array with actual amounts for the returned tokens.\\n     */\\n    function executeActions(\\n        Action[] calldata actions,\\n        AbsoluteTokenAmount[] calldata requiredOutputs,\\n        address payable account\\n    )\\n        external\\n        payable\\n        nonReentrant\\n        returns (AbsoluteTokenAmount[] memory)\\n    {\\n        require(account != address(0), \\\"C: empty account\\\");\\n        address[][] memory tokensToBeWithdrawn = new address[][](actions.length);\\n\\n        for (uint256 i = 0; i < actions.length; i++) {\\n            tokensToBeWithdrawn[i] = executeAction(actions[i]);\\n            emit ExecutedAction(actions[i]);\\n        }\\n\\n        return returnTokens(requiredOutputs, tokensToBeWithdrawn, account);\\n    }\\n\\n    /**\\n     * @notice Execute one action via external call.\\n     * @param action Action struct.\\n     * @dev Can be called only by this contract.\\n     * This function is used to create cross-protocol adapters.\\n     */\\n    function executeActionExternal(\\n        Action calldata action\\n    )\\n        external\\n        returns (address[] memory)\\n    {\\n        require(msg.sender == address(this), \\\"C: only address(this)\\\");\\n        return executeAction(action);\\n    }\\n\\n    /**\\n     * @return Address of the ProtocolAdapterRegistry contract used.\\n     */\\n    function protocolAdapterRegistry()\\n        external\\n        view\\n        returns (address)\\n    {\\n        return protocolAdapterRegistry_;\\n    }\\n\\n    function executeAction(\\n        Action calldata action\\n    )\\n        internal\\n        returns (address[] memory)\\n    {\\n        address adapter = ProtocolAdapterRegistry(protocolAdapterRegistry_).getProtocolAdapterAddress(\\n            action.protocolAdapterName\\n        );\\n        require(adapter != address(0), \\\"C: bad name\\\");\\n        require(\\n            action.actionType == ActionType.Deposit || action.actionType == ActionType.Withdraw,\\n            \\\"C: bad action type\\\"\\n        );\\n        bytes4 selector;\\n        if (action.actionType == ActionType.Deposit) {\\n            selector = InteractiveAdapter(adapter).deposit.selector;\\n        } else {\\n            selector = InteractiveAdapter(adapter).withdraw.selector;\\n        }\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returnData) = adapter.delegatecall(\\n            abi.encodeWithSelector(\\n                selector,\\n                action.tokenAmounts,\\n                action.data\\n            )\\n        );\\n\\n        // assembly revert opcode is used here as `returnData`\\n        // is already bytes array generated by the callee's revert()\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            if eq(success, 0) { revert(add(returnData, 32), returndatasize()) }\\n        }\\n\\n        return abi.decode(returnData, (address[]));\\n    }\\n\\n    function returnTokens(\\n        AbsoluteTokenAmount[] calldata requiredOutputs,\\n        address[][] memory tokensToBeWithdrawn,\\n        address payable account\\n    )\\n        internal\\n        returns (AbsoluteTokenAmount[] memory)\\n    {\\n        uint256 length = requiredOutputs.length;\\n        uint256 lengthNested;\\n        address token;\\n        AbsoluteTokenAmount[] memory actualOutputs = new AbsoluteTokenAmount[](length);\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            token = requiredOutputs[i].token;\\n            actualOutputs[i] = AbsoluteTokenAmount({\\n                token: token,\\n                amount: checkRequirementAndTransfer(\\n                    token,\\n                    requiredOutputs[i].amount,\\n                    account\\n                )\\n            });\\n        }\\n\\n        length = tokensToBeWithdrawn.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            lengthNested = tokensToBeWithdrawn[i].length;\\n            for (uint256 j = 0; j < lengthNested; j++) {\\n                checkRequirementAndTransfer(tokensToBeWithdrawn[i][j], 0, account);\\n            }\\n        }\\n\\n        return actualOutputs;\\n    }\\n\\n    function checkRequirementAndTransfer(\\n        address token,\\n        uint256 requiredAmount,\\n        address account\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 actualAmount;\\n        if (token == ETH) {\\n            actualAmount = address(this).balance;\\n        } else {\\n            actualAmount = ERC20(token).balanceOf(address(this));\\n        }\\n\\n        require(\\n            actualAmount >= requiredAmount,\\n            string(\\n                abi.encodePacked(\\n                    \\\"C: \\\",\\n                    actualAmount,\\n                    \\\" is less than \\\",\\n                    requiredAmount,\\n                    \\\" for \\\",\\n                    token\\n                )\\n            )\\n        );\\n\\n        if (actualAmount > 0) {\\n            if (token == ETH) {\\n                // solhint-disable-next-line avoid-low-level-calls\\n                (bool success, ) = account.call{value: actualAmount}(new bytes(0));\\n                require(success, \\\"ETH transfer to account failed\\\");\\n            } else {\\n                ERC20(token).safeTransfer(account, actualAmount, \\\"C\\\");\\n            }\\n        }\\n\\n        return actualAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/interactiveAdapters/InteractiveAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport { ProtocolAdapter } from \\\"../adapters/ProtocolAdapter.sol\\\";\\nimport { TokenAmount, AmountType } from \\\"../shared/Structs.sol\\\";\\nimport { ERC20 } from \\\"../shared/ERC20.sol\\\";\\n\\n\\n/**\\n * @title Base contract for interactive protocol adapters.\\n * @dev deposit() and withdraw() functions MUST be implemented\\n * as well as all the functions from ProtocolAdapter abstract contract.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\nabstract contract InteractiveAdapter is ProtocolAdapter {\\n\\n    uint256 internal constant DELIMITER = 1e18;\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /**\\n     * @dev The function must deposit assets to the protocol.\\n     * @return MUST return assets to be sent back to the `msg.sender`.\\n     */\\n    function deposit(\\n        TokenAmount[] memory tokenAmounts,\\n        bytes memory data\\n    )\\n        public\\n        payable\\n        virtual\\n        returns (address[] memory);\\n\\n    /**\\n     * @dev The function must withdraw assets from the protocol.\\n     * @return MUST return assets to be sent back to the `msg.sender`.\\n     */\\n    function withdraw(\\n        TokenAmount[] memory tokenAmounts,\\n        bytes memory data\\n    )\\n        public\\n        payable\\n        virtual\\n        returns (address[] memory);\\n\\n    function getAbsoluteAmountDeposit(\\n        TokenAmount memory tokenAmount\\n    )\\n        internal\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        address token = tokenAmount.token;\\n        uint256 amount = tokenAmount.amount;\\n        AmountType amountType = tokenAmount.amountType;\\n\\n        require(\\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\\n            \\\"IA: bad amount type\\\"\\n        );\\n        if (amountType == AmountType.Relative) {\\n            require(amount <= DELIMITER, \\\"IA: bad amount\\\");\\n\\n            uint256 balance;\\n            if (token == ETH) {\\n                balance = address(this).balance;\\n            } else {\\n                balance = ERC20(token).balanceOf(address(this));\\n            }\\n\\n            if (amount == DELIMITER) {\\n                return balance;\\n            } else {\\n                return mul(balance, amount) / DELIMITER;\\n            }\\n        } else {\\n            return amount;\\n        }\\n    }\\n\\n    function getAbsoluteAmountWithdraw(\\n        TokenAmount memory tokenAmount\\n    )\\n        internal\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        address token = tokenAmount.token;\\n        uint256 amount = tokenAmount.amount;\\n        AmountType amountType = tokenAmount.amountType;\\n\\n        require(\\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\\n            \\\"IA: bad amount type\\\"\\n        );\\n        if (amountType == AmountType.Relative) {\\n            require(amount <= DELIMITER, \\\"IA: bad amount\\\");\\n\\n            uint256 balance = getBalance(token, address(this));\\n            if (amount == DELIMITER) {\\n                return balance;\\n            } else {\\n                return mul(balance, amount) / DELIMITER;\\n            }\\n        } else {\\n            return amount;\\n        }\\n    }\\n\\n    function mul(\\n        uint256 a,\\n        uint256 b\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"IA: mul overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/adapters/ProtocolAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\n\\n/**\\n * @title Protocol adapter abstract contract.\\n * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\nabstract contract ProtocolAdapter {\\n\\n    /**\\n     * @dev MUST return amount and type of the given token\\n     * locked on the protocol by the given account.\\n     */\\n    function getBalance(\\n        address token,\\n        address account\\n    )\\n        public\\n        view\\n        virtual\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/core/ProtocolAdapterRegistry.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport { AdapterBalance, AbsoluteTokenAmount } from \\\"../shared/Structs.sol\\\";\\nimport { ERC20 } from \\\"../shared/ERC20.sol\\\";\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\nimport { ProtocolAdapterManager } from \\\"./ProtocolAdapterManager.sol\\\";\\nimport { ProtocolAdapter } from \\\"../adapters/ProtocolAdapter.sol\\\";\\n\\n\\n/**\\n * @title Registry for protocol adapters.\\n * @notice getBalances() function implements the main functionality.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\ncontract ProtocolAdapterRegistry is Ownable, ProtocolAdapterManager {\\n\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /**\\n     * @param account Address of the account.\\n     * @return AdapterBalance array by the given account.\\n     * @notice Zero values are filtered out!\\n     */\\n    function getBalances(\\n        address account\\n    )\\n        external\\n        view\\n        returns (AdapterBalance[] memory)\\n    {\\n        // Get balances for all the adapters\\n        AdapterBalance[] memory adapterBalances = getAdapterBalances(\\n            _protocolAdapterNames,\\n            account\\n        );\\n\\n        // Declare temp variable and counters\\n        AbsoluteTokenAmount[] memory currentAbsoluteTokenAmounts;\\n        AbsoluteTokenAmount[] memory nonZeroAbsoluteTokenAmounts;\\n        uint256 nonZeroAdaptersCounter;\\n        uint256[] memory nonZeroTokensCounters;\\n        uint256 adapterBalancesLength;\\n        uint256 currentAbsoluteTokenAmountsLength;\\n\\n        // Reset counters\\n        nonZeroTokensCounters = new uint256[](adapterBalances.length);\\n        nonZeroAdaptersCounter = 0;\\n        adapterBalancesLength = adapterBalances.length;\\n\\n        // Iterate over all the adapters' balances\\n        for (uint256 i = 0; i < adapterBalancesLength; i++) {\\n            // Fill temp variable\\n            currentAbsoluteTokenAmounts = adapterBalances[i].absoluteTokenAmounts;\\n\\n            // Reset counter\\n            nonZeroTokensCounters[i] = 0;\\n            currentAbsoluteTokenAmountsLength = currentAbsoluteTokenAmounts.length;\\n\\n            // Increment if token balance is positive\\n            for (uint256 j = 0; j < currentAbsoluteTokenAmountsLength; j++) {\\n                if (currentAbsoluteTokenAmounts[j].amount > 0) {\\n                    nonZeroTokensCounters[i]++;\\n                }\\n            }\\n\\n            // Increment if at least one positive token balance\\n            if (nonZeroTokensCounters[i] > 0) {\\n                nonZeroAdaptersCounter++;\\n            }\\n        }\\n\\n        // Declare resulting variable\\n        AdapterBalance[] memory nonZeroAdapterBalances;\\n\\n        // Reset resulting variable and counter\\n        nonZeroAdapterBalances = new AdapterBalance[](nonZeroAdaptersCounter);\\n        nonZeroAdaptersCounter = 0;\\n\\n        // Iterate over all the adapters' balances\\n        for (uint256 i = 0; i < adapterBalancesLength; i++) {\\n            // Skip if no positive token balances\\n            if (nonZeroTokensCounters[i] == 0) {\\n                continue;\\n            }\\n\\n            // Fill temp variable\\n            currentAbsoluteTokenAmounts = adapterBalances[i].absoluteTokenAmounts;\\n\\n            // Reset temp variable and counter\\n            nonZeroAbsoluteTokenAmounts = new AbsoluteTokenAmount[](nonZeroTokensCounters[i]);\\n            nonZeroTokensCounters[i] = 0;\\n            currentAbsoluteTokenAmountsLength = currentAbsoluteTokenAmounts.length;\\n\\n            for (uint256 j = 0; j < currentAbsoluteTokenAmountsLength; j++) {\\n                // Skip if balance is not positive\\n                if (currentAbsoluteTokenAmounts[j].amount == 0) {\\n                    continue;\\n                }\\n\\n                // Else fill temp variable\\n                nonZeroAbsoluteTokenAmounts[nonZeroTokensCounters[i]] = currentAbsoluteTokenAmounts[j];\\n\\n                // Increment counter\\n                nonZeroTokensCounters[i]++;\\n            }\\n\\n            // Fill resulting variable\\n            nonZeroAdapterBalances[nonZeroAdaptersCounter] = AdapterBalance({\\n                protocolAdapterName: adapterBalances[i].protocolAdapterName,\\n                absoluteTokenAmounts: nonZeroAbsoluteTokenAmounts\\n            });\\n\\n            // Increment counter\\n            nonZeroAdaptersCounter++;\\n        }\\n\\n        return nonZeroAdapterBalances;\\n    }\\n\\n    /**\\n     * @param protocolAdapterNames Array of the protocol adapters' names.\\n     * @param account Address of the account.\\n     * @return AdapterBalance array by the given parameters.\\n     */\\n    function getAdapterBalances(\\n        bytes32[] memory protocolAdapterNames,\\n        address account\\n    )\\n        public\\n        view\\n        returns (AdapterBalance[] memory)\\n    {\\n        uint256 length = protocolAdapterNames.length;\\n        AdapterBalance[] memory adapterBalances = new AdapterBalance[](length);\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            adapterBalances[i] = getAdapterBalance(\\n                protocolAdapterNames[i],\\n                _protocolAdapterSupportedTokens[protocolAdapterNames[i]],\\n                account\\n            );\\n        }\\n\\n        return adapterBalances;\\n    }\\n\\n    /**\\n     * @param protocolAdapterName Protocol adapter's Name.\\n     * @param tokens Array of tokens' addresses.\\n     * @param account Address of the account.\\n     * @return AdapterBalance array by the given parameters.\\n     */\\n    function getAdapterBalance(\\n        bytes32 protocolAdapterName,\\n        address[] memory tokens,\\n        address account\\n    )\\n        public\\n        view\\n        returns (AdapterBalance memory)\\n    {\\n        address adapter = _protocolAdapterAddress[protocolAdapterName];\\n        require(adapter != address(0), \\\"AR: bad protocolAdapterName\\\");\\n\\n        uint256 length = tokens.length;\\n        AbsoluteTokenAmount[] memory absoluteTokenAmounts = new AbsoluteTokenAmount[](tokens.length);\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            try ProtocolAdapter(adapter).getBalance(\\n                tokens[i],\\n                account\\n            ) returns (uint256 amount) {\\n                absoluteTokenAmounts[i] = AbsoluteTokenAmount({\\n                    token: tokens[i],\\n                    amount: amount\\n                });\\n            } catch {\\n                absoluteTokenAmounts[i] = AbsoluteTokenAmount({\\n                    token: tokens[i],\\n                    amount: 0\\n                });\\n            }\\n        }\\n\\n        return AdapterBalance({\\n            protocolAdapterName: protocolAdapterName,\\n            absoluteTokenAmounts: absoluteTokenAmounts\\n        });\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/core/ProtocolAdapterManager.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\n\\n\\n/**\\n * @title ProtocolAdapterRegistry part responsible for protocol adapters management.\\n * @dev Base contract for ProtocolAdapterRegistry.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\nabstract contract ProtocolAdapterManager is Ownable {\\n\\n    // Protocol adapters' names\\n    bytes32[] internal _protocolAdapterNames;\\n    // Protocol adapter's name => protocol adapter's address\\n    mapping (bytes32 => address) internal _protocolAdapterAddress;\\n    // protocol adapter's name => protocol adapter's supported tokens\\n    mapping (bytes32 => address[]) internal _protocolAdapterSupportedTokens;\\n\\n    /**\\n     * @notice Adds protocol adapters.\\n     * The function is callable only by the owner.\\n     * @param newProtocolAdapterNames Array of the new protocol adapters' names.\\n     * @param newProtocolAdapterAddresses Array of the new protocol adapters' addresses.\\n     * @param newSupportedTokens Array of the new protocol adapters' supported tokens.\\n     */\\n    function addProtocolAdapters(\\n        bytes32[] calldata newProtocolAdapterNames,\\n        address[] calldata newProtocolAdapterAddresses,\\n        address[][] calldata newSupportedTokens\\n    )\\n        external\\n        onlyOwner\\n    {\\n        uint256 length = newProtocolAdapterNames.length;\\n        require(length != 0, \\\"PAM: empty[1]\\\");\\n        require(length == newProtocolAdapterAddresses.length, \\\"PAM: lengths differ[1]\\\");\\n        require(length == newSupportedTokens.length, \\\"PAM: lengths differ[2]\\\");\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            addProtocolAdapter(\\n                newProtocolAdapterNames[i],\\n                newProtocolAdapterAddresses[i],\\n                newSupportedTokens[i]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Removes protocol adapters.\\n     * The function is callable only by the owner.\\n     * @param protocolAdapterNames Array of the protocol adapters' names.\\n     */\\n    function removeProtocolAdapters(\\n        bytes32[] calldata protocolAdapterNames\\n    )\\n        external\\n        onlyOwner\\n    {\\n        uint256 length = protocolAdapterNames.length;\\n        require(length != 0, \\\"PAM: empty[2]\\\");\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            removeProtocolAdapter(protocolAdapterNames[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates protocol adapters.\\n     * The function is callable only by the owner.\\n     * @param protocolAdapterNames Array of the protocol adapters' names.\\n     * @param newProtocolAdapterAddresses Array of the protocol adapters' new addresses.\\n     * @param newSupportedTokens Array of the protocol adapters' new supported tokens.\\n     */\\n    function updateProtocolAdapters(\\n        bytes32[] calldata protocolAdapterNames,\\n        address[] calldata newProtocolAdapterAddresses,\\n        address[][] calldata newSupportedTokens\\n    )\\n        external\\n        onlyOwner\\n    {\\n        uint256 length = protocolAdapterNames.length;\\n        require(length != 0, \\\"PAM: empty[3]\\\");\\n        require(length == newProtocolAdapterAddresses.length, \\\"PAM: lengths differ[3]\\\");\\n        require(length == newSupportedTokens.length, \\\"PAM: lengths differ[4]\\\");\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            updateProtocolAdapter(\\n                protocolAdapterNames[i],\\n                newProtocolAdapterAddresses[i],\\n                newSupportedTokens[i]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @return Array of protocol adapters' names.\\n     */\\n    function getProtocolAdapterNames()\\n        external\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        return _protocolAdapterNames;\\n    }\\n\\n    /**\\n     * @param protocolAdapterName Name of the protocol adapter.\\n     * @return Address of protocol adapter.\\n     */\\n    function getProtocolAdapterAddress(\\n        bytes32 protocolAdapterName\\n    )\\n        external\\n        view\\n        returns (address)\\n    {\\n        return _protocolAdapterAddress[protocolAdapterName];\\n    }\\n\\n    /**\\n     * @param protocolAdapterName Name of the protocol adapter.\\n     * @return Array of protocol adapter's supported tokens.\\n     */\\n    function getSupportedTokens(\\n        bytes32 protocolAdapterName\\n    )\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        return _protocolAdapterSupportedTokens[protocolAdapterName];\\n    }\\n\\n    /**\\n     * @notice Adds a protocol adapter.\\n     * @param newProtocolAdapterName New protocol adapter's protocolAdapterName.\\n     * @param newAddress New protocol adapter's address.\\n     * @param newSupportedTokens Array of the new protocol adapter's supported tokens.\\n     * Empty array is always allowed.\\n     */\\n    function addProtocolAdapter(\\n        bytes32 newProtocolAdapterName,\\n        address newAddress,\\n        address[] calldata newSupportedTokens\\n    )\\n        internal\\n    {\\n        require(newProtocolAdapterName != bytes32(0), \\\"PAM: zero[1]\\\");\\n        require(newAddress != address(0), \\\"PAM: zero[2]\\\");\\n        require(_protocolAdapterAddress[newProtocolAdapterName] == address(0), \\\"PAM: exists\\\");\\n\\n        _protocolAdapterNames.push(newProtocolAdapterName);\\n        _protocolAdapterAddress[newProtocolAdapterName] = newAddress;\\n        _protocolAdapterSupportedTokens[newProtocolAdapterName] = newSupportedTokens;\\n    }\\n\\n    /**\\n     * @notice Removes a protocol adapter.\\n     * @param protocolAdapterName Protocol adapter's protocolAdapterName.\\n     */\\n    function removeProtocolAdapter(\\n        bytes32 protocolAdapterName\\n    )\\n        internal\\n    {\\n        require(_protocolAdapterAddress[protocolAdapterName] != address(0), \\\"PAM: does not exist[1]\\\");\\n\\n        uint256 length = _protocolAdapterNames.length;\\n        uint256 index = 0;\\n        while (_protocolAdapterNames[index] != protocolAdapterName) {\\n            index++;\\n        }\\n\\n        if (index != length - 1) {\\n            _protocolAdapterNames[index] = _protocolAdapterNames[length - 1];\\n        }\\n\\n        _protocolAdapterNames.pop();\\n\\n        delete _protocolAdapterAddress[protocolAdapterName];\\n        delete _protocolAdapterSupportedTokens[protocolAdapterName];\\n    }\\n\\n    /**\\n     * @notice Updates a protocol adapter.\\n     * @param protocolAdapterName Protocol adapter's protocolAdapterName.\\n     * @param newProtocolAdapterAddress Protocol adapter's new address.\\n     * @param newSupportedTokens Array of the protocol adapter's new supported tokens.\\n     * Empty array is always allowed.\\n     */\\n    function updateProtocolAdapter(\\n        bytes32 protocolAdapterName,\\n        address newProtocolAdapterAddress,\\n        address[] calldata newSupportedTokens\\n    )\\n        internal\\n    {\\n        address oldProtocolAdapterAddress = _protocolAdapterAddress[protocolAdapterName];\\n        require(oldProtocolAdapterAddress != address(0), \\\"PAM: does not exist[2]\\\");\\n        require(newProtocolAdapterAddress != address(0), \\\"PAM: zero[3]\\\");\\n\\n        if (oldProtocolAdapterAddress == newProtocolAdapterAddress) {\\n            _protocolAdapterSupportedTokens[protocolAdapterName] = newSupportedTokens;\\n        } else {\\n            _protocolAdapterAddress[protocolAdapterName] = newProtocolAdapterAddress;\\n            _protocolAdapterSupportedTokens[protocolAdapterName] = newSupportedTokens;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/shared/Helpers.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\n\\n/**\\n * @notice Library helps to convert different types to strings.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\nlibrary Helpers {\\n\\n    /**\\n     * @dev Internal function to convert bytes32 to string and trim zeroes.\\n     */\\n    function toString(bytes32 data) internal pure returns (string memory) {\\n        uint256 counter = 0;\\n        for (uint256 i = 0; i < 32; i++) {\\n            if (data[i] != bytes1(0)) {\\n                counter++;\\n            }\\n        }\\n\\n        bytes memory result = new bytes(counter);\\n        counter = 0;\\n        for (uint256 i = 0; i < 32; i++) {\\n            if (data[i] != bytes1(0)) {\\n                result[counter] = data[i];\\n                counter++;\\n            }\\n        }\\n\\n        return string(result);\\n    }\\n\\n    /**\\n     * @dev Internal function to convert uint256 to string.\\n     */\\n    function toString(uint256 data) internal pure returns (string memory) {\\n        uint256 length = 0;\\n\\n        uint256 dataCopy = data;\\n        while (dataCopy != 0) {\\n            length++;\\n            dataCopy /= 10;\\n        }\\n\\n        bytes memory result = new bytes(length);\\n        dataCopy = data;\\n\\n        // Here, we have on-purpose underflow cause we need case `i = 0` to be included in the loop\\n        for (uint256 i = length - 1; i < length; i--) {\\n            result[i] = bytes1(uint8(48 + dataCopy % 10));\\n            dataCopy /= 10;\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/core/ReentrancyGuard.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\ncontract ReentrancyGuard {\\n\\n    uint256 internal constant UNLOCKED = 1;\\n    uint256 internal constant LOCKED = 2;\\n\\n    uint256 internal guard_;\\n\\n    constructor () internal {\\n        guard_ = UNLOCKED;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(guard_ == UNLOCKED, \\\"RG: locked\\\");\\n\\n        guard_ = LOCKED;\\n\\n        _;\\n\\n        guard_ = UNLOCKED;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": []\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"core\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"protocolAdapterName\",\"type\":\"bytes32\"},{\"internalType\":\"enum ActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"internalType\":\"struct Fee\",\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct AbsoluteTokenAmount[]\",\"name\":\"requiredOutputs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct TransactionData\",\"name\":\"data\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"getAccountFromSignature\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRequiredAllowances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct AbsoluteTokenAmount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRequiredBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct AbsoluteTokenAmount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"returnLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"protocolAdapterName\",\"type\":\"bytes32\"},{\"internalType\":\"enum ActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"internalType\":\"struct Fee\",\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct AbsoluteTokenAmount[]\",\"name\":\"requiredOutputs\",\"type\":\"tuple[]\"}],\"name\":\"startExecution\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct AbsoluteTokenAmount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"protocolAdapterName\",\"type\":\"bytes32\"},{\"internalType\":\"enum ActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"internalType\":\"struct Fee\",\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct AbsoluteTokenAmount[]\",\"name\":\"requiredOutputs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct TransactionData\",\"name\":\"data\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"startExecution\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct AbsoluteTokenAmount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"Router","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"000000000000000000000000d291328a6c202c5b18dcb24f279f69de1e065f70","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d90bfeb4a591f165d95cc8b854cf588cdd46dd6a1c6bd47ad13c6ffd82cd4168"}]}