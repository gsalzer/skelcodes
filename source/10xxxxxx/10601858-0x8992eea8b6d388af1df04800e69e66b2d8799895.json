{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOFlashExercise.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./IWETH.sol\\\";\\r\\nimport \\\"./IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./IUniswapV2Callee.sol\\\";\\r\\nimport \\\"./IUniswapV2Factory.sol\\\";\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\nimport \\\"./IACOToken.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ACOFlashExercise\\r\\n * @dev Contract to exercise ACO tokens using Uniswap Flash Swap.\\r\\n */\\r\\ncontract ACOFlashExercise is IUniswapV2Callee {\\r\\n    \\r\\n    /**\\r\\n     * @dev The Uniswap factory address.\\r\\n     */\\r\\n    address immutable public uniswapFactory;\\r\\n    \\r\\n    /**\\r\\n     * @dev The Uniswap Router address.\\r\\n     */\\r\\n    address immutable public uniswapRouter;\\r\\n\\r\\n    /**\\r\\n     * @dev The WETH address used on Uniswap.\\r\\n     */\\r\\n    address immutable public weth;\\r\\n    \\r\\n    /**\\r\\n     * @dev Selector for ERC20 approve function.\\r\\n     */\\r\\n    bytes4 immutable internal _approveSelector;\\r\\n    \\r\\n    /**\\r\\n     * @dev Selector for ERC20 transfer function.\\r\\n     */\\r\\n    bytes4 immutable internal _transferSelector;\\r\\n    \\r\\n    constructor(address _uniswapRouter) public {\\r\\n        uniswapRouter = _uniswapRouter;\\r\\n        uniswapFactory = IUniswapV2Router02(_uniswapRouter).factory();\\r\\n        weth = IUniswapV2Router02(_uniswapRouter).WETH();\\r\\n        \\r\\n        _approveSelector = bytes4(keccak256(bytes(\\\"approve(address,uint256)\\\")));\\r\\n        _transferSelector = bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev To accept ether from the WETH.\\r\\n     */\\r\\n    receive() external payable {}\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the Uniswap pair for an ACO token.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @return The Uniswap pair for the ACO token.\\r\\n     */\\r\\n    function getUniswapPair(address acoToken) public view returns(address) {\\r\\n        address underlying = _getUniswapToken(IACOToken(acoToken).underlying());\\r\\n        address strikeAsset = _getUniswapToken(IACOToken(acoToken).strikeAsset());\\r\\n        return IUniswapV2Factory(uniswapFactory).getPair(underlying, strikeAsset);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the required amount of collateral to be paid to Uniswap and the expected amount to exercise the ACO token.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param tokenAmount Amount of tokens to be exercised.\\r\\n     * @param accounts The array of addresses to be exercised. Whether the array is empty the exercise will be executed using the standard method.\\r\\n     * @return The required amount of collateral to be paid to Uniswap and the expected amount to exercise the ACO token.\\r\\n     */\\r\\n    function getExerciseData(address acoToken, uint256 tokenAmount, address[] memory accounts) public view returns(uint256, uint256) {\\r\\n        if (tokenAmount \\u003e 0) {\\r\\n            address pair = getUniswapPair(acoToken);\\r\\n            if (pair != address(0)) {\\r\\n                address token0 = IUniswapV2Pair(pair).token0();\\r\\n                address token1 = IUniswapV2Pair(pair).token1();\\r\\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\\r\\n                \\r\\n                (address exerciseAddress, uint256 expectedAmount) = _getAcoExerciseData(acoToken, tokenAmount, accounts);\\r\\n                \\r\\n\\t\\t\\t\\texerciseAddress = _getUniswapToken(exerciseAddress);\\r\\n                \\r\\n                uint256 reserveIn = 0; \\r\\n                uint256 reserveOut = 0;\\r\\n                if (exerciseAddress == token0 \\u0026\\u0026 expectedAmount \\u003c reserve0) {\\r\\n                    reserveIn = reserve1;\\r\\n                    reserveOut = reserve0;\\r\\n                } else if (exerciseAddress == token1 \\u0026\\u0026 expectedAmount \\u003c reserve1) {\\r\\n                    reserveIn = reserve0;\\r\\n                    reserveOut = reserve1;\\r\\n                }\\r\\n                \\r\\n                if (reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0) {\\r\\n                    uint256 amountRequired = IUniswapV2Router02(uniswapRouter).getAmountIn(expectedAmount, reserveIn, reserveOut);\\r\\n                    return (amountRequired, expectedAmount);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return (0, 0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the estimated collateral to be received through a flash exercise.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param tokenAmount Amount of tokens to be exercised.\\r\\n     * @return The estimated collateral to be received through a flash exercise using the standard exercise function.\\r\\n     */\\r\\n    function getEstimatedReturn(address acoToken, uint256 tokenAmount) public view returns(uint256) {\\r\\n        (uint256 amountRequired,) = getExerciseData(acoToken, tokenAmount, new address[](0));\\r\\n        if (amountRequired \\u003e 0) {\\r\\n            (uint256 collateralAmount,) = IACOToken(acoToken).getCollateralOnExercise(tokenAmount);\\r\\n            if (amountRequired \\u003c collateralAmount) {\\r\\n                return collateralAmount - amountRequired;\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to flash exercise ACO tokens.\\r\\n     * The flash exercise uses the flash swap functionality on Uniswap.\\r\\n     * No asset is required to exercise the ACO token because the own collateral redeemed is used to fulfill the terms of the contract.\\r\\n     * The account will receive the remaining difference.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param tokenAmount Amount of tokens to be exercised.\\r\\n     * @param minimumCollateral The minimum amount of collateral accepted to be received on the flash exercise.\\r\\n     * @param salt Random number to calculate the start index of the array of accounts to be exercised.\\r\\n     */\\r\\n    function flashExercise(address acoToken, uint256 tokenAmount, uint256 minimumCollateral, uint256 salt) public {\\r\\n        _flashExercise(acoToken, tokenAmount, minimumCollateral, salt, new address[](0));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to flash exercise ACO tokens.\\r\\n     * The flash exercise uses the flash swap functionality on Uniswap.\\r\\n     * No asset is required to exercise the ACO token because the own collateral redeemed is used to fulfill the terms of the contract.\\r\\n     * The account will receive the remaining difference.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param tokenAmount Amount of tokens to be exercised.\\r\\n     * @param minimumCollateral The minimum amount of collateral accepted to be received on the flash exercise.\\r\\n     * @param accounts The array of addresses to get the deposited collateral. \\r\\n     */\\r\\n    function flashExerciseAccounts(\\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 minimumCollateral, \\r\\n        address[] memory accounts\\r\\n    ) public {\\r\\n        require(accounts.length \\u003e 0, \\\"ACOFlashExercise::flashExerciseAccounts: Accounts are required\\\");\\r\\n        _flashExercise(acoToken, tokenAmount, minimumCollateral, 0, accounts);\\r\\n    }\\r\\n    \\r\\n     /**\\r\\n     * @dev External function to be called by the Uniswap pair on flash swap transaction.\\r\\n     * @param sender Address of the sender of the Uniswap swap. It must be the ACOFlashExercise contract.\\r\\n     * @param amount0Out Amount of token0 on Uniswap pair to be received on the flash swap.\\r\\n     * @param amount1Out Amount of token1 on Uniswap pair to be received on the flash swap.\\r\\n     * @param data The ABI encoded with ACO token flash exercise data.\\r\\n     */\\r\\n    function uniswapV2Call(\\r\\n        address sender, \\r\\n        uint256 amount0Out, \\r\\n        uint256 amount1Out, \\r\\n        bytes calldata data\\r\\n    ) external override {\\r\\n        require(sender == address(this), \\\"ACOFlashExercise::uniswapV2Call: Invalid sender\\\");\\r\\n        \\r\\n        uint256 amountRequired;\\r\\n        {\\r\\n        address token0 = IUniswapV2Pair(msg.sender).token0();\\r\\n        address token1 = IUniswapV2Pair(msg.sender).token1();\\r\\n        require(msg.sender == IUniswapV2Factory(uniswapFactory).getPair(token0, token1), \\\"ACOFlashExercise::uniswapV2Call: Invalid transaction sender\\\"); \\r\\n        require(amount0Out == 0 || amount1Out == 0, \\\"ACOFlashExercise::uniswapV2Call: Invalid out amounts\\\"); \\r\\n        \\r\\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(msg.sender).getReserves();\\r\\n        uint256 reserveIn = amount0Out == 0 ? reserve0 : reserve1; \\r\\n        uint256 reserveOut = amount0Out == 0 ? reserve1 : reserve0; \\r\\n        amountRequired = IUniswapV2Router02(uniswapRouter).getAmountIn((amount0Out + amount1Out), reserveIn, reserveOut);\\r\\n        }\\r\\n        \\r\\n        address acoToken;\\r\\n        uint256 tokenAmount; \\r\\n        uint256 ethValue = 0;\\r\\n        uint256 remainingAmount;\\r\\n        uint256 salt;\\r\\n        address from;\\r\\n        address[] memory accounts;\\r\\n        {\\r\\n        uint256 minimumCollateral;\\r\\n        (from, acoToken, tokenAmount, minimumCollateral, salt, accounts) = abi.decode(data, (address, address, uint256, uint256, uint256, address[]));\\r\\n        \\r\\n\\t\\t(address exerciseAddress, uint256 expectedAmount) = _getAcoExerciseData(acoToken, tokenAmount, accounts);\\r\\n        \\r\\n        require(expectedAmount == (amount1Out + amount0Out), \\\"ACOFlashExercise::uniswapV2Call: Invalid expected amount\\\");\\r\\n        \\r\\n        (uint256 collateralAmount,) = IACOToken(acoToken).getCollateralOnExercise(tokenAmount);\\r\\n        require(amountRequired \\u003c= collateralAmount, \\\"ACOFlashExercise::uniswapV2Call: Insufficient collateral amount\\\");\\r\\n        \\r\\n        remainingAmount = collateralAmount - amountRequired;\\r\\n        require(remainingAmount \\u003e= minimumCollateral, \\\"ACOFlashExercise::uniswapV2Call: Minimum amount not satisfied\\\");\\r\\n        \\r\\n        if (_isEther(exerciseAddress)) {\\r\\n            ethValue = expectedAmount;\\r\\n            IWETH(weth).withdraw(expectedAmount);\\r\\n        } else {\\r\\n            _callApproveERC20(exerciseAddress, acoToken, expectedAmount);\\r\\n        }\\r\\n        }\\r\\n        \\r\\n        if (accounts.length == 0) {\\r\\n            IACOToken(acoToken).exerciseFrom{value: ethValue}(from, tokenAmount, salt);\\r\\n        } else {\\r\\n            IACOToken(acoToken).exerciseAccountsFrom{value: ethValue}(from, tokenAmount, accounts);\\r\\n        }\\r\\n        \\r\\n        address collateral = IACOToken(acoToken).collateral();\\r\\n        address uniswapPayment;\\r\\n        if (_isEther(collateral)) {\\r\\n            payable(from).transfer(remainingAmount);\\r\\n            IWETH(weth).deposit{value: amountRequired}();\\r\\n            uniswapPayment = weth;\\r\\n        } else {\\r\\n            _callTransferERC20(collateral, from, remainingAmount); \\r\\n            uniswapPayment = collateral;\\r\\n        }\\r\\n        \\r\\n        _callTransferERC20(uniswapPayment, msg.sender, amountRequired); \\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to get the ACO tokens exercise data.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param tokenAmount Amount of tokens to be exercised.\\r\\n     * @param accounts The array of addresses to be exercised. Whether the array is empty the exercise will be executed using the standard method.\\r\\n\\t * @return The asset and the respective amount that should be sent to get the collateral.\\r\\n     */\\r\\n\\tfunction _getAcoExerciseData(address acoToken, uint256 tokenAmount, address[] memory accounts) internal view returns(address, uint256) {\\r\\n\\t\\t(address exerciseAddress, uint256 expectedAmount) = IACOToken(acoToken).getBaseExerciseData(tokenAmount);\\r\\n\\t\\tif (accounts.length == 0) {\\r\\n\\t\\t\\texpectedAmount = expectedAmount + IACOToken(acoToken).maxExercisedAccounts();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\texpectedAmount = expectedAmount + accounts.length;\\r\\n\\t\\t}\\r\\n\\t\\treturn (exerciseAddress, expectedAmount);\\r\\n\\t}\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Internal function to flash exercise ACO tokens.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param tokenAmount Amount of tokens to be exercised.\\r\\n     * @param minimumCollateral The minimum amount of collateral accepted to be received on the flash exercise.\\r\\n     * @param salt Random number to calculate the start index of the array of accounts to be exercised when using standard method.\\r\\n     * @param accounts The array of addresses to get the deposited collateral. Whether the array is empty the exercise will be executed using the standard method.\\r\\n     */\\r\\n    function _flashExercise(\\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 minimumCollateral, \\r\\n        uint256 salt,\\r\\n        address[] memory accounts\\r\\n    ) internal {\\r\\n        address pair = getUniswapPair(acoToken);\\r\\n        require(pair != address(0), \\\"ACOFlashExercise::_flashExercise: Invalid Uniswap pair\\\");\\r\\n        \\r\\n        (address exerciseAddress, uint256 expectedAmount) = _getAcoExerciseData(acoToken, tokenAmount, accounts);\\r\\n\\r\\n        uint256 amount0Out = 0;\\r\\n        uint256 amount1Out = 0;\\r\\n        if (_getUniswapToken(exerciseAddress) == IUniswapV2Pair(pair).token0()) {\\r\\n            amount0Out = expectedAmount;\\r\\n        } else {\\r\\n            amount1Out = expectedAmount;  \\r\\n        }\\r\\n        \\r\\n        IUniswapV2Pair(pair).swap(amount0Out, amount1Out, address(this), abi.encode(msg.sender, acoToken, tokenAmount, minimumCollateral, salt, accounts));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get Uniswap token address.\\r\\n     * The Ethereum address on ACO must be swapped to WETH to be used on Uniswap.\\r\\n     * @param token Address of the token on ACO.\\r\\n     * @return Uniswap token address.\\r\\n     */\\r\\n    function _getUniswapToken(address token) internal view returns(address) {\\r\\n        if (_isEther(token)) {\\r\\n            return weth;\\r\\n        } else {\\r\\n            return token;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get if the token is for Ethereum (0x0).\\r\\n     * @param token Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address token) internal pure returns(bool) {\\r\\n        return token == address(0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to approve ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param spender Authorized address.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_approveSelector, spender, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOTokenExercise::_callApproveERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferSelector, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOTokenExercise::_callTransferERC20\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"IACOToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IACOToken is IERC20 {\\r\\n\\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function underlying() external view returns (address);\\r\\n    function strikeAsset() external view returns (address);\\r\\n    function feeDestination() external view returns (address);\\r\\n    function isCall() external view returns (bool);\\r\\n    function strikePrice() external view returns (uint256);\\r\\n    function expiryTime() external view returns (uint256);\\r\\n    function totalCollateral() external view returns (uint256);\\r\\n    function acoFee() external view returns (uint256);\\r\\n\\tfunction maxExercisedAccounts() external view returns (uint256);\\r\\n    function underlyingSymbol() external view returns (string memory);\\r\\n    function strikeAssetSymbol() external view returns (string memory);\\r\\n    function underlyingDecimals() external view returns (uint8);\\r\\n    function strikeAssetDecimals() external view returns (uint8);\\r\\n    function currentCollateral(address account) external view returns(uint256);\\r\\n    function unassignableCollateral(address account) external view returns(uint256);\\r\\n    function assignableCollateral(address account) external view returns(uint256);\\r\\n    function currentCollateralizedTokens(address account) external view returns(uint256);\\r\\n    function unassignableTokens(address account) external view returns(uint256);\\r\\n    function assignableTokens(address account) external view returns(uint256);\\r\\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\\r\\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\\r\\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\\r\\n    function numberOfAccountsWithCollateral() external view returns(uint256);\\r\\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\\r\\n    function collateral() external view returns(address);\\r\\n    function mintPayable() external payable;\\r\\n    function mintToPayable(address account) external payable;\\r\\n    function mint(uint256 collateralAmount) external;\\r\\n    function mintTo(address account, uint256 collateralAmount) external;\\r\\n    function burn(uint256 tokenAmount) external;\\r\\n    function burnFrom(address account, uint256 tokenAmount) external;\\r\\n    function redeem() external;\\r\\n    function redeemFrom(address account) external;\\r\\n    function exercise(uint256 tokenAmount, uint256 salt) external payable;\\r\\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable;\\r\\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable;\\r\\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable;\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"IUniswapV2Callee.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IUniswapV2Callee {\\r\\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\\r\\n}\"},\"IUniswapV2Factory.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\"},\"IUniswapV2Pair.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"},\"IUniswapV2Router02.sol\":{\"content\":\"pragma solidity 0.6.6;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"},\"IWETH.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IWETH {\\r\\n    function deposit() external payable;\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function withdraw(uint) external;\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"flashExercise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"flashExerciseAccounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getEstimatedReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"getExerciseData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"}],\"name\":\"getUniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOFlashExercise","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://80e7d2a3c96e7d9395a948916565e0774f13c7fd1e8d887f0e71036037c90b45"}]}