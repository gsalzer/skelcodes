{"status":"1","message":"OK","result":[{"SourceCode":"{\"NamedContract.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/// @title Named Contract\\n/// @author growlot (@growlot)\\ncontract NamedContract {\\n    /// @notice The name of contract, which can be set once\\n    string public name;\\n\\n    /// @notice Sets contract name.\\n    function setContractName(string memory newName) internal {\\n        name = newName;\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n/// @title Ownable Contract\\n/// @author growlot (@growlot)\\ncontract Ownable {\\n    /// @notice Storage position of the owner address\\n    /// @dev The address of the current owner is stored in a\\n    /// constant pseudorandom slot of the contract storage\\n    /// (slot number obtained as a result of hashing a certain message),\\n    /// the probability of rewriting which is almost zero\\n    bytes32 private constant _ownerPosition = keccak256(\\\"owner\\\");\\n\\n    /// @notice Storage position of the authorized new owner address\\n    bytes32 private constant _authorizedNewOwnerPosition = keccak256(\\\"authorizedNewOwner\\\");\\n\\n    /// @notice Contract constructor\\n    /// @dev Sets msg sender address as owner address\\n    constructor() public {\\n        bytes32 ownerPosition = _ownerPosition;\\n        address owner = msg.sender;\\n        assembly {\\n            sstore(ownerPosition, owner)\\n        }\\n    }\\n\\n    /// @notice Check that requires msg.sender to be the current owner\\n    function requireOwner() internal view {\\n        require(\\n            msg.sender == getOwner(),\\n            \\\"Sender must be owner\\\"\\n        );\\n    }\\n\\n    /// @notice Returns contract owner address\\n    function getOwner() public view returns (address owner) {\\n        bytes32 ownerPosition = _ownerPosition;\\n        assembly {\\n            owner := sload(ownerPosition)\\n        }\\n    }\\n\\n    /// @notice Returns authorized new owner address\\n    function getAuthorizedNewOwner() public view returns (address newOwner) {\\n        bytes32 authorizedNewOwnerPosition = _authorizedNewOwnerPosition;\\n        assembly {\\n            newOwner := sload(authorizedNewOwnerPosition)\\n        }\\n    }\\n\\n    /**\\n     * @notice Authorizes the transfer of ownership to the provided address.\\n     * NOTE: No transfer will occur unless authorizedAddress calls assumeOwnership( ).\\n     * This authorization may be removed by another call to this function authorizing\\n     * the null address.\\n     *\\n     * @param authorizedAddress The address authorized to become the new owner.\\n     */\\n    function authorizeOwnershipTransfer(address authorizedAddress) external {\\n        requireOwner();\\n        bytes32 authorizedNewOwnerPosition = _authorizedNewOwnerPosition;\\n        assembly {\\n            sstore(authorizedNewOwnerPosition, authorizedAddress)\\n        }\\n    }\\n    \\n    /**\\n     * @notice Transfers ownership of this contract to the authorizedNewOwner.\\n     */\\n    function assumeOwnership() external {\\n        bytes32 authorizedNewOwnerPosition = _authorizedNewOwnerPosition;\\n        address newOwner;\\n\\n        assembly {\\n            newOwner := sload(authorizedNewOwnerPosition)\\n        }\\n\\n        require(\\n            msg.sender == newOwner,\\n            \\\"Only the authorized new owner can accept ownership\\\"\\n        );\\n        \\n        bytes32 ownerPosition = _ownerPosition;\\n        address zero = address(0);\\n\\n        assembly {\\n            sstore(ownerPosition, newOwner)\\n            sstore(authorizedNewOwnerPosition, zero)\\n        }\\n    }\\n}\\n\"},\"StakingEvent.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/// @title Staking Event Contract\\n/// @author growlot (@growlot)\\ncontract StakingEvent {\\n\\n    event Initialize(\\n        address indexed owner,\\n        address indexed sxp,\\n        address indexed rewardProvider,\\n        uint256 minimumStakeAmount,\\n        uint256 rewardCycle,\\n        uint256 rewardAmount,\\n        uint256 rewardCycleTimestamp\\n    );\\n\\n    event Stake(\\n        address indexed staker,\\n        uint256 indexed amount\\n    );\\n\\n    event Claim(\\n        address indexed toAddress,\\n        uint256 indexed amount,\\n        uint256 indexed nonce\\n    );\\n\\n    event Withdraw(\\n        address indexed toAddress,\\n        uint256 indexed amount\\n    );\\n\\n    event GuardianshipTransferAuthorization(\\n        address indexed authorizedAddress\\n    );\\n\\n    event GuardianUpdate(\\n        address indexed oldValue,\\n        address indexed newValue\\n    );\\n\\n    event MinimumStakeAmountUpdate(\\n        uint256 indexed oldValue,\\n        uint256 indexed newValue\\n    );\\n\\n    event RewardProviderUpdate(\\n        address indexed oldValue,\\n        address indexed newValue\\n    );\\n\\n    event RewardPolicyUpdate(\\n        uint256 oldCycle,\\n        uint256 oldAmount,\\n        uint256 indexed newCycle,\\n        uint256 indexed newAmount,\\n        uint256 indexed newTimeStamp\\n    );\\n\\n    event DepositRewardPool(\\n        address indexed depositor,\\n        uint256 indexed amount\\n    );\\n\\n    event WithdrawRewardPool(\\n        address indexed toAddress,\\n        uint256 indexed amount\\n    );\\n\\n    event ApproveClaim(\\n        address indexed toAddress,\\n        uint256 indexed amount,\\n        uint256 indexed nonce\\n    );\\n}\\n\"},\"StakingProxy.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./SwipeRegistry.sol\\\";\\nimport \\\"./StakingEvent.sol\\\";\\n\\n/// @title Upgradeable Registry Contract\\n/// @author growlot (@growlot)\\ncontract StakingProxy is SwipeRegistry, StakingEvent {\\n    /// @notice Contract constructor\\n    /// @dev Calls SwipeRegistry contract constructor\\n    constructor() public SwipeRegistry(\\\"Swipe Staking Proxy\\\") {}\\n}\\n\"},\"SwipeRegistry.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./NamedContract.sol\\\";\\nimport \\\"./Upgradeable.sol\\\";\\n\\n/// @title Upgradeable Registry Contract\\n/// @author growlot (@growlot)\\ncontract SwipeRegistry is NamedContract, Upgradeable {\\n    /// @notice Contract constructor\\n    /// @dev Calls Upgradable contract constructor and sets contract name\\n    constructor(string memory contractName) public Upgradeable() {\\n        setContractName(contractName);\\n    }\\n    \\n    /// @notice Performs a delegatecall to the implementation contract.\\n    /// @dev Fallback function allows to perform a delegatecall to the given implementation.\\n    /// This function will return whatever the implementation call returns.\\n    function() external payable {\\n        require(msg.data.length \\u003e 0, \\\"Calldata must not be empty\\\");\\n        address _impl = getImplementation();\\n        assembly {\\n            // The pointer to the free memory slot\\n            let ptr := mload(0x40)\\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\\n            calldatacopy(ptr, 0x0, calldatasize)\\n            // Delegatecall method of the implementation contract, returns 0 on error\\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0x0, 0)\\n            // Get the size of the last return data\\n            let size := returndatasize\\n            // Copy the size length of bytes from return data at zero position to pointer position\\n            returndatacopy(ptr, 0x0, size)\\n            // Depending on result value\\n            switch result\\n                case 0 {\\n                    // End execution and revert state changes\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    // Return data with length of size at pointers position\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n}\\n\"},\"Upgradeable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n\\n/// @title Upgradeable contract\\n/// @author growlot (@growlot)\\ncontract Upgradeable is Ownable {\\n    /// @notice Storage position of the current implementation address.\\n    /// @dev The address of the current implementation is stored in a\\n    /// constant pseudorandom slot of the contract proxy contract storage\\n    /// (slot number obtained as a result of hashing a certain message),\\n    /// the probability of rewriting which is almost zero\\n    bytes32 private constant implementationPosition = keccak256(\\n        \\\"implementation\\\"\\n    );\\n\\n    /// @notice Contract constructor\\n    /// @dev Calls Ownable contract constructor\\n    constructor() public Ownable() {}\\n\\n    /// @notice Returns the current implementation contract address\\n    function getImplementation() public view returns (address implementation) {\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            implementation := sload(position)\\n        }\\n    }\\n\\n    /// @notice Sets new implementation contract address as current\\n    /// @param _newImplementation New implementation contract address\\n    function setImplementation(address _newImplementation) public {\\n        requireOwner();\\n        require(_newImplementation != address(0), \\\"New implementation must have non-zero address\\\");\\n        address currentImplementation = getImplementation();\\n        require(currentImplementation != _newImplementation, \\\"New implementation must have new address\\\");\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            sstore(position, _newImplementation)\\n        }\\n    }\\n\\n    /// @notice Sets new implementation contract address and call its initializer.\\n    /// @dev New implementation call is a low level delegatecall.\\n    /// @param _newImplementation the new implementation address.\\n    /// @param _newImplementaionCallData represents the msg.data to bet sent through the low level delegatecall.\\n    /// This parameter may include the initializer function signature with the needed payload.\\n    function setImplementationAndCall(\\n        address _newImplementation,\\n        bytes calldata _newImplementaionCallData\\n    ) external payable {\\n        setImplementation(_newImplementation);\\n        if (_newImplementaionCallData.length \\u003e 0) {\\n            (bool success, ) = address(this).call.value(msg.value)(\\n                _newImplementaionCallData\\n            );\\n            require(success, \\\"Delegatecall has failed\\\");\\n        }\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"ApproveClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositRewardPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"GuardianUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"}],\"name\":\"GuardianshipTransferAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sxp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCycleTimestamp\",\"type\":\"uint256\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"MinimumStakeAmountUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newCycle\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newTimeStamp\",\"type\":\"uint256\"}],\"name\":\"RewardPolicyUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"RewardProviderUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawRewardPool\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"assumeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"}],\"name\":\"authorizeOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuthorizedNewOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_newImplementaionCallData\",\"type\":\"bytes\"}],\"name\":\"setImplementationAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"StakingProxy","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"1","Implementation":"0xb994a94cce737a1e9750a6772b3e0661ed6ca72f","SwarmSource":"bzzr://8cd4c435043dca2699a32a9ca29176e46c1427fc84bc171cd62b6124c602f3c8"}]}