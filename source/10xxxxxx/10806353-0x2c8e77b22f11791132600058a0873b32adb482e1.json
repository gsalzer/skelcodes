{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/registry/ImplementationProvider.sol\n\npragma solidity ^0.6.12;\n// : GPL-3.0\n\n\n/**\n * @title ImplementationProvider\n * @dev Abstract contract for providing implementation addresses for other contracts by name.\n */\n // solhint-disable-next-line indent\nabstract contract ImplementationProvider {\n  /**\n   * @dev Abstract function to return the implementation address of a contract.\n   * @param contractName Name of the contract.\n   * @return Implementation address of the contract.\n   */\n    function getImplementation(string memory contractName) public view virtual returns (address);\n}\n\n// File: @daostack/upgrades/contracts/ownership/Ownable.sol\n\npragma solidity ^0.6.0;\n// : MIT\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\n */\ncontract OpenZeppelinUpgradesOwnable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/registry/Package.sol\n\npragma solidity ^0.6.12;\n// : GPL-3.0\n\n\n\n/**\n * @title Package\n * @dev A package is composed by a set of versions, identified via semantic versioning,\n * where each version has a contract address that refers to a reusable implementation,\n * plus an optional content URI with metadata. Note that the semver identifier is restricted\n * to major, minor, and patch, as prerelease tags are not supported.\n */\ncontract Package is OpenZeppelinUpgradesOwnable {\n  /**\n   * @dev Emitted when a version is added to the package.\n   * @param semanticVersion Name of the added version.\n   * @param contractAddress Contract associated with the version.\n   * @param contentURI Optional content URI with metadata of the version.\n   */\n    event VersionAdded(uint64[3] semanticVersion, address contractAddress, bytes contentURI);\n\n    struct Version {\n        uint64[3] semanticVersion;\n        address contractAddress;\n        bytes contentURI;\n    }\n\n    mapping (bytes32 => Version) internal versions;\n    mapping (uint64 => bytes32) internal majorToLatestVersion;\n    uint64 internal latestMajor;\n\n  /**\n   * @dev Adds a new version to the package. Only the Owner can add new versions.\n   * Reverts if the specified semver identifier already exists.\n   * Emits a `VersionAdded` event if successful.\n   * @param semanticVersion Semver identifier of the version.\n   * @param contractAddress Contract address for the version, must be non-zero.\n   * @param contentURI Optional content URI for the version.\n   */\n    function addVersion(uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI)\n    public\n    onlyOwner {\n        require(contractAddress != address(0), \"Contract address is required\");\n        require(!hasVersion(semanticVersion), \"Given version is already registered in package\");\n        require(!semanticVersionIsZero(semanticVersion), \"Version must be non zero\");\n\n        // Register version\n        bytes32 versionId = semanticVersionHash(semanticVersion);\n        versions[versionId] = Version(semanticVersion, contractAddress, contentURI);\n\n        // Update latest major\n        uint64 major = semanticVersion[0];\n        if (major > latestMajor) {\n            latestMajor = semanticVersion[0];\n        }\n\n        // Update latest version for this major\n        uint64 minor = semanticVersion[1];\n        uint64 patch = semanticVersion[2];\n        uint64[3] storage latestVersionForMajor = versions[majorToLatestVersion[major]].semanticVersion;\n        if (semanticVersionIsZero(latestVersionForMajor) // No latest was set for this major\n            || (minor > latestVersionForMajor[1]) // Or current minor is greater\n            || (minor == latestVersionForMajor[1] && patch > latestVersionForMajor[2]) // Or current patch is greater\n        ) {\n            majorToLatestVersion[major] = versionId;\n        }\n\n        emit VersionAdded(semanticVersion, contractAddress, contentURI);\n    }\n\n  /**\n   * @dev Checks whether a version is present in the package.\n   * @param semanticVersion Semver identifier of the version.\n   * @return true if the version is registered in this package, false otherwise.\n   */\n    function hasVersion(uint64[3] memory semanticVersion) public view returns (bool) {\n        Version storage version = versions[semanticVersionHash(semanticVersion)];\n        return address(version.contractAddress) != address(0);\n    }\n\n  /**\n   * @dev Returns the version with the highest semver identifier registered in the package.\n   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will always return `2.0.0`, regardless\n   * of the order in which they were registered. Returns zero if no versions are registered.\n   * @return semanticVersion Semver identifier, contract address,\n   * and content URI for the version, or zero if not exists.\n   */\n    function getLatest()\n    public\n    view\n    returns (uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) {\n        return getLatestByMajor(latestMajor);\n    }\n\n  /**\n   * @dev Returns the version with the highest semver identifier for the given major.\n   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will return `1.3.0` for major `1`,\n   * regardless of the order in which they were registered. Returns zero if no versions are registered\n   * for the specified major.\n   * @param major Major identifier to query\n   * @return semanticVersion Semver identifier, contract address,\n   * and content URI for the version, or zero if not exists.\n   */\n    function getLatestByMajor(uint64 major)\n    public\n    view\n    returns (uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) {\n        Version storage version = versions[majorToLatestVersion[major]];\n        return (version.semanticVersion, version.contractAddress, version.contentURI);\n    }\n\n    /**\n     * @dev Returns a version given its semver identifier.\n     * @param semanticVersion Semver identifier of the version.\n     * @return contractAddress Contract address and content URI for the version,\n     * or zero if not exists.\n     */\n    function getVersion(uint64[3] memory semanticVersion)\n    public\n    view\n    returns (address contractAddress, bytes memory contentURI) {\n        Version storage version = versions[semanticVersionHash(semanticVersion)];\n        return (version.contractAddress, version.contentURI);\n    }\n\n  /**\n   * @dev Returns a contract for a version given its semver identifier.\n   * This method is equivalent to `getVersion`, but returns only the contract address.\n   * @param semanticVersion Semver identifier of the version.\n   * @return contractAddress address for the version, or zero if not exists.\n   */\n    function getContract(uint64[3] memory semanticVersion) public view returns (address contractAddress) {\n        Version storage version = versions[semanticVersionHash(semanticVersion)];\n        return version.contractAddress;\n    }\n\n    function semanticVersionHash(uint64[3] memory version) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(version[0], version[1], version[2]));\n    }\n\n    function semanticVersionIsZero(uint64[3] memory version) internal pure returns (bool) {\n        return version[0] == 0 && version[1] == 0 && version[2] == 0;\n    }\n}\n\n// File: ../upgrades/contracts/upgradeability/Proxy.sol\n\npragma solidity ^0.6.0;\n// : MIT\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  fallback () payable external {\n    _fallback();\n  }\n\n  receive () payable external {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize()) }\n      default { return(0, returndatasize()) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal virtual {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n\n// File: ../upgrades/contracts/utils/Address.sol\n\npragma solidity ^0.6.0;\n// : MIT\n\n/**\n * Utility library of inline functions on addresses\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n */\nlibrary OpenZeppelinUpgradesAddress {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n// File: ../upgrades/contracts/upgradeability/BaseUpgradeabilityProxy.sol\n\npragma solidity ^0.6.0;\n// : MIT\n\n\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return impl Address of the current implementation\n   */\n  function _implementation() internal view override returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n\n// File: ../upgrades/contracts/upgradeability/UpgradeabilityProxy.sol\n\npragma solidity ^0.6.0;\n// : MIT\n\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) public payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }\n}\n\n// File: ../upgrades/contracts/upgradeability/BaseAdminUpgradeabilityProxy.sol\n\npragma solidity ^0.6.0;\n// : MIT\n\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return adm The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  // /**\n  //  * @dev Only fall back when the sender is not the admin.\n  //  */\n  // function _willFallback() internal override {\n  //   require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n  //   super._willFallback();\n  // }\n}\n\n// File: @daostack/upgrades/contracts/upgradeability/AdminUpgradeabilityProxy.sol\n\npragma solidity ^0.6.0;\n// : MIT\n\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal override(Proxy) {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}\n\n// File: contracts/registry/App.sol\n\npragma solidity ^0.6.12;\n// : GPL-3.0\n\n\n\n\n\n\n/**\n * @title App\n * @dev Contract for upgradeable applications.\n * It handles the creation of proxies.\n */\ncontract App is OpenZeppelinUpgradesOwnable {\n    /**\n     * @dev Emitted when a new proxy is created.\n     * @param proxy Address of the created proxy.\n     */\n    event ProxyCreated(address proxy);\n\n  /**\n   * @dev Emitted when a package dependency is changed in the application.\n   * @param providerName Name of the package that changed.\n   * @param package Address of the package associated to the name.\n   * @param version Version of the package in use.\n   */\n    event PackageChanged(string providerName, address package, uint64[3] version);\n\n  /**\n   * @dev Tracks a package in a particular version, used for retrieving implementations\n   */\n    struct ProviderInfo {\n        Package package;\n        uint64[3] version;\n    }\n\n  /**\n   * @dev Maps from dependency name to a tuple of package and version\n   */\n    mapping(string => ProviderInfo) internal providers;\n\n  /**\n   * @dev Sets a package in a specific version as a dependency for this application.\n   * Requires the version to be present in the package.\n   * @param packageName Name of the package to set or overwrite.\n   * @param package Address of the package to register.\n   * @param version Version of the package to use in this application.\n   */\n    function setPackage(string memory packageName, Package package, uint64[3] memory version) public onlyOwner {\n        require(package.hasVersion(version), \"The requested version must be registered in the given package\");\n        providers[packageName] = ProviderInfo(package, version);\n        emit PackageChanged(packageName, address(package), version);\n    }\n\n    /**\n     * @dev Unsets a package given its name.\n     * Reverts if the package is not set in the application.\n     * @param packageName Name of the package to remove.\n     */\n    function unsetPackage(string memory packageName) public onlyOwner {\n        require(address(providers[packageName].package) != address(0), \"Package to unset not found\");\n        delete providers[packageName];\n        emit PackageChanged(packageName, address(0), [uint64(0), uint64(0), uint64(0)]);\n    }\n\n    /**\n     * @dev Creates a new proxy for the given contract and forwards a function call to it.\n     * This is useful to initialize the proxied contract.\n     * @param packageName Name of the package where the contract is contained.\n     * @param contractName Name of the contract.\n     * @param admin Address of the proxy administrator.\n     * @param data Data to send as msg.data to the corresponding implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     * @return Address of the new proxy.\n     */\n    function create(string memory packageName, string memory contractName, address admin, bytes memory data)\n    public\n    payable\n    returns (AdminUpgradeabilityProxy) {\n        address implementation = getImplementation(packageName, contractName);\n        // solhint-disable-next-line\n        AdminUpgradeabilityProxy proxy = (new AdminUpgradeabilityProxy){value:msg.value}(implementation, admin, data);\n        emit ProxyCreated(address(proxy));\n        return proxy;\n    }\n\n    /**\n     * @dev Returns the implementation address for a given contract name, provided by the `ImplementationProvider`.\n     * @param packageName Name of the package where the contract is contained.\n     * @param contractName Name of the contract.\n     * @return Address where the contract is implemented.\n     */\n    function getImplementation(string memory packageName, string memory contractName) public view returns (address) {\n        ImplementationProvider provider = getProvider(packageName);\n        if (address(provider) == address(0)) return address(0);\n        return provider.getImplementation(contractName);\n    }\n\n    /**\n     * @dev Returns the provider for a given package name, or zero if not set.\n     * @param packageName Name of the package to be retrieved.\n     * @return provider The provider.\n     */\n    function getProvider(string memory packageName) public view returns (ImplementationProvider provider) {\n        ProviderInfo storage info = providers[packageName];\n        if (address(info.package) == address(0)) return ImplementationProvider(0);\n        return ImplementationProvider(info.package.getContract(info.version));\n    }\n\n  /**\n   * @dev Returns information on a package given its name.\n   * @param packageName Name of the package to be queried.\n   * @return A tuple with the package address and pinned version given a package name, or zero if not set\n   */\n    function getPackage(string memory packageName) public view returns (Package, uint64[3] memory) {\n        ProviderInfo storage info = providers[packageName];\n        return (info.package, info.version);\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"providerName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"package\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64[3]\",\"name\":\"version\",\"type\":\"uint64[3]\"}],\"name\":\"PackageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"packageName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"contract AdminUpgradeabilityProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"packageName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"packageName\",\"type\":\"string\"}],\"name\":\"getPackage\",\"outputs\":[{\"internalType\":\"contract Package\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint64[3]\",\"name\":\"\",\"type\":\"uint64[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"packageName\",\"type\":\"string\"}],\"name\":\"getProvider\",\"outputs\":[{\"internalType\":\"contract ImplementationProvider\",\"name\":\"provider\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"packageName\",\"type\":\"string\"},{\"internalType\":\"contract Package\",\"name\":\"package\",\"type\":\"address\"},{\"internalType\":\"uint64[3]\",\"name\":\"version\",\"type\":\"uint64[3]\"}],\"name\":\"setPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"packageName\",\"type\":\"string\"}],\"name\":\"unsetPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"App","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}