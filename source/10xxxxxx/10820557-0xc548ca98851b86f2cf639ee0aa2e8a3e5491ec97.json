{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n###########################################################################################################################\r\n#    ###                                                                                                               \r\n#     #    #    #  #####  ######  #####    ####   #####  ######  #       #         ##    #####    ####         #    ####  \r\n#     #    ##   #    #    #       #    #  #         #    #       #       #        #  #   #    #  #             #   #    # \r\n#     #    # #  #    #    #####   #    #   ####     #    #####   #       #       #    #  #    #   ####         #   #    # \r\n#     #    #  # #    #    #       #####        #    #    #       #       #       ######  #####        #  ###   #   #    # \r\n#     #    #   ##    #    #       #   #   #    #    #    #       #       #       #    #  #   #   #    #  ###   #   #    # \r\n#    ###   #    #    #    ######  #    #   ####     #    ######  ######  ######  #    #  #    #   ####   ###   #    ####  \r\n############################################################################################################################\r\n**/\r\n\r\npragma solidity =0.6.9;\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ninterface IINSS {\r\n  function mint(address user, uint amount) external;\r\n  function totalSupply() external view returns (uint256);\r\n}\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\ncontract INSSMiner is ReentrancyGuard {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  uint constant DAY = 24 * 60 * 60;\r\n  uint constant ONE = 10 ** 18;\r\n  uint constant PERDIFF = 100000;\r\n  uint constant PERCENT_250 = 250;\r\n  uint constant PERCENT_100 = 100;\r\n  uint constant LUCKY_1000_AMOUNT = 1000 ether;\r\n  uint constant LUCKY_100_AMOUNT  = 100 ether;\r\n\r\n  address private immutable feeTo;\r\n\r\n  address private immutable referFrom;\r\n\r\n  IINSS private inss;\r\n\r\n\r\n  // a slot for save gas\r\n  uint96 private topPool;    \r\n  uint80 private luckyPool;   // Up to 1.2 million eth\r\n  uint80 private feePool;    \r\n\r\n  struct Order {\r\n    uint104 value;\r\n    uint112 withdrawed;\r\n    uint8 level;\r\n    uint32 ts;\r\n  }\r\n\r\n  struct Earn {\r\n    uint32  earnTs;\r\n    uint112 luckyBonus;\r\n    uint112 superBonus;\r\n    \r\n\r\n    uint96 referBonus;\r\n    uint80 matchBonus;\r\n    uint80 topBonus;\r\n  }\r\n\r\n  struct Lucky {\r\n    uint112 inValue;\r\n    uint112 luckyValue;\r\n    uint32 ts;\r\n    address user;\r\n  }\r\n  \r\n  mapping(address => Order) orders;\r\n  mapping(address => Earn) earns;\r\n\r\n  mapping(address => address) refers;\r\n  mapping(address => uint) cycles;    \r\n\r\n  Lucky lucky;\r\n\r\n  // total \r\n  uint totalDeposit;   // \r\n\r\n  mapping(address => uint) refereeNums;\r\n  mapping(address => uint) partners;\r\n  mapping(address => uint) referValues;\r\n\r\n  mapping(uint => mapping(address => uint)) public dayReferValues;\r\n  mapping(uint => address[]) private topAddrs;\r\n\r\n  event NewStaking(address indexed user, address indexed partner, uint256 amount);\r\n\r\n  constructor (address feeto, address referfrom) public {\r\n    feeTo = feeto;\r\n    referFrom = referfrom;\r\n  }\r\n\r\n  function initINSS(address token) external {\r\n    require(msg.sender == token && address(inss) == address(0), \"inss error\");\r\n    inss = IINSS(token);\r\n  }\r\n\r\n  function getLucky() external view returns (uint112, uint112, uint32, address) {\r\n    return (lucky.inValue, lucky.luckyValue, lucky.ts, lucky.user);\r\n  }\r\n\r\n  function getPools() external view returns (uint , uint96, uint80, uint80) {\r\n    return (totalDeposit, topPool, luckyPool, feePool);\r\n  }\r\n\r\n  function referInfo() external view returns (uint, uint, uint) {\r\n    return (refereeNums[msg.sender], referValues[msg.sender], partners[msg.sender] );\r\n  }\r\n\r\n  function myOrder() external view returns (uint104, uint112, uint8, uint, \r\n    uint32, uint112, uint112, \r\n    uint96, uint80, uint80, uint, uint) {\r\n    Order memory order = orders[msg.sender];\r\n    Earn memory earn = earns[msg.sender];\r\n\r\n    (uint wdableEarn, uint edays,) = myEarns(msg.sender);\r\n\r\n    return (order.value, order.withdrawed, order.level, cycles[msg.sender], \r\n      earn.earnTs, earn.luckyBonus, earn.superBonus, \r\n      earn.referBonus, earn.matchBonus, earn.topBonus, wdableEarn, edays);\r\n  }\r\n\r\n  function dayTopAddrs(uint day) external view returns (address[] memory) {\r\n    return topAddrs[day];\r\n  }\r\n\r\n  function join(address p, uint8 level) external payable nonReentrant {\r\n    address user = msg.sender;\r\n    uint value = msg.value;\r\n\r\n    require(user != referFrom, \"E/refer error\");\r\n    (uint earned, ,) = myEarns(user);\r\n    require(earned == 0, \"E/need wd\");\r\n    require(orders[user].withdrawed >= (PERCENT_250 * orders[user].value / PERCENT_100) || !liveUser(user) , \"E/aleady\");\r\n    require(checkValue(user, value), \"E/invalid value\");\r\n    emit NewStaking(user, p, value);\r\n\r\n    mintInss(user, value * (10 + level) / 10);\r\n\r\n    totalDeposit += value;\r\n    topPool   += uint96(value / 20);\r\n    luckyPool += uint80(value * 3 / 100);\r\n    feePool   += uint80(value * 5 / 100);\r\n\r\n    orders[user] = Order(uint104(value), uint112(0), level, uint32(block.timestamp));\r\n    earns[user] = Earn(uint32(block.timestamp), uint112(0), uint112(0),  uint96(0), uint80(0), uint80(0));\r\n\r\n    address refer = refers[user];\r\n    if(refer == address(0)) {\r\n      refer = p;\r\n      if(!liveUser(p)) {\r\n        refer = referFrom;\r\n      } else {\r\n        refereeNums[refer] += 1;\r\n        \r\n        address partnerRefer = refers[refer];\r\n        for(uint layer=2; layer<=10 && partnerRefer != referFrom; layer++) {\r\n          partners[partnerRefer] += 1;  \r\n          partnerRefer = refers[partnerRefer];\r\n        }\r\n\r\n      }\r\n      refers[user] = refer;  \r\n    }\r\n    \r\n    awardRefer(refer, 1, value);\r\n\r\n    lucky1000(user, value);\r\n  }\r\n\r\n  function inssPrice() public view returns  (uint) {\r\n    return ONE - (inss.totalSupply() / ONE * ONE / PERDIFF);\r\n  }\r\n\r\n  function mintInss(address user, uint value) internal {\r\n    uint amount = inssAmount(value);\r\n    inss.mint(user, amount);\r\n    inss.mint(feeTo, amount / 20);\r\n  } \r\n\r\n  function inssAmount(uint ethAmount) public view returns  (uint) {\r\n    uint price = inssPrice();\r\n    if(price == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint leftEth = ethAmount; \r\n    uint inssTotal = 0;\r\n\r\n    uint leftInss = ONE - (inss.totalSupply() % ONE);\r\n    uint spendEth;\r\n\r\n    while(leftEth > 0) {\r\n      spendEth = leftInss * ONE / price;\r\n\r\n      if (leftEth >= spendEth) {\r\n        inssTotal += leftInss;\r\n        leftEth -= spendEth;\r\n        price -= PERDIFF;\r\n        leftInss = ONE;\r\n      } else {\r\n        inssTotal += leftEth.mul(price).div(ONE);\r\n        return inssTotal;\r\n      }\r\n    }\r\n    return inssTotal;\r\n  }\r\n\r\n  function openDayTop() external {\r\n    return openTopAward(block.timestamp - DAY);\r\n  }\r\n\r\n  function openTopAward(uint timestamp) public nonReentrant {\r\n    require(timestamp < block.timestamp, \"ts not valid\");\r\n    uint day = getDay(timestamp);\r\n    uint nowDay = getDay(block.timestamp);\r\n    require(nowDay > day, \"day not end\");\r\n    require(topAddrs[day].length > 0, \"aleady opened\");\r\n\r\n    uint length = topAddrs[day].length;\r\n    uint topAward = topPool/10;\r\n    uint awarded;\r\n    address topUser;\r\n    uint percent;\r\n\r\n    for (uint i=0;i < length && i<8; i++) {\r\n      topUser = topAddrs[day][i];\r\n      if(i==0) {\r\n        percent = 40;\r\n      } else if (i == 1) {\r\n        percent = 20;\r\n      } else if (i == 2) {\r\n        percent = 12;\r\n      } else if (i == 3) {\r\n        percent = 8;\r\n      } else if (i >= 4) {\r\n        percent = 5;\r\n      }\r\n\r\n      earns[topUser].topBonus += uint80(topAward * percent / PERCENT_100);\r\n      awarded += topAward * percent / PERCENT_100;\r\n    }\r\n\r\n    topPool -= uint96(awarded);\r\n\r\n    delete topAddrs[day];\r\n  }\r\n\r\n  function awardRefer(address refer, uint layer, uint value) internal {\r\n    if(layer == 1) {\r\n      earns[refer].referBonus +=  uint96(value * 7 / PERCENT_100);\r\n\r\n      if (referFrom == refer) {\r\n        return;\r\n      }\r\n\r\n      referValues[refer] += value;\r\n      superRefer100(refer, value);\r\n      \r\n      uint day = getDay(block.timestamp);\r\n      dayReferValues[day][refer] += value;\r\n      fitTopPos(day, refer);\r\n\r\n      if(refers[refer] == referFrom || !liveUser(refers[refer]) || refereeNums[refers[refer]] < 3) {\r\n        awardRefer(referFrom, 2, value);\r\n      } else {\r\n        awardRefer(refers[refer], 2, value);\r\n      }\r\n    } else if (layer == 2) {\r\n      earns[refer].referBonus += uint96(value * 3 / PERCENT_100);\r\n    }\r\n  }\r\n\r\n  function liveUser(address user) internal view returns (bool) {\r\n    Order memory order = orders[user];\r\n    if(order.value > 0) {\r\n      Earn memory earn = earns[user];\r\n      uint earnedValue = userEarn(user);\r\n\r\n      uint valueTop =  order.value * PERCENT_250 / PERCENT_100;\r\n      if(order.withdrawed + earnedValue < valueTop) {\r\n        uint passDays = (block.timestamp - earn.earnTs) / DAY; \r\n\r\n        if (order.level > 0) {\r\n          passDays = (passDays / (order.level + 1)) * (order.level + 1);\r\n        }\r\n\r\n        uint interest = order.value * passDays * (10 + order.level) / 1000;\r\n        \r\n        if(order.withdrawed + earnedValue + interest < valueTop) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function userEarn(address user) internal view returns (uint) {\r\n    Earn memory earn = earns[user];\r\n    return earn.referBonus + earn.matchBonus + earn.topBonus + earn.luckyBonus;\r\n  } \r\n\r\n  function checkValue(address user, uint value) internal view returns (bool) {\r\n    uint lastValue = orders[user].value;\r\n    if(cycles[user] == 0) {\r\n      if(value >= 0.1 ether && value <= 20 ether) {\r\n        return true;\r\n      }\r\n    } else if (cycles[user] >= 5) {\r\n      if(value >= lastValue) {\r\n        return true;\r\n      }\r\n    } else {\r\n      if(value >= lastValue && value <= (10 * (2 ** (cycles[user] + 1 ))) * 1 ether) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  function getDay(uint ts) internal pure returns (uint) {   \r\n    return (ts - 21600) / DAY; \r\n  }\r\n\r\n  function lucky1000(address user, uint value) internal {\r\n\r\n    uint times = 1 + ((address(this).balance - value) / LUCKY_1000_AMOUNT);\r\n    uint luckyV = times * LUCKY_1000_AMOUNT;\r\n\r\n    if(address(this).balance >= luckyV && (address(this).balance - value) < luckyV ) {\r\n      uint112 lv = uint112(luckyPool/2);\r\n      earns[user].luckyBonus += lv;\r\n      luckyPool = luckyPool / 2;\r\n      lucky = Lucky(uint112(value), lv, uint32(block.timestamp), user);\r\n    }\r\n  }\r\n\r\n  // super bonus \r\n  function superRefer100(address refer, uint value) internal {\r\n    uint times = 1 + ((referValues[refer] - value) / LUCKY_100_AMOUNT);\r\n    uint luckyV = times * LUCKY_100_AMOUNT;\r\n    if(referValues[refer] >= luckyV && (referValues[refer] - value) < luckyV ) {\r\n      earns[refer].superBonus += 3 ether;\r\n    }\r\n  }\r\n  \r\n  function wdFee() external {\r\n    uint fee = feePool;\r\n    feePool = 0;\r\n    payable(feeTo).transfer(fee);\r\n  }\r\n\r\n  function wdEarn() external nonReentrant {\r\n    address payable user = msg.sender;\r\n\r\n    (uint earn, uint earnDays, bool over) = myEarns(user);\r\n    uint superBonus = earns[user].superBonus;\r\n    if(earn + superBonus == 0) {\r\n      return;\r\n    }\r\n\r\n    orders[user].withdrawed += uint112(earn);\r\n\r\n    uint32 earnTs = earns[user].earnTs + uint32(earnDays * DAY);\r\n\r\n    earns[user] = Earn(earnTs, uint112(0), uint112(0),  uint96(0), uint80(0), uint80(0));\r\n    \r\n    if(over) {\r\n      cycles[user] += 1;\r\n    } \r\n\r\n    user.transfer(earn + superBonus);\r\n\r\n    address refer = user;\r\n    for(uint layer=1; layer<=10 && refer != referFrom; layer++) {\r\n      refer = refers[refer];\r\n      matchAward(refer, layer, earn);\r\n    }\r\n  }\r\n\r\n  function matchAward(address refer, uint layer, uint value) internal {\r\n    if(layer == 1) {\r\n      earns[refer].matchBonus += uint80(value * 20 / PERCENT_100);\r\n    } else if(refereeNums[refer] >= layer) {\r\n      if(layer == 2) {\r\n        earns[refer].matchBonus += uint80(value * 10 / PERCENT_100);\r\n      } else if(layer == 3 || layer == 4 || layer == 5 ) {\r\n        earns[refer].matchBonus += uint80(value * 7 / PERCENT_100);\r\n      } else if (layer >= 6) {\r\n        earns[refer].matchBonus += uint80(value * 3 / PERCENT_100);\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  // bool : over\r\n  function myEarns(address user) internal view returns(uint, uint , bool) {\r\n    if(user == referFrom) {\r\n      return (earns[user].referBonus + earns[user].matchBonus, 0 , false);\r\n    }\r\n\r\n    Order memory order = orders[user];\r\n    Earn memory earned = earns[user];\r\n    uint earnedValue = userEarn(user);\r\n\r\n    uint valueTop = order.value * PERCENT_250 / PERCENT_100;\r\n    if(order.value > 0 && order.withdrawed < valueTop) {\r\n      uint passDays = (block.timestamp - earned.earnTs) / DAY; \r\n\r\n      if (order.level > 0) {\r\n        passDays = (passDays / (order.level + 1)) * (order.level + 1);\r\n      }\r\n\r\n      uint yield = order.value * passDays * (10 + order.level) / 1000;\r\n      \r\n      if(order.withdrawed + earnedValue + yield < valueTop) {\r\n        return (earnedValue + yield, passDays, false);\r\n      } else {\r\n        return (valueTop - order.withdrawed, passDays, true);\r\n      }\r\n    }\r\n  }\r\n\r\n    function fitTopPos(uint day, address refer) internal {\r\n        uint length = topAddrs[day].length ;\r\n        for (uint i = 0 ; i < length ; i++) {\r\n            if (refer == topAddrs[day][i]) {  // aleady in top8.\r\n                swapLast(day, i, refer);\r\n                return ;\r\n            }\r\n        }\r\n\r\n        //  if top8 list has space.\r\n        if (length < 8) {\r\n            topAddrs[day].push(refer);\r\n            swapLast(day, length, refer);\r\n        } else {  // compare the last one.\r\n            if(dayReferValues[day][refer] > dayReferValues[day][topAddrs[day][7]]) {\r\n              topAddrs[day][7] = refer;\r\n              swapLast(day, 7, refer);\r\n            }\r\n        }\r\n    }\r\n\r\n    function swapLast(uint  day, uint pos, address refer) internal {\r\n        while (pos >= 1 && dayReferValues[day][refer] > dayReferValues[day][topAddrs[day][pos-1]]  ) {   // big then pre , then swap\r\n            topAddrs[day][pos] = topAddrs[day][pos-1];   // pre move to back\r\n            topAddrs[day][pos-1] = refer;   //  move the curr to pre\r\n            pos -= 1;\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeto\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referfrom\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewStaking\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dayReferValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"dayTopAddrs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLucky\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"},{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"initINSS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"inssAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inssPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"p\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myOrder\",\"outputs\":[{\"internalType\":\"uint104\",\"name\":\"\",\"type\":\"uint104\"},{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"},{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"},{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openDayTop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"openTopAward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wdEarn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wdFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"INSSMiner","CompilerVersion":"v0.6.9+commit.3e3065ac","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000bb46bb15f1f710c9c559cddf0325ccd16c1f970d000000000000000000000000b2ff63b2a2dfc719523f169ed13d36604839d725","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://52c49ea2af6d4baa42401343b59905f67234eee9eb3c78a4e1928a9dc9e97e6d"}]}