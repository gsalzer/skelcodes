{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/XIOPortal.sol\n\npragma solidity 0.5.8;\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage)\n        internal\n        pure\n        returns (uint256)\n    {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\ninterface UniswapFactoryInterface {\n    // Create Exchange\n    function createExchange(address token) external returns (address exchange);\n\n    // Get Exchange and Token Info\n    function getExchange(address token)\n        external\n        view\n        returns (address exchange);\n\n    function getToken(address exchange) external view returns (address token);\n\n    function getTokenWithId(uint256 tokenId)\n        external\n        view\n        returns (address token);\n\n    // Never use\n    function initializeFactory(address template) external;\n}\n\n\ninterface UniswapExchangeInterface {\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress() external view returns (address token);\n\n    // Address of Uniswap Factory\n    function factoryAddress() external view returns (address factory);\n\n    // Provide Liquidity\n    function addLiquidity(\n        uint256 min_liquidity,\n        uint256 max_tokens,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256 min_eth,\n        uint256 min_tokens,\n        uint256 deadline\n    ) external returns (uint256, uint256);\n\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold)\n        external\n        view\n        returns (uint256 tokens_bought);\n\n    function getEthToTokenOutputPrice(uint256 tokens_bought)\n        external\n        view\n        returns (uint256 eth_sold);\n\n    function getTokenToEthInputPrice(uint256 tokens_sold)\n        external\n        view\n        returns (uint256 eth_bought);\n\n    function getTokenToEthOutputPrice(uint256 eth_bought)\n        external\n        view\n        returns (uint256 tokens_sold);\n\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)\n        external\n        payable\n        returns (uint256 tokens_bought);\n\n    function ethToTokenTransferInput(\n        uint256 min_tokens,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256 tokens_bought);\n\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline)\n        external\n        payable\n        returns (uint256 eth_sold);\n\n    function ethToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256 eth_sold);\n\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline\n    ) external returns (uint256 eth_bought);\n\n    function tokenToEthTransferInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline,\n        address recipient\n    ) external returns (uint256 eth_bought);\n\n    function tokenToEthSwapOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline\n    ) external returns (uint256 tokens_sold);\n\n    function tokenToEthTransferOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline,\n        address recipient\n    ) external returns (uint256 tokens_sold);\n\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address token_addr\n    ) external returns (uint256 tokens_bought);\n\n    function tokenToTokenTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external returns (uint256 tokens_bought);\n\n    function tokenToTokenSwapOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address token_addr\n    ) external returns (uint256 tokens_sold);\n\n    function tokenToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external returns (uint256 tokens_sold);\n\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address exchange_addr\n    ) external returns (uint256 tokens_bought);\n\n    function tokenToExchangeTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address exchange_addr\n    ) external returns (uint256 tokens_bought);\n\n    function tokenToExchangeSwapOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address exchange_addr\n    ) external returns (uint256 tokens_sold);\n\n    function tokenToExchangeTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address exchange_addr\n    ) external returns (uint256 tokens_sold);\n\n    // ERC20 comaptibility for liquidity tokens\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 value)\n        external\n        returns (bool);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    // Never use\n    function setup(address token_addr) external;\n}\n\n\ninterface Token {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (string memory);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n\ncontract Ownable {\n    address public _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\ncontract Pausable is Ownable {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool _paused;\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function _pause() internal whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function _unpause() internal whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n\n\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(\n            initializing || isConstructor() || !initialized,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n\ncontract XIOPortal is Pausable, Initializable {\n    using SafeMath for uint256;\n    using SafeMath for uint32;\n\n    uint256 interestRate;\n    uint256 MAX_UINT;\n    uint256 ONE_DAY;\n    //stake restriction parameters\n    uint256 stakeDays;\n    uint256 xioQuantity;\n\n    address public xioExchangeAddress;\n    address public xioContractAddress;\n    address public uniswapFactoryAddress;\n\n    mapping(address => mapping(uint256 => StakerData)) public stakerData; //address to timestamp to data\n    mapping(address => PortalData) public portalData; //address to data\n    address[] portalAddresses; //history of portals\n\n    //for testing\n    uint256 ONE_MINUTE;\n    mapping(address => bool) internal whiteListed;\n\n    mapping(address => uint256) public stakerBalance;\n\n    struct StakerData {\n        uint256 quantity;\n        uint256 durationTimestamp;\n        uint256 boughAmount;\n        bool unstaked;\n        address outputTokenAddress;\n        address staker;\n    }\n\n    struct PortalData {\n        uint256 xioStaked;\n        bool active;\n        address tokenAddress;\n        address tokenExchangeAddress;\n    }\n\n    event StakeCompleted(\n        address staker,\n        address outputTokenAddress,\n        uint256 xioQuantity,\n        uint256 timestamp,\n        uint256 duration,\n        uint256 altQuantity\n    ); // When bought tokens are transferred to staker\n\n    event Unstake(address to, uint256 value); // When tokens are withdrawn\n\n    event PortalAdded(address tokenAddress, address exchangeAddress); // When portals are added\n\n    event PortalRemoved(address tokenAddress); //When portals are removed\n\n    event WhiteListerAdded(address whitelistAccount); //When whitelisters are added\n\n    function initialize() public initializer {\n        _paused = false;\n        _owner = msg.sender;\n        interestRate = 684931506849315;\n        MAX_UINT = 2**256 - 1;\n        ONE_DAY = 24 * 60 * 60;\n        xioExchangeAddress = 0x7B6E5278a14d5318571d65aceD036d09c998C707;\n        xioContractAddress = 0x0f7F961648aE6Db43C75663aC7E5414Eb79b5704;\n        uniswapFactoryAddress = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\n        ONE_MINUTE = 60;\n        stakeDays = 15;\n        xioQuantity = 5000000000000000000000;\n    }\n\n    /* @dev to get interest rate of the portal */\n    function getInterestRate() public view returns (uint256) {\n        return interestRate;\n    }\n\n    /* @dev to get exchange rate of XIO to ETH\n     *  @param _amount, xio amount\n     */\n    function getXIOtoETH(uint256 _amount) public view returns (uint256) {\n        return\n            UniswapExchangeInterface(xioExchangeAddress)\n                .getTokenToEthInputPrice(_amount);\n    }\n\n    /* @dev to get exchange rate of ETH to ALT\n     *  @param _amount, xio amount\n     *  @param _outputTokenAddressExchange, exchange address of output token on uniswap\n     */\n    function getETHtoALT(uint256 _amount, address _outputTokenAddressExchange)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            UniswapExchangeInterface(_outputTokenAddressExchange)\n                .getEthToTokenInputPrice(_amount);\n    }\n\n    /* @dev to get portal history\n     */\n    function getPortalHistory() public view returns (address[] memory) {\n        return portalAddresses;\n    }\n\n    /* @dev to get number of days in the stake condition\n     */\n    function getDays() public view returns (uint256) {\n        return stakeDays;\n    }\n\n    /* @dev to get number of xio quantity user can max stake\n     */\n    function getxioQuantity() public view returns (uint256) {\n        return xioQuantity;\n    }\n\n\n    /* @dev stake function which calls uniswaps exchange to buy output tokens and send them to the user.\n     *  @param _xioQuantity, xio interest generated upon the days (in wei)\n     *  @param _tokensBought, how much tokens are bought from the uniswaps exchange (in wei)\n     *  @param _outputTokenAddress, bought token ERC20 address\n     *  @param _days, how much days he has staked (in days)\n     */\n\n    function stakeXIO(\n        address _outputTokenAddress,\n        uint256 _days,\n        uint256 _xioQuantity,\n        uint256 _tokensBought\n    ) public whenNotPaused returns (uint256) {\n        require(_days <= stakeDays, \"Invalid Days\"); // To check days\n        require(_xioQuantity <= xioQuantity, \"Invalid XIO quantity\"); // To verify XIO quantity\n        require(_outputTokenAddress != address(0), \"0 address not allowed\"); // To verify output token address\n        require(\n            portalData[_outputTokenAddress].tokenAddress != address(0),\n            \"Portal does not exists\"\n        ); // To verify portal info\n        require(\n            portalData[_outputTokenAddress].active == true,\n            \"Portal is not active\"\n        );\n        require(whiteListed[msg.sender] == true, \"Not whitelist address\"); //To verify whitelisters\n\n        portalData[_outputTokenAddress]\n            .xioStaked = portalData[_outputTokenAddress].xioStaked.add(\n            _xioQuantity\n        );\n\n        Token(xioContractAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _xioQuantity\n        );\n\n        uint256 soldXIO = (_xioQuantity.mul(interestRate).mul(_days)).div(\n            1000000000000000000\n        );\n\n        uint256 bought = UniswapExchangeInterface(xioExchangeAddress)\n            .tokenToTokenSwapInput(\n            soldXIO,\n            _tokensBought,\n            1,\n            1839591241,\n            _outputTokenAddress\n        );\n\n        uint256 _timestamp = block.timestamp;\n\n        if(stakerData[msg.sender][_timestamp].staker != address(0)){\n            _timestamp = _timestamp.add(1);\n        }\n\n        stakerData[msg.sender][_timestamp] = StakerData(\n            _xioQuantity,\n            _days.mul(ONE_DAY),\n            bought,\n            false,\n            _outputTokenAddress,\n            msg.sender\n        );\n\n        stakerBalance[msg.sender] = stakerBalance[msg.sender].add(_xioQuantity);\n\n        Token(_outputTokenAddress).transfer(msg.sender, bought);\n        emit StakeCompleted(\n            msg.sender,\n            _outputTokenAddress,\n            _xioQuantity,\n            _timestamp,\n            _days,\n            bought\n        );\n        return bought;\n    }\n\n    /* @dev withdrwal function by which user can withdraw their staked xio\n     *  @param _timestampArray , those staked timestamp who needs to be processed\n     *  @param _amount , xio token quanity user has staked\n     */\n\n    function withdrawXIO(uint256[] memory _timestampArray, uint256 _amount)\n        public\n        whenNotPaused\n    {\n        require(_amount > 0, \"Amount should be greater than 0\");\n        uint256 withdrawAmount = 0;\n        for (uint256 i = 0; i < _timestampArray.length; i++) {\n            require(\n                    stakerData[msg.sender][_timestampArray[i]]\n                        .durationTimestamp !=\n                    0,\n                \"Nothing staked\"\n            );\n            if (\n                (_timestampArray[i]\n                    .add(\n                    stakerData[msg.sender][_timestampArray[i]].durationTimestamp\n                ) <= block.timestamp) &&\n                (stakerData[msg.sender][_timestampArray[i]].unstaked == false)\n            ) {\n                if (\n                    _amount >\n                    stakerData[msg.sender][_timestampArray[i]].quantity\n                ) {\n                    stakerData[msg.sender][_timestampArray[i]].unstaked = true;\n                    _amount = _amount.sub(\n                        stakerData[msg.sender][_timestampArray[i]].quantity\n                    );\n                    withdrawAmount = withdrawAmount.add(\n                        stakerData[msg.sender][_timestampArray[i]].quantity\n                    );\n                    updatePortalData(\n                        stakerData[msg.sender][_timestampArray[i]]\n                            .outputTokenAddress,\n                        stakerData[msg.sender][_timestampArray[i]].quantity\n                    );\n                    stakerData[msg.sender][_timestampArray[i]].quantity = 0;\n                } else if (\n                    _amount ==\n                    stakerData[msg.sender][_timestampArray[i]].quantity\n                ) {\n                    stakerData[msg.sender][_timestampArray[i]].unstaked = true;\n                    withdrawAmount = withdrawAmount.add(\n                        stakerData[msg.sender][_timestampArray[i]].quantity\n                    );\n                    stakerData[msg.sender][_timestampArray[i]].quantity = 0;\n                    updatePortalData(\n                        stakerData[msg.sender][_timestampArray[i]]\n                            .outputTokenAddress,\n                        _amount\n                    );\n                    break;\n                } else if (\n                    _amount <\n                    stakerData[msg.sender][_timestampArray[i]].quantity\n                ) {\n                    stakerData[msg.sender][_timestampArray[i]]\n                        .quantity = stakerData[msg.sender][_timestampArray[i]]\n                        .quantity\n                        .sub(_amount);\n                    withdrawAmount = withdrawAmount.add(_amount);\n                    updatePortalData(\n                        stakerData[msg.sender][_timestampArray[i]]\n                            .outputTokenAddress,\n                        _amount\n                    );\n                    break;\n                }\n            }\n        }\n        require(withdrawAmount != 0, \"Not Transferred\");\n        stakerBalance[msg.sender] = stakerBalance[msg.sender].sub(withdrawAmount);\n        Token(xioContractAddress).transfer(msg.sender, withdrawAmount);\n        emit Unstake(msg.sender, withdrawAmount);\n    }\n\n    /* @dev incase of emergency owner can withdraw all the funds */\n    function withdrawTokens() public onlyOwner whenNotPaused {\n        uint256 balance = Token(xioContractAddress).balanceOf(address(this));\n        Token(xioContractAddress).transfer(_owner, balance);\n    }\n\n    /* @dev to add portal into the contract\n     *  @param _tokenAddress, address of output token\n     */\n    function addPortal(address _tokenAddress)\n        public\n        onlyOwner\n        whenNotPaused\n        returns (address)\n    {\n        require(_tokenAddress != address(0), \"Zero address not allowed\");\n        require(\n            checkPortalExists(_tokenAddress) == true,\n            \"Portal already exists\"\n        );\n        address exchangeAddress = UniswapFactoryInterface(uniswapFactoryAddress)\n            .getExchange(_tokenAddress);\n        require(exchangeAddress != address(0));\n        portalData[_tokenAddress] = PortalData(\n            0,\n            true,\n            _tokenAddress,\n            exchangeAddress\n        );\n        portalAddresses.push(_tokenAddress);\n        emit PortalAdded(_tokenAddress, exchangeAddress);\n        return exchangeAddress;\n    }\n\n    /* @dev to deactivate portal into the contract\n     *  @param _tokenAddress, address of portal token\n     */\n    function deactivatePortal(address _tokenAddress)\n        public\n        onlyOwner\n        whenNotPaused\n        returns (bool)\n    {\n        require(\n            portalData[_tokenAddress].tokenAddress != address(0),\n            \"Portal does not exist\"\n        );\n        portalData[_tokenAddress].active = false;\n        return false;\n    }\n\n    /* @dev to activate portal into the contract\n     *  @param _tokenAddress, address of portal token\n     */\n    function activatePortal(address _tokenAddress)\n        public\n        onlyOwner\n        whenNotPaused\n        returns (bool)\n    {\n        require(\n            portalData[_tokenAddress].tokenAddress != address(0),\n            \"Portal does not exist\"\n        );\n        portalData[_tokenAddress].active = true;\n        return true;\n    }\n\n    /* @dev to set interest rate. Can only be called by owner\n     *  @param _rate, interest rate (in wei)\n     */\n    function setInterestRate(uint256 _rate)\n        public\n        onlyOwner\n        whenNotPaused\n        returns (uint256)\n    {\n        require(_rate != 0, \"Rate connot be zero\");\n        interestRate = _rate;\n        return interestRate;\n    }\n\n    /* @dev to set days. Can only be called by owner\n     *  @param _days, days in number\n     */\n    function setDays(uint256 _days)\n        public\n        onlyOwner\n        whenNotPaused\n        returns (uint256)\n    {\n        require(_days != 0, \"Rate connot be zero\");\n        stakeDays = _days;\n        return stakeDays;\n    }\n\n    /* @dev to set xio quantity. Can only be called by owner\n     *  @param _quantity, xio quantity (in wei)\n     */\n    function setXIOquantity(uint256 _quantity)\n        public\n        onlyOwner\n        whenNotPaused\n        returns (uint256)\n    {\n        require(_quantity > 0, \"quantity connot be zero\");\n        xioQuantity = _quantity;\n        return xioQuantity;\n    }\n\n    /* @dev to allow XIO exchange max XIO tokens from the portal, can only be called by owner */\n    function allowXIO() public onlyOwner whenNotPaused {\n        Token(xioContractAddress).approve(xioExchangeAddress, MAX_UINT);\n    }\n\n    /* @dev to add whitelist addresses // for front end feasiblity\n     *  @param __staker, array of staker address\n     */\n    function addWhiteListAccount(address[] memory _staker)\n        public\n        onlyOwner\n        whenNotPaused\n    {\n        for (uint8 i = 0; i < _staker.length; i++) {\n            require(_staker[i] != address(0), \"Zero address not allowed\");\n            whiteListed[_staker[i]] = true;\n            emit WhiteListerAdded(_staker[i]);\n        }\n    }\n\n    /* @dev to update exchange address\n     *  @param _exchangeAddress, xio exchange address\n     */\n    function setXIOExchangeAddress(address _exchangeAddress)\n        public\n        onlyOwner\n        whenNotPaused\n        returns (address)\n    {\n        require(_exchangeAddress != address(0), \"Zero address not allowed\");\n        xioExchangeAddress = _exchangeAddress;\n        return xioExchangeAddress;\n    }\n\n    /* @dev to update the stake expiry time\n     *  @param _time, in timestamp\n     */\n    function setDaysForStake(uint256 _time) public onlyOwner whenNotPaused {\n        ONE_DAY = _time;\n    }\n\n    /* @dev to update factory address\n     *  @param _factoryAddress, factory address of uniswap\n     */\n    function setUniswapFactoryAddress(address _factoryAddress)\n        public\n        onlyOwner\n        whenNotPaused\n        returns (address)\n    {\n        require(_factoryAddress != address(0), \"Zero address not allowed\");\n        uniswapFactoryAddress = _factoryAddress;\n        return uniswapFactoryAddress;\n    }\n\n    /* @dev to update portal data\n     *  @param _outputTokenAddress, token address\n     *  @param _amount, amount that will be minus from portal\n     */\n    function updatePortalData(address _outputTokenAddress, uint256 _amount)\n        internal\n    {\n        portalData[_outputTokenAddress]\n            .xioStaked = portalData[_outputTokenAddress].xioStaked.sub(_amount);\n    }\n\n    /* @dev to check portal if it already exists or not\n     *  @param _tokenAddress, address of output token\n     */\n    function checkPortalExists(address _tokenAddress)\n        internal\n        view\n        returns (bool)\n    {\n        return portalData[_tokenAddress].tokenAddress == address(0);\n    }\n}\n","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getXIOtoETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timestampArray\",\"type\":\"uint256[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawXIO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowXIO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"setXIOquantity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapFactoryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"addPortal\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xioExchangeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"portalData\",\"outputs\":[{\"name\":\"xioStaked\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokenExchangeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_outputTokenAddressExchange\",\"type\":\"address\"}],\"name\":\"getETHtoALT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPortalHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakerData\",\"outputs\":[{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"durationTimestamp\",\"type\":\"uint256\"},{\"name\":\"boughAmount\",\"type\":\"uint256\"},{\"name\":\"unstaked\",\"type\":\"bool\"},{\"name\":\"outputTokenAddress\",\"type\":\"address\"},{\"name\":\"staker\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getxioQuantity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_outputTokenAddress\",\"type\":\"address\"},{\"name\":\"_days\",\"type\":\"uint256\"},{\"name\":\"_xioQuantity\",\"type\":\"uint256\"},{\"name\":\"_tokensBought\",\"type\":\"uint256\"}],\"name\":\"stakeXIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"deactivatePortal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xioContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factoryAddress\",\"type\":\"address\"}],\"name\":\"setUniswapFactoryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeAddress\",\"type\":\"address\"}],\"name\":\"setXIOExchangeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address[]\"}],\"name\":\"addWhiteListAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"setDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"activatePortal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setDaysForStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"outputTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"xioQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"altQuantity\",\"type\":\"uint256\"}],\"name\":\"StakeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"exchangeAddress\",\"type\":\"address\"}],\"name\":\"PortalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"PortalRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"whitelistAccount\",\"type\":\"address\"}],\"name\":\"WhiteListerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"XIOPortal","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}