{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\n\r\nlibrary EnumerableSet {\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\ncontract Permissions {\r\n\r\n  mapping (address=>bool) public permits;\r\n\r\n  event AddPermit(address _addr);\r\n  event RemovePermit(address _addr);\r\n  \r\n   constructor() public {\r\n    permits[msg.sender] = true;\r\n    permits[0xafc5eDF046034fDb0C23d32d52564E23E49C8389] = true;\r\n  }\r\n\r\n  modifier onlyPermits(){\r\n    require(permits[msg.sender] == true);\r\n    _;\r\n  }\r\n\r\n  function isPermit(address _addr) public view returns(bool){\r\n    return permits[_addr];\r\n  }\r\n  \r\n  function addPermit(address _addr) public onlyPermits{\r\n    require(permits[_addr] == false);\r\n    permits[_addr] = true;\r\n    emit AddPermit(_addr);\r\n  }\r\n\r\n\r\n  function removePermit(address _addr) public onlyPermits{\r\n    require(_addr != msg.sender);\r\n    permits[_addr] = false;\r\n    emit RemovePermit(_addr);\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract ERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    //Auto Call from outside to check supportInterface\r\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal  {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\ninterface IERC721  {\r\n    event Transfer(address indexed _from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address _from, address to, uint256 tokenId) external;\r\n    function transferFrom(address _from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address _from, address to, uint256 tokenId, bytes calldata  data) external;\r\n}\r\n\r\ncontract S1Tools{\r\n  function toString(uint256 value) public pure returns (string memory);\r\n}\r\n\r\ncontract RatContract{\r\n  function checkAllow(address _from,address _to,uint256 _tokenID) public  returns (bool);\r\n}\r\n\r\ncontract RATToken is Permissions,ERC165,IERC721{\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n    string public  name = \"Risk Assesement Token\";\r\n    string public  symbol = \"RAT\";\r\n    uint256 public version = 17;\r\n    \r\n\r\n    address[] oldContracts; // for list of old contract Version\r\n    address public newContractAddress;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    // Base URI\r\n    string public baseURI;\r\n \r\n    event ContractUpgrade(address newContract);\r\n    /*\r\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\r\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\r\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\r\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\r\n     *\r\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\r\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /*\r\n     *     bytes4(keccak256('name()')) == 0x06fdde03\r\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\r\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\r\n     *\r\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n    /*\r\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\r\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\r\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\r\n     *\r\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n\r\n\r\n    mapping (address => EnumerableSet.UintSet) _holderTokens;\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private tokenOwner;\r\n   // mapping (address => uint256) private ownershipTokenCount;\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    mapping (uint256=>uint256) tokenIdx;  // By ID\r\n    mapping (uint256=>uint256) tokenID; // By Idx\r\n\r\n    struct RATToken{\r\n      uint256  tokenType; // \r\n      uint256  documentId; // check type and then link to ID\r\n      address  contractAddr; // link contract address\r\n    }\r\n     \r\n    RATToken[] ratTokens;\r\n    S1Tools    tools;\r\n    \r\n    // Check document id not same tpp\r\n    // function mintEmptyToken(address _to,uint256 _tokenId) public onlyCLevelOrPermits{\r\n    //      RATToken memory rat = RATToken({\r\n    //         tokenType : RATTYPE.LOAN_NONE,\r\n    //         documentId: 0\r\n    //     });\r\n        \r\n                \r\n    //     uint256 curIdx = ratTokens.push(rat);\r\n    //     tokenIdx[_tokenId] = curIdx;\r\n    //     ownershipTokenCount[_to]++;\r\n    //     tokenOwner[_tokenId] =  _to;\r\n        \r\n        \r\n    //     emit Transfer(address(0),_to,_tokenId);\r\n    // }\r\n    constructor() public {\r\n \r\n        \r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n        // genesis token\r\n        RATToken memory rat = RATToken({\r\n            tokenType : 0,\r\n            documentId: 1,\r\n            contractAddr:address(this)\r\n        });\r\n        \r\n        uint256 curIdx = ratTokens.push(rat);\r\n        tokenIdx[1] = curIdx;\r\n\r\n        _holderTokens[msg.sender].add(1);\r\n\r\n        tokenOwner[1] =  msg.sender;\r\n        \r\n        baseURI = \"shuttleone.network/rattoken/\";\r\n        emit Transfer(address(0),msg.sender,1);\r\n        \r\n    }\r\n\r\n    function mintToken(address _to,uint256 _tokenId,uint256 _docID,uint256 _tokenType,address _contractAddr) external onlyPermits returns(bool){\r\n        \r\n        require(isValidToken(_tokenId) == false);\r\n\r\n        RATToken memory rat = RATToken({\r\n            tokenType : _tokenType,\r\n            documentId: _docID,\r\n            contractAddr:_contractAddr\r\n        });\r\n        \r\n        uint256 curIdx = ratTokens.push(rat);\r\n        tokenIdx[_tokenId] = curIdx;\r\n//        ownershipTokenCount[_to]++;\r\n        tokenOwner[_tokenId] =  _to;\r\n        \r\n        _holderTokens[_to].add(_tokenId);\r\n\r\n        emit Transfer(address(0),_to,_tokenId);\r\n\r\n        return true;\r\n    }\r\n    \r\n    function getRatDetail(uint256 _tokenID) public view  returns(uint256 _tokenType,uint256 _docID,address _contract){\r\n        require(tokenIdx[_tokenID] > 0,\"Not have tokenID\");\r\n        uint256 curIdx = tokenIdx[_tokenID] - 1;\r\n        \r\n        _tokenType = ratTokens[curIdx].tokenType;\r\n        _docID = ratTokens[curIdx].documentId;\r\n        _contract = ratTokens[curIdx].contractAddr;\r\n        \r\n    }\r\n    \r\n    function isValidToken(uint256 _tokeID) public view  returns (bool) {\r\n        return (tokenIdx[_tokeID] != 0);\r\n    }\r\n  \r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(isValidToken(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function setTools (address _addr) public onlyPermits{\r\n       tools = S1Tools(_addr);\r\n    }\r\n\r\n    function changeName (string memory _name) public onlyPermits{\r\n        name = _name;\r\n    }\r\n    \r\n    function changeSymbol(string memory _symbol) public onlyPermits{\r\n        symbol = _symbol;\r\n    }\r\n\r\n    function balanceOf(address owner) public view  returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _holderTokens[owner].length();\r\n        //return ownershipTokenCount[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n       return tokenOwner[tokenId];\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\r\n       require(isValidToken(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        string memory _tokenURI = tools.toString(tokenId);\r\n\r\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\r\n        return string(abi.encodePacked(baseURI, _tokenURI));\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n      return _holderTokens[owner].at(index);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n       return ratTokens.length;\r\n    }  \r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        return tokenID[index];\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public  {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(msg.sender == owner || isApprovedForAll(owner,msg.sender),\"ERC721: approve caller is not owner nor approved for all\");\r\n        \r\n         _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n     \r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        //  require(tokenIdx[tokenId] > 0,\" nonexistent token\");\r\n         return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public {\r\n        require(operator != msg.sender, \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(address _from, address to, uint256 tokenId) public {\r\n     //   require(_tokenApprovals[tokenId] == msg.sender || tokenOwner[tokenId] == msg.sender ,\"This address not allowed\");\r\n       require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _transfer(_from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address to, uint256 tokenId) public  {\r\n        safeTransferFrom(_from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address to, uint256 tokenId, bytes memory _data) public  {\r\n       // require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(_from, to, tokenId, _data);\r\n    }\r\n\r\n    function _safeTransfer(address _from, address to, uint256 tokenId, bytes memory _data) internal {\r\n        _transfer(_from, to, tokenId);\r\n      \r\n    }\r\n    function intTransfer(address _from, address _to, uint256 tokenId) external onlyPermits returns(bool){\r\n        require(tokenOwner[tokenId] == _from, \"ERC721: transfer of token that is not own\");\r\n        \r\n         _transfer(_from,_to,tokenId);\r\n         return true;\r\n    }\r\n    \r\n    function _transfer(address _from, address _to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == _from, \"ERC721: transfer of token that is not own\");\r\n        require(_to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        require(_beforeTokenTransfer(_from,_to,tokenId) == true,\"Have transfer problem from or to address\");\r\n        _tokenApprovals[tokenId] = address(0);\r\n\r\n        _holderTokens[_from].remove(tokenId);\r\n        _holderTokens[_to].add(tokenId);\r\n        // ownershipTokenCount[_from]--;\r\n        // ownershipTokenCount[_to]++;\r\n        tokenOwner[tokenId] = _to;\r\n        \r\n        emit Transfer(_from, _to, tokenId);\r\n    }\r\n\r\n    // function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal  {\r\n    // }\r\n\r\n    function setBaseURI(string memory _baseURI_) public onlyPermits  {\r\n        baseURI = _baseURI_;\r\n    }\r\n\r\n\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal returns(bool) { \r\n      uint256 idx = tokenIdx[tokenId] - 1;\r\n      RatContract  conCheck = RatContract(ratTokens[idx].contractAddr);\r\n      bool canTran = conCheck.checkAllow(from,to,tokenId);\r\n\r\n      return canTran;\r\n    }\r\n\r\n    \r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"AddPermit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"RemovePermit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addPermit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"changeName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"changeSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"}],\"name\":\"getRatDetail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_docID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"intTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isPermit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokeID\",\"type\":\"uint256\"}],\"name\":\"isValidToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_docID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_contractAddr\",\"type\":\"address\"}],\"name\":\"mintToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removePermit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTools\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RATToken","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d45063038276d2e5bab90af6f27d7a8563b84e7de429c314a50a382463dab196"}]}