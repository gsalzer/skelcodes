{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    Copyright 2020 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/BaseMath.sol\r\n\r\n/**\r\n * @title BaseMath\r\n * @author dYdX\r\n *\r\n * @dev Arithmetic for fixed-point numbers with 18 decimals of precision.\r\n */\r\nlibrary BaseMath {\r\n    using SafeMath for uint256;\r\n\r\n    // The number One in the BaseMath system.\r\n    uint256 constant internal BASE = 10 ** 18;\r\n\r\n    /**\r\n     * @dev Getter function since constants can't be read directly from libraries.\r\n     */\r\n    function base()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return BASE;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies a value by a base value (result is rounded down).\r\n     */\r\n    function baseMul(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return value.mul(baseValue).div(BASE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies a value by a base value (result is rounded down).\r\n     *  Intended as an alternaltive to baseMul to prevent overflow, when `value` is known\r\n     *  to be divisible by `BASE`.\r\n     */\r\n    function baseDivMul(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return value.div(BASE).mul(baseValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies a value by a base value (result is rounded up).\r\n     */\r\n    function baseMulRoundUp(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (value == 0 || baseValue == 0) {\r\n            return 0;\r\n        }\r\n        return value.mul(baseValue).sub(1).div(BASE).add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a value by a base value (result is rounded down).\r\n     */\r\n    function baseDiv(\r\n        uint256 value,\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return value.mul(BASE).div(baseValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a base value representing the reciprocal of another base value (result is\r\n     *  rounded down).\r\n     */\r\n    function baseReciprocal(\r\n        uint256 baseValue\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return baseDiv(BASE, baseValue);\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @author dYdX\r\n *\r\n * @dev Library for non-standard Math functions.\r\n */\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /**\r\n     * @dev Return target * (numerator / denominator), rounded down.\r\n     */\r\n    function getFraction(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /**\r\n     * @dev Return target * (numerator / denominator), rounded up.\r\n     */\r\n    function getFractionRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the minimum between a and b.\r\n     */\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the maximum between a and b.\r\n     */\r\n    function max(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/SafeCast.sol\r\n\r\n/**\r\n * @title SafeCast\r\n * @author dYdX\r\n *\r\n * @dev Library for casting uint256 to other types of uint.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     *  overflow (i.e. when the input is greater than largest uint128).\r\n     *\r\n     *  Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     *  Requirements:\r\n     *  - `value` must fit into 128 bits.\r\n     */\r\n    function toUint128(\r\n        uint256 value\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint128)\r\n    {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint120 from uint256, reverting on\r\n     *  overflow (i.e. when the input is greater than largest uint120).\r\n     *\r\n     *  Counterpart to Solidity's `uint120` operator.\r\n     *\r\n     *  Requirements:\r\n     *  - `value` must fit into 120 bits.\r\n     */\r\n    function toUint120(\r\n        uint256 value\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint120)\r\n    {\r\n        require(value < 2**120, \"SafeCast: value doesn\\'t fit in 120 bits\");\r\n        return uint120(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     *  overflow (i.e. when the input is greater than largest uint32).\r\n     *\r\n     *  Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     *  Requirements:\r\n     *  - `value` must fit into 32 bits.\r\n     */\r\n    function toUint32(\r\n        uint256 value\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/SignedMath.sol\r\n\r\n/**\r\n * @title SignedMath\r\n * @author dYdX\r\n *\r\n * @dev SignedMath library for doing math with signed integers.\r\n */\r\nlibrary SignedMath {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Int {\r\n        uint256 value;\r\n        bool isPositive;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    /**\r\n     * @dev Returns a new signed integer equal to a signed integer plus an unsigned integer.\r\n     */\r\n    function add(\r\n        Int memory sint,\r\n        uint256 value\r\n    )\r\n        internal\r\n        pure\r\n        returns (Int memory)\r\n    {\r\n        if (sint.isPositive) {\r\n            return Int({\r\n                value: value.add(sint.value),\r\n                isPositive: true\r\n            });\r\n        }\r\n        if (sint.value < value) {\r\n            return Int({\r\n                value: value.sub(sint.value),\r\n                isPositive: true\r\n            });\r\n        }\r\n        return Int({\r\n            value: sint.value.sub(value),\r\n            isPositive: false\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a new signed integer equal to a signed integer minus an unsigned integer.\r\n     */\r\n    function sub(\r\n        Int memory sint,\r\n        uint256 value\r\n    )\r\n        internal\r\n        pure\r\n        returns (Int memory)\r\n    {\r\n        if (!sint.isPositive) {\r\n            return Int({\r\n                value: value.add(sint.value),\r\n                isPositive: false\r\n            });\r\n        }\r\n        if (sint.value > value) {\r\n            return Int({\r\n                value: sint.value.sub(value),\r\n                isPositive: true\r\n            });\r\n        }\r\n        return Int({\r\n            value: value.sub(sint.value),\r\n            isPositive: false\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a new signed integer equal to a signed integer plus another signed integer.\r\n     */\r\n    function signedAdd(\r\n        Int memory augend,\r\n        Int memory addend\r\n    )\r\n        internal\r\n        pure\r\n        returns (Int memory)\r\n    {\r\n        return addend.isPositive\r\n            ? add(augend, addend.value)\r\n            : sub(augend, addend.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a new signed integer equal to a signed integer minus another signed integer.\r\n     */\r\n    function signedSub(\r\n        Int memory minuend,\r\n        Int memory subtrahend\r\n    )\r\n        internal\r\n        pure\r\n        returns (Int memory)\r\n    {\r\n        return subtrahend.isPositive\r\n            ? sub(minuend, subtrahend.value)\r\n            : add(minuend, subtrahend.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if signed integer `a` is greater than signed integer `b`, false otherwise.\r\n     */\r\n    function gt(\r\n        Int memory a,\r\n        Int memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.isPositive) {\r\n            if (b.isPositive) {\r\n                return a.value > b.value;\r\n            } else {\r\n                // True, unless both values are zero.\r\n                return a.value != 0 || b.value != 0;\r\n            }\r\n        } else {\r\n            if (b.isPositive) {\r\n                return false;\r\n            } else {\r\n                return a.value < b.value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the minimum of signed integers `a` and `b`.\r\n     */\r\n    function min(\r\n        Int memory a,\r\n        Int memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Int memory)\r\n    {\r\n        return gt(b, a) ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the maximum of signed integers `a` and `b`.\r\n     */\r\n    function max(\r\n        Int memory a,\r\n        Int memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Int memory)\r\n    {\r\n        return gt(a, b) ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/v1/intf/I_P1Funder.sol\r\n\r\n/**\r\n * @title I_P1Funder\r\n * @author dYdX\r\n *\r\n * @notice Interface for an oracle providing the funding rate for a perpetual market.\r\n */\r\ninterface I_P1Funder {\r\n\r\n    /**\r\n     * @notice Calculates the signed funding amount that has accumulated over a period of time.\r\n     *\r\n     * @param  timeDelta  Number of seconds over which to calculate the accumulated funding amount.\r\n     * @return            True if the funding rate is positive, and false otherwise.\r\n     * @return            The funding amount as a unitless rate, represented as a fixed-point number\r\n     *                    with 18 decimals.\r\n     */\r\n    function getFunding(\r\n        uint256 timeDelta\r\n    )\r\n        external\r\n        view\r\n        returns (bool, uint256);\r\n}\r\n\r\n// File: contracts/protocol/v1/lib/P1Types.sol\r\n\r\n/**\r\n * @title P1Types\r\n * @author dYdX\r\n *\r\n * @dev Library for common types used in PerpetualV1 contracts.\r\n */\r\nlibrary P1Types {\r\n    // ============ Structs ============\r\n\r\n    /**\r\n     * @dev Used to represent the global index and each account's cached index.\r\n     *  Used to settle funding paymennts on a per-account basis.\r\n     */\r\n    struct Index {\r\n        uint32 timestamp;\r\n        bool isPositive;\r\n        uint128 value;\r\n    }\r\n\r\n    /**\r\n     * @dev Used to track the signed margin balance and position balance values for each account.\r\n     */\r\n    struct Balance {\r\n        bool marginIsPositive;\r\n        bool positionIsPositive;\r\n        uint120 margin;\r\n        uint120 position;\r\n    }\r\n\r\n    /**\r\n     * @dev Used to cache commonly-used variables that are relatively gas-intensive to obtain.\r\n     */\r\n    struct Context {\r\n        uint256 price;\r\n        uint256 minCollateral;\r\n        Index index;\r\n    }\r\n\r\n    /**\r\n     * @dev Used by contracts implementing the I_P1Trader interface to return the result of a trade.\r\n     */\r\n    struct TradeResult {\r\n        uint256 marginAmount;\r\n        uint256 positionAmount;\r\n        bool isBuy; // From taker's perspective.\r\n        bytes32 traderFlags;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/v1/lib/P1IndexMath.sol\r\n\r\n/**\r\n * @title P1IndexMath\r\n * @author dYdX\r\n *\r\n * @dev Library for manipulating P1Types.Index structs.\r\n */\r\nlibrary P1IndexMath {\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 private constant FLAG_IS_POSITIVE = 1 << (8 * 16);\r\n\r\n    // ============ Functions ============\r\n\r\n    /**\r\n     * @dev Returns a compressed bytes32 representation of the index for logging.\r\n     */\r\n    function toBytes32(\r\n        P1Types.Index memory index\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        uint256 result =\r\n            index.value\r\n            | (index.isPositive ? FLAG_IS_POSITIVE : 0)\r\n            | (uint256(index.timestamp) << 136);\r\n        return bytes32(result);\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/v1/oracles/P1FundingOracle.sol\r\n\r\n/**\r\n * @title P1FundingOracle\r\n * @author dYdX\r\n *\r\n * @notice Oracle providing the funding rate for a perpetual market.\r\n */\r\ncontract P1FundingOracle is\r\n    Ownable,\r\n    I_P1Funder\r\n{\r\n    using BaseMath for uint256;\r\n    using SafeCast for uint256;\r\n    using SafeMath for uint128;\r\n    using SafeMath for uint256;\r\n    using P1IndexMath for P1Types.Index;\r\n    using SignedMath for SignedMath.Int;\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 private constant FLAG_IS_POSITIVE = 1 << 128;\r\n    uint128 constant internal BASE = 10 ** 18;\r\n\r\n    /**\r\n     * @notice Bounding params constraining updates to the funding rate.\r\n     *\r\n     *  Like the funding rate, these are per-second rates, fixed-point with 18 decimals.\r\n     *  We calculate the per-second rates from the market specifications, which use 8-hour rates:\r\n     *  - The max absolute funding rate is 0.75% (8-hour rate).\r\n     *  - The max change over a 45-minute period is 1.5% (8-hour rate).\r\n     *\r\n     *  This means the fastest the funding rate can go from its min to its max value, or vice versa,\r\n     *  is in 45 minutes.\r\n     */\r\n    uint128 public constant MAX_ABS_VALUE = BASE * 75 / 10000 / (8 hours);\r\n    uint128 public constant MAX_ABS_DIFF_PER_SECOND = MAX_ABS_VALUE * 2 / (45 minutes);\r\n\r\n    // ============ Events ============\r\n\r\n    event LogFundingRateUpdated(\r\n        bytes32 fundingRate\r\n    );\r\n\r\n    event LogFundingRateProviderSet(\r\n        address fundingRateProvider\r\n    );\r\n\r\n    // ============ Mutable Storage ============\r\n\r\n    // The funding rate is denoted in units per second, as a fixed-point number with 18 decimals.\r\n    P1Types.Index private _FUNDING_RATE_;\r\n\r\n    // Address which has the ability to update the funding rate.\r\n    address public _FUNDING_RATE_PROVIDER_;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address fundingRateProvider\r\n    )\r\n        public\r\n    {\r\n        P1Types.Index memory fundingRate = P1Types.Index({\r\n            timestamp: block.timestamp.toUint32(),\r\n            isPositive: true,\r\n            value: 0\r\n        });\r\n        _FUNDING_RATE_ = fundingRate;\r\n        _FUNDING_RATE_PROVIDER_ = fundingRateProvider;\r\n\r\n        emit LogFundingRateUpdated(fundingRate.toBytes32());\r\n        emit LogFundingRateProviderSet(fundingRateProvider);\r\n    }\r\n\r\n    // ============ External Functions ============\r\n\r\n    /**\r\n     * @notice Set the funding rate, denoted in units per second, fixed-point with 18 decimals.\r\n     * @dev Can only be called by the funding rate provider. Emits the LogFundingRateUpdated event.\r\n     *\r\n     * @param  newRate  The intended new funding rate. Is bounded by the global constant bounds.\r\n     * @return          The new funding rate with a timestamp of the update.\r\n     */\r\n    function setFundingRate(\r\n        SignedMath.Int calldata newRate\r\n    )\r\n        external\r\n        returns (P1Types.Index memory)\r\n    {\r\n        require(\r\n            msg.sender == _FUNDING_RATE_PROVIDER_,\r\n            \"The funding rate can only be set by the funding rate provider\"\r\n        );\r\n\r\n        SignedMath.Int memory boundedNewRate = _boundRate(newRate);\r\n        P1Types.Index memory boundedNewRateWithTimestamp = P1Types.Index({\r\n            timestamp: block.timestamp.toUint32(),\r\n            isPositive: boundedNewRate.isPositive,\r\n            value: boundedNewRate.value.toUint128()\r\n        });\r\n        _FUNDING_RATE_ = boundedNewRateWithTimestamp;\r\n\r\n        emit LogFundingRateUpdated(boundedNewRateWithTimestamp.toBytes32());\r\n\r\n        return boundedNewRateWithTimestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the funding rate provider. Can only be called by the admin.\r\n     * @dev Emits the LogFundingRateProviderSet event.\r\n     *\r\n     * @param  newProvider  The new provider, who will have the ability to set the funding rate.\r\n     */\r\n    function setFundingRateProvider(\r\n        address newProvider\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        _FUNDING_RATE_PROVIDER_ = newProvider;\r\n        emit LogFundingRateProviderSet(newProvider);\r\n    }\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * @notice Calculates the signed funding amount that has accumulated over a period of time.\r\n     *\r\n     * @param  timeDelta  Number of seconds over which to calculate the accumulated funding amount.\r\n     * @return            True if the funding rate is positive, and false otherwise.\r\n     * @return            The funding amount as a unitless rate, represented as a fixed-point number\r\n     *                    with 18 decimals.\r\n     */\r\n    function getFunding(\r\n        uint256 timeDelta\r\n    )\r\n        public\r\n        view\r\n        returns (bool, uint256)\r\n    {\r\n        // Note: Funding interest in PerpetualV1 does not compound, as the interest affects margin\r\n        // balances but is calculated based on position balances.\r\n        P1Types.Index memory fundingRate = _FUNDING_RATE_;\r\n        uint256 fundingAmount = uint256(fundingRate.value).mul(timeDelta);\r\n        return (fundingRate.isPositive, fundingAmount);\r\n    }\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    /**\r\n     * @dev Apply the contract-defined bounds and return the bounded rate.\r\n     */\r\n    function _boundRate(\r\n        SignedMath.Int memory newRate\r\n    )\r\n        private\r\n        view\r\n        returns (SignedMath.Int memory)\r\n    {\r\n        // Get the old rate from storage.\r\n        P1Types.Index memory oldRateWithTimestamp = _FUNDING_RATE_;\r\n        SignedMath.Int memory oldRate = SignedMath.Int({\r\n            value: oldRateWithTimestamp.value,\r\n            isPositive: oldRateWithTimestamp.isPositive\r\n        });\r\n\r\n        // Get the maximum allowed change in the rate.\r\n        uint256 timeDelta = block.timestamp.sub(oldRateWithTimestamp.timestamp);\r\n        uint256 maxDiff = MAX_ABS_DIFF_PER_SECOND.mul(timeDelta);\r\n\r\n        // Calculate and return the bounded rate.\r\n        if (newRate.gt(oldRate)) {\r\n            SignedMath.Int memory upperBound = SignedMath.min(\r\n                oldRate.add(maxDiff),\r\n                SignedMath.Int({ value: MAX_ABS_VALUE, isPositive: true })\r\n            );\r\n            return SignedMath.min(\r\n                newRate,\r\n                upperBound\r\n            );\r\n        } else {\r\n            SignedMath.Int memory lowerBound = SignedMath.max(\r\n                oldRate.sub(maxDiff),\r\n                SignedMath.Int({ value: MAX_ABS_VALUE, isPositive: false })\r\n            );\r\n            return SignedMath.max(\r\n                newRate,\r\n                lowerBound\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/v1/oracles/P1InverseFundingOracle.sol\r\n\r\n/**\r\n * @title P1InverseFundingOracle\r\n * @author dYdX\r\n *\r\n * @notice P1FundingOracle that uses the inverted rate (i.e. flips base and quote currencies)\r\n *  when getting the funding amount.\r\n */\r\ncontract P1InverseFundingOracle is\r\n    P1FundingOracle\r\n{\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address fundingRateProvider\r\n    )\r\n        P1FundingOracle(fundingRateProvider)\r\n        public\r\n    {\r\n    }\r\n\r\n    // ============ External Functions ============\r\n\r\n    /**\r\n     * @notice Calculates the signed funding amount that has accumulated over a period of time.\r\n     *\r\n     * @param  timeDelta  Number of seconds over which to calculate the accumulated funding amount.\r\n     * @return            True if the funding rate is positive, and false otherwise.\r\n     * @return            The funding amount as a unitless rate, represented as a fixed-point number\r\n     *                    with 18 decimals.\r\n     */\r\n    function getFunding(\r\n        uint256 timeDelta\r\n    )\r\n        public\r\n        view\r\n        returns (bool, uint256)\r\n    {\r\n        (bool isPositive, uint256 fundingAmount) = super.getFunding(timeDelta);\r\n        return (!isPositive, fundingAmount);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fundingRateProvider\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundingRateProvider\",\"type\":\"address\"}],\"name\":\"LogFundingRateProviderSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fundingRate\",\"type\":\"bytes32\"}],\"name\":\"LogFundingRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ABS_DIFF_PER_SECOND\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ABS_VALUE\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_FUNDING_RATE_PROVIDER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeDelta\",\"type\":\"uint256\"}],\"name\":\"getFunding\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPositive\",\"type\":\"bool\"}],\"internalType\":\"struct SignedMath.Int\",\"name\":\"newRate\",\"type\":\"tuple\"}],\"name\":\"setFundingRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isPositive\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"}],\"internalType\":\"struct P1Types.Index\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newProvider\",\"type\":\"address\"}],\"name\":\"setFundingRateProvider\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"P1InverseFundingOracle","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000e5e98525553d8a20d77211f4db4dc1f599515ff3","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d873407f54ff990301af9ab3c279696b080f7e4533b26d3a359ba9423b5ad8bc"}]}