{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-08-25\r\n*/\r\n\r\n/*\r\n*\r\n* ######## ##     ## ########  ######## ######## ##      ##    ###    ##    ##  ######      ##     ## ##    ## ######## \r\n*    ##    ##     ## ##     ## ##       ##       ##  ##  ##   ## ##    ##  ##  ##    ##      ##   ##   ##  ##       ##  \r\n*    ##    ##     ## ##     ## ##       ##       ##  ##  ##  ##   ##    ####   ##             ## ##     ####       ##   \r\n*    ##    ######### ########  ######   ######   ##  ##  ## ##     ##    ##     ######         ###       ##       ##    \r\n*    ##    ##     ## ##   ##   ##       ##       ##  ##  ## #########    ##          ##       ## ##      ##      ##     \r\n*    ##    ##     ## ##    ##  ##       ##       ##  ##  ## ##     ##    ##    ##    ## ###  ##   ##     ##     ##      \r\n*    ##    ##     ## ##     ## ######## ########  ###  ###  ##     ##    ##     ######  ### ##     ##    ##    ######## \r\n*\r\n* Hello\r\n* This is ThreeWays 1.0\r\n* https://threeways.xyz\r\n*\r\n*/\r\n\r\npragma solidity 0.5.16;\r\n\r\n// Owner Handler\r\ncontract ownerShip    // Auction Contract Owner and OwherShip change\r\n{\r\n    //Global storage declaration\r\n    address payable public ownerWallet;\r\n    address payable public newOwner;\r\n\r\n    //Event defined for ownership transfered\r\n    event OwnershipTransferredEv(address indexed previousOwner, address indexed newOwner);\r\n\r\n    //Sets owner only on first run\r\n    constructor() public \r\n    {\r\n        //Set contract owner\r\n        ownerWallet = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner\r\n    {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //the reason for this flow is to protect owners from sending ownership to unintended address due to human error\r\n    function acceptOwnership() public \r\n    {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferredEv(ownerWallet, newOwner);\r\n        ownerWallet = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n\r\n    //This will restrict function only for owner where attached\r\n    modifier onlyOwner() \r\n    {\r\n        require(msg.sender == ownerWallet);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract threeWays is ownerShip {\r\n\r\n    uint public defaultRefID = 1;   //this ref ID will be used if user joins without any ref ID\r\n    uint public constant maxDownLimit = 2;\r\n    uint public constant levelLifeTime = 31536000;  // = 365 days;\r\n    uint public lastIDCount = 0;\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint referrerID;\r\n        uint originalReferrer;\r\n        address[] referral;\r\n        mapping(uint => uint) levelExpired;\r\n    }\r\n\r\n    mapping(uint => uint) public priceOfLevel;\r\n\r\n    mapping (address => userInfo) public userInfos;\r\n    mapping (uint => address) public userAddressByID;\r\n\r\n\r\n    event regLevelEv(uint indexed _userID, address indexed _userWallet, uint indexed _referrerID, address _referrerWallet, uint _originalReferrer, uint _time);\r\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\r\n    event paidForLevelEv(uint userID, address indexed _user, uint referralID, address indexed _referral, uint _level, uint _amount, uint _time);\r\n    event lostForLevelEv(uint userID, address indexed _user, uint referralID, address indexed _referral, uint _level, uint _amount, uint _time);\r\n\r\n    constructor() public {\r\n\r\n        priceOfLevel[1] = 0.1 ether;\r\n        priceOfLevel[2] = 0.2 ether;\r\n        priceOfLevel[3] = 0.4 ether;\r\n        priceOfLevel[4] = 0.8 ether;\r\n        priceOfLevel[5] = 1.6 ether;\r\n        priceOfLevel[6] = 3.2 ether;\r\n        priceOfLevel[7] = 6.4 ether;\r\n        priceOfLevel[8] = 12.8 ether;\r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: 0,\r\n            originalReferrer: 0,\r\n            referral: new address[](0)\r\n        });\r\n\r\n        userInfos[ownerWallet] = UserInfo;\r\n        userAddressByID[lastIDCount] = ownerWallet;\r\n\r\n        for(uint i = 1; i <= 8; i++) {\r\n            userInfos[ownerWallet].levelExpired[i] = 99999999999;\r\n            emit paidForLevelEv(lastIDCount, ownerWallet, 0, address(0), i, priceOfLevel[i], now);\r\n        }\r\n        \r\n        emit regLevelEv(lastIDCount, msg.sender, 0, address(0), 0, now);\r\n    }\r\n    \r\n    function () external payable {\r\n        uint level;\r\n\r\n        if(msg.value == priceOfLevel[1]) level = 1;\r\n        else if(msg.value == priceOfLevel[2]) level = 2;\r\n        else if(msg.value == priceOfLevel[3]) level = 3;\r\n        else if(msg.value == priceOfLevel[4]) level = 4;\r\n        else if(msg.value == priceOfLevel[5]) level = 5;\r\n        else if(msg.value == priceOfLevel[6]) level = 6;\r\n        else if(msg.value == priceOfLevel[7]) level = 7;\r\n        else if(msg.value == priceOfLevel[8]) level = 8;\r\n        else revert('Incorrect Value send');\r\n\r\n        if(userInfos[msg.sender].joined) buyLevel(msg.sender, level);\r\n        else if(level == 1) {\r\n            uint refId = 0;\r\n            address referrer = bytesToAddress(msg.data);\r\n\r\n            if(userInfos[referrer].joined) refId = userInfos[referrer].id;\r\n            else revert('Incorrect referrer');\r\n\r\n            regUser(msg.sender, refId);\r\n        }\r\n        else revert('Please buy first level for 0.1 ETH');\r\n    }\r\n\r\n    function regUser(address _user, uint _referrerID) public payable returns(bool) {\r\n\r\n        if(!(_referrerID > 0 && _referrerID <= lastIDCount)) _referrerID = defaultRefID;\r\n        uint originalReferrer = _referrerID;\r\n\r\n        require(!userInfos[_user].joined, 'User exists');\r\n\r\n        if(msg.sender != ownerWallet){\r\n            require(msg.value == priceOfLevel[1], 'Incorrect Value');\r\n            require(msg.sender == _user, 'Invalid user');\r\n        }\r\n\r\n        if(userInfos[userAddressByID[_referrerID]].referral.length >= maxDownLimit){\r\n\r\n            _referrerID = userInfos[findFreeReferrer(userAddressByID[_referrerID])].id;\r\n        }\r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: _referrerID,\r\n            originalReferrer: originalReferrer,\r\n            referral: new address[](0)\r\n        });\r\n\r\n        userInfos[_user] = UserInfo;\r\n        userAddressByID[lastIDCount] = _user;\r\n\r\n        userInfos[_user].levelExpired[1] = now + levelLifeTime;\r\n\r\n        userInfos[userAddressByID[_referrerID]].referral.push(_user);\r\n\r\n        if(msg.sender != ownerWallet){\r\n            payForCycle(1, _user);  //pay to uplines\r\n        }\r\n\r\n        emit regLevelEv(lastIDCount, _user, _referrerID, userAddressByID[_referrerID], originalReferrer, now);\r\n        return true;\r\n    }\r\n\r\n    function buyLevel(address _user, uint _level) public payable {\r\n        \r\n        require(userInfos[_user].joined, 'User not exist'); \r\n        require(_level > 0 && _level < 9, 'Incorrect level');\r\n\r\n        if(msg.sender != ownerWallet){\r\n            require(msg.value == priceOfLevel[_level], 'Incorrect Value');\r\n            require(msg.sender == _user, 'Invalid user');\r\n        }\r\n\r\n        if(_level == 1) {\r\n            userInfos[_user].levelExpired[1] += levelLifeTime;\r\n        }\r\n        else {\r\n            for(uint l =_level - 1; l > 0; l--) require(userInfos[_user].levelExpired[l] >= now, 'Buy the previous level first');\r\n            if(userInfos[_user].levelExpired[_level] == 0) userInfos[_user].levelExpired[_level] = now + levelLifeTime;\r\n            else userInfos[_user].levelExpired[_level] += levelLifeTime;\r\n        }\r\n        \r\n        if(msg.sender != ownerWallet){\r\n            payForCycle(_level, _user);  //pay to uplines.\r\n        }\r\n\r\n        emit levelBuyEv(_user, _level, msg.value, now);\r\n    }\r\n    \r\n    function payForCycle(uint _level, address _user) internal {\r\n\r\n        address referrer;\r\n        address referrer1;\r\n        address def = userAddressByID[defaultRefID];\r\n        uint256 price = priceOfLevel[_level] * 4500 / 10000;\r\n        uint256 adminPart = price * 10000 / 45000;\r\n\r\n        referrer = findValidUpline(_user, _level);\r\n        referrer1 = findValidUpline(referrer, _level);\r\n\r\n        if(!userInfos[referrer].joined)\r\n        {\r\n            address(uint160(def)).transfer(price);\r\n            emit lostForLevelEv(userInfos[referrer].id, referrer, userInfos[_user].id, _user, _level, price, now);\r\n        }\r\n        else\r\n        {\r\n            address(uint160(referrer)).transfer(price);\r\n            emit paidForLevelEv(userInfos[referrer].id, referrer, userInfos[_user].id, _user, _level, price, now);\r\n        }\r\n\r\n        if(!userInfos[referrer1].joined || !(userInfos[_user].levelExpired[_level] >= now ) )\r\n        {\r\n            address(uint160(def)).transfer(price);\r\n            emit lostForLevelEv(userInfos[referrer1].id, referrer1, userInfos[_user].id, _user, _level, price, now);\r\n        }\r\n        else\r\n        {\r\n            address(uint160(referrer1)).transfer(price);\r\n            emit paidForLevelEv(userInfos[referrer1].id, referrer1, userInfos[_user].id, _user, _level, price, now);\r\n        }\r\n        ownerWallet.transfer(adminPart);\r\n    }\r\n\r\n    function findValidUpline(address _user, uint _level) internal view returns(address)\r\n    {\r\n        for(uint i=0;i<64;i++)\r\n        {\r\n            _user = userAddressByID[userInfos[_user].referrerID];\r\n            if(userInfos[_user].levelExpired[_level] >= now ) break;\r\n        }\r\n        if(!(userInfos[_user].levelExpired[_level] >= now )) _user = userAddressByID[defaultRefID];\r\n        return _user;\r\n    }\r\n\r\n    function findFreeReferrer(address _user) public view returns(address) {\r\n\r\n        if(userInfos[_user].referral.length < maxDownLimit) return _user;\r\n\r\n        address[] memory referrals = new address[](126);\r\n        referrals[0] = userInfos[_user].referral[0];\r\n        referrals[1] = userInfos[_user].referral[1];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for(uint i = 0; i < 126; i++) {\r\n            if(userInfos[referrals[i]].referral.length == maxDownLimit) {\r\n                if(i < 62) {\r\n                    referrals[(i+1)*2] = userInfos[referrals[i]].referral[0];\r\n                    referrals[(i+1)*2+1] = userInfos[referrals[i]].referral[1];\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n\r\n        return freeReferrer;\r\n    }\r\n\r\n    function viewUserReferral(address _user) public view returns(address[] memory) {\r\n        return userInfos[_user].referral;\r\n    }\r\n\r\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\r\n        return userInfos[_user].levelExpired[_level];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n\r\n    function changeDefaultRefID(uint newDefaultRefID) onlyOwner public returns(string memory){\r\n        //this ref ID will be assigned to user who joins without any referral ID.\r\n        defaultRefID = newDefaultRefID;\r\n        return(\"Default Ref ID updated successfully\");\r\n    }\r\n    \r\n    function viewTimestampSinceJoined(address usr) public view returns(uint256[8] memory timeSinceJoined )\r\n    {\r\n        if(userInfos[usr].joined)\r\n        {\r\n            for(uint256 i=0;i<8;i++)\r\n            {\r\n                uint256 t = userInfos[usr].levelExpired[i+1];\r\n                if(t>now)\r\n                {\r\n                    timeSinceJoined[i] = (t-now);\r\n                }\r\n            }\r\n        }\r\n        return timeSinceJoined;\r\n    }\r\n    \r\n    function ownerOnlyCreateUser(address[] memory _user ) public onlyOwner returns(bool)\r\n    {\r\n        require(_user.length <= 50, \"invalid input\");\r\n        for(uint i=0; i < _user.length; i++ )\r\n        {\r\n            require(regUser(_user[i], 1), \"registration fail\");\r\n        }\r\n        return true;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferredEv\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ownerShip","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"BSD-2-Clause","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0b7a5748a51c8cda77f3481835f00e77292f07894ce73e745bff84c3470f6b4c"}]}