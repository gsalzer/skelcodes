{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.4;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract BondingCurve is DSMath {\r\n    uint256 public currentSupply;\r\n    mapping (address => uint256) public ledger;\r\n\r\n    uint256 public exponent;\r\n    uint256 public coefficient;\r\n    uint256 public reserveRatio;\r\n    uint256 public exitVar;\r\n    \r\n    uint256 public constant precision = 1000000000000000000;\r\n\r\n    event NewPrice(uint256 buy, uint256 sell);\r\n\r\n    string internal constant INSUFFICIENT_ETH = 'Insufficient Ether';\r\n    string internal constant INSUFFICIENT_TOKENS = 'Request exceeds token balance';\r\n    string internal constant INVALID_ADDRESS = 'Wallet does not exist';\r\n    string internal constant ZERO_AMOUNT = \"Amount must be nonzero\";\r\n    string internal constant TOKENS_LOCKED = \"Vesting period for this stake has not elapsed\";\r\n\r\n    constructor()\r\n    public {\r\n        exponent = 2;\r\n        coefficient = 100000000;\r\n        reserveRatio = 1;\r\n        currentSupply = 1;\r\n        exitVar = 1;\r\n\r\n        emit NewPrice(calcMintPrice(1), calcBurnReward(1));\r\n    }\r\n\r\n    function buyPriceInWei(uint256 amount)\r\n    public returns (uint256) {\r\n        uint256 price = calcMintPrice(amount);\r\n        return price;\r\n    }\r\n    \r\n    function buy(uint256 amount)\r\n    external payable {\r\n        uint256 price = calcMintPrice(amount);\r\n        require(msg.value >= price, INSUFFICIENT_ETH);\r\n        uint256 refund = msg.value - price;\r\n        if (refund > 0) {\r\n            msg.sender.transfer(refund);\r\n        }\r\n        ledger[msg.sender] = add(ledger[msg.sender], amount);\r\n        currentSupply = add(currentSupply, amount);\r\n        uint256 newBuyPrice = calcMintPrice(1);\r\n        uint256 newSellPrice = calcBurnReward(1);\r\n        emit NewPrice(newBuyPrice, newSellPrice);\r\n    }\r\n\r\n    function sell(uint256 amount)\r\n    external {\r\n        require(amount <= ledger[msg.sender], INSUFFICIENT_TOKENS);\r\n        uint256 exitValue = calcBurnReward(amount);\r\n        msg.sender.transfer(exitValue);\r\n        exitVar = exitValue;\r\n        ledger[msg.sender] = sub(ledger[msg.sender], amount);\r\n        currentSupply = sub(currentSupply, amount);\r\n    }\r\n\r\n\r\n    function integrate(uint256 limitA, uint256 limitB, uint256 multiplier)\r\n    internal returns (uint256) {\r\n        uint256 raiseExp = exponent + 1;\r\n        uint256 _coefficient = wmul(coefficient, multiplier);\r\n        uint256 upper = wdiv((limitB ** raiseExp), raiseExp);\r\n        uint256 lower = wdiv((limitA ** raiseExp), raiseExp);\r\n        return wmul(_coefficient, (sub(upper, lower)));\r\n    }\r\n    \r\n    function calcMintPrice(uint256 amount)\r\n    internal returns (uint256) {\r\n        uint256 newSupply = add(currentSupply, amount);\r\n        uint256 result = integrate(currentSupply, newSupply, precision);\r\n        return result;\r\n    }\r\n\r\n    function calcBurnReward(uint256 amount)\r\n    internal returns (uint256) {\r\n        uint256 newSupply = sub(currentSupply, amount);\r\n        uint256 result = integrate(newSupply, currentSupply, precision);\r\n        return result;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"}],\"name\":\"NewPrice\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyPriceInWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitVar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exponent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ledger\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"precision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BondingCurve","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fd7b691e2eedec346900e53708b31e4a888d2aaa89ff4e2b4b3810b5545d9e27"}]}