{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\ninterface IERC20Token {\r\n    function balanceOf(address owner) external returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function decimals() external returns (uint256);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _tokenholder, address _spender) external view returns (uint256 remaining);\r\n}\r\n\r\ninterface IUSDTToken {\r\n    function transferFrom(address from, address to, uint256 value) external;\r\n    function transfer(address to, uint256 amount) external;\r\n    function balanceOf(address owner) external returns (uint);\r\n}\r\n\r\ncontract WDXStacking {\r\n    IERC20Token public tokenContract;  // the token being sold\r\n    IUSDTToken public usdtTokenContract;\r\n    uint public wdx_price;\r\n    address owner;\r\n    struct Status {\r\n        uint price;\r\n        uint limit;\r\n        uint referal_lines;\r\n    }\r\n\r\n    mapping (uint8 => Status) public statuses;\r\n\r\n    struct Stake {\r\n        uint256 start_time;\r\n        uint256 amount;\r\n\r\n        uint256 week_starts_at;\r\n        uint256 week_withdrawal_amount;\r\n        uint256 last_withdrawal_time;\r\n\r\n        uint256 last_compute_time;\r\n        uint256 last_percent;\r\n        uint256 pure_profit;\r\n\r\n        uint8 status;\r\n    }\r\n\r\n    mapping (address => Stake) public stakes;\r\n\r\n\r\n    constructor(IERC20Token _tokenContract, IUSDTToken _usdtTokenContract) public {\r\n        owner = msg.sender;\r\n        tokenContract = _tokenContract;\r\n        usdtTokenContract = _usdtTokenContract;\r\n\r\n        // status price, status limit in $, referral line limit\r\n        statuses[0] = Status(0, 10000000, 1);\r\n        statuses[1] = Status(100000000, 50000000, 2);\r\n        statuses[2] = Status(300000000, 150000000, 3);\r\n        statuses[3] = Status(1000000000, 500000000, 5);\r\n        statuses[4] = Status(3000000000, 1500000000, 7);\r\n        statuses[5] = Status(10000000000, 5000000000, 10);\r\n\r\n        wdx_price = 1000000; // 1$\r\n    }\r\n\r\n    // Guards against integer overflows\r\n    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        } else {\r\n            uint256 c = a * b;\r\n            assert(c / a == b);\r\n            return c;\r\n        }\r\n    }\r\n\r\n    function safeDivision(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function computeAmount() internal returns(bool) {\r\n        uint256 stake_amount = stakes[address(msg.sender)].amount;\r\n        uint256 stake_start_time = stakes[address(msg.sender)].start_time;\r\n        uint256 stake_last_compute_time = stakes[address(msg.sender)].last_compute_time;\r\n        uint256 profit_percent = 6; //0.6%\r\n        uint256 duration_from_last_compute= safeDivision(now - stake_last_compute_time, 86400); // in days\r\n        if (duration_from_last_compute < 1) {\r\n            return false;\r\n        }\r\n\r\n        // Duration additional profit percent\r\n        uint256 stake_duration = safeDivision(now - stake_start_time, 2592000); // devide 30 days\r\n        if (stake_duration >= 1) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 3) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 6) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 12) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 18) {\r\n            profit_percent += 1;\r\n        }\r\n        // Amount additional profit percent\r\n        if (stake_amount >= 100000000000000000000000) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 200000000000000000000000) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 1000000000000000000000000) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 2000000000000000000000000) {\r\n            profit_percent += 1;\r\n        }\r\n\r\n        if (profit_percent > 20) {\r\n            profit_percent = 20;\r\n        }\r\n\r\n        //uint256 profit_per_day = safeDivision(safeMultiply(profit_percent, stake_amount), 1000); // in wdx\r\n        //uint256 profit_from_last_compute = safeMultiply(profit_per_day, duration_from_last_compute);\r\n        //stakes[address(msg.sender)].amount = profit_from_last_compute + stake_amount;\r\n        stakes[address(msg.sender)].last_compute_time = now;\r\n        stakes[address(msg.sender)].last_percent = profit_percent;\r\n\r\n        // Compound profit\r\n        //stakes[address(msg.sender)].amount = safeMultiply(stake_amount, (1+0)**duration_from_last_compute);\r\n        for (uint i=0; i< duration_from_last_compute; i++) {\r\n            uint256 profit = safeDivision(safeMultiply(profit_percent, stakes[address(msg.sender)].amount), 1000);\r\n            stakes[address(msg.sender)].amount += profit;\r\n            stakes[address(msg.sender)].pure_profit += profit;\r\n        }\r\n\r\n    }\r\n\r\n    function buyStatus(uint8 status, address[] memory referrals) public returns(bool) {\r\n        require(status > stakes[address(msg.sender)].status, \"Status already bought. Or attemption to buy lower status\");\r\n\r\n        uint delta_amount = statuses[status].price - statuses[stakes[address(msg.sender)].status].price;\r\n        uint256 residue = delta_amount;\r\n        uint[10] memory ref_parts = [uint(200), 100, 50, 30, 20, 20, 20, 20, 20, 20];\r\n        for (uint i=0; i<referrals.length; i++) {\r\n            uint256 amount_to_send = safeDivision(safeMultiply(delta_amount, ref_parts[i]), 1000);\r\n            usdtTokenContract.transferFrom(msg.sender, address(referrals[i]), amount_to_send);\r\n            residue -= amount_to_send;\r\n        }\r\n        if (residue > 0) {\r\n            usdtTokenContract.transferFrom(msg.sender, address(this), residue);\r\n        }\r\n        stakes[address(msg.sender)].status = status;\r\n        return true;\r\n    }\r\n\r\n    function sendToStaking(uint256 numberOfTokens) public returns(bool) {\r\n        require(numberOfTokens > 0, \"You need to sell at least some tokens\");\r\n\r\n        uint256 allowance = tokenContract.allowance(msg.sender, address(this));\r\n        require(allowance >= numberOfTokens, \"Check the token allowance\");\r\n\r\n\r\n        tokenContract.transferFrom(msg.sender, address(this), numberOfTokens);\r\n        if (stakes[address(msg.sender)].amount > 0) {\r\n            computeAmount();\r\n            stakes[address(msg.sender)].amount = stakes[address(msg.sender)].amount + numberOfTokens;\r\n            return true;\r\n        }\r\n        stakes[address(msg.sender)] = Stake(\r\n            now, //start_time\r\n            numberOfTokens, //amount\r\n\r\n            now, //week_starts_at\r\n            0, //week_withdrawal_amount\r\n            now , //last_withdrawal_time\r\n\r\n            now, //last_compute_time\r\n            0, //last_percent\r\n            0, //pure_profit\r\n            stakes[address(msg.sender)].status //status\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function set_valid_amount_by_status(uint256 numberOfTokens) internal returns(uint256) {\r\n        uint8 status = stakes[address(msg.sender)].status;\r\n        uint usd_amount = safeDivision(safeMultiply(numberOfTokens, wdx_price), 10**18);\r\n        uint week = 604800;\r\n\r\n        if (now - stakes[address(msg.sender)].week_starts_at > week) {\r\n            stakes[address(msg.sender)].week_withdrawal_amount = 0;\r\n            uint weeks_count_from_last = safeDivision(now - stakes[address(msg.sender)].week_starts_at, week);\r\n            stakes[address(msg.sender)].week_starts_at += safeMultiply(week, weeks_count_from_last);\r\n        }\r\n\r\n        if (stakes[address(msg.sender)].week_withdrawal_amount + usd_amount > statuses[status].limit) {\r\n            usd_amount = statuses[status].limit - stakes[address(msg.sender)].week_withdrawal_amount;\r\n        }\r\n        require(usd_amount > 0, \"Limit is exceeded\");\r\n        return usd_amount;\r\n    }\r\n\r\n    function getFromStaking(uint256 numberOfTokens) public returns(bool) {\r\n        require(numberOfTokens > 0, \"You need to get at least some tokens\");\r\n\r\n        computeAmount();\r\n\r\n        uint usd_amount = set_valid_amount_by_status(numberOfTokens);\r\n        numberOfTokens = safeDivision(safeMultiply(usd_amount, 10**18), wdx_price);\r\n\r\n        tokenContract.transfer(address(msg.sender), numberOfTokens);\r\n\r\n        stakes[address(msg.sender)].last_withdrawal_time = now;\r\n        stakes[address(msg.sender)].amount = stakes[address(msg.sender)].amount - numberOfTokens;\r\n        stakes[address(msg.sender)].week_withdrawal_amount += usd_amount;\r\n        return true;\r\n    }\r\n\r\n    function getUSDT() public {\r\n        require(msg.sender == owner);\r\n\r\n        // Send unsold tokens to the owner.\r\n        usdtTokenContract.transfer(owner, usdtTokenContract.balanceOf(address(this)));\r\n    }\r\n\r\n    function updateWDXPrice(uint price) public {\r\n        require(msg.sender == owner);\r\n        wdx_price = price;\r\n    }\r\n\r\n    function setStatusByAdmin(uint8 status, address user) public {\r\n        require(msg.sender == owner);\r\n        stakes[user].status = status;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"contract IUSDTToken\",\"name\":\"_usdtTokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"referrals\",\"type\":\"address[]\"}],\"name\":\"buyStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"getFromStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getUSDT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"sendToStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"setStatusByAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"week_starts_at\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"week_withdrawal_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_withdrawal_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_compute_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pure_profit\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"statuses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referal_lines\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"updateWDXPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdtTokenContract\",\"outputs\":[{\"internalType\":\"contract IUSDTToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wdx_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WDXStacking","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001138f905505dcb0cbb0027529338fd34b74fc33e000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8196e6520dfd0d9f71d8ef194b7cc0e6908d393c7e514f2427b9a09a55b8de60"}]}