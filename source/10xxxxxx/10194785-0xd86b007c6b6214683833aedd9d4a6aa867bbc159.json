{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17; // optimization runs: 200, evm version: istanbul\r\n\r\n\r\ninterface IERC20 {\r\n    function transfer(address, uint256) external returns (bool);\r\n    function approve(address, uint256) external returns (bool);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function allowance(address, address) external view returns (uint256);\r\n}\r\n\r\n\r\n/// @notice This contract serves as an isolated execution environment for\r\n/// performing Eth-to-ERC20, ERC20-to-Eth, and ERC20-to-ERC20 trades in a\r\n/// manner that does not require the initiating account to issue any ERC20\r\n/// approvals. DO NOT approve *this* contract, as anyone will be able to\r\n/// steal the approved tokens. Instead, transfer in the tokens and call\r\n/// `tradeERC20ForEth` or `tradeERC20ForERC20` to swap for the respective\r\n/// asset (obviously, these steps must be performed atomically). For\r\n/// Eth-to-ERC20, simply supply ether with the call to `tradeEthForERC20`.\r\n/// Be sure to include a parameter with the expected amount - this serves\r\n/// as a minimum that the contract must be able to return at the end of\r\n/// the swap, reverting if the received amount is insufficient.\r\n/// @author 0age\r\ncontract ApprovalBufferV1 {\r\n    /**\r\n    * @notice Accept Ether in the fallback.\r\n    */\r\n    function () external payable {}\r\n    \r\n    /// @notice target is the dex to call and data is the payload\r\n    function tradeEthForERC20(\r\n        IERC20 tokenToReceive,\r\n        uint256 tokenAmountExpected,\r\n        address payable target,\r\n        bytes calldata data\r\n    ) external payable returns (uint256 tokenAmountReceived) {\r\n        // Call into the provided target, supplying ETH and data.\r\n        (bool ok,) = target.call.value(address(this).balance)(data);\r\n        \r\n        // Revert with reason if the call was not successful.\r\n        _revertOnFailure(ok);\r\n        \r\n        // Determine the total token balance of this contract.\r\n        tokenAmountReceived = tokenToReceive.balanceOf(address(this));\r\n        \r\n        // Ensure that enough tokens were received.\r\n        require(\r\n            tokenAmountReceived >= tokenAmountExpected,\r\n            \"Trade did not result in the expected amount of tokens.\"\r\n        );\r\n        \r\n        // Transfer the tokens to the caller and revert on failure.\r\n        ok = (tokenToReceive.transfer(msg.sender, tokenAmountReceived));\r\n        require(ok, \"ERC20 transfer out failed.\");\r\n    }\r\n\r\n    /// @notice target is the dex to call and data is the payload\r\n    function tradeERC20ForEth(\r\n        IERC20 tokenToGive,\r\n        uint256 ethExpected,\r\n        address target,\r\n        bytes calldata data\r\n    ) external returns (uint256 ethReceived) {\r\n        // Ensure that target has allowance to transfer tokens.\r\n        if (tokenToGive.allowance(address(this), target) != uint256(-1)) {\r\n            tokenToGive.approve(target, uint256(-1));\r\n        }\r\n        \r\n        // Call into the provided target, providing data.\r\n        (bool ok,) = target.call(data);\r\n        \r\n        // Revert with reason if the call was not successful.\r\n        _revertOnFailure(ok);\r\n        \r\n        // Determine the total Ether balance of this contract.\r\n        ethReceived = address(this).balance;\r\n\r\n        // Ensure that enough Ether was received.\r\n        require(\r\n            ethReceived >= ethExpected,\r\n            \"Trade did not result in the expected amount of Ether.\"\r\n        );\r\n   \r\n        // Transfer the Ether to the caller and revert on failure.\r\n        (ok, ) = msg.sender.call.gas(4999).value(ethReceived)(\"\");\r\n\r\n        // Revert with reason if the call was not successful.\r\n        _revertOnFailure(ok);\r\n    }\r\n\r\n    /// @notice target is the dex to call and data is the payload\r\n    function tradeERC20ForERC20(\r\n        IERC20 tokenToGive,\r\n        IERC20 tokenToReceive,\r\n        uint256 tokenAmountExpected,\r\n        address payable target,\r\n        bytes calldata data\r\n    ) external payable returns (uint256 tokenAmountReceived) {\r\n        // Ensure that target has allowance to transfer tokens.\r\n        if (tokenToGive.allowance(address(this), target) != uint256(-1)) {\r\n            tokenToGive.approve(target, uint256(-1));\r\n        }\r\n        \r\n        // Call into the provided target, providing data.\r\n        (bool ok,) = target.call(data);\r\n        \r\n        // Revert with reason if the call was not successful.\r\n        _revertOnFailure(ok);\r\n        \r\n        // Determine the total token balance of this contract.\r\n        tokenAmountReceived = tokenToReceive.balanceOf(address(this));\r\n        \r\n        // Ensure that enough tokens were received.\r\n        require(\r\n            tokenAmountReceived >= tokenAmountExpected,\r\n            \"Trade did not result in the expected amount of tokens.\"\r\n        );\r\n        \r\n        // Transfer the tokens to the caller and revert on failure.\r\n        ok = (tokenToReceive.transfer(msg.sender, tokenAmountReceived));\r\n        require(ok, \"ERC20 transfer out failed.\");\r\n    }\r\n\r\n    /// @notice pass along revert reasons on external calls.\r\n    function _revertOnFailure(bool ok) internal pure {\r\n        if (!ok) {\r\n            assembly {\r\n                returndatacopy(0, 0, returndatasize)\r\n                revert(0, returndatasize)\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenToGive\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenToReceive\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountExpected\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tradeERC20ForERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountReceived\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenToGive\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethExpected\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tradeERC20ForEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenToReceive\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountExpected\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tradeEthForERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountReceived\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ApprovalBufferV1","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://78385ac09a70e1438b00bb899340afef205c25b636520c6bb3ca136c6e6eeaae"}]}