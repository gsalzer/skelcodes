{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\r\n\r\n\r\ninterface ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes20 data) external;\r\n}\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n  function mult(uint256 x, uint256 y) internal pure returns (uint256) {\r\n      if (x == 0) {\r\n          return 0;\r\n      }\r\n\r\n      uint256 z = x * y;\r\n      require(z / x == y, \"Mult overflow\");\r\n      return z;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n  function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\r\n      require(y != 0, \"Div by zero\");\r\n      uint256 r = x / y;\r\n      if (x % y != 0) {\r\n          r = r + 1;\r\n      }\r\n\r\n      return r;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n    uint256 c = add(a,m);\r\n    uint256 d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n}\r\ninterface ERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function approveAndCall(address spender, uint tokens, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function burn(uint256 amount) external;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Admin{\r\n  mapping(address=>bool) public admin;\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract IContribute{\r\n  function donateTokens(uint256 todonate) public;\r\n}\r\ncontract Lottery is ApproveAndCallFallBack{\r\n  using SafeMath for uint;\r\n  mapping(uint => mapping (uint => uint)) public token_map;\r\n  mapping(uint => mapping (uint => address)) public entry_map;\r\n  mapping(uint => mapping (uint => uint)) public entry_position_map;\r\n\r\n  //read only\r\n  mapping(uint => mapping (address => uint)) public token_count_by_address;\r\n  mapping(uint => uint) public totalRoundTokens;\r\n\r\n  uint public current_round;\r\n  uint public entry_cursor;\r\n  uint public cursor;\r\n  ERC20 public tributeToken;\r\n  ERC20 public liquidityToken;\r\n  IContribute public contributeContract;\r\n  uint public tokensToSend;\r\n  Admin public administration; //other contracts allowed to access functions\r\n  bytes32 public entropyHash;//secret for preventing miner manipulation of random\r\n  uint256 public finalizationBlock;//the block from which random winner will be derived\r\n  uint256 public winningIndex;\r\n  bool public finalizingLock=false;\r\n  uint public lastDrawing=0;\r\n  uint public startingLiquidityTokens=0;\r\n  uint public maxRewardable=15;//15%\r\n  uint public minTimeBetweenDrawings=24 hours;//10 minutes;//6 days;\r\n\r\n  modifier isAdmin(){\r\n    require(administration.admin(msg.sender),\"is not admin\");\r\n    _;\r\n  }\r\n  modifier isStakingTime(){\r\n    require(!finalizingLock,\"is not staking time\");\r\n    _;\r\n  }\r\n  constructor(address token,address a,address fundsDestination) public{\r\n    tributeToken=ERC20(token);\r\n\r\n    administration=Admin(a);\r\n    contributeContract=IContribute(fundsDestination);\r\n  }\r\n  /*\r\n    call this AFTER sending liquidity tokens\r\n  */\r\n  function init(address liqToken) public isAdmin{\r\n    require(lastDrawing==0,\"must be before any dispersal\");\r\n    liquidityToken=ERC20(liqToken);\r\n    startingLiquidityTokens=liquidityToken.balanceOf(address(this));\r\n  }\r\n  function setWinningIndex1(bytes32 eh) public isAdmin{\r\n    require(startingLiquidityTokens>0);\r\n    require(now>=lastDrawing.add(minTimeBetweenDrawings),\"is not finalization time\");\r\n    require(finalizationBlock==0||block.number>finalizationBlock+256,\"finalization block is already set\");\r\n    entropyHash=eh;\r\n    finalizationBlock=block.number+1;\r\n    finalizingLock=true;\r\n    lastDrawing=now;\r\n  }\r\n  //must call this before 256 blocks pass from setWinnngIndex1\r\n  function setWinningIndex2(uint a,uint b) public isAdmin{\r\n    require(finalizationBlock!=0,\"fblock is zero\");\r\n    require(block.number>=finalizationBlock,\"block number not large enough yet\");\r\n    require(block.number<finalizationBlock+256,\"block number progressed too far\");\r\n    require(keccak256(abi.encodePacked(a,b))==entropyHash,\"hash does not match\");\r\n    winningIndex=random(cursor,finalizationBlock,a);\r\n  }\r\n  function withdrawFunds(uint left,uint right,address winner,uint reward) public isAdmin{\r\n    require(getWinningIndex().sub(left)!=getWinningIndex().add(right),\"w1\");//checked indexes should be different positions\r\n    require(getWinningIndex()!=0,\"w2\");\r\n    uint leftval=token_map[current_round][getWinningIndex().sub(left)];\r\n    uint rightval=token_map[current_round][getWinningIndex().add(right)];\r\n    require(leftval!=0,\"w3\");//both checked indexes should be nonzero\r\n    require(leftval==rightval,\"w4\");//both checked values should be the same\r\n    require(winner == entry_map[current_round][leftval],\"w5\");//check that the proposed winner actually submitted the given entry\r\n\r\n    //uint cbal=liquidityToken.balanceOf(address(this));\r\n    require(startingLiquidityTokens.mul(maxRewardable).div(100)>=reward,\"cannot reward too large a portion\");\r\n    liquidityToken.transfer(winner,reward);\r\n\r\n    current_round+=1;\r\n    entry_cursor=0;\r\n    cursor=0;\r\n    winningIndex=0;\r\n    finalizingLock=false;\r\n    finalizationBlock=0;\r\n  }\r\n  function getWinningIndex() public view returns(uint256){\r\n    return winningIndex;\r\n  }\r\n  function getWinningOffsets() public view returns(uint,uint){\r\n    if(getWinningIndex()==0 || entry_cursor<1){\r\n      return(0,0);\r\n    }\r\n    if(entry_cursor==1){\r\n      return (getWinningIndex()-1,cursor-getWinningIndex());//then return the first entry (the only one)\r\n    }\r\n    for(uint i=2;i<=entry_cursor;i++){\r\n      if(entry_position_map[current_round][i]>getWinningIndex()){\r\n        return (getWinningIndex()-entry_position_map[current_round][i-1],entry_position_map[current_round][i]-1-getWinningIndex());\r\n      }\r\n    }\r\n    return (getWinningIndex()-entry_position_map[current_round][entry_cursor],cursor-getWinningIndex());\r\n  }\r\n  function getWinningAddress() public view returns(address){\r\n    (uint l,uint r) = getWinningOffsets();\r\n    return entry_map[current_round][token_map[current_round][getWinningIndex()-l]];\r\n  }\r\n  function getHashCombo(uint a,uint b) public pure returns(bytes32){\r\n    return keccak256(abi.encodePacked(a,b));\r\n  }\r\n  function maxRandom(uint blockn, uint256 entropy)\r\n    internal view\r\n    returns (uint256 randomNumber)\r\n  {\r\n      return uint256(keccak256(\r\n          abi.encodePacked(\r\n            blockhash(blockn),\r\n            entropy)\r\n      ));\r\n  }\r\n  function random(uint256 upper, uint256 blockn, uint256 entropy)\r\n    internal view\r\n    returns (uint256 randomNumber)\r\n  {\r\n      return maxRandom(blockn, entropy) % upper + 1;\r\n  }\r\n  function checkAndTransfer(\r\n      uint256 _amount,\r\n      address _from\r\n  )\r\n      private\r\n  {\r\n      require(\r\n          tributeToken.transferFrom(\r\n              _from,\r\n              address(this),\r\n              _amount\r\n          ) == true, \"transfer must succeed\"\r\n      );\r\n  }\r\n  //event DebugTest(uint allowed,uint amount,address from,address tokenAddr,address sender,address lotteryAddr);\r\n\r\n  function receiveApproval(address from, uint256 tokens, address tokenAddr, bytes20 data) external{\r\n    require(msg.sender==address(tributeToken));\r\n    //emit DebugTest(ERC20(msg.sender).allowance(from,address(this)),tokens,from,tokenAddr,msg.sender,address(this));\r\n\r\n    checkAndTransfer(tokens,from);\r\n    tributeToken.approve(address(contributeContract),tokens/2);\r\n    contributeContract.donateTokens(tokens/2);\r\n    tributeToken.burn(tokens/2);\r\n    enter(from,tokens);\r\n\r\n  }\r\n\r\n  function enter(address entrant,uint toLock) private isStakingTime{\r\n    require(!finalizingLock,\"contest is now finalizing please wait\");\r\n    require(toLock>3,\"must lock a minimal quantity of tokens\");\r\n    entry_cursor=entry_cursor.add(1);\r\n    token_map[current_round][cursor.add(1)]=entry_cursor;\r\n    token_map[current_round][cursor.add(toLock)]=entry_cursor;\r\n    entry_position_map[current_round][entry_cursor]=cursor.add(1);\r\n    cursor=cursor.add(toLock);\r\n    entry_map[current_round][entry_cursor]=entrant;//msg.sender;\r\n    token_count_by_address[current_round][entrant]=token_count_by_address[current_round][entrant].add(toLock);\r\n    totalRoundTokens[current_round]=totalRoundTokens[current_round].add(toLock);\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fundsDestination\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"administration\",\"outputs\":[{\"internalType\":\"contract Admin\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributeContract\",\"outputs\":[{\"internalType\":\"contract IContribute\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"current_round\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"entropyHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"entry_cursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entry_map\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entry_position_map\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizationBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizingLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"getHashCombo\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningOffsets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"liqToken\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDrawing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidityToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRewardable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTimeBetweenDrawings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"bytes20\",\"name\":\"data\",\"type\":\"bytes20\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"eh\",\"type\":\"bytes32\"}],\"name\":\"setWinningIndex1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"setWinningIndex2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingLiquidityTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"token_count_by_address\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"token_map\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensToSend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalRoundTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tributeToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winningIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"left\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"right\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Lottery","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007031ab87dcc46818806ec07af46fa8c2ad2a2bfc0000000000000000000000006168f02a691afe7caba520d4df18665e9c780cc60000000000000000000000008ee57d45794b80588e9e5102ce0bdcc4f612bbd3","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://289a12c50f7cc988416b2aa82b198efcc6466ea4c453c84ceeab2405f5a6f01e"}]}