{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOFactory.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./BokkyPooBahsDateTimeLibrary.sol\\\";\\r\\nimport \\\"./Strings.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ACOFactory\\r\\n * @dev The contract is the implementation for the ACOProxy.\\r\\n */\\r\\ncontract ACOFactory {\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the factory admin address has been changed.\\r\\n     * @param previousFactoryAdmin Address of the previous factory admin.\\r\\n     * @param newFactoryAdmin Address of the new factory admin.\\r\\n     */\\r\\n    event SetFactoryAdmin(address previousFactoryAdmin, address newFactoryAdmin);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the ACO token implementation has been changed.\\r\\n     * @param previousAcoTokenImplementation Address of the previous ACO token implementation.\\r\\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\\r\\n     */\\r\\n    event SetAcoTokenImplementation(address previousAcoTokenImplementation, address newAcoTokenImplementation);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the ACO fee has been changed.\\r\\n     * @param previousAcoFee Value of the previous ACO fee.\\r\\n     * @param newAcoFee Value of the new ACO fee.\\r\\n     */\\r\\n    event SetAcoFee(uint256 previousAcoFee, uint256 newAcoFee);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the ACO fee destination address has been changed.\\r\\n     * @param previousAcoFeeDestination Address of the previous ACO fee destination.\\r\\n     * @param newAcoFeeDestination Address of the new ACO fee destination.\\r\\n     */\\r\\n    event SetAcoFeeDestination(address previousAcoFeeDestination, address newAcoFeeDestination);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when a new ACO token has been created.\\r\\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\\r\\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\\r\\n     * @param isCall True if the type is CALL, false for PUT.\\r\\n     * @param strikePrice The strike price with the strike asset precision.\\r\\n     * @param expiryTime The UNIX time for the ACO token expiration.\\r\\n     * @param acoToken Address of the new ACO token created.\\r\\n     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\\r\\n     */\\r\\n    event NewAcoToken(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation);\\r\\n    \\r\\n    /**\\r\\n     * @dev The ACO fee value. \\r\\n     * It is a percentage value (100000 is 100%).\\r\\n     */\\r\\n    uint256 public acoFee;\\r\\n    \\r\\n    /**\\r\\n     * @dev The factory admin address.\\r\\n     */\\r\\n    address public factoryAdmin;\\r\\n    \\r\\n    /**\\r\\n     * @dev The ACO token implementation address.\\r\\n     */\\r\\n    address public acoTokenImplementation;\\r\\n    \\r\\n    /**\\r\\n     * @dev The ACO fee destination address.\\r\\n     */\\r\\n    address public acoFeeDestination;\\r\\n    \\r\\n    /**\\r\\n     * @dev Modifier to check if the `msg.sender` is the factory admin.\\r\\n     * Only factory admin address can execute.\\r\\n     */\\r\\n    modifier onlyFactoryAdmin() {\\r\\n        require(msg.sender == factoryAdmin, \\\"ACOFactory::onlyFactoryAdmin\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to initialize the contract.\\r\\n     * It should be called through the `data` argument when creating the proxy.\\r\\n     * It must be called only once. The `assert` is to guarantee that behavior.\\r\\n     * @param _factoryAdmin Address of the factory admin.\\r\\n     * @param _acoTokenImplementation Address of the ACO token implementation.\\r\\n     * @param _acoFee Value of the ACO fee.\\r\\n     * @param _acoFeeDestination Address of the ACO fee destination.\\r\\n     */\\r\\n    function init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) public {\\r\\n        require(factoryAdmin == address(0) \\u0026\\u0026 acoTokenImplementation == address(0), \\\"ACOFactory::init: Contract already initialized.\\\");\\r\\n        \\r\\n        _setFactoryAdmin(_factoryAdmin);\\r\\n        _setAcoTokenImplementation(_acoTokenImplementation);\\r\\n        _setAcoFee(_acoFee);\\r\\n        _setAcoFeeDestination(_acoFeeDestination);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to guarantee that the contract will not receive ether.\\r\\n     */\\r\\n    receive() external payable virtual {\\r\\n        revert();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to create a new ACO token.\\r\\n     * It deploys a minimal proxy for the ACO token implementation address. \\r\\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\\r\\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\\r\\n     * @param isCall Whether the ACO token is the Call type.\\r\\n     * @param strikePrice The strike price with the strike asset precision.\\r\\n     * @param expiryTime The UNIX time for the ACO token expiration.\\r\\n     */\\r\\n    function createAcoToken(\\r\\n        address underlying, \\r\\n        address strikeAsset, \\r\\n        bool isCall,\\r\\n        uint256 strikePrice, \\r\\n        uint256 expiryTime\\r\\n    ) onlyFactoryAdmin external virtual {\\r\\n        address acoToken = _deployAcoToken(_getAcoTokenInitData(underlying, strikeAsset, isCall, strikePrice, expiryTime));\\r\\n        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);   \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the factory admin address.\\r\\n     * Only can be called by the factory admin.\\r\\n     * @param newFactoryAdmin Address of the new factory admin.\\r\\n     */\\r\\n    function setFactoryAdmin(address newFactoryAdmin) onlyFactoryAdmin external virtual {\\r\\n        _setFactoryAdmin(newFactoryAdmin);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the ACO token implementation address.\\r\\n     * Only can be called by the factory admin.\\r\\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\\r\\n     */\\r\\n    function setAcoTokenImplementation(address newAcoTokenImplementation) onlyFactoryAdmin external virtual {\\r\\n        _setAcoTokenImplementation(newAcoTokenImplementation);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the ACO fee.\\r\\n     * Only can be called by the factory admin.\\r\\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\\r\\n     */\\r\\n    function setAcoFee(uint256 newAcoFee) onlyFactoryAdmin external virtual {\\r\\n        _setAcoFee(newAcoFee);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the ACO destination address.\\r\\n     * Only can be called by the factory admin.\\r\\n     * @param newAcoFeeDestination Address of the new ACO destination.\\r\\n     */\\r\\n    function setAcoFeeDestination(address newAcoFeeDestination) onlyFactoryAdmin external virtual {\\r\\n        _setAcoFeeDestination(newAcoFeeDestination);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the factory admin address.\\r\\n     * @param newFactoryAdmin Address of the new factory admin.\\r\\n     */\\r\\n    function _setFactoryAdmin(address newFactoryAdmin) internal virtual {\\r\\n        require(newFactoryAdmin != address(0), \\\"ACOFactory::_setFactoryAdmin: Invalid factory admin\\\");\\r\\n        emit SetFactoryAdmin(factoryAdmin, newFactoryAdmin);\\r\\n        factoryAdmin = newFactoryAdmin;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the ACO token implementation address.\\r\\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\\r\\n     */\\r\\n    function _setAcoTokenImplementation(address newAcoTokenImplementation) internal virtual {\\r\\n        require(Address.isContract(newAcoTokenImplementation), \\\"ACOFactory::_setAcoTokenImplementation: Invalid ACO token implementation\\\");\\r\\n        emit SetAcoTokenImplementation(acoTokenImplementation, newAcoTokenImplementation);\\r\\n        acoTokenImplementation = newAcoTokenImplementation;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the ACO fee.\\r\\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\\r\\n     */\\r\\n    function _setAcoFee(uint256 newAcoFee) internal virtual {\\r\\n        emit SetAcoFee(acoFee, newAcoFee);\\r\\n        acoFee = newAcoFee;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the ACO destination address.\\r\\n     * @param newAcoFeeDestination Address of the new ACO destination.\\r\\n     */\\r\\n    function _setAcoFeeDestination(address newAcoFeeDestination) internal virtual {\\r\\n        require(newAcoFeeDestination != address(0), \\\"ACOFactory::_setAcoFeeDestination: Invalid ACO fee destination\\\");\\r\\n        emit SetAcoFeeDestination(acoFeeDestination, newAcoFeeDestination);\\r\\n        acoFeeDestination = newAcoFeeDestination;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the ACO token initialize data.\\r\\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\\r\\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\\r\\n     * @param isCall True if the type is CALL, false for PUT.\\r\\n     * @param strikePrice The strike price with the strike asset precision.\\r\\n     * @param expiryTime The UNIX time for the ACO token expiration.\\r\\n     * @return ABI encoded with signature for initializing ACO token.\\r\\n     */\\r\\n    function _getAcoTokenInitData(\\r\\n        address underlying, \\r\\n        address strikeAsset, \\r\\n        bool isCall,\\r\\n        uint256 strikePrice, \\r\\n        uint256 expiryTime\\r\\n    ) internal view virtual returns(bytes memory) {\\r\\n        return abi.encodeWithSignature(\\\"init(address,address,bool,uint256,uint256,uint256,address)\\\",\\r\\n            underlying,\\r\\n            strikeAsset,\\r\\n            isCall,\\r\\n            strikePrice,\\r\\n            expiryTime,\\r\\n            acoFee,\\r\\n            acoFeeDestination\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to deploy a minimal proxy using ACO token implementation.\\r\\n     * @param initData ABI encoded with signature for initializing the new ACO token.\\r\\n     * @return Address of the new minimal proxy deployed for the ACO token.\\r\\n     */\\r\\n    function _deployAcoToken(bytes memory initData) internal virtual returns(address) {\\r\\n        require(initData.length \\u003e 0, \\\"ACOFactory::_deployToken: Invalid init data\\\");\\r\\n        bytes20 implentationBytes = bytes20(acoTokenImplementation);\\r\\n        address proxy;\\r\\n        assembly {\\r\\n            let clone := mload(0x40)\\r\\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\r\\n            mstore(add(clone, 0x14), implentationBytes)\\r\\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\r\\n            proxy := create(0, clone, 0x37)\\r\\n        }\\r\\n        (bool success, bytes memory returnData) = proxy.call(initData);\\r\\n        require(success, _acoTokenInititalizeError(returnData));\\r\\n        return proxy;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to handle the return data on initializing ACO token with an error.\\r\\n     * 4 bytes (function signature) + 32 bytes (offset) + 32 bytes (error string length) + X bytes (error string)\\r\\n     * @param data Returned data with an error.\\r\\n     * @return String with the error.\\r\\n     */\\r\\n    function _acoTokenInititalizeError(bytes memory data) internal pure virtual returns(string memory) {\\r\\n        if (data.length \\u003e= 100) {\\r\\n            bytes memory buffer = new bytes(data.length - 68);\\r\\n            uint256 index = 0;\\r\\n            for (uint256 i = 68; i \\u003c data.length; ++i) {\\r\\n                buffer[index++] = data[i];\\r\\n            }\\r\\n            return string(buffer);\\r\\n        } else {\\r\\n            return \\\"ACOFactory::_acoTokenInititalizeError\\\";\\r\\n        }  \\r\\n    }\\r\\n}\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"BokkyPooBahsDateTimeLibrary.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// BokkyPooBah\\u0027s DateTime Library v1.01\\r\\n//\\r\\n// A gas-efficient Solidity date and time library\\r\\n//\\r\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\r\\n//\\r\\n// Tested date range 1970/01/01 to 2345/12/31\\r\\n//\\r\\n// Conventions:\\r\\n// Unit      | Range         | Notes\\r\\n// :-------- |:-------------:|:-----\\r\\n// timestamp | \\u003e= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\r\\n// year      | 1970 ... 2345 |\\r\\n// month     | 1 ... 12      |\\r\\n// day       | 1 ... 31      |\\r\\n// hour      | 0 ... 23      |\\r\\n// minute    | 0 ... 59      |\\r\\n// second    | 0 ... 59      |\\r\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\r\\n//\\r\\n//\\r\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------\\r\\n\\r\\nlibrary BokkyPooBahsDateTimeLibrary {\\r\\n\\r\\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n    uint constant SECONDS_PER_HOUR = 60 * 60;\\r\\n    uint constant SECONDS_PER_MINUTE = 60;\\r\\n    int constant OFFSET19700101 = 2440588;\\r\\n\\r\\n    uint constant DOW_MON = 1;\\r\\n    uint constant DOW_TUE = 2;\\r\\n    uint constant DOW_WED = 3;\\r\\n    uint constant DOW_THU = 4;\\r\\n    uint constant DOW_FRI = 5;\\r\\n    uint constant DOW_SAT = 6;\\r\\n    uint constant DOW_SUN = 7;\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // days = day\\r\\n    //      - 32075\\r\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\r\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\r\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\r\\n    //      - offset\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\\r\\n        require(year \\u003e= 1970);\\r\\n        int _year = int(year);\\r\\n        int _month = int(month);\\r\\n        int _day = int(day);\\r\\n\\r\\n        int __days = _day\\r\\n          - 32075\\r\\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\\r\\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\\r\\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\\r\\n          - OFFSET19700101;\\r\\n\\r\\n        _days = uint(__days);\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // int L = days + 68569 + offset\\r\\n    // int N = 4 * L / 146097\\r\\n    // L = L - (146097 * N + 3) / 4\\r\\n    // year = 4000 * (L + 1) / 1461001\\r\\n    // L = L - 1461 * year / 4 + 31\\r\\n    // month = 80 * L / 2447\\r\\n    // dd = L - 2447 * month / 80\\r\\n    // L = month / 11\\r\\n    // month = month + 2 - 12 * L\\r\\n    // year = 100 * (N - 49) + year + L\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\\r\\n        int __days = int(_days);\\r\\n\\r\\n        int L = __days + 68569 + OFFSET19700101;\\r\\n        int N = 4 * L / 146097;\\r\\n        L = L - (146097 * N + 3) / 4;\\r\\n        int _year = 4000 * (L + 1) / 1461001;\\r\\n        L = L - 1461 * _year / 4 + 31;\\r\\n        int _month = 80 * L / 2447;\\r\\n        int _day = L - 2447 * _month / 80;\\r\\n        L = _month / 11;\\r\\n        _month = _month + 2 - 12 * L;\\r\\n        _year = 100 * (N - 49) + _year + L;\\r\\n\\r\\n        year = uint(_year);\\r\\n        month = uint(_month);\\r\\n        day = uint(_day);\\r\\n    }\\r\\n\\r\\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\\r\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\r\\n    }\\r\\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\\r\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\\r\\n    }\\r\\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\\r\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\\r\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        uint secs = timestamp % SECONDS_PER_DAY;\\r\\n        hour = secs / SECONDS_PER_HOUR;\\r\\n        secs = secs % SECONDS_PER_HOUR;\\r\\n        minute = secs / SECONDS_PER_MINUTE;\\r\\n        second = secs % SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\\r\\n        if (year \\u003e= 1970 \\u0026\\u0026 month \\u003e 0 \\u0026\\u0026 month \\u003c= 12) {\\r\\n            uint daysInMonth = _getDaysInMonth(year, month);\\r\\n            if (day \\u003e 0 \\u0026\\u0026 day \\u003c= daysInMonth) {\\r\\n                valid = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\\r\\n        if (isValidDate(year, month, day)) {\\r\\n            if (hour \\u003c 24 \\u0026\\u0026 minute \\u003c 60 \\u0026\\u0026 second \\u003c 60) {\\r\\n                valid = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\\r\\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        leapYear = _isLeapYear(year);\\r\\n    }\\r\\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\\r\\n        leapYear = ((year % 4 == 0) \\u0026\\u0026 (year % 100 != 0)) || (year % 400 == 0);\\r\\n    }\\r\\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\\r\\n        weekDay = getDayOfWeek(timestamp) \\u003c= DOW_FRI;\\r\\n    }\\r\\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\\r\\n        weekEnd = getDayOfWeek(timestamp) \\u003e= DOW_SAT;\\r\\n    }\\r\\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\\r\\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        daysInMonth = _getDaysInMonth(year, month);\\r\\n    }\\r\\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\\r\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\r\\n            daysInMonth = 31;\\r\\n        } else if (month != 2) {\\r\\n            daysInMonth = 30;\\r\\n        } else {\\r\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\r\\n        }\\r\\n    }\\r\\n    // 1 = Monday, 7 = Sunday\\r\\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\\r\\n        uint _days = timestamp / SECONDS_PER_DAY;\\r\\n        dayOfWeek = (_days + 3) % 7 + 1;\\r\\n    }\\r\\n\\r\\n    function getYear(uint timestamp) internal pure returns (uint year) {\\r\\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getMonth(uint timestamp) internal pure returns (uint month) {\\r\\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getDay(uint timestamp) internal pure returns (uint day) {\\r\\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getHour(uint timestamp) internal pure returns (uint hour) {\\r\\n        uint secs = timestamp % SECONDS_PER_DAY;\\r\\n        hour = secs / SECONDS_PER_HOUR;\\r\\n    }\\r\\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\\r\\n        uint secs = timestamp % SECONDS_PER_HOUR;\\r\\n        minute = secs / SECONDS_PER_MINUTE;\\r\\n    }\\r\\n    function getSecond(uint timestamp) internal pure returns (uint second) {\\r\\n        second = timestamp % SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        year += _years;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        month += _months;\\r\\n        year += (month - 1) / 12;\\r\\n        month = (month - 1) % 12 + 1;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _seconds;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n\\r\\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        year -= _years;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        uint yearMonth = year * 12 + (month - 1) - _months;\\r\\n        year = yearMonth / 12;\\r\\n        month = yearMonth % 12 + 1;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _seconds;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n\\r\\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\r\\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\r\\n        _years = toYear - fromYear;\\r\\n    }\\r\\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\r\\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\r\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\r\\n    }\\r\\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\r\\n    }\\r\\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\r\\n    }\\r\\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\r\\n    }\\r\\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _seconds = toTimestamp - fromTimestamp;\\r\\n    }\\r\\n}\\r\\n\"},\"Strings.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        uint256 index = digits - 1;\\r\\n        temp = value;\\r\\n        while (temp != 0) {\\r\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\r\\n            temp /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acoTokenImplementation\",\"type\":\"address\"}],\"name\":\"NewAcoToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousAcoFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAcoFee\",\"type\":\"uint256\"}],\"name\":\"SetAcoFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAcoFeeDestination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAcoFeeDestination\",\"type\":\"address\"}],\"name\":\"SetAcoFeeDestination\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAcoTokenImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAcoTokenImplementation\",\"type\":\"address\"}],\"name\":\"SetAcoTokenImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousFactoryAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFactoryAdmin\",\"type\":\"address\"}],\"name\":\"SetFactoryAdmin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acoFeeDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acoTokenImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"}],\"name\":\"createAcoToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factoryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factoryAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_acoTokenImplementation\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_acoFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_acoFeeDestination\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAcoFee\",\"type\":\"uint256\"}],\"name\":\"setAcoFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAcoFeeDestination\",\"type\":\"address\"}],\"name\":\"setAcoFeeDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAcoTokenImplementation\",\"type\":\"address\"}],\"name\":\"setAcoTokenImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFactoryAdmin\",\"type\":\"address\"}],\"name\":\"setFactoryAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOFactory","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d18cc52df86a631782d50d6fb3de3f58645d79f0c537456a5296335e8944e329"}]}