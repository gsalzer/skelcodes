{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.12;\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ninterface ERC20Token {\r\n\r\n    /**\r\n     * @notice send `_value` token to `_to` from `msg.sender`\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return success Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return success Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return success Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return balance The balance\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return remaining Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    /**\r\n     * @notice return total supply of tokens\r\n     */\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n\r\n    bool internal reentranceLock = false;\r\n\r\n    /**\r\n     * @dev Use this modifier on functions susceptible to reentrancy attacks\r\n     */\r\n    modifier reentrancyGuard() {\r\n        require(!reentranceLock, \"Reentrant call detected!\");\r\n        reentranceLock = true; // No no no, you naughty naughty!\r\n        _;\r\n        reentranceLock = false;\r\n    }\r\n}\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\r\n * @notice interface for StickerMarket\r\n */\r\ninterface StickerMarket {\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\n    event MarketState(State state);\r\n    event RegisterFee(uint256 value);\r\n    event BurnRate(uint256 value);\r\n\r\n    enum State { Invalid, Open, BuyOnly, Controlled, Closed }\r\n\r\n    function state() external view returns(State);\r\n    function snt() external view returns (address);\r\n    function stickerPack() external view returns (address);\r\n    function stickerType() external view returns (address);\r\n\r\n    /**\r\n     * @dev Mints NFT StickerPack in `_destination` account, and Transfers SNT using user allowance\r\n     * emit NonfungibleToken.Transfer(`address(0)`, `_destination`, `tokenId`)\r\n     * @notice buy a pack from market pack owner, including a StickerPack's token in `_destination` account with same metadata of `_packId`\r\n     * @param _packId id of market pack\r\n     * @param _destination owner of token being brought\r\n     * @param _price agreed price\r\n     * @return tokenId generated StickerPack token\r\n     */\r\n    function buyToken(\r\n        uint256 _packId,\r\n        address _destination,\r\n        uint256 _price\r\n    )\r\n        external\r\n        returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev emits StickerMarket.Register(`packId`, `_urlHash`, `_price`, `_contenthash`)\r\n     * @notice Registers to sell a sticker pack\r\n     * @param _price cost in wei to users minting this pack\r\n     * @param _donate value between 0-10000 representing percentage of `_price` that is donated to StickerMarket at every buy\r\n     * @param _category listing category\r\n     * @param _owner address of the beneficiary of buys\r\n     * @param _contenthash EIP1577 pack contenthash for listings\r\n     * @param _fee Fee msg.sender agrees to pay for this registration\r\n     * @return packId Market position of Sticker Pack data.\r\n     */\r\n    function registerPack(\r\n        uint256 _price,\r\n        uint256 _donate,\r\n        bytes4[] calldata _category,\r\n        address _owner,\r\n        bytes calldata _contenthash,\r\n        uint256 _fee\r\n    )\r\n        external\r\n        returns(uint256 packId);\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev ERC-721 non-fungible token standard. \r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721\r\n{\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 indexed value\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n   * `onERC721Received` on `_to` and throws if the return value is not \r\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they mayb be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved The new approved NFT controller.\r\n   * @param _tokenId The NFT to approve.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @notice The contract MUST allow multiple operators per owner.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n    \r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId The NFT to find the approved address for.\r\n   * @return Address that _tokenId is approved for. \r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   * @return True if approved for all, false otherwise.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721Enumerable\r\n{\r\n\r\n  /**\r\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\r\n   * assigned and queryable owner not equal to the zero address.\r\n   * @return Total supply of NFTs.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   * @return Token id.\r\n   */\r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\r\n   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\r\n   * representing invalid NFTs.\r\n   * @param _owner An address where we are interested in NFTs owned by them.\r\n   * @param _index A counter less than `balanceOf(_owner)`.\r\n   * @return Token id.\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n}\r\n\r\n\r\n/**\r\n * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\r\n * @notice interface for StickerType\r\n */\r\n/* interface */ abstract contract StickerType is ERC721, ERC721Enumerable { // Interfaces can't inherit\r\n\r\n    /**\r\n     * @notice controller can generate packs at will\r\n     * @param _price cost in wei to users minting with _urlHash metadata\r\n     * @param _donate optional amount of `_price` that is donated to StickerMarket at every buy\r\n     * @param _category listing category\r\n     * @param _owner address of the beneficiary of buys\r\n     * @param _contenthash EIP1577 pack contenthash for listings\r\n     * @return packId Market position of Sticker Pack data.\r\n     */\r\n    function generatePack(\r\n        uint256 _price,\r\n        uint256 _donate,\r\n        bytes4[] calldata _category,\r\n        address _owner,\r\n        bytes calldata _contenthash\r\n    )\r\n        external\r\n        virtual\r\n        returns(uint256 packId);\r\n\r\n    /**\r\n     * @notice removes all market data about a marketed pack, can only be called by market controller\r\n     * @param _packId position to be deleted\r\n     * @param _limit limit of categories to cleanup\r\n     */\r\n    function purgePack(uint256 _packId, uint256 _limit)\r\n        external\r\n        virtual;\r\n\r\n    /**\r\n     * @notice changes contenthash of `_packId`, can only be called by controller\r\n     * @param _packId which market position is being altered\r\n     * @param _contenthash new contenthash\r\n     */\r\n    function setPackContenthash(uint256 _packId, bytes calldata _contenthash)\r\n        external\r\n        virtual;\r\n\r\n    /**\r\n     * @notice This method can be used by the controller to extract mistakenly\r\n     *  sent tokens to this contract.\r\n     * @param _token The address of the token contract that you want to recover\r\n     *  set to 0 in case you want to extract ether.\r\n     */\r\n    function claimTokens(address _token)\r\n        external\r\n        virtual;\r\n\r\n    /**\r\n     * @notice changes price of `_packId`, can only be called when market is open\r\n     * @param _packId pack id changing price settings\r\n     * @param _price cost in wei to users minting this pack\r\n     * @param _donate value between 0-10000 representing percentage of `_price` that is donated to StickerMarket at every buy\r\n     */\r\n    function setPackPrice(uint256 _packId, uint256 _price, uint256 _donate)\r\n        external\r\n        virtual;\r\n\r\n    /**\r\n     * @notice add caregory in `_packId`, can only be called when market is open\r\n     * @param _packId pack adding category\r\n     * @param _category category to list\r\n     */\r\n    function addPackCategory(uint256 _packId, bytes4 _category)\r\n        external\r\n        virtual;\r\n\r\n    /**\r\n     * @notice remove caregory in `_packId`, can only be called when market is open\r\n     * @param _packId pack removing category\r\n     * @param _category category to unlist\r\n     */\r\n    function removePackCategory(uint256 _packId, bytes4 _category)\r\n        external\r\n        virtual;\r\n\r\n    /**\r\n     * @notice Changes if pack is enabled for sell\r\n     * @param _packId position edit\r\n     * @param _mintable true to enable sell\r\n     */\r\n    function setPackState(uint256 _packId, bool _mintable)\r\n        external\r\n        virtual;\r\n\r\n    /**\r\n     * @notice read available market ids in a category (might be slow)\r\n     * @param _category listing category\r\n     * @return availableIds array of market id registered\r\n     */\r\n    function getAvailablePacks(bytes4 _category)\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint256[] memory availableIds);\r\n\r\n    /**\r\n     * @notice count total packs in a category\r\n     * @param _category listing category\r\n     * @return size total number of packs in category\r\n     */\r\n    function getCategoryLength(bytes4 _category)\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint256 size);\r\n\r\n    /**\r\n     * @notice read a packId in the category list at a specific index\r\n     * @param _category listing category\r\n     * @param _index index\r\n     * @return packId on index\r\n     */\r\n    function getCategoryPack(bytes4 _category, uint256 _index)\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint256 packId);\r\n\r\n    /**\r\n     * @notice returns all data from pack in market\r\n     * @param _packId pack id being queried\r\n     * @return category list of categories registered to this packType\r\n     * @return owner authorship holder\r\n     * @return mintable new pack can be generated (rare tool)\r\n     * @return timestamp registration timestamp\r\n     * @return price current price\r\n     * @return contenthash EIP1577 encoded hash\r\n     */\r\n    function getPackData(uint256 _packId)\r\n        external\r\n        virtual\r\n        view\r\n        returns (\r\n            bytes4[] memory category,\r\n            address owner,\r\n            bool mintable,\r\n            uint256 timestamp,\r\n            uint256 price,\r\n            bytes memory contenthash\r\n        );\r\n\r\n    /**\r\n     * @notice returns all data from pack in market\r\n     * @param _packId pack id being queried\r\n     * @return category list of categories registered to this packType\r\n     * @return timestamp registration timestamp\r\n     * @return contenthash EIP1577 encoded hash\r\n     */\r\n    function getPackSummary(uint256 _packId)\r\n        external\r\n        virtual\r\n        view\r\n        returns (\r\n            bytes4[] memory category,\r\n            uint256 timestamp,\r\n            bytes memory contenthash\r\n        );\r\n\r\n    /**\r\n     * @notice returns payment data for migrated contract\r\n     * @param _packId pack id being queried\r\n     * @return owner authorship holder\r\n     * @return mintable new pack can be generated (rare tool)\r\n     * @return price current price\r\n     * @return donate informational value between 0-10000 representing percentage of `price` that is donated to StickerMarket at every buy\r\n     */\r\n    function getPaymentData(uint256 _packId)\r\n        external\r\n        virtual\r\n        view\r\n        returns (\r\n            address owner,\r\n            bool mintable,\r\n            uint256 price,\r\n            uint256 donate\r\n        );\r\n   \r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n * and https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n */\r\ncontract SafeTransfer {\r\n    \r\n    function _safeTransfer(ERC20Token token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function _safeTransferFrom(ERC20Token token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    \r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(ERC20Token token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(_isContract(address(token)), \"SafeTransfer: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeTransfer: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeTransfer: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function _isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\r\n * @notice Owner's backdoor withdrawal logic, used for code reuse.\r\n */\r\ncontract TokenWithdrawer is SafeTransfer {\r\n    /**\r\n     * @dev Withdraw all balance of each `_tokens` into `_destination`.\r\n     * @param _tokens address of ERC20 token, or zero for withdrawing ETH.\r\n     * @param _destination receiver of token\r\n     */\r\n    function withdrawTokens(\r\n        address[] memory _tokens,\r\n        address payable _destination\r\n    )\r\n        internal\r\n    {\r\n        uint len = _tokens.length;\r\n        for(uint i = 0; i < len; i++){\r\n            withdrawToken(_tokens[i], _destination);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw all balance of `_token` into `_destination`.\r\n     * @param _token address of ERC20 token, or zero for withdrawing ETH.\r\n     * @param _destination receiver of token\r\n     */\r\n    function withdrawToken(address _token, address payable _destination)\r\n        internal\r\n    {\r\n        uint256 balance;\r\n        if (_token == address(0)) {\r\n            balance = address(this).balance;\r\n            (bool success, ) = _destination.call.value(balance)(\"\");\r\n            require(success, \"Transfer failed\");\r\n        } else {\r\n            ERC20Token token = ERC20Token(_token);\r\n            balance = token.balanceOf(address(this));\r\n            _safeTransfer(token, _destination, balance);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title Starterpack Distributor\r\n/// @notice Attempts to deliver 1 and only 1 starterpack containing ETH, ERC20 Tokens and NFT Stickerpacks to an eligible recipient\r\n/// @dev The contract assumes Signer has verified an In-App Purchase Receipt, only 1 pack per address is allowed, unless the owner calls clearPurchases()\r\ncontract Distributor is SafeTransfer, ReentrancyGuard, TokenWithdrawer {\r\n    address payable private owner;  // Contract deployer can modify parameters\r\n    address private signer; // Signer can only distribute Starterpacks\r\n\r\n    // Defines the Starterpack parameters\r\n    struct Pack {\r\n        StickerMarket stickerMarket; // Sticker market contract for minting the sticker pack ids\r\n        uint256 ethAmount; // The Amount of ETH to transfer to the recipient\r\n        address[] tokens; // Array of ERC20 Contract Addresses\r\n        uint256[] tokenAmounts; // Array of ERC20 amounts corresponding to cells in tokens[]\r\n        uint256[] stickerPackIds; // Array of NFT's\r\n    }\r\n\r\n    Pack private defaultPack;\r\n    Pack private promoPack;\r\n    uint private promoAvailable;\r\n\r\n    ERC20Token public sntToken;\r\n\r\n    bool public pause = true;\r\n    \r\n    uint ineligibleVersion;\r\n    mapping(bytes32 => bool) public ineligible; // Used to make addresses ineligible for subsequent starterpacks, after successful transaction\r\n\r\n    event RequireApproval(address attribution);\r\n    \r\n    mapping(address => uint) public pendingAttributionCnt;\r\n    mapping(address => uint) public attributionCnt;\r\n    \r\n    struct Attribution {\r\n        bool enabled;\r\n        uint256 ethAmount; // The Amount of ETH to transfer to the referrer\r\n        address[] tokens; // Array of ERC20 Contract Addresses\r\n        uint256[] tokenAmounts; // Array of ERC20 amounts corresponding to cells in tokens[]\r\n        uint maxThreshold;\r\n    }\r\n    \r\n    mapping(address => Attribution) defaultAttributionSettings;\r\n    mapping(address => Attribution) promoAttributionSettings;\r\n\r\n    // Modifiers --------------------------------------------------------------------------------------------\r\n\r\n    // Functions only Owner can call\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Unauthorized\");\r\n        _;\r\n    }\r\n\r\n    // Logic ------------------------------------------------------------------------------------------------\r\n\r\n    /// @notice Check if an address is eligible for a starterpack\r\n    /// @dev will return false if a transaction of distributePack for _recipient has been successfully executed\r\n    /// @param _recipient The address to be checked for eligibility\r\n    function eligible(address _recipient) public view returns (bool){\r\n        return !ineligible[keccak256(abi.encodePacked(ineligibleVersion, _recipient))];\r\n    }\r\n\r\n    /// @notice Get the starter pack configuration\r\n    /// @return stickerMarket address Stickermarket contract address\r\n    /// @return ethAmount uint256 ETH amount in wei that will be sent to a recipient\r\n    /// @return tokens address[] List of tokens that will be sent to a recipient\r\n    /// @return tokenAmounts uint[] Amount of tokens that will be sent to a recipient\r\n    /// @return stickerPackIds uint[] List of sticker packs to send to a recipient\r\n    function getDefaultPack() external view returns(address stickerMarket, uint256 ethAmount, address[] memory tokens, uint[] memory tokenAmounts, uint[] memory stickerPackIds) {\r\n        stickerMarket = address(defaultPack.stickerMarket);\r\n        ethAmount = defaultPack.ethAmount;\r\n        tokens = defaultPack.tokens;\r\n        tokenAmounts = defaultPack.tokenAmounts;\r\n        stickerPackIds = defaultPack.stickerPackIds;\r\n    }\r\n\r\n    /// @notice Get the promo pack configuration\r\n    /// @return stickerMarket address Stickermarket contract address\r\n    /// @return ethAmount uint256 ETH amount in wei that will be sent to a recipient\r\n    /// @return tokens address[] List of tokens that will be sent to a recipient\r\n    /// @return tokenAmounts uint[] Amount of tokens that will be sent to a recipient\r\n    /// @return stickerPackIds uint[] List of sticker packs to send to a recipient\r\n    /// @return available uint number of promo packs available\r\n    function getPromoPack() external view returns(address stickerMarket, uint256 ethAmount, address[] memory tokens, uint[] memory tokenAmounts, uint[] memory stickerPackIds, uint256 available) {\r\n        stickerMarket = address(promoPack.stickerMarket);\r\n        ethAmount = promoPack.ethAmount;\r\n        tokens = promoPack.tokens;\r\n        tokenAmounts = promoPack.tokenAmounts;\r\n        stickerPackIds = promoPack.stickerPackIds;\r\n        available = promoAvailable;\r\n    }\r\n\r\n    event Distributed(address indexed recipient, address indexed attribution);\r\n\r\n    /// @notice Distributes a starterpack to an eligible address. Either a promo pack or a default will be distributed depending on availability\r\n    /// @dev Can only be called by signer, assumes signer has validated an IAP receipt, owner can block calling by pausing.\r\n    /// @param _recipient A payable address that is sent a starterpack after being checked for eligibility\r\n    /// @param _attribution A payable address who referred the starterpack purchaser \r\n    function distributePack(address payable _recipient, address payable _attribution) external reentrancyGuard {\r\n        require(!pause, \"Paused\");\r\n        require(msg.sender == signer, \"Unauthorized\");\r\n        require(eligible(_recipient), \"Recipient is not eligible.\");\r\n        require(_recipient != _attribution, \"Recipient should be different from Attribution address\");\r\n\r\n        Pack memory pack;\r\n        if(promoAvailable > 0){\r\n            pack = promoPack;\r\n            promoAvailable--;\r\n        } else {\r\n            pack = defaultPack;\r\n        }\r\n\r\n        // Transfer Tokens\r\n        // Iterate over tokens[] and transfer the an amount corresponding to the i cell in tokenAmounts[]\r\n        for (uint256 i = 0; i < pack.tokens.length; i++) {\r\n            ERC20Token token = ERC20Token(pack.tokens[i]);\r\n            uint256 amount = pack.tokenAmounts[i];\r\n            _safeTransfer(token, _recipient, amount);\r\n        }\r\n\r\n        // NFT Sticker Packs\r\n        StickerType stickerType = StickerType(pack.stickerMarket.stickerType());\r\n        for (uint256 i = 0; i < pack.stickerPackIds.length; i++) {\r\n            uint256 packId = pack.stickerPackIds[i];\r\n            (, bool mintable, uint256 price,) = stickerType.getPaymentData(packId);\r\n            if(mintable && price > 0){\r\n                sntToken.approve(address(pack.stickerMarket),price);\r\n                pack.stickerMarket.buyToken(\r\n                    packId,\r\n                    _recipient,\r\n                    price\r\n                ); \r\n            }\r\n        }\r\n\r\n        // The recipient is no longer eligible for a pack, unless clearPurchases is called.\r\n        ineligible[keccak256(abi.encodePacked(ineligibleVersion, _recipient))] = true;\r\n\r\n        // Transfer ETH\r\n        // .transfer bad post Istanbul fork :|\r\n        (bool success, ) = _recipient.call.value(pack.ethAmount)(\"\");\r\n        require(success, \"ETH Transfer failed\");\r\n\r\n        emit Distributed(_recipient, _attribution);\r\n\r\n        if (_attribution == address(0)) return;\r\n        \r\n        // Determine if attribution is valid\r\n\r\n\r\n        bool isPromo;\r\n        Attribution memory attr;\r\n        if(promoAttributionSettings[_attribution].maxThreshold > 0){\r\n            isPromo = true;\r\n            promoAttributionSettings[_attribution].maxThreshold--;\r\n            attr = promoAttributionSettings[_attribution];\r\n        } else {\r\n            attr = defaultAttributionSettings[_attribution];\r\n        }\r\n\r\n        if (!attr.enabled) {\r\n           attr = defaultAttributionSettings[address(0)];\r\n        }\r\n        \r\n        if(!isPromo && (attributionCnt[_attribution] + 1) > attr.maxThreshold){\r\n            emit RequireApproval(_attribution);\r\n            pendingAttributionCnt[_attribution]++;\r\n        } else {\r\n            if(!isPromo){\r\n                attributionCnt[_attribution]++;\r\n            }\r\n\r\n            if (attr.ethAmount != 0){\r\n                (bool success, ) = _attribution.call.value(attr.ethAmount)(\"\");\r\n                require(success, \"ETH Transfer failed\");\r\n            }\r\n\r\n            for (uint256 i = 0; i < attr.tokens.length; i++) {\r\n                ERC20Token token = ERC20Token(attr.tokens[i]);\r\n                uint256 amount = attr.tokenAmounts[i];\r\n                _safeTransfer(token, _attribution, amount);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function _payPendingAttributions(address _attribOwner, Attribution memory attr) internal {\r\n        uint pendingAttributions = pendingAttributionCnt[_attribOwner];\r\n        \r\n        if (pendingAttributions == 0) return;\r\n        if (attr.maxThreshold < attributionCnt[_attribOwner] + pendingAttributions) return;\r\n        \r\n        uint totalETHToPay = pendingAttributions * attr.ethAmount;\r\n\r\n        attributionCnt[_attribOwner] += pendingAttributions;\r\n        pendingAttributionCnt[_attribOwner] = 0;\r\n        \r\n        if (totalETHToPay != 0){\r\n            (bool success, ) = _attribOwner.call.value(totalETHToPay)(\"\");\r\n            require(success, \"ETH Transfer failed\");\r\n        }\r\n\r\n        for (uint256 i = 0; i < attr.tokens.length; i++) {\r\n            ERC20Token token = ERC20Token(attr.tokens[i]);\r\n            uint256 amount = attr.tokenAmounts[i] * pendingAttributions;\r\n            _safeTransfer(token, _attribOwner, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Get rewards for specific referrer\r\n    /// @param _account The address to obtain the attribution config\r\n    /// @param _isPromo Indicates if the configuration for a promo should be returned or not\r\n    /// @return ethAmount Amount of ETH in wei\r\n    /// @return tokenLen Number of tokens configured as part of the reward\r\n    /// @return maxThreshold If isPromo == true: Number of promo bonuses still available for that address else: Max number of attributions to pay before requiring approval\r\n    /// @return attribCount Number of referrals\r\n    function getReferralReward(address _account, bool _isPromo) public view returns (uint ethAmount, uint tokenLen, uint maxThreshold, uint attribCount) {\r\n        Attribution memory attr;\r\n        if(_isPromo){\r\n            attr = promoAttributionSettings[_account];\r\n        } else {\r\n            attr = defaultAttributionSettings[_account];\r\n            if (!attr.enabled) {\r\n                attr = defaultAttributionSettings[address(0)];\r\n            }\r\n        }\r\n        \r\n        ethAmount = attr.ethAmount;\r\n        maxThreshold = attr.maxThreshold;\r\n        attribCount = attributionCnt[_account];\r\n        tokenLen = attr.tokens.length;\r\n    }\r\n\r\n    /// @notice Get token rewards for specific address\r\n    /// @param _account The address to obtain the attribution's token config\r\n    /// @param _isPromo Indicates if the configuration for a promo should be returned or not\r\n    /// @param _idx Index of token array in the attribution used to obtain the token config\r\n    /// @return token ERC20 contract address\r\n    /// @return tokenAmount Amount of token configured in the attribution\r\n    function getReferralRewardTokens(address _account, bool _isPromo, uint _idx) public view returns (address token, uint tokenAmount) {\r\n        Attribution memory attr;\r\n        if(_isPromo){\r\n            attr = promoAttributionSettings[_account];\r\n        } else {\r\n            attr = defaultAttributionSettings[_account];\r\n            if (!attr.enabled) {\r\n                attr = defaultAttributionSettings[address(0)];\r\n            }\r\n        }\r\n        \r\n        token = attr.tokens[_idx];\r\n        tokenAmount = attr.tokenAmounts[_idx];\r\n    }\r\n    \r\n    fallback() external payable  {\r\n     // ...\r\n    }\r\n    \r\n    // Admin ------------------------------------------------------------------------------------------------\r\n\r\n    /// @notice Allows the Owner to allow or prohibit Signer from calling distributePack().\r\n    /// @dev setPause must be called before Signer can call distributePack()\r\n    function setPause(bool _pause) external onlyOwner {\r\n        pause = _pause;\r\n    }\r\n\r\n    /// @notice Allows the owner to clear the purchase history. Recipients will be able to receive a starter pack again\r\n    function clearPurchases() external onlyOwner {\r\n        ineligibleVersion++;\r\n    }\r\n\r\n    /// @notice Set a starter pack configuration\r\n    /// @dev The Owner can change the default starterpack contents\r\n    /// @param _newPack starter pack configuration\r\n    function changeStarterPack(Pack memory _newPack) public onlyOwner {\r\n        require(_newPack.tokens.length == _newPack.tokenAmounts.length, \"Mismatch with Tokens & Amounts\");\r\n\r\n        for (uint256 i = 0; i < _newPack.tokens.length; i++) {\r\n            require(_newPack.tokenAmounts[i] > 0, \"Amounts must be non-zero\");\r\n        }\r\n\r\n        defaultPack = _newPack;\r\n        sntToken = ERC20Token(defaultPack.stickerMarket.snt());\r\n    }\r\n\r\n    /// @notice Set a promo configuration\r\n    /// @dev The Owner can change the promo pack contents\r\n    /// @param _newPromoPack Promo pack configuration\r\n    /// @param _numberOfPacks Max number of promo packs to be given before using the default config\r\n    function changePromoPack(Pack memory _newPromoPack, uint _numberOfPacks) public onlyOwner {\r\n        require(_newPromoPack.tokens.length == _newPromoPack.tokenAmounts.length, \"Mismatch with Tokens & Amounts\");\r\n\r\n        for (uint256 i = 0; i < _newPromoPack.tokens.length; i++) {\r\n            require(_newPromoPack.tokenAmounts[i] > 0, \"Amounts must be non-zero\");\r\n        }\r\n\r\n        promoPack = _newPromoPack;\r\n        promoAvailable = _numberOfPacks;\r\n    }\r\n\r\n    /// @notice Safety function allowing the owner to immediately pause starterpack distribution and withdraw all balances in the the contract\r\n    function withdraw(address[] calldata _tokens) external onlyOwner {\r\n        pause = true;\r\n        withdrawTokens(_tokens, owner);\r\n    }\r\n\r\n    /// @notice Changes the Signer of the contract\r\n    /// @param _newSigner The new Signer of the contract\r\n    function changeSigner(address _newSigner) public onlyOwner {\r\n        require(_newSigner != address(0), \"zero_address not allowed\");\r\n        signer = _newSigner;\r\n    }\r\n\r\n    /// @notice Changes the owner of the contract\r\n    /// @param _newOwner The new owner of the contract\r\n    function changeOwner(address payable _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"zero_address not allowed\");\r\n        owner = _newOwner;\r\n    }\r\n    \r\n    /// @notice Set default/custom payout and threshold for referrals\r\n    /// @param _isPromo indicates if this attribution config is a promo or default config\r\n    /// @param _ethAmount Payout for referrals\r\n    /// @param _thresholds Max number of referrals allowed beforee requiring approval\r\n    /// @param _assignedTo Use a valid address here to set custom settings. To set the default payout and threshold, use address(0);\r\n    function setPayoutAndThreshold(\r\n        bool _isPromo,\r\n        uint256 _ethAmount,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _tokenAmounts,\r\n        uint256[] calldata _thresholds,\r\n        address[] calldata _assignedTo\r\n    ) external onlyOwner {\r\n        require(_thresholds.length == _assignedTo.length, \"Array length mismatch\");\r\n        require(_tokens.length == _tokenAmounts.length, \"Array length mismatch\");\r\n        \r\n        for (uint256 i = 0; i < _thresholds.length; i++) {\r\n            bool enabled = _assignedTo[i] != address(0);\r\n            \r\n            Attribution memory attr = Attribution({\r\n                enabled: enabled,\r\n                ethAmount: _ethAmount,\r\n                maxThreshold: _thresholds[i],\r\n                tokens: _tokens,\r\n                tokenAmounts: _tokenAmounts\r\n            });\r\n            \r\n            if(_isPromo){\r\n                promoAttributionSettings[_assignedTo[i]] = attr;\r\n            } else {\r\n                if(enabled){\r\n                    _payPendingAttributions(_assignedTo[i], attr); \r\n                }\r\n                defaultAttributionSettings[_assignedTo[i]] = attr;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// @notice Remove attribution configuration for addresses\r\n    /// @param _assignedTo Array of addresses with an attribution configured\r\n    /// @param _isPromo Indicates if the configuration to delete is the promo or default\r\n    function removePayoutAndThreshold(address[] calldata _assignedTo, bool _isPromo) external onlyOwner {\r\n        if (_isPromo) {\r\n            for (uint256 i = 0; i < _assignedTo.length; i++) {\r\n                delete promoAttributionSettings[_assignedTo[i]];\r\n            }\r\n        } else {\r\n            for (uint256 i = 0; i < _assignedTo.length; i++) {\r\n                delete defaultAttributionSettings[_assignedTo[i]];\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @param _signer allows the contract deployer(owner) to define the signer on construction\r\n    constructor(address _signer) public {\r\n        require(_signer != address(0), \"zero_address not allowed\");\r\n        owner = msg.sender;\r\n        signer = _signer;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"attribution\",\"type\":\"address\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"attribution\",\"type\":\"address\"}],\"name\":\"RequireApproval\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"attributionCnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract StickerMarket\",\"name\":\"stickerMarket\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stickerPackIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Distributor.Pack\",\"name\":\"_newPromoPack\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfPacks\",\"type\":\"uint256\"}],\"name\":\"changePromoPack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSigner\",\"type\":\"address\"}],\"name\":\"changeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract StickerMarket\",\"name\":\"stickerMarket\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stickerPackIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Distributor.Pack\",\"name\":\"_newPack\",\"type\":\"tuple\"}],\"name\":\"changeStarterPack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearPurchases\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_attribution\",\"type\":\"address\"}],\"name\":\"distributePack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"eligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultPack\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stickerMarket\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stickerPackIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPromoPack\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stickerMarket\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stickerPackIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isPromo\",\"type\":\"bool\"}],\"name\":\"getReferralReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenLen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"attribCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isPromo\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getReferralRewardTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ineligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingAttributionCnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assignedTo\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_isPromo\",\"type\":\"bool\"}],\"name\":\"removePayoutAndThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPromo\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_assignedTo\",\"type\":\"address[]\"}],\"name\":\"setPayoutAndThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sntToken\",\"outputs\":[{\"internalType\":\"contract ERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Distributor","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007b73046e14cc085885455ad0ab7684abef7bfe0d","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://aea3dc90128008bb7afb621745619f69f73ee910e290eb988faa9ecc8beea79f"}]}