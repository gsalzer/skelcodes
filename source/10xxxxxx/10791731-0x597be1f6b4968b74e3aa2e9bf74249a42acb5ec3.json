{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.7.0;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\nstruct UnipumpGroupData\r\n{\r\n    uint64 tokenListId;\r\n    address leader;\r\n\r\n    uint32 runTimeout;\r\n    bool aborted;\r\n    bool complete;\r\n    \r\n    uint32 startTimeout;\r\n    uint16 maxRunTimeHours;  \r\n    uint16 leaderProfitShareOutOf10000;\r\n    \r\n    uint256 leaderUppCollateral;\r\n    uint256 requiredMemberUppFee;\r\n    uint256 minEthToJoin;\r\n\r\n    uint256 minEthToStart;\r\n    uint256 maxEthAcceptable;\r\n\r\n    // ^-- parameters\r\n    \r\n    address[] members;\r\n    uint256 totalContributions;\r\n\r\n    // ^-- pre-start\r\n}\r\n\r\nstruct UnipumpGroupDataMappings\r\n{\r\n    // To work around deficiencies in solidity\r\n\r\n    mapping (address => bool) authorizedTraders;\r\n    // ^-- any time before finish/abort\r\n\r\n    mapping (address => uint256) contributions;\r\n    // ^-- pre-start\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => bool)) withdrawals;\r\n    // ^-- operational\r\n}\r\n\r\nstruct UnipumpTokenList\r\n{\r\n    address owner;\r\n    bool locked;\r\n    address[] tokens;\r\n    mapping (address => uint256) tokenIndexes;    \r\n}\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary UnipumpGroupLibrary\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    function joinGroup(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        address unipump\r\n    )\r\n        public\r\n    {\r\n        require (!groupData.aborted, \"Aborted\");\r\n        require (groupData.runTimeout == 0, \"Started\");\r\n        uint256 totalContributions = groupData.totalContributions;\r\n        address leader = groupData.leader;\r\n        require (leader != address(0), \"Group does not exist\");\r\n        uint256 contribution = groupDataMappings.contributions[msg.sender];\r\n        bool isLeader = msg.sender == leader;\r\n        if (contribution == 0 && !isLeader) {\r\n            IERC20(unipump).transferFrom(msg.sender, address(this), groupData.requiredMemberUppFee);\r\n            groupData.members.push(msg.sender);\r\n        }\r\n        contribution += msg.value;\r\n        totalContributions += msg.value;\r\n        require (contribution >= groupData.minEthToJoin || isLeader, \"Insufficient ETH\");\r\n        require (totalContributions <= groupData.maxEthAcceptable, \"Too much ETH for group\");\r\n        groupDataMappings.contributions[msg.sender] = contribution;\r\n        groupData.totalContributions = totalContributions;\r\n    }\r\n\r\n    function abortGroup(UnipumpGroupData storage groupData)\r\n        public\r\n    {\r\n        require (!groupData.aborted, \"Aborted\");\r\n        require (groupData.runTimeout == 0, \"Started\");\r\n        address leader = groupData.leader;\r\n        require (leader != address(0), \"Group does not exist\");\r\n        if (msg.sender != leader) {\r\n            require (block.timestamp >= groupData.startTimeout, \"Leader only\");\r\n        }\r\n        groupData.aborted = true;\r\n        groupData.startTimeout = uint32(block.timestamp);\r\n    }\r\n\r\n    function startGroup(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        address weth\r\n    )\r\n        public\r\n    {\r\n        require (!groupData.aborted, \"Aborted\");\r\n        require (groupData.runTimeout == 0, \"Started\");\r\n        require (msg.sender == groupData.leader, \"Leader only\");\r\n        uint256 totalContributions = groupData.totalContributions;\r\n        require (totalContributions >= groupData.minEthToStart, \"Insufficient ETH\");\r\n        groupData.runTimeout = uint32(block.timestamp + groupData.maxRunTimeHours * 60 * 60);\r\n        groupDataMappings.balances[weth] = totalContributions;\r\n        IWETH(weth).deposit{ value: totalContributions }();\r\n    }\r\n\r\n    function finishGroup(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        address weth\r\n    )\r\n        public\r\n    {\r\n        require (!groupData.complete, \"Already complete\");\r\n        require (groupData.runTimeout > 0, \"Not started\");\r\n        address leader = groupData.leader;\r\n        if (msg.sender != leader) {\r\n            require (block.timestamp >= groupData.runTimeout, \"Leader only\");\r\n        }\r\n        groupData.complete = true;\r\n        groupData.runTimeout = uint32(block.timestamp);\r\n        IWETH(weth).withdraw(groupDataMappings.balances[weth]);\r\n    }\r\n    \r\n    function validatePath(\r\n        mapping (address => uint256) storage mainTokenList,\r\n        mapping (address => uint256) storage groupTokenList,\r\n        address[] memory path,\r\n        address weth\r\n    )\r\n        private\r\n        view\r\n    {\r\n        require (path.length >= 2);\r\n        for (uint256 x = 0; x < path.length; ++x) {\r\n            address token = path[x];\r\n            require (token == weth || mainTokenList[token] > 0 || groupTokenList[token] > 0, \"Token not approved\");\r\n        }\r\n    }\r\n\r\n    function prepareSwap(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        address[] memory path,\r\n        uint256 amountIn,\r\n        IUniswapV2Router02 uniswapV2Router\r\n    )\r\n        private\r\n        returns (uint256 groupBalanceIn, uint256 balanceIn, uint256 balanceOut)\r\n    {\r\n        address tokenIn = path[0];\r\n        address tokenOut = path[path.length - 1];\r\n        require (msg.sender == groupData.leader || groupDataMappings.authorizedTraders[msg.sender], \"Leader only\");\r\n        require (!groupData.complete, \"Already complete\");\r\n        require (groupData.runTimeout > 0, \"Not started\");\r\n        groupBalanceIn = groupDataMappings.balances[tokenIn];\r\n        require (groupBalanceIn >= amountIn);\r\n        balanceIn = IERC20(tokenIn).balanceOf(address(this));\r\n        balanceOut = IERC20(tokenOut).balanceOf(address(this));\r\n        IERC20(tokenIn).approve(address(uniswapV2Router), amountIn);\r\n    }\r\n\r\n    function updateBalances(\r\n        UnipumpGroupDataMappings storage groupDataMappings,        \r\n        mapping (address => uint256) storage totalTraded,\r\n        address[] memory path,\r\n        uint256 groupBalanceIn,\r\n        uint256 balanceIn,\r\n        uint256 balanceOut\r\n    )\r\n        private\r\n    {\r\n        address tokenIn = path[0];\r\n        address tokenOut = path[path.length - 1];\r\n        uint256 newBalanceIn = IERC20(tokenIn).balanceOf(address(this));\r\n        uint256 newBalanceOut = IERC20(tokenOut).balanceOf(address(this));\r\n        \r\n        groupDataMappings.balances[tokenIn] = groupBalanceIn.add(newBalanceIn).sub(balanceIn);\r\n        groupDataMappings.balances[tokenOut] = groupDataMappings.balances[tokenOut].add(newBalanceOut).sub(balanceOut);\r\n\r\n        totalTraded[tokenIn] += newBalanceIn > balanceIn ? newBalanceIn - balanceIn : balanceIn - newBalanceIn;\r\n        totalTraded[tokenOut] += newBalanceOut > balanceOut ? newBalanceOut - balanceOut : balanceOut - newBalanceOut;\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        mapping (address => uint256) storage mainTokenList,\r\n        mapping (address => uint256) storage groupTokenList,\r\n        mapping (address => uint256) storage totalTraded,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory path,\r\n        uint256 deadline,\r\n        address weth,\r\n        IUniswapV2Router02 uniswapV2Router\r\n    ) \r\n        public        \r\n        returns (uint256[] memory amounts)\r\n    {\r\n        validatePath(mainTokenList, groupTokenList, path, weth);\r\n        (uint256 groupBalanceIn, uint256 balanceIn, uint256 balanceOut) = prepareSwap(groupData, groupDataMappings, path, amountIn, uniswapV2Router);\r\n        amounts = uniswapV2Router.swapExactTokensForTokens(\r\n            amountIn,\r\n            amountOutMin,\r\n            path,\r\n            address(this),\r\n            deadline);\r\n        updateBalances(groupDataMappings, totalTraded, path, groupBalanceIn, balanceIn, balanceOut);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        mapping (address => uint256) storage mainTokenList,\r\n        mapping (address => uint256) storage groupTokenList,\r\n        mapping (address => uint256) storage totalTraded,\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] memory path,\r\n        uint256 deadline,\r\n        address weth,\r\n        IUniswapV2Router02 uniswapV2Router\r\n    ) \r\n        public\r\n        returns (uint256[] memory amounts)\r\n    {\r\n        validatePath(mainTokenList, groupTokenList, path, weth);\r\n        (uint256 groupBalanceIn, uint256 balanceIn, uint256 balanceOut) = prepareSwap(groupData, groupDataMappings, path, amountInMax, uniswapV2Router);\r\n        amounts = uniswapV2Router.swapTokensForExactTokens(\r\n            amountOut,\r\n            amountInMax,\r\n            path,\r\n            address(this),\r\n            deadline);\r\n        updateBalances(groupDataMappings, totalTraded,path, groupBalanceIn, balanceIn, balanceOut);\r\n    }\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        mapping (address => uint256) storage mainTokenList,\r\n        mapping (address => uint256) storage groupTokenList,\r\n        mapping (address => uint256) storage totalTraded,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory path,\r\n        uint256 deadline,\r\n        address weth,\r\n        IUniswapV2Router02 uniswapV2Router\r\n    ) \r\n        public\r\n    {\r\n        validatePath(mainTokenList, groupTokenList, path, weth);\r\n        (uint256 groupBalanceIn, uint256 balanceIn, uint256 balanceOut) = prepareSwap(groupData, groupDataMappings, path, amountIn, uniswapV2Router);\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amountIn,\r\n            amountOutMin,\r\n            path,\r\n            address(this),\r\n            deadline);\r\n        updateBalances(groupDataMappings, totalTraded, path, groupBalanceIn, balanceIn, balanceOut);\r\n    }\r\n\r\n    function addAuthorizedTrader(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        address trader\r\n    ) \r\n        public\r\n    {\r\n        require (msg.sender == groupData.leader, \"Leader only\");\r\n        require (!groupData.complete, \"Already complete\");\r\n        require (!groupData.aborted, \"Aborted\");\r\n        groupDataMappings.authorizedTraders[trader] = true;\r\n    }\r\n\r\n    function removeAuthorizedTrader(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        address trader\r\n    ) \r\n        public\r\n    {\r\n        require (msg.sender == groupData.leader, \"Leader only\");\r\n        require (!groupData.complete, \"Already complete\");\r\n        require (!groupData.aborted, \"Aborted\");\r\n        groupDataMappings.authorizedTraders[trader] = false;\r\n    }\r\n\r\n    function withdraw(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        address token,\r\n        address unipump,\r\n        address weth,\r\n        address caller\r\n    )\r\n        public\r\n    {\r\n        uint256 contribution = groupDataMappings.contributions[caller];\r\n        bool isLeader = caller == groupData.leader;\r\n        if (groupData.aborted) {            \r\n            // token parameter is ignored - we send eth/upp back\r\n            require (!groupDataMappings.withdrawals[caller][address(0)], \"Already withdrawn\");\r\n            groupDataMappings.withdrawals[caller][address(0)] = true;\r\n            if (isLeader) {\r\n                IERC20(unipump).transfer(msg.sender, groupData.leaderUppCollateral);\r\n            }\r\n            else {\r\n                IERC20(unipump).transfer(msg.sender, groupData.requiredMemberUppFee);\r\n            }\r\n            if (contribution > 0) {\r\n                (bool success,) = msg.sender.call{ value: contribution }(\"\");\r\n                require (success, \"Transfer failed\");\r\n            }\r\n            return;\r\n        }\r\n        if (token == address(0)) { token = weth; }\r\n        require (groupData.complete, \"Cannot yet withdraw\");\r\n        require (!groupDataMappings.withdrawals[caller][token], \"Already withdrawn\");\r\n        groupDataMappings.withdrawals[caller][token] = true;\r\n        uint256 totalContributions = groupData.totalContributions;\r\n        uint256 finalBalance = groupDataMappings.balances[token];\r\n        uint256 extra = 0;\r\n        if (token == weth) {\r\n            uint256 leaderPayout = finalBalance > totalContributions ? (finalBalance - totalContributions) * groupData.leaderProfitShareOutOf10000 / 10000 : 0;\r\n            finalBalance -= leaderPayout;\r\n            if (isLeader) { extra = leaderPayout; }\r\n        }\r\n        else if (token == unipump) {\r\n            uint256 finalWethBalance = groupDataMappings.balances[weth];\r\n            uint256 totalUppPot = groupData.leaderUppCollateral + (groupData.requiredMemberUppFee * groupData.members.length);\r\n            if (finalWethBalance >= totalContributions) {\r\n                if (isLeader) {\r\n                    IERC20(unipump).transfer(msg.sender, totalUppPot);\r\n                }\r\n            }\r\n            else {\r\n                uint256 forMembers = totalUppPot.mul(totalContributions - finalWethBalance) / totalContributions;\r\n                if (isLeader) {\r\n                    IERC20(unipump).transfer(msg.sender, totalUppPot - forMembers);\r\n                }\r\n                else {\r\n                    IERC20(unipump).transfer(msg.sender, forMembers.mul(contribution) / totalContributions);\r\n                }\r\n            }\r\n        }\r\n        uint256 toSend = extra + finalBalance.mul(contribution) / totalContributions;\r\n        if (toSend > 0) {\r\n            if (token == weth) {\r\n                (bool success,) = msg.sender.call{ value: toSend }(\"\");\r\n                require (success, \"Transfer failed\");\r\n            }\r\n            else {\r\n                require (IERC20(token).transfer(msg.sender, toSend));\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdrawMany(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        address[] memory tokens,\r\n        address unipump,\r\n        address weth\r\n    )\r\n        public\r\n    {\r\n        for (uint256 x = 0; x < tokens.length; ++x) {\r\n            withdraw(groupData, groupDataMappings, tokens[x], unipump, weth, msg.sender);\r\n        }\r\n    }\r\n\r\n    function emergencyWithdrawal(\r\n        UnipumpGroupData storage groupData,\r\n        UnipumpGroupDataMappings storage groupDataMappings,\r\n        address member,\r\n        address[] memory tokens,\r\n        address unipump,\r\n        address weth\r\n    )\r\n        public\r\n    {\r\n        require (\r\n            (groupData.complete && block.timestamp > groupData.runTimeout + 60 * 60 * 24 * 30) || // 30 days after group is complete\r\n            (groupData.aborted && block.timestamp > groupData.startTimeout + 60 * 60 * 24 * 30)   // 30 days after group is aborted\r\n        );\r\n        for (uint256 x = 0; x < tokens.length; ++x) {\r\n            withdraw(groupData, groupDataMappings, tokens[x], unipump, weth, member);\r\n        }\r\n    }\r\n}","ABI":"[]","ContractName":"UnipumpGroupLibrary","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7736e6f2df8d4cd70af2c8e311191187ca165cdbcb62801e911f7319a7cd2d04"}]}