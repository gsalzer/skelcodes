{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.0;\r\n// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n * Copyright Â© 2017-2019 Ramp Network sp. z o.o. All rights reserved (MIT License).\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\r\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\r\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\r\n * is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies\r\n * or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\r\n * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n\r\n/**\r\n * Abstract class for an asset adapter -- a class handling a binary asset description,\r\n * encapsulating the asset-specific transfer logic, to maintain a single interface for the main\r\n * escrows contract, regardless of asset type.\r\n * The `assetData` bytes represent a tightly packed struct, consisting of a 2-byte (uint16) asset\r\n * type, followed by asset-specific data. For now there are 2 asset types, ETH and ERC-20 tokens.\r\n * The asset type bytes must be equal to the `ASSET_TYPE` constant in each subclass.\r\n *\r\n * @dev Subclasses of this class are used as mixins to their respective main escrows contract.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\nabstract contract AssetAdapter {\r\n\r\n    uint16 public immutable ASSET_TYPE;  // solhint-disable-line var-name-mixedcase\r\n\r\n    constructor(\r\n        uint16 assetType\r\n    ) {\r\n        ASSET_TYPE = assetType;\r\n    }\r\n\r\n    /**\r\n     * Ensure the described asset is sent to the given address.\r\n     * Should revert if the transfer failed, but callers must also handle `false` being returned,\r\n     * much like ERC-20's `transfer`.\r\n     */\r\n    function rawSendAsset(\r\n        bytes memory assetData,\r\n        uint256 _amount,\r\n        address payable _to\r\n    ) internal virtual returns (bool success);\r\n\r\n    /**\r\n     * Ensure the described asset is sent to this contract.\r\n     * Should revert if the transfer failed, but callers must also handle `false` being returned,\r\n     * much like ERC-20's `transfer`.\r\n     */\r\n    function rawLockAsset(\r\n        uint256 amount,\r\n        address payable _from\r\n    ) internal returns (bool success) {\r\n        return RampInstantPoolInterface(_from).sendFundsToSwap(amount);\r\n    }\r\n\r\n    function getAmount(bytes memory assetData) internal virtual pure returns (uint256);\r\n\r\n    /**\r\n     * Verify that the passed asset data can be handled by this adapter and given pool.\r\n     *\r\n     * @dev it's sufficient to use this only when creating a new swap -- all the other swap\r\n     * functions first check if the swap hash is valid, while a swap hash with invalid\r\n     * asset type wouldn't be created at all.\r\n     *\r\n     * @dev asset type is 2 bytes long, and it's at offset 32 in `assetData`'s memory (the first 32\r\n     * bytes are the data length). We load the word at offset 2 (it ends with the asset type bytes),\r\n     * and retrieve its last 2 bytes into a `uint16` variable.\r\n     */\r\n    modifier checkAssetTypeAndData(bytes memory assetData, address _pool) {\r\n        uint16 assetType;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            assetType := and(\r\n                mload(add(assetData, 2)),\r\n                0xffff\r\n            )\r\n        }\r\n        require(assetType == ASSET_TYPE, \"iat\");  // \"invalid asset type\"\r\n        checkAssetData(assetData, _pool);\r\n        _;\r\n    }\r\n\r\n    function checkAssetData(bytes memory assetData, address _pool) internal virtual view;\r\n\r\n}\r\n\r\n/**\r\n * A simple interface used by the escrows contract (precisely AssetAdapters) to interact\r\n * with the liquidity pools.\r\n */\r\nabstract contract RampInstantPoolInterface {\r\n\r\n    uint16 public ASSET_TYPE;  // solhint-disable-line var-name-mixedcase\r\n\r\n    function sendFundsToSwap(uint256 _amount)\r\n        public virtual /*onlyActive onlySwapsContract isWithinLimits*/ returns(bool success);\r\n\r\n}\r\n\r\n/**\r\n * A standard, simple transferrable contract ownership.\r\n */\r\nabstract contract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"ooc\");  // \"only the owner can call this\"\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnerChanged(msg.sender, _newOwner);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * An extended version of the standard `Pausable` contract, with more possible statuses:\r\n *  * STOPPED: all swap actions cannot be executed until the status is changed,\r\n *  * RETURN_ONLY: the existing swaps can only be returned, no new swaps can be created;\r\n *  * FINALIZE_ONLY: the existing swaps can be released or returned, no new swaps can be created;\r\n *  * ACTIVE: all swap actions can be executed.\r\n *\r\n * @dev the status enum is strictly monotonic (i.e. all actions allowed on status X are allowed on\r\n * status X+1) and the default 0 is mapped to STOPPED for safety.\r\n */\r\nabstract contract WithStatus is Ownable {\r\n\r\n    enum Status {\r\n        STOPPED,\r\n        RETURN_ONLY,\r\n        FINALIZE_ONLY,\r\n        ACTIVE\r\n    }\r\n\r\n    event StatusChanged(Status oldStatus, Status newStatus);\r\n\r\n    Status public status = Status.ACTIVE;\r\n\r\n    function setStatus(Status _status) external onlyOwner {\r\n        emit StatusChanged(status, _status);\r\n        status = _status;\r\n    }\r\n\r\n    modifier statusAtLeast(Status _status) {\r\n        require(status >= _status, \"ics\");  // \"invalid contract status\"\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * An owner-managed list of oracles, that are allowed to release or return swaps.\r\n * The deployer is the default only oracle.\r\n */\r\nabstract contract WithOracles is Ownable {\r\n\r\n    mapping (address => bool) internal oracles;\r\n\r\n    constructor() {\r\n        oracles[msg.sender] = true;\r\n    }\r\n\r\n    function approveOracle(address _oracle) external onlyOwner {\r\n        oracles[_oracle] = true;\r\n    }\r\n\r\n    function revokeOracle(address _oracle) external onlyOwner {\r\n        oracles[_oracle] = false;\r\n    }\r\n\r\n    modifier isOracle(address _oracle) {\r\n        require(oracles[_oracle], \"ioa\");  // invalid oracle address\"\r\n        _;\r\n    }\r\n\r\n    modifier onlyOracleOrPool(address _pool, address _oracle) {\r\n        require(\r\n            msg.sender == _pool || (msg.sender == _oracle && oracles[msg.sender]),\r\n            \"oop\"  // \"only the oracle or the pool can call this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * An owner-managed address that is allowed to create new swaps.\r\n */\r\nabstract contract WithSwapsCreators is Ownable {\r\n\r\n    mapping (address => bool) internal creators;\r\n\r\n    constructor() {\r\n        creators[msg.sender] = true;\r\n    }\r\n\r\n    function approveSwapCreator(address _creator) external onlyOwner {\r\n        creators[_creator] = true;\r\n    }\r\n\r\n    function revokeSwapCreator(address _creator) external onlyOwner {\r\n        creators[_creator] = false;\r\n    }\r\n\r\n    modifier onlySwapCreator() {\r\n        require(creators[msg.sender], \"osc\");  // \"only the swap creator can call this\"\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * An extension of `AssetAdapter` that encapsulates collecting Ramp fees while locking and resolving\r\n * an escrow. The collected fees can be withdrawn by the contract owner.\r\n *\r\n * Fees are configured dynamically by the backend and encoded in `assetData`. The fee amount is\r\n * also hashed into the swapHash, so a swap is guaranteed to be released/returned with the same fee\r\n * it was created with.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\nabstract contract AssetAdapterWithFees is Ownable, AssetAdapter {\r\n\r\n    function accumulateFee(bytes memory assetData) internal virtual;\r\n\r\n    function withdrawFees(\r\n        bytes calldata assetData,\r\n        address payable _to\r\n    ) external virtual /*onlyOwner*/ returns (bool success);\r\n\r\n    function getFee(bytes memory assetData) internal virtual pure returns (uint256);\r\n\r\n    function getAmountWithFee(bytes memory assetData) internal pure returns (uint256) {\r\n        return getAmount(assetData) + getFee(assetData);\r\n    }\r\n\r\n    function lockAssetWithFee(\r\n        bytes memory assetData,\r\n        address payable _from\r\n    ) internal returns (bool success) {\r\n        return rawLockAsset(getAmountWithFee(assetData), _from);\r\n    }\r\n\r\n    function sendAssetWithFee(\r\n        bytes memory assetData,\r\n        address payable _to\r\n    ) internal returns (bool success) {\r\n        return rawSendAsset(assetData, getAmountWithFee(assetData), _to);\r\n    }\r\n\r\n    function sendAssetKeepingFee(\r\n        bytes memory assetData,\r\n        address payable _to\r\n    ) internal returns (bool success) {\r\n        bool result = rawSendAsset(assetData, getAmount(assetData), _to);\r\n        if (result) accumulateFee(assetData);\r\n        return result;\r\n    }\r\n\r\n    function getAccumulatedFees(address _assetAddress) public virtual view returns (uint256);\r\n\r\n}\r\n\r\n/**\r\n * The main contract managing Ramp Swaps escrows lifecycle: create, release or return.\r\n * Uses an abstract AssetAdapter to carry out the transfers and handle the particular asset data.\r\n * With a corresponding off-chain oracle protocol allows for atomic-swap-like transfer between\r\n * fiat currencies and crypto assets.\r\n *\r\n * @dev an active swap is represented by a hash of its details, mapped to its escrow expiration\r\n * timestamp. When the swap is created, its end time is set a given amount of time in the future\r\n * (but within {MIN,MAX}_SWAP_LOCK_TIME_S).\r\n * The hashed swap details are:\r\n *  * address pool: the `RampInstantPool` contract that sells the crypto asset;\r\n *  * address receiver: the user that buys the crypto asset;\r\n *  * address oracle: address of the oracle that handles this particular swap;\r\n *  * bytes assetData: description of the crypto asset, handled by an AssetAdapter;\r\n *  * bytes32 paymentDetailsHash: hash of the fiat payment details: account numbers, fiat value\r\n *    and currency, and the transfer reference (title), that can be verified off-chain.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\nabstract contract RampInstantEscrows\r\nis Ownable, WithStatus, WithOracles, WithSwapsCreators, AssetAdapterWithFees {\r\n\r\n    /// @dev contract version, defined in semver\r\n    string public constant VERSION = \"0.6.4\";\r\n\r\n    uint32 internal constant MIN_ACTUAL_TIMESTAMP = 1000000000;\r\n\r\n    /// @dev lock time limits for pool's assets, after which unreleased escrows can be returned\r\n    uint32 internal constant MIN_SWAP_LOCK_TIME_S = 24 hours;\r\n    uint32 internal constant MAX_SWAP_LOCK_TIME_S = 30 days;\r\n\r\n    event Created(bytes32 indexed swapHash);\r\n    event Released(bytes32 indexed swapHash);\r\n    event PoolReleased(bytes32 indexed swapHash);\r\n    event Returned(bytes32 indexed swapHash);\r\n    event PoolReturned(bytes32 indexed swapHash);\r\n\r\n    /**\r\n     * @dev Mapping from swap details hash to its end time (as a unix timestamp).\r\n     * After the end time the swap can be cancelled, and the funds will be returned to the pool.\r\n     */\r\n    mapping (bytes32 => uint32) internal swaps;\r\n\r\n    /**\r\n     * Swap creation, called by the Ramp Network. Checks swap parameters and ensures the crypto\r\n     * asset is locked on this contract.\r\n     *\r\n     * Emits a `Created` event with the swap hash.\r\n     */\r\n    function create(\r\n        address payable _pool,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash,\r\n        uint32 lockTimeS\r\n    )\r\n        external\r\n        statusAtLeast(Status.ACTIVE)\r\n        onlySwapCreator()\r\n        isOracle(_oracle)\r\n        checkAssetTypeAndData(_assetData, _pool)\r\n        returns\r\n        (bool success)\r\n    {\r\n        require(\r\n            lockTimeS >= MIN_SWAP_LOCK_TIME_S && lockTimeS <= MAX_SWAP_LOCK_TIME_S,\r\n            \"ltl\"  // \"lock time outside limits\"\r\n        );\r\n        bytes32 swapHash = getSwapHash(\r\n            _pool, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        requireSwapNotExists(swapHash);\r\n        // Set up swap status before transfer, to avoid reentrancy attacks.\r\n        // Even if a malicious token is somehow passed to this function (despite the oracle\r\n        // signature of its details), the state of this contract is already fully updated,\r\n        // so it will behave correctly (as it would be a separate call).\r\n        // solhint-disable-next-line not-rely-on-time\r\n        swaps[swapHash] = uint32(block.timestamp) + lockTimeS;\r\n        require(\r\n            lockAssetWithFee(_assetData, _pool),\r\n            \"elf\"  // \"escrow lock failed\"\r\n        );\r\n        emit Created(swapHash);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Swap release, which transfers the crypto asset to the receiver and removes the swap from\r\n     * the active swap mapping. Normally called by the swap's oracle after it confirms a matching\r\n     * wire transfer on pool's bank account. Can be also called by the pool, for example in case\r\n     * of a dispute, when the parties reach an agreement off-chain.\r\n     *\r\n     * Emits a `Released` or `PoolReleased` event with the swap's hash.\r\n     */\r\n    function release(\r\n        address _pool,\r\n        address payable _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external statusAtLeast(Status.FINALIZE_ONLY) onlyOracleOrPool(_pool, _oracle) {\r\n        bytes32 swapHash = getSwapHash(\r\n            _pool, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        requireSwapCreated(swapHash);\r\n        // Delete the swap status before transfer, to avoid reentrancy attacks.\r\n        swaps[swapHash] = 0;\r\n        require(\r\n            sendAssetKeepingFee(_assetData, _receiver),\r\n            \"arf\"  // \"asset release failed\"\r\n        );\r\n        if (msg.sender == _pool) {\r\n            emit PoolReleased(swapHash);\r\n        } else {\r\n            emit Released(swapHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Swap return, which transfers the crypto asset back to the pool and removes the swap from\r\n     * the active swap mapping. Can be called by the pool or the swap's oracle, but only if the\r\n     * escrow lock time expired.\r\n     *\r\n     * Emits a `Returned` or `PoolReturned` event with the swap's hash.\r\n     */\r\n    function returnFunds(\r\n        address payable _pool,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external statusAtLeast(Status.RETURN_ONLY) onlyOracleOrPool(_pool, _oracle) {\r\n        bytes32 swapHash = getSwapHash(\r\n            _pool, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        requireSwapExpired(swapHash);\r\n        // Delete the swap status before transfer, to avoid reentrancy attacks.\r\n        swaps[swapHash] = 0;\r\n        require(\r\n            sendAssetWithFee(_assetData, _pool),\r\n            \"acf\"  // \"asset return failed\"\r\n        );\r\n        if (msg.sender == _pool) {\r\n            emit PoolReturned(swapHash);\r\n        } else {\r\n            emit Returned(swapHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given all valid swap details, returns its status. The return can be:\r\n     * 0: the swap details are invalid, swap doesn't exist, or was already released/returned.\r\n     * >1: the swap was created, and the value is a timestamp indicating end of its lock time.\r\n     */\r\n    function getSwapStatus(\r\n        address _pool,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external view returns (uint32 status) {\r\n        bytes32 swapHash = getSwapHash(\r\n            _pool, _receiver, _oracle, keccak256(_assetData), _paymentDetailsHash\r\n        );\r\n        return swaps[swapHash];\r\n    }\r\n\r\n    /**\r\n     * Calculates the swap hash used to reference the swap in this contract's storage.\r\n     */\r\n    function getSwapHash(\r\n        address _pool,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes32 assetHash,\r\n        bytes32 _paymentDetailsHash\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                _pool, _receiver, _oracle, assetHash, _paymentDetailsHash\r\n            )\r\n        );\r\n    }\r\n\r\n    function requireSwapNotExists(bytes32 swapHash) internal view {\r\n        require(\r\n            swaps[swapHash] == 0,\r\n            \"sae\"  // \"swap already exists\"\r\n        );\r\n    }\r\n\r\n    function requireSwapCreated(bytes32 swapHash) internal view {\r\n        require(\r\n            swaps[swapHash] > MIN_ACTUAL_TIMESTAMP,\r\n            \"siv\"  // \"swap invalid\"\r\n        );\r\n    }\r\n\r\n    function requireSwapExpired(bytes32 swapHash) internal view {\r\n        require(\r\n            // solhint-disable-next-line not-rely-on-time\r\n            swaps[swapHash] > MIN_ACTUAL_TIMESTAMP && block.timestamp > swaps[swapHash],\r\n            \"sei\"  // \"swap not expired or invalid\"\r\n        );\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * An adapter for handling ether assets.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\nabstract contract EthAdapter is AssetAdapterWithFees {\r\n\r\n    uint16 internal constant ETH_TYPE_ID = 1;\r\n    uint16 internal constant ETH_ASSET_DATA_LENGTH = 66;\r\n    uint256 internal accumulatedFees = 0;\r\n\r\n    constructor() AssetAdapter(ETH_TYPE_ID) {}\r\n\r\n    /**\r\n    * @dev extract the amount from the asset data bytes. ETH assetData bytes contents:\r\n    * offset length type     contents\r\n    * +00    32     uint256  data length (== 0x22 == 34 bytes)\r\n    * +32     2     uint16   asset type  (== ETH_TYPE_ID == 1)\r\n    * +34    32     uint256  ether amount in wei\r\n    * +66    32     uint256  ether fee in wei\r\n    */\r\n    function getAmount(bytes memory assetData) internal override pure returns (uint256 amount) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            amount := mload(add(assetData, 34))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev extract the fee from the asset data bytes. See getAmount for bytes contents.\r\n     */\r\n    function getFee(bytes memory assetData) internal override pure returns (uint256 fee) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            fee := mload(add(assetData, 66))\r\n        }\r\n    }\r\n\r\n    function rawSendAsset(\r\n        bytes memory /*assetData*/,\r\n        uint256 _amount,\r\n        address payable _to\r\n    ) internal override returns (bool success) {\r\n        // To enable more complex purchase receiver contracts, we're using `call.value(...)` instead\r\n        // of plain `transfer(...)`, which allows only 2300 gas to be used by the fallback function.\r\n        // This works for transfers to plain accounts too, no need to check if it's a contract.\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool transferSuccessful,) = _to.call{ value:_amount }(\"\");\r\n        require(transferSuccessful, \"etf\");  // \"eth transfer failed\"\r\n        return true;\r\n    }\r\n\r\n    function accumulateFee(bytes memory assetData) internal override {\r\n        accumulatedFees += getFee(assetData);\r\n    }\r\n\r\n    function withdrawFees(\r\n        bytes calldata /*assetData*/,\r\n        address payable _to\r\n    ) external override onlyOwner returns (bool success) {\r\n        uint256 fees = accumulatedFees;\r\n        accumulatedFees = 0;\r\n        _to.transfer(fees);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This adapter can receive eth payments, but no other use of the fallback function is allowed.\r\n     * @dev this is the \"receive ether\" fallback function, split off from the regular fallback\r\n     * function in Solidity 0.6\r\n     */\r\n    receive () external payable {}\r\n\r\n    function checkAssetData(bytes memory assetData, address /*_pool*/) internal override pure {\r\n        require(assetData.length == ETH_ASSET_DATA_LENGTH, \"adl\");  // \"invalid asset data length\"\r\n    }\r\n\r\n    function getAccumulatedFees(address /*_assetAddress*/) public override view returns (uint256) {\r\n        return accumulatedFees;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Ramp Swaps contract with the ether asset adapter.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\ncontract RampInstantEthEscrows is RampInstantEscrows, EthAdapter {}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"PoolReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"PoolReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"swapHash\",\"type\":\"bytes32\"}],\"name\":\"Returned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum WithStatus.Status\",\"name\":\"oldStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum WithStatus.Status\",\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"StatusChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ASSET_TYPE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"approveOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"approveSwapCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_assetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"lockTimeS\",\"type\":\"uint32\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getAccumulatedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_assetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"getSwapStatus\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"status\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_assetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_assetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"returnFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"revokeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"revokeSwapCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum WithStatus.Status\",\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"setStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum WithStatus.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"RampInstantEthEscrows","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"420","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://40d4f4e159553924fcd3405061198325b4e3a8413f7dda315300452cc7e2cce5"}]}