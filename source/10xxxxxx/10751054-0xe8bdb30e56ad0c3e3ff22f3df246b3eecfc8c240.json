{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.6;\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SignedSafeMath.sol\r\n\r\n\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/math/UseSafeMath.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice ((a - 1) / b) + 1 = (a + b -1) / b\r\n * for example a.add(10**18 -1).div(10**18) = a.sub(1).div(10**18) + 1\r\n */\r\n\r\nlibrary SafeMathDivRoundUp {\r\n    using SafeMath for uint256;\r\n\r\n    function divRoundUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(b > 0, errorMessage);\r\n        return ((a - 1) / b) + 1;\r\n    }\r\n\r\n    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return divRoundUp(a, b, \"SafeMathDivRoundUp: modulo by zero\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title UseSafeMath\r\n * @dev One can use SafeMath for not only uint256 but also uin64 or uint16,\r\n * and also can use SafeCast for uint256.\r\n * For example:\r\n *   uint64 a = 1;\r\n *   uint64 b = 2;\r\n *   a = a.add(b).toUint64() // `a` become 3 as uint64\r\n * In additionally, one can use SignedSafeMath and SafeCast.toUint256(int256) for int256.\r\n * In the case of the operation to the uint64 value, one need to cast the value into int256 in\r\n * advance to use `sub` as SignedSafeMath.sub not SafeMath.sub.\r\n * For example:\r\n *   int256 a = 1;\r\n *   uint64 b = 2;\r\n *   int256 c = 3;\r\n *   a = a.add(int256(b).sub(c)); // `a` become 0 as int256\r\n *   b = a.toUint256().toUint64(); // `b` become 0 as uint64\r\n */\r\nabstract contract UseSafeMath {\r\n    using SafeMath for uint256;\r\n    using SafeMathDivRoundUp for uint256;\r\n    using SafeMath for uint64;\r\n    using SafeMathDivRoundUp for uint64;\r\n    using SafeMath for uint16;\r\n    using SignedSafeMath for int256;\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n}\r\n\r\n// File: contracts/AuctionTimeControlInterface.sol\r\n\r\n\r\n\r\n\r\ninterface AuctionTimeControlInterface {\r\n    enum TimeControlFlag {\r\n        BEFORE_AUCTION_FLAG,\r\n        ACCEPTING_BIDS_PERIOD_FLAG,\r\n        REVEALING_BIDS_PERIOD_FLAG,\r\n        RECEIVING_SBT_PERIOD_FLAG,\r\n        AFTER_AUCTION_FLAG\r\n    }\r\n\r\n    function listAuction(uint256 timestamp)\r\n        external\r\n        view\r\n        returns (bytes32[] memory);\r\n\r\n    function getTimeControlFlag(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (TimeControlFlag);\r\n\r\n    function isInPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function isAfterPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/AuctionInterface.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface AuctionInterface is AuctionTimeControlInterface {\r\n    event LogStartAuction(\r\n        bytes32 indexed auctionID,\r\n        bytes32 bondID,\r\n        uint256 auctionedAmount\r\n    );\r\n\r\n    event LogCancelBid(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        bytes32 secret,\r\n        uint256 returnedIDOLAmount\r\n    );\r\n\r\n    event LogAuctionResult(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        uint256 SBTAmountOfReward,\r\n        uint256 IDOLAmountOfPayment,\r\n        uint256 IDOLAmountOfChange\r\n    );\r\n\r\n    event LogCloseAuction(\r\n        bytes32 indexed auctionID,\r\n        bool isLast,\r\n        bytes32 nextAuctionID\r\n    );\r\n\r\n    function ongoingAuctionSBTTotal(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64 ongoingSBTAmountE8);\r\n\r\n    function startAuction(\r\n        bytes32 bondID,\r\n        uint64 auctionAmount,\r\n        bool isEmergency\r\n    ) external returns (bytes32 auctonID);\r\n\r\n    function cancelBid(bytes32 auctionID, bytes32 secret)\r\n        external\r\n        returns (uint64 returnedIDOLAmount);\r\n\r\n    function makeAuctionResult(\r\n        bytes32 auctionID,\r\n        uint64 myLowestPrice,\r\n        uint64[] calldata winnerBids,\r\n        uint64[] calldata loserBids\r\n    )\r\n        external\r\n        returns (\r\n            uint64 winnerAmount,\r\n            uint64 toPay,\r\n            uint64 IDOLAmountOfChange\r\n        );\r\n\r\n    function closeAuction(bytes32 auctionID)\r\n        external\r\n        returns (bool isLast, bytes32 nextAuctionID);\r\n\r\n    function receiveUnrevealedBidDistribution(bytes32 auctionID, bytes32 secret)\r\n        external\r\n        returns (bool success);\r\n\r\n    function getCurrentAuctionID(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (bytes32 auctionID);\r\n\r\n    function generateAuctionID(bytes32 bondID, uint256 auctionCount)\r\n        external\r\n        pure\r\n        returns (bytes32 auctionID);\r\n\r\n    function listBondIDFromAuctionID(bytes32[] calldata auctionIDs)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs);\r\n\r\n    function getAuctionStatus(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 closingTime,\r\n            uint64 auctionAmount,\r\n            uint64 rewardedAmount,\r\n            uint64 totalSBTAmountBid,\r\n            bool isEmergency,\r\n            bool doneFinalizeWinnerAmount,\r\n            bool doneSortPrice,\r\n            uint64 lowestBidPriceDeadLine,\r\n            uint64 highestBidPriceDeadLine,\r\n            uint64 totalSBTAmountPaidForUnrevealed\r\n        );\r\n\r\n    function getWeeklyAuctionStatus(uint256 weekNumber)\r\n        external\r\n        view\r\n        returns (uint256[] memory weeklyAuctionStatus);\r\n\r\n    function calcWinnerAmount(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64[] calldata winnerBids\r\n    ) external view returns (uint64 winnerAmount);\r\n\r\n    function calcBillAndCheckLoserBids(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64 winnerAmountInput,\r\n        uint64 myLowestPrice,\r\n        uint64[] calldata myLoseBids\r\n    ) external view returns (uint64 paymentAmount);\r\n\r\n    function getAuctionCount(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (uint256 auctionCount);\r\n}\r\n\r\n// File: contracts/util/Time.sol\r\n\r\n\r\n\r\n\r\nabstract contract Time {\r\n    function _getBlockTimestampSec()\r\n        internal\r\n        view\r\n        returns (uint256 unixtimesec)\r\n    {\r\n        unixtimesec = now; // solium-disable-line security/no-block-members\r\n    }\r\n}\r\n\r\n// File: contracts/AuctionTimeControl.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AuctionTimeControl is Time, AuctionTimeControlInterface {\r\n    uint256 internal immutable MIN_NORMAL_AUCTION_PERIOD;\r\n    uint256 internal immutable MIN_EMERGENCY_AUCTION_PERIOD;\r\n    uint256 internal immutable NORMAL_AUCTION_REVEAL_SPAN;\r\n    uint256 internal immutable EMERGENCY_AUCTION_REVEAL_SPAN;\r\n    uint256 internal immutable AUCTION_WITHDRAW_SPAN;\r\n    uint256 internal immutable EMERGENCY_AUCTION_WITHDRAW_SPAN;\r\n\r\n    TimeControlFlag internal constant BEFORE_AUCTION_FLAG = TimeControlFlag\r\n        .BEFORE_AUCTION_FLAG;\r\n    TimeControlFlag internal constant ACCEPTING_BIDS_PERIOD_FLAG = TimeControlFlag\r\n        .ACCEPTING_BIDS_PERIOD_FLAG;\r\n    TimeControlFlag internal constant REVEALING_BIDS_PERIOD_FLAG = TimeControlFlag\r\n        .REVEALING_BIDS_PERIOD_FLAG;\r\n    TimeControlFlag internal constant RECEIVING_SBT_PERIOD_FLAG = TimeControlFlag\r\n        .RECEIVING_SBT_PERIOD_FLAG;\r\n    TimeControlFlag internal constant AFTER_AUCTION_FLAG = TimeControlFlag\r\n        .AFTER_AUCTION_FLAG;\r\n\r\n    /**\r\n     * @dev Get whether the auction is in emergency or not.\r\n     */\r\n    mapping(bytes32 => bool) public isAuctionEmergency;\r\n\r\n    /**\r\n     * @dev The end time that the auction accepts bids.\r\n     * The zero value indicates the auction is not held.\r\n     */\r\n    mapping(bytes32 => uint256) public auctionClosingTime;\r\n\r\n    /**\r\n     * @dev The contents in this internal storage variable can be seen by listAuction function.\r\n     */\r\n    mapping(uint256 => bytes32[]) internal _weeklyAuctionList;\r\n\r\n    constructor(\r\n        uint256 minNormalAuctionPeriod,\r\n        uint256 minEmergencyAuctionPeriod,\r\n        uint256 normalAuctionRevealSpan,\r\n        uint256 emergencyAuctionRevealSpan,\r\n        uint256 auctionWithdrawSpan,\r\n        uint256 emergencyAuctionWithdrawSpan\r\n    ) public {\r\n        MIN_NORMAL_AUCTION_PERIOD = minNormalAuctionPeriod;\r\n        MIN_EMERGENCY_AUCTION_PERIOD = minEmergencyAuctionPeriod;\r\n        NORMAL_AUCTION_REVEAL_SPAN = normalAuctionRevealSpan;\r\n        EMERGENCY_AUCTION_REVEAL_SPAN = emergencyAuctionRevealSpan;\r\n        AUCTION_WITHDRAW_SPAN = auctionWithdrawSpan;\r\n        EMERGENCY_AUCTION_WITHDRAW_SPAN = emergencyAuctionWithdrawSpan;\r\n    }\r\n\r\n    /**\r\n     * @dev Get auctions which will close within the week.\r\n     */\r\n    function listAuction(uint256 weekNumber)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        return _weeklyAuctionList[weekNumber];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the period the auction is currently in.\r\n     * This function returns 0-4 corresponding to its period.\r\n     */\r\n    function getTimeControlFlag(bytes32 auctionID)\r\n        public\r\n        override\r\n        view\r\n        returns (TimeControlFlag)\r\n    {\r\n        uint256 closingTime = auctionClosingTime[auctionID];\r\n\r\n        // Note that the auction span differs based on whether the auction is in emergency or not.\r\n        bool isEmergency = isAuctionEmergency[auctionID];\r\n        uint256 revealSpan = NORMAL_AUCTION_REVEAL_SPAN;\r\n        uint256 withdrawSpan = AUCTION_WITHDRAW_SPAN;\r\n        if (isEmergency) {\r\n            revealSpan = EMERGENCY_AUCTION_REVEAL_SPAN;\r\n            withdrawSpan = EMERGENCY_AUCTION_WITHDRAW_SPAN;\r\n        }\r\n\r\n        uint256 nowTime = _getBlockTimestampSec();\r\n        if (closingTime == 0) {\r\n            return BEFORE_AUCTION_FLAG;\r\n        } else if (nowTime <= closingTime) {\r\n            return ACCEPTING_BIDS_PERIOD_FLAG;\r\n        } else if (nowTime < closingTime + revealSpan) {\r\n            return REVEALING_BIDS_PERIOD_FLAG;\r\n        } else if (nowTime < closingTime + revealSpan + withdrawSpan) {\r\n            return RECEIVING_SBT_PERIOD_FLAG;\r\n        } else {\r\n            return AFTER_AUCTION_FLAG;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns whether or not the auction is in the period indicated\r\n     * by the flag.\r\n     */\r\n    function isInPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        public\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return getTimeControlFlag(auctionID) == flag;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether or not the auction is in or after the period indicated\r\n     * by the flag.\r\n     */\r\n    function isAfterPeriod(bytes32 auctionID, TimeControlFlag flag)\r\n        public\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return getTimeControlFlag(auctionID) >= flag;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates and registers the end time of the period in which the auction accepts bids\r\n     * (= closingTime). The period in which bids are revealed follows after this time.\r\n     */\r\n    function _setAuctionClosingTime(bytes32 auctionID, bool isEmergency)\r\n        internal\r\n    {\r\n        uint256 closingTime;\r\n\r\n        if (isEmergency) {\r\n            closingTime =\r\n                ((_getBlockTimestampSec() +\r\n                    MIN_EMERGENCY_AUCTION_PERIOD +\r\n                    5 minutes -\r\n                    1) / 5 minutes) *\r\n                (5 minutes);\r\n        } else {\r\n            closingTime =\r\n                ((_getBlockTimestampSec() +\r\n                    MIN_NORMAL_AUCTION_PERIOD +\r\n                    1 hours -\r\n                    1) / 1 hours) *\r\n                (1 hours);\r\n        }\r\n        _setAuctionClosingTime(auctionID, isEmergency, closingTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the end time of the period in which the auction accepts bids (= closingTime).\r\n     * The period in which bids are revealed follows after this time.\r\n     */\r\n    function _setAuctionClosingTime(\r\n        bytes32 auctionID,\r\n        bool isEmergency,\r\n        uint256 closingTime\r\n    ) internal {\r\n        isAuctionEmergency[auctionID] = isEmergency;\r\n        auctionClosingTime[auctionID] = closingTime;\r\n        uint256 weekNumber = closingTime / (1 weeks);\r\n        _weeklyAuctionList[weekNumber].push(auctionID);\r\n    }\r\n}\r\n\r\n// File: contracts/BondMakerInterface.sol\r\n\r\n\r\n\r\n\r\ninterface BondMakerInterface {\r\n    event LogNewBond(\r\n        bytes32 indexed bondID,\r\n        address bondTokenAddress,\r\n        uint64 stableStrikePrice,\r\n        bytes32 fnMapID\r\n    );\r\n\r\n    event LogNewBondGroup(uint256 indexed bondGroupID);\r\n\r\n    event LogIssueNewBonds(\r\n        uint256 indexed bondGroupID,\r\n        address indexed issuer,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogReverseBondToETH(\r\n        uint256 indexed bondGroupID,\r\n        address indexed owner,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogExchangeEquivalentBonds(\r\n        address indexed owner,\r\n        uint256 indexed inputBondGroupID,\r\n        uint256 indexed outputBondGroupID,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogTransferETH(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    function registerNewBond(uint256 maturity, bytes calldata fnMap)\r\n        external\r\n        returns (\r\n            bytes32 bondID,\r\n            address bondTokenAddress,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function registerNewBondGroup(\r\n        bytes32[] calldata bondIDList,\r\n        uint256 maturity\r\n    ) external returns (uint256 bondGroupID);\r\n\r\n    function issueNewBonds(uint256 bondGroupID)\r\n        external\r\n        payable\r\n        returns (uint256 amount);\r\n\r\n    function reverseBondToETH(uint256 bondGroupID, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function exchangeEquivalentBonds(\r\n        uint256 inputBondGroupID,\r\n        uint256 outputBondGroupID,\r\n        uint256 amount,\r\n        bytes32[] calldata exceptionBonds\r\n    ) external returns (bool);\r\n\r\n    function liquidateBond(uint256 bondGroupID, uint256 oracleHintID) external;\r\n\r\n    function getBond(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (\r\n            address bondAddress,\r\n            uint256 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function getFnMap(bytes32 fnMapID)\r\n        external\r\n        view\r\n        returns (bytes memory fnMap);\r\n\r\n    function getBondGroup(uint256 bondGroupID)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs, uint256 maturity);\r\n\r\n    function generateBondID(uint256 maturity, bytes calldata functionHash)\r\n        external\r\n        pure\r\n        returns (bytes32 bondID);\r\n}\r\n\r\n// File: contracts/UseBondMaker.sol\r\n\r\n\r\n\r\n\r\n\r\nabstract contract UseBondMaker {\r\n    BondMakerInterface internal immutable _bondMakerContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _bondMakerContract = BondMakerInterface(payable(contractAddress));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/StableCoinInterface.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface StableCoinInterface is IERC20 {\r\n    event LogIsAcceptableSBT(bytes32 indexed bondID, bool isAcceptable);\r\n\r\n    event LogMintIDOL(\r\n        bytes32 indexed bondID,\r\n        address indexed owner,\r\n        bytes32 poolID,\r\n        uint256 obtainIDOLAmount,\r\n        uint256 poolIDOLAmount\r\n    );\r\n\r\n    event LogBurnIDOL(\r\n        bytes32 indexed bondID, // poolID?\r\n        address indexed owner,\r\n        uint256 burnIDOLAmount,\r\n        uint256 unlockSBTAmount\r\n    );\r\n\r\n    event LogReturnLockedPool(\r\n        bytes32 indexed poolID,\r\n        address indexed owner,\r\n        uint64 backIDOLAmount\r\n    );\r\n\r\n    event LogLambda(\r\n        bytes32 indexed poolID,\r\n        uint64 settledAverageAuctionPrice,\r\n        uint256 totalSupply,\r\n        uint256 lockedSBTValue\r\n    );\r\n\r\n    function getPoolInfo(bytes32 poolID)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 lockedSBTTotal,\r\n            uint64 unlockedSBTTotal,\r\n            uint64 lockedPoolIDOLTotal,\r\n            uint64 burnedIDOLTotal,\r\n            uint64 soldSBTTotalInAuction,\r\n            uint64 paidIDOLTotalInAuction,\r\n            uint64 settledAverageAuctionPrice,\r\n            bool isAllAmountSoldInAuction\r\n        );\r\n\r\n    function solidValueTotal() external view returns (uint256 solidValue);\r\n\r\n    function isAcceptableSBT(bytes32 bondID) external returns (bool ok);\r\n\r\n    function mint(\r\n        bytes32 bondID,\r\n        address recipient,\r\n        uint64 lockAmount\r\n    )\r\n        external\r\n        returns (\r\n            bytes32 poolID,\r\n            uint64 obtainIDOLAmount,\r\n            uint64 poolIDOLAmount\r\n        );\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n\r\n    function unlockSBT(bytes32 bondID, uint64 burnAmount)\r\n        external\r\n        returns (uint64 rewardSBT);\r\n\r\n    function startAuctionOnMaturity(bytes32 bondID) external;\r\n\r\n    function startAuctionByMarket(bytes32 bondID) external;\r\n\r\n    function setSettledAverageAuctionPrice(\r\n        bytes32 bondID,\r\n        uint64 totalPaidIDOL,\r\n        uint64 SBTAmount,\r\n        bool isLast\r\n    ) external;\r\n\r\n    function calcSBT2IDOL(uint256 solidBondAmount)\r\n        external\r\n        view\r\n        returns (uint256 IDOLAmount);\r\n\r\n    function returnLockedPool(bytes32[] calldata poolIDs)\r\n        external\r\n        returns (uint64 IDOLAmount);\r\n\r\n    function returnLockedPoolTo(bytes32[] calldata poolIDs, address account)\r\n        external\r\n        returns (uint64 IDOLAmount);\r\n\r\n    function generatePoolID(bytes32 bondID, uint64 count)\r\n        external\r\n        pure\r\n        returns (bytes32 poolID);\r\n\r\n    function getCurrentPoolID(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (bytes32 poolID);\r\n\r\n    function getLockedPool(address user, bytes32 poolID)\r\n        external\r\n        view\r\n        returns (uint64, uint64);\r\n}\r\n\r\n// File: contracts/UseStableCoin.sol\r\n\r\n\r\n\r\n\r\n\r\nabstract contract UseStableCoin {\r\n    StableCoinInterface internal immutable _IDOLContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _IDOLContract = StableCoinInterface(contractAddress);\r\n    }\r\n\r\n    function _transferIDOLFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        _IDOLContract.transferFrom(from, to, amount);\r\n    }\r\n\r\n    function _transferIDOL(address to, uint256 amount) internal {\r\n        _IDOLContract.transfer(to, amount);\r\n    }\r\n\r\n    function _transferIDOL(\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMessage\r\n    ) internal {\r\n        require(_IDOLContract.balanceOf(address(this)) >= amount, errorMessage);\r\n        _IDOLContract.transfer(to, amount);\r\n    }\r\n}\r\n\r\n// File: contracts/auction/AuctionSecret.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface AuctionSecretInterface {\r\n        function auctionSecret(\r\n        bytes32 auctionID,\r\n        bytes32 secret\r\n    ) external view returns (\r\n        address sender,\r\n        uint64 amount,\r\n        uint64 IDOLamount\r\n    );\r\n}\r\n\r\nabstract contract AuctionSecret is AuctionSecretInterface {\r\n    /**\r\n     * @param sender is the account who set this secret bid.\r\n     * @param amount is target SBT amount.\r\n     * @param IDOLamount is deposited iDOL amount attached to this secret bid.\r\n     */\r\n    struct Secret {\r\n        address sender;\r\n        uint64 amount;\r\n        uint64 IDOLamount;\r\n    }\r\n    mapping(bytes32 => mapping(bytes32 => Secret)) public override auctionSecret;\r\n\r\n    function _setSecret(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        address sender,\r\n        uint64 amount,\r\n        uint64 IDOLamount\r\n    ) internal returns (bool) {\r\n        require(\r\n            auctionSecret[auctionID][secret].sender == address(0),\r\n            \"Secret already exists\"\r\n        );\r\n        require(sender != address(0), \"the zero address cannot set secret\");\r\n        auctionSecret[auctionID][secret] = Secret({\r\n            sender: sender,\r\n            amount: amount,\r\n            IDOLamount: IDOLamount\r\n        });\r\n        return true;\r\n    }\r\n\r\n    function _removeSecret(bytes32 auctionID, bytes32 secret)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        delete auctionSecret[auctionID][secret];\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/AuctionBoardInterface.sol\r\n\r\n\r\n\r\n\r\ninterface AuctionBoardInterface is AuctionSecretInterface {\r\n    event LogBidMemo(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        bytes memo\r\n    );\r\n\r\n    event LogInsertBoard(\r\n        bytes32 indexed auctionID,\r\n        address indexed bidder,\r\n        uint64 bidPrice,\r\n        uint64 boardIndex,\r\n        uint64 targetSBTAmount\r\n    );\r\n\r\n    event LogAuctionInfoDiff(\r\n        bytes32 indexed auctionID,\r\n        uint64 settledAmount,\r\n        uint64 paidIDOL,\r\n        uint64 rewardedSBT\r\n    );\r\n\r\n    function bidWithMemo(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        uint64 totalSBTAmountBid,\r\n        bytes calldata memo\r\n    ) external returns (uint256 depositedIDOLAmount);\r\n\r\n    function revealBids(\r\n        bytes32 auctionID,\r\n        uint64[] calldata bids,\r\n        uint64 random\r\n    ) external;\r\n\r\n    function sortBidPrice(bytes32 auctionID, uint64[] calldata sortedPrice)\r\n        external;\r\n\r\n    function makeEndInfo(bytes32 auctionID) external;\r\n\r\n    function calcBill(\r\n        bytes32 auctionID,\r\n        uint64 winnerAmount,\r\n        uint64 myLowestPrice\r\n    ) external view returns (uint64 paymentAmount);\r\n\r\n    function getUnsortedBidPrice(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory bidPriceList);\r\n\r\n    function getSortedBidPrice(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory bidPriceList);\r\n\r\n    function getEndInfo(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 price,\r\n            uint64 boardIndex,\r\n            uint64 loseSBTAmount,\r\n            uint64 auctionEndPriceWinnerSBTAmount\r\n        );\r\n\r\n    function getBidderStatus(bytes32 auctionID, address bidder)\r\n        external\r\n        view\r\n        returns (uint64 toBack, bool isIDOLReturned);\r\n\r\n    function getBoard(\r\n        bytes32 auctionID,\r\n        uint64 price,\r\n        uint64 boardIndex\r\n    ) external view returns (address bidder, uint64 amount);\r\n\r\n    function getBoardStatus(bytes32 auctionID)\r\n        external\r\n        view\r\n        returns (uint64[] memory boardStatus);\r\n\r\n    function generateMultiSecret(\r\n        bytes32 auctionID,\r\n        uint64[] calldata bids,\r\n        uint64 random\r\n    ) external pure returns (bytes32 secret);\r\n\r\n    function discretizeBidPrice(uint64 price)\r\n        external\r\n        pure\r\n        returns (uint64 discretizedPrice);\r\n\r\n    function auctionDisposalInfo(bytes32 auctionID) external view returns (\r\n        uint64 solidStrikePriceIDOLForUnrevealedE8,\r\n        uint64 solidStrikePriceIDOLForRestWinnersE8,\r\n        bool isEndInfoCreated,\r\n        bool isForceToFinalizeWinnerAmountTriggered,\r\n        bool isPriceSorted\r\n    );\r\n\r\n    function removeSecret(\r\n        bytes32 auctionID,\r\n        bytes32 secret,\r\n        uint64 subtractAmount\r\n    ) external;\r\n\r\n    function auctionRevealInfo(bytes32 auctionID) external view returns (\r\n        uint64 totalSBTAmountBid,\r\n        uint64 totalIDOLSecret,\r\n        uint64 totalIDOLRevealed,\r\n        uint16 auctionPriceCount\r\n    );\r\n\r\n    function auctionBoard(\r\n        bytes32 auctionID,\r\n        uint64 bidPrice,\r\n        uint256 boardIndex\r\n    ) external view returns (\r\n        uint64 bidAmount,\r\n        address bidder\r\n    );\r\n\r\n    function auctionParticipantInfo(\r\n        bytes32 auctionID,\r\n        address participant\r\n    ) external view returns (\r\n        uint64 auctionLockedIDOLAmountE8,\r\n        uint16 bidCount\r\n    );\r\n\r\n    function auctionInfo(\r\n        bytes32 auctionID\r\n    ) external view returns (\r\n        uint64 auctionSettledTotalE8,\r\n        uint64 auctionRewardedTotalE8,\r\n        uint64 auctionPaidTotalE8\r\n    );\r\n\r\n    function updateAuctionInfo(\r\n        bytes32 auctionID,\r\n        uint64 settledAmountE8,\r\n        uint64 paidIDOLE8,\r\n        uint64 rewardedSBTE8\r\n    ) external;\r\n\r\n    function deleteParticipantInfo(\r\n        bytes32 auctionID,\r\n        address participant\r\n    ) external;\r\n}\r\n\r\n// File: contracts/UseAuctionBoard.sol\r\n\r\n\r\n\r\n\r\n\r\nabstract contract UseAuctionBoard {\r\n    AuctionBoardInterface internal immutable _auctionBoardContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _auctionBoardContract = AuctionBoardInterface(contractAddress);\r\n    }\r\n}\r\n\r\n// File: contracts/oracle/OracleInterface.sol\r\n\r\n\r\n\r\n\r\n// Oracle referenced by OracleProxy must implement this interface.\r\ninterface OracleInterface {\r\n    // Returns if oracle is running.\r\n    function alive() external view returns (bool);\r\n\r\n    // Returns latest id.\r\n    // The first id is 1 and 0 value is invalid as id.\r\n    // Each price values and theirs timestamps are identified by id.\r\n    // Ids are assigned incrementally to values.\r\n    function latestId() external returns (uint256);\r\n\r\n    // Returns latest price value.\r\n    // decimal 8\r\n    function latestPrice() external returns (uint256);\r\n\r\n    // Returns timestamp of latest price.\r\n    function latestTimestamp() external returns (uint256);\r\n\r\n    // Returns price of id.\r\n    function getPrice(uint256 id) external returns (uint256);\r\n\r\n    // Returns timestamp of id.\r\n    function getTimestamp(uint256 id) external returns (uint256);\r\n\r\n    function getVolatility() external returns (uint256);\r\n}\r\n\r\n// File: contracts/oracle/UseOracle.sol\r\n\r\n\r\n\r\n\r\n\r\nabstract contract UseOracle {\r\n    OracleInterface internal _oracleContract;\r\n\r\n    constructor(address contractAddress) public {\r\n        require(\r\n            contractAddress != address(0),\r\n            \"contract should be non-zero address\"\r\n        );\r\n        _oracleContract = OracleInterface(contractAddress);\r\n    }\r\n\r\n    /// @notice Get the latest USD/ETH price and historical volatility using oracle.\r\n    /// @return rateETH2USDE8 (10^-8 USD/ETH)\r\n    /// @return volatilityE8 (10^-8)\r\n    function _getOracleData()\r\n        internal\r\n        returns (uint256 rateETH2USDE8, uint256 volatilityE8)\r\n    {\r\n        rateETH2USDE8 = _oracleContract.latestPrice();\r\n        volatilityE8 = _oracleContract.getVolatility();\r\n\r\n        return (rateETH2USDE8, volatilityE8);\r\n    }\r\n\r\n    /// @notice Get the price of the oracle data with a minimum timestamp that does more than input value\r\n    /// when you know the ID you are looking for.\r\n    /// @param timestamp is the timestamp that you want to get price.\r\n    /// @param hintID is the ID of the oracle data you are looking for.\r\n    /// @return rateETH2USDE8 (10^-8 USD/ETH)\r\n    function _getPriceOn(uint256 timestamp, uint256 hintID)\r\n        internal\r\n        returns (uint256 rateETH2USDE8)\r\n    {\r\n        uint256 latestID = _oracleContract.latestId();\r\n        require(\r\n            latestID != 0,\r\n            \"system error: the ID of oracle data should not be zero\"\r\n        );\r\n\r\n        require(hintID != 0, \"the hint ID must not be zero\");\r\n        uint256 id = hintID;\r\n        if (hintID > latestID) {\r\n            id = latestID;\r\n        }\r\n\r\n        require(\r\n            _oracleContract.getTimestamp(id) > timestamp,\r\n            \"there is no price data after maturity\"\r\n        );\r\n\r\n        id--;\r\n        while (id != 0) {\r\n            if (_oracleContract.getTimestamp(id) <= timestamp) {\r\n                break;\r\n            }\r\n            id--;\r\n        }\r\n\r\n        return _oracleContract.getPrice(id + 1);\r\n    }\r\n}\r\n\r\n// File: contracts/util/TransferETHInterface.sol\r\n\r\n\r\n\r\n\r\ninterface TransferETHInterface {\r\n    receive() external payable;\r\n\r\n    event LogTransferETH(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/bondToken/BondTokenInterface.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface BondTokenInterface is TransferETHInterface, IERC20 {\r\n    event LogExpire(\r\n        uint128 rateNumerator,\r\n        uint128 rateDenominator,\r\n        bool firstTime\r\n    );\r\n\r\n    function mint(address account, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function expire(uint128 rateNumerator, uint128 rateDenominator)\r\n        external\r\n        returns (bool firstTime);\r\n\r\n    function burn(uint256 amount) external returns (bool success);\r\n\r\n    function burnAll() external returns (uint256 amount);\r\n\r\n    function isMinter(address account) external view returns (bool minter);\r\n\r\n    function getRate()\r\n        external\r\n        view\r\n        returns (uint128 rateNumerator, uint128 rateDenominator);\r\n}\r\n\r\n// File: contracts/Auction.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Auction is\r\n    UseSafeMath,\r\n    AuctionInterface,\r\n    AuctionTimeControl,\r\n    UseStableCoin,\r\n    UseBondMaker,\r\n    UseAuctionBoard\r\n{\r\n    using Math for uint256;\r\n\r\n    uint64 internal constant NO_SKIP_BID = uint64(-1);\r\n    uint64 internal constant SKIP_RECEIVING_WIN_BIDS = uint64(-2);\r\n    uint256 internal constant POOL_AUCTION_COUNT_PADDING = 10**8;\r\n\r\n    /**\r\n     * @notice The times of auctions held for the auction ID.\r\n     * @dev The contents in this internal storage variable can be seen by getAuctionCount function.\r\n     */\r\n    mapping(bytes32 => uint256) internal _bondIDAuctionCount;\r\n\r\n    /**\r\n     * @notice Get the bond ID from the auction ID.\r\n     */\r\n    mapping(bytes32 => bytes32) public auctionID2BondID;\r\n\r\n    /**\r\n     * @dev The contents in this internal storage variable can be seen by getAuctionStatus function.\r\n     * @param ongoingAuctionSBTTotalE8 is the SBT amount put up in the auction.\r\n     * @param lowestBidPriceDeadLineE8 is the minimum bid price in the auction.\r\n     * @param highestBidPriceDeadLineE8 is the maximum bid price in the auction.\r\n     * @param totalSBTAmountPaidForUnrevealedE8 is the SBT Amount allocated for those who had not revealed their own bid.\r\n     */\r\n    struct AuctionConfig {\r\n        uint64 ongoingAuctionSBTTotalE8;\r\n        uint64 lowestBidPriceDeadLineE8;\r\n        uint64 highestBidPriceDeadLineE8;\r\n        uint64 totalSBTAmountPaidForUnrevealedE8;\r\n    }\r\n    mapping(bytes32 => AuctionConfig) internal _auctionConfigList;\r\n\r\n    constructor(\r\n        address bondMakerAddress,\r\n        address IDOLAddress,\r\n        address auctionBoardAddress,\r\n        uint256 minNormalAuctionPeriod,\r\n        uint256 minEmergencyAuctionPeriod,\r\n        uint256 normalAuctionRevealSpan,\r\n        uint256 emergencyAuctionRevealSpan,\r\n        uint256 auctionWithdrawSpan,\r\n        uint256 emergencyAuctionWithdrawSpan\r\n    )\r\n        public\r\n        AuctionTimeControl(\r\n            minNormalAuctionPeriod,\r\n            minEmergencyAuctionPeriod,\r\n            normalAuctionRevealSpan,\r\n            emergencyAuctionRevealSpan,\r\n            auctionWithdrawSpan,\r\n            emergencyAuctionWithdrawSpan\r\n        )\r\n        UseBondMaker(bondMakerAddress)\r\n        UseStableCoin(IDOLAddress)\r\n        UseAuctionBoard(auctionBoardAddress)\r\n    {}\r\n\r\n    /**\r\n     * @dev This function starts the auction for the auctionID. Can be called only by the IDOL contract.\r\n     */\r\n    function startAuction(\r\n        bytes32 bondID,\r\n        uint64 auctionAmount,\r\n        bool isEmergency\r\n    ) external override returns (bytes32) {\r\n        require(\r\n            msg.sender == address(_IDOLContract),\r\n            \"caller must be IDOL contract\"\r\n        );\r\n        return _startAuction(bondID, auctionAmount, isEmergency);\r\n    }\r\n\r\n    /**\r\n     * @notice This function is called when the auction (re)starts.\r\n     * @param bondID is SBT ID whose auction will be held.\r\n     * @param auctionAmount is SBT amount put up in the auction.\r\n     * @param isEmergency is the flag that indicates the auction schedule is for emergency mode.\r\n     */\r\n    function _startAuction(\r\n        bytes32 bondID,\r\n        uint64 auctionAmount,\r\n        bool isEmergency\r\n    ) internal returns (bytes32) {\r\n        (, , uint256 solidStrikePriceE4, ) = _bondMakerContract.getBond(bondID);\r\n        uint256 strikePriceIDOL = _IDOLContract.calcSBT2IDOL(\r\n            solidStrikePriceE4.mul(10**8)\r\n        );\r\n\r\n        uint256 auctionCount = _bondIDAuctionCount[bondID].add(1);\r\n        _bondIDAuctionCount[bondID] = auctionCount;\r\n        bytes32 auctionID = getCurrentAuctionID(bondID);\r\n        require(\r\n            isInPeriod(auctionID, BEFORE_AUCTION_FLAG),\r\n            \"the auction has been held\"\r\n        );\r\n\r\n        uint256 betaCount = auctionCount.mod(POOL_AUCTION_COUNT_PADDING).min(9);\r\n\r\n        auctionID2BondID[auctionID] = bondID;\r\n\r\n        _setAuctionClosingTime(auctionID, isEmergency);\r\n\r\n        {\r\n            AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n            auctionConfig.ongoingAuctionSBTTotalE8 = auctionAmount;\r\n            auctionConfig.lowestBidPriceDeadLineE8 = _auctionBoardContract\r\n                .discretizeBidPrice(\r\n                strikePriceIDOL\r\n                    .mul(10 - betaCount)\r\n                    .divRoundUp(10**(1 + 8))\r\n                    .mul(10**8)\r\n                    .toUint64()\r\n            );\r\n            auctionConfig.highestBidPriceDeadLineE8 = _auctionBoardContract\r\n                .discretizeBidPrice(\r\n                strikePriceIDOL.divRoundUp(10**8).mul(10**8).toUint64()\r\n            );\r\n            _auctionConfigList[auctionID] = auctionConfig;\r\n        }\r\n\r\n        emit LogStartAuction(auctionID, bondID, auctionAmount);\r\n\r\n        return auctionID;\r\n    }\r\n\r\n    /**\r\n     * @notice submit only your own winning bids and get SBT amount which you'll aquire.\r\n     */\r\n    function calcWinnerAmount(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64[] memory winnerBids\r\n    ) public override view returns (uint64) {\r\n        uint256 totalBidAmount;\r\n\r\n        (\r\n            uint64 endPrice,\r\n            uint64 endBoardIndex,\r\n            uint64 loseSBTAmount,\r\n\r\n        ) = _auctionBoardContract.getEndInfo(auctionID);\r\n\r\n        uint64 bidPrice;\r\n        uint64 boardIndex;\r\n        // can calculate winner amount after making the end info.\r\n        {\r\n            (, , bool isEndInfoCreated, , ) = _auctionBoardContract\r\n                .auctionDisposalInfo(auctionID);\r\n            require(isEndInfoCreated, \"the end info has not been made yet\");\r\n        }\r\n\r\n        for (uint256 i = 0; i < winnerBids.length; i += 2) {\r\n            if (i != 0) {\r\n                require(\r\n                    bidPrice > winnerBids[i] ||\r\n                        (bidPrice == winnerBids[i] &&\r\n                            boardIndex < winnerBids[i + 1]),\r\n                    \"winner bids are not sorted\"\r\n                );\r\n            }\r\n            bidPrice = winnerBids[i];\r\n            boardIndex = winnerBids[i + 1];\r\n            (uint64 bidAmount, address bidder) = _auctionBoardContract\r\n                .auctionBoard(auctionID, bidPrice, boardIndex);\r\n            require(bidder == sender, \"this bid is not yours\");\r\n\r\n            totalBidAmount = totalBidAmount.add(bidAmount);\r\n            if (endPrice == bidPrice) {\r\n                if (boardIndex == endBoardIndex) {\r\n                    // Guarantee loseSBTAmount <= bidAmount in this case.\r\n                    totalBidAmount = totalBidAmount.sub(loseSBTAmount);\r\n                } else {\r\n                    require(\r\n                        boardIndex < endBoardIndex,\r\n                        \"this bid does not win\"\r\n                    );\r\n                }\r\n            } else {\r\n                require(endPrice < bidPrice, \"this bid does not win\");\r\n            }\r\n        }\r\n\r\n        return totalBidAmount.toUint64();\r\n    }\r\n\r\n    /**\r\n     * @notice all loser bids must be reported to this function. These are checked and counted for calculations of bill.\r\n     * @param auctionID aunctionID\r\n     * @param sender owner of the bids\r\n     * @param winnerAmountInput SBT amount to aquire. this is needed because this effect the price of SBT in Vickly Auction's protocol.\r\n     * @param myLowestPrice myLowestPrice is the lowest price of skip bids.\r\n     * @param myLoseBids is the all bids which is after the endInfo\r\n     */\r\n    function calcBillAndCheckLoserBids(\r\n        bytes32 auctionID,\r\n        address sender,\r\n        uint64 winnerAmountInput,\r\n        uint64 myLowestPrice,\r\n        uint64[] memory myLoseBids\r\n    ) public override view returns (uint64) {\r\n        uint256 winnerAmount = winnerAmountInput;\r\n        uint256 toPaySkip = 0;\r\n\r\n        if (\r\n            myLowestPrice != NO_SKIP_BID &&\r\n            myLowestPrice != SKIP_RECEIVING_WIN_BIDS\r\n        ) {\r\n            bool myLowestVerify = false;\r\n            for (uint256 i = 0; i < myLoseBids.length; i += 2) {\r\n                uint64 price = myLoseBids[i];\r\n                if (price == myLowestPrice) {\r\n                    myLowestVerify = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            require(\r\n                myLowestVerify,\r\n                \"myLowestPrice must be included in myLoseBids\"\r\n            );\r\n        }\r\n\r\n        // The amount of sender's lose bids will be skipped. In order to optimize the calculation,\r\n        // components in myLoseBids with a higher price than myLowestPrice are added to winnerAmount and\r\n        // to be subtracted at the end of this function.\r\n        for (uint256 i = 0; i < myLoseBids.length; i += 2) {\r\n            uint64 price = myLoseBids[i];\r\n            uint64 boardIndex = myLoseBids[i + 1];\r\n\r\n            if (i != 0) {\r\n                require(\r\n                    price < myLoseBids[i - 2] ||\r\n                        (price == myLoseBids[i - 2] &&\r\n                            boardIndex > myLoseBids[i - 1]),\r\n                    \"myLoseBids is not sorted\"\r\n                );\r\n            }\r\n            {\r\n                (\r\n                    uint64 endPrice,\r\n                    uint64 endBoardIndex,\r\n                    uint64 loseSBTAmount,\r\n\r\n                ) = _auctionBoardContract.getEndInfo(auctionID);\r\n\r\n                if (price == endPrice) {\r\n                    if (boardIndex == endBoardIndex) {\r\n                        require(\r\n                            loseSBTAmount != 0,\r\n                            \"myLoseBids includes the bid which is same as endInfo with no lose SBT amount\"\r\n                        );\r\n\r\n                        // This function does not guarantee to return the correct result if an invalid input is given,\r\n                        // because this function can be used just for getting information.\r\n                        // This function is used in the procecss of makeAuctionResult(), and in such a case,\r\n                        // all the verification for bidder==sender and some necessary conditions are processed\r\n                        // in different functions.\r\n\r\n                        if (myLowestPrice <= price) {\r\n                            winnerAmount = winnerAmount.add(loseSBTAmount);\r\n                            toPaySkip = toPaySkip.add(\r\n                                price.mul(loseSBTAmount).div(10**8)\r\n                            );\r\n                            continue;\r\n                        }\r\n                    } else {\r\n                        require(\r\n                            boardIndex > endBoardIndex,\r\n                            \"myLoseBids includes the bid whose bid index is less than that of endInfo\"\r\n                        );\r\n                    }\r\n                } else {\r\n                    require(\r\n                        price < endPrice,\r\n                        \"myLoseBids includes the bid whose price is more than that of endInfo\"\r\n                    );\r\n                }\r\n            }\r\n\r\n            (uint64 bidAmount, address bidder) = _auctionBoardContract\r\n                .auctionBoard(auctionID, price, boardIndex);\r\n            require(\r\n                bidder == sender,\r\n                \"myLoseBids includes the bid whose owner is not the sender\"\r\n            );\r\n\r\n            if (myLowestPrice <= price) {\r\n                winnerAmount = winnerAmount.add(bidAmount);\r\n                toPaySkip = toPaySkip.add(price.mul(bidAmount).div(10**8));\r\n            }\r\n        }\r\n\r\n        if (myLowestPrice == SKIP_RECEIVING_WIN_BIDS) {\r\n            // Reduce calculation costs instead by receiving obtained SBT at the highest losing price.\r\n            (uint64 endPrice, , , ) = _auctionBoardContract.getEndInfo(\r\n                auctionID\r\n            );\r\n            //while toPaySkip is expected to be zero in the loop above,\r\n            //only the exception is when the the price acctually hit uint64(-1) at an extremely unexpected case.\r\n            return\r\n                endPrice\r\n                    .mul(winnerAmount)\r\n                    .divRoundUp(10**8)\r\n                    .sub(toPaySkip)\r\n                    .toUint64();\r\n        }\r\n\r\n        return\r\n            _auctionBoardContract\r\n                .calcBill(auctionID, winnerAmount.toUint64(), myLowestPrice)\r\n                .sub(toPaySkip)\r\n                .toUint64();\r\n    }\r\n\r\n    /**\r\n     * @notice Submit all my win and lose bids, verify them, and transfer the auction reward.\r\n     * @param winnerBids is an array of alternating price and board index.\r\n     * For example, if the end info is { price: 96, boardIndex: 0, loseSBTAmount: 100000000 } and you have 3 bids:\r\n     * { price: 99, boardIndex: 0 }, { price: 97, boardIndex: 2 }, and { price: 96, boardIndex: 1 },\r\n     * you should submit [9900000000, 0, 9700000000, 2] as winnerBids and [9600000000, 1] as loserBids.\r\n     * If the end info is { price: 96, boardIndex: 0, loseSBTAmount: 100000000 } and you have 1 bid:\r\n     * { price: 96, boardIndex: 0 }, you should submit [9600000000, 0] as winnerBids and [9600000000, 0]\r\n     * as loserBids.\r\n     */\r\n    function makeAuctionResult(\r\n        bytes32 auctionID,\r\n        uint64 myLowestPrice,\r\n        uint64[] memory winnerBids,\r\n        uint64[] memory loserBids\r\n    )\r\n        public\r\n        override\r\n        returns (\r\n            uint64,\r\n            uint64,\r\n            uint64\r\n        )\r\n    {\r\n        (\r\n            uint64 auctionLockedIDOLAmountE8,\r\n            uint16 bidCount\r\n        ) = _auctionBoardContract.auctionParticipantInfo(auctionID, msg.sender);\r\n\r\n        require(auctionLockedIDOLAmountE8 != 0, \"This process is already done\");\r\n\r\n        {\r\n            (\r\n                uint64 endPrice,\r\n                uint64 endBoardIndex,\r\n                uint64 loseSBTAmount,\r\n                uint64 auctionEndPriceWinnerSBTAmount\r\n            ) = _auctionBoardContract.getEndInfo(auctionID);\r\n            (address endBidder, ) = _auctionBoardContract.getBoard(\r\n                auctionID,\r\n                endPrice,\r\n                endBoardIndex\r\n            );\r\n            // If dupicated bid count is included (loseSBTAmount != 0), bidCount is increased by 1.\r\n            // When both auctionEndPriceWinnerSBTAmount and loseSBTAmount are no-zero value,\r\n            // the end info bid has two components(a winner bid side & a loser bid side).\r\n            // If endInfo bid is frauded in calcBillAndCheckLoserBids L269, revert here. So there needs not check sender==bidder.\r\n            require(\r\n                winnerBids.length.div(2) + loserBids.length.div(2) ==\r\n                    bidCount +\r\n                        (\r\n                            (msg.sender == endBidder &&\r\n                                loseSBTAmount != 0 &&\r\n                                auctionEndPriceWinnerSBTAmount != 0)\r\n                                ? 1\r\n                                : 0\r\n                        ),\r\n                \"must submit all of your bids\"\r\n            );\r\n        }\r\n\r\n        uint64 winnerAmount = calcWinnerAmount(\r\n            auctionID,\r\n            msg.sender,\r\n            winnerBids\r\n        );\r\n\r\n        uint64 toPay;\r\n        TimeControlFlag timeFlag = getTimeControlFlag(auctionID);\r\n\r\n        if (timeFlag == RECEIVING_SBT_PERIOD_FLAG) {\r\n            toPay = calcBillAndCheckLoserBids(\r\n                auctionID,\r\n                msg.sender,\r\n                winnerAmount,\r\n                myLowestPrice,\r\n                loserBids\r\n            );\r\n        } else {\r\n            require(\r\n                timeFlag > RECEIVING_SBT_PERIOD_FLAG,\r\n                \"has not been the receiving period yet\"\r\n            );\r\n            toPay = calcBillAndCheckLoserBids(\r\n                auctionID,\r\n                msg.sender,\r\n                winnerAmount,\r\n                SKIP_RECEIVING_WIN_BIDS,\r\n                loserBids\r\n            );\r\n        }\r\n\r\n        // IDOLAmountOfChange = max(auctionLockedIDOLAmountE8 - toPay, 0)\r\n        if (toPay > auctionLockedIDOLAmountE8) {\r\n            // assertion to prevent from the worst case that accumulate to certain amount by rounding up of toPay.\r\n            require(\r\n                toPay.sub(auctionLockedIDOLAmountE8) < 10**8,\r\n                \"system error: does not ignore too big error for spam protection\"\r\n            );\r\n            toPay = auctionLockedIDOLAmountE8;\r\n        }\r\n        uint64 IDOLAmountOfChange = auctionLockedIDOLAmountE8 - toPay;\r\n\r\n        _auctionBoardContract.deleteParticipantInfo(auctionID, msg.sender);\r\n        _transferIDOL(msg.sender, IDOLAmountOfChange);\r\n\r\n        _auctionBoardContract.updateAuctionInfo(\r\n            auctionID,\r\n            0,\r\n            toPay,\r\n            winnerAmount\r\n        );\r\n        _distributeToWinners(auctionID, winnerAmount);\r\n\r\n        emit LogAuctionResult(\r\n            auctionID,\r\n            msg.sender,\r\n            winnerAmount,\r\n            toPay,\r\n            IDOLAmountOfChange\r\n        );\r\n\r\n        return (winnerAmount, toPay, IDOLAmountOfChange);\r\n    }\r\n\r\n    /**\r\n     * @notice Close the auction when it is done. If some part of SBTs remain unsold, the auction is held again.\r\n     */\r\n    function closeAuction(bytes32 auctionID)\r\n        public\r\n        override\r\n        returns (bool, bytes32)\r\n    {\r\n        (uint64 auctionSettledTotalE8, , ) = _auctionBoardContract.auctionInfo(\r\n            auctionID\r\n        );\r\n        require(\r\n            isInPeriod(auctionID, AFTER_AUCTION_FLAG),\r\n            \"This function is not allowed to execute in this period\"\r\n        );\r\n\r\n        uint64 ongoingAuctionSBTTotal = _auctionConfigList[auctionID]\r\n            .ongoingAuctionSBTTotalE8;\r\n        require(ongoingAuctionSBTTotal != 0, \"already closed\");\r\n        bytes32 bondID = auctionID2BondID[auctionID];\r\n\r\n        {\r\n            (, , bool isEndInfoCreated, , ) = _auctionBoardContract\r\n                .auctionDisposalInfo(auctionID);\r\n            require(isEndInfoCreated, \"has not set end info\");\r\n        }\r\n\r\n        _forceToFinalizeWinnerAmount(auctionID);\r\n\r\n        uint256 nextAuctionAmount = ongoingAuctionSBTTotal.sub(\r\n            auctionSettledTotalE8,\r\n            \"allocated SBT amount for auction never becomes lower than reward total\"\r\n        );\r\n\r\n        bool isLast = nextAuctionAmount == 0;\r\n        _publishSettledAverageAuctionPrice(auctionID, isLast);\r\n\r\n        bytes32 nextAuctionID = bytes32(0);\r\n        if (isLast) {\r\n            // closeAuction adds 10**8 to _bondIDAuctionCount[bondID] and resets beta count\r\n            // when all SBT of the auction is sold out.\r\n            _bondIDAuctionCount[bondID] = _bondIDAuctionCount[bondID]\r\n                .div(POOL_AUCTION_COUNT_PADDING)\r\n                .add(1)\r\n                .mul(POOL_AUCTION_COUNT_PADDING);\r\n        } else {\r\n            // When the SBT is not sold out in the auction, restart a new one until all the SBT is successfully sold.\r\n            nextAuctionID = _startAuction(\r\n                bondID,\r\n                nextAuctionAmount.toUint64(),\r\n                true\r\n            );\r\n        }\r\n        delete _auctionConfigList[auctionID].ongoingAuctionSBTTotalE8;\r\n\r\n        emit LogCloseAuction(auctionID, isLast, nextAuctionID);\r\n\r\n        return (isLast, nextAuctionID);\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns SBT amount and iDOL amount (as its change) settled for those who didn't reveal bids.\r\n     */\r\n    function _calcUnrevealedBidDistribution(\r\n        uint64 ongoingAmount,\r\n        uint64 totalIDOLAmountUnrevealed,\r\n        uint64 totalSBTAmountPaidForUnrevealed,\r\n        uint64 solidStrikePriceIDOL,\r\n        uint64 IDOLAmountDeposited\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint64 receivingSBTAmount, uint64 returnedIDOLAmount)\r\n    {\r\n        // (total target) - (total revealed) = (total unrevealed)\r\n        uint64 totalSBTAmountUnrevealed = totalIDOLAmountUnrevealed\r\n            .mul(10**8)\r\n            .div(solidStrikePriceIDOL, \"system error: Oracle has a problem\")\r\n            .toUint64();\r\n\r\n        // min((total unrevealed), ongoing) - (total paid already) = (total deposit for punishment)\r\n        uint64 totalLeftSBTAmountForUnrevealed = uint256(\r\n            totalSBTAmountUnrevealed\r\n        )\r\n            .min(ongoingAmount)\r\n            .sub(totalSBTAmountPaidForUnrevealed)\r\n            .toUint64();\r\n\r\n        // (receiving SBT amount) = min((bid amount), (total deposited))\r\n        uint256 expectedReceivingSBTAmount = IDOLAmountDeposited.mul(10**8).div(\r\n            solidStrikePriceIDOL,\r\n            \"system error: Oracle has a problem\"\r\n        );\r\n\r\n        // (returned iDOL amount) = (deposit amount) - (iDOL value of receiving SBT amount)\r\n        if (expectedReceivingSBTAmount <= totalLeftSBTAmountForUnrevealed) {\r\n            receivingSBTAmount = expectedReceivingSBTAmount.toUint64();\r\n            returnedIDOLAmount = 0;\r\n        } else if (totalLeftSBTAmountForUnrevealed == 0) {\r\n            receivingSBTAmount = 0;\r\n            returnedIDOLAmount = IDOLAmountDeposited;\r\n        } else {\r\n            receivingSBTAmount = totalLeftSBTAmountForUnrevealed;\r\n            returnedIDOLAmount = IDOLAmountDeposited\r\n                .sub(\r\n                totalLeftSBTAmountForUnrevealed\r\n                    .mul(solidStrikePriceIDOL)\r\n                    .divRoundUp(10**8)\r\n            )\r\n                .toUint64();\r\n        }\r\n\r\n        return (receivingSBTAmount, returnedIDOLAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer SBT for those who forget to reveal.\r\n     */\r\n    function receiveUnrevealedBidDistribution(bytes32 auctionID, bytes32 secret)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        (\r\n            uint64 solidStrikePriceIDOL,\r\n            ,\r\n            bool isEndInfoCreated,\r\n            ,\r\n\r\n        ) = _auctionBoardContract.auctionDisposalInfo(auctionID);\r\n        require(\r\n            isEndInfoCreated,\r\n            \"EndInfo hasn't been made. This Function has not been allowed yet.\"\r\n        );\r\n\r\n        (address secOwner, , uint64 IDOLAmountDeposited) = _auctionBoardContract\r\n            .auctionSecret(auctionID, secret);\r\n        require(secOwner == msg.sender, \"ownership of the bid is required\");\r\n\r\n        (\r\n            ,\r\n            uint64 totalIDOLSecret,\r\n            uint64 totalIDOLAmountRevealed,\r\n\r\n        ) = _auctionBoardContract.auctionRevealInfo(auctionID);\r\n        uint64 totalIDOLAmountUnrevealed = totalIDOLSecret\r\n            .sub(totalIDOLAmountRevealed)\r\n            .toUint64();\r\n\r\n        uint64 receivingSBTAmount;\r\n        uint64 returnedIDOLAmount;\r\n        uint64 totalSBTAmountPaidForUnrevealed;\r\n        {\r\n            AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n            totalSBTAmountPaidForUnrevealed = auctionConfig\r\n                .totalSBTAmountPaidForUnrevealedE8;\r\n\r\n            (\r\n                receivingSBTAmount,\r\n                returnedIDOLAmount\r\n            ) = _calcUnrevealedBidDistribution(\r\n                auctionConfig.ongoingAuctionSBTTotalE8,\r\n                totalIDOLAmountUnrevealed,\r\n                totalSBTAmountPaidForUnrevealed,\r\n                solidStrikePriceIDOL,\r\n                IDOLAmountDeposited\r\n            );\r\n        }\r\n\r\n        _auctionConfigList[auctionID]\r\n            .totalSBTAmountPaidForUnrevealedE8 = totalSBTAmountPaidForUnrevealed\r\n            .add(receivingSBTAmount)\r\n            .toUint64();\r\n        _auctionBoardContract.removeSecret(auctionID, secret, 0);\r\n\r\n        // Transfer the winning SBT and (if necessary) return the rest of deposited iDOL.\r\n        _distributeToWinners(auctionID, receivingSBTAmount);\r\n        _IDOLContract.transfer(secOwner, returnedIDOLAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel the bid of your own within the bid acceptance period.\r\n     */\r\n    function cancelBid(bytes32 auctionID, bytes32 secret)\r\n        public\r\n        override\r\n        returns (uint64)\r\n    {\r\n        require(\r\n            isInPeriod(auctionID, ACCEPTING_BIDS_PERIOD_FLAG),\r\n            \"it is not the time to accept bids\"\r\n        );\r\n        (address owner, , uint64 IDOLamount) = _auctionBoardContract\r\n            .auctionSecret(auctionID, secret);\r\n        require(owner == msg.sender, \"you are not the bidder for the secret\");\r\n        _auctionBoardContract.removeSecret(auctionID, secret, IDOLamount);\r\n        _transferIDOL(\r\n            owner,\r\n            IDOLamount,\r\n            \"system error: try to cancel bid, but cannot return iDOL\"\r\n        );\r\n\r\n        emit LogCancelBid(auctionID, owner, secret, IDOLamount);\r\n\r\n        return IDOLamount;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current auction ID.\r\n     */\r\n    function getCurrentAuctionID(bytes32 bondID)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        uint256 count = _bondIDAuctionCount[bondID];\r\n        return generateAuctionID(bondID, count);\r\n    }\r\n\r\n    /**\r\n     * @notice Generates auction ID from bond ID and the count of auctions for the bond.\r\n     */\r\n    function generateAuctionID(bytes32 bondID, uint256 count)\r\n        public\r\n        override\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(bondID, count));\r\n    }\r\n\r\n    /**\r\n     * @dev The bidder succeeds in winning the SBT for the auctionID with receivingBondAmount, and pays IDOL with billingIDOLAmount.\r\n     */\r\n    function _distributeToWinners(bytes32 auctionID, uint64 receivingBondAmount)\r\n        internal\r\n        returns (uint64)\r\n    {\r\n        // Get the address of SBT contract.\r\n        (address solidBondAddress, , , ) = _getBondFromAuctionID(auctionID);\r\n        require(solidBondAddress != address(0), \"the bond is not registered\");\r\n\r\n        // Transfer the winning SBT.\r\n        BondTokenInterface solidBondContract = BondTokenInterface(\r\n            payable(solidBondAddress)\r\n        );\r\n        solidBondContract.transfer(msg.sender, receivingBondAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev When isLast is true, the SBTs put up in the auction are sold entirely.\r\n     * The average auction price is used for deciding the amount of IDOL to return from the lock pool.\r\n     */\r\n    function _publishSettledAverageAuctionPrice(bytes32 auctionID, bool isLast)\r\n        internal\r\n    {\r\n        bytes32 bondID = auctionID2BondID[auctionID];\r\n        (\r\n            ,\r\n            uint64 auctionRewardedTotalE8,\r\n            uint64 auctionPaidTotalE8\r\n        ) = _auctionBoardContract.auctionInfo(auctionID);\r\n\r\n        // The auction contract actually do not burn iDOL. Paid iDOL will be transferred and burned in the stable coin contract.\r\n        _transferIDOL(\r\n            address(_IDOLContract),\r\n            auctionPaidTotalE8,\r\n            \"system error: cannot transfer iDOL from auction contract to iDOL contract\"\r\n        );\r\n\r\n        _IDOLContract.setSettledAverageAuctionPrice(\r\n            bondID,\r\n            auctionPaidTotalE8,\r\n            auctionRewardedTotalE8,\r\n            isLast\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev How much IDOL to burn is decided by the settlement price.\r\n     * Hence, this contract needs to decide the price within some specified period.\r\n     */\r\n    function _forceToFinalizeWinnerAmount(bytes32 auctionID) internal {\r\n        (\r\n            uint64 auctionSettledTotalE8,\r\n            uint64 auctionRewardedTotalE8,\r\n\r\n        ) = _auctionBoardContract.auctionInfo(auctionID);\r\n\r\n        if (_auctionBoardContract.getSortedBidPrice(auctionID).length == 0) {\r\n            return;\r\n        }\r\n\r\n        (uint256 burnIDOLRate, , , ) = _auctionBoardContract.getEndInfo(\r\n            auctionID\r\n        );\r\n\r\n        uint256 _totalSBTForRestWinners = auctionSettledTotalE8.sub(\r\n            auctionRewardedTotalE8,\r\n            \"system error: allocated SBT amount for auction never becomes lower than reward total at any point\"\r\n        );\r\n\r\n        uint256 burnIDOL = _totalSBTForRestWinners.mul(burnIDOLRate).div(10**8);\r\n\r\n        _auctionBoardContract.updateAuctionInfo(\r\n            auctionID,\r\n            _totalSBTForRestWinners.toUint64(),\r\n            burnIDOL.toUint64(),\r\n            _totalSBTForRestWinners.toUint64()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the bond information corresponding to the auction ID.\r\n     */\r\n    function _getBondFromAuctionID(bytes32 auctionID)\r\n        internal\r\n        view\r\n        returns (\r\n            address erc20Address,\r\n            uint256 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        )\r\n    {\r\n        bytes32 bondID = auctionID2BondID[auctionID];\r\n        return _bondMakerContract.getBond(bondID);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the bond IDs corresponding to the auction IDs respectively.\r\n     */\r\n    function listBondIDFromAuctionID(bytes32[] memory auctionIDs)\r\n        public\r\n        override\r\n        view\r\n        returns (bytes32[] memory bondIDs)\r\n    {\r\n        bondIDs = new bytes32[](auctionIDs.length);\r\n        for (uint256 i = 0; i < auctionIDs.length; i++) {\r\n            bondIDs[i] = auctionID2BondID[auctionIDs[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the auction status.\r\n     * @param auctionID is a auction ID.\r\n     * @return closingTime is .\r\n     * @return auctionAmount is the SBT amount put up in the auction.\r\n     * @return rewardedAmount is .\r\n     * @return totalSBTAmountBid is .\r\n     * @return isEmergency is .\r\n     * @return doneFinalizeWinnerAmount is .\r\n     * @return doneSortPrice is .\r\n     * @return lowestBidPriceDeadLine is the minimum bid price in the auction.\r\n     * @return highestBidPriceDeadLine is the maximum bid price in the auction.\r\n     * @return totalSBTAmountPaidForUnrevealed is the SBT Amount allocated for those who had not revealed their own bid.\r\n     */\r\n    function getAuctionStatus(bytes32 auctionID)\r\n        public\r\n        override\r\n        view\r\n        returns (\r\n            uint256 closingTime,\r\n            uint64 auctionAmount,\r\n            uint64 rewardedAmount,\r\n            uint64 totalSBTAmountBid,\r\n            bool isEmergency,\r\n            bool doneFinalizeWinnerAmount,\r\n            bool doneSortPrice,\r\n            uint64 lowestBidPriceDeadLine,\r\n            uint64 highestBidPriceDeadLine,\r\n            uint64 totalSBTAmountPaidForUnrevealed\r\n        )\r\n    {\r\n        closingTime = auctionClosingTime[auctionID].toUint64();\r\n        AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n        auctionAmount = auctionConfig.ongoingAuctionSBTTotalE8;\r\n        lowestBidPriceDeadLine = auctionConfig.lowestBidPriceDeadLineE8;\r\n        highestBidPriceDeadLine = auctionConfig.highestBidPriceDeadLineE8;\r\n        totalSBTAmountPaidForUnrevealed = auctionConfig\r\n            .totalSBTAmountPaidForUnrevealedE8;\r\n        (, rewardedAmount, ) = _auctionBoardContract.auctionInfo(auctionID);\r\n        (totalSBTAmountBid, , , ) = _auctionBoardContract.auctionRevealInfo(\r\n            auctionID\r\n        );\r\n        isEmergency = isAuctionEmergency[auctionID];\r\n        (, , , doneFinalizeWinnerAmount, doneSortPrice) = _auctionBoardContract\r\n            .auctionDisposalInfo(auctionID);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the status of auctions which is held in the week.\r\n     * @param weekNumber is the quotient obtained by dividing the timestamp by 7 * 24 * 60 * 60 (= 7 days).\r\n     */\r\n    function getWeeklyAuctionStatus(uint256 weekNumber)\r\n        external\r\n        override\r\n        view\r\n        returns (uint256[] memory weeklyAuctionStatus)\r\n    {\r\n        bytes32[] memory auctions = listAuction(weekNumber);\r\n        weeklyAuctionStatus = new uint256[](auctions.length.mul(6));\r\n        for (uint256 i = 0; i < auctions.length; i++) {\r\n            (\r\n                uint256 closingTime,\r\n                uint64 auctionAmount,\r\n                uint64 rewardedAmount,\r\n                uint64 totalSBTAmountBid,\r\n                bool isEmergency,\r\n                bool doneFinalizeWinnerAmount,\r\n                bool doneSortPrice,\r\n                ,\r\n                ,\r\n\r\n            ) = getAuctionStatus(auctions[i]);\r\n            uint8 auctionStatusCode = (isEmergency ? 1 : 0) << 2;\r\n            auctionStatusCode += (doneFinalizeWinnerAmount ? 1 : 0) << 1;\r\n            auctionStatusCode += doneSortPrice ? 1 : 0;\r\n            weeklyAuctionStatus[i * 6] = closingTime;\r\n            weeklyAuctionStatus[i * 6 + 1] = auctionAmount;\r\n            weeklyAuctionStatus[i * 6 + 2] = rewardedAmount;\r\n            weeklyAuctionStatus[i * 6 + 3] = totalSBTAmountBid;\r\n            weeklyAuctionStatus[i * 6 + 4] = auctionStatusCode;\r\n            weeklyAuctionStatus[i * 6 + 5] = uint256(auctions[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns total SBT amount put up in the auction.\r\n     */\r\n    function ongoingAuctionSBTTotal(bytes32 auctionID)\r\n        external\r\n        override\r\n        view\r\n        returns (uint64 ongoingSBTAmountE8)\r\n    {\r\n        AuctionConfig memory auctionConfig = _auctionConfigList[auctionID];\r\n        return auctionConfig.ongoingAuctionSBTTotalE8;\r\n    }\r\n\r\n    function getAuctionCount(bytes32 bondID)\r\n        external\r\n        override\r\n        view\r\n        returns (uint256 auctionCount)\r\n    {\r\n        return _bondIDAuctionCount[bondID];\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bondMakerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"IDOLAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"auctionBoardAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minNormalAuctionPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEmergencyAuctionPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"normalAuctionRevealSpan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyAuctionRevealSpan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionWithdrawSpan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyAuctionWithdrawSpan\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"SBTAmountOfReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"IDOLAmountOfPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"IDOLAmountOfChange\",\"type\":\"uint256\"}],\"name\":\"LogAuctionResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnedIDOLAmount\",\"type\":\"uint256\"}],\"name\":\"LogCancelBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLast\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nextAuctionID\",\"type\":\"bytes32\"}],\"name\":\"LogCloseAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionedAmount\",\"type\":\"uint256\"}],\"name\":\"LogStartAuction\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"auctionClosingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"auctionID2BondID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"winnerAmountInput\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"myLowestPrice\",\"type\":\"uint64\"},{\"internalType\":\"uint64[]\",\"name\":\"myLoseBids\",\"type\":\"uint64[]\"}],\"name\":\"calcBillAndCheckLoserBids\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64[]\",\"name\":\"winnerBids\",\"type\":\"uint64[]\"}],\"name\":\"calcWinnerAmount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"cancelBid\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"}],\"name\":\"closeAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"generateAuctionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"getAuctionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"}],\"name\":\"getAuctionStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"auctionAmount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"rewardedAmount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"totalSBTAmountBid\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isEmergency\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"doneFinalizeWinnerAmount\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"doneSortPrice\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"lowestBidPriceDeadLine\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"highestBidPriceDeadLine\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"totalSBTAmountPaidForUnrevealed\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"}],\"name\":\"getCurrentAuctionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"}],\"name\":\"getTimeControlFlag\",\"outputs\":[{\"internalType\":\"enum AuctionTimeControlInterface.TimeControlFlag\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weekNumber\",\"type\":\"uint256\"}],\"name\":\"getWeeklyAuctionStatus\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"weeklyAuctionStatus\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"enum AuctionTimeControlInterface.TimeControlFlag\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"isAfterPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isAuctionEmergency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"enum AuctionTimeControlInterface.TimeControlFlag\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"isInPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weekNumber\",\"type\":\"uint256\"}],\"name\":\"listAuction\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"auctionIDs\",\"type\":\"bytes32[]\"}],\"name\":\"listBondIDFromAuctionID\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"bondIDs\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"myLowestPrice\",\"type\":\"uint64\"},{\"internalType\":\"uint64[]\",\"name\":\"winnerBids\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64[]\",\"name\":\"loserBids\",\"type\":\"uint64[]\"}],\"name\":\"makeAuctionResult\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"}],\"name\":\"ongoingAuctionSBTTotal\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"ongoingSBTAmountE8\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"receiveUnrevealedBidDistribution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bondID\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"auctionAmount\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isEmergency\",\"type\":\"bool\"}],\"name\":\"startAuction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Auction","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"0000000000000000000000008b24f5c764ab741bc8a2426505bda458c30df0100000000000000000000000007591a309df68bf43ba42dd11b0344220a260020a0000000000000000000000000f454bc375ab377e5f593fb3855580f1fded8d4000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000e10","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c83357f0ea467a1e31ccd3b6ff624b636dfd81931c4c42bef58ed98ae73bcda0"}]}