{"status":"1","message":"OK","result":[{"SourceCode":"{\"mmmglobalgroup.sol\":{\"content\":\"pragma solidity ^0.5.16;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./token.sol\\\";\\r\\n\\r\\ncontract mmmglobalgroup {\\r\\n    address payable public creator;\\r\\n    address payable public clsmad;\\r\\n    uint256 public deployTime;\\r\\n    PAXImplementation token;\\r\\n    address public tokenAdd;\\r\\n    address public lastContractAddress;\\r\\n    uint256 public AcVerAmt;\\r\\n    using SafeMath for uint256;\\r\\n    address _TempPHOC;\\r\\n    address public MINSC;\\r\\n    address _TempInsAdr;\\r\\n    \\r\\n    constructor(address paxkey, address payable owner, address payable smad) public{\\r\\n        token = PAXImplementation(paxkey);\\r\\n        deployTime = now;\\r\\n        tokenAdd = paxkey;\\r\\n        creator = owner;\\r\\n        clsmad = smad;\\r\\n        AcVerAmt = 1000000000000000;\\r\\n    }\\r\\n        mapping (address =\\u003e uint256) public ubalances;\\r\\n        mapping (uint256 =\\u003e uint256) public phOrders;\\r\\n        mapping (uint256 =\\u003e uint256) public ghOrders;\\r\\n        mapping (uint256 =\\u003e uint256) public InsOrders;\\r\\n\\r\\n        PHcontracts[] public PHDB;\\r\\n        struct PHcontracts{\\r\\n            uint256 createtime;\\r\\n            uint256 oid;\\r\\n            address phcontractadd;\\r\\n            address phregisteredUserAdd;\\r\\n            uint256 phamt;\\r\\n        }\\r\\n\\r\\n        GHorders[] public GHDB;\\r\\n        struct GHorders{\\r\\n            uint256 createtime;\\r\\n            uint256 ghoid;\\r\\n            uint256 ghamount;\\r\\n            address ghUserAdd;\\r\\n        }\\r\\n        \\r\\n        InsContracts[] public INSDB;\\r\\n        struct InsContracts{\\r\\n            uint256 InsCreatetime;\\r\\n            uint256 InsOid;\\r\\n            address InsContract;\\r\\n            address RegUadr;\\r\\n            uint256 InsAmount;\\r\\n        }\\r\\n\\r\\n        event EthTransferred(\\r\\n            string Crypto, \\r\\n            uint256 Amt);\\r\\n            \\r\\n        event GHD(\\r\\n            string TransType, \\r\\n            uint256 Amount);\\r\\n        \\r\\n        event NewPHOCcreated(\\r\\n            address _phcontractadd, \\r\\n            address indexed registeredUserAdd\\r\\n        );\\r\\n        event NewInsContract(\\r\\n            address _contractadd, \\r\\n            address indexed _userAddress\\r\\n        );\\r\\n\\r\\n        modifier OnM() {\\r\\n            require(msg.sender == creator, \\\"You\\u0027re not creator\\\");\\r\\n            _;\\r\\n        }\\r\\n        modifier OnlClsam() {\\r\\n            require(msg.sender == clsmad, \\\"You\\u0027re not authorized\\\");\\r\\n            _;\\r\\n        }\\r\\n\\r\\n        function upVerAm(uint256 _AcVerAmt) public OnM{\\r\\n    \\t    AcVerAmt = _AcVerAmt;\\r\\n    \\t}\\r\\n    \\tfunction upClsm(address payable newclsm) public OnM{\\r\\n    \\t    clsmad = newclsm;\\r\\n    \\t}\\r\\n    \\r\\n    \\tfunction ValidateUser(address uad) public view OnlClsam returns(bool){\\r\\n    \\t    uint256 ubal = ubalances[uad];\\r\\n            if (ubal \\u003e= AcVerAmt){\\r\\n                return true;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        function () external payable{\\r\\n            ubalances[msg.sender] += msg.value;\\r\\n        }\\r\\n\\r\\n        function ethbal() public view returns (uint256){\\r\\n            return address(this).balance;\\r\\n        }\\r\\n        function ethbalOf(address adr) public view OnM returns (uint256){\\r\\n            return adr.balance;\\r\\n        }\\r\\n        function withdrawEth() public OnM{\\r\\n            msg.sender.transfer(address(this).balance);\\r\\n            emit EthTransferred(\\\"ETH\\\", address(this).balance);\\r\\n        }\\r\\n        function VerUsrMapEth(address uad) public view OnM returns(uint256 bal){\\r\\n            bal = ubalances[uad];\\r\\n            return bal;\\r\\n        }\\r\\n        function TokenBal() public view returns (uint256){\\r\\n            return token.balanceOf(address(this));\\r\\n        }\\r\\n        function TokenBalOf(address _uadr) public view OnM returns (uint256){\\r\\n            return token.balanceOf(_uadr);\\r\\n        }\\r\\n        \\r\\n        function GeneratePHO(address UAdd, uint256 phamout, uint256 phoid) public OnM payable returns(address newPHOC) \\r\\n    \\t{\\r\\n    \\t\\tphsubcontract p = (new phsubcontract).value(msg.value)(tokenAdd, creator, address(this) , UAdd);\\r\\n    \\t\\t\\r\\n    \\t\\t_TempPHOC = address(p);\\r\\n    \\t\\t\\r\\n    \\t\\tPHDB.push(PHcontracts({\\r\\n    \\t\\t    createtime: now,\\r\\n    \\t\\t    oid: phoid,\\r\\n                phcontractadd: _TempPHOC,\\r\\n                phregisteredUserAdd: UAdd,\\r\\n                phamt: phamout\\r\\n            }));\\r\\n            \\r\\n            phOrders[phoid] = PHDB.length - 1;\\r\\n    \\t\\tlastContractAddress = address(p);\\r\\n            emit NewPHOCcreated (\\r\\n                _TempPHOC,\\r\\n                UAdd\\r\\n            );\\r\\n    \\t\\treturn address(p);\\r\\n    \\t}\\r\\n    \\r\\n        function getPHOCcnt() public view OnM returns(uint phContractCount){\\r\\n    \\t\\tphContractCount = PHDB.length;\\r\\n    \\t    return phContractCount;\\r\\n        }\\r\\n\\r\\n        function getPHDBindx(uint256 phordid) public view OnM returns(uint phdindx){\\r\\n    \\t    phdindx = phOrders[phordid];\\r\\n    \\t\\treturn phdindx;\\r\\n        }\\r\\n\\r\\n    \\tfunction get_PHOC(uint ai) public view OnM returns(uint256 phoctime, uint256 ordid, address PHOCadr, address uaddress, uint256 amount)\\r\\n    \\t{\\r\\n    \\t    if((PHDB.length) \\u003e ai){\\r\\n        \\t    phoctime = PHDB[ai].createtime;\\r\\n        \\t    ordid = PHDB[ai].oid;\\r\\n        \\t    PHOCadr = PHDB[ai].phcontractadd;\\r\\n        \\t    uaddress =  PHDB[ai].phregisteredUserAdd;\\r\\n        \\t    amount = PHDB[ai].phamt;\\r\\n            }\\r\\n            else{\\r\\n                phoctime = 0;\\r\\n        \\t    ordid = 0;\\r\\n        \\t    PHOCadr = creator;\\r\\n        \\t    uaddress = creator;\\r\\n        \\t    amount = 0;\\r\\n            }\\r\\n    \\t    return(phoctime,ordid,PHOCadr,uaddress,amount);\\r\\n    \\t}\\r\\n\\r\\n        function GHengine(address uadr, uint256 ghtok, uint256 GHOID) public OnM{\\r\\n            require(token.balanceOf(address(this)) \\u003e= ghtok);\\r\\n            token.transfer(uadr, ghtok);\\r\\n            \\r\\n            GHDB.push(GHorders({\\r\\n                createtime: now,\\r\\n                ghoid: GHOID,\\r\\n                ghamount : ghtok,\\r\\n                ghUserAdd : uadr\\r\\n            }));\\r\\n            ghOrders[GHOID] = GHDB.length - 1;\\r\\n            emit GHD(\\\"Get Help\\\", ghtok);\\r\\n        }\\r\\n    \\r\\n        function getGHOCcnt() public view OnM returns(uint){\\r\\n    \\t\\treturn GHDB.length;\\r\\n        }\\r\\n\\t\\t\\r\\n        function getGHDBindx(uint256 ghordid) public view OnM returns(uint ghindx){\\r\\n    \\t    ghindx = ghOrders[ghordid];\\r\\n    \\t\\treturn ghindx;\\r\\n    \\t}\\r\\n\\r\\n    \\tfunction get_GHOC(uint ai) public view OnM returns(uint256 ghoctime, uint256 ghordid, uint256 ghamount,address ghuaddress)\\r\\n    \\t{\\r\\n    \\t    if((GHDB.length) \\u003e ai)\\r\\n            {\\r\\n        \\t    ghoctime = GHDB[ai].createtime;\\r\\n        \\t    ghordid = GHDB[ai].ghoid;\\r\\n        \\t    ghamount = GHDB[ai].ghamount;\\r\\n        \\t    ghuaddress =  GHDB[ai].ghUserAdd;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                ghoctime = 0;\\r\\n                ghordid = 0;\\r\\n        \\t    ghamount = 0; \\r\\n        \\t    ghuaddress = creator;\\r\\n            }\\r\\n    \\t    return(ghoctime,ghordid,ghamount,ghuaddress);\\r\\n    \\t}\\r\\n\\r\\n        function generateInsuranceOrder(address userAddress, uint256 insoid, uint256 InsAmt) public OnM payable returns(bool) \\r\\n    \\t{\\r\\n    \\t\\tinsurancesub c = (new insurancesub).value(msg.value)(tokenAdd, creator, MINSC, userAddress);\\r\\n    \\t\\t_TempInsAdr = address(c);\\r\\n    \\t\\t\\r\\n    \\t\\tINSDB.push(InsContracts({\\r\\n    \\t\\t    InsCreatetime: now,\\r\\n    \\t\\t    InsOid: insoid,\\r\\n                InsContract: _TempInsAdr,\\r\\n                RegUadr : userAddress,\\r\\n                InsAmount: InsAmt\\r\\n            }));\\r\\n            \\r\\n            //PUSH MAPPING FOR INS OID TO =\\u003e ARRAY POSITION\\r\\n            InsOrders[insoid] = INSDB.length - 1;\\r\\n    \\t\\tlastContractAddress = _TempInsAdr;\\r\\n            emit NewInsContract (\\r\\n                _TempInsAdr,\\r\\n                userAddress);\\r\\n    \\t\\treturn true;\\r\\n    \\t}\\r\\n\\r\\n        function getINSOCcnt() public view OnM returns(uint InsCount){\\r\\n    \\t\\treturn INSDB.length;\\r\\n    \\t}\\r\\n\\r\\n    \\tfunction getMINSC() public view OnM returns(address){\\r\\n    \\t\\treturn MINSC;\\r\\n    \\t}\\r\\n        function getINSDBindx(uint256 insordid) public view OnM returns(uint insindx){\\r\\n    \\t    insindx = InsOrders[insordid];\\r\\n    \\t\\treturn insindx;\\r\\n    \\t}\\r\\n    \\tfunction get_INSOC(uint ai) public view OnM returns(uint256 insoctime, uint256 insordid, address INSOCadr, address uaddress, uint256 insamount)\\r\\n    \\t{\\r\\n    \\t    if((INSDB.length) \\u003e ai)\\r\\n            {\\r\\n        \\t    insoctime = INSDB[ai].InsCreatetime;\\r\\n        \\t    insordid = INSDB[ai].InsOid;\\r\\n        \\t    INSOCadr = INSDB[ai].InsContract;\\r\\n        \\t    uaddress =  INSDB[ai].RegUadr;\\r\\n        \\t    insamount = INSDB[ai].InsAmount;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                insoctime = 0;\\r\\n        \\t    insordid = 0;\\r\\n        \\t    INSOCadr = creator;\\r\\n        \\t    uaddress = creator;\\r\\n        \\t    insamount = 0;\\r\\n            }\\r\\n    \\t    return(insoctime,insordid,INSOCadr,uaddress,insamount);\\r\\n    \\t}\\r\\n        function addInsC(address Iadr) public OnM{\\r\\n            MINSC = Iadr;\\r\\n        }\\r\\n}\\r\\n\\r\\ncontract phsubcontract {\\r\\n    constructor(address _token, address owner_adr, address Mcontract, address _userAddress) public payable{\\r\\n      ParentConractAdd = Mcontract;\\r\\n      owner = owner_adr;\\r\\n      tokenAdr = _token;\\r\\n      userAdd = _userAddress;\\r\\n      token = PAXImplementation(tokenAdr);\\r\\n      phoc_creator = msg.sender;\\r\\n    }\\r\\n    address payable phoc_creator;\\r\\n    address public owner;\\r\\n    address public ParentConractAdd;\\r\\n    address public userAdd;\\r\\n    address public tokenAdr;\\r\\n    PAXImplementation token;\\r\\n\\r\\n    mapping (address =\\u003e uint256) public balances;\\r\\n    \\r\\n    modifier OnlyOwn() {\\r\\n        require(msg.sender == owner, \\\"You\\u0027re not the owner of contract\\\");\\r\\n        _;}\\r\\n    function () external payable {\\r\\n        balances[msg.sender] += msg.value;\\r\\n    }\\r\\n    function witalltok() public OnlyOwn {\\r\\n        token.transfer(ParentConractAdd, token.balanceOf(address(this)));\\r\\n    }\\r\\n    function witalleth() public OnlyOwn{\\r\\n        msg.sender.transfer(address(this).balance);\\r\\n    }\\r\\n    function getTOKbal() public view returns (uint256){\\r\\n       return token.balanceOf(address(this));\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract insurancesub {\\r\\n    constructor( address tokenkey, address _InsCreator, address _InsCo, address _UsrAdr) public payable{\\r\\n      MinsAdd = _InsCo;\\r\\n      owner = _InsCreator;\\r\\n      tokenAd = tokenkey;\\r\\n      userAdd = _UsrAdr;\\r\\n      token = PAXImplementation(tokenAd);\\r\\n      DOwns = msg.sender;\\r\\n    }\\r\\n    address public owner;\\r\\n    address public MinsAdd;\\r\\n    address public userAdd;\\r\\n    address public tokenAd;\\r\\n    PAXImplementation token;\\r\\n    address payable DOwns;\\r\\n    \\r\\n    mapping (address =\\u003e uint256) public balances;\\r\\n\\r\\n    modifier OnM(){\\r\\n        require(msg.sender == owner, \\\"You are not the owner.\\\");\\r\\n        _;}\\r\\n    function() external payable {\\r\\n        balances[msg.sender] += msg.value;\\r\\n    }\\r\\n    function witalltok() public OnM{\\r\\n        token.transfer(MinsAdd, token.balanceOf(address(this)));\\r\\n    }\\r\\n    function witalleth() public OnM{\\r\\n        msg.sender.transfer(address(this).balance);\\r\\n    }\\r\\n    function getTOKbal() public view returns (uint256){\\r\\n       return token.balanceOf(address(this));\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.16;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Unsigned math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\r\\n     * reverts when dividing by zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"token.sol\":{\"content\":\"pragma solidity ^0.5.16;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title PAXImplementation\\r\\n * @dev this contract is a Pausable ERC20 token with Burn and Mint\\r\\n * controleld by a central SupplyController. By implementing PaxosImplementation\\r\\n * this contract also includes external methods for setting\\r\\n * a new implementation contract for the Proxy.\\r\\n * NOTE: The storage defined here will actually be held in the Proxy\\r\\n * contract and all calls to this contract should be made through\\r\\n * the proxy, including admin actions done as owner or supplyController.\\r\\n * Any call to transfer against this contract should fail\\r\\n * with insufficient funds since no tokens will be issued there.\\r\\n */\\r\\n \\r\\n \\r\\ncontract PAXImplementation {\\r\\n\\r\\n    /**\\r\\n     * MATH\\r\\n     */\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * DATA\\r\\n     */\\r\\n\\r\\n    // INITIALIZATION DATA\\r\\n    bool private initialized = false;\\r\\n\\r\\n    // ERC20 BASIC DATA\\r\\n    mapping(address =\\u003e uint256) internal balances;\\r\\n    uint256 internal totalSupply_;\\r\\n    string public constant name = \\\"PAX\\\"; // solium-disable-line uppercase\\r\\n    string public constant symbol = \\\"PAX\\\"; // solium-disable-line uppercase\\r\\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\\r\\n\\r\\n    // ERC20 DATA\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\r\\n\\r\\n    // OWNER DATA\\r\\n    address public owner;\\r\\n\\r\\n    // PAUSABILITY DATA\\r\\n    bool public paused = false;\\r\\n\\r\\n    // LAW ENFORCEMENT DATA\\r\\n    address public lawEnforcementRole;\\r\\n    mapping(address =\\u003e bool) internal frozen;\\r\\n\\r\\n    // SUPPLY CONTROL DATA\\r\\n    address public supplyController;\\r\\n\\r\\n    /**\\r\\n     * EVENTS\\r\\n     */\\r\\n\\r\\n    // ERC20 BASIC EVENTS\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    // ERC20 EVENTS\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    // OWNABLE EVENTS\\r\\n    event OwnershipTransferred(\\r\\n        address indexed oldOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    // PAUSABLE EVENTS\\r\\n    event Pause();\\r\\n    event Unpause();\\r\\n\\r\\n    // LAW ENFORCEMENT EVENTS\\r\\n    event AddressFrozen(address indexed addr);\\r\\n    event AddressUnfrozen(address indexed addr);\\r\\n    event FrozenAddressWiped(address indexed addr);\\r\\n    event LawEnforcementRoleSet (\\r\\n        address indexed oldLawEnforcementRole,\\r\\n        address indexed newLawEnforcementRole\\r\\n    );\\r\\n\\r\\n    // SUPPLY CONTROL EVENTS\\r\\n    event SupplyIncreased(address indexed to, uint256 value);\\r\\n    event SupplyDecreased(address indexed from, uint256 value);\\r\\n    event SupplyControllerSet(\\r\\n        address indexed oldSupplyController,\\r\\n        address indexed newSupplyController\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * FUNCTIONALITY\\r\\n     */\\r\\n\\r\\n    // INITIALIZATION FUNCTIONALITY\\r\\n\\r\\n    /**\\r\\n     * @dev sets 0 initials tokens, the owner, and the supplyController.\\r\\n     * this serves as the constructor for the proxy but compiles to the\\r\\n     * memory model of the Implementation contract.\\r\\n     */\\r\\n    function initialize() public {\\r\\n        require(!initialized, \\\"already initialized\\\");\\r\\n        owner = msg.sender;\\r\\n        lawEnforcementRole = address(0);\\r\\n        totalSupply_ = 0;\\r\\n        supplyController = msg.sender;\\r\\n        initialized = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * The constructor is used here to ensure that the implementation\\r\\n     * contract is initialized. An uncontrolled implementation\\r\\n     * contract might lead to misleading state\\r\\n     * for users who accidentally interact with it.\\r\\n     */\\r\\n    constructor() public {\\r\\n        initialize();\\r\\n        pause();\\r\\n    }\\r\\n\\r\\n    // ERC20 BASIC FUNCTIONALITY\\r\\n\\r\\n    /**\\r\\n    * @dev Total number of tokens in existence\\r\\n    */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return totalSupply_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Transfer token for a specified address\\r\\n    * @param _to The address to transfer to.\\r\\n    * @param _value The amount to be transferred.\\r\\n    */\\r\\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\\r\\n        require(_to != address(0), \\\"cannot transfer to address zero\\\");\\r\\n        require(!frozen[_to] \\u0026\\u0026 !frozen[msg.sender], \\\"address frozen\\\");\\r\\n        require(_value \\u003c= balances[msg.sender], \\\"insufficient funds\\\");\\r\\n\\r\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        emit Transfer(msg.sender, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Gets the balance of the specified address.\\r\\n    * @param _addr The address to query the the balance of.\\r\\n    * @return An uint256 representing the amount owned by the passed address.\\r\\n    */\\r\\n    function balanceOf(address _addr) public view returns (uint256) {\\r\\n        return balances[_addr];\\r\\n    }\\r\\n\\r\\n    // ERC20 FUNCTIONALITY\\r\\n\\r\\n    /**\\r\\n     * @dev Transfer tokens from one address to another\\r\\n     * @param _from address The address which you want to send tokens from\\r\\n     * @param _to address The address which you want to transfer to\\r\\n     * @param _value uint256 the amount of tokens to be transferred\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    )\\r\\n    public\\r\\n    whenNotPaused\\r\\n    returns (bool)\\r\\n    {\\r\\n        require(_to != address(0), \\\"cannot transfer to address zero\\\");\\r\\n        require(!frozen[_to] \\u0026\\u0026 !frozen[_from] \\u0026\\u0026 !frozen[msg.sender], \\\"address frozen\\\");\\r\\n        require(_value \\u003c= balances[_from], \\\"insufficient funds\\\");\\r\\n        require(_value \\u003c= allowed[_from][msg.sender], \\\"insufficient allowance\\\");\\r\\n\\r\\n        balances[_from] = balances[_from].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\r\\n        emit Transfer(_from, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\r\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\r\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\r\\n     * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     * @param _spender The address which will spend the funds.\\r\\n     * @param _value The amount of tokens to be spent.\\r\\n     */\\r\\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\\r\\n        require(!frozen[_spender] \\u0026\\u0026 !frozen[msg.sender], \\\"address frozen\\\");\\r\\n        allowed[msg.sender][_spender] = _value;\\r\\n        emit Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\r\\n     * @param _owner address The address which owns the funds.\\r\\n     * @param _spender address The address which will spend the funds.\\r\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\r\\n     */\\r\\n    function allowance(\\r\\n        address _owner,\\r\\n        address _spender\\r\\n    )\\r\\n    public\\r\\n    view\\r\\n    returns (uint256)\\r\\n    {\\r\\n        return allowed[_owner][_spender];\\r\\n    }\\r\\n\\r\\n    // OWNER FUNCTIONALITY\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"onlyOwner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n     * @param _newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address _newOwner) public onlyOwner {\\r\\n        require(_newOwner != address(0), \\\"cannot transfer ownership to address zero\\\");\\r\\n        emit OwnershipTransferred(owner, _newOwner);\\r\\n        owner = _newOwner;\\r\\n    }\\r\\n\\r\\n    // PAUSABILITY FUNCTIONALITY\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        require(!paused, \\\"whenNotPaused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev called by the owner to pause, triggers stopped state\\r\\n     */\\r\\n    function pause() public onlyOwner {\\r\\n        require(!paused, \\\"already paused\\\");\\r\\n        paused = true;\\r\\n        emit Pause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev called by the owner to unpause, returns to normal state\\r\\n     */\\r\\n    function unpause() public onlyOwner {\\r\\n        require(paused, \\\"already unpaused\\\");\\r\\n        paused = false;\\r\\n        emit Unpause();\\r\\n    }\\r\\n\\r\\n    // LAW ENFORCEMENT FUNCTIONALITY\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a new law enforcement role address.\\r\\n     * @param _newLawEnforcementRole The new address allowed to freeze/unfreeze addresses and seize their tokens.\\r\\n     */\\r\\n    function setLawEnforcementRole(address _newLawEnforcementRole) public {\\r\\n        require(msg.sender == lawEnforcementRole || msg.sender == owner, \\\"only lawEnforcementRole or Owner\\\");\\r\\n        emit LawEnforcementRoleSet(lawEnforcementRole, _newLawEnforcementRole);\\r\\n        lawEnforcementRole = _newLawEnforcementRole;\\r\\n    }\\r\\n\\r\\n    modifier onlyLawEnforcementRole() {\\r\\n        require(msg.sender == lawEnforcementRole, \\\"onlyLawEnforcementRole\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Freezes an address balance from being transferred.\\r\\n     * @param _addr The new address to freeze.\\r\\n     */\\r\\n    function freeze(address _addr) public onlyLawEnforcementRole {\\r\\n        require(!frozen[_addr], \\\"address already frozen\\\");\\r\\n        frozen[_addr] = true;\\r\\n        emit AddressFrozen(_addr);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Unfreezes an address balance allowing transfer.\\r\\n     * @param _addr The new address to unfreeze.\\r\\n     */\\r\\n    function unfreeze(address _addr) public onlyLawEnforcementRole {\\r\\n        require(frozen[_addr], \\\"address already unfrozen\\\");\\r\\n        frozen[_addr] = false;\\r\\n        emit AddressUnfrozen(_addr);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Wipes the balance of a frozen address, burning the tokens\\r\\n     * and setting the approval to zero.\\r\\n     * @param _addr The new frozen address to wipe.\\r\\n     */\\r\\n    function wipeFrozenAddress(address _addr) public onlyLawEnforcementRole {\\r\\n        require(frozen[_addr], \\\"address is not frozen\\\");\\r\\n        uint256 _balance = balances[_addr];\\r\\n        balances[_addr] = 0;\\r\\n        totalSupply_ = totalSupply_.sub(_balance);\\r\\n        emit FrozenAddressWiped(_addr);\\r\\n        emit SupplyDecreased(_addr, _balance);\\r\\n        emit Transfer(_addr, address(0), _balance);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Gets the balance of the specified address.\\r\\n    * @param _addr The address to check if frozen.\\r\\n    * @return A bool representing whether the given address is frozen.\\r\\n    */\\r\\n    function isFrozen(address _addr) public view returns (bool) {\\r\\n        return frozen[_addr];\\r\\n    }\\r\\n\\r\\n    // SUPPLY CONTROL FUNCTIONALITY\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a new supply controller address.\\r\\n     * @param _newSupplyController The address allowed to burn/mint tokens to control supply.\\r\\n     */\\r\\n    function setSupplyController(address _newSupplyController) public {\\r\\n        require(msg.sender == supplyController || msg.sender == owner, \\\"only SupplyController or Owner\\\");\\r\\n        require(_newSupplyController != address(0), \\\"cannot set supply controller to address zero\\\");\\r\\n        emit SupplyControllerSet(supplyController, _newSupplyController);\\r\\n        supplyController = _newSupplyController;\\r\\n    }\\r\\n\\r\\n    modifier onlySupplyController() {\\r\\n        require(msg.sender == supplyController, \\\"onlySupplyController\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Increases the total supply by minting the specified number of tokens to the supply controller account.\\r\\n     * @param _value The number of tokens to add.\\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function increaseSupply(uint256 _value) public onlySupplyController returns (bool success) {\\r\\n        totalSupply_ = totalSupply_.add(_value);\\r\\n        balances[supplyController] = balances[supplyController].add(_value);\\r\\n        emit SupplyIncreased(supplyController, _value);\\r\\n        emit Transfer(address(0), supplyController, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Decreases the total supply by burning the specified number of tokens from the supply controller account.\\r\\n     * @param _value The number of tokens to remove.\\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function decreaseSupply(uint256 _value) public onlySupplyController returns (bool success) {\\r\\n        require(_value \\u003c= balances[supplyController], \\\"not enough supply\\\");\\r\\n        balances[supplyController] = balances[supplyController].sub(_value);\\r\\n        totalSupply_ = totalSupply_.sub(_value);\\r\\n        emit SupplyDecreased(supplyController, _value);\\r\\n        emit Transfer(supplyController, address(0), _value);\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"paxkey\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"smad\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"Crypto\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amt\",\"type\":\"uint256\"}],\"name\":\"EthTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"TransType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"GHD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contractadd\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"NewInsContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_phcontractadd\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"registeredUserAdd\",\"type\":\"address\"}],\"name\":\"NewPHOCcreated\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"AcVerAmt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"GHDB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"createtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ghoid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ghamount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ghUserAdd\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"uadr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ghtok\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"GHOID\",\"type\":\"uint256\"}],\"name\":\"GHengine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"UAdd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"phamout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"phoid\",\"type\":\"uint256\"}],\"name\":\"GeneratePHO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newPHOC\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"INSDB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"InsCreatetime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"InsOid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"InsContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"RegUadr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"InsAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"InsOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINSC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PHDB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"createtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"phcontractadd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"phregisteredUserAdd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"phamt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TokenBal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uadr\",\"type\":\"address\"}],\"name\":\"TokenBalOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"uad\",\"type\":\"address\"}],\"name\":\"ValidateUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"uad\",\"type\":\"address\"}],\"name\":\"VerUsrMapEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"Iadr\",\"type\":\"address\"}],\"name\":\"addInsC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"clsmad\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethbal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"ethbalOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"insoid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"InsAmt\",\"type\":\"uint256\"}],\"name\":\"generateInsuranceOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ghordid\",\"type\":\"uint256\"}],\"name\":\"getGHDBindx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ghindx\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGHOCcnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"insordid\",\"type\":\"uint256\"}],\"name\":\"getINSDBindx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"insindx\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getINSOCcnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"InsCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMINSC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phordid\",\"type\":\"uint256\"}],\"name\":\"getPHDBindx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"phdindx\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPHOCcnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"phContractCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ai\",\"type\":\"uint256\"}],\"name\":\"get_GHOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ghoctime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ghordid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ghamount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ghuaddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ai\",\"type\":\"uint256\"}],\"name\":\"get_INSOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"insoctime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"insordid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"INSOCadr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"insamount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ai\",\"type\":\"uint256\"}],\"name\":\"get_PHOC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"phoctime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ordid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"PHOCadr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ghOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAdd\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ubalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newclsm\",\"type\":\"address\"}],\"name\":\"upClsm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_AcVerAmt\",\"type\":\"uint256\"}],\"name\":\"upVerAm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"mmmglobalgroup","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008e870d67f660d95d5be530380d0ec0bd388289e1000000000000000000000000fbeae28fc336bc2d15a7cf731820ccb8cdf4705c000000000000000000000000bafef136f05cd12137fa7c0728ee5dab2e7f072f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8966b1541eee1465c2068785ba11d588f4ef26f060e346a5b871c418c1204df9"}]}