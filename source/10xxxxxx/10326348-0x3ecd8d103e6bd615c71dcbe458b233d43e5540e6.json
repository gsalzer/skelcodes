{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-06-24\r\n*/\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract MultiSigInterface{\r\n  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);\r\n  function is_signer(address addr) public view returns(bool);\r\n}\r\n\r\ncontract MultiSigTools{\r\n  MultiSigInterface public multisig_contract;\r\n  constructor(address _contract) public{\r\n    require(_contract!= address(0x0));\r\n    multisig_contract = MultiSigInterface(_contract);\r\n  }\r\n\r\n  modifier only_signer{\r\n    require(multisig_contract.is_signer(msg.sender), \"only a signer can call in MultiSigTools\");\r\n    _;\r\n  }\r\n\r\n  modifier is_majority_sig(uint64 id, string memory name) {\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\r\n      _;\r\n    }\r\n  }\r\n\r\n  event TransferMultiSig(address _old, address _new);\r\n\r\n  function transfer_multisig(uint64 id, address _contract) public only_signer\r\n  is_majority_sig(id, \"transfer_multisig\"){\r\n    require(_contract != address(0x0));\r\n    address old = address(multisig_contract);\r\n    multisig_contract = MultiSigInterface(_contract);\r\n    emit TransferMultiSig(old, _contract);\r\n  }\r\n}\r\n\r\ncontract TransferableToken{\r\n    function balanceOf(address _owner) public returns (uint256 balance) ;\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) ;\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) ;\r\n}\r\n\r\n\r\ncontract TokenClaimer{\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n  function _claimStdTokens(address _token, address payable to) internal {\r\n        if (_token == address(0x0)) {\r\n            to.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        TransferableToken token = TransferableToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n\r\n        (bool status,) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, balance));\r\n        require(status, \"call failed\");\r\n        emit ClaimedTokens(_token, to, balance);\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"add\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"sub\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"mul\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"div\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract SimpleMultiSigVote is MultiSigTools, TokenClaimer{\r\n\r\n  struct InternalData{\r\n    bool exist;\r\n    bool determined;\r\n    uint start_height;\r\n    uint end_height;\r\n    address owner;\r\n    string announcement;\r\n    string value;\r\n    uint64 vote_id;\r\n  }\r\n\r\n  mapping (bytes32 => InternalData) public vote_status;\r\n  uint public determined_vote_number;\r\n  uint public created_vote_number;\r\n\r\n  constructor(address _multisig) MultiSigTools(_multisig) public{\r\n    determined_vote_number = 0;\r\n    created_vote_number = 0;\r\n  }\r\n\r\n  event VoteCreate(bytes32 _hash, uint _start_height, uint _end_height);\r\n  event VoteChange(bytes32 _hash, uint _start_height, uint _end_height, string announcement);\r\n  event VotePass(bytes32 _hash, string _value);\r\n\r\n  modifier vote_exist(bytes32 _hash){\r\n    require(vote_status[_hash].exist, \"vote not exist\");\r\n    _;\r\n  }\r\n\r\n  function createVote(bytes32 _hash, uint _start_height, uint _end_height)\r\n    public\r\n    returns (bool){\r\n    require(!vote_status[_hash].exist, \"already exist\");\r\n    require(_end_height > block.number, \"end height too small\");\r\n    require(_end_height > _start_height, \"end height should be greater than start height\");\r\n    if(_start_height == 0){\r\n      _start_height = block.number;\r\n    }\r\n    InternalData storage d = vote_status[_hash];\r\n\r\n    d.exist = true;\r\n    d.determined = false;\r\n    d.start_height = _start_height;\r\n    d.end_height = _end_height;\r\n    d.owner = msg.sender;\r\n    d.vote_id = 0;\r\n    created_vote_number += 1;\r\n    emit VoteCreate(_hash, _start_height, _end_height);\r\n    return true;\r\n  }\r\n\r\n  function changeVoteInfo(bytes32 _hash, uint _start_height, uint _end_height, string memory announcement) public\r\n    vote_exist(_hash)\r\n    returns (bool){\r\n    InternalData storage d = vote_status[_hash];\r\n    require(d.owner == msg.sender, \"only creator can change vote info\");\r\n\r\n    if(_end_height != 0){\r\n      require(_end_height > block.number, \"end height too small\");\r\n      d.end_height = _end_height;\r\n    }\r\n    require(d.start_height > block.number, \"already start, cannot change start height\");\r\n    if(_start_height != 0){\r\n      require(_start_height >= block.number, \"start block too small\");\r\n      d.start_height = _start_height;\r\n    }\r\n\r\n    require(d.end_height > d.start_height, \"end height should be greater than start height\");\r\n\r\n    d.announcement = announcement;\r\n    emit VoteChange(_hash, _start_height, _end_height, announcement);\r\n    return true;\r\n  }\r\n  function vote_internal(uint64 id, bytes32 _hash, string memory _value) private\r\n    vote_exist(_hash)\r\n    only_signer\r\n    is_majority_sig(id, \"vote\")\r\n    returns (bool){\r\n    InternalData storage d = vote_status[_hash];\r\n    require(d.start_height <= block.number, \"vote not start yet\");\r\n    require(d.end_height >= block.number, \"vote already end\");\r\n\r\n    d.value = _value;\r\n    d.determined = true;\r\n    emit VotePass(_hash, _value);\r\n    determined_vote_number += 1;\r\n    return true;\r\n  }\r\n\r\n  function vote(uint64 id, bytes32 _hash, string memory _value) public\r\n    returns (bool){\r\n    InternalData storage d = vote_status[_hash];\r\n    require(d.start_height <= block.number, \"vote not start yet\");\r\n    require(d.end_height >= block.number, \"vote already end\");\r\n\r\n    uint64 tid = id;\r\n    if(d.vote_id == 0){\r\n      d.vote_id = id;\r\n    }else{\r\n      tid = d.vote_id;\r\n    }\r\n    return vote_internal(tid, _hash, _value);\r\n  }\r\n\r\n  function isVoteDetermined(bytes32 _hash) public view returns (bool){\r\n    return vote_status[_hash].determined;\r\n  }\r\n\r\n  function checkVoteValue(bytes32 _hash) public view returns(string memory value){\r\n    require(vote_status[_hash].exist, \"not exist\");\r\n    require(vote_status[_hash].determined, \"not determined\");\r\n\r\n    value = vote_status[_hash].value;\r\n  }\r\n\r\n  function voteInfo(bytes32 _hash) public\r\n  vote_exist(_hash)\r\n  view returns(bool determined, uint start_height, uint end_height, address owner, string memory announcement, string memory value){\r\n\r\n    InternalData storage d = vote_status[_hash];\r\n    return (d.determined, d.start_height, d.end_height, d.owner, d.announcement, d.value);\r\n  }\r\n\r\n  function claimStdTokens(uint64 id, address _token, address payable to) public only_signer is_majority_sig(id, \"claimStdTokens\"){\r\n    _claimStdTokens(_token, to);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimStdTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"transfer_multisig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"isVoteDetermined\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"vote_status\",\"outputs\":[{\"name\":\"exist\",\"type\":\"bool\"},{\"name\":\"determined\",\"type\":\"bool\"},{\"name\":\"start_height\",\"type\":\"uint256\"},{\"name\":\"end_height\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"announcement\",\"type\":\"string\"},{\"name\":\"value\",\"type\":\"string\"},{\"name\":\"vote_id\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"determined_vote_number\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"created_vote_number\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_start_height\",\"type\":\"uint256\"},{\"name\":\"_end_height\",\"type\":\"uint256\"}],\"name\":\"createVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"voteInfo\",\"outputs\":[{\"name\":\"determined\",\"type\":\"bool\"},{\"name\":\"start_height\",\"type\":\"uint256\"},{\"name\":\"end_height\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"announcement\",\"type\":\"string\"},{\"name\":\"value\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"checkVoteValue\",\"outputs\":[{\"name\":\"value\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_start_height\",\"type\":\"uint256\"},{\"name\":\"_end_height\",\"type\":\"uint256\"},{\"name\":\"announcement\",\"type\":\"string\"}],\"name\":\"changeVoteInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_multisig\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_start_height\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_end_height\",\"type\":\"uint256\"}],\"name\":\"VoteCreate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_start_height\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_end_height\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"announcement\",\"type\":\"string\"}],\"name\":\"VoteChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"VotePass\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"TransferMultiSig\",\"type\":\"event\"}]","ContractName":"SimpleMultiSigVote","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000086880095c6a4dccef7e8dbdb8a864d417a37b7ea","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9597f197d129cecce592f4fde9fd8e225869e0f3be5bfc1143db656520d0a643"}]}