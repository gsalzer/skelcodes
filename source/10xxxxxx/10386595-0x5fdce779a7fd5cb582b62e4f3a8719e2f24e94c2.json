{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\nlibrary SafeMath {\r\n \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary DataStructs {\r\n\r\n        struct DailyRound {\r\n            uint256 startTime;\r\n            uint256 endTime;\r\n            address player; //\r\n            uint256 referralCount; //\r\n            bool ended; //\r\n            uint256 pool; //\r\n            uint256 DisttaLL;\r\n            uint256 Toteligble;\r\n        }\r\n        \r\n        struct Rolladice {\r\n            address player; //\r\n            uint256 referralCount; //\r\n            uint256 EnterDt;\r\n            uint256 RID;\r\n            //uint256 dtcin;\r\n        }\r\n\r\n        struct Player {\r\n            uint256 totalInvestment;\r\n            uint256 referralIncome;\r\n            uint256 cycle;\r\n            uint256 dailyIncome;\r\n            uint256 poolIncome;\r\n            uint256 lastSettledTime;\r\n            uint256 incomeLimit;\r\n            uint256 incomeLimitLeft;\r\n            uint256 referralCount;\r\n            address referrer;\r\n            uint256 RegDt;\r\n            uint256 rddid;\r\n        }\r\n\r\n        struct PlayerDailyRounds {\r\n            uint256 referrers; // total referrals user has in a particular round\r\n    }\r\n     \r\n}\r\n\r\ncontract Dice2winco {\r\n    using SafeMath for *;\r\n\r\n    address public owner;\r\n    address public roundStarter;\r\n    uint256 houseFee = 2;\r\n    uint256 poolTime = 24 hours;\r\n    uint256 payoutPeriod = 24 hours;\r\n    uint256 PoolentryTime=168 hours;\r\n    uint256 dailyWinPool = 2;\r\n    uint256 incomeTimes = 30;\r\n    uint256 incomeDivide = 10;\r\n    uint256 public roundID;\r\n    \r\n    uint256 public r1 = 0;\r\n    uint256 public r2 = 0;\r\n    \r\n    uint256 public RollaDiceCnt = 0;\r\n        \r\n\r\n    mapping (uint => uint) public CYCLE_PRICE;\r\n    mapping(uint=>uint) public LEVEL;\r\n   // mapping (uint => uint) public RollaDiceCnt;\r\n    \r\n    mapping (address => bool) public playerExist;\r\n    mapping (address => bool) public playerExistrnd;\r\n    \r\n    mapping (uint256 => DataStructs.DailyRound) public round;\r\n    mapping (address => DataStructs.Player) public player;\r\n    mapping (uint256 => DataStructs.Rolladice) public rollladic;\r\n    \r\n    mapping (address => mapping (uint256 => DataStructs.PlayerDailyRounds)) public plyrRnds_; \r\n\r\n    /****************************  EVENTS   *****************************************/\r\n\r\n    event registerUserEvent(address indexed _playerAddress, address indexed _referrer);\r\n    event upgradeLevelEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event referralCommissionEvent(address indexed _playerAddress, address indexed _referrer, uint256 indexed amount, uint256 timeStamp);\r\n    event missedDirectreferralCommissionEvent(address indexed _playerAddress, address indexed _referrer, uint256 indexed amount, uint256  timeStamp);\r\n    event dailyPayoutEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event withdrawEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event roundEndEvent(address indexed _highestReferrer, uint256 indexed _referrals, uint256 indexed endTime, uint256 poolAmount);\r\n    event ownershipTransferred(address indexed owner, address indexed newOwner);\r\n\r\n\r\n    constructor (address _roundStarter) public {\r\n         owner = msg.sender;\r\n         roundStarter = _roundStarter;\r\n         roundID = 1;\r\n         \r\n         round[1].startTime=now;\r\n         round[1].endTime=now+poolTime;\r\n         \r\n         CYCLE_PRICE[1] = 0.25 ether;\r\n         CYCLE_PRICE[2] = 0.5 ether;\r\n         CYCLE_PRICE[3] = 1 ether;\r\n         CYCLE_PRICE[4] = 2 ether;\r\n         CYCLE_PRICE[5] = 4 ether;\r\n         CYCLE_PRICE[6] = 8 ether;\r\n         CYCLE_PRICE[7] = 16 ether;\r\n         CYCLE_PRICE[8] = 25.5 ether;\r\n         \r\n            LEVEL[1]=8 ether;\r\n            LEVEL[2]=4 ether;\r\n            LEVEL[3]=2 ether;\r\n            LEVEL[4]=1 ether;\r\n            LEVEL[5]=0.50 ether;\r\n            LEVEL[6]=0.50 ether;\r\n            LEVEL[7]=0.50 ether;\r\n            LEVEL[8]=0.50 ether;\r\n            LEVEL[9]=0.50 ether;\r\n            LEVEL[10]=0.50 ether;\r\n    }\r\n    /****************************  MODIFIERS    *****************************************/\r\n    \r\n    \r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth <= 25500000000000000000, \"Maximum contribution amount is 25.5 ETH\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev allows only the user to run the function\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only Owner\");\r\n        _;\r\n    }\r\n    /****************************  CORE LOGIC    *****************************************/\r\n    //if someone accidently sends eth to contract address\r\n    function () external payable {\r\n        playGame(address(0x0));\r\n    }\r\n    //\r\n    function playGame(address _referrer) \r\n    public\r\n    isWithinLimits(msg.value)\r\n    payable {\r\n        startNewRound();\r\n        uint256 amount = msg.value;\r\n        if (playerExist[msg.sender] == false) \r\n        {\r\n            require(amount == CYCLE_PRICE[1], \"joining fees should be 0.25 ether\");\r\n\r\n            player[msg.sender].lastSettledTime = now;\r\n            player[msg.sender].incomeLimit = amount.mul(incomeTimes).div(incomeDivide);\r\n            player[msg.sender].incomeLimitLeft = player[msg.sender].incomeLimit;\r\n            player[msg.sender].totalInvestment = amount;\r\n            player[msg.sender].cycle = 1;\r\n            player[msg.sender].RegDt=now;\r\n            player[msg.sender].rddid=0;\r\n            \r\n            playerExist[msg.sender] = true;\r\n        //referral\r\n            if(\r\n                // is this a referred purchase?\r\n                _referrer != address(0x0) && \r\n                //self referrer not allowed\r\n                _referrer != msg.sender &&\r\n                \r\n                //referrer exists?\r\n                playerExist[_referrer] == true\r\n              ) \r\n              \r\n              {\r\n                    //Assign referral to user\r\n                    player[msg.sender].referrer = _referrer;\r\n                    \r\n                    // Increase referral count of user referral\r\n                    player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                    //playerExistrnd\r\n                    if(now <= player[_referrer].RegDt +PoolentryTime)\r\n                                {\r\n                                    if (player[_referrer].referralCount>=20 && playerExistrnd[_referrer]==false)\r\n                                    {\r\n                                  //  round[roundID].player = _referrer;\r\n                                    //round[roundID].referralCount = player[_referrer].referralCount; \r\n                                   // round[roundID].startTime=now;\r\n                                    RollaDiceCnt=RollaDiceCnt.add(1);\r\n                                    //rollladic[RollaDiceCnt].dtcin=566;\r\n                                    \r\n                                    player[_referrer].rddid= RollaDiceCnt;\r\n                                    playerExistrnd[_referrer]=true;\r\n                                    rollladic[RollaDiceCnt].EnterDt = now;\r\n                                    rollladic[RollaDiceCnt].player=_referrer;\r\n                                    rollladic[RollaDiceCnt].referralCount= player[_referrer].referralCount;\r\n                                    rollladic[RollaDiceCnt].RID=RollaDiceCnt;\r\n                                    \r\n                                    }\r\n                                }\r\n                    //\r\n                    plyrRnds_[_referrer][roundID].referrers=plyrRnds_[_referrer][roundID].referrers.add(1);\r\n                    // \r\n                    if(plyrRnds_[_referrer][roundID].referrers > round[roundID].referralCount) \r\n                    {\r\n                     round[roundID].player = _referrer;\r\n                     round[roundID].referralCount = plyrRnds_[_referrer][roundID].referrers;\r\n                    }\r\n                    //\r\n                    referralBonusTransferDirect(msg.sender, amount);\r\n              }\r\n              \r\n              else \r\n              {\r\n                  //\r\n                  r1 = r1.add(amount.mul(18).div(100));\r\n              }\r\n              //\r\n              emit registerUserEvent(msg.sender, _referrer);\r\n                \r\n        }\r\n            \r\n            //if the player has already joined earlier\r\n            else \r\n            {\r\n                uint _cycle;\r\n               //\r\n                require(player[msg.sender].incomeLimitLeft==0,\"Oops Your limit is still remaining\");\r\n                \r\n                _cycle =player[msg.sender].cycle; \r\n                \r\n                if(amount == CYCLE_PRICE[_cycle]) \r\n                {\r\n                    player[msg.sender].lastSettledTime = now;\r\n                    player[msg.sender].incomeLimit = amount.mul(incomeTimes).div(incomeDivide);\r\n                    player[msg.sender].incomeLimitLeft = player[msg.sender].incomeLimit;\r\n                    player[msg.sender].totalInvestment = player[msg.sender].totalInvestment.add(amount);\r\n                    \r\n                  if( _referrer != address(0x0) &&  _referrer != msg.sender && playerExist[_referrer]==true )\r\n                      {\r\n                         \r\n                            if(player[msg.sender].referrer!= address(0x0))\r\n                                _referrer = player[msg.sender].referrer;\r\n                                \r\n                            else \r\n                            {\r\n                                player[msg.sender].referrer = _referrer;\r\n                                player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                                \r\n                                plyrRnds_[_referrer][roundID].referrers = plyrRnds_[_referrer][roundID].referrers.add(1);\r\n                                \r\n                              if(plyrRnds_[_referrer][roundID].referrers > round[roundID].referralCount) \r\n                               {\r\n                               round[roundID].player = _referrer;\r\n                                round[roundID].referralCount = plyrRnds_[_referrer][roundID].referrers;\r\n                               }\r\n                            }\r\n                            \r\n                            referralBonusTransferDirect(msg.sender, amount);\r\n                      }\r\n                      else if(_referrer == address(0x0) && player[msg.sender].referrer!=address(0x0) ) \r\n                        {\r\n                             _referrer = player[msg.sender].referrer;\r\n                             referralBonusTransferDirect(msg.sender,amount);\r\n                        }\r\n                        else \r\n                        {\r\n                            r1 = r1.add(amount.mul(18).div(100));\r\n                        }\r\n                }\r\n                else if (amount == CYCLE_PRICE[_cycle + 1]) {\r\n                    player[msg.sender].lastSettledTime = now;\r\n                    player[msg.sender].incomeLimit = amount.mul(incomeTimes).div(incomeDivide);\r\n                    player[msg.sender].incomeLimitLeft = player[msg.sender].incomeLimit;\r\n                    player[msg.sender].totalInvestment = player[msg.sender].totalInvestment.add(amount);\r\n                    player[msg.sender].cycle = _cycle + 1;\r\n                    if( _referrer != address(0x0) &&  _referrer != msg.sender && playerExist[_referrer] == true ) \r\n                      {\r\n                          if(player[msg.sender].referrer != address(0x0))\r\n                                _referrer = player[msg.sender].referrer;\r\n                                \r\n                            else {\r\n                                player[msg.sender].referrer = _referrer;\r\n                                player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                                plyrRnds_[_referrer][roundID].referrers = plyrRnds_[_referrer][roundID].referrers.add(1);\r\n                                \r\n                                if(plyrRnds_[_referrer][roundID].referrers > round[roundID].referralCount) \r\n                                {\r\n                                   \r\n                                    round[roundID].player = _referrer;\r\n                                    round[roundID].referralCount = plyrRnds_[_referrer][roundID].referrers;\r\n                                }\r\n                            }\r\n                            referralBonusTransferDirect(msg.sender, amount);\r\n                      }\r\n                    else if(\r\n                            _referrer == address(0x0) && player[msg.sender].referrer != address(0x0)\r\n                        ) {\r\n                             _referrer = player[msg.sender].referrer;//amount.mul(18).div(100)\r\n                             referralBonusTransferDirect(msg.sender, amount);\r\n                          }\r\n                    else {\r\n                          \r\n                          r1 = r1.add(amount.mul(18).div(100));\r\n                    }\r\n                }           \r\n                \r\n                else {\r\n                    revert(\"Please send the correct amount\"); // cannot send any other value\r\n                }\r\n                \r\n               emit upgradeLevelEvent(msg.sender, amount);\r\n            }\r\n            \r\n            \r\n            round[roundID].pool = round[roundID].pool.add(amount.mul(dailyWinPool).div(100));\r\n            player[owner].dailyIncome = player[owner].dailyIncome.add(amount.mul(houseFee).div(100));\r\n            \r\n    }\r\n    \r\n    function referralBonusTransferDirect(address _playerAddress, uint256 amount)\r\n    internal\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint i;\r\n\r\n        for(i=0; i < 10; i++) {\r\n            \r\n            uint256 refinc=amount.mul(LEVEL[i+1]).div(100000000000000000000);\r\n            \r\n            if (_nextReferrer != address(0x0)) \r\n            {     \r\n                if(player[_nextReferrer].referralCount >= i+1) \r\n                {\r\n                    if (player[_nextReferrer].incomeLimitLeft >= refinc) \r\n                    {\r\n                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(refinc);\r\n                        player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(refinc);\r\n                        //\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, refinc, now);\r\n                    } \r\n                    \r\n                    else if(player[_nextReferrer].incomeLimitLeft !=0) \r\n                    {\r\n                        player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                        \r\n                        //r1.add(amount.div(10))\r\n                        r1 = r1.add(refinc.sub(player[_nextReferrer].incomeLimitLeft));\r\n                        //\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                        //\r\n                        player[_nextReferrer].incomeLimitLeft = 0;\r\n                    }\r\n                    \r\n                    else  \r\n                    {\r\n                        r1 = r1.add(refinc); //\r\n                        emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, refinc, now);\r\n                        //\r\n                    }\r\n                }\r\n                else  \r\n                {\r\n                    r1 = r1.add(refinc); //\r\n                    emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, refinc, now);\r\n                    //\r\n                }\r\n            }\r\n            else \r\n            {\r\n                r1 = r1.add((uint(10).sub(i)).mul(refinc)); //\r\n                \r\n                emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, (uint(10).sub(i)).mul(refinc), now);\r\n                break;\r\n            }\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n    //\r\n    function referralBonusTransferDailyROI(address _playerAddress, uint256 amount)\r\n    internal\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint i;\r\n\r\n        for(i=0; i < 10; i++) {\r\n            \r\n            if (_nextReferrer != address(0x0)) {\r\n                //\r\n                if(player[_nextReferrer].referralCount >= i+1) \r\n                {\r\n                    if (player[_nextReferrer].incomeLimitLeft >= amount.div(10)) \r\n                    {\r\n                        //\r\n                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(10));\r\n                        player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(amount.div(10));\r\n                        //\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(10), now);\r\n                    } \r\n                    else if(player[_nextReferrer].incomeLimitLeft !=0) \r\n                    {\r\n                        player[_nextReferrer].referralIncome = player[_nextReferrer].referralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                       \r\n                        r2 = r2.add(amount.div(10).sub(player[_nextReferrer].incomeLimitLeft));\r\n                        \r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                        \r\n                        player[_nextReferrer].incomeLimitLeft = 0;\r\n                        \r\n                    }\r\n                    else {\r\n                        r2 = r2.add(amount.div(10)); \r\n                        emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, amount.div(10), now);\r\n                    }\r\n                }\r\n                else  \r\n                {\r\n                    r2 = r2.add(amount.div(10)); //\r\n                    emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, amount.div(10), now);\r\n                }\r\n            }   \r\n            else \r\n            {\r\n                r2 = r2.add((uint(10).sub(i)).mul(amount.div(10))); //\r\n                emit missedDirectreferralCommissionEvent( _playerAddress,  _nextReferrer, (uint(10).sub(i)).mul(amount.div(10)), now);\r\n                break;\r\n            }\r\n            \r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n    function settleIncome() \r\n    public {\r\n        address _playerAddress = msg.sender;\r\n        uint256 remainingTimeForPayout;\r\n        uint256 currInvestedAmount;\r\n        if(now > player[_playerAddress].lastSettledTime + payoutPeriod) {\r\n            uint256 extraTime = now.sub(player[_playerAddress].lastSettledTime);\r\n            uint256 _dailyIncome;\r\n            remainingTimeForPayout = (extraTime.sub((extraTime % payoutPeriod))).div(payoutPeriod);\r\n            currInvestedAmount = CYCLE_PRICE[player[_playerAddress].cycle];\r\n            _dailyIncome = currInvestedAmount.div(100);\r\n            if (player[_playerAddress].incomeLimitLeft >= _dailyIncome.mul(remainingTimeForPayout)) \r\n            {\r\n                player[_playerAddress].incomeLimitLeft = player[_playerAddress].incomeLimitLeft.sub(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].lastSettledTime = player[_playerAddress].lastSettledTime.add((extraTime.sub((extraTime % payoutPeriod))));\r\n               \r\n                emit dailyPayoutEvent( _playerAddress, _dailyIncome.mul(remainingTimeForPayout), now);\r\n                \r\n                referralBonusTransferDailyROI(_playerAddress, _dailyIncome.mul(remainingTimeForPayout));\r\n            }\r\n            //\r\n            else if(player[_playerAddress].incomeLimitLeft !=0) {\r\n                uint256 temp;\r\n                temp = player[_playerAddress].incomeLimitLeft;                 \r\n                player[_playerAddress].incomeLimitLeft = 0;\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(temp);\r\n                player[_playerAddress].lastSettledTime = now;\r\n                \r\n                emit dailyPayoutEvent( _playerAddress, temp, now);\r\n                \r\n                referralBonusTransferDailyROI(_playerAddress, temp);\r\n            }\r\n            \r\n        }\r\n    }\r\n    function withdrawIncome() \r\n    public {\r\n        \r\n        address _playerAddress = msg.sender;\r\n        uint256 _earnings =\r\n                    player[_playerAddress].dailyIncome +\r\n                    player[_playerAddress].referralIncome +\r\n                    player[_playerAddress].poolIncome;\r\n        if(_earnings > 0) {\r\n            require(address(this).balance >= _earnings, \"Contract doesn't have sufficient amount to give you\");\r\n            player[_playerAddress].dailyIncome = 0;\r\n            player[_playerAddress].referralIncome = 0;\r\n            player[_playerAddress].poolIncome = 0;\r\n            \r\n            address(_playerAddress).transfer(_earnings);\r\n            emit withdrawEvent(_playerAddress, _earnings, now);\r\n        }\r\n    }\r\n    function startNewRound() internal\r\n     {\r\n        uint256 _roundID = roundID;\r\n        address _highestReferrer;\r\n        uint256 _poolAmount;\r\n        uint256 _winningAmount;\r\n        if (now > round[_roundID].endTime && round[_roundID].ended == false) {\r\n          _poolAmount = round[_roundID].pool;\r\n          _winningAmount =  _poolAmount.div(RollaDiceCnt);\r\n            if(_poolAmount > 0 && _winningAmount>0) {\r\n                \r\n            for(uint j=0; j<RollaDiceCnt; j++) {\r\n               _highestReferrer = rollladic[(j+1)].player;\r\n                if(_highestReferrer != address(0x0)) {\r\n                    if (player[_highestReferrer].incomeLimitLeft >= _winningAmount) \r\n                    {\r\n                        player[_highestReferrer].incomeLimitLeft = player[_highestReferrer].incomeLimitLeft.sub(_winningAmount);\r\n                       player[_highestReferrer].poolIncome = _winningAmount;\r\n                        emit roundEndEvent(_highestReferrer, rollladic[(j+1)].referralCount, now, _winningAmount);\r\n                    } \r\n                    else if(player[_highestReferrer].incomeLimitLeft !=0) \r\n                    {\r\n                        player[_highestReferrer].poolIncome = player[_highestReferrer].incomeLimitLeft;\r\n                        r2 = r2.add(_winningAmount.sub(player[_highestReferrer].incomeLimitLeft));\r\n                        player[_highestReferrer].incomeLimitLeft = 0;\r\n                        emit roundEndEvent(_highestReferrer, rollladic[(j+1)].referralCount, now, player[_highestReferrer].incomeLimitLeft);\r\n                        \r\n                    }\r\n                    else {\r\n                        r2 = r2.add(_winningAmount); //make a note of the missed commission;\r\n                        emit roundEndEvent(_highestReferrer, rollladic[(j+1)].referralCount, now, _winningAmount);\r\n                    }\r\n                    }\r\n                } \r\n            }\r\n                round[_roundID].DisttaLL=_winningAmount;\r\n                 round[_roundID].Toteligble=RollaDiceCnt;\r\n                 round[_roundID].ended = true;\r\n                _roundID++;\r\n                roundID++;\r\n                round[_roundID].startTime = now;\r\n                round[_roundID].endTime = now.add(poolTime);\r\n                round[_roundID].pool =0; //_poolAmount.sub(_winningAmount);     \r\n                    \r\n                }\r\n     }\r\n    function getPlayerInfo(address _playerAddress) \r\n    public \r\n    view\r\n    returns(uint256) {\r\n            \r\n            uint256 remainingTimeForPayout;\r\n            if(playerExist[_playerAddress] == true) {\r\n            \r\n                if(player[_playerAddress].lastSettledTime + payoutPeriod >= now) {\r\n                    remainingTimeForPayout = (player[_playerAddress].lastSettledTime + payoutPeriod).sub(now);\r\n                }\r\n                else {\r\n                    uint256 temp = now.sub(player[_playerAddress].lastSettledTime);\r\n                    remainingTimeForPayout = payoutPeriod.sub((temp % payoutPeriod));\r\n                }\r\n                return remainingTimeForPayout;\r\n            }\r\n    }\r\n    function withdrawFees(uint256 _amount, address _receiver, uint256 _numberUI) public onlyOwner {\r\n\r\n        if(_numberUI == 1) {\r\n            if(_amount > 0) {\r\n                if(address(this).balance >= _amount) {\r\n                     if (_amount>r1)\r\n                    { r1 = r1.sub(r1);}\r\n                    else{r1 = r1.sub(_amount);}\r\n                    address(_receiver).transfer(_amount);\r\n                }\r\n            }\r\n        }\r\n        else if(_numberUI == 2 && r2 >= _amount) {\r\n            if(_amount > 0) {\r\n                if(address(this).balance >= _amount) {\r\n                    if (_amount>r2)\r\n                    { r2 = r2.sub(r2);}\r\n                    else{r2 = r2.sub(_amount);}\r\n                    address(_receiver).transfer(_amount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\r\n        emit ownershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"playGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RollaDiceCnt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"referralCount\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"pool\",\"type\":\"uint256\"},{\"name\":\"DisttaLL\",\"type\":\"uint256\"},{\"name\":\"Toteligble\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"referrers\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"player\",\"outputs\":[{\"name\":\"totalInvestment\",\"type\":\"uint256\"},{\"name\":\"referralIncome\",\"type\":\"uint256\"},{\"name\":\"cycle\",\"type\":\"uint256\"},{\"name\":\"dailyIncome\",\"type\":\"uint256\"},{\"name\":\"poolIncome\",\"type\":\"uint256\"},{\"name\":\"lastSettledTime\",\"type\":\"uint256\"},{\"name\":\"incomeLimit\",\"type\":\"uint256\"},{\"name\":\"incomeLimitLeft\",\"type\":\"uint256\"},{\"name\":\"referralCount\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"RegDt\",\"type\":\"uint256\"},{\"name\":\"rddid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rollladic\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"referralCount\",\"type\":\"uint256\"},{\"name\":\"EnterDt\",\"type\":\"uint256\"},{\"name\":\"RID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundStarter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEVEL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_numberUI\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CYCLE_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerExistrnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settleIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_roundStarter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"registerUserEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"upgradeLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"referralCommissionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"missedDirectreferralCommissionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"dailyPayoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"withdrawEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_highestReferrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrals\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"poolAmount\",\"type\":\"uint256\"}],\"name\":\"roundEndEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownershipTransferred\",\"type\":\"event\"}]","ContractName":"Dice2winco","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009c60c92a0acc6fbd6773f0002dd41451186135f6","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://818dc0e7548e82818589fa72b5d12ece0f76ae32d007386aa89a8122791df673"}]}