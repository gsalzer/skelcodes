{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.26;\r\n\r\n interface IERC20 {\r\n   function totalSupply() external view returns(uint256);\r\n\r\n   function balanceOf(address account) external view returns(uint256);\r\n\r\n   function transfer(address recipient, uint256 amount) external returns(bool);\r\n\r\n   function allowance(address owner, address spender) external view returns(uint256);\r\n\r\n   function approve(address spender, uint256 amount) external returns(bool);\r\n\r\n   function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\r\n   event Transfer(address indexed from, address indexed to, uint256 value);\r\n   event Approval(address indexed owner, address indexed spender, uint256 value);\r\n }\r\n contract HexFomo {\r\n   modifier onlyBagholders() {\r\n     require(myTokens() > 0);\r\n     _;\r\n   }\r\n   modifier onlyStronghands() {\r\n     require(myDividends(true) > 0);\r\n     _;\r\n   }\r\n   modifier onlyAdministrator() {\r\n     address _customerAddress = msg.sender;\r\n     require(administrators[keccak256(_customerAddress)]);\r\n     _;\r\n   }\r\n   address owner = msg.sender;\r\n   uint public jackpotFund;\r\n   event onTokenPurchase(\r\n     address indexed customerAddress,\r\n     uint256 incominghex,\r\n     uint256 tokensMinted,\r\n     address indexed referredBy\r\n   );\r\n\r\n   event onTokenSell(\r\n     address indexed customerAddress,\r\n     uint256 tokensBurned,\r\n     uint256 hexEarned\r\n   );\r\n\r\n   event onReinvestment(\r\n     address indexed customerAddress,\r\n     uint256 hexReinvested,\r\n     uint256 tokensMinted\r\n   );\r\n\r\n   event onWithdraw(\r\n     address indexed customerAddress,\r\n     uint256 hexWithdrawn\r\n   );\r\n\r\n   event Transfer(\r\n     address indexed from,\r\n     address indexed to,\r\n     uint256 tokens\r\n   );\r\n\r\n   string public name = \"HEXFOMO\";\r\n   string public symbol = \"HEMO\";\r\n   uint8 constant public decimals = 8;\r\n   uint8 constant internal dividendFee_ = 5;\r\n   uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\r\n   uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\r\n   uint256 constant internal magnitude = 2 ** 64;\r\n\r\n   uint256 public stakingRequirement = 1e8;\r\n\r\n   mapping(address => uint256) internal tokenBalanceLedger_;\r\n   mapping(address => uint256) internal referralBalance_;\r\n   mapping(address => int256) internal payoutsTo_;\r\n   mapping(address => uint256) internal ambassadorAccumulatedQuota_;\r\n   uint256 internal tokenSupply_ = 0;\r\n   uint256 internal profitPerShare_;\r\n\r\n   uint public totalDividendspaid;\r\n   uint public totalPlayers;\r\n   mapping(bytes32 => bool) public administrators;\r\n   mapping(address => bool) public isPlayer;\r\n   bool public onlyAmbassadors = true;\r\n\r\n   IERC20 public hexToken;\r\n\r\n   function HexFomo()\r\n   public {\r\n\r\n   //  hexToken = IERC20(0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39);\r\n     hexToken = IERC20(0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39);\r\n     \r\n     onlyAmbassadors = false;\r\n\r\n   }\r\n\r\n   address public potWinner;\r\n   uint public potTime = now + 4 weeks;\r\n\r\n   function buy(uint hexIn1)\r\n   public\r\n   payable\r\n   returns(uint256) {\r\n     hexToken.transferFrom(msg.sender, address(this), hexIn1);\r\n     claimPot();\r\n     purchaseTokens(hexIn1, 0x0000000000000000000000000000000000000000);\r\n     uint data = hexIn1;\r\n     uint toPot = (data * 10) / 100;\r\n     jackpotFund += toPot;\r\n     potWinner = msg.sender;\r\n     potTime += 1 hours;\r\n   }\r\n\r\n   function claimPot() public {\r\n     if (potTime <= now) {\r\n       hexToken.transfer(potWinner, jackpotFund);\r\n       potTime = now;\r\n     }\r\n   }\r\n\r\n   function ()\r\n   payable\r\n   public {\r\n     owner.transfer(msg.value);\r\n   }\r\n\r\n   function reinvest()\r\n   onlyStronghands()\r\n   public {\r\n\r\n     uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\r\n\r\n     address _customerAddress = msg.sender;\r\n     payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\r\n\r\n     _dividends += referralBalance_[_customerAddress];\r\n     referralBalance_[_customerAddress] = 0;\r\n\r\n     uint256 _tokens = purchaseTokens(_dividends, 0x0);\r\n\r\n     onReinvestment(_customerAddress, _dividends, _tokens);\r\n   }\r\n\r\n   function exit()\r\n   public {\r\n\r\n     address _customerAddress = msg.sender;\r\n     uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n     if (_tokens > 0) sell(_tokens);\r\n\r\n     withdraw();\r\n   }\r\n\r\n  function withdraw()\r\n   onlyStronghands()\r\n   public {\r\n\r\n     address _customerAddress = msg.sender;\r\n     uint256 _dividends = myDividends(false); // get ref. bonus later in the code\r\n\r\n     payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\r\n\r\n     _dividends += referralBalance_[_customerAddress];\r\n     referralBalance_[_customerAddress] = 0;\r\n\r\n     uint fee = (_dividends * 10) / 100;\r\n     hexToken.transfer(owner, fee);\r\n     hexToken.transfer(_customerAddress, _dividends - fee);\r\n\r\n     onWithdraw(_customerAddress, _dividends);\r\n     totalDividendspaid += _dividends;\r\n\r\n   }\r\n\r\n   function sell(uint256 _amountOfTokens)\r\n   onlyBagholders()\r\n   public {\r\n\r\n     address _customerAddress = msg.sender;\r\n\r\n     require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n     uint256 _tokens = _amountOfTokens;\r\n     uint256 _hex = tokensTohex_(_tokens);\r\n     uint256 _dividends = SafeMath.div(_hex, dividendFee_);\r\n     uint256 _taxedHex = SafeMath.sub(_hex, _dividends);\r\n\r\n     tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\r\n     tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n\r\n     int256 _updatedPayouts = (int256)(profitPerShare_ * _tokens + (_taxedHex * magnitude));\r\n     payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n\r\n     if (tokenSupply_ > 0) {\r\n\r\n       profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n     }\r\n\r\n     onTokenSell(_customerAddress, _tokens, _taxedHex);\r\n   }\r\n\r\n   function transfer(address _toAddress, uint256 _amountOfTokens)\r\n   onlyBagholders()\r\n   public\r\n   returns(bool) {\r\n\r\n     address _customerAddress = msg.sender;\r\n\r\n     require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n     if (myDividends(true) > 0) withdraw();\r\n\r\n     uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\r\n     uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\r\n     uint256 _dividends = tokensTohex_(_tokenFee);\r\n\r\n     tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\r\n\r\n     tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n     tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\r\n\r\n     payoutsTo_[_customerAddress] -= (int256)(profitPerShare_ * _amountOfTokens);\r\n     payoutsTo_[_toAddress] += (int256)(profitPerShare_ * _taxedTokens);\r\n\r\n     profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n\r\n     Transfer(_customerAddress, _toAddress, _taxedTokens);\r\n\r\n     return true;\r\n\r\n   }\r\n\r\n   function disableInitialStage()\r\n   onlyAdministrator()\r\n   public {\r\n     onlyAmbassadors = false;\r\n   }\r\n\r\n   function setAdministrator(bytes32 _identifier, bool _status)\r\n   onlyAdministrator()\r\n   public {\r\n     administrators[_identifier] = _status;\r\n   }\r\n\r\n   function setStakingRequirement(uint256 _amountOfTokens)\r\n   onlyAdministrator()\r\n   public {\r\n     stakingRequirement = _amountOfTokens;\r\n   }\r\n\r\n   function setName(string _name)\r\n   onlyAdministrator()\r\n   public {\r\n     name = _name;\r\n   }\r\n\r\n   function setSymbol(string _symbol)\r\n   onlyAdministrator()\r\n   public {\r\n     symbol = _symbol;\r\n   }\r\n\r\n   function totalhexBalance()\r\n   public\r\n   view\r\n   returns(uint) {\r\n     return hexToken.balanceOf(this);\r\n   }\r\n\r\n   function totalSupply()\r\n   public\r\n   view\r\n   returns(uint256) {\r\n     return tokenSupply_;\r\n   }\r\n\r\n   function myTokens()\r\n   public\r\n   view\r\n   returns(uint256) {\r\n     address _customerAddress = msg.sender;\r\n     return balanceOf(_customerAddress);\r\n   }\r\n\r\n   function myDividends(bool _includeReferralBonus)\r\n   public\r\n   view\r\n   returns(uint256) {\r\n     address _customerAddress = msg.sender;\r\n     return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\r\n   }\r\n\r\n   /**\r\n    * Retrieve the token balance of any single address.\r\n    */\r\n   function balanceOf(address _customerAddress)\r\n   view\r\n   public\r\n   returns(uint256) {\r\n     return tokenBalanceLedger_[_customerAddress];\r\n   }\r\n\r\n   /**\r\n    * Retrieve the dividend balance of any single address.\r\n    */\r\n   function dividendsOf(address _customerAddress)\r\n   view\r\n   public\r\n   returns(uint256) {\r\n     return (uint256)((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n   }\r\n\r\n   function sellPrice()\r\n   public\r\n   view\r\n   returns(uint256) {\r\n     // our calculation relies on the token supply, so we need supply. Doh.\r\n     if (tokenSupply_ == 0) {\r\n       return tokenPriceInitial_ - tokenPriceIncremental_;\r\n     } else {\r\n       uint256 _hex = tokensTohex_(1e8);\r\n       uint256 _dividends = SafeMath.div(_hex, dividendFee_);\r\n       uint256 _taxedHex = SafeMath.sub(_hex, _dividends);\r\n       return _taxedHex;\r\n     }\r\n   }\r\n\r\n   function buyPrice()\r\n   public\r\n   view\r\n   returns(uint256) {\r\n     // our calculation relies on the token supply, so we need supply. Doh.\r\n     if (tokenSupply_ == 0) {\r\n       return tokenPriceInitial_ + tokenPriceIncremental_;\r\n     } else {\r\n       uint256 _hex = tokensTohex_(1e8);\r\n       uint256 _dividends = SafeMath.div(_hex, dividendFee_);\r\n       uint256 _taxedHex = SafeMath.add(_hex, _dividends);\r\n       return _taxedHex;\r\n     }\r\n   }\r\n\r\n   function calculateTokensReceived(uint256 _hexToSpend)\r\n   public\r\n   view\r\n   returns(uint256) {\r\n     uint256 _dividends = SafeMath.div(_hexToSpend, dividendFee_);\r\n     uint256 _taxedHex = SafeMath.sub(_hexToSpend, _dividends);\r\n     uint256 _amountOfTokens = hexToTokens_(_taxedHex);\r\n\r\n     return _amountOfTokens;\r\n   }\r\n\r\n   function calculateHexReceived(uint256 _tokensToSell)\r\n   public\r\n   view\r\n   returns(uint256) {\r\n     require(_tokensToSell <= tokenSupply_);\r\n     uint256 _hex = tokensTohex_(_tokensToSell);\r\n     uint256 _dividends = SafeMath.div(_hex, dividendFee_);\r\n     uint256 _taxedHex = SafeMath.sub(_hex, _dividends);\r\n     return _taxedHex;\r\n   }\r\n\r\n   function purchaseTokens(uint256 _incomingHex, address _referredBy)\r\n\r\n   internal\r\n   returns(uint256) {\r\n     // data setup\r\n     address _customerAddress = msg.sender;\r\n     if (!isPlayer[msg.sender]) {\r\n       totalPlayers++;\r\n       isPlayer[msg.sender] = true;\r\n     }\r\n     uint256 _undividedDividends = SafeMath.div(_incomingHex, dividendFee_);\r\n     uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\r\n     uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\r\n     uint256 _taxedHex = SafeMath.sub(_incomingHex, _undividedDividends);\r\n     uint256 _amountOfTokens = hexToTokens_(_taxedHex);\r\n     uint256 _fee = _dividends * magnitude;\r\n\r\n     uint fee = (_incomingHex * 10) / 100;\r\n     hexToken.transfer(owner, fee);\r\n\r\n     require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_));\r\n\r\n     if (\r\n\r\n       _referredBy != 0x0000000000000000000000000000000000000000 &&\r\n\r\n       _referredBy != _customerAddress &&\r\n\r\n       tokenBalanceLedger_[_referredBy] >= stakingRequirement\r\n     ) {\r\n       referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\r\n     } else {\r\n       _dividends = SafeMath.add(_dividends, _referralBonus);\r\n       _fee = _dividends * magnitude;\r\n     }\r\n     if (tokenSupply_ > 0) {\r\n\r\n       tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n\r\n       profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\r\n\r\n       _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\r\n\r\n     } else {\r\n\r\n       tokenSupply_ = _amountOfTokens;\r\n     }\r\n     tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n     int256 _updatedPayouts = (int256)((profitPerShare_ * _amountOfTokens) - _fee);\r\n     payoutsTo_[_customerAddress] += _updatedPayouts;\r\n     return _amountOfTokens;\r\n   }\r\n\r\n   function hexToTokens_(uint256 _hex)\r\n   internal\r\n   view\r\n   returns(uint256) {\r\n     uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e8;\r\n     uint256 _tokensReceived =\r\n       (\r\n         (\r\n\r\n           SafeMath.sub(\r\n             (sqrt(\r\n               (_tokenPriceInitial ** 2) +\r\n               (2 * (tokenPriceIncremental_ * 1e8) * (_hex * 1e8)) +\r\n               (((tokenPriceIncremental_) ** 2) * (tokenSupply_ ** 2)) +\r\n               (2 * (tokenPriceIncremental_) * _tokenPriceInitial * tokenSupply_)\r\n             )), _tokenPriceInitial\r\n           )\r\n         ) / (tokenPriceIncremental_)\r\n       ) - (tokenSupply_);\r\n\r\n     return _tokensReceived;\r\n   }\r\n\r\n   function tokensTohex_(uint256 _tokens)\r\n   internal\r\n   view\r\n   returns(uint256) {\r\n\r\n     uint256 tokens_ = (_tokens + 1e8);\r\n     uint256 _tokenSupply = (tokenSupply_ + 1e8);\r\n     uint256 _etherReceived =\r\n       (\r\n\r\n         SafeMath.sub(\r\n           (\r\n             (\r\n               (\r\n                 tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e8))\r\n               ) - tokenPriceIncremental_\r\n             ) * (tokens_ - 1e8)\r\n           ), (tokenPriceIncremental_ * ((tokens_ ** 2 - tokens_) / 1e8)) / 2\r\n         ) /\r\n         1e8);\r\n     return _etherReceived;\r\n   }\r\n\r\n   function sqrt(uint x) internal pure returns(uint y) {\r\n     uint z = (x + 1) / 2;\r\n     y = x;\r\n     while (z < y) {\r\n       y = z;\r\n       z = (x / z + z) / 2;\r\n     }\r\n   }\r\n }\r\n\r\n library SafeMath {\r\n\r\n   function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     if (a == 0) {\r\n       return 0;\r\n     }\r\n     uint256 c = a * b;\r\n     assert(c / a == b);\r\n     return c;\r\n   }\r\n\r\n   function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     uint256 c = a / b;\r\n     return c;\r\n   }\r\n\r\n   function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     assert(b <= a);\r\n     return a - b;\r\n   }\r\n\r\n   function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     uint256 c = a + b;\r\n     assert(c >= a);\r\n     return c;\r\n   }\r\n }","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hexToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyAmbassadors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateHexReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hexToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"setStakingRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividendspaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableInitialStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hexIn1\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalhexBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimPot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incominghex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hexEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hexReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hexWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"HexFomo","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f9763f6744ef70c032c1d4dcf2348196338a296c4fb7ab17bd8217c3ec29c930"}]}