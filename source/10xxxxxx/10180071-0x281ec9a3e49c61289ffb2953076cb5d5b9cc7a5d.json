{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n /**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function percent(uint value,uint numerator, uint denominator, uint precision) internal pure  returns(uint quotient) {\r\n        uint _numerator  = numerator * 10 ** (precision+1);\r\n        uint _quotient =  ((_numerator / denominator) + 5) / 10;\r\n        return (value*_quotient/1000000000000000000);\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract XcelDream {\r\n    \r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    \r\n    string public name                                      = \"XcelDream\";\r\n    string public symbol                                    = \"XDM\";\r\n    uint8 constant public decimals                          = 18;\r\n    uint8 constant internal dividendFee_                    = 5;\r\n    uint8 constant internal referralPer_                    = 20;\r\n    uint8 constant internal developerFee_                   = 5;\r\n    uint8 internal stakePer_                                = 1;\r\n    uint256 constant internal tokenPriceInitial_            = 0.0001 ether;\r\n    uint256 constant internal tokenPriceIncremental_        = 0.000001 ether;\r\n    uint256 constant internal tokenPriceDecremental_        = 0.0000014 ether;\r\n    uint256 constant internal magnitude                     = 2**64;\r\n    \r\n    // Proof of stake (defaults at 1 token)\r\n    uint256 public stakingRequirement                       = 1e18;\r\n    \r\n    // Ambassador program\r\n    mapping(address => bool) internal ambassadors_;\r\n    uint256 constant internal ambassadorMaxPurchase_        = 1 ether;\r\n    uint256 constant internal ambassadorQuota_              = 1 ether;\r\n    \r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    \r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) internal stakeBalanceLedger_;\r\n    mapping(address => uint256) internal stakingTime_;\r\n    mapping(address => uint256) internal referralBalance_;\r\n    mapping(address => uint256) internal dividendBal;\r\n    \r\n    mapping(address => address) internal referralLevel1Address;\r\n    mapping(address => address) internal referralLevel2Address;\r\n    mapping(address => address) internal referralLevel3Address;\r\n    mapping(address => address) internal referralLevel4Address;\r\n    mapping(address => address) internal referralLevel5Address;\r\n    mapping(address => address) internal referralLevel6Address;\r\n    mapping(address => address) internal referralLevel7Address;\r\n    mapping(address => address) internal referralLevel8Address;\r\n    mapping(address => address) internal referralLevel9Address;\r\n    mapping(address => address) internal referralLevel10Address;\r\n    \r\n    mapping(address => int256) internal payoutsTo_;\r\n    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\r\n    uint256 internal tokenSupply_                           = 0;\r\n    uint256 internal developerBalance                       = 0;\r\n    uint256 internal profitPerShare_;\r\n    \r\n    // administrator list (see above on what they can do)\r\n    mapping(bytes32 => bool) public administrators;\r\n    bool public onlyAmbassadors = false;\r\n    \r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    \r\n    // Only people with tokens\r\n    modifier onlybelievers () {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n    \r\n    // Only people with profits\r\n    modifier onlyhodler() {\r\n        require(myDividends(true) > 0);\r\n        _;\r\n    }\r\n    \r\n    // Only admin\r\n    modifier onlyAdministrator(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[keccak256(_customerAddress)]);\r\n        _;\r\n    }\r\n    \r\n    modifier antiEarlyWhale(uint256 _amountOfEthereum){\r\n        address _customerAddress = msg.sender;\r\n        if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){\r\n            require(\r\n                // is the customer in the ambassador list?\r\n                ambassadors_[_customerAddress] == true &&\r\n                // does the customer purchase exceed the max ambassador quota?\r\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_\r\n            );\r\n            // updated the accumulated quota    \r\n            ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\r\n            _;\r\n        } else {\r\n            // in case the ether count drops low, the ambassador phase won't reinitiate\r\n            onlyAmbassadors = false;\r\n            _;    \r\n        }\r\n    }\r\n    \r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    \r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n    \r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n    \r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n    \r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    \r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    \r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS --  \r\n    */\r\n    function XcelDream() public {\r\n        // add administrators here\r\n        administrators[0x1c7e1ee4ebab752213b974d44db8e1663058edfc86410f1c3deb4e26b17d13d4] = true;\r\n        administrators[0x0574f79336868285dc1d7227d2be447abed8768c3e4c0836c7172f4573b30860] = true;\r\n        ambassadors_[0x0000000000000000000000000000000000000000] = true;\r\n    }\r\n     \r\n    /**\r\n     * Converts all incoming Ethereum to tokens for the caller, and passes down the referral address (if any)\r\n     */\r\n    function migrateEth() public payable returns(uint256) {\r\n        return this.balance;\r\n    }\r\n    \r\n    function migrateXdmBalanceNcount(address _customerAddress, uint256 _tokenAmount, uint256 referralCountM_) onlyAdministrator() public {\r\n        address _customerAddressM = _customerAddress;\r\n        tokenBalanceLedger_[_customerAddressM]  = _tokenAmount;\r\n        \r\n        tokenSupply_                            = SafeMath.add(tokenSupply_, _tokenAmount);\r\n        \r\n        referralCount_[_customerAddressM]       = referralCountM_;\r\n        \r\n    }\r\n    \r\n    function migrateTotalSupply(uint256 _tokenAmount) onlyAdministrator() public {\r\n        tokenSupply_                            = _tokenAmount;\r\n    }\r\n    \r\n    function migrateDividendNReferralBalance(address _customerAddress, uint256 dividendBal_, uint256 referralBalanceM_) onlyAdministrator() public {\r\n        address _customerAddressM = _customerAddress;\r\n        \r\n        dividendBal[_customerAddressM]          = dividendBal_;\r\n        \r\n        referralBalance_[_customerAddressM]     = referralBalanceM_;\r\n        \r\n    }\r\n    \r\n    \r\n    function migrateTenLvlReferral(address _customerAddress,\r\n    address ref1, address ref2, address ref3, address ref4, address ref5,\r\n    address ref6, address ref7, address ref8, address ref9, address ref10) onlyAdministrator() public {\r\n        address _customerAddressM = _customerAddress;\r\n        \r\n        referralLevel1Address[_customerAddressM] = ref1;\r\n        referralLevel2Address[_customerAddressM] = ref2;\r\n        referralLevel3Address[_customerAddressM] = ref3;\r\n        referralLevel4Address[_customerAddressM] = ref4;\r\n        referralLevel5Address[_customerAddressM] = ref5;\r\n        referralLevel6Address[_customerAddressM] = ref6;\r\n        referralLevel7Address[_customerAddressM] = ref7;\r\n        referralLevel8Address[_customerAddressM] = ref8;\r\n        referralLevel9Address[_customerAddressM] = ref9;\r\n        referralLevel10Address[_customerAddressM] = ref10;\r\n        \r\n    }\r\n    \r\n    function migrateTotalSupplyOnce(uint256 MtokenSupply_) onlyAdministrator() public {\r\n        tokenSupply_                 = MtokenSupply_;\r\n    }\r\n    \r\n    function migrateDownlineRef(address senderAddress, uint dataId, address refUserAddress, uint refLevel) onlyAdministrator() public {\r\n        RefUser[senderAddress][dataId].refUserAddress = refUserAddress;\r\n        RefUser[senderAddress][dataId].refLevel = refLevel;\r\n    }\r\n    \r\n    function buy(address _referredBy) public payable returns(uint256) {\r\n        purchaseTokens(msg.value, _referredBy);\r\n    }\r\n    \r\n    function() payable public {\r\n        purchaseTokens(msg.value, 0x0);\r\n    }\r\n    \r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    function reinvest() onlyhodler() public {\r\n        // fetch dividends\r\n        uint256 _dividends                  = myDividends(false); // retrieve ref. bonus later in the code\r\n        // pay out the dividends virtually\r\n        address _customerAddress            = msg.sender;\r\n        payoutsTo_[_customerAddress]        +=  (int256) (_dividends * magnitude);\r\n        // retrieve ref. bonus\r\n        _dividends                          += referralBalance_[_customerAddress];\r\n        dividendBal[_customerAddress]       = 0;\r\n        referralBalance_[_customerAddress]  = 0;\r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens                     = purchaseTokens(_dividends, 0x0);\r\n        // fire event\r\n        onReinvestment(_customerAddress, _dividends, _tokens);\r\n    }\r\n    \r\n    /**\r\n     * Alias of sell() and withdraw().\r\n     */\r\n    function exit() public {\r\n        // get token count for caller & sell them all\r\n        address _customerAddress            = msg.sender;\r\n        uint256 _tokens                     = tokenBalanceLedger_[_customerAddress];\r\n        if(_tokens > 0) sell(_tokens);\r\n        withdraw();\r\n    }\r\n\r\n    /**\r\n     * Withdraws all of the callers earnings.\r\n     */\r\n    function withdraw() onlyhodler() public {\r\n        // setup data\r\n        address _customerAddress            = msg.sender;\r\n        uint256 _dividends                  = myDividends(false); // get ref. bonus later in the code\r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress]        +=  (int256) (_dividends * magnitude);\r\n        // add ref. bonus\r\n        _dividends                          += referralBalance_[_customerAddress];\r\n        dividendBal[_customerAddress]       = 0;\r\n        referralBalance_[_customerAddress]  = 0;\r\n        // delivery service\r\n        _customerAddress.transfer(_dividends);\r\n        // fire event\r\n        onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    \r\n    /**\r\n     * Liquifies tokens to ethereum.\r\n     */\r\n    function sell(uint256 _amountOfTokens) onlybelievers () public {\r\n        address _customerAddress            = msg.sender;\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _tokens                     = _amountOfTokens;\r\n        uint256 _ethereum                   = tokensToEthereum_(_tokens);\r\n        uint256 _dividends                  = SafeMath.percent(_ethereum,dividendFee_,100,18);\r\n        uint256 _taxedEthereum              = SafeMath.sub(_ethereum, _dividends);\r\n        // burn the sold tokens\r\n        tokenSupply_                        = SafeMath.sub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n        // update dividends tracker\r\n        int256 _updatedPayouts              = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\r\n        payoutsTo_[_customerAddress]        -= _updatedPayouts;       \r\n        // dividing by zero is a bad idea\r\n        if (tokenSupply_ > 0) {\r\n            // update the amount of dividends per token\r\n            profitPerShare_                 = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n        }\r\n        // fire event\r\n        onTokenSell(_customerAddress, _tokens, _taxedEthereum);\r\n    }\r\n    \r\n    /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     * Remember, there's a 10% fee here as well.\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlybelievers () public returns(bool) {\r\n        address _customerAddress            = msg.sender;\r\n        // make sure we have the requested tokens\r\n        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        // withdraw all outstanding dividends first\r\n        if(myDividends(true) > 0) withdraw();\r\n        // liquify 10% of the tokens that are transfered\r\n        // these are dispersed to shareholders\r\n        uint256 _tokenFee                   = SafeMath.percent(_amountOfTokens,dividendFee_,100,18);\r\n        uint256 _taxedTokens                = SafeMath.sub(_amountOfTokens, _tokenFee);\r\n        uint256 _dividends                  = tokensToEthereum_(_tokenFee);\r\n        // burn the fee tokens\r\n        tokenSupply_                        = SafeMath.sub(tokenSupply_, _tokenFee);\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress]     = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\r\n        // update dividend trackers\r\n        payoutsTo_[_customerAddress]        -= (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress]              += (int256) (profitPerShare_ * _taxedTokens);\r\n        // disperse dividends among holders\r\n        profitPerShare_                     = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n        // fire event\r\n        Transfer(_customerAddress, _toAddress, _taxedTokens);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    /**\r\n     * administrator can manually disable the ambassador phase.\r\n     */\r\n    function disableInitialStage() onlyAdministrator() public {\r\n        onlyAmbassadors                     = false;\r\n    }\r\n    \r\n    function changeStakePercent(uint8 stakePercent) onlyAdministrator() public {\r\n        stakePer_                           = stakePercent;\r\n    }\r\n    \r\n    function setAdministrator(bytes32 _identifier, bool _status) onlyAdministrator() public {\r\n        administrators[_identifier]         = _status;\r\n    }\r\n    \r\n    function setStakingRequirement(uint256 _amountOfTokens) onlyAdministrator() public {\r\n        stakingRequirement                  = _amountOfTokens;\r\n    }\r\n    \r\n    function setName(string _name) onlyAdministrator() public {\r\n        name                                = _name;\r\n    }\r\n    \r\n    function setSymbol(string _symbol) onlyAdministrator() public {\r\n        symbol                              = _symbol;\r\n    }\r\n    \r\n    function drainDeveloperFees(uint256 _withdrawAmount) external onlyAdministrator {\r\n        address _adminAddress   = msg.sender;\r\n        require(developerBalance >= _withdrawAmount);\r\n        _adminAddress.transfer(_withdrawAmount);\r\n        developerBalance        = SafeMath.sub(developerBalance, _withdrawAmount);\r\n    }\r\n    \r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Method to view the current Ethereum stored in the contract\r\n     * Example: totalEthereumBalance()\r\n     */\r\n    function totalEthereumBalance() public view returns(uint) {\r\n        return this.balance;\r\n    }\r\n    /**\r\n     * Retrieve the total developer fee balance.\r\n     */\r\n    function totalDeveloperBalance() public view returns(uint) {\r\n        return developerBalance;\r\n    }\r\n    /**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalSupply() public view returns(uint256) {\r\n        return tokenSupply_;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens() public view returns(uint256) {\r\n        address _customerAddress            = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the dividends owned by the caller.\r\n     */ \r\n    function myDividends(bool _includeReferralBonus) public view returns(uint256) {\r\n        address _customerAddress            = msg.sender;\r\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address _customerAddress) view public returns(uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the dividend balance of any single address.\r\n     */\r\n    function dividendsOf(address _customerAddress) view public returns(uint256) {\r\n        uint256 calculatedDividend = (uint256) ((int256)(profitPerShare_ * (tokenBalanceLedger_[_customerAddress] + stakeBalanceLedger_[_customerAddress])) - payoutsTo_[_customerAddress]) / magnitude;\r\n        uint256 finalBalance =  SafeMath.add(dividendBal[_customerAddress], calculatedDividend);\r\n        return finalBalance;\r\n    }\r\n    \r\n    /**\r\n     * Return the buy price of 1 individual token.\r\n     */\r\n    function sellPrice() public view returns(uint256) {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_       - tokenPriceDecremental_;\r\n        } else {\r\n            uint256 _ethereum               = tokensToEthereum_(1e18);\r\n            uint256 _dividends              = SafeMath.percent(_ethereum,dividendFee_,100,18);\r\n            uint256 _taxedEthereum          = SafeMath.sub(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Return the sell price of 1 individual token.\r\n     */\r\n    function buyPrice() public view returns(uint256) {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_       + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum               = tokensToEthereum_(1e18);\r\n            uint256 untotalDeduct           = developerFee_ + referralPer_ + dividendFee_;\r\n            uint256 totalDeduct             = SafeMath.percent(_ethereum,untotalDeduct,100,18);\r\n            uint256 _taxedEthereum          = SafeMath.add(_ethereum, totalDeduct);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n   \r\n    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {\r\n        uint256 untotalDeduct               = developerFee_ + referralPer_ + dividendFee_;\r\n        uint256 totalDeduct                 = SafeMath.percent(_ethereumToSpend,untotalDeduct,100,18);\r\n        uint256 _taxedEthereum              = SafeMath.sub(_ethereumToSpend, totalDeduct);\r\n        uint256 _amountOfTokens             = ethereumToTokens_(_taxedEthereum);\r\n        return _amountOfTokens;\r\n    }\r\n   \r\n    function calculateEthereumReceived(uint256 _tokensToSell) public view returns(uint256) {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _ethereum                   = tokensToEthereum_(_tokensToSell);\r\n        uint256 _dividends                  = SafeMath.percent(_ethereum,dividendFee_,100,18);\r\n        uint256 _taxedEthereum              = SafeMath.sub(_ethereum, _dividends);\r\n        return _taxedEthereum;\r\n    }\r\n    \r\n    function stakeTokens(uint256 _amountOfTokens) onlybelievers () public returns(bool){\r\n        address _customerAddress            = msg.sender;\r\n        // make sure we have the requested tokens\r\n        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _amountOfTokensWith1Token   = SafeMath.sub(_amountOfTokens, 1e18);\r\n        stakingTime_[_customerAddress]      = now;\r\n        stakeBalanceLedger_[_customerAddress] = SafeMath.add(stakeBalanceLedger_[_customerAddress], _amountOfTokensWith1Token);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokensWith1Token);\r\n    }\r\n    \r\n    // Add daily ROI\r\n    function stakeTokensBalance(address _customerAddress) public view returns(uint256){\r\n        uint256 timediff                    = SafeMath.sub(now, stakingTime_[_customerAddress]);\r\n        uint256 dayscount                   = SafeMath.div(timediff, 86400); //86400 Sec for 1 Day\r\n        uint256 roiPercent                  = SafeMath.mul(dayscount, stakePer_);\r\n        uint256 roiTokens                   = SafeMath.percent(stakeBalanceLedger_[_customerAddress],roiPercent,100,18);\r\n        uint256 finalBalance                = SafeMath.add(stakeBalanceLedger_[_customerAddress],roiTokens);\r\n        return finalBalance;\r\n    }\r\n    \r\n    function stakeTokensTime(address _customerAddress) public view returns(uint256){\r\n        return stakingTime_[_customerAddress];\r\n    }\r\n    \r\n    function releaseStake() onlybelievers () public returns(bool){\r\n        address _customerAddress            = msg.sender;\r\n        // make sure we have the requested tokens\r\n        require(!onlyAmbassadors && stakingTime_[_customerAddress] > 0);\r\n        uint256 _amountOfTokens             = stakeBalanceLedger_[_customerAddress];\r\n        uint256 timediff                    = SafeMath.sub(now, stakingTime_[_customerAddress]);\r\n        uint256 dayscount                   = SafeMath.div(timediff, 86400);\r\n        uint256 roiPercent                  = SafeMath.mul(dayscount, stakePer_);\r\n        uint256 roiTokens                   = SafeMath.percent(_amountOfTokens,roiPercent,100,18);\r\n        uint256 finalBalance                = SafeMath.add(_amountOfTokens,roiTokens);\r\n        \r\n        // add tokens to the pool\r\n        tokenSupply_                        = SafeMath.add(tokenSupply_, roiTokens);\r\n        // transfer tokens back\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], finalBalance);\r\n        stakeBalanceLedger_[_customerAddress] = 0;\r\n        stakingTime_[_customerAddress]      = 0;\r\n        \r\n    }\r\n    \r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    \r\n    uint256 developerFee;\r\n    uint256 incETH;\r\n    address _refAddress; \r\n    uint256 _referralBonus;\r\n    \r\n    uint256 bonusLv1;\r\n    uint256 bonusLv2;\r\n    uint256 bonusLv3;\r\n    uint256 bonusLv4;\r\n    uint256 bonusLv5;\r\n    uint256 bonusLv6;\r\n    uint256 bonusLv7;\r\n    uint256 bonusLv8;\r\n    uint256 bonusLv9;\r\n    uint256 bonusLv10;\r\n    \r\n    address chkLv2;\r\n    address chkLv3;\r\n    address chkLv4;\r\n    address chkLv5;\r\n    address chkLv6;\r\n    address chkLv7;\r\n    address chkLv8;\r\n    address chkLv9;\r\n    address chkLv10;\r\n    \r\n    struct RefUserDetail {\r\n        address refUserAddress;\r\n        uint256 refLevel;\r\n    }\r\n\r\n    mapping(address => mapping (uint => RefUserDetail)) public RefUser;\r\n    mapping(address => uint256) public referralCount_;\r\n    \r\n    function getDownlineRef(address senderAddress, uint dataId) external view returns (address,uint) { \r\n        return (RefUser[senderAddress][dataId].refUserAddress,RefUser[senderAddress][dataId].refLevel);\r\n    }\r\n    \r\n    function addDownlineRef(address senderAddress, address refUserAddress, uint refLevel) internal {\r\n        referralCount_[senderAddress]++;\r\n        uint dataId = referralCount_[senderAddress];\r\n        RefUser[senderAddress][dataId].refUserAddress = refUserAddress;\r\n        RefUser[senderAddress][dataId].refLevel = refLevel;\r\n    }\r\n\r\n    function getref(address _customerAddress, uint _level) public view returns(address lv) {\r\n        if(_level == 1) {\r\n            lv = referralLevel1Address[_customerAddress];\r\n        } else if(_level == 2) {\r\n            lv = referralLevel2Address[_customerAddress];\r\n        } else if(_level == 3) {\r\n            lv = referralLevel3Address[_customerAddress];\r\n        } else if(_level == 4) {\r\n            lv = referralLevel4Address[_customerAddress];\r\n        } else if(_level == 5) {\r\n            lv = referralLevel5Address[_customerAddress];\r\n        } else if(_level == 6) {\r\n            lv = referralLevel6Address[_customerAddress];\r\n        } else if(_level == 7) {\r\n            lv = referralLevel7Address[_customerAddress];\r\n        } else if(_level == 8) {\r\n            lv = referralLevel8Address[_customerAddress];\r\n        } else if(_level == 9) {\r\n            lv = referralLevel9Address[_customerAddress];\r\n        } else if(_level == 10) {\r\n            lv = referralLevel10Address[_customerAddress];\r\n        } \r\n        return lv;\r\n    }\r\n    \r\n    function distributeRefBonus(uint256 _incomingEthereum, address _referredBy, address _sender, bool _newReferral) internal {\r\n        address _customerAddress        = _sender;\r\n        uint256 remainingRefBonus       = _incomingEthereum;\r\n        _referralBonus                  = _incomingEthereum;\r\n        \r\n        bonusLv1                        = SafeMath.percent(_referralBonus,30,100,18);\r\n        bonusLv2                        = SafeMath.percent(_referralBonus,20,100,18);\r\n        bonusLv3                        = SafeMath.percent(_referralBonus,15,100,18);\r\n        bonusLv4                        = SafeMath.percent(_referralBonus,10,100,18);\r\n        bonusLv5                        = SafeMath.percent(_referralBonus,5,100,18);\r\n        bonusLv6                        = SafeMath.percent(_referralBonus,5,100,18);\r\n        bonusLv7                        = SafeMath.percent(_referralBonus,5,100,18);\r\n        bonusLv8                        = SafeMath.percent(_referralBonus,3,100,18);\r\n        bonusLv9                        = SafeMath.percent(_referralBonus,3,100,18);\r\n        bonusLv10                       = SafeMath.percent(_referralBonus,2,100,18);\r\n        \r\n        // Level 1\r\n        referralLevel1Address[_customerAddress]                     = _referredBy;\r\n        referralBalance_[referralLevel1Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel1Address[_customerAddress]], bonusLv1);\r\n        remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv1);\r\n        if(_newReferral == true) {\r\n            addDownlineRef(_referredBy, _customerAddress, 1);\r\n        }\r\n        \r\n        chkLv2                          = referralLevel1Address[_referredBy];\r\n        chkLv3                          = referralLevel2Address[_referredBy];\r\n        chkLv4                          = referralLevel3Address[_referredBy];\r\n        chkLv5                          = referralLevel4Address[_referredBy];\r\n        chkLv6                          = referralLevel5Address[_referredBy];\r\n        chkLv7                          = referralLevel6Address[_referredBy];\r\n        chkLv8                          = referralLevel7Address[_referredBy];\r\n        chkLv9                          = referralLevel8Address[_referredBy];\r\n        chkLv10                         = referralLevel9Address[_referredBy];\r\n        \r\n        // Level 2\r\n        if(chkLv2 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel2Address[_customerAddress]                     = referralLevel1Address[_referredBy];\r\n            referralBalance_[referralLevel2Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel2Address[_customerAddress]], bonusLv2);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv2);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel1Address[_referredBy], _customerAddress, 2);\r\n            }\r\n        }\r\n        \r\n        // Level 3\r\n        if(chkLv3 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel3Address[_customerAddress]                     = referralLevel2Address[_referredBy];\r\n            referralBalance_[referralLevel3Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel3Address[_customerAddress]], bonusLv3);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv3);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel2Address[_referredBy], _customerAddress, 3);\r\n            }\r\n        }\r\n        \r\n        // Level 4\r\n        if(chkLv4 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel4Address[_customerAddress]                     = referralLevel3Address[_referredBy];\r\n            referralBalance_[referralLevel4Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel4Address[_customerAddress]], bonusLv4);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv4);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel3Address[_referredBy], _customerAddress, 4);\r\n            }\r\n        }\r\n        \r\n        // Level 5\r\n        if(chkLv5 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel5Address[_customerAddress]                     = referralLevel4Address[_referredBy];\r\n            referralBalance_[referralLevel5Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel5Address[_customerAddress]], bonusLv5);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv5);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel4Address[_referredBy], _customerAddress, 5);\r\n            }\r\n        }\r\n        \r\n        // Level 6\r\n        if(chkLv6 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel6Address[_customerAddress]                     = referralLevel5Address[_referredBy];\r\n            referralBalance_[referralLevel6Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel6Address[_customerAddress]], bonusLv6);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv6);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel5Address[_referredBy], _customerAddress, 6);\r\n            }\r\n        }\r\n        \r\n        // Level 7\r\n        if(chkLv7 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel7Address[_customerAddress]                     = referralLevel6Address[_referredBy];\r\n            referralBalance_[referralLevel7Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel7Address[_customerAddress]], bonusLv7);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv7);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel6Address[_referredBy], _customerAddress, 7);\r\n            }\r\n        }\r\n        \r\n        // Level 8\r\n        if(chkLv8 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel8Address[_customerAddress]                     = referralLevel7Address[_referredBy];\r\n            referralBalance_[referralLevel8Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel8Address[_customerAddress]], bonusLv8);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv8);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel7Address[_referredBy], _customerAddress, 8);\r\n            }\r\n        }\r\n        \r\n        // Level 9\r\n        if(chkLv9 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel9Address[_customerAddress]                     = referralLevel8Address[_referredBy];\r\n            referralBalance_[referralLevel9Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel9Address[_customerAddress]], bonusLv9);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv9);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel8Address[_referredBy], _customerAddress, 9);\r\n            }\r\n        }\r\n        \r\n        // Level 10\r\n        if(chkLv10 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel10Address[_customerAddress]                    = referralLevel9Address[_referredBy];\r\n            referralBalance_[referralLevel10Address[_customerAddress]]  = SafeMath.add(referralBalance_[referralLevel10Address[_customerAddress]], bonusLv10);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv10);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel9Address[_referredBy], _customerAddress, 10);\r\n            }\r\n        }\r\n        \r\n        developerBalance                    = SafeMath.add(developerBalance, remainingRefBonus);\r\n    }\r\n\r\n    function distributeNewBonus(uint256 _incETH, uint256 _amountOfTokens, address _customerAddress, bool _adminTransfer) internal {\r\n        uint256 _newXDMbonus                = 0;\r\n        if(_incETH >= 10 ether && _incETH < 20 ether) {\r\n            _newXDMbonus                    = SafeMath.percent(_amountOfTokens,2,100,18);\r\n        }\r\n        if(_incETH >= 20 ether && _incETH < 50 ether) {\r\n            _newXDMbonus                    = SafeMath.percent(_amountOfTokens,3,100,18);\r\n        }\r\n        if(_incETH >= 50 ether && _incETH < 80 ether) {\r\n            _newXDMbonus                    = SafeMath.percent(_amountOfTokens,5,100,18);\r\n        }\r\n        if(_incETH >= 80 ether && _incETH < 100 ether) {\r\n            _newXDMbonus                    = SafeMath.percent(_amountOfTokens,7,100,18);\r\n        }\r\n        if(_incETH >= 100 ether && _incETH <= 1000 ether) {\r\n            _newXDMbonus                    = SafeMath.percent(_amountOfTokens,8,100,18);\r\n        }\r\n        \r\n        if(_adminTransfer == true) {\r\n            tokenBalanceLedger_[0xcCf40300757585E0f6477031141C6Bd0B72f826B]    = SafeMath.add(tokenBalanceLedger_[0xcCf40300757585E0f6477031141C6Bd0B72f826B], _newXDMbonus);\r\n        } else {\r\n            tokenBalanceLedger_[referralLevel1Address[_customerAddress]]    = SafeMath.add(tokenBalanceLedger_[referralLevel1Address[_customerAddress]], _newXDMbonus);\r\n        }\r\n        tokenSupply_                    = SafeMath.add(tokenSupply_, _newXDMbonus);\r\n    }\r\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) antiEarlyWhale(_incomingEthereum) internal returns(uint256) {\r\n        // data setup\r\n        address _customerAddress            = msg.sender;\r\n        incETH                              = _incomingEthereum;\r\n        // Developer Fees 2%\r\n        developerFee                        = SafeMath.percent(incETH,developerFee_,100,18);\r\n        developerBalance                    = SafeMath.add(developerBalance, developerFee);\r\n        \r\n        _referralBonus                      = SafeMath.percent(incETH,referralPer_,100,18);\r\n        \r\n        uint256 _dividends                  = SafeMath.percent(incETH,dividendFee_,100,18);\r\n        \r\n        uint256 untotalDeduct               = developerFee_ + referralPer_ + dividendFee_;\r\n        uint256 totalDeduct                 = SafeMath.percent(incETH,untotalDeduct,100,18);\r\n        \r\n        uint256 _taxedEthereum              = SafeMath.sub(incETH, totalDeduct);\r\n        uint256 _amountOfTokens             = ethereumToTokens_(_taxedEthereum);\r\n        uint256 _fee                        = _dividends * magnitude;\r\n        bool    _newReferral                = true;\r\n        \r\n        \r\n        if(referralLevel1Address[_customerAddress] != 0x0000000000000000000000000000000000000000) {\r\n            _referredBy                     = referralLevel1Address[_customerAddress];\r\n            _newReferral                    = false;\r\n        }\r\n        \r\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\r\n        // is the user referred by a link?\r\n        if(\r\n            // is this a referred purchase?\r\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\r\n            // no cheating!\r\n            _referredBy != _customerAddress &&\r\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\r\n        ){\r\n            // wealth redistribution\r\n            distributeRefBonus(_referralBonus,_referredBy,_customerAddress,_newReferral);\r\n            if(incETH >= 10 ether && incETH <= 1000 ether) {\r\n                distributeNewBonus(incETH,_amountOfTokens,_customerAddress,false);\r\n            }\r\n        } else {\r\n            // no ref purchase\r\n            // send referral bonus back to admin\r\n            developerBalance                = SafeMath.add(developerBalance, _referralBonus);\r\n            if(incETH >= 10 ether && incETH <= 1000 ether) {\r\n                distributeNewBonus(incETH,_amountOfTokens,_customerAddress,true);\r\n            }\r\n        }\r\n        // we can't give people infinite ethereum\r\n        if(tokenSupply_ > 0){\r\n            // add tokens to the pool\r\n            tokenSupply_                    = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\r\n            profitPerShare_                 += (_dividends * magnitude / (tokenSupply_));\r\n            // calculate the amount of tokens the customer receives over his purchase \r\n            _fee                            = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply_                    = _amountOfTokens;\r\n        }\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        int256 _updatedPayouts              = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\r\n        payoutsTo_[_customerAddress]        += _updatedPayouts;\r\n        // fire event\r\n        onTokenPurchase(_customerAddress, incETH, _amountOfTokens, _referredBy);\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /**\r\n     * Calculate Token price based on an amount of incoming ethereum\r\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\r\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n    function ethereumToTokens_(uint256 _ethereum) internal view returns(uint256) {\r\n        uint256 _tokenPriceInitial          = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived             = \r\n         (\r\n            (\r\n                SafeMath.sub(\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial**2)\r\n                            +\r\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n                            +\r\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\r\n                            +\r\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\r\n                        )\r\n                    ), _tokenPriceInitial\r\n                )\r\n            )/(tokenPriceIncremental_)\r\n        )-(tokenSupply_)\r\n        ;\r\n\r\n        return _tokensReceived;\r\n    }\r\n    \r\n    /**\r\n     * Calculate token sell value.\r\n     */\r\n     function tokensToEthereum_(uint256 _tokens) internal view returns(uint256) {\r\n        uint256 tokens_                     = (_tokens + 2e18);\r\n        uint256 _tokenSupply                = (tokenSupply_ + 2e18);\r\n        uint256 _etherReceived              =\r\n        (\r\n            SafeMath.sub(\r\n                (\r\n                    (\r\n                        (\r\n                            tokenPriceInitial_ +(tokenPriceDecremental_ * (_tokenSupply/2e18))\r\n                        )-tokenPriceDecremental_\r\n                    )*(tokens_ - 2e18)\r\n                ),(tokenPriceDecremental_*((tokens_**2-tokens_)/2e18))/2\r\n            )\r\n        /2e18);\r\n        return _etherReceived;\r\n    }\r\n    \r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stakePercent\",\"type\":\"uint8\"}],\"name\":\"changeStakePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyAmbassadors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"dataId\",\"type\":\"uint256\"}],\"name\":\"getDownlineRef\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"dataId\",\"type\":\"uint256\"},{\"name\":\"refUserAddress\",\"type\":\"address\"},{\"name\":\"refLevel\",\"type\":\"uint256\"}],\"name\":\"migrateDownlineRef\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"stakeTokensBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefUser\",\"outputs\":[{\"name\":\"refUserAddress\",\"type\":\"address\"},{\"name\":\"refLevel\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseStake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeveloperBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"stakeTokensTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"migrateTotalSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"setStakingRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableInitialStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"referralCountM_\",\"type\":\"uint256\"}],\"name\":\"migrateXdmBalanceNcount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"drainDeveloperFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"ref1\",\"type\":\"address\"},{\"name\":\"ref2\",\"type\":\"address\"},{\"name\":\"ref3\",\"type\":\"address\"},{\"name\":\"ref4\",\"type\":\"address\"},{\"name\":\"ref5\",\"type\":\"address\"},{\"name\":\"ref6\",\"type\":\"address\"},{\"name\":\"ref7\",\"type\":\"address\"},{\"name\":\"ref8\",\"type\":\"address\"},{\"name\":\"ref9\",\"type\":\"address\"},{\"name\":\"ref10\",\"type\":\"address\"}],\"name\":\"migrateTenLvlReferral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"dividendBal_\",\"type\":\"uint256\"},{\"name\":\"referralBalanceM_\",\"type\":\"uint256\"}],\"name\":\"migrateDividendNReferralBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"MtokenSupply_\",\"type\":\"uint256\"}],\"name\":\"migrateTotalSupplyOnce\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getref\",\"outputs\":[{\"name\":\"lv\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCount_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"XcelDream","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bedeeac9df32bc59e8ff433a0472dc6d4b7363efd94d2e62b57f1f37b483ba80"}]}