{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n* Copyright (c) 2020 DeFiat.net\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n//\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\npragma solidity ^0.6.0;\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath{\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    \r\n        /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n} //adding ALLOWED method\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\n//========\r\n\r\n\r\ncontract DeFiat_Farming_v15 {\r\n    using SafeMath for uint256;\r\n\r\n    //Structs\r\n    struct PoolMetrics {\r\n        address stakedToken;\r\n        uint256 staked;             // sum of tokens staked in the contract\r\n        uint256 stakingFee;         // entry fee\r\n        \r\n        uint256 stakingPoints;\r\n\r\n        address rewardToken;\r\n        uint256 rewards;        // current rewards in the pool\r\n\r\n        uint256 startTime;      // when the pool opens\r\n        uint256 closingTime;    // when the pool closes. \r\n        uint256 duration;       // duration of the staking\r\n        uint256 lastEvent;   // last time metrics were updated.\r\n        \r\n        uint256  ratePerToken;      // CALCULATED pool reward Rate per Token (calculated based on total stake and time)\r\n    }\r\n    PoolMetrics public poolMetrics;\r\n\r\n    struct UserMetrics {\r\n            uint256 stake;          // native token stake (balanceOf)\r\n            uint256 stakingPoints;  // staking points at lastEvent\r\n            uint256 poolPoints;     // pool point at lastEvent\r\n            uint256 lastEvent;\r\n\r\n            uint256 rewardAccrued;  // accrued rewards over time based on staking points\r\n            uint256 rewardsPaid;    // for information only\r\n\r\n            uint256 lastTxBlock;    // latest transaction from the user (antiSpam)\r\n    }\r\n    mapping(address => UserMetrics) public userMetrics;\r\n\r\n//== constructor \r\n    constructor(address _stakedToken, address _rewardToken, uint256 _feeBase1000, uint256 _durationHours, uint256 _delayStartHours) public {\r\n    poolOperator = msg.sender;\r\n    \r\n    poolMetrics.stakedToken = address(_stakedToken);\r\n    poolMetrics.rewardToken = address(_rewardToken);\r\n    poolMetrics.stakingFee = _feeBase1000; //10 = 1%\r\n    \r\n    poolMetrics.duration = _durationHours.mul(3600); //\r\n    poolMetrics.startTime = block.timestamp + _delayStartHours.mul(3600);\r\n    poolMetrics.closingTime = poolMetrics.startTime + poolMetrics.duration; //corrected following report\r\n    \r\n    poolMetrics.stakingPoints = 1; //avoids div by 0 at start\r\n    FullRewards = true;\r\n    }\r\n\r\n//==Events\r\n    event PoolInitalized(uint256 amountAdded, string  _desc);\r\n    event RewardTaken(address indexed user, uint256 reward, string  _desc);\r\n\r\n    event userStaking(address indexed user, uint256 amount, string  _desc);\r\n    event userWithdrawal(address indexed user, uint256 amount, string  _desc);\r\n\r\n    modifier poolLive() {\r\n        require(block.timestamp >= poolMetrics.startTime,\"Pool not started Yet\"); //good for delayed starts.\r\n        require(block.timestamp <= poolMetrics.closingTime,\"Pool closed\"); //good for delayed starts.\r\n        _;\r\n    }\r\n    modifier poolStarted() {\r\n        require(block.timestamp >= poolMetrics.startTime,\"Pool not started Yet\"); //good for delayed starts.\r\n        _;\r\n    }\r\n    modifier poolEnded() {\r\n        require(block.timestamp > poolMetrics.closingTime,\"Pool not ended Yet\"); //good for delayed starts.\r\n        _;\r\n    }\r\n    modifier antiSpam(uint256 _blocks) {\r\n        require(block.number > userMetrics[msg.sender].lastTxBlock.add(_blocks), \"Wait X BLOCKS between Transactions\");\r\n        userMetrics[msg.sender].lastTxBlock = block.number; //update\r\n        _;\r\n    } \r\n    \r\n//==Basics \r\n    function currentTime() public view returns (uint256) {\r\n        return SafeMath.min(block.timestamp, poolMetrics.closingTime); //allows expiration\r\n    } // SafeMath.min(now, endTime)\r\n    \r\n//==Points locking    \r\n    function viewPoolPoints() public view returns(uint256) {\r\n            uint256 _previousPoints = poolMetrics.stakingPoints;    // previous points shapshot \r\n            uint256 _previousStake = poolMetrics.staked;             // previous stake snapshot\r\n            \r\n            uint256 _timeHeld = currentTime().sub(\r\n                        SafeMath.max(poolMetrics.lastEvent, poolMetrics.startTime)\r\n                                                 );                 // time held with _previous Event\r\n                                                 \r\n            return  _previousPoints.add(_previousStake.mul(_timeHeld));    //generated points since event\r\n    }\r\n    function lockPoolPoints() internal returns (uint256) { //ON STAKE/UNSTAKE EVENT\r\n            poolMetrics.stakingPoints = viewPoolPoints();\r\n            poolMetrics.lastEvent = currentTime();   // update lastStakingEvent\r\n            return poolMetrics.stakingPoints;\r\n        } \r\n    \r\n    function viewPointsOf(address _address) public view returns(uint256) {\r\n            uint256 _previousPoints = userMetrics[_address].stakingPoints;    // snapshot\r\n            uint256 _previousStake = userMetrics[_address].stake;             // stake before event\r\n        \r\n            uint256 _timeHeld = currentTime().sub(\r\n                        SafeMath.max(userMetrics[_address].lastEvent, poolMetrics.startTime)\r\n                                                 );                          // time held since lastEvent (take RWD, STK, unSTK)\r\n            \r\n            uint256 _result = _previousPoints.add(_previousStake.mul(_timeHeld));   \r\n            \r\n            if(_result > poolMetrics.stakingPoints){_result = poolMetrics.stakingPoints;}\r\n            return _result;\r\n    }\r\n    function lockPointsOf(address _address) internal returns (uint256) {\r\n            userMetrics[_address].poolPoints = viewPoolPoints();  // snapshot of pool points at lockEvent\r\n            userMetrics[_address].stakingPoints = viewPointsOf(_address); \r\n            userMetrics[_address].lastEvent = currentTime(); \r\n\r\n            return userMetrics[_address].stakingPoints;\r\n    }\r\n    function pointsSnapshot(address _address) public returns (bool) {\r\n        lockPointsOf(_address);lockPoolPoints();\r\n        return true;\r\n    }\r\n    \r\n//==Rewards\r\n    function viewTrancheReward(uint256 _period) internal view returns(uint256) {\r\n        //uint256 _poolRewards = poolMetrics.rewards; //tokens in the pool. Note: This can be setup to a fixed amount (totalRewards)\r\n        uint256 _poolRewards = totalRewards; \r\n        \r\n        if(FullRewards == false){ _poolRewards = SafeMath.min(poolMetrics.staked, _poolRewards);} \r\n        // baseline is the min( staked, rewards); avoids ultra_farming > staking pool - EXPERIMENTAL\r\n        \r\n        uint256 _timeRate = _period.mul(1e18).div(poolMetrics.duration);\r\n        return _poolRewards.mul(_timeRate).div(1e18); //tranche of rewards on period\r\n    }\r\n    \r\n    function userRateOnPeriod(address _address) public view returns (uint256){\r\n        //calculates the delta of pool points and user points since last Event\r\n        uint256 _deltaUser = viewPointsOf(_address).sub(userMetrics[_address].stakingPoints); // points generated since lastEvent\r\n        uint256 _deltaPool = viewPoolPoints().sub(userMetrics[_address].poolPoints);          // pool points generated since lastEvent\r\n        uint256 _rate = 0;\r\n        if(_deltaUser == 0 || _deltaPool == 0 ){_rate = 0;} //rounding\r\n        else {_rate = _deltaUser.mul(1e18).div(_deltaPool);}\r\n        return _rate;\r\n        \r\n    }\r\n    \r\n    function viewAdditionalRewardOf(address _address) public view returns(uint256) { // rewards generated since last Event\r\n        require(poolMetrics.rewards > 0, \"No Rewards in the Pool\");\r\n        \r\n  \r\n        // user weighted average share of Pool since lastEvent\r\n        uint256 _userRateOnPeriod = userRateOnPeriod(_address); //can drop if pool size increases within period -> slows rewards generation\r\n        \r\n        // Pool Yield Rate \r\n        uint256 _period = currentTime().sub(\r\n                            SafeMath.max(userMetrics[_address].lastEvent, poolMetrics.startTime)  \r\n                            );        // time elapsed since last reward or pool started (if never taken rewards)\r\n\r\n        // Calculate reward\r\n        uint256 _reward = viewTrancheReward(_period).mul(_userRateOnPeriod).div(1e18);  //user rate on pool rewards' tranche\r\n\r\n        return _reward;\r\n    }\r\n    \r\n    function lockRewardOf(address _address) public returns(uint256) {\r\n        uint256 _additional = viewAdditionalRewardOf(_address); //stakeShare(sinceLastEvent) * poolRewards(sinceLastEvent)\r\n        userMetrics[_address].rewardAccrued = userMetrics[_address].rewardAccrued.add(_additional); //snapshot rewards.\r\n        \r\n        pointsSnapshot(_address); //updates lastEvent and points\r\n        return userMetrics[_address].rewardAccrued;\r\n    }  \r\n    \r\n    function takeRewards() public poolStarted antiSpam(1) { //1 blocks between rewards\r\n        require(poolMetrics.rewards > 0, \"No Rewards in the Pool\");\r\n        \r\n        uint256 _reward = lockRewardOf(msg.sender); //returns already accrued + additional (also resets time counters)\r\n\r\n        userMetrics[msg.sender].rewardsPaid = _reward;   // update user paid rewards\r\n        \r\n        userMetrics[msg.sender].rewardAccrued = 0; //flush previously accrued rewards.\r\n        \r\n        poolMetrics.rewards = poolMetrics.rewards.sub(_reward);           // update pool rewards\r\n            \r\n        IERC20(poolMetrics.rewardToken).transfer(msg.sender, _reward);  // transfer\r\n            \r\n        pointsSnapshot(msg.sender); //updates lastEvent\r\n        //lockRewardOf(msg.sender);\r\n            \r\n        emit RewardTaken(msg.sender, _reward, \"Rewards Sent\");          \r\n    }\r\n    \r\n//==staking & unstaking\r\n\r\n    modifier antiWhale(address _address) {\r\n        require(myStakeShare(_address) < 20000, \"User stake% share too high. Leave some for the smaller guys ;-)\"); //max 20%\r\n        _;\r\n    } \r\n    // avoids stakes being deposited once a user reached 20%. \r\n    // Simplistic implementation as if we calculate \"futureStake\" value very 1st stakers will not be able to deposit.\r\n    \r\n    function stake(uint256 _amount) public poolLive antiSpam(1) antiWhale(msg.sender){\r\n        require(_amount > 0, \"Cannot stake 0\");\r\n        \r\n        //initialize\r\n        userMetrics[msg.sender].rewardAccrued = lockRewardOf(msg.sender); //Locks previous eligible rewards based on lastRewardEvent and lastStakingEvent\r\n        pointsSnapshot(msg.sender);\r\n\r\n        //receive staked\r\n        uint256 _balanceNow = IERC20(address(poolMetrics.stakedToken)).balanceOf(address(this));\r\n        IERC20(poolMetrics.stakedToken).transferFrom(msg.sender, address(this), _amount); //will require allowance\r\n        uint256 amount = IERC20(address(poolMetrics.stakedToken)).balanceOf(address(this)).sub(_balanceNow); //actually received\r\n        \r\n        //update pool and user based on stake and fee\r\n        uint256 _fee = amount.mul(poolMetrics.stakingFee).div(1000);\r\n        amount = amount.sub(_fee);\r\n        \r\n        if(poolMetrics.stakedToken == poolMetrics.rewardToken){poolMetrics.rewards = poolMetrics.rewards.add(_fee);}\r\n        poolMetrics.staked = poolMetrics.staked.add(amount);\r\n        userMetrics[msg.sender].stake = userMetrics[msg.sender].stake.add(amount);\r\n\r\n        //finalize\r\n        pointsSnapshot(msg.sender); //updates lastEvent\r\n        emit userStaking(msg.sender, amount, \"Staking... ... \");\r\n        \r\n    } \r\n    \r\n    function unStake(uint256 _amount) public poolStarted antiSpam(1) { \r\n        require(_amount > 0, \"Cannot withdraw 0\");\r\n        require(_amount <= userMetrics[msg.sender].stake, \"Cannot withdraw more than stake\");\r\n\r\n        //initialize\r\n        userMetrics[msg.sender].rewardAccrued = lockRewardOf(msg.sender); //snapshot of  previous eligible rewards based on lastStakingEvent\r\n        pointsSnapshot(msg.sender);\r\n\r\n        // update metrics\r\n        userMetrics[msg.sender].stake = userMetrics[msg.sender].stake.sub(_amount);\r\n        poolMetrics.staked = poolMetrics.staked.sub(_amount);\r\n\r\n        // transfer _amount. Put at the end of the function to avoid reentrancy.\r\n        IERC20(poolMetrics.stakedToken).transfer(msg.sender, _amount);\r\n        \r\n        //finalize\r\n        emit userWithdrawal(msg.sender, _amount, \"Widhtdrawal\");\r\n    }\r\n\r\n    function myStake(address _address) public view returns(uint256) {\r\n        return userMetrics[_address].stake;\r\n    }\r\n    function myStakeShare(address _address) public view returns(uint256) {\r\n        if(poolMetrics.staked == 0){return 0;}\r\n        else {\r\n        return (userMetrics[_address].stake).mul(100000).div(poolMetrics.staked);}\r\n    } //base 100,000\r\n    function myPointsShare(address _address) public view returns(uint256) {  //weighted average of your stake over time vs the pool\r\n        return viewPointsOf(_address).mul(100000).div(viewPoolPoints());\r\n    } //base 100,000. Drops when taking rewards.=> Refills after (favors strong hands)\r\n    function myRewards(address _address) public view returns(uint256) {\r\n        //delayed start obfuscation (avoids disturbances in the force...)\r\n        if(block.timestamp <= poolMetrics.startTime || poolMetrics.rewards == 0){return 0;}\r\n        else { return userMetrics[_address].rewardAccrued.add(viewAdditionalRewardOf(_address));} //previousLock + time based extra\r\n    }\r\n\r\n//== OPERATOR FUNCTIONS ==\r\n\r\n    address public poolOperator;\r\n    \r\n    function setPoolOperator(address _address) public onlyPoolOperator {\r\n        poolOperator = _address;\r\n    }\r\n    modifier onlyPoolOperator() {\r\n        require(msg.sender == poolOperator, \"msg.sender is not allowed to operate Pool\");\r\n        _;\r\n    }\r\n    \r\n    bool public FullRewards;\r\n    uint256 totalRewards;\r\n    \r\n    function setFullRewards(bool _bool) public onlyPoolOperator {\r\n        FullRewards = _bool;\r\n    }\r\n    function loadRewards(uint256 _amount, uint256 _preStake) public onlyPoolOperator { //load tokens in the rewards pool.\r\n        \r\n        uint256 _balanceNow = IERC20(address(poolMetrics.rewardToken)).balanceOf(address(this));\r\n        IERC20(address(poolMetrics.rewardToken)).transferFrom( msg.sender,  address(this),  _amount);\r\n        uint256 amount = IERC20(address(poolMetrics.rewardToken)).balanceOf(address(this)).sub(_balanceNow); //actually received\r\n        \r\n\r\n        if(poolMetrics.rewards == 0){                                   // initialization\r\n        poolMetrics.staked = SafeMath.add(poolMetrics.staked,_preStake);}  // creates baseline for pool. Avoids massive movements on rewards\r\n        \r\n        poolMetrics.rewards = SafeMath.add(poolMetrics.rewards,amount);\r\n        totalRewards = totalRewards.add(_amount);\r\n    }    \r\n    function setFee(uint256 _fee) public onlyPoolOperator {\r\n        poolMetrics.stakingFee = _fee;\r\n    }\r\n    \r\n    function flushPool(address _recipient, address _ERC20address) external onlyPoolOperator poolEnded { // poolEnded { // poolEnded returns(bool) {\r\n            uint256 _amount = IERC20(_ERC20address).balanceOf(address(this));\r\n            IERC20(_ERC20address).transfer(_recipient, _amount); //use of the _ERC20 traditional transfer\r\n            //return true;\r\n        } //get tokens sent by error to contract\r\n    function killPool() public onlyPoolOperator poolEnded returns(bool) {\r\n            selfdestruct(msg.sender);\r\n        } //frees space on the ETH chain\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeBase1000\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_durationHours\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_delayStartHours\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_desc\",\"type\":\"string\"}],\"name\":\"PoolInitalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_desc\",\"type\":\"string\"}],\"name\":\"RewardTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_desc\",\"type\":\"string\"}],\"name\":\"userStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_desc\",\"type\":\"string\"}],\"name\":\"userWithdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FullRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ERC20address\",\"type\":\"address\"}],\"name\":\"flushPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"killPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_preStake\",\"type\":\"uint256\"}],\"name\":\"loadRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"lockRewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"myPointsShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"myRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"myStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"myStakeShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"pointsSnapshot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolMetrics\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stakedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"staked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastEvent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratePerToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setFullRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setPoolOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userMetrics\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastEvent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTxBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"userRateOnPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"viewAdditionalRewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"viewPointsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewPoolPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DeFiat_Farming_v15","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b6ee603933e024d8d53dde3faa0bf98fe2a3d6f1000000000000000000000000b6ee603933e024d8d53dde3faa0bf98fe2a3d6f1000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000009c40000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://54e10d7ee9a5290993687d13cd1c792a41536866343c7a048650a141d01ce838"}]}