{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-02-25\r\n*/\r\n\r\npragma solidity ^0.5.12;\r\n\r\ninterface IERC20 {\r\n    function balanceOf   (address)                external view returns (uint256);\r\n    function approve     (address, uint256)       external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function transfer    (address, uint256)       external returns (bool);\r\n}\r\n\r\ncontract GemJoin {\r\n    function join(address, uint) public;\r\n    function exit(address, uint) public;\r\n}\r\n\r\ncontract CdpManager {\r\n    function open(bytes32, address) external returns (uint);\r\n    function frob(uint, int, int) external;\r\n    function move(uint, address, uint) external;\r\n    function flux(uint, address, uint) external;\r\n    function urns(uint) view external returns (address);\r\n}\r\n\r\ncontract Vat {\r\n    function hope(address usr) external;\r\n}\r\n\r\ncontract DirectBTCProxy {\r\n\r\n    uint256 constant RAY  = 10 ** 27; // This is what MakerDAO uses.\r\n    uint256 constant NORM = 10 ** 10; // This is the difference between 18\r\n                                      // decimals in ERC20s and 8 in BTC\r\n                                      // TODO: fix if we make more generic\r\n\r\n    IERC20 public btc; // WBTC.\r\n    IERC20 public dai;  // Dai.\r\n\r\n    bytes32    public ilk;\r\n    CdpManager public manager;\r\n    GemJoin    public daiGemJoin;\r\n    GemJoin    public btcGemJoin;\r\n    Vat        public daiVat;\r\n\r\n    mapping (address => mapping(address => uint256)) cdpids;\r\n\r\n    constructor(\r\n        address _btc,\r\n        address _dai,\r\n\r\n        bytes32 _ilk,\r\n        address _manager,\r\n        address _daiGemJoin,\r\n        address _btcGemJoin,\r\n        address _daiVat\r\n    ) public {\r\n        btc = IERC20(_btc);  // TODO: perhaps we can make this more generic\r\n        dai  = IERC20(_dai);\r\n\r\n        ilk         = _ilk;\r\n        manager     = CdpManager(_manager);\r\n        daiGemJoin  = GemJoin(_daiGemJoin);\r\n        btcGemJoin = GemJoin(_btcGemJoin);\r\n        daiVat      = Vat(_daiVat);\r\n\r\n        daiVat.hope(address(daiGemJoin));\r\n        require(btc.approve(_btcGemJoin, uint(-1)), \"err: approve BTC token\");\r\n        require(dai.approve(_daiGemJoin, uint(-1)), \"err approve: dai\");\r\n    }\r\n\r\n    function borrow(\r\n        address _owner, // CDP owner (if CDP doesn't exist one will be created)\r\n        int     _dink,  // Amount of zBTC to collateralize (18 decimals)\r\n        int     _dart   // Amount of Dai to borrow (18 decimals)\r\n    ) external {\r\n        require(_owner != address(this), \"err: self-reference\");\r\n        require(_dink >= 0, \"err: negative dink\");\r\n        require(_dart >= 0, \"err: negative dart\");\r\n\r\n        // Create CDP\r\n        uint256 cdpid = cdpids[msg.sender][_owner];\r\n        if (cdpid == 0) {\r\n            cdpid = manager.open(ilk, address(this));\r\n            cdpids[msg.sender][_owner] = cdpid;\r\n        }\r\n\r\n        btcGemJoin.join(manager.urns(cdpid), uint(_dink)/NORM);\r\n\r\n        manager.frob(cdpid, _dink, _dart);\r\n        manager.move(cdpid, address(this), uint(_dart) * RAY);\r\n        daiGemJoin.exit(_owner, uint(_dart));\r\n    }\r\n\r\n    function repay(\r\n        address _owner, // CDP owner\r\n        int     _dink,  // Amount of zBTC to reclaim (with 18 decimal places).\r\n        int     _dart   // Amount of Dai to repay\r\n    ) external {\r\n        require(_owner != address(this), \"err: self-reference\");\r\n        require(_dink >= 0, \"err: negative dink\");\r\n        require(_dart >= 0, \"err: negative dart\");\r\n\r\n        uint256 cdpid = cdpids[msg.sender][_owner];\r\n        require(cdpid != 0, \"err: vault not found\");\r\n\r\n        // Join Dai into the gem\r\n        daiGemJoin.join(manager.urns(cdpid), uint(_dart));\r\n\r\n        // Lower the debt and exit some collateral\r\n        manager.frob(cdpid, -_dink, -_dart);\r\n        manager.flux(cdpid, address(this), uint(_dink));\r\n        btcGemJoin.exit(address(this), uint(_dink)/NORM);\r\n\r\n        // Send reclaimed collateral to the msg.sender.\r\n        btc.transfer(msg.sender, uint(_dink)/NORM);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_btc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_ilk\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_daiGemJoin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_btcGemJoin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_daiVat\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"_dink\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_dart\",\"type\":\"int256\"}],\"name\":\"borrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btc\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btcGemJoin\",\"outputs\":[{\"internalType\":\"contract GemJoin\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiGemJoin\",\"outputs\":[{\"internalType\":\"contract GemJoin\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiVat\",\"outputs\":[{\"internalType\":\"contract Vat\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ilk\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract CdpManager\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"_dink\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_dart\",\"type\":\"int256\"}],\"name\":\"repay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DirectBTCProxy","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c5990000000000000000000000006b175474e89094c44da98b954eedeac495271d0f574254432d4100000000000000000000000000000000000000000000000000000000000000000000000000005ef30b9986345249bc32d8928b7ee64de9435e390000000000000000000000009759a6ac90977b93b58547b4a71c78317f391a28000000000000000000000000bf72da2bd84c5170618fbe5914b0eca9638d5eb500000000000000000000000035d1b3f3d7966a1dfe207aa4514c12a259a0492b","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0be002f093b4e9b506311902f021bbc59a2f4031932f0b0db293e84140081bdd"}]}