// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721Holder.sol";
import "@openzeppelin/contracts/introspection/ERC165.sol";
import "@openzeppelin/contracts/introspection/IERC1820Registry.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@prps/solidity/contracts/IBoostableERC20.sol";
import "./DubiexLib.sol";
import "./Boostable.sol";

/**
 * @dev The Dubiex contract
 *
 * Supported currencies:
 * - ETH
 * - ERC20
 * - BoostedERC20
 * - ERC721
 *
 * Any owner of ERC721 tokens may wish to approve Dubiex for all his/her tokens,
 * by calling `setApprovalForAll()`. Then approval for subsequent trades isn't required either.
 *
 * ERC20 can be approved once with an practically-infinite amount, then Dubiex requires
 * approval only once as well.
 *
 * BoostedERC20 tokens are designed to work without any explicit approval for Dubiex.
 *
 * External functions:
 * - makeOrder(s)
 * - takeOrder(s)
 * - cancelOrder(s)
 * - getOrder()
 * - boostedMakeOrder(Batch)
 * - boostedTakeOrder(Batch)
 * - boostedCanceleOrder(Batch)
 *
 */
contract Dubiex is ReentrancyGuard, ERC721Holder, Boostable {
    using SafeERC20 for IERC20;

    bytes32 private constant _BOOSTABLE_ERC20_TOKEN_HASH = keccak256(
        "BoostableERC20Token"
    );

    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/token/ERC721/ERC721.sol#L68
    bytes4 private constant _ERC721_INTERFACE_HASH = 0x80ac58cd;

    IERC1820Registry private constant _ERC1820_REGISTRY = IERC1820Registry(
        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24
    );

    // This is a empty order to workaround:
    // "This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour"
    // In places where we need to return a zero-initialized storage order.
    DubiexLib.PackedOrderBookItem private emptyOrder;

    // Only required for burning fuel
    address private immutable _prps;
    address private immutable _dubi;

    // Security mechanism which anyone can enable if the total supply of PRPS or DUBI should ever go >= 1 billion
    bool private _killSwitchOn;

    function activateKillSwitch() public {
        require(!_killSwitchOn, "Dubiex: kill switch already on");

        uint256 oneBillion = 1000000000 * 1 ether;

        uint256 totalPrpsSupply = IERC20(_prps).totalSupply();
        uint256 totalDubiSupply = IERC20(_dubi).totalSupply();

        require(
            totalPrpsSupply >= oneBillion || totalDubiSupply >= oneBillion,
            "Dubiex: insufficient total supply for kill switch"
        );
        _killSwitchOn = true;
    }

    constructor(
        address optIn,
        address prps,
        address dubi
    ) public ReentrancyGuard() Boostable(optIn) {
        _prps = prps;
        _dubi = dubi;
    }

    event MadeOrder(
        uint32 id,
        address maker,
        // uint96 makerValue, uint96 takerValue, uint32 orderPairAlias, uint32 padding
        uint256 packedData
    );

    event TookOrder(
        uint32 id,
        address maker,
        address taker,
        // uint96 makerValue, uint96 takerValue, uint32 orderPairAlias, uint32 padding
        uint256 packedData
    );
    event CanceledOrder(address maker, uint32 id);

    event UpdatedOrder(address maker, uint32 id);

    /**
     * @dev Order pair aliases are generated by incrementing a number. Although the counter
     * is using 32 bits, we do not support more than 2**28 = 268_435_456 pairs for technical reasons.
     */
    uint32 private _orderPairAliasCounter;

    /**
     * @dev A mapping of order pair alias to a packed order pair.
     */
    mapping(uint32 => DubiexLib.PackedOrderPair) private _orderPairsByAlias;
    /**
     * @dev A reverse mapping of order pair hash to an order pair alias. Required to check if
     * a given pair already exists when creating an order where the full pair information are
     * provided instead of an alias. I.e.
     * MakeOrder {
     *    ...
     *    makerCurrencyType: ...,
     *    takerCurrencyType: ...,
     *    makerContractAddress: ...,
     *    takerContractAddress: ...,
     * }
     *
     * The hash of these four fields is used as the key of the mapping.
     */
    mapping(bytes32 => uint32) private _orderPairAliasesByHash;

    /**
     * @dev Mapping of address to a counter for order ids.
     */
    mapping(address => uint32) private _counters;

    /**
     * @dev Mapping of address to packed order book items.
     */
    mapping(address => DubiexLib.PackedOrderBookItem[])
        private _ordersByAddress;

    /**
     * @dev Get an order by id. If the id doesn't exist (e.g. got cancelled / filled), a default order is returned.
     * The caller should therefore check the id of the returned item. Any non-zero value means the order exists.
     */
    function getOrder(address maker, uint64 id)
        public
        view
        returns (DubiexLib.PrettyOrderBookItem memory)
    {

            DubiexLib.PackedOrderBookItem[] storage orders
         = _ordersByAddress[maker];
        for (uint256 i = 0; i < orders.length; i++) {
            DubiexLib.PackedOrderBookItem storage _packed = orders[i];
            DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib
                .unpackOrderBookItem(_packed.packedData);

            if (_unpacked.id == id) {
                DubiexLib.PrettyOrderBookItem memory pretty;
                pretty.id = _unpacked.id;
                pretty.makerValue = _unpacked.makerValue;
                pretty.takerValue = _unpacked.takerValue;

                pretty.orderPairAlias = _unpacked.orderPairAlias;
                pretty.pair = getOrderPairByAlias(_unpacked.orderPairAlias);

                pretty.flags = _unpacked.flags;

                pretty.successorOrderId = _packed.successorOrderId;
                pretty.ancestorOrderId = _packed.ancestorOrderId;

                return pretty;
            }
        }

        DubiexLib.PrettyOrderBookItem memory empty;
        return empty;
    }

    /**
     * @dev Get an order pair by alias.
     */
    function getOrderPairByAlias(uint32 orderPairAlias)
        public
        view
        returns (DubiexLib.OrderPair memory)
    {
        DubiexLib.OrderPair memory orderPair;


            DubiexLib.PackedOrderPair storage packedOrderPair
         = _orderPairsByAlias[orderPairAlias];

        (
            address makerContractAddress,
            DubiexLib.CurrencyType makerCurrencyType
        ) = DubiexLib.unpackOrderPairAddressType(packedOrderPair.makerPair);

        (
            address takerContractAddress,
            DubiexLib.CurrencyType takerCurrencyType
        ) = DubiexLib.unpackOrderPairAddressType(packedOrderPair.takerPair);

        orderPair.makerContractAddress = makerContractAddress;
        orderPair.makerCurrencyType = makerCurrencyType;
        orderPair.takerContractAddress = takerContractAddress;
        orderPair.takerCurrencyType = takerCurrencyType;

        return orderPair;
    }

    /**
     * @dev Get an order pair by it's hash.
     */
    function getOrderPairByHash(bytes32 orderPairHash)
        public
        view
        returns (DubiexLib.OrderPair memory)
    {
        uint32 orderPairAlias = _orderPairAliasesByHash[orderPairHash];
        return getOrderPairByAlias(orderPairAlias);
    }

    /**
     * @dev Get an order pair alias by it's hash.
     */
    function getOrderPairAliasByHash(bytes32 orderPairHash)
        public
        view
        returns (uint32)
    {
        return _orderPairAliasesByHash[orderPairHash];
    }

    /**
     * @dev Make a single order. Reverts on failure.
     *
     * If an `orderId` is provided, an already existing order will be updated
     * according to `updatedWeiRatio`. For efficiency reasons, the id of the updated order
     * remains the same. Taker orders provide a minimum ratio to protect themselves against
     * front-running by the maker.
     *
     * Returns the assigned order id.
     */
    function makeOrder(DubiexLib.MakeOrderInput memory input)
        external
        payable
        nonReentrant
        returns (uint32)
    {
        require(!_killSwitchOn, "Dubiex: make order prevented by kill switch");

        uint256 excessEth = msg.value;
        uint32 orderId;

        (orderId, excessEth) = _makeOrderInternal({
            input: input,
            maker: msg.sender,
            excessEthAndIntrinsicFuel: excessEth,
            isBoosted: false,
            revertOnUpdateError: true
        });

        _refundExcessEth(excessEth);

        return orderId;
    }

    /**
     * @dev Create multiple orders at once. The transaction won't revert if any make order fails, but
     * silently ignore it. Returns an array of order ids where each item corresponds to an input
     * at the same index and non-zero values indicate success.
     */
    function makeOrders(DubiexLib.MakeOrderInput[] memory inputs)
        external
        payable
        nonReentrant
        returns (uint32[] memory)
    {
        require(!_killSwitchOn, "Dubiex: make order prevented by kill switch");
        require(inputs.length > 0, "Dubiex: empty inputs");

        uint32[] memory orderIds = new uint32[](inputs.length);

        uint256 excessEth = msg.value;

        for (uint256 i = 0; i < inputs.length; i++) {
            uint32 orderId;

            (orderId, excessEth) = _makeOrderInternal({
                input: inputs[i],
                maker: msg.sender,
                excessEthAndIntrinsicFuel: excessEth,
                isBoosted: false,
                revertOnUpdateError: false
            });

            orderIds[i] = orderId;
        }

        _refundExcessEth(excessEth);

        return orderIds;
    }

    /**
     * @dev Take a single order. Reverts on failure.
     */
    function takeOrder(DubiexLib.TakeOrderInput calldata input)
        external
        payable
        nonReentrant
    {
        require(!_killSwitchOn, "Dubiex: take order prevented by kill switch");

        uint256 excessEth = msg.value;

        (, excessEth, ) = _takeOrderInternal({
            input: input,
            taker: msg.sender,
            excessEthAndIntrinsicFuel: excessEth,
            revertOnError: true,
            isBoosted: false
        });

        _refundExcessEth(excessEth);
    }

    /**
     * @dev Take multiple orders at once. The transaction won't revert if any take order fails, but
     * silently ignore it. Check the logs in the receipt to see if any failed.
     *
     * See `takeOrder` for more information about the opt-in.
     *
     * @param inputs the take order inputs
     */
    function takeOrders(DubiexLib.TakeOrderInput[] calldata inputs)
        external
        payable
        nonReentrant
        returns (bool[] memory)
    {
        require(!_killSwitchOn, "Dubiex: take order prevented by kill switch");
        require(inputs.length > 0, "Dubiex: empty inputs");

        bool[] memory result = new bool[](inputs.length);

        uint256 excessEth = msg.value;

        for (uint256 i = 0; i < inputs.length; i++) {
            bool success;
            (success, excessEth, ) = _takeOrderInternal({
                input: inputs[i],
                taker: msg.sender,
                excessEthAndIntrinsicFuel: uint96(excessEth),
                revertOnError: false,
                isBoosted: false
            });

            result[i] = success;
        }

        _refundExcessEth(excessEth);

        return result;
    }

    /**
     * @dev Cancel a single order.
     */
    function cancelOrder(DubiexLib.CancelOrderInput memory input)
        external
        nonReentrant
    {
        _cancelOrderInternal({
            maker: input.maker,
            id: input.id,
            intrinsicFuel: 0,
            isBoosted: false,
            revertOnError: true,
            isKillSwitchOn: _killSwitchOn
        });
    }

    /**
     * @dev Cancel multiple orders at once. It will not revert on error, but ignore failed
     * orders silently. Check the logs in the receipt to see if any failed.
     *
     * @return Array of booleans with `ids.length` items where each item corresponds to an id
     * at the same index and `true` indicate success.
     */
    function cancelOrders(DubiexLib.CancelOrderInput[] calldata inputs)
        external
        nonReentrant
        returns (bool[] memory)
    {
        require(inputs.length > 0, "Dubiex: empty inputs");

        bool[] memory result = new bool[](inputs.length);

        bool isKillSwitchOn = _killSwitchOn;

        for (uint256 i = 0; i < inputs.length; i++) {
            result[i] = _cancelOrderInternal({
                maker: inputs[i].maker,
                id: inputs[i].id,
                intrinsicFuel: 0,
                isBoosted: false,
                revertOnError: false,
                isKillSwitchOn: isKillSwitchOn
            });
        }

        return result;
    }

    /**
     * @dev Create an order for the signer of `signature`.
     */
    function boostedMakeOrder(
        BoostedMakeOrder memory order,
        Signature memory signature
    ) public payable nonReentrant returns (uint32) {
        require(!_killSwitchOn, "Dubiex: make order prevented by kill switch");

        uint32 orderId;
        uint256 excessEth = msg.value;
        (orderId, excessEth) = _boostedMakeOrderInternal(
            order,
            signature,
            excessEth,
            true
        );

        _refundExcessEth(excessEth);
        return orderId;
    }

    function _boostedMakeOrderInternal(
        BoostedMakeOrder memory order,
        Signature memory signature,
        uint256 excessEth,
        bool revertOnUpdateError
    ) private returns (uint32, uint256) {
        uint96 intrinsicFuel = _burnFuel(order.maker, order.fuel);

        // We optimize ERC721 sell orders by not increasing the
        // nonce, because every ERC721 is unique - trying to replay the
        // transaction while the signature hasn't expired yet is almost
        // guaranteed to always fail. The only scenarios where it would be
        // possible is:
        // - if the order gets cancelled
        // - the order is filled by the maker OR the taker sends it back to the maker
        //
        // But this all has to happen in a very short timeframe, so the chance of this happening
        // is really low.
        //
        if (
            order.input.pair.makerCurrencyType == DubiexLib.CurrencyType.ERC721
        ) {
            _verifyBoostWithoutNonce(
                order.maker,
                hashBoostedMakeOrder(order, msg.sender),
                order.boosterPayload,
                signature
            );
        } else {
            verifyBoost(
                order.maker,
                hashBoostedMakeOrder(order, msg.sender),
                order.boosterPayload,
                signature
            );
        }

        uint32 orderId;

        // Encode the intrinsic fuel in the upper bits of the excess eth,
        // because we are hitting 'CompilerError: Stack too deep'.
        uint256 excessEthAndIntrinsicFuel = excessEth;
        excessEthAndIntrinsicFuel |= uint256(intrinsicFuel) << 96;

        (orderId, excessEth) = _makeOrderInternal({
            maker: order.maker,
            input: order.input,
            excessEthAndIntrinsicFuel: excessEthAndIntrinsicFuel,
            isBoosted: true,
            revertOnUpdateError: revertOnUpdateError
        });

        return (orderId, excessEth);
    }

    /**
     * @dev Take an order for the signer of `signature`.
     */
    function boostedTakeOrder(
        BoostedTakeOrder memory order,
        Signature memory signature
    ) public payable nonReentrant {
        require(!_killSwitchOn, "Dubiex: take order prevented by kill switch");

        uint256 excessEth = _boostedTakeOrderInternal({
            order: order,
            signature: signature,
            excessEth: msg.value,
            revertOnError: true
        });

        _refundExcessEth(excessEth);
    }

    function _boostedTakeOrderInternal(
        BoostedTakeOrder memory order,
        Signature memory signature,
        uint256 excessEth,
        bool revertOnError
    ) private returns (uint256) {
        uint96 intrinsicFuel = _burnFuel(order.taker, order.fuel);

        // Encode the intrinsic fuel in the upper bits of the excess eth,
        // because we are hitting 'CompilerError: Stack too deep'.
        uint256 excessEthAndIntrinsicFuel = excessEth;
        excessEthAndIntrinsicFuel |= uint256(intrinsicFuel) << 96;

        DubiexLib.CurrencyType takerCurrencyType;
        (, excessEth, takerCurrencyType) = _takeOrderInternal({
            input: order.input,
            taker: order.taker,
            excessEthAndIntrinsicFuel: excessEthAndIntrinsicFuel,
            revertOnError: revertOnError,
            isBoosted: true
        });

        // We optimize ERC721 take orders by not increasing the
        // nonce, because every ERC721 is unique - trying to replay the
        // transaction will always fail, since once taken - the target order doesn't
        // exist anymore and thus cannot be filled ever again.
        if (takerCurrencyType == DubiexLib.CurrencyType.ERC721) {
            _verifyBoostWithoutNonce(
                order.taker,
                hashBoostedTakeOrder(order, msg.sender),
                order.boosterPayload,
                signature
            );
        } else {
            verifyBoost(
                // The signer of the boosted message
                order.taker,
                hashBoostedTakeOrder(order, msg.sender),
                order.boosterPayload,
                signature
            );
        }

        return excessEth;
    }

    /**
     * @dev Cancel an order for the signer of `signature`.
     */
    function boostedCancelOrder(
        BoostedCancelOrder memory order,
        Signature memory signature
    ) public payable nonReentrant {
        bool isKillSwitchOn = _killSwitchOn;
        _boostedCancelOrderInternal(order, signature, true, isKillSwitchOn);
    }

    function _boostedCancelOrderInternal(
        BoostedCancelOrder memory order,
        Signature memory signature,
        bool reverOnError,
        bool isKillSwitchOn
    ) private {
        uint96 intrinsicFuel = _burnFuel(order.input.maker, order.fuel);

        // We do not need a nonce, since once cancelled the order id can never be re-used again
        _verifyBoostWithoutNonce(
            order.input.maker,
            hashBoostedCancelOrder(order, msg.sender),
            order.boosterPayload,
            signature
        );

        // Encode the intrinsic fuel in the upper bits of the excess eth,
        // (which for cancel order is always 0), because we are hitting 'CompilerError: Stack too deep'.
        uint256 excessEthAndIntrinsicFuel;
        excessEthAndIntrinsicFuel |= uint256(intrinsicFuel) << 96;

        _cancelOrderInternal({
            maker: order.input.maker,
            id: order.input.id,
            isBoosted: true,
            intrinsicFuel: excessEthAndIntrinsicFuel,
            revertOnError: reverOnError,
            isKillSwitchOn: isKillSwitchOn
        });
    }

    /**
     * @dev Perform multiple `boostedMakeOrder` calls in a single transaction.
     */
    function boostedMakeOrderBatch(
        BoostedMakeOrder[] calldata orders,
        Signature[] calldata signatures
    ) external payable nonReentrant {
        require(!_killSwitchOn, "Dubiex: make order prevented by kill switch");
        require(
            orders.length > 0 && orders.length == signatures.length,
            "Dubiex: invalid input lengths"
        );

        uint256 excessEth = msg.value;

        for (uint256 i = 0; i < orders.length; i++) {
            (, excessEth) = _boostedMakeOrderInternal(
                orders[i],
                signatures[i],
                uint96(excessEth),
                false
            );
        }
    }

    /**
     * @dev Perform multiple `boostedTakeOrder` calls in a single transaction.
     */
    function boostedTakeOrderBatch(
        BoostedTakeOrder[] memory boostedTakeOrders,
        Signature[] calldata signatures
    ) external payable nonReentrant {
        require(!_killSwitchOn, "Dubiex: take order prevented by kill switch");
        require(
            boostedTakeOrders.length > 0 &&
                boostedTakeOrders.length == signatures.length,
            "Dubiex: invalid input lengths"
        );

        uint256 excessEth = msg.value;
        for (uint256 i = 0; i < boostedTakeOrders.length; i++) {
            excessEth = _boostedTakeOrderInternal(
                boostedTakeOrders[i],
                signatures[i],
                uint96(excessEth),
                false
            );
        }

        _refundExcessEth(excessEth);
    }

    /**
     * @dev Perform multiple `boostedCancelOrder` calls in a single transaction.
     */
    function boostedCancelOrderBatch(
        BoostedCancelOrder[] memory orders,
        Signature[] calldata signatures
    ) external payable nonReentrant returns (uint32) {
        require(
            orders.length > 0 && orders.length == signatures.length,
            "Dubiex: invalid input lengths"
        );

        bool isKillSwitchOn = _killSwitchOn;

        for (uint256 i = 0; i < orders.length; i++) {
            _boostedCancelOrderInternal(
                orders[i],
                signatures[i],
                false,
                isKillSwitchOn
            );
        }
    }

    /**
     * @dev Create a new single order.
     *
     * @return the assigned order id
     */
    function _makeOrderInternal(
        DubiexLib.MakeOrderInput memory input,
        address payable maker,
        uint256 excessEthAndIntrinsicFuel,
        bool isBoosted,
        bool revertOnUpdateError
    ) private returns (uint32, uint256) {
        require(
            maker != address(this) && maker != address(0),
            "Dubiex: unexpected maker"
        );

        // An explicit id means an existing order should be updated.
        if (input.orderId > 0) {
            return (
                _updateOrder(
                    maker,
                    input.orderId,
                    input.updatedRatioWei,
                    revertOnUpdateError
                ),
                // Update order never uses eth, so we refund everything in case something was mistakenly sent
                uint96(excessEthAndIntrinsicFuel)
            );
        }

        // Reverts if the input is invalid
        require(input.makerValue > 0, "Dubiex: makerValue must be greater 0");
        require(input.takerValue > 0, "Dubiex: takerValue must be greater 0");

        // Reverts if the order pair is incompatible
        uint32 orderPairAlias = _getOrCreateOrderPairAlias(input.pair);

        // Deposit the makerValue, which will fail if no approval has been given
        // or the maker hasn't enough funds.
        // NOTE(reentrancy): safe, because we are using `nonReentrant` for makeOrder(s).
        // NOTE2: _transfer returns the *excessEth* only, but we reuse the 'excessEthAndIntrinsicFuel' variable
        // to work around 'CompilerError: Stack too deep'.
        bool deposited;

        (deposited, excessEthAndIntrinsicFuel) = _transfer({
            from: maker,
            to: payable(address(this)),
            value: input.makerValue,
            valueContractAddress: input.pair.makerContractAddress,
            valueCurrencyType: input.pair.makerCurrencyType,
            excessEthAndIntrinsicFuel: excessEthAndIntrinsicFuel,
            isBoosted: isBoosted
        });

        require(deposited, "Dubiex: failed to deposit. not enough funds?");

        // Create the orderbook item
        DubiexLib.PackedOrderBookItem memory _packed;

        DubiexLib.UnpackedOrderBookItem memory _unpacked;
        _unpacked.id = _getNextOrderId(maker);
        _unpacked.makerValue = input.makerValue;
        _unpacked.takerValue = input.takerValue;
        _unpacked.orderPairAlias = orderPairAlias;
        _unpacked.flags.isMakerERC721 =
            input.pair.makerCurrencyType == DubiexLib.CurrencyType.ERC721;
        _unpacked.flags.isTakerERC721 =
            input.pair.takerCurrencyType == DubiexLib.CurrencyType.ERC721;

        // Update ancestor order if any
        _updateOrderAncestorIfAny(input, maker, _unpacked, _packed);

        // Pack unpacked data and write to storage
        _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);
        _ordersByAddress[maker].push(_packed);

        // Emit event and done

        uint256 packedData;
        packedData |= input.makerValue;
        packedData |= uint256(input.takerValue) << 96;
        packedData |= uint256(orderPairAlias) << (96 + 96);

        emit MadeOrder(_unpacked.id, maker, packedData);

        return (_unpacked.id, excessEthAndIntrinsicFuel);
    }

    function _updateOrderAncestorIfAny(
        DubiexLib.MakeOrderInput memory input,
        address maker,
        DubiexLib.UnpackedOrderBookItem memory unpacked,
        DubiexLib.PackedOrderBookItem memory packed
    ) private {
        // If an ancestor is provided, we check if it exists and try to make this order
        // an successor of it. If it succeeds, then this order ends up being hidden.
        if (input.ancestorOrderId > 0) {
            packed.ancestorOrderId = input.ancestorOrderId;

            bool success = _setSuccessorOfAncestor(
                maker,
                input.ancestorOrderId,
                unpacked.id
            );

            // New successor order must be hidden if it has an existing ancestor now
            unpacked.flags.isHidden = success;
        }
    }

    /**
     * @dev Take a make order.
     * @param input the take order input.
     * @param taker address of the taker
     * @param revertOnError whether to revert on errors or not. True, when taking a single order.
     *
     */
    function _takeOrderInternal(
        address payable taker,
        DubiexLib.TakeOrderInput memory input,
        uint256 excessEthAndIntrinsicFuel,
        bool revertOnError,
        bool isBoosted
    )
        private
        returns (
            bool,
            uint256,
            DubiexLib.CurrencyType
        )
    {
        (
            DubiexLib.PackedOrderBookItem storage _packed,
            DubiexLib.UnpackedOrderBookItem memory _unpacked,
            uint256 index
        ) = _assertTakeOrderInput(input, revertOnError);

        // Order doesn't exist or input is invalid.
        if (_unpacked.id == 0) {
            // Only gets here if 'revertOnError' is false
            return (
                false,
                uint96(excessEthAndIntrinsicFuel),
                DubiexLib.CurrencyType.NULL
            );
        }

        // Get the actual makerValue, which might just be a fraction of the total
        // `takerValue` of the `_makeOrder`.
        (uint96 _makerValue, uint96 _takerValue) = _calculateMakerAndTakerValue(
            _unpacked,
            input.takerValue,
            input.maxTakerMakerRatio
        );
        if (_makerValue == 0 || _takerValue == 0) {
            if (revertOnError) {
                revert("Dubiex: invalid takerValue");
            }

            return (
                false,
                uint96(excessEthAndIntrinsicFuel),
                DubiexLib.CurrencyType.NULL
            );
        }

        // Transfer from taker to maker
        // NOTE(reentrancy): `takeOrder(s)` is marked nonReentrant
        // NOTE2: _transferFromTakerToMaker returns the *excessEth* only, but we reuse the 'excessEthAndIntrinsicFuel' variable
        // to work around 'CompilerError: Stack too deep'.
        excessEthAndIntrinsicFuel = _transferFromTakerToMaker(
            taker,
            input.maker,
            _takerValue,
            _unpacked.pair,
            excessEthAndIntrinsicFuel,
            isBoosted
        );

        // Transfer from maker to taker
        // NOTE(reentrancy): `takeOrder(s)` is marked nonReentrant
        if (
            !_transferFromContractToTaker(
                taker,
                _makerValue,
                _unpacked.pair,
                false,
                0
            )
        ) {
            if (revertOnError) {
                revert("Dubiex: failed to transfer value to taker");
            }

            return (
                false,
                excessEthAndIntrinsicFuel,
                DubiexLib.CurrencyType.NULL
            );
        }

        // If filled, the order can be deleted (without having to update the maker/taker value)
        if (_unpacked.makerValue - _makerValue == 0) {
            // Make successor of filled order visible if any.
            if (_unpacked.flags.hasSuccessor) {
                _setOrderVisible(input.maker, _packed.successorOrderId);
            }

            // Delete the filled order
            _deleteOrder({maker: input.maker, index: index});
        } else {
            // Not filled yet, so update original make order
            _unpacked.makerValue -= _makerValue;
            _unpacked.takerValue -= _takerValue;

            // Write updated item to storage
            _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);
        }

        // NOTE: We write the new taker/maker value to the in-memory struct
        // and pass it to a function that emits 'TookOrder' to avoid the 'Stack too deep' error
        _unpacked.makerValue = _makerValue;
        _unpacked.takerValue = _takerValue;

        return
            _emitTookOrder(
                input.maker,
                taker,
                _unpacked,
                excessEthAndIntrinsicFuel
            );
    }

    /**
     * @dev Emit 'TookOrder' in a separate function to avoid the 'Stack too deep' error
     */
    function _emitTookOrder(
        address maker,
        address taker,
        DubiexLib.UnpackedOrderBookItem memory unpacked,
        uint256 excessEthAndIntrinsicFuel
    )
        private
        returns (
            bool,
            uint256,
            DubiexLib.CurrencyType
        )
    {
        uint256 packedData;
        packedData |= unpacked.makerValue;
        packedData |= uint256(unpacked.takerValue) << 96;
        packedData |= uint256(unpacked.orderPairAlias) << (96 + 96);

        emit TookOrder(unpacked.id, maker, taker, packedData);

        return (
            true,
            excessEthAndIntrinsicFuel,
            unpacked.pair.takerCurrencyType
        );
    }

    /**
     * @dev Cancel an order
     * @param maker the maker of the order
     * @param id the id of the order to cancel
     * @param revertOnError whether to revert on errors or not
     */
    function _cancelOrderInternal(
        address payable maker,
        uint32 id,
        uint256 intrinsicFuel,
        bool isBoosted,
        bool revertOnError,
        bool isKillSwitchOn
    ) private returns (bool) {
        // Anyone can cancel any order if the kill switch is on.
        // For efficiency, we do not need to check the kill switch if this is a boosted cancel order,
        // because in that case we already have the explicit consent of the maker.
        // If it's neither a boosted cancel nor a post-kill switch cancel, the msg.sender must be the maker.
        if (!isBoosted && !isKillSwitchOn) {
            require(maker == msg.sender, "Dubiex: msg.sender must be maker");
        }

        if (!revertOnError && !_orderExists(maker, id)) {
            return false;
        }

        // Get the make order (reverts if order doesn't exist)
        (
            ,
            DubiexLib.UnpackedOrderBookItem memory unpacked,
            uint256 index
        ) = _safeGetOrder(maker, id, DubiexLib.OrderPairReadStrategy.MAKER);

        // Transfer remaining `makerValue` back to maker, by assuming the taker role with the maker.

        // NOTE(reentrancy): `cancelOrder(s)` is marked nonReentrant
        if (
            !_transferFromContractToTaker({
                taker: maker,
                makerValue: unpacked.makerValue,
                pair: unpacked.pair,
                isBoosted: isBoosted,
                excessEthAndIntrinsicFuel: intrinsicFuel
            })
        ) {
            return false;
        }

        // Delete the cancelled order
        _deleteOrder({maker: maker, index: index});

        emit CanceledOrder(maker, id);

        return true;
    }

    /**
     * @dev Update the `takerValue` of an order using the given `updatedRatioWei`
     * @param maker the maker of the order to update
     * @param orderId the id of the existing order
     * @param updatedRatioWei the new ratio in wei
     */
    function _updateOrder(
        address maker,
        uint32 orderId,
        uint128 updatedRatioWei,
        bool revertOnUpdateError
    ) private returns (uint32) {
        (
            DubiexLib.PackedOrderBookItem storage _packed,
            DubiexLib.UnpackedOrderBookItem memory _unpacked,

        ) = _getOrder(maker, orderId, DubiexLib.OrderPairReadStrategy.SKIP);

        // Order doesn't exist
        if (_unpacked.id == 0) {
            if (revertOnUpdateError) {
                revert("Dubiex: order does not exist");
            }

            return 0;
        }

        // We don't prevent reverts here, even if `revertOnUpdateError` is false since
        // they are user errors unlike a non-existing order which a user has no control over.

        require(updatedRatioWei > 0, "Dubiex: ratio is 0");

        require(
            !_unpacked.flags.isMakerERC721 && !_unpacked.flags.isTakerERC721,
            "Dubiex: cannot update ERC721 value"
        );

        // Update the existing order with the new ratio to the takerValue.
        // The makerValue stays untouched.

        uint256 updatedTakerValue = (uint256(_unpacked.makerValue) *
            uint256(updatedRatioWei)) / 1 ether;

        require(updatedTakerValue < 2**96, "Dubiex: takerValue overflow");

        _unpacked.takerValue = uint96(updatedTakerValue);
        _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);

        emit UpdatedOrder(maker, orderId);

        return orderId;
    }

    // If both returned values are > 0, then the provided `takerValue` and `maxTakerMakerRatio` are valid.
    function _calculateMakerAndTakerValue(
        DubiexLib.UnpackedOrderBookItem memory _unpacked,
        uint96 takerValue,
        uint256 maxTakerMakerRatio
    ) private pure returns (uint96, uint96) {
        uint256 calculatedMakerValue = _unpacked.makerValue;
        uint256 calculatedTakerValue = takerValue;

        // ERC721 cannot be bought/sold partially, therefore the `takerValue` must match the requested
        // value exactly.
        if (
            _unpacked.pair.makerCurrencyType == DubiexLib.CurrencyType.ERC721 ||
            _unpacked.pair.takerCurrencyType == DubiexLib.CurrencyType.ERC721
        ) {
            if (takerValue != _unpacked.takerValue) {
                return (0, 0);
            }

            // The order gets filled completely, so we use the values as is.
        } else {
            // Calculate the current takerMakerValue ratio and compare it to `maxTakerMakerRatio`.
            // If it is higher then the order will not be taken.
            uint256 takerMakerRatio = (uint256(_unpacked.takerValue) *
                1 ether) / calculatedMakerValue;

            if (maxTakerMakerRatio < takerMakerRatio) {
                return (0, 0);
            }

            if (calculatedTakerValue > _unpacked.takerValue) {
                calculatedTakerValue = _unpacked.takerValue;
            }

            // Calculate actual makerValue for ETH/ERC20 trades which might only get partially filled by the
            // takerValue. Since we don't have decimals, we need to multiply by 10^18 and divide by it again at the end
            // to not lose any information.
            calculatedMakerValue *= 1 ether;
            calculatedMakerValue *= calculatedTakerValue;
            calculatedMakerValue /= _unpacked.takerValue;
            calculatedMakerValue /= 1 ether;
        }

        // Sanity checks
        assert(
            calculatedMakerValue < 2**96 &&
                calculatedMakerValue <= _unpacked.makerValue
        );
        assert(
            calculatedTakerValue < 2**96 &&
                calculatedTakerValue <= _unpacked.takerValue
        );

        return (uint96(calculatedMakerValue), uint96(calculatedTakerValue));
    }

    /**
     * @dev Assert a take order input and return the order. If a zero-order is returned,
     * then it does not exist and it is up to the caller how to handle it.
     */
    function _assertTakeOrderInput(
        DubiexLib.TakeOrderInput memory input,
        bool revertOnError
    )
        private
        view
        returns (
            DubiexLib.PackedOrderBookItem storage,
            DubiexLib.UnpackedOrderBookItem memory,
            uint256 // index
        )
    {
        (
            DubiexLib.PackedOrderBookItem storage packed,
            DubiexLib.UnpackedOrderBookItem memory unpacked,
            uint256 index
        ) = _getOrder(
            input.maker,
            input.id,
            DubiexLib.OrderPairReadStrategy.FULL
        );

        bool validTakerValue = input.takerValue > 0;
        bool orderExistsAndNotHidden = unpacked.id > 0 &&
            !unpacked.flags.isHidden;
        if (revertOnError) {
            require(validTakerValue, "Dubiex: takerValue must be greater 0");

            require(orderExistsAndNotHidden, "Dubiex: order does not exist");
        } else {
            if (!validTakerValue || !orderExistsAndNotHidden) {
                DubiexLib.UnpackedOrderBookItem memory emptyUnpacked;
                return (emptyOrder, emptyUnpacked, 0);
            }
        }

        return (packed, unpacked, index);
    }

    function _orderExists(address maker, uint32 id)
        private
        view
        returns (bool)
    {
        // Since we don't want to revert for cancelOrders, we have to check that the order
        // (maker, id) exists by looping over the orders of the maker and comparing the id.


            DubiexLib.PackedOrderBookItem[] storage orders
         = _ordersByAddress[maker];

        uint256 length = orders.length;
        for (uint256 i = 0; i < length; i++) {
            // The first 32 bits of the packed data corresponds to the id. By casting to uint32,
            // we can compare the id without having to unpack the entire thing.
            uint32 orderId = uint32(orders[i].packedData);
            if (orderId == id) {
                // Found order
                return true;
            }
        }

        // Doesn't exist
        return false;
    }

    function _refundExcessEth(uint256 excessEth) private {
        // Casting to uint96 to get rid off any of the higher utility bits
        excessEth = uint96(excessEth);

        // Sanity check
        assert(msg.value >= excessEth);

        if (excessEth > 0) {
            msg.sender.transfer(excessEth);
        }
    }

    // Transfer `takerValue` to `maker`.
    function _transferFromTakerToMaker(
        address payable taker,
        address payable maker,
        uint96 takerValue,
        DubiexLib.OrderPair memory pair,
        uint256 excessEthAndIntrinsicFuel,
        bool isBoosted
    ) private returns (uint256) {
        (bool success, uint256 excessEth) = _transfer(
            taker,
            maker,
            takerValue,
            pair.takerContractAddress,
            pair.takerCurrencyType,
            excessEthAndIntrinsicFuel,
            isBoosted
        );

        require(success, "Dubiex: failed to transfer value to maker");

        return excessEth;
    }

    // Transfer `makerValue` to `taker`
    function _transferFromContractToTaker(
        address payable taker,
        uint96 makerValue,
        DubiexLib.OrderPair memory pair,
        bool isBoosted,
        uint256 excessEthAndIntrinsicFuel
    ) private returns (bool) {
        (bool success, ) = _transfer(
            payable(address(this)),
            taker,
            makerValue,
            pair.makerContractAddress,
            pair.makerCurrencyType,
            excessEthAndIntrinsicFuel,
            isBoosted
        );

        return success;
    }

    function _transfer(
        address payable from,
        address payable to,
        uint256 value,
        address valueContractAddress,
        DubiexLib.CurrencyType valueCurrencyType,
        uint256 excessEthAndIntrinsicFuel,
        bool isBoosted
    ) private returns (bool, uint256) {
        uint256 excessEth = uint96(excessEthAndIntrinsicFuel);
        if (valueCurrencyType == DubiexLib.CurrencyType.ETH) {
            // Eth is a bit special, because it's not a token. Therefore we need to ensure
            // that the taker/maker sent enough eth (`excessEth` >= `value`) and also that
            // he is refunded at the end of the transaction properly.
            if (from != address(this)) {
                if (excessEth < value) {
                    return (false, excessEth);
                }

                // Got enough eth, but maybe too much, so we subtract the value from the excessEth. This is important
                // to refund the sender correctly e.g. he mistakenly sent too much or the order
                // was partially filled while his transaction was pending.
                excessEth -= value;
            }

            // Not a deposit, so transfer eth owned by this contract to maker or taker
            if (to != address(this)) {
                to.transfer(value);
            }

            return (true, excessEth);
        }

        if (valueCurrencyType == DubiexLib.CurrencyType.ERC20) {
            IERC20 erc20 = IERC20(valueContractAddress);
            uint256 recipientBalanceBefore = erc20.balanceOf(to);

            if (from == address(this)) {
                // If sending own tokens, use `safeTransfer` because Dubiex doesn't have any allowance
                // for itself which would cause `safeTransferFrom` to fail.
                erc20.safeTransfer(to, value);
            } else {
                erc20.safeTransferFrom(from, to, value);
            }

            uint256 recipientBalanceAfter = erc20.balanceOf(to);
            // Safe guard to minimize the risk of getting buggy orders if the contract
            // deviates from the ERC20 standard.
            require(
                recipientBalanceAfter == recipientBalanceBefore + value,
                "Dubiex: failed to transfer ERC20 token"
            );

            return (true, excessEth);
        }

        if (valueCurrencyType == DubiexLib.CurrencyType.BOOSTABLE_ERC20) {
            IBoostableERC20 erc20 = IBoostableERC20(valueContractAddress);

            if (from == address(this)) {
                // If sending own tokens, use `safeTransfer`, because Dubiex doesn't have any allowance
                // for itself which would cause `permissionSend` to fail.
                IERC20(address(erc20)).safeTransfer(to, value);
            } else {
                bool success = erc20.boostedTransferFrom(
                    from,
                    to,
                    value,
                    abi.encodePacked(isBoosted)
                );

                require(
                    success,
                    "Dubiex: failed to transfer boosted ERC20 token"
                );
            }

            return (true, excessEth);
        }

        if (valueCurrencyType == DubiexLib.CurrencyType.ERC721) {
            IERC721 erc721 = IERC721(valueContractAddress);

            // Pass isBoosted flag + fuel if any
            erc721.safeTransferFrom(
                from,
                to,
                value,
                abi.encodePacked(
                    isBoosted,
                    uint96(excessEthAndIntrinsicFuel >> 96)
                )
            );

            // Safe guard to minimize the risk of getting buggy orders if the contract
            // deviates from the ERC721 standard.
            require(
                erc721.ownerOf(value) == to,
                "Dubiex: failed to transfer ERC721 token"
            );

            return (true, excessEth);
        }

        revert("Dubiex: unexpected currency type");
    }

    /**
     * @dev Validates that the given contract address and currency type are compatible.
     * @param currencyType type of the currency
     * @param contractAddress the contract address associated with currency
     */
    function _validateCurrencyType(
        DubiexLib.CurrencyType currencyType,
        address contractAddress
    ) private returns (bool) {
        if (currencyType == DubiexLib.CurrencyType.ETH) {
            require(
                contractAddress == address(0),
                "Dubiex: expected zero address"
            );
            return true;
        }

        if (currencyType == DubiexLib.CurrencyType.ERC721) {
            // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
            //
            // `contractAddress` must implement the ERC721 standard. According to the ERC721 standard
            // every compliant token is also expected to use ERC165 for that.
            require(
                IERC165(contractAddress).supportsInterface(
                    _ERC721_INTERFACE_HASH
                ),
                "Dubiex: not ERC721 compliant"
            );
            return true;
        }

        if (currencyType == DubiexLib.CurrencyType.BOOSTABLE_ERC20) {
            // The contract must implement the BOOSTABLE_ERC20 interface
            address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(
                contractAddress,
                _BOOSTABLE_ERC20_TOKEN_HASH
            );

            require(
                implementer != address(0),
                "Dubiex: not BoostableERC20 compliant"
            );
            return true;
        }

        if (currencyType == DubiexLib.CurrencyType.ERC20) {
            // Using `call` is our last-resort to check if the given contract implements
            // ERC721, since we can't just call `supportsInterface` directly without reverting
            // if `contractAddress` doesn't implement it. Unlike above, where we want an ERC721,
            // so reverting is fine for non-ERC721 contracts.
            //
            // NOTE: bytes4(keccak256(supportsInterface(bytes4))) => 0x01ffc9a7
            // solhint-disable-next-line avoid-low-level-calls
            (bool success, bytes memory result) = contractAddress.call(
                abi.encodeWithSelector(0x01ffc9a7, _ERC721_INTERFACE_HASH)
            );

            // The call above must either fail (success = false) or if it succeeds,
            // return false.
            bool isERC721 = false;
            if (result.length > 0) {
                isERC721 = abi.decode(result, (bool));
            }

            require(!success || !isERC721, "Dubiex: ERC20 implements ERC721");

            // Lastly, we heuristically check if it responds to `balanceOf`.
            // If it succeeds, we assume it is an ERC20.
            // NOTE: bytes4(keccak256(balanceOf(address))) => 0x70a08231
            result = Address.functionCall(
                contractAddress,
                abi.encodeWithSelector(0x70a08231, contractAddress)
            );
            require(result.length > 0, "Dubiex: not ERC20 compliant");

            return true;
        }

        return false;
    }

    /**
     * @dev Increment the order id counter and return the new id.
     */
    function _getNextOrderId(address account) private returns (uint32) {
        uint32 currentId = _counters[account];
        assert(currentId < 2**32);

        uint32 nextId = currentId + 1;
        _counters[account] = nextId;

        return nextId;
    }

    /**
     * @dev Get or create order pair alias from the given order pair.
     */
    function _getOrCreateOrderPairAlias(DubiexLib.OrderPair memory pair)
        private
        returns (uint32)
    {
        bytes32 orderPairHash = keccak256(
            abi.encode(
                pair.makerContractAddress,
                pair.takerContractAddress,
                pair.makerCurrencyType,
                pair.takerCurrencyType
            )
        );

        uint32 orderPairAlias = _orderPairAliasesByHash[orderPairHash];
        // If it doesn't exist yet, we create it (which makes the make order for the caller a bit more expensive).
        if (orderPairAlias == 0) {
            require(
                _validateCurrencyType(
                    pair.makerCurrencyType,
                    pair.makerContractAddress
                ),
                "Dubiex: makerContractAddress and currencyType mismatch"
            );
            require(
                _validateCurrencyType(
                    pair.takerCurrencyType,
                    pair.takerContractAddress
                ),
                "Dubiex: takerContractAddress and currencyType mismatch"
            );

            uint32 orderPairAliasCounter = _orderPairAliasCounter;
            orderPairAliasCounter++;

            orderPairAlias = orderPairAliasCounter;

            _orderPairAliasCounter = orderPairAliasCounter;

            // Write mappings
            _orderPairAliasesByHash[orderPairHash] = orderPairAlias;
            _orderPairsByAlias[orderPairAlias] = DubiexLib.packOrderPair(pair);
        }

        return orderPairAlias;
    }

    function _safeGetOrderPairByAlias(
        uint32 orderPairAlias,
        DubiexLib.OrderPairReadStrategy strategy
    ) private view returns (DubiexLib.OrderPair memory) {
        DubiexLib.OrderPair memory _unpackedOrderPair;

        if (strategy == DubiexLib.OrderPairReadStrategy.SKIP) {
            return _unpackedOrderPair;
        }


            DubiexLib.PackedOrderPair storage _pairStorage
         = _orderPairsByAlias[orderPairAlias];

        // Read only maker info if requested
        if (
            strategy == DubiexLib.OrderPairReadStrategy.MAKER ||
            strategy == DubiexLib.OrderPairReadStrategy.FULL
        ) {
            (
                address makerContractAddress,
                DubiexLib.CurrencyType makerCurrencyType
            ) = DubiexLib.unpackOrderPairAddressType(_pairStorage.makerPair);
            _unpackedOrderPair.makerContractAddress = makerContractAddress;
            _unpackedOrderPair.makerCurrencyType = makerCurrencyType;

            require(
                _unpackedOrderPair.makerCurrencyType !=
                    DubiexLib.CurrencyType.NULL,
                "Dubiex: maker order pair not found"
            );
        }

        // Read only taker info if requested
        if (
            strategy == DubiexLib.OrderPairReadStrategy.TAKER ||
            strategy == DubiexLib.OrderPairReadStrategy.FULL
        ) {
            (
                address takerContractAddress,
                DubiexLib.CurrencyType takerCurrencyType
            ) = DubiexLib.unpackOrderPairAddressType(_pairStorage.takerPair);
            _unpackedOrderPair.takerContractAddress = takerContractAddress;
            _unpackedOrderPair.takerCurrencyType = takerCurrencyType;

            require(
                _unpackedOrderPair.takerCurrencyType !=
                    DubiexLib.CurrencyType.NULL,
                "Dubiex: taker order pair not found"
            );
        }

        return _unpackedOrderPair;
    }

    /**
     * @dev Tries to set the successor of the order with `ancestorOrderId`.
     *
     * - Reverts, if the ancestor exists and already has a successor.
     * - Returns false, if the ancestor doesn't exist.
     * - If it succeeds, then it implies that the ancestor hasn't been filled yet and thus
     * the caller has to ensure that the successor gets hidden.
     */
    function _setSuccessorOfAncestor(
        address account,
        uint32 ancestorOrderId,
        uint32 successorOrderId
    ) private returns (bool) {

            DubiexLib.PackedOrderBookItem[] storage orders
         = _ordersByAddress[account];
        uint256 length = orders.length;
        for (uint256 i = 0; i < length; i++) {
            DubiexLib.PackedOrderBookItem storage _packed = orders[i];

            uint256 packedData = _packed.packedData;

            // The first 32 bits of the packed data corresponds to the id. By casting to uint32,
            // we can compare the id without having to unpack the entire thing.
            uint32 orderId = uint32(packedData);
            if (orderId == ancestorOrderId) {
                DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib
                    .unpackOrderBookItem(packedData);

                // Set successor if none yet
                if (!_unpacked.flags.hasSuccessor) {
                    _unpacked.flags.hasSuccessor = true;
                    _packed.successorOrderId = successorOrderId;

                    // Pack data again and update storage
                    _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);

                    return true;
                }

                // Ancestor exists, but has already a successor
                revert("Dubiex: ancestor order already has a successor");
            }
        }

        // Ancestor doesn't exist - so it got filled/cancelled or was never created to begin with.
        return false;
    }

    /**
     * @dev Makes the given successor order visible if it exists.
     */
    function _setOrderVisible(address account, uint32 successorOrderId)
        private
    {

            DubiexLib.PackedOrderBookItem[] storage orders
         = _ordersByAddress[account];

        uint256 length = orders.length;
        for (uint256 i = 0; i < length; i++) {
            DubiexLib.PackedOrderBookItem storage _packed = orders[i];

            uint256 packedData = _packed.packedData;

            // The first 32 bits of the packed data corresponds to the id. By casting to uint32,
            // we can compare the id without having to unpack the entire thing.
            uint32 orderId = uint32(packedData);
            if (orderId == successorOrderId) {
                DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib
                    .unpackOrderBookItem(packedData);
                _unpacked.flags.isHidden = false;

                // Write updated data
                _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);

                break;
            }
        }
    }

    /**
     * @dev Returns the order from `account` with the given id from storage
     * plus the index of it.
     *
     * If it cannot be found, then this function reverts, because we expect the
     * caller to operate on existing orders.
     */
    function _safeGetOrder(
        address account,
        uint32 id,
        DubiexLib.OrderPairReadStrategy strategy
    )
        private
        view
        returns (
            DubiexLib.PackedOrderBookItem storage,
            DubiexLib.UnpackedOrderBookItem memory,
            uint256
        )
    {

            DubiexLib.PackedOrderBookItem[] storage orders
         = _ordersByAddress[account];

        uint256 length = orders.length;
        for (uint256 i = 0; i < length; i++) {
            DubiexLib.PackedOrderBookItem storage _packed = orders[i];

            uint256 packedData = _packed.packedData;

            // The first 32 bits of the packed data corresponds to the id. By casting to uint32,
            // we can compare the id without having to unpack the entire thing.
            uint32 orderId = uint32(packedData);
            if (orderId == id) {
                DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib
                    .unpackOrderBookItem(packedData);

                // Read the order pair with the given strategy
                _unpacked.pair = _safeGetOrderPairByAlias(
                    _unpacked.orderPairAlias,
                    strategy
                );

                return (_packed, _unpacked, i);
            }
        }

        revert("Dubiex: order does not exist");
    }

    /**
     * @dev Returns the order from `account` with the given id from storage
     * plus the index of it.
     *
     * If it cannot be found, then this function does not revert and it's up to the
     * caller to decide.
     */
    function _getOrder(
        address account,
        uint32 id,
        DubiexLib.OrderPairReadStrategy strategy
    )
        private
        view
        returns (
            DubiexLib.PackedOrderBookItem storage,
            DubiexLib.UnpackedOrderBookItem memory,
            uint256
        )
    {

            DubiexLib.PackedOrderBookItem[] storage orders
         = _ordersByAddress[account];

        uint256 length = orders.length;
        for (uint256 i = 0; i < length; i++) {
            DubiexLib.PackedOrderBookItem storage _packed = orders[i];

            uint256 packedData = _packed.packedData;

            // The first 32 bits of the packed data corresponds to the id. By casting to uint32,
            // we can compare the id without having to unpack the entire thing.
            uint32 orderId = uint32(packedData);
            if (orderId == id) {
                DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib
                    .unpackOrderBookItem(packedData);

                // Read the order pair with the given strategy
                // NOTE: This cannot revert when the order exists.
                _unpacked.pair = _safeGetOrderPairByAlias(
                    _unpacked.orderPairAlias,
                    strategy
                );

                return (_packed, _unpacked, i);
            }
        }

        DubiexLib.UnpackedOrderBookItem memory _unpacked;
        return (emptyOrder, _unpacked, 0);
    }

    /**
     * @dev Delete an order of `maker` by index in O(1).
     */
    function _deleteOrder(address maker, uint256 index) private {

            DubiexLib.PackedOrderBookItem[] storage orders
         = _ordersByAddress[maker];

        uint256 length = orders.length;
        // swap and pop, changes the order
        if (index != length - 1) {
            // Move last item to the position of the to-be-deleted item (`index`)
            orders[index] = orders[length - 1];
        }

        orders.pop();
    }

    //---------------------------------------------------------------
    // Fuel
    //---------------------------------------------------------------

    /**
     * @dev Burn `fuel` from `from`.
     */
    function _burnFuel(address from, BoosterFuel memory fuel)
        internal
        returns (uint96)
    {
        // Burn unlocked PRPS
        if (fuel.unlockedPrps > 0) {
            IBoostableERC20(address(_prps)).burnFuel(
                from,
                TokenFuel({
                    tokenAlias: 0, /* UNLOCKED PRPS */
                    amount: fuel.unlockedPrps
                })
            );

            return 0;
        }

        // Burn locked PRPS
        if (fuel.lockedPrps > 0) {
            IBoostableERC20(address(_prps)).burnFuel(
                from,
                TokenFuel({
                    tokenAlias: 1, /* LOCKED PRPS */
                    amount: fuel.lockedPrps
                })
            );

            return 0;
        }

        // Burn DUBI from balance
        if (fuel.dubi > 0) {
            IBoostableERC20(address(_dubi)).burnFuel(
                from,
                TokenFuel({
                    tokenAlias: 2, /* DUBI */
                    amount: fuel.dubi
                })
            );

            return 0;
        }

        // The intrinsic fuel is only supported for ERC721 tokens via
        // the 'safeTransferFrom' payload.
        if (fuel.intrinsicFuel > 0) {
            return fuel.intrinsicFuel;
        }

        // No fuel
        return 0;
    }
}

