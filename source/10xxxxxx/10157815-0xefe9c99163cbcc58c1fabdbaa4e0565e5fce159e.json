{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract Moloch is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    /***************\r\n    GLOBAL CONSTANTS\r\n    ***************/\r\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\r\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\r\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\r\n    uint256 public proposalDeposit; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\r\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\r\n    uint256 public processingReward; // default = 0.1 - amount of ETH to give to whoever processes a proposal\r\n    uint256 public summoningTime; // needed to determine the current period\r\n\r\n    address public depositToken; // deposit token contract reference; default = wETH\r\n\r\n    // HARD-CODED LIMITS\r\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\r\n    // with periods or shares, yet big enough to not limit reasonable use cases.\r\n    uint256 constant MAX_VOTING_PERIOD_LENGTH = 10**18; // maximum length of voting period\r\n    uint256 constant MAX_GRACE_PERIOD_LENGTH = 10**18; // maximum length of grace period\r\n    uint256 constant MAX_DILUTION_BOUND = 10**18; // maximum dilution bound\r\n    uint256 constant MAX_NUMBER_OF_SHARES_AND_LOOT = 10**18; // maximum number of shares that can be minted\r\n    uint256 constant MAX_TOKEN_WHITELIST_COUNT = 400; // maximum number of whitelisted tokens\r\n    uint256 constant MAX_TOKEN_GUILDBANK_COUNT = 200; // maximum number of tokens with non-zero balance in guildbank\r\n\r\n    // ***************\r\n    // EVENTS\r\n    // ***************\r\n    event SummonComplete(address indexed summoner, address[] tokens, uint256 summoningTime, uint256 periodDuration, uint256 votingPeriodLength, uint256 gracePeriodLength, uint256 proposalDeposit, uint256 dilutionBound, uint256 processingReward);\r\n    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, string details, bool[6] flags, uint256 proposalId, address indexed delegateKey, address indexed memberAddress);\r\n    event SponsorProposal(address indexed delegateKey, address indexed memberAddress, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);\r\n    event SubmitVote(uint256 proposalId, uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\r\n    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessWhitelistProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessGuildKickProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);\r\n    event TokensCollected(address indexed token, uint256 amountToCollect);\r\n    event CancelProposal(uint256 indexed proposalId, address applicantAddress);\r\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\r\n    event Withdraw(address indexed memberAddress, address token, uint256 amount);\r\n\r\n    // *******************\r\n    // INTERNAL ACCOUNTING\r\n    // *******************\r\n    uint256 public proposalCount = 0; // total proposals submitted\r\n    uint256 public totalShares = 0; // total shares across all members\r\n    uint256 public totalLoot = 0; // total loot across all members\r\n\r\n    uint256 public totalGuildBankTokens = 0; // total tokens with non-zero balance in guild bank\r\n\r\n    address public constant GUILD = address(0xdead);\r\n    address public constant ESCROW = address(0xbeef);\r\n    address public constant TOTAL = address(0xbabe);\r\n    mapping (address => mapping(address => uint256)) public userTokenBalances; // userTokenBalances[userAddress][tokenAddress]\r\n\r\n    enum Vote {\r\n        Null, // default value, counted as abstention\r\n        Yes,\r\n        No\r\n    }\r\n\r\n    struct Member {\r\n        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated\r\n        uint256 shares; // the # of voting shares assigned to this member\r\n        uint256 loot; // the loot amount available to this member (combined with shares on ragequit)\r\n        bool exists; // always true once a member has been created\r\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\r\n        uint256 jailed; // set to proposalIndex of a passing guild kick proposal for this member, prevents voting on and sponsoring proposals\r\n    }\r\n\r\n    struct Proposal {\r\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as guild kick target for gkick proposals)\r\n        address proposer; // the account that submitted the proposal (can be non-member)\r\n        address sponsor; // the member that sponsored the proposal (moving it into the queue)\r\n        uint256 sharesRequested; // the # of shares the applicant is requesting\r\n        uint256 lootRequested; // the amount of loot the applicant is requesting\r\n        uint256 tributeOffered; // amount of tokens offered as tribute\r\n        address tributeToken; // tribute token contract reference\r\n        uint256 paymentRequested; // amount of tokens requested as payment\r\n        address paymentToken; // payment token contract reference\r\n        uint256 startingPeriod; // the period in which voting can start for this proposal\r\n        uint256 yesVotes; // the total number of YES votes for this proposal\r\n        uint256 noVotes; // the total number of NO votes for this proposal\r\n        bool[6] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n        string details; // proposal details - could be IPFS hash, plaintext, or JSON\r\n        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\r\n        mapping(address => Vote) votesByMember; // the votes on this proposal by each member\r\n    }\r\n\r\n    mapping(address => bool) public tokenWhitelist;\r\n    address[] public approvedTokens;\r\n\r\n    mapping(address => bool) public proposedToWhitelist;\r\n    mapping(address => bool) public proposedToKick;\r\n\r\n    mapping(address => Member) public members;\r\n    mapping(address => address) public memberAddressByDelegateKey;\r\n\r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    uint256[] public proposalQueue;\r\n\r\n    modifier onlyMember {\r\n        require(members[msg.sender].shares > 0 || members[msg.sender].loot > 0, \"not a member\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyShareholder {\r\n        require(members[msg.sender].shares > 0, \"not a shareholder\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDelegate {\r\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"not a delegate\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _summoner,\r\n        address[] memory _approvedTokens,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _proposalDeposit,\r\n        uint256 _dilutionBound,\r\n        uint256 _processingReward\r\n    ) public {\r\n        require(_summoner != address(0), \"summoner cannot be 0\");\r\n        require(_periodDuration > 0, \"_periodDuration cannot be 0\");\r\n        require(_votingPeriodLength > 0, \"_votingPeriodLength cannot be 0\");\r\n        require(_votingPeriodLength <= MAX_VOTING_PERIOD_LENGTH, \"_votingPeriodLength exceeds limit\");\r\n        require(_gracePeriodLength <= MAX_GRACE_PERIOD_LENGTH, \"_gracePeriodLength exceeds limit\");\r\n        require(_dilutionBound > 0, \"_dilutionBound cannot be 0\");\r\n        require(_dilutionBound <= MAX_DILUTION_BOUND, \"_dilutionBound exceeds limit\");\r\n        require(_approvedTokens.length > 0, \"need at least one approved token\");\r\n        require(_approvedTokens.length <= MAX_TOKEN_WHITELIST_COUNT, \"too many tokens\");\r\n        require(_proposalDeposit >= _processingReward, \"_proposalDeposit cannot be smaller than _processingReward\");\r\n        \r\n        depositToken = _approvedTokens[0];\r\n        // NOTE: move event up here, avoid stack too deep if too many approved tokens\r\n        emit SummonComplete(_summoner, _approvedTokens, now, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDeposit, _dilutionBound, _processingReward);\r\n\r\n\r\n        for (uint256 i = 0; i < _approvedTokens.length; i++) {\r\n            require(_approvedTokens[i] != address(0), \"_approvedToken cannot be 0\");\r\n            require(!tokenWhitelist[_approvedTokens[i]], \"duplicate approved token\");\r\n            tokenWhitelist[_approvedTokens[i]] = true;\r\n            approvedTokens.push(_approvedTokens[i]);\r\n        }\r\n\r\n        periodDuration = _periodDuration;\r\n        votingPeriodLength = _votingPeriodLength;\r\n        gracePeriodLength = _gracePeriodLength;\r\n        proposalDeposit = _proposalDeposit;\r\n        dilutionBound = _dilutionBound;\r\n        processingReward = _processingReward;\r\n\r\n        summoningTime = now;\r\n\r\n        members[_summoner] = Member(_summoner, 1, 0, true, 0, 0);\r\n        memberAddressByDelegateKey[_summoner] = _summoner;\r\n        totalShares = 1;\r\n    }\r\n\r\n    /*****************\r\n    PROPOSAL FUNCTIONS\r\n    *****************/\r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        string memory details\r\n    ) public nonReentrant returns (uint256 proposalId) {\r\n        require(sharesRequested.add(lootRequested) <= MAX_NUMBER_OF_SHARES_AND_LOOT, \"too many shares requested\");\r\n        require(tokenWhitelist[tributeToken], \"tributeToken is not whitelisted\");\r\n        require(tokenWhitelist[paymentToken], \"payment is not whitelisted\");\r\n        require(applicant != address(0), \"applicant cannot be 0\");\r\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant address cannot be reserved\");\r\n        require(members[applicant].jailed == 0, \"proposal applicant must not be jailed\");\r\n\r\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, 'cannot submit more tribute proposals for new tokens - guildbank is full');\r\n        }\r\n\r\n        // collect tribute from proposer and store it in the Moloch until the proposal is processed\r\n        require(IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered), \"tribute token transfer failed\");\r\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\r\n\r\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n\r\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\r\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\r\n    }\r\n\r\n    function submitWhitelistProposal(address tokenToWhitelist, string memory details) public nonReentrant returns (uint256 proposalId) {\r\n        require(tokenToWhitelist != address(0), \"must provide token address\");\r\n        require(!tokenWhitelist[tokenToWhitelist], \"cannot already have whitelisted the token\");\r\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"cannot submit more whitelist proposals\");\r\n\r\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n        flags[4] = true; // whitelist\r\n\r\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags);\r\n        return proposalCount - 1;\r\n    }\r\n\r\n    function submitGuildKickProposal(address memberToKick, string memory details) public nonReentrant returns (uint256 proposalId) {\r\n        Member memory member = members[memberToKick];\r\n\r\n        require(member.shares > 0 || member.loot > 0, \"member must have at least one share or one loot\");\r\n        require(members[memberToKick].jailed == 0, \"member must not already be jailed\");\r\n\r\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n        flags[5] = true; // guild kick\r\n\r\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags);\r\n        return proposalCount - 1;\r\n    }\r\n\r\n    function _submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        string memory details,\r\n        bool[6] memory flags\r\n    ) internal {\r\n        Proposal memory proposal = Proposal({\r\n            applicant : applicant,\r\n            proposer : msg.sender,\r\n            sponsor : address(0),\r\n            sharesRequested : sharesRequested,\r\n            lootRequested : lootRequested,\r\n            tributeOffered : tributeOffered,\r\n            tributeToken : tributeToken,\r\n            paymentRequested : paymentRequested,\r\n            paymentToken : paymentToken,\r\n            startingPeriod : 0,\r\n            yesVotes : 0,\r\n            noVotes : 0,\r\n            flags : flags,\r\n            details : details,\r\n            maxTotalSharesAndLootAtYesVote : 0\r\n        });\r\n\r\n        proposals[proposalCount] = proposal;\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        // NOTE: argument order matters, avoid stack too deep\r\n        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, proposalCount, msg.sender, memberAddress);\r\n        proposalCount += 1;\r\n    }\r\n\r\n    function sponsorProposal(uint256 proposalId) public nonReentrant onlyDelegate {\r\n        // collect proposal deposit from sponsor and store it in the Moloch until the proposal is processed\r\n        require(IERC20(depositToken).transferFrom(msg.sender, address(this), proposalDeposit), \"proposal deposit token transfer failed\");\r\n        unsafeAddToBalance(ESCROW, depositToken, proposalDeposit);\r\n\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.proposer != address(0), 'proposal must have been proposed');\r\n        require(!proposal.flags[0], \"proposal has already been sponsored\");\r\n        require(!proposal.flags[3], \"proposal has been cancelled\");\r\n        require(members[proposal.applicant].jailed == 0, \"proposal applicant must not be jailed\");\r\n\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, 'cannot sponsor more tribute proposals for new tokens - guildbank is full');\r\n        }\r\n\r\n        // whitelist proposal\r\n        if (proposal.flags[4]) {\r\n            require(!tokenWhitelist[address(proposal.tributeToken)], \"cannot already have whitelisted the token\");\r\n            require(!proposedToWhitelist[address(proposal.tributeToken)], 'already proposed to whitelist');\r\n            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"cannot sponsor more whitelist proposals\");\r\n            proposedToWhitelist[address(proposal.tributeToken)] = true;\r\n\r\n        // guild kick proposal\r\n        } else if (proposal.flags[5]) {\r\n            require(!proposedToKick[proposal.applicant], 'already proposed to kick');\r\n            proposedToKick[proposal.applicant] = true;\r\n        }\r\n\r\n        // compute startingPeriod for proposal\r\n        uint256 startingPeriod = max(\r\n            getCurrentPeriod(),\r\n            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length.sub(1)]].startingPeriod\r\n        ).add(1);\r\n\r\n        proposal.startingPeriod = startingPeriod;\r\n\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        proposal.sponsor = memberAddress;\r\n\r\n        proposal.flags[0] = true; // sponsored\r\n\r\n        // append proposal to the queue\r\n        proposalQueue.push(proposalId);\r\n        \r\n        emit SponsorProposal(msg.sender, memberAddress, proposalId, proposalQueue.length.sub(1), startingPeriod);\r\n    }\r\n\r\n    // NOTE: In MolochV2 proposalIndex !== proposalId\r\n    function submitVote(uint256 proposalIndex, uint8 uintVote) public nonReentrant onlyDelegate {\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\r\n        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(uintVote < 3, \"must be less than 3\");\r\n        Vote vote = Vote(uintVote);\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"voting period has not started\");\r\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"proposal voting period has expired\");\r\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"member has already voted\");\r\n        require(vote == Vote.Yes || vote == Vote.No, \"vote must be either Yes or No\");\r\n\r\n        proposal.votesByMember[memberAddress] = vote;\r\n\r\n        if (vote == Vote.Yes) {\r\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\r\n\r\n            // set highest index (latest) yes vote - must be processed for member to ragequit\r\n            if (proposalIndex > member.highestIndexYesVote) {\r\n                member.highestIndexYesVote = proposalIndex;\r\n            }\r\n\r\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\r\n            if (totalShares.add(totalLoot) > proposal.maxTotalSharesAndLootAtYesVote) {\r\n                proposal.maxTotalSharesAndLootAtYesVote = totalShares.add(totalLoot);\r\n            }\r\n\r\n        } else if (vote == Vote.No) {\r\n            proposal.noVotes = proposal.noVotes.add(member.shares);\r\n        }\r\n     \r\n        // NOTE: subgraph indexes by proposalId not proposalIndex since proposalIndex isn't set untill it's been sponsored but proposal is created on submission\r\n        emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, memberAddress, uintVote);\r\n    }\r\n\r\n    function processProposal(uint256 proposalIndex) public nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(!proposal.flags[4] && !proposal.flags[5], \"must be a standard proposal\");\r\n\r\n        proposal.flags[1] = true; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        // Make the proposal fail if the new total number of shares and loot exceeds the limit\r\n        if (totalShares.add(totalLoot).add(proposal.sharesRequested).add(proposal.lootRequested) > MAX_NUMBER_OF_SHARES_AND_LOOT) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance\r\n        if (proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it would result in too many tokens with non-zero balance in guild bank\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0 && totalGuildBankTokens >= MAX_TOKEN_GUILDBANK_COUNT) {\r\n           didPass = false;\r\n        }\r\n\r\n        // PROPOSAL PASSED\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n\r\n            // if the applicant is already a member, add to their existing shares & loot\r\n            if (members[proposal.applicant].exists) {\r\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\r\n                members[proposal.applicant].loot = members[proposal.applicant].loot.add(proposal.lootRequested);\r\n\r\n            // the applicant is a new member, create a new record for them\r\n            } else {\r\n                // if the applicant address is already taken by a member's delegateKey, reset it to their member address\r\n                if (members[memberAddressByDelegateKey[proposal.applicant]].exists) {\r\n                    address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\r\n                    memberAddressByDelegateKey[memberToOverride] = memberToOverride;\r\n                    members[memberToOverride].delegateKey = memberToOverride;\r\n                }\r\n\r\n                // use applicant address as delegateKey by default\r\n                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, proposal.lootRequested, true, 0, 0);\r\n                memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\r\n            }\r\n\r\n            // mint new shares & loot\r\n            totalShares = totalShares.add(proposal.sharesRequested);\r\n            totalLoot = totalLoot.add(proposal.lootRequested);\r\n\r\n            // if the proposal tribute is the first tokens of its kind to make it into the guild bank, increment total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.tributeToken] == 0 && proposal.tributeOffered > 0) {\r\n                totalGuildBankTokens += 1;\r\n            }\r\n\r\n            unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);\r\n            unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposal.paymentRequested);\r\n\r\n            // if the proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {\r\n                totalGuildBankTokens -= 1;\r\n            }\r\n\r\n        // PROPOSAL FAILED\r\n        } else {\r\n            // return all tokens to the proposer (not the applicant, because funds come from proposer)\r\n            unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        }\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n\r\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processWhitelistProposal(uint256 proposalIndex) public nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[4], \"must be a whitelist proposal\");\r\n\r\n        proposal.flags[1] = true; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (approvedTokens.length >= MAX_TOKEN_WHITELIST_COUNT) {\r\n            didPass = false;\r\n        }\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n\r\n            tokenWhitelist[address(proposal.tributeToken)] = true;\r\n            approvedTokens.push(proposal.tributeToken);\r\n        }\r\n\r\n        proposedToWhitelist[address(proposal.tributeToken)] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n\r\n        emit ProcessWhitelistProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processGuildKickProposal(uint256 proposalIndex) public nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[5], \"must be a guild kick proposal\");\r\n\r\n        proposal.flags[1] = true; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n            Member storage member = members[proposal.applicant];\r\n            member.jailed = proposalIndex;\r\n\r\n            // transfer shares to loot\r\n            member.loot = member.loot.add(member.shares);\r\n            totalShares = totalShares.sub(member.shares);\r\n            totalLoot = totalLoot.add(member.shares);\r\n            member.shares = 0; // revoke all shares\r\n        }\r\n\r\n        proposedToKick[proposal.applicant] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n\r\n        emit ProcessGuildKickProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function _didPass(uint256 proposalIndex) internal returns (bool didPass) {\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        didPass = proposal.yesVotes > proposal.noVotes;\r\n\r\n        // Make the proposal fail if the dilutionBound is exceeded\r\n        if ((totalShares.add(totalLoot)).mul(dilutionBound) < proposal.maxTotalSharesAndLootAtYesVote) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if the applicant is jailed\r\n        // - for standard proposals, we don't want the applicant to get any shares/loot/payment\r\n        // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter\r\n        if (members[proposal.applicant].jailed != 0) {\r\n            didPass = false;\r\n        }\r\n\r\n        return didPass;\r\n    }\r\n\r\n    function _validateProposalForProcessing(uint256 proposalIndex) internal view {\r\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"proposal is not ready to be processed\");\r\n        require(proposal.flags[1] == false, \"proposal has already been processed\");\r\n        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex.sub(1)]].flags[1], \"previous proposal must be processed\");\r\n    }\r\n\r\n    function _returnDeposit(address sponsor) internal {\r\n        unsafeInternalTransfer(ESCROW, msg.sender, depositToken, processingReward);\r\n        unsafeInternalTransfer(ESCROW, sponsor, depositToken, proposalDeposit.sub(processingReward));\r\n    }\r\n\r\n    function ragequit(uint256 sharesToBurn, uint256 lootToBurn) public nonReentrant onlyMember {\r\n        _ragequit(msg.sender, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function _ragequit(address memberAddress, uint256 sharesToBurn, uint256 lootToBurn) internal {\r\n        uint256 initialTotalSharesAndLoot = totalShares.add(totalLoot);\r\n\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(member.shares >= sharesToBurn, \"insufficient shares\");\r\n        require(member.loot >= lootToBurn, \"insufficient loot\");\r\n\r\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\r\n\r\n        uint256 sharesAndLootToBurn = sharesToBurn.add(lootToBurn);\r\n\r\n        // burn shares and loot\r\n        member.shares = member.shares.sub(sharesToBurn);\r\n        member.loot = member.loot.sub(lootToBurn);\r\n        totalShares = totalShares.sub(sharesToBurn);\r\n        totalLoot = totalLoot.sub(lootToBurn);\r\n\r\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\r\n            uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][approvedTokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\r\n            if (amountToRagequit > 0) { // gas optimization to allow a higher maximum token limit\r\n                // deliberately not using safemath here to keep overflows from preventing the function execution (which would break ragekicks)\r\n                // if a token overflows, it is because the supply was artificially inflated to oblivion, so we probably don't care about it anyways\r\n                userTokenBalances[GUILD][approvedTokens[i]] -= amountToRagequit;\r\n                userTokenBalances[memberAddress][approvedTokens[i]] += amountToRagequit;\r\n            }\r\n        }\r\n\r\n        emit Ragequit(msg.sender, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function ragekick(address memberToKick) public nonReentrant {\r\n        Member storage member = members[memberToKick];\r\n\r\n        require(member.jailed != 0, \"member must be in jail\");\r\n        require(member.loot > 0, \"member must have some loot\"); // note - should be impossible for jailed member to have shares\r\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\r\n\r\n        _ragequit(memberToKick, 0, member.loot);\r\n    }\r\n\r\n    function withdrawBalance(address token, uint256 amount) public nonReentrant {\r\n        _withdrawBalance(token, amount);\r\n    }\r\n\r\n    function withdrawBalances(address[] memory tokens, uint256[] memory amounts, bool max) public nonReentrant {\r\n        require(tokens.length == amounts.length, \"tokens and amounts arrays must be matching lengths\");\r\n\r\n        for (uint256 i=0; i < tokens.length; i++) {\r\n            uint256 withdrawAmount = amounts[i];\r\n            if (max) { // withdraw the maximum balance\r\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\r\n            }\r\n\r\n            _withdrawBalance(tokens[i], withdrawAmount);\r\n        }\r\n    }\r\n    \r\n    function _withdrawBalance(address token, uint256 amount) internal {\r\n        require(userTokenBalances[msg.sender][token] >= amount, \"insufficient balance\");\r\n        unsafeSubtractFromBalance(msg.sender, token, amount);\r\n        require(IERC20(token).transfer(msg.sender, amount), \"transfer failed\");\r\n        emit Withdraw(msg.sender, token, amount);\r\n    }\r\n\r\n    function collectTokens(address token) public onlyDelegate nonReentrant {\r\n        uint256 amountToCollect = IERC20(token).balanceOf(address(this)).sub(userTokenBalances[TOTAL][token]);\r\n        // only collect if 1) there are tokens to collect 2) token is whitelisted 3) token has non-zero balance\r\n        require(amountToCollect > 0, 'no tokens to collect');\r\n        require(tokenWhitelist[token], 'token to collect must be whitelisted');\r\n        require(userTokenBalances[GUILD][token] > 0, 'token to collect must have non-zero guild bank balance');\r\n        \r\n        unsafeAddToBalance(GUILD, token, amountToCollect);\r\n        emit TokensCollected(token, amountToCollect);\r\n    }\r\n\r\n    // NOTE: requires that delegate key which sent the original proposal cancels, msg.sender == proposal.proposer\r\n    function cancelProposal(uint256 proposalId) public nonReentrant {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(!proposal.flags[0], \"proposal has already been sponsored\");\r\n        require(!proposal.flags[3], \"proposal has already been cancelled\");\r\n        require(msg.sender == proposal.proposer, \"solely the proposer can cancel\");\r\n\r\n        proposal.flags[3] = true; // cancelled\r\n        \r\n        unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        emit CancelProposal(proposalId, msg.sender);\r\n    }\r\n\r\n    function updateDelegateKey(address newDelegateKey) public nonReentrant onlyShareholder {\r\n        require(newDelegateKey != address(0), \"newDelegateKey cannot be 0\");\r\n\r\n        // skip checks if member is setting the delegate key to their member address\r\n        if (newDelegateKey != msg.sender) {\r\n            require(!members[newDelegateKey].exists, \"cannot overwrite existing members\");\r\n            require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"cannot overwrite existing delegate keys\");\r\n        }\r\n\r\n        Member storage member = members[msg.sender];\r\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\r\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\r\n        member.delegateKey = newDelegateKey;\r\n\r\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\r\n    }\r\n\r\n    // can only ragequit if the latest proposal you voted YES on has been processed\r\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\r\n        require(highestIndexYesVote < proposalQueue.length, \"proposal does not exist\");\r\n        return proposals[proposalQueue[highestIndexYesVote]].flags[1];\r\n    }\r\n\r\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\r\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\r\n    }\r\n\r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return now.sub(summoningTime).div(periodDuration);\r\n    }\r\n\r\n    function getProposalQueueLength() public view returns (uint256) {\r\n        return proposalQueue.length;\r\n    }\r\n\r\n    function getProposalFlags(uint256 proposalId) public view returns (bool[6] memory) {\r\n        return proposals[proposalId].flags;\r\n    }\r\n\r\n    function getUserTokenBalance(address user, address token) public view returns (uint256) {\r\n        return userTokenBalances[user][token];\r\n    }\r\n\r\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) {\r\n        require(members[memberAddress].exists, \"member does not exist\");\r\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\r\n        return proposals[proposalQueue[proposalIndex]].votesByMember[memberAddress];\r\n    }\r\n\r\n    function getTokenCount() public view returns (uint256) {\r\n        return approvedTokens.length;\r\n    }\r\n\r\n    /***************\r\n    HELPER FUNCTIONS\r\n    ***************/\r\n    function unsafeAddToBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] += amount;\r\n        userTokenBalances[TOTAL][token] += amount;\r\n    }\r\n\r\n    function unsafeSubtractFromBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] -= amount;\r\n        userTokenBalances[TOTAL][token] -= amount;\r\n    }\r\n\r\n    function unsafeInternalTransfer(address from, address to, address token, uint256 amount) internal {\r\n        unsafeSubtractFromBalance(from, token, amount);\r\n        unsafeAddToBalance(to, token, amount);\r\n    }\r\n\r\n    function fairShare(uint256 balance, uint256 shares, uint256 totalShares) internal pure returns (uint256) {\r\n        require(totalShares != 0);\r\n\r\n        if (balance == 0) { return 0; }\r\n\r\n        uint256 prod = balance * shares;\r\n\r\n        if (prod / balance == shares) { // no overflow in multiplication above?\r\n            return prod / totalShares;\r\n        }\r\n\r\n        return (balance / totalShares) * shares;\r\n    }\r\n}\r\n\r\ncontract MolochSummoner {\r\n    Moloch private m;\r\n    address[] public molochs;\r\n\r\n    event Summoned(address indexed m, address indexed _summoner);\r\n\r\n    function summonMoloch(\r\n        address _summoner,\r\n        address[] memory _approvedTokens,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _proposalDeposit,\r\n        uint256 _dilutionBound,\r\n        uint256 _processingReward) public {\r\n\r\n        m = new Moloch(\r\n            _summoner,\r\n            _approvedTokens,\r\n            _periodDuration,\r\n            _votingPeriodLength,\r\n            _gracePeriodLength,\r\n            _proposalDeposit,\r\n            _dilutionBound,\r\n            _processingReward);\r\n\r\n        molochs.push(address(m));\r\n        emit Summoned(address(m), _summoner);\r\n    }\r\n\r\n    function getMolochCount() public view returns (uint256 MolochCount) {\r\n        return molochs.length;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"m\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_summoner\",\"type\":\"address\"}],\"name\":\"Summoned\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMolochCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"MolochCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"molochs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_summoner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_approvedTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_periodDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_votingPeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gracePeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_proposalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dilutionBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_processingReward\",\"type\":\"uint256\"}],\"name\":\"summonMoloch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MolochSummoner","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3deecdea03f4ac44e984fc04d2e3199aeec8b42d947c77fb279c057bee3826e1"}]}