{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITwoKeyAcquisitionLogicHandler {\n    function canContractorWithdrawUnsoldTokens() public view returns (bool);\n    bool public IS_CAMPAIGN_ACTIVE;\n    function getEstimatedTokenAmount(uint conversionAmountETHWei, bool isFiatConversion) public view returns (uint, uint);\n    function getReferrers(address customer) public view returns (address[]);\n    function updateRefchainRewards(address _converter, uint _conversionId, uint totalBounty2keys) public;\n    function getReferrerPlasmaTotalEarnings(address _referrer) public view returns (uint);\n    function checkAllRequirementsForConversionAndTotalRaised(address converter, uint conversionAmount, bool isFiatConversion, uint debtPaid) external returns (bool,uint);\n}\n\ncontract ITwoKeyCampaign {\n\n    function getNumberOfUsersToContractor(\n        address _user\n    )\n    public\n    view\n    returns (uint);\n\n    function getReceivedFrom(\n        address _receiver\n    )\n    public\n    view\n    returns (address);\n\n    function balanceOf(\n        address _owner\n    )\n    public\n    view\n    returns (uint256);\n\n    function getReferrerCut(\n        address me\n    )\n    public\n    view\n    returns (uint256);\n\n    function getReferrerPlasmaBalance(\n        address _influencer\n    )\n    public\n    view\n    returns (uint);\n\n    function updateReferrerPlasmaBalance(\n        address _influencer,\n        uint _balance\n    )\n    public;\n\n    function updateModeratorRewards(\n        uint moderatorTokens\n    )\n    public;\n\n    address public logicHandler;\n    address public conversionHandler;\n\n}\n\ncontract ITwoKeyCampaignValidator {\n    function isCampaignValidated(address campaign) public view returns (bool);\n    function validateAcquisitionCampaign(address campaign, string nonSingletonHash) public;\n    function validateDonationCampaign(address campaign, address donationConversionHandler, address donationLogicHandler, string nonSingletonHash) public;\n    function validateCPCCampaign(address campaign, string nonSingletonHash) public;\n}\n\ncontract ITwoKeyMaintainersRegistry {\n    function checkIsAddressMaintainer(address _sender) public view returns (bool);\n    function checkIsAddressCoreDev(address _sender) public view returns (bool);\n\n    function addMaintainers(address [] _maintainers) public;\n    function addCoreDevs(address [] _coreDevs) public;\n    function removeMaintainers(address [] _maintainers) public;\n    function removeCoreDevs(address [] _coreDevs) public;\n}\n\ncontract ITwoKeyReg {\n    function addTwoKeyEventSource(address _twoKeyEventSource) public;\n    function changeTwoKeyEventSource(address _twoKeyEventSource) public;\n    function addWhereContractor(address _userAddress, address _contractAddress) public;\n    function addWhereModerator(address _userAddress, address _contractAddress) public;\n    function addWhereReferrer(address _userAddress, address _contractAddress) public;\n    function addWhereConverter(address _userAddress, address _contractAddress) public;\n    function getContractsWhereUserIsContractor(address _userAddress) public view returns (address[]);\n    function getContractsWhereUserIsModerator(address _userAddress) public view returns (address[]);\n    function getContractsWhereUserIsRefferer(address _userAddress) public view returns (address[]);\n    function getContractsWhereUserIsConverter(address _userAddress) public view returns (address[]);\n    function getTwoKeyEventSourceAddress() public view returns (address);\n    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n    function addNameByUser(string _name) public;\n    function getName2Owner(string _name) public view returns (address);\n    function getOwner2Name(address _sender) public view returns (string);\n    function getPlasmaToEthereum(address plasma) public view returns (address);\n    function getEthereumToPlasma(address ethereum) public view returns (address);\n    function checkIfTwoKeyMaintainerExists(address _maintainer) public view returns (bool);\n    function getUserData(address _user) external view returns (bytes);\n}\n\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestCampaignApprovedVersion(string campaignType) public view returns (string);\n}\n\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    * @param contractName is the name of the contract we added new version\n    */\n    event VersionAdded(string version, address implementation, string contractName);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ncontract ITwoKeyBaseReputationRegistryStorage is IStructuredStorage {\n\n}\n\ncontract ITwoKeySingletonUtils {\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    // Modifier to restrict method calls only to maintainers\n    modifier onlyMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressMaintainer(msg.sender));\n        _;\n    }\n\n    /**\n     * @notice Function to get any singleton contract proxy address from TwoKeySingletonRegistry contract\n     * @param contractName is the name of the contract we're looking for\n     */\n    function getAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getContractProxyAddress(contractName);\n    }\n\n    function getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getNonUpgradableContractAddress(contractName);\n    }\n}\n\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\n\ncontract TwoKeyBaseReputationRegistry is Upgradeable, ITwoKeySingletonUtils {\n\n    /**\n     * Storage keys are stored on the top. Here they are in order to avoid any typos\n     */\n    string constant _address2contractorGlobalReputationScoreWei = \"address2contractorGlobalReputationScoreWei\";\n    string constant _address2converterGlobalReputationScoreWei = \"address2converterGlobalReputationScoreWei\";\n    string constant _plasmaAddress2referrerGlobalReputationScoreWei = \"plasmaAddress2referrerGlobalReputationScoreWei\";\n\n    /**\n     * Keys for the addresses we're accessing\n     */\n    string constant _twoKeyCampaignValidator = \"TwoKeyCampaignValidator\";\n    string constant _twoKeyRegistry = \"TwoKeyRegistry\";\n    bool initialized;\n\n    ITwoKeyBaseReputationRegistryStorage public PROXY_STORAGE_CONTRACT;\n\n\n    /**\n     * @notice          Event which will be emitted every time reputation of a user\n     *                  is getting changed. Either positive or negative.\n     */\n    event ReputationUpdated(\n        address _plasmaAddress,\n        string _role, //role in (CONTRACTOR,REFERRER,CONVERTER)\n        string _type, // type in (MONETARY,BUDGET,FEEDBACK)\n        int _points,\n        address _campaignAddress\n    );\n\n    /**\n     * @notice Since using singletone pattern, this is replacement for the constructor\n     * @param _twoKeySingletoneRegistry is the address of registry of all singleton contracts\n     */\n    function setInitialParams(\n        address _twoKeySingletoneRegistry,\n        address _proxyStorage\n    )\n    public\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletoneRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyBaseReputationRegistryStorage(_proxyStorage);\n\n        initialized = true;\n    }\n\n    /**\n     * @notice Modifier to validate that the call is coming from validated campaign\n     */\n    modifier isCodeValid() {\n        address twoKeyCampaignValidator = getAddressFromTwoKeySingletonRegistry(_twoKeyCampaignValidator);\n        require(ITwoKeyCampaignValidator(twoKeyCampaignValidator).isCampaignValidated(msg.sender) == true);\n        _;\n    }\n\n    /**\n     * @notice If the conversion executed event occured, 10 points for the converter and contractor + 10/distance to referrer\n     * @param converter is the address of the converter\n     * @param contractor is the address of the contractor\n     * @param campaign is the address of the acquisition campaign so we can get referrers from there\n     */\n    function updateOnConversionExecutedEvent(\n        address converter,\n        address contractor,\n        address campaign\n    )\n    public\n    isCodeValid\n    {\n        int initialRewardWei = 10*(10**18);\n\n        updateContractorScore(contractor, initialRewardWei);\n\n        bytes32 keyHashConverterScore = keccak256(_address2converterGlobalReputationScoreWei, converter);\n        int converterScore = PROXY_STORAGE_CONTRACT.getInt(keyHashConverterScore);\n        PROXY_STORAGE_CONTRACT.setInt(keyHashConverterScore, converterScore + initialRewardWei);\n\n        emit ReputationUpdated(\n            plasmaOf(converter),\n            \"CONVERTER\",\n            \"MONETARY\",\n            initialRewardWei,\n            msg.sender\n        );\n\n        address[] memory referrers = getReferrers(converter, campaign);\n\n        int j=0;\n        int len = int(referrers.length) - 1;\n        for(int i=len; i>=0; i--) {\n            bytes32 keyHashReferrerScore = keccak256(_plasmaAddress2referrerGlobalReputationScoreWei, referrers[uint(i)]);\n            int referrerScore = PROXY_STORAGE_CONTRACT.getInt(keyHashReferrerScore);\n            int reward = initialRewardWei/(j+1);\n            PROXY_STORAGE_CONTRACT.setInt(keyHashReferrerScore, referrerScore + reward);\n\n            emit ReputationUpdated(\n                referrers[uint(i)],\n                \"REFERRER\",\n                \"MONETARY\",\n                reward,\n                msg.sender\n            );\n\n            j++;\n        }\n    }\n\n    /**\n     * @notice If the conversion rejected event occured, giving penalty points\n     * @param converter is the address of the converter\n     * @param contractor is the address of the contractor\n     * @param campaign is the address of the acquisition campaign so we can get referrers from there\n     */\n    function updateOnConversionRejectedEvent(\n        address converter,\n        address contractor,\n        address campaign\n    )\n    public\n    isCodeValid\n    {\n        int initialRewardWei = 5*(10**18);\n\n        updateContractorScoreOnRejectedConversion(contractor, initialRewardWei);\n\n        bytes32 keyHashConverterScore = keccak256(_address2converterGlobalReputationScoreWei, converter);\n        int converterScore = PROXY_STORAGE_CONTRACT.getInt(keyHashConverterScore);\n        PROXY_STORAGE_CONTRACT.setInt(keyHashConverterScore, converterScore - initialRewardWei);\n\n        emit ReputationUpdated(\n            plasmaOf(converter),\n            \"CONVERTER\",\n            \"MONETARY\",\n            initialRewardWei * (-1),\n            msg.sender\n        );\n\n        address[] memory referrers = getReferrers(converter, campaign);\n\n        int j=0;\n        for(int i=int(referrers.length)-1; i>=0; i--) {\n            bytes32 keyHashReferrerScore = keccak256(_plasmaAddress2referrerGlobalReputationScoreWei, referrers[uint(i)]);\n            int referrerScore = PROXY_STORAGE_CONTRACT.getInt(keyHashReferrerScore);\n            int reward = initialRewardWei/(j+1);\n            PROXY_STORAGE_CONTRACT.setInt(keyHashReferrerScore, referrerScore - reward);\n\n            emit ReputationUpdated(\n                referrers[uint(i)],\n                \"REFERRER\",\n                \"MONETARY\",\n                reward*(-1),\n                msg.sender\n            );\n            j++;\n        }\n    }\n\n    function updateContractorScoreOnRejectedConversion(\n        address contractor,\n        int reward\n    )\n    internal\n    {\n        updateContractorScore(contractor, reward*(-1));\n    }\n\n    function updateContractorScore(\n        address contractor,\n        int reward\n    )\n    internal\n    {\n        bytes32 keyHashContractorScore = keccak256(_address2contractorGlobalReputationScoreWei, contractor);\n        int contractorScore = PROXY_STORAGE_CONTRACT.getInt(keyHashContractorScore);\n        PROXY_STORAGE_CONTRACT.setInt(keyHashContractorScore, contractorScore + reward);\n\n        emit ReputationUpdated(\n            plasmaOf(contractor),\n            \"CONTRACTOR\",\n            \"MONETARY\",\n            reward,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Internal getter from Acquisition campaign to fetch logic handler address\n     */\n    function getLogicHandlerAddress(\n        address campaign\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeyCampaign(campaign).logicHandler();\n    }\n\n    /**\n     * @notice Internal getter from Acquisition campaign to fetch conersion handler address\n     */\n    function getConversionHandlerAddress(\n        address campaign\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeyCampaign(campaign).conversionHandler();\n    }\n\n\n    /**\n     * @notice Function to get all referrers in the chain for specific converter\n     * @param converter is the converter we want to get referral chain\n     * @param campaign is the acquisition campaign contract\n     * @return array of addresses (referrers)\n     */\n    function getReferrers(\n        address converter,\n        address campaign\n    )\n    internal\n    view\n    returns (address[])\n    {\n        address logicHandlerAddress = getLogicHandlerAddress(campaign);\n        return ITwoKeyAcquisitionLogicHandler(logicHandlerAddress).getReferrers(converter);\n    }\n\n\n    /**\n     * @notice          Function to get reputation for user in case he's an influencer or converter\n     */\n    function getReputationForUser(\n        address _plasmaAddress\n    )\n    public\n    view\n    returns (int,int)\n    {\n        address twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY).getContractProxyAddress(_twoKeyRegistry);\n        address ethereumAddress = ITwoKeyReg(twoKeyRegistry).getPlasmaToEthereum(_plasmaAddress);\n\n        bytes32 keyHashConverterScore = keccak256(_address2converterGlobalReputationScoreWei, ethereumAddress);\n        int converterReputationScore = PROXY_STORAGE_CONTRACT.getInt(keyHashConverterScore);\n\n        bytes32 keyHashReferrerScore = keccak256(_plasmaAddress2referrerGlobalReputationScoreWei, _plasmaAddress);\n        int referrerReputationScore = PROXY_STORAGE_CONTRACT.getInt(keyHashReferrerScore);\n\n        return (converterReputationScore, referrerReputationScore);\n    }\n\n    function getGlobalReputationForUser(\n        address _plasmaAddress\n    )\n    public\n    view\n    returns (int)\n    {\n        int converterReputationScore;\n        int referrerReputationScore;\n\n        (converterReputationScore, referrerReputationScore) = getReputationForUser(_plasmaAddress);\n\n        return (converterReputationScore + referrerReputationScore);\n    }\n\n\n    function getGlobalReputationForUsers(\n        address [] plasmaAddresses\n    )\n    public\n    view\n    returns (int[])\n    {\n        uint len = plasmaAddresses.length;\n\n        int [] memory reputations = new int[](len);\n\n        uint i;\n\n        for(i=0; i<len; i++) {\n            reputations[i] = getGlobalReputationForUser(plasmaAddresses[i]);\n        }\n\n        return (reputations);\n    }\n\n    /**\n     * @notice          Function to get reputation for user in case he's contractor\n     */\n    function getReputationForContractor(\n        address _plasmaAddress\n    )\n    public\n    view\n    returns (int)\n    {\n        address twoKeyRegistry = ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY).getContractProxyAddress(_twoKeyRegistry);\n        address ethereumAddress = ITwoKeyReg(twoKeyRegistry).getPlasmaToEthereum(_plasmaAddress);\n\n        bytes32 keyHashContractorScore = keccak256(_address2contractorGlobalReputationScoreWei, ethereumAddress);\n        int contractorReputationScore = PROXY_STORAGE_CONTRACT.getInt(keyHashContractorScore);\n\n        return (contractorReputationScore);\n    }\n\n\n    function getGlobalReputationForContractors(\n        address [] plasmaAddresses\n    )\n    public\n    view\n    returns (int[])\n    {\n        uint len = plasmaAddresses.length;\n\n        int [] memory reputations = new int[](len);\n\n        uint i;\n\n        for(i=0; i<len; i++) {\n            reputations[i] = getReputationForContractor(plasmaAddresses[i]);\n        }\n\n        return (reputations);\n    }\n\n    function plasmaOf(\n        address _address\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeyReg(getAddressFromTwoKeySingletonRegistry(_twoKeyRegistry)).getEthereumToPlasma(_address);\n    }\n}\n\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_twoKeySingletoneRegistry\",\"type\":\"address\"},{\"name\":\"_proxyStorage\",\"type\":\"address\"}],\"name\":\"setInitialParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"converter\",\"type\":\"address\"},{\"name\":\"contractor\",\"type\":\"address\"},{\"name\":\"campaign\",\"type\":\"address\"}],\"name\":\"updateOnConversionExecutedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROXY_STORAGE_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_plasmaAddress\",\"type\":\"address\"}],\"name\":\"getGlobalReputationForUser\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_plasmaAddress\",\"type\":\"address\"}],\"name\":\"getReputationForContractor\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"converter\",\"type\":\"address\"},{\"name\":\"contractor\",\"type\":\"address\"},{\"name\":\"campaign\",\"type\":\"address\"}],\"name\":\"updateOnConversionRejectedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_plasmaAddress\",\"type\":\"address\"}],\"name\":\"getReputationForUser\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_KEY_SINGLETON_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"plasmaAddresses\",\"type\":\"address[]\"}],\"name\":\"getGlobalReputationForContractors\",\"outputs\":[{\"name\":\"\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"plasmaAddresses\",\"type\":\"address[]\"}],\"name\":\"getGlobalReputationForUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_plasmaAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_role\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_points\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"_campaignAddress\",\"type\":\"address\"}],\"name\":\"ReputationUpdated\",\"type\":\"event\"}]","ContractName":"TwoKeyBaseReputationRegistry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}