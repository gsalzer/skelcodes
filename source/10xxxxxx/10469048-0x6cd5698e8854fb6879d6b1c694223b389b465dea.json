{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.0;\r\n\r\n/**\r\n * @title Voting factory + mapping\r\n * @dev Vote creating method\r\n */\r\ncontract Nest_3_VoteFactory {\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 _limitTime = 7 days;                                    //  Vote duration\r\n    uint256 _NNLimitTime = 1 days;                                  //  NestNode raising time\r\n    uint256 _circulationProportion = 51;                            //  Proportion of votes to pass\r\n    uint256 _NNUsedCreate = 10;                                     //  The minimum number of NNs to create a voting contract\r\n    uint256 _NNCreateLimit = 100;                                   //  The minimum number of NNs needed to start voting\r\n    uint256 _emergencyTime = 0;                                     //  The emergency state start time\r\n    uint256 _emergencyTimeLimit = 3 days;                           //  The emergency state duration\r\n    uint256 _emergencyNNAmount = 1000;                              //  The number of NNs required to switch the emergency state\r\n    ERC20 _NNToken;                                                 //  NestNode Token\r\n    ERC20 _nestToken;                                               //  NestToken\r\n    mapping(string => address) _contractAddress;                    //  Voting contract mapping\r\n    mapping(address => bool) _modifyAuthority;                      //  Modify permissions\r\n    mapping(address => address) _myVote;                            //  Personal voting address\r\n    mapping(address => uint256) _emergencyPerson;                   //  Emergency state personal voting number\r\n    mapping(address => bool) _contractData;                         //  Voting contract data\r\n    bool _stateOfEmergency = false;                                 //  Emergency state\r\n    address _destructionAddress;                                    //  Destroy contract address\r\n\r\n    event ContractAddress(address contractAddress);\r\n    \r\n    /**\r\n    * @dev Initialization method\r\n    */\r\n    constructor () public {\r\n        _modifyAuthority[address(msg.sender)] = true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Reset contract\r\n    */\r\n    function changeMapping() public onlyOwner {\r\n        _NNToken = ERC20(checkAddress(\"nestNode\"));\r\n        _destructionAddress = address(checkAddress(\"nest.v3.destruction\"));\r\n        _nestToken = ERC20(address(checkAddress(\"nest\")));\r\n    }\r\n    \r\n    /**\r\n    * @dev Create voting contract\r\n    * @param implementContract The executable contract address for voting\r\n    * @param nestNodeAmount Number of NNs to pledge\r\n    */\r\n    function createVote(address implementContract, uint256 nestNodeAmount) public {\r\n        require(address(tx.origin) == address(msg.sender), \"It can't be a contract\");\r\n        require(nestNodeAmount >= _NNUsedCreate);\r\n        Nest_3_VoteContract newContract = new Nest_3_VoteContract(implementContract, _stateOfEmergency, nestNodeAmount);\r\n        require(_NNToken.transferFrom(address(tx.origin), address(newContract), nestNodeAmount), \"Authorization transfer failed\");\r\n        _contractData[address(newContract)] = true;\r\n        emit ContractAddress(address(newContract));\r\n    }\r\n    \r\n    /**\r\n    * @dev Use NEST to vote\r\n    * @param contractAddress Vote contract address\r\n    */\r\n    function nestVote(address contractAddress) public {\r\n        require(address(msg.sender) == address(tx.origin), \"It can't be a contract\");\r\n        require(_contractData[contractAddress], \"It's not a voting contract\");\r\n        require(!checkVoteNow(address(msg.sender)));\r\n        Nest_3_VoteContract newContract = Nest_3_VoteContract(contractAddress);\r\n        newContract.nestVote();\r\n        _myVote[address(tx.origin)] = contractAddress;\r\n    }\r\n    \r\n    /**\r\n    * @dev Vote using NestNode Token\r\n    * @param contractAddress Vote contract address\r\n    * @param NNAmount Amount of NNs to pledge\r\n    */\r\n    function nestNodeVote(address contractAddress, uint256 NNAmount) public {\r\n        require(address(msg.sender) == address(tx.origin), \"It can't be a contract\");\r\n        require(_contractData[contractAddress], \"It's not a voting contract\");\r\n        Nest_3_VoteContract newContract = Nest_3_VoteContract(contractAddress);\r\n        require(_NNToken.transferFrom(address(tx.origin), address(newContract), NNAmount), \"Authorization transfer failed\");\r\n        newContract.nestNodeVote(NNAmount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Excecute contract\r\n    * @param contractAddress Vote contract address\r\n    */\r\n    function startChange(address contractAddress) public {\r\n        require(address(msg.sender) == address(tx.origin), \"It can't be a contract\");\r\n        require(_contractData[contractAddress], \"It's not a voting contract\");\r\n        Nest_3_VoteContract newContract = Nest_3_VoteContract(contractAddress);\r\n        require(_stateOfEmergency == newContract.checkStateOfEmergency());\r\n        addSuperManPrivate(address(newContract));\r\n        newContract.startChange();\r\n        deleteSuperManPrivate(address(newContract));\r\n    }\r\n    \r\n    /**\r\n    * @dev Switch emergency state-transfer in NestNode Token\r\n    * @param amount Amount of NNs to transfer\r\n    */\r\n    function sendNestNodeForStateOfEmergency(uint256 amount) public {\r\n        require(_NNToken.transferFrom(address(tx.origin), address(this), amount));\r\n        _emergencyPerson[address(tx.origin)] = _emergencyPerson[address(tx.origin)].add(amount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Switch emergency state-transfer out NestNode Token\r\n    */\r\n    function turnOutNestNodeForStateOfEmergency() public {\r\n        require(_emergencyPerson[address(tx.origin)] > 0);\r\n        require(_NNToken.transfer(address(tx.origin), _emergencyPerson[address(tx.origin)]));\r\n        _emergencyPerson[address(tx.origin)] = 0;\r\n        uint256 nestAmount = _nestToken.balanceOf(address(this));\r\n        require(_nestToken.transfer(address(_destructionAddress), nestAmount));\r\n    }\r\n    \r\n    /**\r\n    * @dev Modify emergency state\r\n    */\r\n    function changeStateOfEmergency() public {\r\n        if (_stateOfEmergency) {\r\n            require(now > _emergencyTime.add(_emergencyTimeLimit));\r\n            _stateOfEmergency = false;\r\n            _emergencyTime = 0;\r\n        } else {\r\n            require(_emergencyPerson[address(msg.sender)] > 0);\r\n            require(_NNToken.balanceOf(address(this)) >= _emergencyNNAmount);\r\n            _stateOfEmergency = true;\r\n            _emergencyTime = now;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Check whether participating in the voting\r\n    * @param user Address to check\r\n    * @return bool Whether voting\r\n    */\r\n    function checkVoteNow(address user) public view returns (bool) {\r\n        if (_myVote[user] == address(0x0)) {\r\n            return false;\r\n        } else {\r\n            Nest_3_VoteContract vote = Nest_3_VoteContract(_myVote[user]);\r\n            if (vote.checkContractEffective() || vote.checkPersonalAmount(user) == 0) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Check my voting\r\n    * @param user Address to check\r\n    * @return address Address recently participated in the voting contract address\r\n    */\r\n    function checkMyVote(address user) public view returns (address) {\r\n        return _myVote[user];\r\n    }\r\n    \r\n    //  Check the voting time\r\n    function checkLimitTime() public view returns (uint256) {\r\n        return _limitTime;\r\n    }\r\n    \r\n    //  Check the NestNode raising time\r\n    function checkNNLimitTime() public view returns (uint256) {\r\n        return _NNLimitTime;\r\n    }\r\n    \r\n    //  Check the voting proportion to pass\r\n    function checkCirculationProportion() public view returns (uint256) {\r\n        return _circulationProportion;\r\n    }\r\n    \r\n    //  Check the minimum number of NNs to create a voting contract\r\n    function checkNNUsedCreate() public view returns (uint256) {\r\n        return _NNUsedCreate;\r\n    }\r\n    \r\n    //  Check the minimum number of NNs raised to start a vote\r\n    function checkNNCreateLimit() public view returns (uint256) {\r\n        return _NNCreateLimit;\r\n    }\r\n    \r\n    //  Check whether in emergency state\r\n    function checkStateOfEmergency() public view returns (bool) {\r\n        return _stateOfEmergency;\r\n    }\r\n    \r\n    //  Check the start time of the emergency state\r\n    function checkEmergencyTime() public view returns (uint256) {\r\n        return _emergencyTime;\r\n    }\r\n    \r\n    //  Check the duration of the emergency state\r\n    function checkEmergencyTimeLimit() public view returns (uint256) {\r\n        return _emergencyTimeLimit;\r\n    }\r\n    \r\n    //  Check the amount of personal pledged NNs\r\n    function checkEmergencyPerson(address user) public view returns (uint256) {\r\n        return _emergencyPerson[user];\r\n    }\r\n    \r\n    //  Check the number of NNs required for the emergency\r\n    function checkEmergencyNNAmount() public view returns (uint256) {\r\n        return _emergencyNNAmount;\r\n    }\r\n    \r\n    //  Verify voting contract data\r\n    function checkContractData(address contractAddress) public view returns (bool) {\r\n        return _contractData[contractAddress];\r\n    }\r\n    \r\n    //  Modify voting time\r\n    function changeLimitTime(uint256 num) public onlyOwner {\r\n        require(num > 0, \"Parameter needs to be greater than 0\");\r\n        _limitTime = num;\r\n    }\r\n    \r\n    //  Modify the NestNode raising time\r\n    function changeNNLimitTime(uint256 num) public onlyOwner {\r\n        require(num > 0, \"Parameter needs to be greater than 0\");\r\n        _NNLimitTime = num;\r\n    }\r\n    \r\n    //  Modify the voting proportion\r\n    function changeCirculationProportion(uint256 num) public onlyOwner {\r\n        require(num > 0, \"Parameter needs to be greater than 0\");\r\n        _circulationProportion = num;\r\n    }\r\n    \r\n    //  Modify the minimum number of NNs to create a voting contract\r\n    function changeNNUsedCreate(uint256 num) public onlyOwner {\r\n        _NNUsedCreate = num;\r\n    }\r\n    \r\n    //  Modify the minimum number of NNs to raised to start a voting\r\n    function checkNNCreateLimit(uint256 num) public onlyOwner {\r\n        _NNCreateLimit = num;\r\n    }\r\n    \r\n    //  Modify the emergency state duration\r\n    function changeEmergencyTimeLimit(uint256 num) public onlyOwner {\r\n        require(num > 0);\r\n        _emergencyTimeLimit = num.mul(1 days);\r\n    }\r\n    \r\n    //  Modify the number of NNs required for emergency state\r\n    function changeEmergencyNNAmount(uint256 num) public onlyOwner {\r\n        require(num > 0);\r\n        _emergencyNNAmount = num;\r\n    }\r\n    \r\n    //  Check address\r\n    function checkAddress(string memory name) public view returns (address contractAddress) {\r\n        return _contractAddress[name];\r\n    }\r\n    \r\n    //  Add contract mapping address\r\n    function addContractAddress(string memory name, address contractAddress) public onlyOwner {\r\n        _contractAddress[name] = contractAddress;\r\n    }\r\n    \r\n    //  Add administrator address \r\n    function addSuperMan(address superMan) public onlyOwner {\r\n        _modifyAuthority[superMan] = true;\r\n    }\r\n    function addSuperManPrivate(address superMan) private {\r\n        _modifyAuthority[superMan] = true;\r\n    }\r\n    \r\n    //  Delete administrator address\r\n    function deleteSuperMan(address superMan) public onlyOwner {\r\n        _modifyAuthority[superMan] = false;\r\n    }\r\n    function deleteSuperManPrivate(address superMan) private {\r\n        _modifyAuthority[superMan] = false;\r\n    }\r\n    \r\n    //  Delete voting contract data\r\n    function deleteContractData(address contractAddress) public onlyOwner {\r\n        _contractData[contractAddress] = false;\r\n    }\r\n    \r\n    //  Check whether the administrator\r\n    function checkOwners(address man) public view returns (bool) {\r\n        return _modifyAuthority[man];\r\n    }\r\n    \r\n    //  Administrator only\r\n    modifier onlyOwner() {\r\n        require(checkOwners(msg.sender), \"No authority\");\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Voting contract\r\n */\r\ncontract Nest_3_VoteContract {\r\n    using SafeMath for uint256;\r\n    \r\n    Nest_3_Implement _implementContract;                //  Executable contract\r\n    Nest_3_TokenSave _tokenSave;                        //  Lock-up contract\r\n    Nest_3_VoteFactory _voteFactory;                    //  Voting factory contract\r\n    Nest_3_TokenAbonus _tokenAbonus;                    //  Bonus logic contract\r\n    ERC20 _nestToken;                                   //  NestToken\r\n    ERC20 _NNToken;                                     //  NestNode Token\r\n    address _miningSave;                                //  Mining pool contract\r\n    address _implementAddress;                          //  Executable contract address\r\n    address _destructionAddress;                        //  Destruction contract address\r\n    uint256 _createTime;                                //  Creation time\r\n    uint256 _endTime;                                   //  End time\r\n    uint256 _totalAmount;                               //  Total votes\r\n    uint256 _circulation;                               //  Passed votes\r\n    uint256 _destroyedNest;                             //  Destroyed NEST\r\n    uint256 _NNLimitTime;                               //  NestNode raising time\r\n    uint256 _NNCreateLimit;                             //  Minimum number of NNs to create votes\r\n    uint256 _abonusTimes;                               //  Period number of used snapshot in emergency state\r\n    uint256 _allNNAmount;                               //  Total number of NNs\r\n    bool _effective = false;                            //  Whether vote is effective\r\n    bool _nestVote = false;                             //  Whether NEST vote can be performed\r\n    bool _isChange = false;                             //  Whether NEST vote is executed\r\n    bool _stateOfEmergency;                             //  Whether the contract is in emergency state\r\n    mapping(address => uint256) _personalAmount;        //  Number of personal votes\r\n    mapping(address => uint256) _personalNNAmount;      //  Number of NN personal votes\r\n    \r\n    /**\r\n    * @dev Initialization method\r\n    * @param contractAddress Executable contract address\r\n    * @param stateOfEmergency Whether in emergency state\r\n    * @param NNAmount Amount of NNs\r\n    */\r\n    constructor (address contractAddress, bool stateOfEmergency, uint256 NNAmount) public {\r\n        Nest_3_VoteFactory voteFactory = Nest_3_VoteFactory(address(msg.sender));\r\n        _voteFactory = voteFactory;\r\n        _nestToken = ERC20(voteFactory.checkAddress(\"nest\"));\r\n        _NNToken = ERC20(voteFactory.checkAddress(\"nestNode\"));\r\n        _implementContract = Nest_3_Implement(address(contractAddress));\r\n        _implementAddress = address(contractAddress);\r\n        _destructionAddress = address(voteFactory.checkAddress(\"nest.v3.destruction\"));\r\n        _personalNNAmount[address(tx.origin)] = NNAmount;\r\n        _allNNAmount = NNAmount;\r\n        _createTime = now;                                    \r\n        _endTime = _createTime.add(voteFactory.checkLimitTime());\r\n        _NNLimitTime = voteFactory.checkNNLimitTime();\r\n        _NNCreateLimit = voteFactory.checkNNCreateLimit();\r\n        _stateOfEmergency = stateOfEmergency;\r\n        if (stateOfEmergency) {\r\n            //  If in emergency state, read the last two periods of bonus lock-up and total circulation data\r\n            _tokenAbonus = Nest_3_TokenAbonus(voteFactory.checkAddress(\"nest.v3.tokenAbonus\"));\r\n            _abonusTimes = _tokenAbonus.checkTimes().sub(2);\r\n            require(_abonusTimes > 0);\r\n            _circulation = _tokenAbonus.checkTokenAllValueHistory(address(_nestToken),_abonusTimes).mul(voteFactory.checkCirculationProportion()).div(100);\r\n        } else {\r\n            _miningSave = address(voteFactory.checkAddress(\"nest.v3.miningSave\"));\r\n            _tokenSave = Nest_3_TokenSave(voteFactory.checkAddress(\"nest.v3.tokenSave\"));\r\n            _circulation = (uint256(10000000000 ether).sub(_nestToken.balanceOf(address(_miningSave))).sub(_nestToken.balanceOf(address(_destructionAddress)))).mul(voteFactory.checkCirculationProportion()).div(100);\r\n        }\r\n        if (_allNNAmount >= _NNCreateLimit) {\r\n            _nestVote = true;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev NEST voting\r\n    */\r\n    function nestVote() public onlyFactory {\r\n        require(now <= _endTime, \"Voting time exceeded\");\r\n        require(!_effective, \"Vote in force\");\r\n        require(_nestVote);\r\n        require(_personalAmount[address(tx.origin)] == 0, \"Have voted\");\r\n        uint256 amount;\r\n        if (_stateOfEmergency) {\r\n            //  If in emergency state, read the last two periods of bonus lock-up and total circulation data\r\n            amount = _tokenAbonus.checkTokenSelfHistory(address(_nestToken),_abonusTimes, address(tx.origin));\r\n        } else {\r\n            amount = _tokenSave.checkAmount(address(tx.origin), address(_nestToken));\r\n        }\r\n        _personalAmount[address(tx.origin)] = amount;\r\n        _totalAmount = _totalAmount.add(amount);\r\n        ifEffective();\r\n    }\r\n    \r\n    /**\r\n    * @dev NEST voting cancellation\r\n    */\r\n    function nestVoteCancel() public {\r\n        require(address(msg.sender) == address(tx.origin), \"It can't be a contract\");\r\n        require(now <= _endTime, \"Voting time exceeded\");\r\n        require(!_effective, \"Vote in force\");\r\n        require(_personalAmount[address(tx.origin)] > 0, \"No vote\");                     \r\n        _totalAmount = _totalAmount.sub(_personalAmount[address(tx.origin)]);\r\n        _personalAmount[address(tx.origin)] = 0;\r\n    }\r\n    \r\n    /**\r\n    * @dev  NestNode voting\r\n    * @param NNAmount Amount of NNs\r\n    */\r\n    function nestNodeVote(uint256 NNAmount) public onlyFactory {\r\n        require(now <= _createTime.add(_NNLimitTime), \"Voting time exceeded\");\r\n        require(!_nestVote);\r\n        _personalNNAmount[address(tx.origin)] = _personalNNAmount[address(tx.origin)].add(NNAmount);\r\n        _allNNAmount = _allNNAmount.add(NNAmount);\r\n        if (_allNNAmount >= _NNCreateLimit) {\r\n            _nestVote = true;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Withdrawing lock-up NNs\r\n    */\r\n    function turnOutNestNode() public {\r\n        if (_nestVote) {\r\n            //  Normal NEST voting\r\n            if (!_stateOfEmergency || !_effective) {\r\n                //  Non-emergency state\r\n                require(now > _endTime, \"Vote unenforceable\");\r\n            }\r\n        } else {\r\n            //  NN voting\r\n            require(now > _createTime.add(_NNLimitTime));\r\n        }\r\n        require(_personalNNAmount[address(tx.origin)] > 0);\r\n        //  Reverting back the NNs\r\n        require(_NNToken.transfer(address(tx.origin), _personalNNAmount[address(tx.origin)]));\r\n        _personalNNAmount[address(tx.origin)] = 0;\r\n        //  Destroying NEST Tokens \r\n        uint256 nestAmount = _nestToken.balanceOf(address(this));\r\n        _destroyedNest = _destroyedNest.add(nestAmount);\r\n        require(_nestToken.transfer(address(_destructionAddress), nestAmount));\r\n    }\r\n    \r\n    /**\r\n    * @dev Execute the contract\r\n    */\r\n    function startChange() public onlyFactory {\r\n        require(!_isChange);\r\n        _isChange = true;\r\n        if (_stateOfEmergency) {\r\n            require(_effective, \"Vote unenforceable\");\r\n        } else {\r\n            require(_effective && now > _endTime, \"Vote unenforceable\");\r\n        }\r\n        //  Add the executable contract to the administrator list\r\n        _voteFactory.addSuperMan(address(_implementContract));\r\n        //  Execute\r\n        _implementContract.doit();\r\n        //  Delete the authorization\r\n        _voteFactory.deleteSuperMan(address(_implementContract));\r\n    }\r\n    \r\n    /**\r\n    * @dev check whether the vote is effective\r\n    */\r\n    function ifEffective() private {\r\n        if (_totalAmount >= _circulation) {\r\n            _effective = true;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Check whether the vote is over\r\n    */\r\n    function checkContractEffective() public view returns (bool) {\r\n        if (_effective || now > _endTime) {\r\n            return true;\r\n        } \r\n        return false;\r\n    }\r\n    \r\n    //  Check the executable implement contract address\r\n    function checkImplementAddress() public view returns (address) {\r\n        return _implementAddress;\r\n    }\r\n    \r\n    //  Check the voting start time\r\n    function checkCreateTime() public view returns (uint256) {\r\n        return _createTime;\r\n    }\r\n    \r\n    //  Check the voting end time\r\n    function checkEndTime() public view returns (uint256) {\r\n        return _endTime;\r\n    }\r\n    \r\n    //  Check the current total number of votes\r\n    function checkTotalAmount() public view returns (uint256) {\r\n        return _totalAmount;\r\n    }\r\n    \r\n    //  Check the number of votes to pass\r\n    function checkCirculation() public view returns (uint256) {\r\n        return _circulation;\r\n    }\r\n    \r\n    //  Check the number of personal votes\r\n    function checkPersonalAmount(address user) public view returns (uint256) {\r\n        return _personalAmount[user];\r\n    }\r\n    \r\n    //  Check the destroyed NEST\r\n    function checkDestroyedNest() public view returns (uint256) {\r\n        return _destroyedNest;\r\n    }\r\n    \r\n    //  Check whether the contract is effective\r\n    function checkEffective() public view returns (bool) {\r\n        return _effective;\r\n    }\r\n    \r\n    //  Check whether in emergency state\r\n    function checkStateOfEmergency() public view returns (bool) {\r\n        return _stateOfEmergency;\r\n    }\r\n    \r\n    //  Check NestNode raising time\r\n    function checkNNLimitTime() public view returns (uint256) {\r\n        return _NNLimitTime;\r\n    }\r\n    \r\n    //  Check the minimum number of NNs to create a vote\r\n    function checkNNCreateLimit() public view returns (uint256) {\r\n        return _NNCreateLimit;\r\n    }\r\n    \r\n    //  Check the period number of snapshot used in the emergency state\r\n    function checkAbonusTimes() public view returns (uint256) {\r\n        return _abonusTimes;\r\n    }\r\n    \r\n    //  Check number of personal votes\r\n    function checkPersonalNNAmount(address user) public view returns (uint256) {\r\n        return _personalNNAmount[address(user)];\r\n    }\r\n    \r\n    //  Check the total number of NNs\r\n    function checkAllNNAmount() public view returns (uint256) {\r\n        return _allNNAmount;\r\n    }\r\n    \r\n    //  Check whether NEST voting is available\r\n    function checkNestVote() public view returns (bool) {\r\n        return _nestVote;\r\n    }\r\n    \r\n    //  Check whether it has been excecuted\r\n    function checkIsChange() public view returns (bool) {\r\n        return _isChange;\r\n    }\r\n    \r\n    //  Vote Factory contract only\r\n    modifier onlyFactory() {\r\n        require(address(_voteFactory) == address(msg.sender), \"No authority\");\r\n        _;\r\n    }\r\n}\r\n\r\n//  Executable contract\r\ninterface Nest_3_Implement {\r\n    //  Execute\r\n    function doit() external;\r\n}\r\n\r\n//  NEST lock-up contract\r\ninterface Nest_3_TokenSave {\r\n    //  Check lock-up amount\r\n    function checkAmount(address sender, address token) external view returns (uint256);\r\n}\r\n\r\n//  Bonus logic contract\r\ninterface Nest_3_TokenAbonus {\r\n    //  Check NEST circulation snapshot\r\n    function checkTokenAllValueHistory(address token, uint256 times) external view returns (uint256);\r\n    //  Check NEST user balance snapshot\r\n    function checkTokenSelfHistory(address token, uint256 times, address user) external view returns (uint256);\r\n    //  Check bonus ledger period\r\n    function checkTimes() external view returns (uint256);\r\n}\r\n\r\n//  Erc20 contract\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ContractAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"addContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superMan\",\"type\":\"address\"}],\"name\":\"addSuperMan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeCirculationProportion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeEmergencyNNAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeEmergencyTimeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeLimitTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeMapping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeNNLimitTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeNNUsedCreate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeStateOfEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"checkAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkCirculationProportion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"checkContractData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEmergencyNNAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkEmergencyPerson\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEmergencyTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEmergencyTimeLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkLimitTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkMyVote\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"checkNNCreateLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkNNCreateLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkNNLimitTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkNNUsedCreate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"man\",\"type\":\"address\"}],\"name\":\"checkOwners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkStateOfEmergency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkVoteNow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nestNodeAmount\",\"type\":\"uint256\"}],\"name\":\"createVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"deleteContractData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superMan\",\"type\":\"address\"}],\"name\":\"deleteSuperMan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"NNAmount\",\"type\":\"uint256\"}],\"name\":\"nestNodeVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"nestVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendNestNodeForStateOfEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"startChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"turnOutNestNodeForStateOfEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Nest_3_VoteFactory","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e245d2fac7fb05efe6914180891050801ac814d143bf1b6854d3455aed0b190e"}]}