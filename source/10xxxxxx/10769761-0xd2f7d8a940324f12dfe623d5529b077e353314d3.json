{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/os/ERC20.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/token/ERC20.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/lib/os/SafeMath.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\r\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\r\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\r\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a, ERROR_ADD_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, ERROR_DIV_ZERO);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/SafeERC20.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/SafeERC20.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\r\n    // https://github.com/ethereum/solidity/issues/3544\r\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferCallData = abi.encodeWithSelector(\r\n            TRANSFER_SELECTOR,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), transferCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferFromCallData = abi.encodeWithSelector(\r\n            _token.transferFrom.selector,\r\n            _from,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\r\n        bytes memory approveCallData = abi.encodeWithSelector(\r\n            _token.approve.selector,\r\n            _spender,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), approveCallData);\r\n    }\r\n\r\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata) private returns (bool) {\r\n        bool ret;\r\n        assembly {\r\n            let ptr := mload(0x40)    // free memory pointer\r\n\r\n            let success := call(\r\n                gas,                  // forward all gas\r\n                _addr,                // address\r\n                0,                    // no value\r\n                add(_calldata, 0x20), // calldata start\r\n                mload(_calldata),     // calldata length\r\n                ptr,                  // write output over free memory\r\n                0x20                  // uint256 return\r\n            )\r\n\r\n            if gt(success, 0) {\r\n            // Check number of bytes returned from last function call\r\n                switch returndatasize\r\n\r\n                // No bytes returned: assume success\r\n                case 0 {\r\n                    ret := 1\r\n                }\r\n\r\n                // 32 bytes returned: check if non-zero\r\n                case 0x20 {\r\n                // Only return success if returned data was true\r\n                // Already have output in ptr\r\n                    ret := eq(mload(ptr), 1)\r\n                }\r\n\r\n                // Not sure what was returned: don't mark as success\r\n                default { }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/IsContract.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/IsContract.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ncontract IsContract {\r\n    /*\r\n    * NOTE: this should NEVER be used for authentication\r\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\r\n    *\r\n    * This is only intended to be used as a sanity check that an address is actually a contract,\r\n    * RATHER THAN an address not being a contract.\r\n    */\r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly { size := extcodesize(_target) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/Uint256Helpers.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Uint256Helpers.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\nlibrary Uint256Helpers {\r\n    uint256 private constant MAX_UINT8 = uint8(-1);\r\n    uint256 private constant MAX_UINT64 = uint64(-1);\r\n\r\n    string private constant ERROR_UINT8_NUMBER_TOO_BIG = \"UINT8_NUMBER_TOO_BIG\";\r\n    string private constant ERROR_UINT64_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\r\n\r\n    function toUint8(uint256 a) internal pure returns (uint8) {\r\n        require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);\r\n        return uint8(a);\r\n    }\r\n\r\n    function toUint64(uint256 a) internal pure returns (uint64) {\r\n        require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);\r\n        return uint64(a);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/TimeHelpers.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/TimeHelpers.sol\r\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\ncontract TimeHelpers {\r\n    using Uint256Helpers for uint256;\r\n\r\n    /**\r\n    * @dev Returns the current block number.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current block number, converted to uint64.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber64() internal view returns (uint64) {\r\n        return getBlockNumber().toUint64();\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp() internal view returns (uint256) {\r\n        return block.timestamp; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp, converted to uint64.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp64() internal view returns (uint64) {\r\n        return getTimestamp().toUint64();\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/UnstructuredStorage.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/UnstructuredStorage.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\nlibrary UnstructuredStorage {\r\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function setStorageBool(bytes32 position, bool data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageAddress(bytes32 position, address data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageUint256(bytes32 position, uint256 data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/Initializable.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Initializable.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\ncontract Initializable is TimeHelpers {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    // keccak256(\"aragonOS.initializable.initializationBlock\")\r\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\r\n\r\n    string private constant ERROR_ALREADY_INITIALIZED = \"INIT_ALREADY_INITIALIZED\";\r\n    string private constant ERROR_NOT_INITIALIZED = \"INIT_NOT_INITIALIZED\";\r\n\r\n    modifier onlyInit {\r\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\r\n        _;\r\n    }\r\n\r\n    modifier isInitialized {\r\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return Block number in which the contract was initialized\r\n    */\r\n    function getInitializationBlock() public view returns (uint256) {\r\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\r\n    }\r\n\r\n    /**\r\n    * @return Whether the contract has been initialized by the time of the current block\r\n    */\r\n    function hasInitialized() public view returns (bool) {\r\n        uint256 initializationBlock = getInitializationBlock();\r\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract after initialization has finished.\r\n    */\r\n    function initialized() internal onlyInit {\r\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract after initialization to enable the contract\r\n    *      at a future block number rather than immediately.\r\n    */\r\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\r\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/Petrifiable.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Petrifiable.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\ncontract Petrifiable is Initializable {\r\n    // Use block UINT256_MAX (which should be never) as the initializable date\r\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\r\n\r\n    function isPetrified() public view returns (bool) {\r\n        return getInitializationBlock() == PETRIFIED_BLOCK;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to be called by top level contract to prevent being initialized.\r\n    *      Useful for freezing base contracts when they're used behind proxies.\r\n    */\r\n    function petrify() internal onlyInit {\r\n        initializedAt(PETRIFIED_BLOCK);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/Autopetrified.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Autopetrified.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\ncontract Autopetrified is Petrifiable {\r\n    constructor() public {\r\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\r\n        // This renders them uninitializable (and unusable without a proxy).\r\n        petrify();\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Checkpointing.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n/**\r\n* @title Checkpointing - Library to handle a historic set of numeric values\r\n*/\r\nlibrary Checkpointing {\r\n    uint256 private constant MAX_UINT192 = uint256(uint192(-1));\r\n\r\n    string private constant ERROR_VALUE_TOO_BIG = \"CHECKPOINT_VALUE_TOO_BIG\";\r\n    string private constant ERROR_CANNOT_ADD_PAST_VALUE = \"CHECKPOINT_CANNOT_ADD_PAST_VALUE\";\r\n\r\n    /**\r\n     * @dev To specify a value at a given point in time, we need to store two values:\r\n     *      - `time`: unit-time value to denote the first time when a value was registered\r\n     *      - `value`: a positive numeric value to registered at a given point in time\r\n     *\r\n     *      Note that `time` does not need to refer necessarily to a timestamp value, any time unit could be used\r\n     *      for it like block numbers, terms, etc.\r\n     */\r\n    struct Checkpoint {\r\n        uint64 time;\r\n        uint192 value;\r\n    }\r\n\r\n    /**\r\n     * @dev A history simply denotes a list of checkpoints\r\n     */\r\n    struct History {\r\n        Checkpoint[] history;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new value to a history for a given point in time. This function does not allow to add values previous\r\n     *      to the latest registered value, if the value willing to add corresponds to the latest registered value, it\r\n     *      will be updated.\r\n     * @param self Checkpoints history to be altered\r\n     * @param _time Point in time to register the given value\r\n     * @param _value Numeric value to be registered at the given point in time\r\n     */\r\n    function add(History storage self, uint64 _time, uint256 _value) internal {\r\n        require(_value <= MAX_UINT192, ERROR_VALUE_TOO_BIG);\r\n        _add192(self, _time, uint192(_value));\r\n    }\r\n\r\n    /**\r\n     * TODO\r\n     */\r\n    function lastUpdate(History storage self) internal view returns (uint256) {\r\n        uint256 length = self.history.length;\r\n\r\n        if (length > 0) {\r\n            return uint256(self.history[length - 1].time);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Fetch the latest registered value of history, it will return zero if there was no value registered\r\n     * @param self Checkpoints history to be queried\r\n     */\r\n    function getLast(History storage self) internal view returns (uint256) {\r\n        uint256 length = self.history.length;\r\n        if (length > 0) {\r\n            return uint256(self.history[length - 1].value);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Fetch the most recent registered past value of a history based on a given point in time that is not known\r\n     *      how recent it is beforehand. It will return zero if there is no registered value or if given time is\r\n     *      previous to the first registered value.\r\n     *      It uses a binary search.\r\n     * @param self Checkpoints history to be queried\r\n     * @param _time Point in time to query the most recent registered past value of\r\n     */\r\n    function get(History storage self, uint64 _time) internal view returns (uint256) {\r\n        return _binarySearch(self, _time);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a new value to a history for a given point in time. This function does not allow to\r\n     *      add values previous to the latest registered value, if the value willing to add corresponds to the latest\r\n     *      registered value, it will be updated.\r\n     * @param self Checkpoints history to be altered\r\n     * @param _time Point in time to register the given value\r\n     * @param _value Numeric value to be registered at the given point in time\r\n     */\r\n    function _add192(History storage self, uint64 _time, uint192 _value) private {\r\n        uint256 length = self.history.length;\r\n        if (length == 0 || self.history[self.history.length - 1].time < _time) {\r\n            // If there was no value registered or the given point in time is after the latest registered value,\r\n            // we can insert it to the history directly.\r\n            self.history.push(Checkpoint(_time, _value));\r\n        } else {\r\n            // If the point in time given for the new value is not after the latest registered value, we must ensure\r\n            // we are only trying to update the latest value, otherwise we would be changing past data.\r\n            Checkpoint storage currentCheckpoint = self.history[length - 1];\r\n            require(_time == currentCheckpoint.time, ERROR_CANNOT_ADD_PAST_VALUE);\r\n            currentCheckpoint.value = _value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Private function execute a binary search to find the most recent registered past value of a history based on\r\n     *      a given point in time. It will return zero if there is no registered value or if given time is previous to\r\n     *      the first registered value. Note that this function will be more suitable when don't know how recent the\r\n     *      time used to index may be.\r\n     * @param self Checkpoints history to be queried\r\n     * @param _time Point in time to query the most recent registered past value of\r\n     */\r\n    function _binarySearch(History storage self, uint64 _time) private view returns (uint256) {\r\n        // If there was no value registered for the given history return simply zero\r\n        uint256 length = self.history.length;\r\n        if (length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // If the requested time is equal to or after the time of the latest registered value, return latest value\r\n        uint256 lastIndex = length - 1;\r\n        if (_time >= self.history[lastIndex].time) {\r\n            return uint256(self.history[lastIndex].value);\r\n        }\r\n\r\n        // If the requested time is previous to the first registered value, return zero to denote missing checkpoint\r\n        if (_time < self.history[0].time) {\r\n            return 0;\r\n        }\r\n\r\n        // Execute a binary search between the checkpointed times of the history\r\n        uint256 low = 0;\r\n        uint256 high = lastIndex;\r\n\r\n        while (high > low) {\r\n            // No need for SafeMath: for this to overflow array size should be ~2^255\r\n            uint256 mid = (high + low + 1) / 2;\r\n            Checkpoint storage checkpoint = self.history[mid];\r\n            uint64 midTime = checkpoint.time;\r\n\r\n            if (_time > midTime) {\r\n                low = mid;\r\n            } else if (_time < midTime) {\r\n                // No need for SafeMath: high > low >= 0 => high >= 1 => mid >= 1\r\n                high = mid - 1;\r\n            } else {\r\n                return uint256(checkpoint.value);\r\n            }\r\n        }\r\n\r\n        return uint256(self.history[low].value);\r\n    }\r\n}\r\n\r\n// File: contracts/standards/ERC900.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n// Interface for ERC900: https://eips.ethereum.org/EIPS/eip-900\r\ninterface ERC900 {\r\n    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n\r\n    /**\r\n     * @dev Stake a certain amount of tokens\r\n     * @param _amount Amount of tokens to be staked\r\n     * @param _data Optional data that can be used to add signalling information in more complex staking applications\r\n     */\r\n    function stake(uint256 _amount, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @dev Stake a certain amount of tokens in favor of someone\r\n     * @param _user Address to stake an amount of tokens to\r\n     * @param _amount Amount of tokens to be staked\r\n     * @param _data Optional data that can be used to add signalling information in more complex staking applications\r\n     */\r\n    function stakeFor(address _user, uint256 _amount, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @dev Unstake a certain amount of tokens\r\n     * @param _amount Amount of tokens to be unstaked\r\n     * @param _data Optional data that can be used to add signalling information in more complex staking applications\r\n     */\r\n    function unstake(uint256 _amount, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @dev Tell the total amount of tokens staked for an address\r\n     * @param _addr Address querying the total amount of tokens staked for\r\n     * @return Total amount of tokens staked for an address\r\n     */\r\n    function totalStakedFor(address _addr) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Tell the total amount of tokens staked\r\n     * @return Total amount of tokens staked\r\n     */\r\n    function totalStaked() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Tell the address of the token used for staking\r\n     * @return Address of the token used for staking\r\n     */\r\n    function token() external view returns (address);\r\n\r\n    /*\r\n     * @dev Tell if the current registry supports historic information or not\r\n     * @return True if the optional history functions are implemented, false otherwise\r\n     */\r\n    function supportsHistory() external pure returns (bool);\r\n}\r\n\r\n// File: contracts/locking/IStakingLocking.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ninterface IStakingLocking {\r\n    event NewLockManager(address indexed account, address indexed lockManager, bytes data);\r\n    event Unlocked(address indexed account, address indexed lockManager, uint256 amount);\r\n    event LockAmountChanged(address indexed account, address indexed lockManager, uint256 amount, bool increase);\r\n    event LockAllowanceChanged(address indexed account, address indexed lockManager, uint256 allowance, bool increase);\r\n    event LockManagerRemoved(address indexed account, address lockManager);\r\n    event LockManagerTransferred(address indexed account, address indexed oldLockManager, address newLockManager);\r\n    event StakeTransferred(address indexed from, address to, uint256 amount);\r\n\r\n    function allowManager(address _lockManager, uint256 _allowance, bytes calldata _data) external;\r\n    function allowManagerAndLock(uint256 _amount, address _lockManager, uint256 _allowance, bytes calldata _data) external;\r\n    function unlockAndRemoveManager(address _account, address _lockManager) external;\r\n    function increaseLockAllowance(address _lockManager, uint256 _allowance) external;\r\n    function decreaseLockAllowance(address _account, address _lockManager, uint256 _allowance) external;\r\n    function lock(address _account, address _lockManager, uint256 _amount) external;\r\n    function unlock(address _account, address _lockManager, uint256 _amount) external;\r\n    function setLockManager(address _account, address _newLockManager) external;\r\n    function transfer(address _to, uint256 _amount) external;\r\n    function transferAndUnstake(address _to, uint256 _amount) external;\r\n    function slash(address _account, address _to, uint256 _amount) external;\r\n    function slashAndUnstake(address _account, address _to, uint256 _amount) external;\r\n\r\n    function getLock(address _account, address _lockManager) external view returns (uint256 _amount, uint256 _allowance);\r\n    function unlockedBalanceOf(address _account) external view returns (uint256);\r\n    function lockedBalanceOf(address _user) external view returns (uint256);\r\n    function getBalancesOf(address _user) external view returns (uint256 staked, uint256 locked);\r\n    function canUnlock(address _sender, address _account, address _lockManager, uint256 _amount) external view returns (bool);\r\n}\r\n\r\n// File: contracts/locking/ILockManager.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ninterface ILockManager {\r\n    /**\r\n     * @notice Check if `_user`'s by `_lockManager` can be unlocked\r\n     * @param _user Owner of lock\r\n     * @param _amount Amount of locked tokens to unlock\r\n     * @return Whether given lock of given owner can be unlocked by given sender\r\n     */\r\n    function canUnlock(address _user, uint256 _amount) external view returns (bool);\r\n}\r\n\r\n// File: contracts/Staking.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Staking is Autopetrified, ERC900, IStakingLocking, IsContract {\r\n    using SafeMath for uint256;\r\n    using Checkpointing for Checkpointing.History;\r\n    using SafeERC20 for ERC20;\r\n\r\n    uint256 private constant MAX_UINT64 = uint256(uint64(-1));\r\n\r\n    string private constant ERROR_TOKEN_NOT_CONTRACT = \"STAKING_TOKEN_NOT_CONTRACT\";\r\n    string private constant ERROR_AMOUNT_ZERO = \"STAKING_AMOUNT_ZERO\";\r\n    string private constant ERROR_TOKEN_TRANSFER = \"STAKING_TOKEN_TRANSFER_FAIL\";\r\n    string private constant ERROR_TOKEN_DEPOSIT = \"STAKING_TOKEN_DEPOSIT_FAIL\";\r\n    string private constant ERROR_TOKEN_NOT_SENDER = \"STAKING_TOKEN_NOT_SENDER\";\r\n    string private constant ERROR_WRONG_TOKEN = \"STAKING_WRONG_TOKEN\";\r\n    string private constant ERROR_NOT_ENOUGH_BALANCE = \"STAKING_NOT_ENOUGH_BALANCE\";\r\n    string private constant ERROR_NOT_ENOUGH_ALLOWANCE = \"STAKING_NOT_ENOUGH_ALLOWANCE\";\r\n    string private constant ERROR_SENDER_NOT_ALLOWED = \"STAKING_SENDER_NOT_ALLOWED\";\r\n    string private constant ERROR_ALLOWANCE_ZERO = \"STAKING_ALLOWANCE_ZERO\";\r\n    string private constant ERROR_LOCK_ALREADY_EXISTS = \"STAKING_LOCK_ALREADY_EXISTS\";\r\n    string private constant ERROR_LOCK_DOES_NOT_EXIST = \"STAKING_LOCK_DOES_NOT_EXIST\";\r\n    string private constant ERROR_NOT_ENOUGH_LOCK = \"STAKING_NOT_ENOUGH_LOCK\";\r\n    string private constant ERROR_CANNOT_UNLOCK = \"STAKING_CANNOT_UNLOCK\";\r\n    string private constant ERROR_CANNOT_CHANGE_ALLOWANCE = \"STAKING_CANNOT_CHANGE_ALLOWANCE\";\r\n    string private constant ERROR_LOCKMANAGER_CALL_FAIL = \"STAKING_LOCKMANAGER_CALL_FAIL\";\r\n    string private constant ERROR_BLOCKNUMBER_TOO_BIG = \"STAKING_BLOCKNUMBER_TOO_BIG\";\r\n\r\n    struct Lock {\r\n        uint256 amount;\r\n        uint256 allowance;  // must be greater than zero to consider the lock active, and always greater than or equal to amount\r\n    }\r\n\r\n    struct Account {\r\n        mapping (address => Lock) locks; // from manager to lock\r\n        uint256 totalLocked;\r\n        Checkpointing.History stakedHistory;\r\n    }\r\n\r\n    ERC20 internal stakingToken;\r\n    mapping (address => Account) internal accounts;\r\n    Checkpointing.History internal totalStakedHistory;\r\n\r\n    /**\r\n     * @notice Initialize Staking app with token `_stakingToken`\r\n     * @param _stakingToken ERC20 token used for staking\r\n     */\r\n    function initialize(ERC20 _stakingToken) external {\r\n        require(isContract(address(_stakingToken)), ERROR_TOKEN_NOT_CONTRACT);\r\n        initialized();\r\n        stakingToken = _stakingToken;\r\n    }\r\n\r\n    /**\r\n     * @notice Stakes `@tokenAmount(self.token(): address, _amount)`, transferring them from `msg.sender`\r\n     * @param _amount Number of tokens staked\r\n     * @param _data Used in Staked event, to add signalling information in more complex staking applications\r\n     */\r\n    function stake(uint256 _amount, bytes calldata _data) external isInitialized {\r\n        _stakeFor(msg.sender, msg.sender, _amount, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Stakes `@tokenAmount(self.token(): address, _amount)`, transferring them from `msg.sender`, and assigns them to `_user`\r\n     * @param _user The receiving accounts for the tokens staked\r\n     * @param _amount Number of tokens staked\r\n     * @param _data Used in Staked event, to add signalling information in more complex staking applications\r\n     */\r\n    function stakeFor(address _user, uint256 _amount, bytes calldata _data) external isInitialized {\r\n        _stakeFor(msg.sender, _user, _amount, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstakes `@tokenAmount(self.token(): address, _amount)`, returning them to the user\r\n     * @param _amount Number of tokens to unstake\r\n     * @param _data Used in Unstaked event, to add signalling information in more complex staking applications\r\n     */\r\n    function unstake(uint256 _amount, bytes calldata _data) external isInitialized {\r\n        // unstaking 0 tokens is not allowed\r\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        _unstake(msg.sender, _amount, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Allow `_lockManager` to lock up to `@tokenAmount(self.token(): address, _allowance)` of `msg.sender`\r\n     *         It creates a new lock, so the lock for this manager cannot exist before.\r\n     * @param _lockManager The manager entity for this particular lock\r\n     * @param _allowance Amount of tokens that the manager can lock\r\n     * @param _data Data to parametrize logic for the lock to be enforced by the manager\r\n     */\r\n    function allowManager(address _lockManager, uint256 _allowance, bytes calldata _data) external isInitialized {\r\n        _allowManager(_lockManager, _allowance, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Lock `@tokenAmount(self.token(): address, _amount)` and assign `_lockManager` as manager with `@tokenAmount(self.token(): address, _allowance)` allowance and `_data` as data, so they can not be unstaked\r\n     * @param _amount The amount of tokens to be locked\r\n     * @param _lockManager The manager entity for this particular lock. This entity will have full control over the lock, in particular will be able to unlock it\r\n     * @param _allowance Amount of tokens that the manager can lock\r\n     * @param _data Data to parametrize logic for the lock to be enforced by the manager\r\n     */\r\n    function allowManagerAndLock(uint256 _amount, address _lockManager, uint256 _allowance, bytes calldata _data) external isInitialized {\r\n        _allowManager(_lockManager, _allowance, _data);\r\n\r\n        _lockUnsafe(msg.sender, _lockManager, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `@tokenAmount(self.token(): address, _amount)` to `_to`’s staked balance\r\n     * @param _to Recipient of the tokens\r\n     * @param _amount Number of tokens to be transferred\r\n     */\r\n    function transfer(address _to, uint256 _amount) external isInitialized {\r\n        _transfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `@tokenAmount(self.token(): address, _amount)` to `_to`’s external balance (i.e. unstaked)\r\n     * @param _to Recipient of the tokens\r\n     * @param _amount Number of tokens to be transferred\r\n     */\r\n    function transferAndUnstake(address _to, uint256 _amount) external isInitialized {\r\n        _transfer(msg.sender, _to, _amount);\r\n        _unstake(_to, _amount, new bytes(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `@tokenAmount(self.token(): address, _amount)` from `_from`'s lock by `msg.sender` to `_to`\r\n     * @param _from Owner of locked tokens\r\n     * @param _to Recipient of the tokens\r\n     * @param _amount Number of tokens to be transferred\r\n     */\r\n    function slash(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        isInitialized\r\n    {\r\n        _unlockUnsafe(_from, msg.sender, _amount);\r\n        _transfer(_from, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `@tokenAmount(self.token(): address, _amount)` from `_from`'s lock by `msg.sender` to `_to` (unstaked)\r\n     * @param _from Owner of locked tokens\r\n     * @param _to Recipient of the tokens\r\n     * @param _amount Number of tokens to be transferred\r\n     */\r\n    function slashAndUnstake(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        isInitialized\r\n    {\r\n        _unlockUnsafe(_from, msg.sender, _amount);\r\n        _transfer(_from, _to, _amount);\r\n        _unstake(_to, _amount, new bytes(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `@tokenAmount(self.token(): address, _slashAmount)` from `_from`'s lock by `msg.sender` to `_to`, and decrease `@tokenAmount(self.token(): address, _unlockAmount)` from that lock\r\n     * @param _from Owner of locked tokens\r\n     * @param _to Recipient of the tokens\r\n     * @param _unlockAmount Number of tokens to be unlocked\r\n     * @param _slashAmount Number of tokens to be transferred\r\n     */\r\n    function slashAndUnlock(\r\n        address _from,\r\n        address _to,\r\n        uint256 _unlockAmount,\r\n        uint256 _slashAmount\r\n    )\r\n        external\r\n        isInitialized\r\n    {\r\n        // No need to check that _slashAmount is positive, as _transfer will fail\r\n        // No need to check that have enough locked funds, as _unlockUnsafe will fail\r\n        require(_unlockAmount > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        _unlockUnsafe(_from, msg.sender, _unlockAmount.add(_slashAmount));\r\n        _transfer(_from, _to, _slashAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Increase allowance by `@tokenAmount(self.token(): address, _allowance)` of lock manager `_lockManager` for user `msg.sender`\r\n     * @param _lockManager The manager entity for this particular lock\r\n     * @param _allowance Amount of allowed tokens increase\r\n     */\r\n    function increaseLockAllowance(address _lockManager, uint256 _allowance) external isInitialized {\r\n        Lock storage lock_ = accounts[msg.sender].locks[_lockManager];\r\n        require(lock_.allowance > 0, ERROR_LOCK_DOES_NOT_EXIST);\r\n\r\n        _increaseLockAllowance(_lockManager, lock_, _allowance);\r\n    }\r\n\r\n    /**\r\n     * @notice Decrease allowance by `@tokenAmount(self.token(): address, _allowance)` of lock manager `_lockManager` for user `_user`\r\n     * @param _user Owner of locked tokens\r\n     * @param _lockManager The manager entity for this particular lock\r\n     * @param _allowance Amount of allowed tokens decrease\r\n     */\r\n    function decreaseLockAllowance(address _user, address _lockManager, uint256 _allowance) external isInitialized {\r\n        // only owner and manager can decrease allowance\r\n        require(msg.sender == _user || msg.sender == _lockManager, ERROR_CANNOT_CHANGE_ALLOWANCE);\r\n        require(_allowance > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        Lock storage lock_ = accounts[_user].locks[_lockManager];\r\n        uint256 newAllowance = lock_.allowance.sub(_allowance);\r\n        require(newAllowance >= lock_.amount, ERROR_NOT_ENOUGH_ALLOWANCE);\r\n        // unlockAndRemoveManager must be used for this:\r\n        require(newAllowance > 0, ERROR_ALLOWANCE_ZERO);\r\n\r\n        lock_.allowance = newAllowance;\r\n\r\n        emit LockAllowanceChanged(_user, _lockManager, _allowance, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Increase locked amount by `@tokenAmount(self.token(): address, _amount)` for user `_user` by lock manager `_lockManager`\r\n     * @param _user Owner of locked tokens\r\n     * @param _lockManager The manager entity for this particular lock\r\n     * @param _amount Amount of locked tokens increase\r\n     */\r\n    function lock(address _user, address _lockManager, uint256 _amount) external isInitialized {\r\n        // we are locking funds from owner account, so only owner or manager are allowed\r\n        require(msg.sender == _user || msg.sender == _lockManager, ERROR_SENDER_NOT_ALLOWED);\r\n\r\n        _lockUnsafe(_user, _lockManager, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Decrease locked amount by `@tokenAmount(self.token(): address, _amount)` for user `_user` by lock manager `_lockManager`\r\n     * @param _user Owner of locked tokens\r\n     * @param _lockManager The manager entity for this particular lock\r\n     * @param _amount Amount of locked tokens decrease\r\n     */\r\n    function unlock(address _user, address _lockManager, uint256 _amount) external isInitialized {\r\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        // only manager and owner (if manager allows) can unlock\r\n        require(_canUnlockUnsafe(msg.sender, _user, _lockManager, _amount), ERROR_CANNOT_UNLOCK);\r\n\r\n        _unlockUnsafe(_user, _lockManager, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Unlock `_user`'s lock by `_lockManager` so locked tokens can be unstaked again\r\n     * @param _user Owner of locked tokens\r\n     * @param _lockManager Manager of the lock for the given account\r\n     */\r\n    function unlockAndRemoveManager(address _user, address _lockManager) external isInitialized {\r\n        // only manager and owner (if manager allows) can unlock\r\n        require(_canUnlockUnsafe(msg.sender, _user, _lockManager, 0), ERROR_CANNOT_UNLOCK);\r\n\r\n        Account storage account = accounts[_user];\r\n        Lock storage lock_ = account.locks[_lockManager];\r\n\r\n        uint256 amount = lock_.amount;\r\n        // update total\r\n        account.totalLocked = account.totalLocked.sub(amount);\r\n\r\n        emit LockAmountChanged(_user, _lockManager, amount, false);\r\n        emit LockManagerRemoved(_user, _lockManager);\r\n\r\n        delete account.locks[_lockManager];\r\n    }\r\n\r\n    /**\r\n     * @notice Change the manager of `_user`'s lock from `msg.sender` to `_newLockManager`\r\n     * @param _user Owner of lock\r\n     * @param _newLockManager New lock manager\r\n     */\r\n    function setLockManager(address _user, address _newLockManager) external isInitialized {\r\n        Lock storage lock_ = accounts[_user].locks[msg.sender];\r\n        require(lock_.allowance > 0, ERROR_LOCK_DOES_NOT_EXIST);\r\n\r\n        accounts[_user].locks[_newLockManager] = lock_;\r\n\r\n        delete accounts[_user].locks[msg.sender];\r\n\r\n        emit LockManagerTransferred(_user, msg.sender, _newLockManager);\r\n    }\r\n\r\n    /**\r\n     * @dev MiniMeToken ApproveAndCallFallBack compliance\r\n     * @param _from Account approving tokens\r\n     * @param _amount Amount of `_token` tokens being approved\r\n     * @param _token MiniMeToken that is being approved and that the call comes from\r\n     * @param _data Used in Staked event, to add signalling information in more complex staking applications\r\n     */\r\n    function receiveApproval(address _from, uint256 _amount, address _token, bytes calldata _data) external isInitialized {\r\n        require(_token == msg.sender, ERROR_TOKEN_NOT_SENDER);\r\n        require(_token == address(stakingToken), ERROR_WRONG_TOKEN);\r\n\r\n        _stakeFor(_from, _from, _amount, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether it supports history of stakes\r\n     * @return Always true\r\n     */\r\n    function supportsHistory() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the token used by the contract for staking and locking\r\n     * @return The token used by the contract for staking and locking\r\n     */\r\n    function token() external view isInitialized returns (address) {\r\n        return address(stakingToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Get last time `_user` modified its staked balance\r\n     * @param _user Account requesting for\r\n     * @return Last block number when account's balance was modified\r\n     */\r\n    function lastStakedFor(address _user) external view isInitialized returns (uint256) {\r\n        return accounts[_user].stakedHistory.lastUpdate();\r\n    }\r\n\r\n    /**\r\n     * @notice Get total amount of locked tokens for `_user`\r\n     * @param _user Owner of locks\r\n     * @return Total amount of locked tokens for the requested account\r\n     */\r\n    function lockedBalanceOf(address _user) external view isInitialized returns (uint256) {\r\n        return _lockedBalanceOf(_user);\r\n    }\r\n\r\n    /**\r\n     * @notice Get details of `_user`'s lock by `_lockManager`\r\n     * @param _user Owner of lock\r\n     * @param _lockManager Manager of the lock for the given account\r\n     * @return Amount of locked tokens\r\n     * @return Amount of tokens that lock manager is allowed to lock\r\n     */\r\n    function getLock(address _user, address _lockManager)\r\n        external\r\n        view\r\n        isInitialized\r\n        returns (\r\n            uint256 _amount,\r\n            uint256 _allowance\r\n        )\r\n    {\r\n        Lock storage lock_ = accounts[_user].locks[_lockManager];\r\n        _amount = lock_.amount;\r\n        _allowance = lock_.allowance;\r\n    }\r\n\r\n    /**\r\n     * @notice Get staked and locked balances of `_user`\r\n     * @param _user Account being requested\r\n     * @return Amount of staked tokens\r\n     * @return Amount of total locked tokens\r\n     */\r\n    function getBalancesOf(address _user) external view isInitialized returns (uint256 staked, uint256 locked) {\r\n        staked = _totalStakedFor(_user);\r\n        locked = _lockedBalanceOf(_user);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the amount of tokens staked by `_user`\r\n     * @param _user The owner of the tokens\r\n     * @return The amount of tokens staked by the given account\r\n     */\r\n    function totalStakedFor(address _user) external view isInitialized returns (uint256) {\r\n        return _totalStakedFor(_user);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total amount of tokens staked by all users\r\n     * @return The total amount of tokens staked by all users\r\n     */\r\n    function totalStaked() external view isInitialized returns (uint256) {\r\n        return _totalStaked();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total amount of tokens staked by `_user` at block number `_blockNumber`\r\n     * @param _user Account requesting for\r\n     * @param _blockNumber Block number at which we are requesting\r\n     * @return The amount of tokens staked by the account at the given block number\r\n     */\r\n    function totalStakedForAt(address _user, uint256 _blockNumber) external view isInitialized returns (uint256) {\r\n        require(_blockNumber <= MAX_UINT64, ERROR_BLOCKNUMBER_TOO_BIG);\r\n\r\n        return accounts[_user].stakedHistory.get(uint64(_blockNumber));\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total amount of tokens staked by all users at block number `_blockNumber`\r\n     * @param _blockNumber Block number at which we are requesting\r\n     * @return The amount of tokens staked at the given block number\r\n     */\r\n    function totalStakedAt(uint256 _blockNumber) external view isInitialized returns (uint256) {\r\n        require(_blockNumber <= MAX_UINT64, ERROR_BLOCKNUMBER_TOO_BIG);\r\n\r\n        return totalStakedHistory.get(uint64(_blockNumber));\r\n    }\r\n\r\n    /**\r\n     * @notice Get the staked but unlocked amount of tokens by `_user`\r\n     * @param _user Owner of the staked but unlocked balance\r\n     * @return Amount of tokens staked but not locked by given account\r\n     */\r\n    function unlockedBalanceOf(address _user) external view isInitialized returns (uint256) {\r\n        return _unlockedBalanceOf(_user);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if `_sender` can unlock `_user`'s `@tokenAmount(self.token(): address, _amount)` locked by `_lockManager`\r\n     * @param _sender Account that would try to unlock tokens\r\n     * @param _user Owner of lock\r\n     * @param _lockManager Manager of the lock for the given owner\r\n     * @param _amount Amount of tokens to be potentially unlocked. If zero, it means the whole locked amount\r\n     * @return Whether given lock of given owner can be unlocked by given sender\r\n     */\r\n    function canUnlock(address _sender, address _user, address _lockManager, uint256 _amount) external view isInitialized returns (bool) {\r\n        return _canUnlockUnsafe(_sender, _user, _lockManager, _amount);\r\n    }\r\n\r\n    function _stakeFor(address _from, address _user, uint256 _amount, bytes memory _data) internal {\r\n        // staking 0 tokens is invalid\r\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        // checkpoint updated staking balance\r\n        uint256 newStake = _modifyStakeBalance(_user, _amount, true);\r\n\r\n        // checkpoint total supply\r\n        _modifyTotalStaked(_amount, true);\r\n\r\n        // pull tokens into Staking contract\r\n        require(stakingToken.safeTransferFrom(_from, address(this), _amount), ERROR_TOKEN_DEPOSIT);\r\n\r\n        emit Staked(_user, _amount, newStake, _data);\r\n    }\r\n\r\n    function _unstake(address _from, uint256 _amount, bytes memory _data) internal {\r\n        // checkpoint updated staking balance\r\n        uint256 newStake = _modifyStakeBalance(_from, _amount, false);\r\n\r\n        // checkpoint total supply\r\n        _modifyTotalStaked(_amount, false);\r\n\r\n        // transfer tokens\r\n        require(stakingToken.safeTransfer(_from, _amount), ERROR_TOKEN_TRANSFER);\r\n\r\n        emit Unstaked(_from, _amount, newStake, _data);\r\n    }\r\n\r\n    function _modifyStakeBalance(address _user, uint256 _by, bool _increase) internal returns (uint256) {\r\n        uint256 currentStake = _totalStakedFor(_user);\r\n\r\n        uint256 newStake;\r\n        if (_increase) {\r\n            newStake = currentStake.add(_by);\r\n        } else {\r\n            require(_by <= _unlockedBalanceOf(_user), ERROR_NOT_ENOUGH_BALANCE);\r\n            newStake = currentStake.sub(_by);\r\n        }\r\n\r\n        // add new value to account history\r\n        accounts[_user].stakedHistory.add(getBlockNumber64(), newStake);\r\n\r\n        return newStake;\r\n    }\r\n\r\n    function _modifyTotalStaked(uint256 _by, bool _increase) internal {\r\n        uint256 currentStake = _totalStaked();\r\n\r\n        uint256 newStake;\r\n        if (_increase) {\r\n            newStake = currentStake.add(_by);\r\n        } else {\r\n            newStake = currentStake.sub(_by);\r\n        }\r\n\r\n        // add new value to total history\r\n        totalStakedHistory.add(getBlockNumber64(), newStake);\r\n    }\r\n\r\n    function _allowManager(address _lockManager, uint256 _allowance, bytes memory _data) internal {\r\n        Lock storage lock_ = accounts[msg.sender].locks[_lockManager];\r\n        // check if lock exists\r\n        require(lock_.allowance == 0, ERROR_LOCK_ALREADY_EXISTS);\r\n\r\n        emit NewLockManager(msg.sender, _lockManager, _data);\r\n\r\n        _increaseLockAllowance(_lockManager, lock_, _allowance);\r\n    }\r\n\r\n    function _increaseLockAllowance(address _lockManager, Lock storage _lock, uint256 _allowance) internal {\r\n        require(_allowance > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        _lock.allowance = _lock.allowance.add(_allowance);\r\n\r\n        emit LockAllowanceChanged(msg.sender, _lockManager, _allowance, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Assumes that sender is either owner or lock manager\r\n     */\r\n    function _lockUnsafe(address _user, address _lockManager, uint256 _amount) internal {\r\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        // check enough unlocked tokens are available\r\n        require(_amount <= _unlockedBalanceOf(_user), ERROR_NOT_ENOUGH_BALANCE);\r\n\r\n        Account storage account = accounts[_user];\r\n        Lock storage lock_ = account.locks[_lockManager];\r\n\r\n        uint256 newAmount = lock_.amount.add(_amount);\r\n        // check allowance is enough, it also means that lock exists, as newAmount is greater than zero\r\n        require(newAmount <= lock_.allowance, ERROR_NOT_ENOUGH_ALLOWANCE);\r\n\r\n        lock_.amount = newAmount;\r\n\r\n        // update total\r\n        account.totalLocked = account.totalLocked.add(_amount);\r\n\r\n        emit LockAmountChanged(_user, _lockManager, _amount, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Assumes `canUnlock` passes\r\n     */\r\n    function _unlockUnsafe(address _user, address _lockManager, uint256 _amount) internal {\r\n        Account storage account = accounts[_user];\r\n        Lock storage lock_ = account.locks[_lockManager];\r\n\r\n        uint256 lockAmount = lock_.amount;\r\n        require(lockAmount >= _amount, ERROR_NOT_ENOUGH_LOCK);\r\n\r\n        // update lock amount\r\n        // No need for SafeMath: checked just above\r\n        lock_.amount = lockAmount - _amount;\r\n\r\n        // update total\r\n        account.totalLocked = account.totalLocked.sub(_amount);\r\n\r\n        emit LockAmountChanged(_user, _lockManager, _amount, false);\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _amount) internal {\r\n        // transferring 0 staked tokens is invalid\r\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        // update stakes\r\n        _modifyStakeBalance(_from, _amount, false);\r\n        _modifyStakeBalance(_to, _amount, true);\r\n\r\n        emit StakeTransferred(_from, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the amount of tokens staked by `_user`\r\n     * @param _user The owner of the tokens\r\n     * @return The amount of tokens staked by the given account\r\n     */\r\n    function _totalStakedFor(address _user) internal view returns (uint256) {\r\n        // we assume it's not possible to stake in the future\r\n        return accounts[_user].stakedHistory.getLast();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total amount of tokens staked by all users\r\n     * @return The total amount of tokens staked by all users\r\n     */\r\n    function _totalStaked() internal view returns (uint256) {\r\n        // we assume it's not possible to stake in the future\r\n        return totalStakedHistory.getLast();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the staked but unlocked amount of tokens by `_user`\r\n     * @param _user Owner of the staked but unlocked balance\r\n     * @return Amount of tokens staked but not locked by given account\r\n     */\r\n    function _unlockedBalanceOf(address _user) internal view returns (uint256) {\r\n        return _totalStakedFor(_user).sub(_lockedBalanceOf(_user));\r\n    }\r\n\r\n    function _lockedBalanceOf(address _user) internal view returns (uint256) {\r\n        return accounts[_user].totalLocked;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if `_sender` can unlock `_user`'s `@tokenAmount(self.token(): address, _amount)` locked by `_lockManager`\r\n     * @dev If calling this from a state modifying function trying to unlock tokens, make sure first parameter is `msg.sender`\r\n     * @param _sender Account that would try to unlock tokens\r\n     * @param _user Owner of lock\r\n     * @param _lockManager Manager of the lock for the given owner\r\n     * @param _amount Amount of locked tokens to unlock. If zero, the full locked amount\r\n     * @return Whether given lock of given owner can be unlocked by given sender\r\n     */\r\n    function _canUnlockUnsafe(address _sender, address _user, address _lockManager, uint256 _amount) internal view returns (bool) {\r\n        Lock storage lock_ = accounts[_user].locks[_lockManager];\r\n        require(lock_.allowance > 0, ERROR_LOCK_DOES_NOT_EXIST);\r\n        require(lock_.amount >= _amount, ERROR_NOT_ENOUGH_LOCK);\r\n\r\n        uint256 amount = _amount == 0 ? lock_.amount : _amount;\r\n\r\n        // If the sender is the lock manager, unlocking is allowed\r\n        if (_sender == _lockManager) {\r\n            return true;\r\n        }\r\n\r\n        // If the sender is neither the lock manager nor the owner, unlocking is not allowed\r\n        if (_sender != _user) {\r\n            return false;\r\n        }\r\n\r\n        // The sender must therefore be the owner of the tokens\r\n        // Allow unlocking if the amount of locked tokens has already been decreased to 0\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n\r\n        // Otherwise, check whether the lock manager allows unlocking\r\n        return ILockManager(_lockManager).canUnlock(_user, amount);\r\n    }\r\n\r\n    function _toBytes4(bytes memory _data) internal pure returns (bytes4 result) {\r\n        if (_data.length < 4) {\r\n            return bytes4(0);\r\n        }\r\n\r\n        assembly { result := mload(add(_data, 0x20)) }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/os/ERCProxy.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/misc/ERCProxy.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ncontract ERCProxy {\r\n    uint256 internal constant FORWARDING = 1;\r\n    uint256 internal constant UPGRADEABLE = 2;\r\n\r\n    function proxyType() public pure returns (uint256 proxyTypeId);\r\n    function implementation() public view returns (address codeAddr);\r\n}\r\n\r\n// File: contracts/lib/os/DelegateProxy.sol\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Autopetrified.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\ncontract DelegateProxy is ERCProxy, IsContract {\r\n    uint256 internal constant FWD_GAS_LIMIT = 10000;\r\n\r\n    /**\r\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\r\n    * @param _dst Destination address to perform the delegatecall\r\n    * @param _calldata Calldata for the delegatecall\r\n    */\r\n    function delegatedFwd(address _dst, bytes memory _calldata) internal {\r\n        require(isContract(_dst));\r\n        uint256 fwdGasLimit = FWD_GAS_LIMIT;\r\n\r\n        assembly {\r\n            let result := delegatecall(sub(gas, fwdGasLimit), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/proxies/ThinProxy.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\ncontract ThinProxy is DelegateProxy {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    constructor(address _implementation) public {\r\n        _implementationSlot().setStorageAddress(_implementation);\r\n    }\r\n\r\n    function () external {\r\n        delegatedFwd(implementation(), msg.data);\r\n    }\r\n\r\n    function proxyType() public pure returns (uint256) {\r\n        return FORWARDING;\r\n    }\r\n\r\n    function implementation() public view returns (address) {\r\n        return _implementationSlot().getStorageAddress();\r\n    }\r\n\r\n    function _implementationSlot() internal pure returns (bytes32);\r\n}\r\n\r\n// File: contracts/proxies/StakingProxy.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\n\r\ncontract StakingProxy is ThinProxy {\r\n    // keccak256(\"aragon.network.staking\")\r\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0xbd536e2e005accda865e2f0d1827f83ec8824f3ea04ecd6131b7c10058635814;\r\n\r\n    constructor(Staking _implementation, ERC20 _token) ThinProxy(address(_implementation)) public {\r\n        bytes4 selector = _implementation.initialize.selector;\r\n        bytes memory initializeData = abi.encodeWithSelector(selector, _token);\r\n        (bool success,) = address(_implementation).delegatecall(initializeData);\r\n\r\n        if (!success) {\r\n            assembly {\r\n                let output := mload(0x40)\r\n                mstore(0x40, add(output, returndatasize))\r\n                returndatacopy(output, 0, returndatasize)\r\n                revert(output, returndatasize)\r\n            }\r\n        }\r\n    }\r\n\r\n    function _implementationSlot() internal pure returns (bytes32) {\r\n        return IMPLEMENTATION_SLOT;\r\n    }\r\n}\r\n\r\n// File: contracts/StakingFactory.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\n\r\ncontract StakingFactory {\r\n    Staking public baseImplementation;\r\n    mapping (address => address) internal instances;\r\n\r\n    event NewStaking(address indexed instance, address token);\r\n\r\n    constructor() public {\r\n        baseImplementation = new Staking();\r\n    }\r\n\r\n    function existsInstance(ERC20 token) external view returns (bool) {\r\n        return _getInstance(token) != address(0);\r\n    }\r\n\r\n    function getInstance(ERC20 token) external view returns (Staking) {\r\n        return Staking(_getInstance(token));\r\n    }\r\n\r\n    function getOrCreateInstance(ERC20 token) external returns (Staking) {\r\n        address instance = _getInstance(token);\r\n        return instance != address(0) ? Staking(instance) : _createInstance(token);\r\n    }\r\n\r\n    function _getInstance(ERC20 token) internal view returns (address) {\r\n        return instances[address(token)];\r\n    }\r\n\r\n    function _createInstance(ERC20 token) internal returns (Staking) {\r\n        StakingProxy instance = new StakingProxy(baseImplementation, token);\r\n        address tokenAddress = address(token);\r\n        address instanceAddress = address(instance);\r\n        instances[tokenAddress] = instanceAddress;\r\n        emit NewStaking(instanceAddress, tokenAddress);\r\n        return Staking(instanceAddress);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"NewStaking\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseImplementation\",\"outputs\":[{\"internalType\":\"contract Staking\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"existsInstance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getInstance\",\"outputs\":[{\"internalType\":\"contract Staking\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getOrCreateInstance\",\"outputs\":[{\"internalType\":\"contract Staking\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakingFactory","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4d77d94485f75064c4aa35c086326df3d846593d3ffaffbea1577dfd3b013069"}]}