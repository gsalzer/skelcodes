{"status":"1","message":"OK","result":[{"SourceCode":"/***\n *    ██████╗ ███████╗ ██████╗  ██████╗ \n *    ██╔══██╗██╔════╝██╔════╝ ██╔═══██╗\n *    ██║  ██║█████╗  ██║  ███╗██║   ██║\n *    ██║  ██║██╔══╝  ██║   ██║██║   ██║\n *    ██████╔╝███████╗╚██████╔╝╚██████╔╝\n *    ╚═════╝ ╚══════╝ ╚═════╝  ╚═════╝ \n *    \n * https://dego.finance\n                                  \n* MIT License\n* ===========\n*\n* Copyright (c) 2020 dego\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/interface/IPowerStrategy.sol\n\npragma solidity ^0.5.0;\n\n\ninterface IPowerStrategy {\n    function lpIn(address sender, uint256 amount) external;\n    function lpOut(address sender, uint256 amount) external;\n    \n    function getPower(address sender) view  external returns (uint256);\n}\n\n// File: contracts/library/Governance.sol\n\npragma solidity ^0.5.0;\n\ncontract Governance {\n\n    address public _governance;\n\n    constructor() public {\n        _governance = tx.origin;\n    }\n\n    event GovernanceTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyGovernance {\n        require(msg.sender == _governance, \"not governance\");\n        _;\n    }\n\n    function setGovernance(address governance)  public  onlyGovernance\n    {\n        require(governance != address(0), \"new governance the zero address\");\n        emit GovernanceTransferred(_governance, governance);\n        _governance = governance;\n    }\n\n\n}\n\n// File: contracts/library/SegmentPowerStrategy.sol\n\npragma solidity ^0.5.0;\n\n\n\n\ncontract SegmentPowerStrategy is IPowerStrategy, Governance {\n    using SafeMath for uint256;\n    ////\n    struct degoSegment {\n        uint256 min;\n        uint256 max;\n    }\n    struct countSegment {\n        uint32 length;\n        uint32 curCount;\n    }\n    struct playerInfo {\n        uint256 amount;\n        uint8 segIndex;\n        uint32 playerId;\n        uint32 offset;\n    }\n\n    mapping(address => uint32) public _addressXId;\n    mapping(uint8 => degoSegment) public _degoSegment;\n    mapping(uint8 => countSegment) public _countSegment;\n    mapping(uint8 => mapping(uint32 => uint32)) public _playerIds;\n    mapping(uint32 => playerInfo) public _playerMap;\n\n    uint8[3] public _ruler = [8, 1, 1];\n    uint8[3] public _factor = [3, 5, 1];\n\n    uint8 public _high = 3;\n    uint8 public _mid = 2;\n    uint8 public _low = 1;\n\n    uint32 public _playerId = 0;\n    uint32 public _base = 100;\n    uint32 public _anchor = _base;\n    uint32 public _grouthCondition = 100;\n    uint32 public _grouthStep = 10;\n    uint32 constant public _highMax = 50;\n    uint32 constant public _midMax = 50;\n\n    uint256 constant public  _initMaxValue = 500 * (10**18);  //500lp,10w usdt,100 eth\n\n    address public _contractCaller = address(0x0);\n\n    /**\n     * check pool\n     */\n    modifier isNormalPool(){\n        require( msg.sender==_contractCaller,\"invalid pool address!\");\n        _;\n    }\n\n    constructor()\n        public\n    {\n        _playerId = 0;\n\n        initSegment();\n        updateRuler(_initMaxValue);\n    }\n\n    function lpIn(address sender, uint256 amount) \n    isNormalPool()\n    external {\n\n        uint32 playerId = _addressXId[sender];\n        if ( playerId > 0 ) {\n            _playerMap[playerId].amount = _playerMap[playerId].amount.add(amount);\n        } else {\n            //new addr\n            _playerId = _playerId+1;\n            _addressXId[sender] = _playerId;\n\n            playerId = _playerId;\n            _playerMap[playerId].playerId = playerId;\n            _playerMap[playerId].amount = amount;\n            _playerMap[playerId].segIndex = 0;\n            _playerMap[playerId].offset =  0;\n\n            //update segment\n            updateSegment();\n        }\n\n        settlePowerData(playerId);\n    }\n\n    function lpOut(address sender, uint256 amount) \n    isNormalPool()\n    external{\n        uint32 playerId = _addressXId[sender];\n        if ( playerId > 0 ) {\n            _playerMap[playerId].amount = _playerMap[playerId].amount.sub(amount);\n        } else {\n            return;\n        }\n\n        settlePowerData(playerId);\n    }\n    \n    function getPower(address sender) \n    view external\n    returns (uint256) {\n\n        uint32 playerId = _addressXId[sender];\n        if ( playerId > 0 ) {\n            uint8 segment = _playerMap[playerId].segIndex;\n            if(segment>0){\n                return uint256(_factor[segment-1]).mul(_playerMap[playerId].amount);\n            }\n        }\n\n        return 0;\n    }\n\n\n    function setCaller( address caller ) public  onlyGovernance{\n        _contractCaller = caller;\n    }\n\n    function updateRuler( uint256 maxCount ) internal{\n\n        uint256 lastBegin = 0;\n        uint256 lastEnd = 0;\n        uint256 splitPoint = 0;\n        for (uint8 i = 1; i <= _ruler.length; i++) {\n            splitPoint = maxCount * _ruler[i - 1]/10;\n            if (splitPoint <= 0) {\n                splitPoint = 1;\n            }\n            lastEnd = lastBegin + splitPoint;\n            if (i == _ruler.length) {\n                lastEnd = maxCount;\n            }\n            _degoSegment[i].min = lastBegin + 1;\n            _degoSegment[i].max = lastEnd;\n            lastBegin = lastEnd;\n        }\n    }\n\n    function initSegment() internal {    \n\n        _countSegment[_low].length = 80;\n        _countSegment[_mid].length = 10;\n        _countSegment[_high].length = 10;\n\n        _countSegment[_low].curCount = 0;\n        _countSegment[_mid].curCount = 0;\n        _countSegment[_high].curCount = 0;\n    }\n\n    function updateSegment( ) internal {\n\n        if (_playerId >= _grouthCondition+_anchor ) {\n            if (_countSegment[_high].length + _grouthStep > _highMax) {\n                _countSegment[_high].length = _highMax;\n            } else {\n                _countSegment[_high].length = _countSegment[_high].length+_grouthStep;\n            }\n\n            if (_countSegment[_mid].length + _grouthStep > _midMax) {\n                _countSegment[_mid].length = _midMax;\n            } else {\n                _countSegment[_mid].length = _countSegment[_mid].length+_grouthStep;\n            }\n            _anchor = _playerId;\n        }\n    }\n\n    function hasCountSegmentSlot(uint8 segIndex) internal view returns (bool){\n        uint32 value = _countSegment[segIndex].length-_countSegment[segIndex].curCount;\n        if (value > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function findSegmentMinPlayer(uint8 segIndex) internal view returns (uint32,uint256){\n        uint256 firstMinAmount = _degoSegment[segIndex].max;\n        uint256 secondMinAmount = _degoSegment[segIndex].max;\n        uint32 minPlayerOffset = 0;\n        for (uint8 i = 0; i < _countSegment[segIndex].curCount; i++) {\n            uint32 playerId = _playerIds[segIndex][i];\n            if( playerId==0 ){\n                continue;\n            }\n            uint256 amount = _playerMap[playerId].amount;\n\n            //find min amount;\n            if ( amount < firstMinAmount) {\n                if (firstMinAmount < secondMinAmount) {\n                    secondMinAmount = firstMinAmount;\n                }\n                firstMinAmount = amount;\n                minPlayerOffset = i;\n            }else{\n                //find second min amount\n                if(amount < secondMinAmount ){\n                    secondMinAmount = amount;\n                }\n            }\n        }\n\n        return (minPlayerOffset,secondMinAmount);\n    }\n\n    //swap the player data from old segment to the new segment\n    function segmentSwap(uint32 playerId, uint8 segIndex) internal {\n\n        uint8 oldSegIndex = _playerMap[playerId].segIndex;\n\n        uint32 oldOffset = _playerMap[playerId].offset;\n        uint32 tail = _countSegment[segIndex].curCount;\n\n        _playerMap[playerId].segIndex = segIndex;\n        _playerMap[playerId].offset = tail;\n\n        _countSegment[segIndex].curCount = _countSegment[segIndex].curCount+1;\n        _playerIds[segIndex][tail] = playerId;\n\n        if (oldSegIndex>0 && segIndex != oldSegIndex && _playerIds[oldSegIndex][oldOffset] > 0) {\n\n            uint32 originTail = _countSegment[oldSegIndex].curCount-1;\n            uint32 originTailPlayer = _playerIds[oldSegIndex][originTail];\n\n            if(originTailPlayer != playerId){\n\n                _playerMap[originTailPlayer].segIndex = oldSegIndex;\n                _playerMap[originTailPlayer].offset = oldOffset;\n                _playerIds[oldSegIndex][oldOffset] = originTailPlayer;\n            }\n\n            _playerIds[oldSegIndex][originTail] = 0;\n            _countSegment[oldSegIndex].curCount = _countSegment[oldSegIndex].curCount-1;\n        }\n    }\n\n    //swap the player data with tail \n    function tailSwap( uint8 segIndex) internal returns (uint32){\n\n        uint32 minPlayerOffset;\n        uint256 secondMinAmount;\n        (minPlayerOffset,secondMinAmount) = findSegmentMinPlayer(segIndex);\n        _degoSegment[segIndex].min = secondMinAmount;\n\n        uint32 leftPlayerId = _playerIds[segIndex][minPlayerOffset];\n\n        //segmentSwap to reset\n        uint32 tail = _countSegment[segIndex].curCount - 1;\n        uint32 tailPlayerId = _playerIds[segIndex][tail];\n        _playerIds[segIndex][minPlayerOffset] = tailPlayerId;\n\n        _playerMap[tailPlayerId].offset = minPlayerOffset;\n\n        return leftPlayerId;\n    }\n\n    function joinHigh(uint32 playerId) internal {\n        uint8 segIndex = _high;\n        if (hasCountSegmentSlot(segIndex)) {\n            segmentSwap(playerId, segIndex);\n        } else {\n            uint32 leftPlayerId = tailSwap(segIndex);\n            joinMid(leftPlayerId);\n            segmentSwap(playerId, segIndex);\n\n        }\n    }\n\n    function joinMid(uint32 playerId) internal {\n        uint8 segIndex = _mid;\n        if (hasCountSegmentSlot(segIndex)) {\n            segmentSwap(playerId, segIndex);\n        } else {\n            uint32 leftPlayerId = tailSwap(segIndex);\n            joinLow(leftPlayerId);\n            segmentSwap(playerId, segIndex);\n        }\n        _degoSegment[segIndex].max = _degoSegment[segIndex + 1].min;\n    }\n\n    function joinLow(uint32 playerId) internal {\n\n        uint8 segIndex = _low;\n        segmentSwap(playerId, segIndex);\n        _degoSegment[segIndex].max = _degoSegment[segIndex + 1].min;\n        //_low segment length update\n        if( _countSegment[segIndex].curCount > _countSegment[segIndex].length){\n            _countSegment[segIndex].length = _countSegment[segIndex].curCount;\n        }\n    }\n\n    function settlePowerData(uint32 playerId) internal {\n\n        uint256 amount = _playerMap[playerId].amount;\n        uint8 segIndex = 0;\n        for (uint8 i = 1; i <= _high; i++) {\n            if (amount < _degoSegment[i].max) {\n                segIndex = i;\n                break;\n            }\n        }\n        if (segIndex == 0) {\n            _degoSegment[_high].max = amount;\n            segIndex = _high;\n        }\n\n        if (_playerMap[playerId].segIndex == segIndex) {\n            return;\n        }\n\n        if (segIndex == _high) {\n            joinHigh(playerId);\n        } else if (segIndex == _mid) {\n            joinMid(playerId);\n        } else {\n            joinLow(playerId);\n        }\n    }\n\n    ////////////////////////////\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"_mid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_addressXId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_governance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"_playerIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"_playerMap\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"segIndex\",\"type\":\"uint8\"},{\"name\":\"playerId\",\"type\":\"uint32\"},{\"name\":\"offset\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_high\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_low\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_highMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"_degoSegment\",\"outputs\":[{\"name\":\"min\",\"type\":\"uint256\"},{\"name\":\"max\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_base\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_ruler\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_initMaxValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_midMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_playerId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"_countSegment\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint32\"},{\"name\":\"curCount\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_contractCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_grouthStep\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_anchor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"setCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_factor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_grouthCondition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lpOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lpIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"GovernanceTransferred\",\"type\":\"event\"}]","ContractName":"SegmentPowerStrategy","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}