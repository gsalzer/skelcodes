{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract PauserRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(_msgSender());\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(_msgSender()), \"PauserRole: caller does not have the Pauser role\");\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(_msgSender());\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract Pausable is Context, PauserRole {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n     * to the deployer.\r\n     */\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to pause, triggers stopped state.\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to unpause, returns to normal state.\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\ncontract RacingAdmins is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event AdminAdded(address indexed account);\r\n    event AdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _admins;\r\n\r\n    constructor () internal {\r\n        _addAdmin(_msgSender());\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(_msgSender()), \"AdminRole: caller does not have the Admin role\");\r\n        _;\r\n    }\r\n\r\n    function isAdmin(address account) public view returns (bool) {\r\n        return _admins.has(account);\r\n    }\r\n\r\n    function addAdmin(address account) public onlyAdmin {\r\n        _addAdmin(account);\r\n    }\r\n\r\n    function renounceAdmin(address account) public onlyAdmin {\r\n        _removeAdmin(account);\r\n    }\r\n\r\n    function _addAdmin(address account) internal {\r\n        _admins.add(account);\r\n        emit AdminAdded(account);\r\n    }\r\n\r\n    function _removeAdmin(address account) internal {\r\n        _admins.remove(account);\r\n        emit AdminRemoved(account);\r\n    }\r\n}\r\n\r\ncontract RacingFeeReceiver is RacingAdmins {\r\n    address payable private _feeWallet;\r\n\r\n    event FeeWalletTransferred(address indexed previousFeeWallet, address indexed newFeeWallet);\r\n\r\n    /**\r\n     * @dev Returns the address of the current fee receiver.\r\n     */\r\n    function feeWallet() public view returns (address payable) {\r\n        return _feeWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the fee receiver wallet.\r\n     */\r\n    modifier onlyFeeWallet() {\r\n        require(isFeeWallet(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current fee receiver wallet.\r\n     */\r\n    function isFeeWallet() public view returns (bool) {\r\n        return _msgSender() == _feeWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without fee receiver wallet.\r\n     *\r\n     * NOTE: Renouncing will leave the contract without an fee receiver wallet.\r\n     * It means that fee will be transferred to the zero address.\r\n     */\r\n    function renounceFeeWallet() public onlyAdmin {\r\n        emit FeeWalletTransferred(_feeWallet, address(0));\r\n        _feeWallet = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers address of the fee receiver to a new address (`newFeeWallet`).\r\n     * Can only be called by admins.\r\n     */\r\n    function transferFeeWalletOwnership(address payable newFeeWallet) public onlyAdmin {\r\n        _transferFeeWalletOwnership(newFeeWallet);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers address of the fee receiver to a new address (`newFeeWallet`).\r\n     */\r\n    function _transferFeeWalletOwnership(address payable newFeeWallet) internal {\r\n        require(newFeeWallet != address(0), \"Ownable: new owner is the zero address\");\r\n        emit FeeWalletTransferred(_feeWallet, newFeeWallet);\r\n        _feeWallet = newFeeWallet;\r\n    }\r\n}\r\n\r\ncontract RacingStorage is RacingFeeReceiver, ReentrancyGuard {\r\n    // --\r\n    // Permanent Storage Variables\r\n    // --\r\n\r\n    mapping(bytes32 => Race) public Races; // The race mapping structure.\r\n    mapping(uint256 => address) public Owner_Horse; // Owner of the Horse ID.\r\n    mapping(uint256 => uint256) public Horse_Active_Races; // Number of races the horse is registered for.\r\n    mapping(bytes32 => bool) public ID_Saved; // Returns whether or not the race ID is present on storage already.\r\n    mapping(uint256 => uint256) public Position_To_Payment; // Returns the percentage of the payment depending on horse's position in a race.\r\n    mapping(address => bool) public Is_Authorized; // Returns whether an address is authorized or not.\r\n    mapping(bytes32 => string) public Cancelled_Races; // Returns a cancelled race and its reason to be cancelled.\r\n    mapping(bytes32 => bool) public Has_Zed_Claimed; // Returns whether or not winnings for a race have been claimed for Zed.\r\n\r\n    address BB; // Blockchain Brain\r\n    address Core; // Core contract.\r\n\r\n    struct Race {\r\n        string Track_Name; // Name of the track or event.\r\n        bytes32 Race_ID; // Key provided for Race ID.\r\n        uint256 Length; // Length of the track (m).\r\n        uint256 Horses_Registered; // Current number of horses registered.\r\n        uint256 Unix_Start; // Timestamp the race starts.\r\n        uint256 Entrance_Fee; // Entrance fee for a particular race (10^18).\r\n        uint256 Prize_Pool; // Total bets in the prize pool (10^18).\r\n        uint256 Horses_Allowed; // Total number of horses allowed for a race.\r\n        uint256[] Horses; // List of Horse IDs on Race.\r\n        State Race_State; // Current state of the race.\r\n        mapping(uint256 => Horse) Lineup; // Mapping of the Horse ID => Horse struct.\r\n        mapping(uint256 => uint256) Gate_To_ID; // Mapping of the Gate # => Horse ID.\r\n        mapping(uint256 => bool) Is_Gate_Taken; // Whether or not a gate number has been taken.\r\n    }\r\n\r\n    struct Horse {\r\n        uint256 Gate; // Gate this horse is currently at.\r\n        uint256 Total_Bet; // Total amount bet on this horse.\r\n        uint256 Final_Position; // Final position of the horse (1 to Horses allowed in race).\r\n        mapping(address => uint256) Bet_Placed; // Amount a specific address bet on this horse.\r\n        mapping(address => bool) Bet_Claimed; // Whether or not that specific address claimed their bet.\r\n    }\r\n\r\n    enum State {Null, Registration, Betting, Final, Fail_Safe}\r\n}\r\n\r\ncontract RacingArena is RacingStorage, Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    // --\r\n    // Events\r\n    // --\r\n\r\n    event BetPlaced(\r\n        bytes32 indexed _raceId,\r\n        address indexed _bettor,\r\n        uint256 _betAmount,\r\n        uint256 indexed _horseID\r\n    );\r\n\r\n    event PrizeClaimed(\r\n        bytes32 indexed _raceId,\r\n        address indexed _bettor,\r\n        uint256 _claimAmount,\r\n        uint256 indexed _horseID\r\n    );\r\n\r\n    event HorseRegistered(\r\n        bytes32 indexed _raceId,\r\n        address indexed _horseOwner,\r\n        uint256 indexed _horseID,\r\n        uint256 _gateNumber\r\n    );\r\n\r\n    event HorseTransferredIn(address indexed _horseOwner, uint256[] _horseIDs);\r\n\r\n    event HorseTransferredOut(address indexed _horseOwner, uint256[] _horseIDs);\r\n\r\n    event RaceCreated(\r\n        bytes32 indexed _raceId,\r\n        string _name,\r\n        uint256 _length,\r\n        uint256 _registrationFee\r\n    );\r\n\r\n    event RaceScheduled(\r\n        bytes32 indexed _raceId,\r\n        uint256 _unixStart,\r\n        string _name\r\n    );\r\n\r\n    event RaceFull(bytes32 indexed _raceId);\r\n\r\n    event ResultsPosted(\r\n        bytes32 indexed _raceId,\r\n        uint256 _firstPlaceHorseID,\r\n        uint256 _secondPlaceHorseID,\r\n        uint256 _thirdPlaceHorseID\r\n    );\r\n\r\n    event RaceCancelled(\r\n        bytes32 indexed _raceId,\r\n        string _reason,\r\n        address _canceller\r\n    );\r\n\r\n    // --\r\n    // Admin Functions\r\n    // --\r\n\r\n    // Admin creates upcoming races, specifying the track name, the track length, and the entrance fee.\r\n    function createRace(\r\n        bytes32 _raceId,\r\n        string memory _name,\r\n        uint256 _horsesAllowed,\r\n        uint256 _entranceFee,\r\n        uint256 _length\r\n    ) public onlyAdmin() nonReentrant() whenNotPaused() {\r\n        // Pre-check and struct inialization.\r\n        require(_entranceFee > 0, \"Entrance fee lower than zero\");\r\n        require(!ID_Saved[_raceId], \"Race ID exists\");\r\n\r\n        Race memory race;\r\n        race.Race_ID = _raceId;\r\n        race.Track_Name = _name;\r\n        race.Horses_Allowed = _horsesAllowed;\r\n        race.Entrance_Fee = _entranceFee;\r\n        race.Length = _length;\r\n        race.Race_State = State.Registration;\r\n\r\n        Races[_raceId] = race;\r\n        ID_Saved[_raceId] = true;\r\n\r\n        // Event trigger.\r\n        emit RaceCreated(_raceId, _name, _length, _entranceFee);\r\n    }\r\n\r\n    // Admin can schedule a race when it's full (12 horses).\r\n    function scheduleRace(bytes32 _raceId, uint256 _startTime)\r\n        public\r\n        onlyAdmin()\r\n        nonReentrant()\r\n    {\r\n        // Prechecks.\r\n        Race storage race = Races[_raceId];\r\n\r\n        require(\r\n            race.Horses_Registered == race.Horses_Allowed,\r\n            \"Not enough horses registered\"\r\n        );\r\n        require(\r\n            race.Race_State == State.Registration,\r\n            \"Race is not in registration state\"\r\n        );\r\n        require(\r\n            _startTime > now + 5 minutes,\r\n            \"Start time doesnt meet criteria\"\r\n        );\r\n\r\n        // State changes.\r\n        race.Unix_Start = _startTime;\r\n        race.Race_State = State.Betting; // State transition from Registration -> Betting.\r\n\r\n        emit RaceScheduled(_raceId, _startTime, race.Track_Name);\r\n    }\r\n\r\n    function initSetup(address _core, address _bb)\r\n        public\r\n        onlyAdmin()\r\n    {\r\n        Position_To_Payment[1] = 60;\r\n        Position_To_Payment[2] = 20;\r\n        Position_To_Payment[3] = 10;\r\n\r\n        BB = _bb;\r\n        Core = _core;\r\n    }\r\n\r\n    function setBbAddress(address _bb)\r\n        public\r\n        onlyAdmin()\r\n    {\r\n        BB = _bb;\r\n    }\r\n\r\n    // Admin posts the result of the race, enabling bettors to claim their winnings.\r\n    /*\r\n    @dev Receives results for a given race, removes 1 active race from the given horses.\r\n    Transitions race state and sends funds to one of the owner addresses as well.\r\n    @param _raceId Race ID we're going to post the results to.\r\n    @param _results List of of horse IDs that participated on the race in position order.\r\n    */\r\n    function postResults(bytes32 _raceId, uint256[12] memory _results)\r\n        public\r\n        onlyAdmin()\r\n        nonReentrant()\r\n    {\r\n        Race storage race = Races[_raceId];\r\n\r\n        // Pre-checks\r\n        require(\r\n            race.Race_State == State.Betting,\r\n            \"Race is not on betting state\"\r\n        );\r\n        require(race.Unix_Start <= now + 1 minutes, \"Mismatch on unix start\");\r\n\r\n        race.Race_State = State.Final; // State transition from Betting -> Final.\r\n\r\n        for (uint256 k = 0; k < race.Horses_Allowed; k++) {\r\n            require(race.Lineup[_results[k]].Gate != 0, \"ID not registered\");\r\n        }\r\n\r\n        // Update the Race struct. Active race reduced.\r\n        for (uint256 j = 0; j < race.Horses_Allowed; j++) {\r\n            race.Lineup[_results[j]].Final_Position = j + 1;\r\n            Horse_Active_Races[_results[j]]--;\r\n        }\r\n\r\n        // Duplication post-check.\r\n        for (uint256 i = 0; i < race.Horses_Allowed; i++) {\r\n            require(\r\n                race.Lineup[_results[i]].Final_Position == i + 1,\r\n                \"ID not submitted properly\"\r\n            );\r\n        }\r\n\r\n        // Sends funds to one of Zed's accounts.\r\n        feeWallet().transfer(race.Prize_Pool.mul(10).div(100));\r\n\r\n        emit ResultsPosted(_raceId, _results[0], _results[1], _results[2]);\r\n    }\r\n\r\n    function cancelRace(bytes32 _raceId, string memory _reason)\r\n        public\r\n        onlyAdmin()\r\n        nonReentrant()\r\n    {\r\n        Race storage race = Races[_raceId];\r\n\r\n        // Pre-checks.\r\n        require(\r\n            race.Race_State == State.Registration ||\r\n                race.Race_State == State.Betting,\r\n            \"Race not on regs or betting state\"\r\n        );\r\n\r\n        race.Race_State = State.Fail_Safe;\r\n\r\n        Cancelled_Races[_raceId] = _reason;\r\n\r\n        // Loops through the IDs on a race by index and removes them out of an active race.\r\n        for (uint256 i = 0; i < race.Horses_Registered; i++) {\r\n            Horse_Active_Races[race.Horses[i]]--;\r\n        }\r\n\r\n        emit RaceCancelled(_raceId, _reason, msg.sender);\r\n    }\r\n\r\n    // --\r\n    // Public Functions\r\n    // --\r\n\r\n    // Bulk transfers horses into race contract.\r\n    // Limit of 15.\r\n    function bulkTransferIn(uint256[] memory _horseIDs) public nonReentrant() {\r\n        require(_horseIDs.length < 16, \"Only 15 horses allowed per transfer\");\r\n\r\n        for (uint8 i = 0; i < _horseIDs.length; i++) {\r\n            Owner_Horse[_horseIDs[i]] = msg.sender;\r\n            ERC721(Core).safeTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                _horseIDs[i]\r\n            );\r\n        }\r\n\r\n        emit HorseTransferredIn(msg.sender, _horseIDs);\r\n    }\r\n\r\n    // Bulk transfers horses out of race contract.\r\n    // Limit of 15.\r\n    function bulkTransferOut(uint256[] memory _horseIDs) public nonReentrant() {\r\n        require(_horseIDs.length < 16, \"Only 15 horses allowed per transfer\");\r\n\r\n        for (uint8 i = 0; i < _horseIDs.length; i++) {\r\n            require(\r\n                Owner_Horse[_horseIDs[i]] == msg.sender,\r\n                \"Caller is not the owner.\"\r\n            );\r\n            require(\r\n                Horse_Active_Races[_horseIDs[i]] == 0,\r\n                \"Horse currently active in a race.\"\r\n            );\r\n\r\n            Owner_Horse[_horseIDs[i]] = address(0);\r\n\r\n            ERC721(Core).safeTransferFrom(\r\n                address(this),\r\n                msg.sender,\r\n                _horseIDs[i]\r\n            );\r\n        }\r\n\r\n        emit HorseTransferredOut(msg.sender, _horseIDs);\r\n    }\r\n\r\n    // Registers a horse for the selected race. Enacts transfer of the entrance fee, and transfer of the ERC-721 horse.\r\n    function registerHorse(\r\n        bytes32 _raceId,\r\n        uint256 _horseID,\r\n        uint256 _gateNumber\r\n    ) public payable nonReentrant() whenNotPaused() {\r\n        Race storage race = Races[_raceId];\r\n\r\n        // Pre-checks.\r\n        require(msg.value >= race.Entrance_Fee, \"Entrance fee not met\");\r\n        require(\r\n            race.Race_State == State.Registration,\r\n            \"Race not accepting registrations\"\r\n        );\r\n        require(\r\n            race.Horses_Registered < race.Horses_Allowed,\r\n            \"Max number of horses for race\"\r\n        );\r\n        require(_gateNumber >= 1, \"Gate number lower than 1.\");\r\n        require(\r\n            _gateNumber <= race.Horses_Allowed,\r\n            \"Gate number greater than max\"\r\n        );\r\n        require(!race.Is_Gate_Taken[_gateNumber], \"Gate number already taken\");\r\n        require(\r\n            Horse_Active_Races[_horseID] < 3,\r\n            \"Horse currently active in 3 races\"\r\n        );\r\n        require(\r\n            race.Lineup[_horseID].Gate == 0,\r\n            \"Horse already registered for this race\"\r\n        );\r\n        require(\r\n            ERC721(Core).ownerOf(_horseID) == address(this),\r\n            \"Racing contract not owner of horse.\"\r\n        );\r\n\r\n        // Insert a new Horse struct with the appropriate information.\r\n        Horse_Active_Races[_horseID]++;\r\n        race.Horses_Registered++;\r\n        race.Lineup[_horseID] = Horse(_gateNumber, 0, 0);\r\n        race.Gate_To_ID[_gateNumber] = _horseID;\r\n\r\n        // Mark gate number as taken.\r\n        race.Is_Gate_Taken[_gateNumber] = true;\r\n\r\n        // Handle accounting of the registration fee as a bet on their horse.\r\n        race.Prize_Pool += race.Entrance_Fee;\r\n        race.Lineup[_horseID].Total_Bet += race.Entrance_Fee;\r\n        race.Lineup[_horseID].Bet_Placed[msg.sender] += race.Entrance_Fee;\r\n        race.Horses.push(_horseID);\r\n\r\n        if (race.Horses_Registered == race.Horses_Allowed) {\r\n            emit RaceFull(_raceId);\r\n        }\r\n\r\n        emit HorseRegistered(_raceId, msg.sender, _horseID, _gateNumber);\r\n        emit BetPlaced(_raceId, msg.sender, race.Entrance_Fee, _horseID);\r\n    }\r\n\r\n    // function placeBet(bytes32 _raceId, uint _horseID, uint _amount) public nonReentrant() {\r\n    //     Race storage race = Races[_raceId];\r\n\r\n    //     // Pre-checks.\r\n    //     require(race.Race_State == State.Betting, \"Bets are not allowed\");\r\n    //     require(race.Unix_Start > now - 5 minutes, \"The betting period has ended.\");\r\n    //     require(race.Lineup[_horseID].Gate != 0, \"Horse not registered for this race.\");\r\n    //     require(_amount % 1 ether == 0, \"Bet should have no remainder\");\r\n\r\n    //     // Transfer bet and update Race struct.\r\n    //     require(ERC20(DAI).transferFrom(msg.sender, address(this), _amount), \"Caller lacks funds, or contract lacks approval for the bet.\");\r\n\r\n    //     race.Prize_Pool += _amount;\r\n    //     race.Lineup[_horseID].Total_Bet += _amount;\r\n    //     race.Lineup[_horseID].Bet_Placed[msg.sender] += _amount;\r\n\r\n    //     emit BetPlaced(_raceId, msg.sender, _amount, _horseID);\r\n    // }\r\n\r\n    /**\r\n     * @dev Method validates, calculates and transfer funds to winner address,\r\n     * regarding to provided _raceId and _horseID results.\r\n     */\r\n    function claimWinningsHelper(bytes32 _raceId, uint256 _horseID)\r\n        external\r\n        nonReentrant()\r\n    {\r\n        _claimRaceWinnings(_raceId, _horseID, _msgSender());\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev The same meaning as `claimWinningsHelper()` method,\r\n     * but its intended for many races and horses of winner with one transaction.\r\n     * It use 'for-loop' method, and to be protected from 'Out of Gas' issue the sender should limit the length of provided arrays.\r\n     */\r\n    function claimAllWinningsHelper(bytes32[] calldata _raceIds, uint256[] calldata _horseIDs)\r\n        external\r\n        nonReentrant()\r\n    {\r\n        require(_raceIds.length > 0, \"claimAllWinningsHelper: raceId array should not be empty.\");\r\n        require(_raceIds.length < 125, \"claimAllWinningsHelper: raceId array length is bigger than provided limit.\");\r\n        require(_raceIds.length == _horseIDs.length, \"claimAllWinningsHelper: lengths of raceids and horseids arrays should be equal.\");\r\n\r\n        for (uint256 i = 0; i < _raceIds.length; i++) {\r\n            _claimRaceWinnings(_raceIds[i], _horseIDs[i], _msgSender());\r\n        }\r\n    }\r\n\r\n\r\n    // --\r\n    // Private Functions\r\n    // --\r\n\r\n    function _claimRaceWinnings(bytes32 _raceId, uint256 _horseID, address payable _winner)\r\n        private\r\n    {\r\n        Race storage race = Races[_raceId];\r\n        address horseOwner = Owner_Horse[_horseID];\r\n\r\n        // Pre-checks.\r\n        // For now only the owner is able to claim the winnings for a horse.\r\n        require(_winner == horseOwner, \"Not horse owner\");\r\n        require(race.Race_State == State.Final, \"Race still running\");\r\n        require(\r\n            !race.Lineup[_horseID].Bet_Claimed[horseOwner],\r\n            \"Winnings have already been claimed\"\r\n        );\r\n\r\n        race.Lineup[_horseID].Bet_Claimed[horseOwner] = true;\r\n\r\n        uint256 horsePosition = race.Lineup[_horseID].Final_Position;\r\n\r\n        // Limit is race's prize pool.\r\n        uint256 toTransfer = race\r\n            .Prize_Pool\r\n            .mul(Position_To_Payment[horsePosition])\r\n            .div(100);\r\n\r\n        _winner.transfer(toTransfer);\r\n\r\n        emit PrizeClaimed(_raceId, horseOwner, toTransfer, _horseID);\r\n    }\r\n\r\n    // function reclaimBetHelper(bytes32 _raceId, uint _horseID, address payable _bettor) public nonReentrant() {\r\n    //     Race storage race = Races[_raceId];\r\n\r\n    //     // Pre-checks.\r\n    //     require(race.Race_State == State.Fail_Safe, \"Contract not in fail safe mode\");\r\n    //     require(!race.Lineup[_horseID].Bet_Claimed[_bettor], \"Bet already reclaimed\");\r\n    //     race.Lineup[_horseID].Bet_Claimed[_bettor] = true;\r\n\r\n    //     // Reclaim bet.\r\n    //     uint bet = race.Lineup[_horseID].Bet_Placed[_bettor];\r\n\r\n    //     _bettor.transfer(bet);\r\n\r\n    //     // ? Add an event.\r\n    // }\r\n\r\n    function onERC721Received(address, address, uint256, bytes calldata)\r\n        external\r\n        pure\r\n        returns (bytes4)\r\n    {\r\n        return\r\n            bytes4(\r\n                keccak256(\"onERC721Received(address,address,uint256,bytes)\")\r\n            );\r\n    }\r\n\r\n    // Small helper function for retreieving the Horse ID based off Gate # (1 - 12, no 0 element).\r\n    function getHorseID(bytes32 _raceId, uint256 _gate)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return Races[_raceId].Gate_To_ID[_gate];\r\n    }\r\n\r\n    // Small helper function for retreieving more detailed information about a horse (for Retrieval purposes) based off Gate # (1 - 12, no 0 element).\r\n    function getHorseInfo(bytes32 _raceId, uint256 _gate)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        Race storage race = Races[_raceId];\r\n\r\n        return (\r\n            race.Gate_To_ID[_gate],\r\n            race.Lineup[race.Gate_To_ID[_gate]].Final_Position\r\n        );\r\n    }\r\n\r\n    // Small helper function for personal bet information based off Gate # (1 - 12, no 0 element).\r\n    function getBetInfo(bytes32 _raceId, uint256 _gate, address _bettor)\r\n        public\r\n        view\r\n        returns (uint256, uint256, uint256, bool, uint256)\r\n    {\r\n        Race storage race = Races[_raceId];\r\n\r\n        return (\r\n            race.Prize_Pool,\r\n            race.Lineup[race.Gate_To_ID[_gate]].Total_Bet,\r\n            race.Lineup[race.Gate_To_ID[_gate]].Bet_Placed[_bettor],\r\n            race.Lineup[race.Gate_To_ID[_gate]].Bet_Claimed[_bettor],\r\n            race.Lineup[race.Gate_To_ID[_gate]].Final_Position\r\n        );\r\n    }\r\n\r\n    function getHorsesInRace(bytes32 _raceId)\r\n        public\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        Race storage race = Races[_raceId];\r\n\r\n        return race.Horses;\r\n    }\r\n\r\n    function getCoreAddress()\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return Core;\r\n    }\r\n\r\n    function getBBAddress()\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return BB;\r\n    }\r\n\r\n    /*  RESTRICTED  */\r\n    function changePaymentAllocation(uint256 _position, uint256 _percentage)\r\n        public\r\n        onlyAdmin()\r\n    {\r\n        Position_To_Payment[_position] = _percentage;\r\n    }\r\n\r\n    function() external payable {}\r\n}\r\n\r\ninterface ERC721 {\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 indexed _tokenId\r\n    );\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n        external\r\n        payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId)\r\n        external\r\n        payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function setApprovalForAll(address _to, bool _approved) external;\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\ncontract Proxy is RacingStorage {\r\n\t/**\r\n\t * @dev Fallback function.\r\n\t * Implemented entirely in `_fallback`.\r\n\t */\r\n\tfunction () payable external {\r\n\t\t_fallback();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev fallback implementation.\r\n\t * Extracted to enable manual triggering.\r\n\t */\r\n\tfunction _fallback() internal {\r\n\t\t_willFallback();\r\n\t\t_delegate(_implementation());\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that is run as the first thing in the fallback function.\r\n\t * Can be redefined in derived contracts to add functionality.\r\n\t * Redefinitions must call super._willFallback().\r\n\t */\r\n\tfunction _willFallback() internal {}\r\n\r\n\t/**\r\n\t * @dev Delegates execution to an implementation contract.\r\n\t * This is a low level function that doesn't return to its internal call site.\r\n\t * It will return to the external caller whatever the implementation returns.\r\n\t * @param implementation Address to delegate.\r\n\t */\r\n\tfunction _delegate(address implementation) internal {\r\n\t\tassembly {\r\n\t\t\t// Copy msg.data. We take full control of memory in this inline assembly\r\n\t\t\t// block because it will not return to Solidity code. We overwrite the\r\n\t\t\t// Solidity scratch pad at memory position 0.\r\n\t\t\tcalldatacopy(0, 0, calldatasize)\r\n\r\n\t\t\t// Call the implementation.\r\n\t\t\t// out and outsize are 0 because we don't know the size yet.\r\n\t\t\tlet result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n\t\t\t// Copy the returned data.\r\n\t\t\treturndatacopy(0, 0, returndatasize)\r\n\r\n\t\t\tswitch result\r\n\t\t\t// delegatecall returns 0 on error.\r\n\t\t\tcase 0 { revert(0, returndatasize) }\r\n\t\t\tdefault { return(0, returndatasize) }\r\n\t\t}\r\n  \t}\r\n\r\n\t/**\r\n\t * @return The Address of the implementation.\r\n\t */\r\n\tfunction _implementation() internal view returns (address);\r\n}\r\n\r\n/**\r\n * @title BaseUpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n\tusing Address for address;\r\n\r\n\t/**\r\n\t * @dev The version of current(active) logic contract\r\n\t */\r\n    string internal _version;\r\n\r\n\t/**\r\n\t * @dev Storage slot with the address of the current implementation.\r\n\t * This is the keccak-256 hash of \"org.zeppelinos.proxy.implementation\", and is\r\n\t * validated in the constructor.\r\n\t */\r\n\tbytes32 internal constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\r\n\r\n\t/**\r\n\t * @dev Emitted when the implementation is upgraded.\r\n\t * @param implementation Address of the new implementation.\r\n\t */\r\n\tevent Upgraded(address indexed implementation);\r\n\r\n\t/**\r\n\t * @dev Returns the current implementation.\r\n\t * @return Address of the current implementation\r\n\t */\r\n\tfunction _implementation() internal view returns (address impl) {\r\n\t\tbytes32 slot = IMPLEMENTATION_SLOT;\r\n\t\tassembly {\r\n\t\t    impl := sload(slot)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Upgrades the proxy to a new implementation.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t * @param newVersion of proxied contract.\r\n\t */\r\n\tfunction _upgradeProxyTo(address newImplementation, string memory newVersion) internal {\r\n\t\t_setProxyImplementation(newImplementation, newVersion);\r\n\r\n\t\temit Upgraded(newImplementation);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets the implementation address of the proxy.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t * @param newVersion of proxied contract.\r\n\t */\r\n\tfunction _setProxyImplementation(address newImplementation, string memory newVersion) internal {\r\n\t\trequire(newImplementation.isContract(), \"Cannot set a proxy implementation to a non-contract address\");\r\n\r\n \t\t_version = newVersion;\r\n\r\n\t\tbytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n\t\tassembly {\r\n\t\t    sstore(slot, newImplementation)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\r\n * implementation and init data.\r\n */\r\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n\t/**\r\n\t * @dev Contract constructor.\r\n\t * @param _logic Address of the initial implementation.\r\n\t */\r\n\tconstructor(address _logic) public payable {\r\n\t\tassert(IMPLEMENTATION_SLOT == keccak256(\"org.zeppelinos.proxy.implementation\"));\r\n\t\t_setProxyImplementation(_logic, \"1.0.0\");\r\n\t}\r\n}\r\n\r\n/**\r\n * @title BaseAdminUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks.\r\n * All external functions in this contract must be guarded by the\r\n * `ifProxyAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n\t/**\r\n\t * @dev Emitted when the administration has been transferred.\r\n\t * @param previousAdmin Address of the previous admin.\r\n\t * @param newProxyAdmin Address of the new admin.\r\n\t */\r\n\tevent ProxyAdminChanged(address previousAdmin, address newProxyAdmin);\r\n\r\n\t/**\r\n\t * @dev Storage slot with the admin of the contract.\r\n\t * This is the keccak-256 hash of \"org.zeppelinos.proxy.admin\", and is\r\n\t * validated in the constructor.\r\n\t */\r\n  \tbytes32 internal constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\r\n\r\n  \t/**\r\n\t * @dev Modifier to check whether the `msg.sender` is the admin.\r\n\t * If it is, it will run the function. Otherwise, it will delegate the call\r\n\t * to the implementation.\r\n\t */\r\n\tmodifier ifProxyAdmin() {\r\n\t\tif (msg.sender == _proxyAdmin()) {\r\n\t\t    _;\r\n\t\t} else {\r\n\t\t    _fallback();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return The address of the proxy admin.\r\n\t */\r\n\tfunction proxyAdmin() external view returns (address) {\r\n\t\treturn _proxyAdmin();\r\n\t}\r\n\r\n\t/**\r\n\t * @return The version of logic contract\r\n\t */\r\n\tfunction proxyVersion() external view returns (string memory) {\r\n\t\treturn _version;\r\n\t}\r\n\r\n\t/**\r\n\t * @return The address of the implementation.\r\n\t */\r\n\tfunction proxyImplementation() external view returns (address) {\r\n\t\treturn _implementation();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Changes the admin of the proxy.\r\n\t * Only the current admin can call this function.\r\n\t * @param newProxyAdmin Address to transfer proxy administration to.\r\n\t */\r\n\tfunction changeProxyAdmin(address newProxyAdmin) external ifProxyAdmin {\r\n\t\trequire(newProxyAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\r\n\t\temit ProxyAdminChanged(_proxyAdmin(), newProxyAdmin);\r\n\t\t_setProxyAdmin(newProxyAdmin);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Upgrade the backing implementation of the proxy.\r\n\t * Only the admin can call this function.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t * @param newVersion of proxied contract.\r\n\t */\r\n\tfunction upgradeProxyTo(address newImplementation, string calldata newVersion) external ifProxyAdmin {\r\n\t\t_upgradeProxyTo(newImplementation, newVersion);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Upgrade the backing implementation of the proxy and call a function\r\n\t * on the new implementation.\r\n\t * This is useful to initialize the proxied contract.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t * @param newVersion of proxied contract.\r\n\t * @param data Data to send as msg.data in the low level call.\r\n\t * It should include the signature and the parameters of the function to be called, as described in\r\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n\t */\r\n\tfunction upgradeProxyToAndCall(address newImplementation, string calldata newVersion, bytes calldata data) payable external ifProxyAdmin {\r\n\t\t_upgradeProxyTo(newImplementation, newVersion);\r\n\t\t(bool success,) = newImplementation.delegatecall(data);\r\n\t\trequire(success);\r\n\t}\r\n\r\n\t/**\r\n\t * @return The admin slot.\r\n\t */\r\n\tfunction _proxyAdmin() internal view returns (address adm) {\r\n\t\tbytes32 slot = ADMIN_SLOT;\r\n\t\tassembly {\r\n    \t\tadm := sload(slot)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets the address of the proxy admin.\r\n\t * @param newProxyAdmin Address of the new proxy admin.\r\n\t */\r\n\tfunction _setProxyAdmin(address newProxyAdmin) internal {\r\n\t\tbytes32 slot = ADMIN_SLOT;\r\n\r\n\t\tassembly {\r\n\t\t\tsstore(slot, newProxyAdmin)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Only fall back when the sender is not the admin.\r\n\t */\r\n\tfunction _willFallback() internal {\r\n\t\trequire(msg.sender != _proxyAdmin(), \"Cannot call fallback function from the proxy admin\");\r\n\t\tsuper._willFallback();\r\n\t}\r\n}\r\n\r\n/**\r\n * @title RacingProxy\r\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\r\n * initializing the implementation, admin, and init data.\r\n */\r\ncontract RacingProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\r\n\t/**\r\n\t * Contract constructor.\r\n\t * @param _logic address of the initial implementation.\r\n\t * @param _admin Address of the proxy administrator.\r\n\t */\r\n\tconstructor(address _logic, address _admin) UpgradeabilityProxy(_logic) public payable {\r\n\t\tassert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\"));\r\n\t\t_setProxyAdmin(_admin);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"name\":\"_gate\",\"type\":\"uint256\"}],\"name\":\"getHorseID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_horseIDs\",\"type\":\"uint256[]\"}],\"name\":\"bulkTransferOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_horsesAllowed\",\"type\":\"uint256\"},{\"name\":\"_entranceFee\",\"type\":\"uint256\"},{\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"createRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_raceId\",\"type\":\"bytes32\"}],\"name\":\"getHorsesInRace\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Cancelled_Races\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCoreAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ID_Saved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bb\",\"type\":\"address\"}],\"name\":\"setBbAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_horseIDs\",\"type\":\"uint256[]\"}],\"name\":\"bulkTransferIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"scheduleRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"name\":\"_results\",\"type\":\"uint256[12]\"}],\"name\":\"postResults\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_position\",\"type\":\"uint256\"},{\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"changePaymentAllocation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceFeeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Is_Authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Races\",\"outputs\":[{\"name\":\"Track_Name\",\"type\":\"string\"},{\"name\":\"Race_ID\",\"type\":\"bytes32\"},{\"name\":\"Length\",\"type\":\"uint256\"},{\"name\":\"Horses_Registered\",\"type\":\"uint256\"},{\"name\":\"Unix_Start\",\"type\":\"uint256\"},{\"name\":\"Entrance_Fee\",\"type\":\"uint256\"},{\"name\":\"Prize_Pool\",\"type\":\"uint256\"},{\"name\":\"Horses_Allowed\",\"type\":\"uint256\"},{\"name\":\"Race_State\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_raceIds\",\"type\":\"bytes32[]\"},{\"name\":\"_horseIDs\",\"type\":\"uint256[]\"}],\"name\":\"claimAllWinningsHelper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"name\":\"_horseID\",\"type\":\"uint256\"},{\"name\":\"_gateNumber\",\"type\":\"uint256\"}],\"name\":\"registerHorse\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFeeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"name\":\"_gate\",\"type\":\"uint256\"}],\"name\":\"getHorseInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Owner_Horse\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBBAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFeeWallet\",\"type\":\"address\"}],\"name\":\"transferFeeWalletOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"cancelRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_core\",\"type\":\"address\"},{\"name\":\"_bb\",\"type\":\"address\"}],\"name\":\"initSetup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"name\":\"_gate\",\"type\":\"uint256\"},{\"name\":\"_bettor\",\"type\":\"address\"}],\"name\":\"getBetInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Horse_Active_Races\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Position_To_Payment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Has_Zed_Claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"name\":\"_horseID\",\"type\":\"uint256\"}],\"name\":\"claimWinningsHelper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_bettor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_betAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_horseID\",\"type\":\"uint256\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_bettor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_claimAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_horseID\",\"type\":\"uint256\"}],\"name\":\"PrizeClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_horseOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_horseID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gateNumber\",\"type\":\"uint256\"}],\"name\":\"HorseRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_horseOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_horseIDs\",\"type\":\"uint256[]\"}],\"name\":\"HorseTransferredIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_horseOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_horseIDs\",\"type\":\"uint256[]\"}],\"name\":\"HorseTransferredOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_length\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_registrationFee\",\"type\":\"uint256\"}],\"name\":\"RaceCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_unixStart\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"RaceScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_raceId\",\"type\":\"bytes32\"}],\"name\":\"RaceFull\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_firstPlaceHorseID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_secondPlaceHorseID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_thirdPlaceHorseID\",\"type\":\"uint256\"}],\"name\":\"ResultsPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_raceId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_reason\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_canceller\",\"type\":\"address\"}],\"name\":\"RaceCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousFeeWallet\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newFeeWallet\",\"type\":\"address\"}],\"name\":\"FeeWalletTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"}]","ContractName":"RacingArena","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6bf9b18135615c64d28842945084edc2ef3d9fe787080f9cbfdbf0f22a688a6d"}]}