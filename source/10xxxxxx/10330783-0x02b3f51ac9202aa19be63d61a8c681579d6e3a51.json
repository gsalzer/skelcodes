{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-05-18\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2020-01-23\r\n*/\r\n\r\n// File: github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a); // dev: overflow\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a); // dev: underflow\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b); // dev: overflow\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0); // dev: divide by zero\r\n        c = a / b;\r\n    }\r\n}\r\n// File: browser/dex-adapter-simple.sol\r\n\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n}\r\n\r\ninterface IGateway {\r\n    function mint(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) external returns (uint256);\r\n    function burn(bytes calldata _to, uint256 _amount) external returns (uint256);\r\n}\r\n\r\ninterface IGatewayRegistry {\r\n    function getGatewayBySymbol(string calldata _tokenSymbol) external view returns (IGateway);\r\n    function getGatewayByToken(address  _tokenAddress) external view returns (IGateway);\r\n    function getTokenBySymbol(string calldata _tokenSymbol) external view returns (IERC20);\r\n}\r\n\r\ninterface ICurveExchange {\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\r\n\r\n    function get_dy(int128, int128 j, uint256 dx) external view returns (uint256);\r\n\r\n    function calc_token_amount(uint256[3] calldata amounts, bool deposit) external returns (uint256 amount);\r\n\r\n    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;\r\n\r\n    function remove_liquidity(\r\n        uint256 _amount,\r\n        uint256[3] calldata min_amounts\r\n    ) external;\r\n\r\n    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external;\r\n\r\n    function remove_liquidity_one_coin(uint256 _token_amounts, int128 i, uint256 min_amount) external;\r\n}\r\n\r\ninterface IFreeFromUpTo {\r\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract CurveExchangeAdapter {\r\n    using SafeMath for uint256;\r\n\r\n    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n\r\n    modifier discountCHI {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 *\r\n                           msg.data.length;\r\n        if(chi.balanceOf(address(this)) > 0) {\r\n            chi.freeFromUpTo(address(this), (gasSpent + 14154) / 41947);\r\n        }\r\n        else {\r\n            chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\r\n        }\r\n    }\r\n\r\n    uint256 constant N_COINS = 3;\r\n    \r\n    //first coin always is renBTC\r\n    IERC20[N_COINS] coins;\r\n    uint256[N_COINS] precisions_normalized = [1,1,1e10];\r\n\r\n    IERC20 curveToken;\r\n\r\n    ICurveExchange public exchange;  \r\n    IGatewayRegistry public registry;\r\n\r\n    event SwapReceived(uint256 mintedAmount, uint256 erc20BTCAmount, int128 j);\r\n    event DepositMintedCurve(uint256 mintedAmount, uint256 curveAmount, uint256[N_COINS] amounts);\r\n    event ReceiveRen(uint256 renAmount);\r\n    event Burn(uint256 burnAmount);\r\n\r\n    constructor(ICurveExchange _exchange, address _curveTokenAddress, IGatewayRegistry _registry, IERC20[N_COINS] memory _coins) public {\r\n        exchange = _exchange;\r\n        registry = _registry;\r\n        curveToken = IERC20(_curveTokenAddress);\r\n        for(uint256 i = 0; i < N_COINS; i++) {\r\n            coins[i] = _coins[i];\r\n            require(coins[i].approve(address(exchange), uint256(-1)));\r\n        }\r\n        require(chi.approve(address(this), uint256(-1)));\r\n    }\r\n\r\n    function recoverStuck(\r\n        bytes calldata encoded,\r\n        uint256 _amount,\r\n        bytes32 _nHash,\r\n        bytes calldata _sig\r\n    ) external {\r\n        uint256 start = encoded.length - 32;\r\n        address sender = abi.decode(encoded[start:], (address));\r\n        require(sender == msg.sender);\r\n        bytes32 pHash = keccak256(encoded);\r\n        uint256 mintedAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\r\n        require(coins[0].transfer(msg.sender, mintedAmount));\r\n    }\r\n    \r\n    function mintThenSwap(\r\n        uint256 _minExchangeRate,\r\n        uint256 _newMinExchangeRate,\r\n        uint256 _slippage,\r\n        int128 _j,\r\n        address payable _coinDestination,\r\n        uint256 _amount,\r\n        bytes32 _nHash,\r\n        bytes calldata _sig\r\n    ) external discountCHI {\r\n        //params is [_minExchangeRate, _slippage, _i, _j]\r\n        //fail early so not to spend much gas?\r\n        //require(_i <= 2 && _j <= 2 && _i != _j);\r\n        // Mint renBTC tokens\r\n        bytes32 pHash = keccak256(abi.encode(_minExchangeRate, _slippage, _j, _coinDestination, msg.sender));\r\n        uint256 mintedAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\r\n        \r\n        // Get price\r\n        // compare if the exchange rate now * slippage in BPS is what user submitted as\r\n        uint256 dy = exchange.get_dy(0, _j, mintedAmount);\r\n        uint256 rate = dy.mul(1e8).div(precisions_normalized[uint256(_j)]).div(mintedAmount);\r\n        _slippage = uint256(1e4).sub(_slippage);\r\n        uint256 min_dy = dy.mul(_slippage).div(1e4);\r\n        \r\n        // Price is OK\r\n        if (rate >= _newMinExchangeRate) {\r\n            require(_j != 0);\r\n            doSwap(_j, mintedAmount, min_dy, _coinDestination);\r\n        } else {\r\n            //Send renBTC to the User instead\r\n            require(coins[0].transfer(_coinDestination, mintedAmount));\r\n            emit ReceiveRen(mintedAmount);\r\n        }\r\n    }\r\n\r\n    function doSwap(int128 _j, uint256 _mintedAmount, uint256 _min_dy, address payable _coinDestination) internal {\r\n        uint256 startBalance = coins[uint256(_j)].balanceOf(address(this));\r\n        exchange.exchange(0, _j, _mintedAmount, _min_dy);\r\n        uint256 endBalance = coins[uint256(_j)].balanceOf(address(this));\r\n        uint256 bought = endBalance.sub(startBalance);\r\n    \r\n        //Send proceeds to the User\r\n        require(coins[uint256(_j)].transfer(_coinDestination, bought));\r\n        emit SwapReceived(_mintedAmount, bought, _j);\r\n    }\r\n\r\n    function mintThenDeposit(\r\n        address payable _wbtcDestination, \r\n        uint256 _amount, \r\n        uint256[N_COINS] calldata _amounts, \r\n        uint256 _min_mint_amount, \r\n        uint256 _new_min_mint_amount, \r\n        bytes32 _nHash, \r\n        bytes calldata _sig\r\n    ) external discountCHI {\r\n        // Mint renBTC tokens\r\n        bytes32 pHash = keccak256(abi.encode(_wbtcDestination, _amounts, _min_mint_amount, msg.sender));\r\n        //use actual _amount the user sent\r\n        uint256 mintedAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\r\n\r\n        //set renBTC to actual minted amount in case the user sent less BTC to Ren\r\n        uint256[N_COINS] memory receivedAmounts = _amounts;\r\n        receivedAmounts[0] = mintedAmount;\r\n        for(uint256 i = 1; i < N_COINS; i++) {\r\n            receivedAmounts[i] = _amounts[i];\r\n        }\r\n        if(exchange.calc_token_amount(_amounts, true) >= _new_min_mint_amount) {\r\n            doDeposit(receivedAmounts, mintedAmount, _new_min_mint_amount, _wbtcDestination);\r\n        }\r\n        else {\r\n            require(coins[0].transfer(_wbtcDestination, mintedAmount));\r\n            emit ReceiveRen(mintedAmount);\r\n        }\r\n    }\r\n\r\n    function doDeposit(uint256[N_COINS] memory receivedAmounts, uint256 mintedAmount, uint256 _new_min_mint_amount, address _wbtcDestination) internal {\r\n        for(uint256 i = 1; i < N_COINS; i++) {\r\n            if(receivedAmounts[i] > 0) {\r\n                require(coins[i].transferFrom(msg.sender, address(this), receivedAmounts[i]));\r\n            }\r\n        }\r\n        uint256 curveBalanceBefore = curveToken.balanceOf(address(this));\r\n        exchange.add_liquidity(receivedAmounts, 0);\r\n        uint256 curveBalanceAfter = curveToken.balanceOf(address(this));\r\n        uint256 curveAmount = curveBalanceAfter.sub(curveBalanceBefore);\r\n        require(curveAmount >= _new_min_mint_amount);\r\n        require(curveToken.transfer(_wbtcDestination, curveAmount));\r\n        emit DepositMintedCurve(mintedAmount, curveAmount, receivedAmounts);\r\n    }\r\n\r\n    function mintNoSwap(\r\n        uint256 _minExchangeRate,\r\n        uint256 _newMinExchangeRate,\r\n        uint256 _slippage,\r\n        int128 _j,\r\n        address payable _wbtcDestination,\r\n        uint256 _amount,\r\n        bytes32 _nHash,\r\n        bytes calldata _sig\r\n    ) external discountCHI {\r\n        bytes32 pHash = keccak256(abi.encode(_minExchangeRate, _slippage, _j, _wbtcDestination, msg.sender));\r\n        uint256 mintedAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\r\n        \r\n        require(coins[0].transfer(_wbtcDestination, mintedAmount));\r\n        emit ReceiveRen(mintedAmount);\r\n    }\r\n\r\n    function mintNoDeposit(\r\n        address payable _wbtcDestination, \r\n        uint256 _amount, \r\n        uint256[N_COINS] calldata _amounts, \r\n        uint256 _min_mint_amount, \r\n        uint256 _new_min_mint_amount, \r\n        bytes32 _nHash, \r\n        bytes calldata _sig\r\n    ) external discountCHI {\r\n         // Mint renBTC tokens\r\n        bytes32 pHash = keccak256(abi.encode(_wbtcDestination, _amounts, _min_mint_amount, msg.sender));\r\n        //use actual _amount the user sent\r\n        uint256 mintedAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\r\n\r\n        require(coins[0].transfer(_wbtcDestination, mintedAmount));\r\n        emit ReceiveRen(mintedAmount);\r\n    }\r\n\r\n    function removeLiquidityThenBurn(bytes calldata _btcDestination, address _coinDestination, uint256 amount, uint256[N_COINS] calldata min_amounts) external discountCHI {\r\n        uint256[N_COINS] memory balances;\r\n        for(uint256 i = 0; i < coins.length; i++) {\r\n            balances[i] = coins[i].balanceOf(address(this));\r\n        }\r\n\r\n        require(curveToken.transferFrom(msg.sender, address(this), amount));\r\n        exchange.remove_liquidity(amount, min_amounts);\r\n\r\n        for(uint256 i = 0; i < coins.length; i++) {\r\n            balances[i] = coins[i].balanceOf(address(this)).sub(balances[i]);\r\n            if(i == 0) continue;\r\n            require(coins[i].transfer(_coinDestination, balances[i]));\r\n        }\r\n\r\n        // Burn and send proceeds to the User\r\n        uint256 burnAmount = registry.getGatewayBySymbol(\"BTC\").burn(_btcDestination, balances[0]);\r\n        emit Burn(burnAmount);\r\n    }\r\n\r\n    function removeLiquidityImbalanceThenBurn(bytes calldata _btcDestination, address _coinDestination, uint256[N_COINS] calldata amounts, uint256 max_burn_amount) external discountCHI {\r\n        uint256[N_COINS] memory balances;\r\n        for(uint256 i = 0; i < coins.length; i++) {\r\n            balances[i] = coins[i].balanceOf(address(this));\r\n        }\r\n\r\n        uint256 _tokens = curveToken.balanceOf(msg.sender);\r\n        if(_tokens > max_burn_amount) { \r\n            _tokens = max_burn_amount;\r\n        }\r\n        require(curveToken.transferFrom(msg.sender, address(this), _tokens));\r\n        exchange.remove_liquidity_imbalance(amounts, max_burn_amount.mul(101).div(100));\r\n        _tokens = curveToken.balanceOf(address(this));\r\n        require(curveToken.transfer(_coinDestination, _tokens));\r\n\r\n        for(uint256 i = 0; i < coins.length; i++) {\r\n            balances[i] = coins[i].balanceOf(address(this)).sub(balances[i]);\r\n            if(i == 0) continue;\r\n            require(coins[i].transfer(_coinDestination, balances[i]));\r\n        }\r\n\r\n        // Burn and send proceeds to the User\r\n        uint256 burnAmount = registry.getGatewayBySymbol(\"BTC\").burn(_btcDestination, balances[0]);\r\n        emit Burn(burnAmount);\r\n    }\r\n\r\n    //always removing in renBTC, else use normal method\r\n    function removeLiquidityOneCoinThenBurn(bytes calldata _btcDestination, uint256 _token_amounts, uint256 min_amount, uint8 _i) external discountCHI {\r\n        uint256 startRenbtcBalance = coins[0].balanceOf(address(this));\r\n        require(curveToken.transferFrom(msg.sender, address(this), _token_amounts));\r\n        exchange.remove_liquidity_one_coin(_token_amounts, _i, min_amount);\r\n        uint256 endRenbtcBalance = coins[0].balanceOf(address(this));\r\n        uint256 renbtcWithdrawn = endRenbtcBalance.sub(startRenbtcBalance);\r\n\r\n        // Burn and send proceeds to the User\r\n        uint256 burnAmount = registry.getGatewayBySymbol(\"BTC\").burn(_btcDestination, renbtcWithdrawn);\r\n        emit Burn(burnAmount);\r\n    }\r\n    \r\n    function swapThenBurn(bytes calldata _btcDestination, uint256 _amount, uint256 _minRenbtcAmount, uint8 _i) external discountCHI {\r\n        require(coins[_i].transferFrom(msg.sender, address(this), _amount));\r\n        uint256 startRenbtcBalance = coins[0].balanceOf(address(this));\r\n        exchange.exchange(_i, 0, _amount, _minRenbtcAmount);\r\n        uint256 endRenbtcBalance = coins[0].balanceOf(address(this));\r\n        uint256 renbtcBought = endRenbtcBalance.sub(startRenbtcBalance);\r\n        \r\n        // Burn and send proceeds to the User\r\n        uint256 burnAmount = registry.getGatewayBySymbol(\"BTC\").burn(_btcDestination, renbtcBought);\r\n        emit Burn(burnAmount);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ICurveExchange\",\"name\":\"_exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveTokenAddress\",\"type\":\"address\"},{\"internalType\":\"contract IGatewayRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[3]\",\"name\":\"_coins\",\"type\":\"address[3]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"curveAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"}],\"name\":\"DepositMintedCurve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"renAmount\",\"type\":\"uint256\"}],\"name\":\"ReceiveRen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"erc20BTCAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"j\",\"type\":\"int128\"}],\"name\":\"SwapReceived\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"chi\",\"outputs\":[{\"internalType\":\"contract IFreeFromUpTo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"contract ICurveExchange\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wbtcDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[3]\",\"name\":\"_amounts\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256\",\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_new_min_mint_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"mintNoDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newMinExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"},{\"internalType\":\"int128\",\"name\":\"_j\",\"type\":\"int128\"},{\"internalType\":\"address payable\",\"name\":\"_wbtcDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"mintNoSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wbtcDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[3]\",\"name\":\"_amounts\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256\",\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_new_min_mint_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"mintThenDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newMinExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"},{\"internalType\":\"int128\",\"name\":\"_j\",\"type\":\"int128\"},{\"internalType\":\"address payable\",\"name\":\"_coinDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"mintThenSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"recoverStuck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IGatewayRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_btcDestination\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_coinDestination\",\"type\":\"address\"},{\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256\",\"name\":\"max_burn_amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityImbalanceThenBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_btcDestination\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_token_amounts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_i\",\"type\":\"uint8\"}],\"name\":\"removeLiquidityOneCoinThenBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_btcDestination\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_coinDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[3]\",\"name\":\"min_amounts\",\"type\":\"uint256[3]\"}],\"name\":\"removeLiquidityThenBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_btcDestination\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minRenbtcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_i\",\"type\":\"uint8\"}],\"name\":\"swapThenBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CurveExchangeAdapter","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007fc77b5c7614e1533320ea6ddc2eb61fa00a9714000000000000000000000000075b1bb99792c9e1041ba13afef80c91a1e70fb3000000000000000000000000e80d347df1209a76dd9d2319d62912ba98c54ddd000000000000000000000000eb4c2781e4eba804ce9a9803c67d0893436bb27d0000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000fe18be6b3bd88a2d2a7f928d00292e7a9963cfc6","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0b97a1d3bb04993f4e591a4ae12b2407bc703a38eac68f71b2ca5cede79e8fe9"}]}