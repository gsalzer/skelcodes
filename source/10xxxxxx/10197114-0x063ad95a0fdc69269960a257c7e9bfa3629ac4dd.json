{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-06-02\r\n*/\r\n\r\npragma experimental ABIEncoderV2;\r\npragma solidity ^0.6.0;\r\n\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\ninterface IACL {\r\n    function accessible(address from, address to, bytes4 sig)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\ninterface IReplaceACL {\r\n    function setACL(address _ACL) external;\r\n}\r\n\r\ncontract ACL {\r\n    using Address for address;\r\n\r\n    //系统停机控制\r\n    bool public locked;\r\n\r\n    //系统维护者\r\n    address public admin;\r\n\r\n    struct ownerset {\r\n        address[] addresses;\r\n        mapping(address => uint256) indexes;\r\n    }\r\n\r\n    ownerset private _owners_set;\r\n    uint public owners_size;\r\n\r\n    address public pending_admin;\r\n    address public pending_owner;\r\n\r\n    //控制签名串的重放攻击\r\n    uint public nonce;\r\n\r\n    //访问控制列表(函数级别)\r\n    mapping(address => mapping(address => mapping(bytes4 => bool))) public facl;\r\n    //访问控制列表(合约级别)\r\n    mapping(address => mapping(address => bool)) public cacl;\r\n\r\n    modifier auth {\r\n        require(\r\n            accessible(msg.sender, address(this), msg.sig),\r\n            \"access unauthorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function owners() public view returns (address[] memory) {\r\n        return _owners_set.addresses;\r\n    }\r\n\r\n    constructor(address[] memory _owners, uint _owners_size) public {\r\n        require(_owners.length >= _owners_size, \"invalid _owners_size\");\r\n        for (uint256 i = 0; i < _owners.length; ++i) {\r\n            require(_add(_owners[i]), \"added address is already an owner\");\r\n        }\r\n        admin = msg.sender;\r\n        owners_size = _owners_size;\r\n    }\r\n\r\n    function unlock() external auth {\r\n        locked = false;\r\n    }\r\n\r\n    function lock() external auth {\r\n        locked = true;\r\n    }\r\n\r\n    function accessible(address sender, address to, bytes4 sig)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (sender == admin) return true;\r\n        if (_indexof(sender) != 0) return true;\r\n        if (locked) return false;\r\n        if (cacl[sender][to]) return true;\r\n        if (facl[sender][to][sig]) return true;\r\n        return false;\r\n    }\r\n\r\n    function mulsigauth(\r\n        bytes32 _hash,\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s,\r\n        address who) public {\r\n        uint256 _size = _size();\r\n        uint256 weights = _size / 2 + 1;\r\n        require(_indexof(who) != 0, \"msg.sender must be owner\");\r\n        require(v.length == r.length && r.length == s.length, \"invalid signatures\");\r\n        require(v.length <= _size && v.length >= weights, \"invalid length\");\r\n\r\n        uint256[] memory unique = new uint256[](_size);\r\n        for (uint256 i = 0; i < v.length; ++i) {\r\n            address owner = ecrecover(_hash, v[i], r[i], s[i]);\r\n            uint256 _i = _indexof(owner);\r\n            require(_i != 0, \"is not owner\");\r\n            require(unique[_i - 1] == 0, \"duplicate signature\");\r\n            unique[_i - 1] = 1;\r\n        }\r\n\r\n        uint256 _weights = 0;\r\n        for (uint256 i = 0; i < _size; ++i) {\r\n            _weights += unique[i];\r\n        }\r\n\r\n        require(_weights >= weights, \"insufficient weights\");\r\n    }\r\n\r\n    function multiSigSetACLs(\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s,\r\n        address[] memory execTargets,\r\n        address newACL) public {\r\n        bytes32 inputHash = keccak256(abi.encode(newACL, msg.sender, nonce, this.multiSigSetACLs.selector));\r\n        bytes32 totalHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", inputHash));\r\n        mulsigauth(totalHash, v, r, s, msg.sender);\r\n        nonce += 1;\r\n        for (uint i = 0; i < execTargets.length; ++i) {\r\n            IReplaceACL(execTargets[i]).setACL(newACL);\r\n        }\r\n    }\r\n\r\n    //预设置 @who 具有owner权限.\r\n    function proposeOwner(\r\n        uint8[] calldata v,\r\n        bytes32[] calldata r,\r\n        bytes32[] calldata s,\r\n        address who\r\n    ) external {\r\n        bytes32 inputHash = keccak256(abi.encode(who, msg.sender, nonce, this.proposeOwner.selector));\r\n        bytes32 totalHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", inputHash));\r\n        mulsigauth(totalHash, v, r, s, msg.sender);\r\n        pending_owner = who;\r\n        nonce += 1;\r\n    }\r\n\r\n    function confirmOwner() external {\r\n        require(msg.sender == pending_owner, \"sender is not pending_owner\");\r\n        require(_add(msg.sender), \"added address is already an owner\");\r\n        pending_owner = address(0);\r\n    }\r\n\r\n    //最高级别owner修改admin\r\n    function proposeAdmin(address who) external {\r\n        require(_indexof(msg.sender) != 0, \"msg.sender is not sys owner\");\r\n        pending_admin = who;\r\n    }\r\n\r\n    function confirmAdmin() external {\r\n        require(msg.sender == pending_admin, \"sender is not pending_admin\");\r\n        admin = msg.sender;\r\n        pending_admin = address(0);\r\n    }\r\n\r\n    function replace(address who) external {\r\n        require(msg.sender == pending_owner, \"sender is not pending_owner\");\r\n        require(_add(msg.sender), \"added address is already an owner\");\r\n        require(_remove(who), \"removed address is not owner\");\r\n        pending_owner = address(0);\r\n    }\r\n\r\n    function remove(\r\n        uint8[] calldata v,\r\n        bytes32[] calldata r,\r\n        bytes32[] calldata s,\r\n        address who\r\n    ) external {\r\n        bytes32 inputHash = keccak256(abi.encode(who, msg.sender, nonce, this.remove.selector));\r\n        bytes32 totalHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", inputHash));\r\n        mulsigauth(totalHash, v, r, s, msg.sender);\r\n        require(_remove(who), \"removed address is not owner\");\r\n        require(_size() >= owners_size, \"invalid size and weights\");\r\n        nonce += 1;\r\n    }\r\n\r\n    function updateOwnerSize(\r\n        uint8[] calldata v,\r\n        bytes32[] calldata r,\r\n        bytes32[] calldata s,\r\n        uint256 _owners_size\r\n    ) external {\r\n        bytes32 inputHash = keccak256(abi.encode(_owners_size, msg.sender, nonce, this.updateOwnerSize.selector));\r\n        bytes32 totalHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", inputHash));\r\n        mulsigauth(totalHash, v, r, s, msg.sender);\r\n        nonce += 1;\r\n        owners_size = _owners_size;\r\n        require(_size() >= owners_size, \"invalid size and weights\");\r\n    }\r\n\r\n    //添加访问控制: 允许 @who 访问 @code 的所有方法\r\n    function enable(address sender, address to, bytes4 sig) external auth {\r\n        require(to.isContract(), \"To is not contract\");\r\n        facl[sender][to][sig] = true;\r\n    }\r\n\r\n    function disable(address sender, address to, bytes4 sig) external auth {\r\n        require(to.isContract(), \"To is not contract\");\r\n        facl[sender][to][sig] = false;\r\n    }\r\n\r\n    function enableany(address sender, address to) external auth {\r\n        require(to.isContract(), \"To is not contract\");\r\n        cacl[sender][to] = true;\r\n    }\r\n\r\n    function enableboth(address sender, address to) external auth {\r\n        require(to.isContract(), \"To is not contract\");\r\n        cacl[sender][to] = true;\r\n        cacl[to][sender] = true;\r\n    }\r\n\r\n    function disableany(address sender, address to) external auth {\r\n        require(to.isContract(), \"To is not contract\");\r\n        cacl[sender][to] = false;\r\n    }\r\n\r\n    function _add(address value) internal returns (bool) {\r\n        if (_owners_set.indexes[value] != 0) return false;\r\n        _owners_set.addresses.push(value);\r\n        _owners_set.indexes[value] = _owners_set.addresses.length;\r\n        return true;\r\n    }\r\n\r\n    function _remove(address value) internal returns (bool) {\r\n        if (_owners_set.indexes[value] == 0) return false;\r\n\r\n        uint256 _i = _owners_set.indexes[value];\r\n        address _popv = _owners_set.addresses[_size() - 1];\r\n\r\n        _owners_set.addresses[_i - 1] = _popv;\r\n        _owners_set.addresses.pop();\r\n\r\n        _owners_set.indexes[_popv] = _i;\r\n        delete _owners_set.indexes[value];\r\n\r\n        return true;\r\n    }\r\n\r\n    function _size() internal view returns (uint256) {\r\n        return _owners_set.addresses.length;\r\n    }\r\n\r\n    function _indexof(address owner) internal view returns (uint256) {\r\n        return _owners_set.indexes[owner];\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_owners_size\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"}],\"name\":\"accessible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cacl\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"}],\"name\":\"disable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"disableany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"}],\"name\":\"enable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"enableany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"enableboth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"facl\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"mulsigauth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"execTargets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"newACL\",\"type\":\"address\"}],\"name\":\"multiSigSetACLs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owners_size\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pending_admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pending_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"proposeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"replace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_owners_size\",\"type\":\"uint256\"}],\"name\":\"updateOwnerSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ACL","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000030000000000000000000000004abe902f0b7ce67ca7897dc5ab2f0b5c15e63f7800000000000000000000000000ad986f1f4fbb6cbe1a385248d61c5f989f3713000000000000000000000000a05b770842f60cdf66dccb06b8931d59adaf1802","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://aeb323b7478c79a581299ff15e8d9f46f1c207065f3b3e2224321fa4e9d19a8d"}]}