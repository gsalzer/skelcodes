{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\ninterface CTokenInterface {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n}\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cTokenAddress) external returns (uint);\r\n}\r\n\r\ninterface InstaMapping {\r\n    function cTokenMapping(address) external view returns (address);\r\n}\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helpers is DSMath {\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getAddressETH() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    function getAddressWETH() internal pure returns (address) {\r\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\r\n        // return 0xd0A1E359811322d97991E03f863a0C30C2cF029C; // kovan\r\n    }\r\n\r\n    function isETH(address token) internal pure returns(bool) {\r\n        return token == getAddressETH() || token == getAddressWETH();\r\n    }\r\n}\r\n\r\n\r\ncontract CompoundHelpers is Helpers {\r\n    /**\r\n     * @dev Return Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() internal pure returns (address) {\r\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B; // main\r\n        // return 0x1f5D7F3CaAC149fE41b8bd62A3673FE6eC0AB73b; // kovan\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaDApp Mapping Addresses\r\n     */\r\n    function getMappingAddr() internal pure returns (address) {\r\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev enter compound market\r\n     */\r\n    function enterMarket(address cToken) internal {\r\n        address[] memory cTokens = new address[](1);\r\n        cTokens[0] = cToken;\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        troller.enterMarkets(cTokens);\r\n    }\r\n}\r\n\r\n\r\ncontract BasicResolver is CompoundHelpers {\r\n    event LogDeposit(address indexed token, uint256 tokenAmt);\r\n    event LogWithdraw(address indexed token);\r\n    event LogBorrow(address indexed token, uint256 tokenAmt);\r\n    event LogPayback(address indexed token);\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20_Token.\r\n     * @param token token address to deposit.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to deposit.\r\n    */\r\n    function deposit(address token, uint amt) external payable{\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        uint _amt = amt;\r\n        enterMarket(cToken);\r\n        if (isETH(token)) {\r\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\r\n            CETHInterface(cToken).mint.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\r\n            tokenContract.approve(cToken, _amt);\r\n            require(CTokenInterface(cToken).mint(_amt) == 0, \"minting-failed\");\r\n        }\r\n\r\n        emit LogDeposit(token, _amt);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw ETH/ERC20_Token.\r\n     * @param token token address to withdraw.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to withdraw.\r\n    */\r\n    function withdraw(address token, uint amt) external {\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        if (amt == uint(-1)) {\r\n            require(cTokenContract.redeem(cTokenContract.balanceOf(address(this))) == 0, \"full-withdraw-failed\");\r\n        } else {\r\n            require(cTokenContract.redeemUnderlying(amt) == 0, \"withdraw-failed\");\r\n        }\r\n\r\n        emit LogWithdraw(token);\r\n    }\r\n\r\n    /**\r\n     * @dev Borrow ETH/ERC20_Token.\r\n     * @param token token address to borrow.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to borrow.\r\n    */\r\n    function borrow(address token, uint amt) external {\r\n        uint _amt = amt;\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        enterMarket(cToken);\r\n        require(CTokenInterface(cToken).borrow(_amt) == 0, \"borrow-failed\");\r\n\r\n        emit LogBorrow(token, _amt);\r\n    }\r\n\r\n    /**\r\n     * @dev Payback borrowed ETH/ERC20_Token.\r\n     * @param token token address to payback.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to payback.\r\n    */\r\n    function payback(address token, uint amt) external {\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        uint _amt = amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(address(this)) : amt;\r\n\r\n        if (isETH(token)) {\r\n            require(address(this).balance >= _amt, \"not-enough-eth\");\r\n            CETHInterface(cToken).repayBorrow.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            require(tokenContract.balanceOf(address(this)) >= _amt, \"not-enough-token\");\r\n            tokenContract.approve(cToken, _amt);\r\n            require(cTokenContract.repayBorrow(_amt) == 0, \"repay-failed.\");\r\n        }\r\n\r\n        emit LogPayback(token);\r\n    }\r\n}\r\n\r\ncontract ConnectCompound is BasicResolver {\r\n    string public name = \"flashloan-Compound-v1.0\";\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"}],\"name\":\"LogBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LogPayback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"payback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ConnectCompound","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7c0b4cb08a42ab3ae9a6920107918d6e8731976a728a8fdea66e3e1380bb1c22"}]}