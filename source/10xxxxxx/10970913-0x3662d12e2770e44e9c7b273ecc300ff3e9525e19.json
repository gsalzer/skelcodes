{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            // solium-disable-next-line arg-overflow\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Configurations is Ownable {\r\n    using SafeMath for uint256;\r\n    uint256 public minFee;\r\n    uint256 public maxFee;\r\n    uint256 public minAmount;\r\n    uint256 public maxAmount;\r\n    uint256 public percentageFee;\r\n    uint256 public collectedFee;\r\n\r\n    address public pauser;\r\n    address public feeAccount;\r\n    address public middleware;\r\n\r\n    string[] public pairs;\r\n    uint256[] public minRate;\r\n    uint256[] public maxRate;\r\n\r\n    uint256 public rateDecimals = 18;\r\n    string public baseCurrency = \"GSU\";\r\n\r\n    mapping(string => uint8) public pairIndex;\r\n\r\n    event PauserChanged(address pauser);\r\n    event MiddlewareChanged(address middleware);\r\n    event FeeAccountUpdated(address feeAccount);\r\n    event RateUpdated(uint8 pair, uint256 minRate, uint256 maxRate);\r\n    event AmountUpdated(uint256 minAmount, uint256 maxAmount);\r\n    event FeeUpdated(uint256 minFee, uint256 maxFee, uint256 percentageFee);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the pauser.\r\n     */\r\n    modifier onlyPauser() {\r\n        require(pauser == _msgSender(), \"Dex: caller is not the pauser\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        uint256 _minFee,\r\n        uint256 _maxFee,\r\n        uint256 _percentageFee,\r\n        uint256 _minAmount,\r\n        uint256 _maxAmount,\r\n        uint256[] memory _minRate,\r\n        uint256[] memory _maxRate,\r\n        address _feeAccount,\r\n        address _middleware\r\n    ) public {\r\n        require(_feeAccount != address(0x0));\r\n        collectedFee = 0;\r\n        minFee = _minFee;\r\n        maxFee = _maxFee;\r\n        minRate = _minRate;\r\n        maxRate = _maxRate;\r\n        minAmount = _minAmount;\r\n        maxAmount = _maxAmount;\r\n        percentageFee = _percentageFee;\r\n        setfeeAccount(_feeAccount);\r\n        setMiddleware(_middleware);\r\n        setPauser(_msgSender());\r\n        pairs.push(\"GSU/ETH\");\r\n        pairs.push(\"ETH/GSU\");\r\n        pairs.push(\"GSU/USDT\");\r\n        pairs.push(\"USDT/GSU\");\r\n        pairIndex[\"GSU/ETH\"] = 0;\r\n        pairIndex[\"ETH/GSU\"] = 1;\r\n        pairIndex[\"GSU/USDT\"] = 2;\r\n        pairIndex[\"USDT/GSU\"] = 3;\r\n    }\r\n\r\n    function setMinFee(uint256 _minFee) external onlyOwner returns (bool) {\r\n        require(_minFee <= maxFee);\r\n        minFee = _minFee;\r\n        emit FeeUpdated(minFee, maxFee, percentageFee);\r\n        return true;\r\n    }\r\n\r\n    function setMaxFee(uint256 _maxFee) external onlyOwner returns (bool) {\r\n        require(_maxFee >= minFee);\r\n        maxFee = _maxFee;\r\n        emit FeeUpdated(minFee, maxFee, percentageFee);\r\n        return true;\r\n    }\r\n\r\n    function setPercentageFee(uint256 _percentageFee)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        percentageFee = _percentageFee;\r\n        emit FeeUpdated(minFee, maxFee, percentageFee);\r\n        return true;\r\n    }\r\n\r\n    function setfeeAccount(address _feeAccount)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_feeAccount != address(0x0));\r\n\r\n        feeAccount = _feeAccount;\r\n        emit FeeAccountUpdated(feeAccount);\r\n        return true;\r\n    }\r\n\r\n    function setMiddleware(address _middleware)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _middleware != address(0x0),\r\n            \"[Dex] middleware is ZERO Address\"\r\n        );\r\n        middleware = _middleware;\r\n        emit MiddlewareChanged(middleware);\r\n        return true;\r\n    }\r\n\r\n    function setPauser(address _pauser) public onlyOwner returns (bool) {\r\n        require(_pauser != address(0x0), \"[Dex] pauser is ZERO Address\");\r\n        pauser = _pauser;\r\n        emit PauserChanged(pauser);\r\n        return true;\r\n    }\r\n\r\n    function collectFee(uint256 _fee) internal returns (bool) {\r\n        collectedFee = collectedFee.add(_fee);\r\n        return true;\r\n    }\r\n\r\n    function claimFee(uint256 _fee) internal returns (bool) {\r\n        collectedFee = collectedFee.sub(_fee);\r\n        return true;\r\n    }\r\n\r\n    function setMinRate(uint8 pair, uint256 rate)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(rate != 0);\r\n        minRate[pair] = rate;\r\n        emit RateUpdated(pair, minRate[pair], maxRate[pair]);\r\n        return true;\r\n    }\r\n\r\n    function setMaxRate(uint8 pair, uint256 rate)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(rate >= minRate[pair]);\r\n        maxRate[pair] = rate;\r\n        emit RateUpdated(pair, minRate[pair], maxRate[pair]);\r\n        return true;\r\n    }\r\n\r\n    function setMinAmount(uint256 amount) public onlyOwner returns (bool) {\r\n        require(amount != 0);\r\n        minAmount = amount;\r\n        emit AmountUpdated(minAmount, maxAmount);\r\n        return true;\r\n    }\r\n\r\n    function setMaxAmount(uint256 amount) public onlyOwner returns (bool) {\r\n        require(amount >= minAmount);\r\n        maxAmount = amount;\r\n        emit AmountUpdated(minAmount, maxAmount);\r\n        return true;\r\n    }\r\n}\r\n\r\ninterface ILIQUIDITY {\r\n    function balanceOf(string calldata symbol) external view returns (uint256);\r\n\r\n    function contractAddress(string calldata symbol)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function transfer(\r\n        string calldata symbol,\r\n        address payable recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract Dex is Ownable, Pausable, Configurations {\r\n    using SafeMath for uint256;\r\n    using ECDSA for bytes32;\r\n\r\n    ILIQUIDITY public liquidityContract;\r\n\r\n    event FeeWithdrawn(address to, uint256 amount);\r\n    event LiquidityContractUpdated(ILIQUIDITY liquidityContract);\r\n    event Swap(\r\n        address indexed sender,\r\n        string buy,\r\n        string sell,\r\n        uint256 buyAmount,\r\n        uint256 sellAmount,\r\n        uint256 rate,\r\n        uint256 fee\r\n    );\r\n\r\n    constructor(\r\n        uint256 _minFee,\r\n        uint256 _maxFee,\r\n        uint256 _percentageFee,\r\n        uint256 _minAmount,\r\n        uint256 _maxAmount,\r\n        uint256[] memory _minRate,\r\n        uint256[] memory _maxRate,\r\n        address _feeAccount,\r\n        address _middleware,\r\n        ILIQUIDITY _liquidity\r\n    )\r\n        public\r\n        Configurations(\r\n            _minFee,\r\n            _maxFee,\r\n            _percentageFee,\r\n            _minAmount,\r\n            _maxAmount,\r\n            _minRate,\r\n            _maxRate,\r\n            _feeAccount,\r\n            _middleware\r\n        )\r\n    {\r\n        setLiquidity(_liquidity);\r\n    }\r\n\r\n    // Reject incoming ethers\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n    // swap currencies\r\n    function swap(\r\n        string calldata buy,\r\n        string calldata sell,\r\n        uint256 amount,\r\n        uint256 rate,\r\n        uint32 expireTime,\r\n        bytes calldata signature\r\n    ) external payable whenNotPaused returns (bool) {\r\n        if (\r\n            keccak256(bytes(buy)) == keccak256(bytes(baseCurrency)) &&\r\n            keccak256(bytes(sell)) == keccak256(bytes(\"ETH\"))\r\n        ) {\r\n            require(\r\n                _beforeSwap(buy, sell, msg.value, rate, expireTime, signature)\r\n            );\r\n            return swapETHForGSU(rate);\r\n        }\r\n\r\n        require(msg.value == 0, \"[Dex] ethers are not accepted\");\r\n        require(_beforeSwap(buy, sell, amount, rate, expireTime, signature));\r\n\r\n        if (\r\n            keccak256(bytes(buy)) == keccak256(bytes(\"ETH\")) &&\r\n            keccak256(bytes(sell)) == keccak256(bytes(baseCurrency))\r\n        ) {\r\n            return swapGSUForETH(amount, rate);\r\n        } else {\r\n            return swapTokens(buy, sell, amount, rate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Pauses swap.\r\n     *\r\n     * See {Pausable-_pause}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `PAUSER_ROLE`.\r\n     */\r\n    function pause() external onlyPauser {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpauses swap.\r\n     *\r\n     * See {Pausable-_unpause}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `PAUSER_ROLE`.\r\n     */\r\n    function unpause() external onlyPauser {\r\n        _unpause();\r\n    }\r\n\r\n    function withdrawFee(uint256 _fee) external onlyOwner returns (bool) {\r\n        require(_fee <= collectedFee);\r\n\r\n        require(\r\n            liquidityContract.transfer(baseCurrency, payable(feeAccount), _fee)\r\n        );\r\n\r\n        require(claimFee(_fee), \"[Dex] unable to update collected fee\");\r\n\r\n        emit FeeWithdrawn(feeAccount, _fee);\r\n\r\n        return true;\r\n    }\r\n\r\n    function setLiquidity(ILIQUIDITY _liquidity)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _liquidity != ILIQUIDITY(address(0x0)),\r\n            \"[Dex] liquidityContract is ZERO Address\"\r\n        );\r\n        liquidityContract = _liquidity;\r\n        emit LiquidityContractUpdated(liquidityContract);\r\n        return true;\r\n    }\r\n\r\n    function _beforeSwap(\r\n        string memory buy,\r\n        string memory sell,\r\n        uint256 amount,\r\n        uint256 rate,\r\n        uint32 expireTime,\r\n        bytes memory signature\r\n    ) private view returns (bool) {\r\n        require(verifySigner(buy, sell, amount, rate, expireTime, signature));\r\n        require(verifySwap(buy, sell, amount, rate, expireTime));\r\n        return true;\r\n    }\r\n\r\n    function swapETHForGSU(uint256 rate) private returns (bool) {\r\n        uint256 amountBase = (swapAmount(\"GSU\", \"ETH\", msg.value, rate));\r\n\r\n        (uint256 fee, uint256 netAmount) = chargeFee(amountBase);\r\n\r\n        payable(address(liquidityContract)).transfer(msg.value);\r\n        liquidityContract.transfer(\"GSU\", _msgSender(), netAmount);\r\n        emit Swap(_msgSender(), \"GSU\", \"ETH\", netAmount, msg.value, rate, fee);\r\n        return true;\r\n    }\r\n\r\n    function swapGSUForETH(uint256 amount, uint256 rate)\r\n        private\r\n        returns (bool)\r\n    {\r\n        require(_moveTokensToLiquidity(\"GSU\", amount));\r\n\r\n        (uint256 fee, uint256 netAmount) = chargeFee(amount);\r\n\r\n        uint256 amountWei = (swapAmount(\"ETH\", \"GSU\", netAmount, rate));\r\n\r\n        require(\r\n            liquidityContract.transfer(\"ETH\", _msgSender(), amountWei),\r\n            \"[Dex] error in token tranfer\"\r\n        );\r\n\r\n        emit Swap(_msgSender(), \"ETH\", \"GSU\", amountWei, amount, rate, fee);\r\n        return true;\r\n    }\r\n\r\n    function swapTokens(\r\n        string memory buy,\r\n        string memory sell,\r\n        uint256 amount,\r\n        uint256 rate\r\n    ) private returns (bool) {\r\n        uint256 fee;\r\n        uint256 buyAmount;\r\n\r\n        require(_moveTokensToLiquidity(sell, amount));\r\n\r\n        //if baseCurrency is received deduct fee directly from amount\r\n        if (keccak256(bytes(sell)) == keccak256(bytes(baseCurrency))) {\r\n            (uint256 _fee, uint256 netAmount) = chargeFee(amount);\r\n            buyAmount = (swapAmount(buy, sell, netAmount, rate));\r\n            fee = _fee;\r\n        } else {\r\n            //else convert amount to baseCurrency then deduct fee\r\n            (fee, buyAmount) = chargeFee((swapAmount(buy, sell, amount, rate)));\r\n        }\r\n\r\n        // tranfer buyAmount to sender.\r\n        require(\r\n            liquidityContract.transfer(buy, _msgSender(), buyAmount),\r\n            \"[Dex] error in token tranfer\"\r\n        );\r\n\r\n        emit Swap(_msgSender(), buy, sell, buyAmount, amount, rate, fee);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _moveTokensToLiquidity(string memory currency, uint256 amount)\r\n        private\r\n        returns (bool)\r\n    {\r\n        address _contractAddress = contractAddress(currency);\r\n        require(\r\n            IERC20(_contractAddress).transferFrom(\r\n                _msgSender(),\r\n                address(liquidityContract),\r\n                amount\r\n            ),\r\n            \"[Dex] error in tranferFrom\"\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function chargeFee(uint256 amount)\r\n        internal\r\n        returns (uint256 fee, uint256 netAmount)\r\n    {\r\n        uint256 _fee = calculateFee(amount);\r\n        uint256 _amount = amount.sub(_fee);\r\n        collectFee(_fee);\r\n        return (_fee, _amount);\r\n    }\r\n\r\n    function verifySwap(\r\n        string memory buy,\r\n        string memory sell,\r\n        uint256 amount,\r\n        uint256 rate,\r\n        uint32 expireTime\r\n    ) public view whenNotPaused returns (bool) {\r\n        require(expireTime > block.timestamp, \"[Dex] rate is expired\");\r\n        require(\r\n            rate >= minRate[pairId(buy, sell)],\r\n            \"[Dex] rate is less than minRate\"\r\n        );\r\n        require(\r\n            rate <= maxRate[pairId(buy, sell)],\r\n            \"[Dex] rate is greater than maxRate\"\r\n        );\r\n\r\n        uint256 _amount = toBaseCurrency(sell, amount, rate);\r\n        require(_amount >= minAmount, \"[Dex] amount is less than minAmount\");\r\n        require(_amount <= maxAmount, \"[Dex] amount is greater than maxAmount\");\r\n        require(liquidity(buy) >= _amount, \"[Dex] Not enough liquidity\");\r\n\r\n        return true;\r\n    }\r\n\r\n    function pairId(string memory buy, string memory sell)\r\n        private\r\n        view\r\n        returns (uint8)\r\n    {\r\n        string memory _pair = string(abi.encodePacked(buy, \"/\", sell));\r\n        return pairIndex[_pair];\r\n    }\r\n\r\n    function toBaseCurrency(\r\n        string memory from,\r\n        uint256 amount,\r\n        uint256 rate\r\n    ) private view returns (uint256) {\r\n        if (keccak256(bytes(from)) == keccak256(bytes(baseCurrency))) {\r\n            return amount;\r\n        } else {\r\n            return swapAmount(\"GSU\", from, amount, rate);\r\n        }\r\n    }\r\n\r\n    function swapAmount(\r\n        string memory buy,\r\n        string memory sell,\r\n        uint256 amount,\r\n        uint256 rate\r\n    ) private view returns (uint256) {\r\n        uint256 exponent = (rateDecimals.add(decimals(buy))).sub(\r\n            decimals(sell)\r\n        );\r\n        return (amount.mul(10**exponent)).div(rate);\r\n    }\r\n\r\n    function verifySigner(\r\n        string memory buy,\r\n        string memory sell,\r\n        uint256 amount,\r\n        uint256 rate,\r\n        uint32 expireTime,\r\n        bytes memory signature\r\n    ) public view returns (bool) {\r\n        address signer = keccak256(\r\n            abi.encodePacked(buy, sell, amount, rate, expireTime)\r\n        )\r\n            .recover(signature);\r\n\r\n        require(middleware == signer, \"[Dex] signer is not middleware\");\r\n\r\n        return true;\r\n    }\r\n\r\n    function decimals(string memory symbol) public view returns (uint256) {\r\n        if (keccak256(bytes(symbol)) == keccak256(bytes(\"ETH\"))) return 18;\r\n        else {\r\n            address contractAddress = liquidityContract.contractAddress(symbol);\r\n            return IERC20(contractAddress).decimals();\r\n        }\r\n    }\r\n\r\n    function contractAddress(string memory symbol)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return liquidityContract.contractAddress(symbol);\r\n    }\r\n\r\n    function liquidity(string memory symbol) public view returns (uint256) {\r\n        return liquidityContract.balanceOf(symbol);\r\n    }\r\n\r\n    function calculateFee(uint256 baseAmount) public view returns (uint256) {\r\n        uint256 divisor = uint256(100).mul((10**decimals(baseCurrency)));\r\n        uint256 _fee = (baseAmount.mul(percentageFee)).div(divisor);\r\n\r\n        if (_fee < minFee) {\r\n            _fee = minFee;\r\n        } else if (_fee > maxFee) {\r\n            _fee = maxFee;\r\n        }\r\n        return _fee;\r\n    }\r\n\r\n    function destroy() external onlyOwner {\r\n        selfdestruct(payable(owner()));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentageFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_minRate\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_maxRate\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_feeAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_middleware\",\"type\":\"address\"},{\"internalType\":\"contract ILIQUIDITY\",\"name\":\"_liquidity\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"AmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"FeeAccountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentageFee\",\"type\":\"uint256\"}],\"name\":\"FeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ILIQUIDITY\",\"name\":\"liquidityContract\",\"type\":\"address\"}],\"name\":\"LiquidityContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"middleware\",\"type\":\"address\"}],\"name\":\"MiddlewareChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pauser\",\"type\":\"address\"}],\"name\":\"PauserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"pair\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxRate\",\"type\":\"uint256\"}],\"name\":\"RateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"buy\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sell\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"baseCurrency\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"contractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityContract\",\"outputs\":[{\"internalType\":\"contract ILIQUIDITY\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"middleware\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"minRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"pairIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentageFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILIQUIDITY\",\"name\":\"_liquidity\",\"type\":\"address\"}],\"name\":\"setLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxFee\",\"type\":\"uint256\"}],\"name\":\"setMaxFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"pair\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setMaxRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_middleware\",\"type\":\"address\"}],\"name\":\"setMiddleware\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minFee\",\"type\":\"uint256\"}],\"name\":\"setMinFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"pair\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setMinRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pauser\",\"type\":\"address\"}],\"name\":\"setPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentageFee\",\"type\":\"uint256\"}],\"name\":\"setPercentageFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAccount\",\"type\":\"address\"}],\"name\":\"setfeeAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"buy\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sell\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"expireTime\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"buy\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sell\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"expireTime\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verifySigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"buy\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sell\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"expireTime\",\"type\":\"uint32\"}],\"name\":\"verifySwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"withdrawFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Dex","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000019000000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000054ad24472b596ea928fc57d12cb84a9ab0531d8200000000000000000000000042bc0011b1a6c342d50989c9303e3e89a004e8a000000000000000000000000097e655c7580c09819ac76c1aa7647462de4c4a8e000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000099ea388a8880000000000000000000000000000000000000000000000000f810c1cb501b800000000000000000000000000000000000000000000000000000ced20d5aaba00000000000000000000000000000000000000000000000000000b89bcea21ae30000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000c3e4cf6d33000000000000000000000000000000000000000000000000013bb83c7720230000000000000000000000000000000000000000000000000000010739e3a431f78000000000000000000000000000000000000000000000000000eaf4ce8c06f5000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1ae955a16a23755523e1cf83439d91db3d01187a9402a44e84630506638f4205"}]}