{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.6.0 <0.7.0;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Register  {\r\n    \r\n    using SafeMath for *;\r\n    uint public id;\r\n    uint public deposit;\r\n    address private owner;\r\n    struct dadList{\r\n        bytes32 dadHash;\r\n        address userDad;\r\n        uint joinTime;\r\n        uint deposit;\r\n    }\r\n    struct dadAccount{\r\n        uint aid;\r\n        address userDad;\r\n        address referrer;\r\n        uint joinCount;\r\n        uint referredCount;\r\n        uint totalDeposit;\r\n        uint lastJoinTime;\r\n        uint totalProfit;\r\n    }\r\n    struct userDepoHis{\r\n        uint uid;\r\n        address dadAdd;\r\n        uint depositAmt;\r\n        uint depositDate;\r\n    }\r\n    struct userProfitHis{\r\n        address userDadFrom;\r\n        address userDadTo;\r\n        uint profitAmt;\r\n        uint profitDate;\r\n    }\r\n    struct userWithdrawHis{\r\n        bytes32 dadHash;\r\n        uint withdrawAmt;\r\n        uint withdrawDate;\r\n        uint exitPosition;\r\n        uint exitCount;\r\n    }\r\n    struct queueAcc{\r\n        uint qid;\r\n        address accDad;\r\n        uint queueBalance;\r\n        uint lastQueue;\r\n    }\r\n    mapping (bytes32 => dadList) public stringDad;\r\n    mapping (address => dadAccount) public accountView;\r\n    mapping (uint => userDepoHis) public userDepoHistory;\r\n    mapping (address => userProfitHis) public userProfitHistory;\r\n    mapping (address => userWithdrawHis) public userWithdrawHistory;\r\n    mapping (address => queueAcc) public queueAccount;\r\n    event RegistrationSuccess(address indexed user,address indexed parent,uint amount,uint jointime);\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    modifier isCorrectAddress(address _user) {\r\n        require(_user !=address(0), \"Invalid Address!\");\r\n        _;\r\n    }\r\n    modifier isNotReferrer(address currentUser,address user) {\r\n        require(currentUser !=user, \"Referrer cannot register as its own Referee\");\r\n        _;\r\n    }\r\n    modifier isNotRegister(address _user) {\r\n        require(accountView[_user].userDad==address(0), \"Address registered!\");\r\n        _;\r\n    }\r\n    modifier depositNotEmpty(uint value){\r\n        require(deposit>0,\"Invalid deposit amount\");\r\n        _;\r\n    }\r\n    constructor () public{\r\n        owner = msg.sender;\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n    function newDadRegister(bytes32 _hash,address _referrer,uint _time,uint _amount)isCorrectAddress(_referrer)isNotReferrer(msg.sender,_referrer)depositNotEmpty(msg.value) public payable returns(bool){\r\n        address checkUser=accountView[msg.sender].userDad;\r\n        bytes32 userHash=stringDad[_hash].dadHash;\r\n        if(checkUser!=address(0) && _hash!=userHash){\r\n            createNewAcc(_hash,msg.sender,_time,_amount);\r\n        }else{\r\n        id++;\r\n        updateDadAcc(id,msg.sender,_referrer,_amount,_time);\r\n        emit RegistrationSuccess(msg.sender,_referrer,_amount,_time);\r\n        return true;\r\n        }\r\n        \r\n    }\r\n    function updateDadAcc(uint _id,address _newDad,address _dadRefer,uint _joinTime,uint _deposit)internal returns(bool){\r\n        dadAccount storage insertNewDad=accountView[_newDad];\r\n        insertNewDad.aid=_id;\r\n        insertNewDad.userDad=_newDad;\r\n        insertNewDad.referrer=_dadRefer;\r\n        insertNewDad.joinCount=insertNewDad.joinCount.add(1);\r\n        insertNewDad.lastJoinTime=_joinTime;\r\n        insertNewDad.totalDeposit=insertNewDad.totalDeposit.add(_deposit);\r\n        updateDadList(_newDad,_deposit,_joinTime);\r\n        updateUserDepo(_newDad,_joinTime,_deposit);\r\n        updateParentAcc(_dadRefer);\r\n        updateUserProfit(_newDad);\r\n        return true;\r\n    }\r\n    function updateDadList (address _newDad,uint _deposit,uint _joinTime)internal returns (bool){\r\n        bytes32 dadId=keccak256(abi.encodePacked(_newDad,_deposit,_joinTime,id));\r\n        dadList storage updateNewDad=stringDad[dadId];\r\n        updateNewDad.dadHash=dadId;\r\n        updateNewDad.userDad=_newDad;\r\n        updateNewDad.joinTime=_joinTime;\r\n        updateNewDad.deposit=_deposit;\r\n        updateUserWithdraw(dadId,_newDad);\r\n        return true;\r\n    }\r\n    function updateUserDepo(address _newDad,uint _joinTime,uint _deposit)internal returns(bool){\r\n        userDepoHis storage updateUserDepohis=userDepoHistory[id];\r\n        updateUserDepohis.uid=id;\r\n        updateUserDepohis.dadAdd=_newDad;\r\n        updateUserDepohis.depositAmt=_deposit;\r\n        updateUserDepohis.depositDate=_joinTime;\r\n        return true;\r\n    }\r\n    function updateUserProfit(address _newDad)internal returns(bool){\r\n        userProfitHis storage updateUserProhis=userProfitHistory[_newDad];\r\n        updateUserProhis.userDadTo=_newDad;\r\n        return true;\r\n    }\r\n    function updateUserWithdraw(bytes32 _id,address _newDad)internal returns(bool){\r\n        userWithdrawHis storage setUserWithdraw=userWithdrawHistory[_newDad];\r\n        setUserWithdraw.dadHash=_id;\r\n        return true;\r\n    }\r\n    function updateParentAcc(address _dadRefer)internal returns(bool){\r\n        dadAccount storage updateParentDad=accountView[_dadRefer];\r\n         updateParentDad.referredCount=updateParentDad.referredCount.add(1);\r\n         return true;\r\n    }\r\n    function createNewAcc(bytes32 _userHash,address _user,uint _joinTime,uint _deposit)internal returns(bool){\r\n        dadList storage addNewAccDad=stringDad[_userHash];\r\n        addNewAccDad.dadHash=_userHash;\r\n        addNewAccDad.userDad=_user;\r\n        addNewAccDad.joinTime=_joinTime;\r\n        addNewAccDad.deposit=_deposit;\r\n        return true;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"jointime\",\"type\":\"uint256\"}],\"name\":\"RegistrationSuccess\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"aid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userDad\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"joinCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referredCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastJoinTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalProfit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"newDadRegister\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"queueAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"accDad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"queueBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastQueue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stringDad\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"dadHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"userDad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"joinTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userDepoHistory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dadAdd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userProfitHistory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userDadFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userDadTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"profitAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profitDate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userWithdrawHistory\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"dadHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exitPosition\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exitCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Register","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://94361c1d6fbbaa12300c915e46be47c1adf5d3d773954b0f8641a1e61a9e78de"}]}