{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20Interface.sol\":{\"content\":\"// Abstract contract for the full ERC 20 Token standard\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\npragma solidity ^0.5.0;\\n\\n/**\\n * @author Quant Network\\n * @title ERC20Interface\\n * @dev Allows contracts to easily interface with an ERC20 contract without knowing the whole code\\n */\\ninterface ERC20Interface {\\n \\n    /**\\n     * @return The total supply of tokens\\n     */   \\n    function totalSupply() external view  returns (uint256 supply);\\n\\n    /**\\n     * @param _owner The address from which the balance will be retrieved\\n     * @return The balance\\n     */\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    /** \\n     * send `_value` token(s) to `_to` from `msg.sender`\\n     * @param _to The address of the recipient\\n     * @param _value The amount of token to be transferred\\n     * @return Whether the transfer was successful or not\\n     */\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    /**\\n     * send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\\n     * @param _from The address of the sender\\n     * @param _to The address of the recipient\\n     * @param _value The amount of token to be transferred\\n     * @return Whether the transfer was successful or not\\n     */\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n\\n    /**\\n     * `msg.sender` approves `_spender` to spend `_value` tokens\\n     * @param _spender The address of the account able to transfer the tokens\\n     * @param _value The amount of tokens to be approved for transfer\\n     * @return Whether the approval was successful or not\\n     */\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    /**\\n     * @param _owner The address of the account owning tokens\\n     * @param _spender The address of the account able to transfer the tokens\\n     * @return Amount of remaining tokens allowed to spent\\n     */\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n}\"},\"EternalStorageData.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n * @author Quant Network\\n * @title EternalStorage\\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\\n */\\ncontract EternalStorage {\\n\\n  mapping(bytes32 =\\u003e bool) internal boolStorage;\\n  mapping(bytes32 =\\u003e address) internal addressStorage;\\n  mapping(bytes32 =\\u003e string) internal stringStorage;\\n  mapping(bytes32 =\\u003e bytes) internal bytesStorage;\\n\\n  mapping(bytes32 =\\u003e bytes1) internal bytes1Storage;\\n  mapping(bytes32 =\\u003e bytes2) internal bytes2Storage;\\n  mapping(bytes32 =\\u003e bytes4) internal bytes4Storage;\\n  mapping(bytes32 =\\u003e bytes8) internal bytes8Storage;\\n  mapping(bytes32 =\\u003e bytes16) internal bytes16Storage;\\n  mapping(bytes32 =\\u003e bytes32) internal bytes32Storage;\\n  \\n  mapping(bytes32 =\\u003e int8) internal int8Storage;\\n  mapping(bytes32 =\\u003e int16) internal int16Storage;\\n  mapping(bytes32 =\\u003e int32) internal int32Storage;\\n  mapping(bytes32 =\\u003e int64) internal int64Storage;\\n  mapping(bytes32 =\\u003e int128) internal int128Storage;\\n  mapping(bytes32 =\\u003e int256) internal int256Storage;\\n  \\n  mapping(bytes32 =\\u003e uint8) internal uint8Storage;\\n  mapping(bytes32 =\\u003e uint16) internal uint16Storage;\\n  mapping(bytes32 =\\u003e uint32) internal uint32Storage;\\n  mapping(bytes32 =\\u003e uint64) internal uint64Storage;\\n  mapping(bytes32 =\\u003e uint128) internal uint128Storage;\\n  mapping(bytes32 =\\u003e uint256) internal uint256Storage;\\n\\n\\n}\"},\"TreasuryBase.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title TreasuryAbstract\\n * @dev Sets the main variables of a Treasury contract and allows other contracts to easily interface with a Treasury contract without knowing the whole code. \\n */\\ncontract TreasuryBase is UpgradeableProxy {\\n    \\n        // the connected factory of this treasury\\n        bytes constant private treasurysFactory1 = \\u00271.treasurysFactory\\u0027;\\n        // the connected rulelist of this treasury\\n        bytes constant private treasurysRuleList1 = \\u00271.treasurysRuleList\\u0027;\\n        // the treasury\\u0027s escrowed deposit\\n        bytes constant private treasurysDeposit1 = \\u00271.treasuryDeposit\\u0027;\\n        // the QNT address of this treasury (possible cold wallet)   \\n        bytes constant private QNTAddress1 = \\u00271.QNTAddress\\u0027;\\n        // the operator address of this treasury, which can call other smart contract functions on behalf of the treasury\\n        bytes constant private operatorAddress1 = \\u00271.operatorAddress\\u0027;\\n        // whether this treasury is currently paused (true) or active (false)\\n        bytes constant private circuitBreakerOn1 = \\u00271.circuitBreakerOn\\u0027;\\n        // the fee the MAPP has to pay for any dispute raised per gateway\\n        bytes constant private mappDisputeFeeMultipler1 = \\u00271.mappDisputeFeeMultipler\\u0027;\\n        // the commission divider charged for every mapp to gateway transaction. \\n        // The divider is used with the original fee of the function.\\n        // I.e a commission divider of 2 is equal to 50% commission\\n        bytes constant private commissionDivider1 = \\u00271.commissionDivider\\u0027;\\n        // the penalty multiplier the treasury has to pay if it has been found in breach of \\n        // one of its verification rules. The mulitipication is used with the original fee of the function.\\n        // I.e. a treasuryPenalty of 10 is equal to a 10x penalty\\n        bytes constant private  treasuryPenaltyMultipler1 = \\u00271.treasuryPenaltyMultipler\\u0027;\\n        // the penalty multiplier a gateway has to pay if it has be found in breach of\\n        // one of its verification rules. The mulitipication is used with the original fee of the function\\n        // I.e. a gatewayPenalty of 5 is equal to a 5x penalty.\\n        bytes constant private gatewayPenaltyMultipler1 = \\u00271.gatewayPenaltyMultipler\\u0027;\\n\\n        /**\\n         * set a new factory for this treasury\\n         */        \\n        function treasurysFactory(address newTreasurysFactory) internal {\\n            addressStorage[keccak256(treasurysFactory1)] = newTreasurysFactory;\\n        } \\n        \\n        \\n        /**\\n         * set a new rulelist for this treasury\\n         */        \\n        function treasurysRuleList(address newTreasurysRuleList) internal {\\n            addressStorage[keccak256(treasurysRuleList1)] = newTreasurysRuleList;\\n        } \\n\\n        /**\\n         * set a new treasury deposit \\n         */        \\n        function treasurysDeposit(address newTreasuryDeposit) internal {\\n            addressStorage[keccak256(treasurysDeposit1)] = newTreasuryDeposit;\\n        }\\n        \\n        /**\\n         * set a new QNTAddress for this treasury\\n         */        \\n        function QNTAddress(address newQNTAddress) internal {\\n            addressStorage[keccak256(QNTAddress1)] = newQNTAddress;\\n        }\\n        \\n        /**\\n         * set a new operator for this treasury\\n         */        \\n        function operatorAddress(address newOperator) internal {\\n            addressStorage[keccak256(operatorAddress1)] = newOperator;\\n        }\\n        \\n        /**\\n         * set the circuitbreaker of this treasury\\n         */        \\n        function circuitBreakerOn(bool newCircuitBreakerOn) internal {\\n            boolStorage[keccak256(circuitBreakerOn1)] = newCircuitBreakerOn;\\n        }\\n        \\n        /**\\n         * set the mapp dispute fee multiplier\\n         */        \\n        function mappDisputeFeeMultipler(uint16 newMappDisputeFeeMultipler) internal {\\n            uint16Storage[keccak256(mappDisputeFeeMultipler1)] = newMappDisputeFeeMultipler;\\n        }\\n        \\n \\n        /**\\n         * set the commission divider\\n         */        \\n        function commissionDivider(uint16 neCommissionDivider) internal {\\n            uint16Storage[keccak256(commissionDivider1)] = neCommissionDivider;\\n        }\\n\\n        /**\\n         * set the treasury dispute multiplier\\n         */        \\n        function treasuryPenaltyMultipler(uint16 newTreasuryPenaltyMultipler) internal {\\n            uint16Storage[keccak256(treasuryPenaltyMultipler1)] = newTreasuryPenaltyMultipler;\\n        }\\n\\n        /**\\n         * set the gateway dispute multiplier\\n         */        \\n        function gatewayPenaltyMultipler(uint16 newGatewayPenaltyMultipler) internal {\\n            uint16Storage[keccak256(gatewayPenaltyMultipler1)] = newGatewayPenaltyMultipler;\\n        }\\n\\n      /**\\n       * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n       */\\n      function admin() public view returns (address) {\\n          return addressStorage[keccak256(\\u0027proxy.admin\\u0027)];   \\n      }\\n    \\n        /**\\n        * @return - the number of hours wait time for any critical update\\n        */        \\n        function speedBumpHours() public view returns (uint16){\\n            return uint16Storage[keccak256(\\u0027proxy.speedBumpHours\\u0027)];\\n        }\\n     \\n        /**\\n         * @return - the connected factory of this treasury\\n         */        \\n        function treasurysFactory() public view returns (address){\\n            return addressStorage[keccak256(treasurysFactory1)];\\n        } \\n        \\n        /**\\n         * @return - the connected rulelist of this treasury\\n         */        \\n        function treasurysRuleList() public view returns (address){\\n            return addressStorage[keccak256(treasurysRuleList1)];\\n        } \\n\\n\\n        /**\\n         * @return - the treasury\\u0027s escrowed deposit\\n         */        \\n        function treasurysDeposit() public view returns (address){\\n            return addressStorage[keccak256(treasurysDeposit1)];\\n        }\\n        \\n        /**\\n         * @return - the withdrawal address of this treasury\\n         */        \\n        function QNTAddress() public view returns (address){\\n            return addressStorage[keccak256(QNTAddress1)];\\n        }\\n        \\n        /**\\n         * @return - the operator of this treasury\\n         */        \\n        function operatorAddress() public view returns (address){\\n            return addressStorage[keccak256(operatorAddress1)];\\n        }\\n        \\n        /**\\n         * @return - whether this treasury is currently active or not\\n         */        \\n        function circuitBreakerOn() public view returns (bool){\\n            return boolStorage[keccak256(circuitBreakerOn1)];\\n        }\\n        \\n        /**\\n         * @return - the fee the mapp has to pay for any dispute raised per gateway\\n         */        \\n        function mappDisputeFeeMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(mappDisputeFeeMultipler1)];\\n        }\\n        \\n \\n        /**\\n         * @return the commission divider charged for every mapp to gateway transaction.\\n         * The divider is used with the original fee of the function.\\n         * I.e a commission divider of 2 is equal to 50% commission\\n         */        \\n        function commissionDivider() public view returns (uint16){\\n            return uint16Storage[keccak256(commissionDivider1)];\\n        }\\n\\n        /**\\n         * @return - the penalty multiplier for the treasury has to pay if it has been found in breach of\\n         * one of its verification rules. The mulitipication is used with the original fee of the function.\\n         * I.e. a treasuryPenalty of 10 is equal to a 10x penalty\\n         */        \\n        function treasuryPenaltyMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(treasuryPenaltyMultipler1)];\\n        }\\n\\n        /**\\n         * @return - the penalty multiplier a gateway has to pay if it has be found in breach of\\n         * one of its verification rules. The mulitipication is used with the original fee of the function\\n         * I.e. a gatewayPenalty of 5 is equal to a 5x penalty.\\n         */        \\n        function gatewayPenaltyMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(gatewayPenaltyMultipler1)];\\n        }\\n    \\n}\"},\"TreasuryFactory.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./ERC20Interface.sol\\\";\\nimport \\\"./TreasuryBase.sol\\\";\\nimport \\\"./TreasuryFactoryBase.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title Allows child payment channel \\u0026 escrow deposit contracts to be easily created for gateways and mapps. \\n */\\ncontract TreasuryFactory is FactoryBase  {\\n    \\n    // the linked treasury contract\\n    bytes constant private treasuryAddress1 = \\u00271.treasuryaddress\\u0027;\\n    //mainnet QNT address\\n    ERC20Interface constant private QNTContract = ERC20Interface(0x4a220E6096B25EADb88358cb44068A3248254675);    \\n    \\n    // The event fired when a new mapp or gateway is stored here:\\n    event addedNewStakeholder(uint8 gateway, address newStakeholderQNTAddress, address newStakeholderOperatorAddress, uint256 QNTforChannel, uint256 QNTforDeposit, uint256 expirationTime);\\n    \\n    /**\\n     * All functions with this modifier can only be called by the current treasury smart contract owner\\n     * of the contract\\n     */\\n    modifier onlyTreasuryOperator(){\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        address operator = t.operatorAddress();\\n        if (msg.sender != operator){\\n            revert(\\\"Only the treasury address of this contract can modify its associated storage\\\");\\n        } else {\\n            _; // otherwise carry on with the computation\\n        }\\n    }\\n\\n    /**\\n     * Sets the linked treasury contract to the variable passed through\\n     * @param linkedTreasuryContract - the address of the linked treasury\\n     */ \\n    function initialize (address linkedTreasuryContract) external {\\n        require(!initialized(),\\\"contract can only be initialised once\\\");\\n         addressStorage[keccak256(treasuryAddress1)] = linkedTreasuryContract;\\n         initializeNow(); //sets this contract to initialized\\n    }\\n    \\n    /**\\n     * Adds a new mapp or gateway to the treasury and creates the payment channel and escrow deposit contract\\n     * @param gateway - is this stakeholder a gateway (true) or a mapp (false)\\n     * @param newStakeholderQNTAddress - the Ethereum address associated to the stakeholder\\u0027s (possibly cold) Wallet\\n     * @param newStakeholderOperatorAddress - the Ethereum address associated to the stakeholder\\u0027s operator address\\n     * @param QNTForPaymentChannel - the QNT to be placed in this channel\\n     * @param QNTForDeposit - how much QNT is being deposited in the escrow\\n     * @param expirationTime - when the payment channel times out\\n     */\\n    function addNew(uint8 gateway, address newStakeholderQNTAddress,  address newStakeholderOperatorAddress, uint256 QNTForPaymentChannel, uint256 QNTForDeposit, uint256 expirationTime) external onlyTreasuryOperator() {\\n        if (gateway == 1){\\n            if (gatewayChannel(newStakeholderQNTAddress) != address(0x0)){\\n                revert(\\\"A stakeholder cannot be re-added\\\"); //especially for a payment channel! Otherwise there maybe replay attacks (signed messages of the sender being used more than once)\\\");\\n            }\\n            gatewayCount(gatewayCount()+1);\\n        } else {\\n            if (mappChannel(newStakeholderQNTAddress) != address(0x0)){\\n                revert(\\\"A stakeholder cannot be re-added\\\"); //especially for a payment channel! Otherwise there maybe replay attacks (signed messages of the sender being used more than once)\\\");\\n            }\\n            mappCount(mappCount()+1);\\n        }\\n        address newChannel = addChannel(gateway,newStakeholderQNTAddress,newStakeholderOperatorAddress,expirationTime);\\n        address newEscrow = addEscrowDeposit(gateway,newStakeholderQNTAddress,newStakeholderOperatorAddress,newChannel);\\n        //function will fail if the new gateway/mapp has not approved this contract to take the total QNT\\n        //transfer all QNT to this contract to distribute to the payment channel and escrowed deposit in the subsequent function calls\\n        QNTContract.transferFrom(newStakeholderQNTAddress,address(this),(QNTForPaymentChannel+QNTForDeposit));\\n        //transfers QNT from this contract to the payment channel:\\n        //(stakeholder\\u0027s QNT has already been transferred to this contract)\\n        QNTContract.transfer(newChannel,QNTForPaymentChannel);\\n        //transfers QNT from this contract to the escrowed:\\n        //(stakeholder\\u0027s QNT has already been transferred to this contract)\\n        QNTContract.transfer(newEscrow,QNTForDeposit);\\n        emit addedNewStakeholder(gateway,newStakeholderQNTAddress,newStakeholderOperatorAddress,QNTForPaymentChannel,QNTForDeposit,expirationTime);\\n    }\\n    \\n    /**\\n     * Adds a new payment channel\\n     * @param gateway - is this stakeholder a gateway (true) or a mapp (false)\\n     * @param MAPPorGatewayQNTAddress - the QNT address of the MAPP or gateway in this channel\\n     * @param MAPPorGatewayOperatorAddress - the operator address of the MAPP or gateway in this channel\\n     * @param expirationTime - when the payment channel times out\\n     */\\n    function addChannel(uint8 gateway, address MAPPorGatewayQNTAddress, address MAPPorGatewayOperatorAddress,uint256 expirationTime) internal returns (address){\\n        //creates a new instance of the payment channel\\n        PaymentChannel tpc = new PaymentChannel(MAPPorGatewayQNTAddress,MAPPorGatewayOperatorAddress,treasuryAddress(),gateway,expirationTime);\\n        address channel = address(tpc);\\n        //records the newly created contract address:\\n        if (gateway == 1){\\n            gatewayChannel(MAPPorGatewayOperatorAddress, channel);\\n        } else {\\n            mappChannel(MAPPorGatewayOperatorAddress, channel);\\n        }\\n        return channel;\\n    }\\n    \\n    /**\\n     * Adds a new escrowed deposit\\n     * @param gateway - is this stakeholder a gateway (true) or a mapp (false)\\n     * @param MAPPorGatewayQNTAddress - the Ethereum address associated to the mapp or gateway\\u0027s coldWallet\\n     * @param MAPPorGatewayOperatorAddress - the Ethereum address associated to the mapp or gateway\\u0027s operator address, able to call functions of the escrow deposit when permissioned to do so\\n     * @param paymentChannel - the linked payment channel\\n     */\\n    function addEscrowDeposit(uint8 gateway, address MAPPorGatewayQNTAddress,  address MAPPorGatewayOperatorAddress, address paymentChannel) internal returns (address) {\\n        //creates a new instance of the deposit contract\\n        EscrowedDeposit ued = new EscrowedDeposit(MAPPorGatewayQNTAddress,MAPPorGatewayOperatorAddress,treasuryAddress(),paymentChannel);\\n        address escrow = address(ued);\\n        //records the newly created contract address:\\n        if (gateway == 1){\\n            gatewayDeposit(MAPPorGatewayOperatorAddress,escrow);\\n        } else {\\n            mappDeposit(MAPPorGatewayOperatorAddress,escrow);\\n        }\\n        return escrow;\\n    }\\n    \\n    /**\\n     * Reads the linked treasury contract address\\n     * @return - the treasury contract\\n     */       \\n    function treasuryAddress() public view returns (address) {\\n        return addressStorage[keccak256(treasuryAddress1)];\\n    }\\n\\n    /**\\n    * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n    */\\n    function admin() public view returns (address) {\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        return t.admin();   \\n    }\\n      \\n    /**\\n    * @return - the number of hours wait time for any critical update\\n    */        \\n    function speedBumpHours() public view returns (uint16){\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        return t.speedBumpHours();\\n    }\\n    \\n\\n}\\n\\n/**\\n * @author Quant Network\\n * @title Allows QNT to be held in a payment channel either between mapp (sender) and treasury (receiver), or between treasury (sender) and gateway (receiver)\\n */\\ncontract PaymentChannel {\\n    \\n    // the current nonce of the payment channel, updated when a claim is made. It is required to stop replay attacks (signed messages of the sender being used more than once)\\n    uint256 public currentNonce;\\n    // The address who added the deposit\\n    address public MAPPorGatewayQNTAddress;\\n    // The address that can trigger functions of this channel on behalf of the MAPP or Gateway\\n    address public MAPPorGatewayOperatorAddress;\\n    // the linked treasury contract\\n    TreasuryBase t;\\n    // treasuryIsReceiver of channel (true) or not (false)\\n    uint8 public treasuryIsSender;\\n    // How long this channel is locked for\\n    uint256 public expiration;\\n    // Hardcoded link to the QNT contract:\\n    ERC20Interface private constant QNTContract = ERC20Interface(0x19Bc592A0E1BAb3AFFB1A8746D8454743EE6E838); \\n \\n     // The event fired when the payment channel\\u0027s timeout variable is changed:\\n    event expirationChanged(uint256 expirationTime);\\n    // The event fired when the receiver has claimed some of the payment channel\\u0027s balance:\\n    event QNTPaymentClaimed(uint256 claimedQNT, uint256 remainingQNT);\\n    // The event fired when the sender has re-claimed the remaining QNT after the payment channel has timed out:\\n    event QNTReclaimed(uint256 returnedQNT);\\n\\n    /**\\n    * Deploys the contract and initialises the variables\\n    * @param thisMAPPorGatewayQNTAddress - the QNT address of the MAPP or gateway in this channel\\n    * @param thisMAPPorGatewayOperatorAddress - the operator address of the MAPP or gateway in this channel\\n    * @param thisTreasuryAddress - the address of the treasury smart contract\\n    * @param thisTreasuryIsSender - is the treasury the receiver (true) or sender (false) of this channel\\n    * @param thisExpirationTime - the expiry time of this channel\\n    */ \\n    constructor(address thisMAPPorGatewayQNTAddress, address thisMAPPorGatewayOperatorAddress, address thisTreasuryAddress, uint8 thisTreasuryIsSender, uint256 thisExpirationTime) public {    \\n       MAPPorGatewayQNTAddress = thisMAPPorGatewayQNTAddress;\\n       MAPPorGatewayOperatorAddress = thisMAPPorGatewayOperatorAddress;\\n       t = TreasuryBase(thisTreasuryAddress);\\n       treasuryIsSender = thisTreasuryIsSender;\\n       expiration = thisExpirationTime; \\n    }\\n    \\n\\n    /**\\n     * The receiver of the payment channel can claim a QNT payment from it, \\n     * if the receiver can produce a valid message from the sender authorising him to do so \\n     * @param tokenAmount - the amount to claim\\n     * @param timeout - the timeout for the gateway to respond by to the last function request \\n     * @param disputeTimeout - the timeout for any dispute on the last function call\\n     * @param signature - the signed message (which must include the above variables)\\n     * @param refund - any refund to the sender of the channel?\\n     */\\n     function claimQNTPayment(uint256 tokenAmount, uint256 timeout, uint256 disputeTimeout, bytes calldata signature, uint256 refund) external {\\n        //can be invoked by anyone who has the signed off-chain message in their possession\\n        //but only the receiver\\u0027s operator address can refund the channel\\n        require(refund \\u003c tokenAmount,\\\"Refund amount cannot cause an underflow\\\");\\n        if (msg.sender != receiverAddress(true)){\\n            require(refund == 0, \\\"Only the receiver can give refund the channel\\\");\\n        }\\n        require(now \\u003c expiration, \\\"This function must be called before the channel times out\\\");\\n        // this recreates the message that was signed on the client, by the sender\\u0027s operator address -\\u003e sent to the receiver\\u0027s QNTAddress\\n        //address(this) is included for an additional replay attack protection\\n        bytes32 message = prefixed(keccak256(abi.encodePacked(receiverAddress(false), tokenAmount, currentNonce, timeout, disputeTimeout, address(this)))); \\n        if(recoverSigner(message, signature) != senderAddress(true)){\\n            revert(\\\"Signed message does not match parameters passed in\\\");\\n        }\\n        // update the nonce so no replay attacks can occur\\n        currentNonce += 1;\\n        // transfer the QNT\\n        // (it is up to the sender and/or receiver to check off-chain if the payment channel does not have enough value)\\n        // the receiver is allowed to refund the sender here if he chooses to take less than the off-chain signed for amount\\n        QNTContract.transfer(receiverAddress(false), tokenAmount-refund); \\n        // emit event\\n        emit QNTPaymentClaimed(tokenAmount,QNTContract.balanceOf(address(this)));\\n    }\\n\\n    /**\\n     * Increases the expiry time of the channel\\n     * @param newExpirationTime - the new expiration time\\n     */\\n    function updateExpirationTime(uint256 newExpirationTime) external {\\n        require(msg.sender == senderAddress(true), \\\"Only the senders operator can increase the expiration time\\\");\\n        require(expiration \\u003c newExpirationTime, \\\"You must increase the expiration time\\\");\\n        expiration = newExpirationTime;\\n        // emit event\\n        emit expirationChanged(newExpirationTime);\\n\\n    }\\n\\n    /**\\n     * Allows the sender to reclaim QNT from the channel, if this channel has expired\\n     */\\n    function reclaimQNT(uint256 tokenAmount) external {\\n      require(msg.sender == senderAddress(true), \\\"Only the senders operator can reclaim the QNT\\\");\\n      require(now \\u003e= expiration, \\\"The channel must have expired\\\");\\n        //transfer required amount\\n        QNTContract.transfer(senderAddress(false), tokenAmount);\\n        // Emit event\\n        emit QNTReclaimed(tokenAmount);\\n    }\\n\\n    /**\\n     * Finds the signer of a message\\n     * @param message - the message\\n     * @param sig - the signed bytes\\n     * @return - the address of the signer\\n     */\\n    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {\\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\\n        return ecrecover(message, v, r, s);\\n    }\\n    \\n    /**\\n     * Finds the v, r and s value of the signature\\n     * @param sig - the signed bytes\\n     * @return - the v, r and s values\\n     */\\n    function splitSignature(bytes memory sig) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        require(sig.length == 65);\\n        assembly {\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n        return (v, r, s);\\n    }\\n\\n    /**\\n     * builds a prefixed hash to mimic the behavior of eth_sign.\\n     * @param hash - the hash of the message\\n     * @return - hash of the message mimicing the signing\\n     */\\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * Reads the receiver addresses of this payment channel \\n     * @param operatorAddress - should the operator address be returned (true) or the QNTAddress (false)\\n     * @return - the chosen receiver address\\n     */       \\n    function receiverAddress(bool operatorAddress) public view returns (address) {\\n        if (treasuryIsSender == 0){\\n            //note that this code allows the treasury\\u0027s current operator and QNT address to be connected to the channel\\n            if (operatorAddress == true){\\n                return t.operatorAddress();\\n            } else {\\n                return t.QNTAddress();\\n            }\\n        } else {\\n            if (operatorAddress == true){\\n                return MAPPorGatewayOperatorAddress;                \\n            } else {\\n                return MAPPorGatewayQNTAddress;\\n            }\\n        }\\n    }\\n    \\n    /**\\n     * Reads the sender addresses of this payment channel \\n     * @param operatorAddress - should the operator address be returned (true) or the QNTAddress (false)\\n     * @return - the chosen sender address\\n     */        \\n    function senderAddress(bool operatorAddress) public view returns (address) {\\n        if (treasuryIsSender == 0){\\n            if (operatorAddress == true){\\n                return MAPPorGatewayOperatorAddress;                \\n            } else {\\n                return MAPPorGatewayQNTAddress;\\n            }\\n        } else {\\n            //note that this code allows the treasury\\u0027s current operator and QNT address to be connected to the channel\\n            if (operatorAddress == true){\\n                return t.operatorAddress();\\n            } else {\\n                return t.QNTAddress();\\n            }\\n        }\\n    }\\n    \\n    /**\\n     * Reads the current QNT balance of this contract by checking the linked contract\\n     * @return - the QNT balance\\n     */\\n    function readQNTBalance() public view returns (uint256) {\\n        return QNTContract.balanceOf(address(this));\\n    }\\n    \\n    /**\\n     * Reads the linked treasury contract address\\n     * @return - the treasury contract\\n     */       \\n    function treasuryAddress() public view returns (address) {\\n        return address(t);\\n    }\\n    \\n}\\n\\n/**\\n * @author Quant Network\\n * @title Allows a mapp or gateway OVL Network staked deposit to be held in escrow to either be returned or slashed according to the verification rules\\n */\\ncontract EscrowedDeposit {\\n\\n    // @return - the connected payment channel\\n    PaymentChannel pc;\\n    // The QNT address of the MAPP or Gateway who added the deposit\\n    address public MAPPorGatewayQNTAddress;\\n    // The operator address that can trigger functions of this channel on behalf of the MAPP or Gateway\\n    address public MAPPorGatewayOperatorAddress;\\n    // the linked treasury contract\\n    TreasuryBase t;\\n    // Hardcoded link to the QNT contract:\\n    ERC20Interface private constant QNTContract = ERC20Interface(0x19Bc592A0E1BAb3AFFB1A8746D8454743EE6E838);\\n\\n    // The event fired when the deposit is deducted:\\n    event depositDeducted(uint256 claimedQNT, uint256 remainingQNT, address ruleAddress);\\n    // The event fired when the deposit is returned:\\n    event depositReturned(uint256 returnedQNT);\\n\\n    /**\\n    * Deploys the contract and initialises the variables\\n    * @param thisMAPPorGatewayQNTAddress - the QNT address of the MAPP or gateway in this escrow\\n    * @param thisMAPPorGatewayOperatorAddress - the operator address of the MAPP or gateway in this escrow\\n    * @param thisTreasuryAddress - the address of the treasury smart contract\\n    * @param thisChannelAddress - the corresponding payment channel\\n    */ \\n    constructor(address thisMAPPorGatewayQNTAddress, address thisMAPPorGatewayOperatorAddress, address thisTreasuryAddress, address thisChannelAddress) public {    \\n       MAPPorGatewayQNTAddress = thisMAPPorGatewayQNTAddress;\\n       MAPPorGatewayOperatorAddress = thisMAPPorGatewayOperatorAddress;\\n       t = TreasuryBase(thisTreasuryAddress);\\n       pc = PaymentChannel(thisChannelAddress);\\n    }\\n    \\n    /**\\n     * The rule list contract can deduct QNT from this escrow and send it to the receiver (without closing the escrow)\\n     * @param tokenAmount - the amount to deduct\\n     * @param ruleAddress - the contract address detailing the specific rule the sender has broken\\n     */\\n    function deductDeposit(uint256 tokenAmount, address ruleAddress) external {\\n        address ruleList = t.treasurysRuleList();\\n        require(msg.sender == ruleList, \\\"This function can only be called by the associated rule list contract\\\");\\n        require(now \\u003e= expiration(), \\\"The channel must have expired\\\");\\n        // Transfer the escrowed QNT:\\n        uint256 startingBalance = readQNTBalance();\\n        if (tokenAmount \\u003e startingBalance){ \\n            //transfer as much as possible:\\n            QNTContract.transfer(t.QNTAddress(), startingBalance);  \\n            //emits event\\n            emit depositDeducted(startingBalance,0,ruleAddress);\\n        } else {\\n            //transfer required amount\\n            QNTContract.transfer(t.QNTAddress(), tokenAmount);     \\n            //emits event\\n            emit depositDeducted(tokenAmount,readQNTBalance(),ruleAddress); \\n        }\\n    }\\n\\n    /**\\n     * After the expiration time, the sender of this deposit can withdraw it through this function\\n     */\\n    function WithdrawDeposit(uint256 tokenAmount) external {\\n      require(msg.sender == MAPPorGatewayOperatorAddress, \\\"Can only be called by the MAPP/Gateway operator address after expiry\\\");\\n        require(now \\u003e= expiration(), \\\"Can only be called by the MAPP/Gateway operator address after expiry\\\");\\n       //transfer required amount\\n       QNTContract.transfer(MAPPorGatewayQNTAddress, tokenAmount);\\n       // Emit event\\n       emit depositReturned(tokenAmount);\\n    }\\n\\n    /**\\n     * Reads the current QNT balance of this contract by checking the linked ERC20 contract\\n     * @return - the QNT balance\\n     */\\n    function readQNTBalance() public view returns (uint256) {\\n        return QNTContract.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * Reads the current expiration time of this contract by checking the linked payment channel contract\\n     * @return - the expiration\\n     */\\n    function expiration() public view returns (uint256){\\n        return pc.expiration();\\n    }\\n    \\n\\n    /**\\n     * Reads the linked treasury contract address\\n     * @return - the treasury contract\\n     */       \\n    function treasuryAddress() public view returns (address) {\\n        return address(t);\\n    }\\n    \\n    /**\\n     * Reads the corresponding payment channel address\\n     * @return - the payment channel contract\\n     */       \\n    function paymentChannelAddress() public view returns (address) {\\n        return address(pc);\\n    }\\n    \\n}\\n\"},\"TreasuryFactoryBase.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title FactoryAbstract\\n * @dev Sets the main variables of a Treasury Factory contract and allows other contracts to easily interface with a Treasury Factory contract without knowing the whole code.\\n */\\ncontract FactoryBase is UpgradeableProxy {\\n    \\n    // stores the mapping of MAPP (multi-chain app) -\\u003e treasury payment channels\\n    bytes constant private mappChannels1 = \\u00271.mappChannels\\u0027;\\n    // stores the mapping of MAPP -\\u003e escrowed deposits contracts\\n    bytes constant private mappDeposits1 = \\u00271.mappDeposits\\u0027;\\n    //  stores the number of registered gateways\\n    bytes constant private mappCount1 = \\u00271.mappCount\\u0027;\\n    // stores the mapping of treasury -\\u003e gateway payment channels\\n    bytes constant private gatewayChannels1 = \\u00271.gatewayChannels\\u0027;\\n    //  stores the mapping of gateway -\\u003e escrowed deposits contracts\\n    bytes constant private gatewayDeposits1 = \\u00271.gatewayDeposits\\u0027;\\n    //  stores the number of registered gateways\\n    bytes constant private gatewayCount1 = \\u00271.gatewayCount\\u0027;\\n    \\n    /**\\n     * sets the payment channel for this mapp (multi-chain app)\\n     */\\n    function mappChannel(address mappOperator, address channel) internal {\\n        addressStorage[keccak256(abi.encodePacked(mappChannels1,mappOperator))] = channel;\\n    }\\n    \\n    /**\\n     * sets the escrowed deposit contract for this mapp\\n     */\\n    function mappDeposit(address mappOperator, address depositContract) internal {\\n        addressStorage[keccak256(abi.encodePacked(mappDeposits1,mappOperator))] = depositContract;\\n    }\\n    \\n    /**\\n     * sets the number of gateways\\n     */\\n    function mappCount(uint32 count) internal {\\n        uint32Storage[keccak256(abi.encodePacked(mappCount1))] = count;\\n    }\\n    \\n    /**\\n     * sets the payment channel for this gateway\\n     */\\n    function gatewayChannel(address gatewayOperator, address channel) internal {\\n        addressStorage[keccak256(abi.encodePacked(gatewayChannels1,gatewayOperator))] = channel;\\n    }\\n    \\n    /**\\n     * sets the escrowed deposit contract for this gateway\\n     */\\n    function gatewayDeposit(address gatewayOperator, address deposit) internal {\\n        addressStorage[keccak256(abi.encodePacked(gatewayDeposits1,gatewayOperator))] =  deposit;\\n    }\\n    \\n    /**\\n     * sets the number of gateways\\n     */\\n    function gatewayCount(uint32 count) internal {\\n        uint32Storage[keccak256(abi.encodePacked(gatewayCount1))] =  count;\\n    }\\n\\n    /**\\n     * @return - the payment channel for this mapp (multi-chain app)\\n     */\\n    function mappChannel(address mappOperator) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(mappChannels1,mappOperator))];\\n    }\\n    \\n    /**\\n     * @return - the escrowed deposit for this mapp (multi-chain app)\\n     */\\n    function mappDeposit(address mappOperator) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(mappDeposits1,mappOperator))];\\n    }\\n    \\n    /**\\n     * @return - the number of mapps\\n     */\\n    function mappCount() public view returns (uint32) {\\n        return uint32Storage[keccak256(abi.encodePacked(mappCount1))];\\n    }\\n    \\n    /**\\n     * @return - the payment channel for this gateway\\n     */\\n    function gatewayChannel(address gatewayOperator) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(gatewayChannels1,gatewayOperator))];\\n    }\\n    \\n    /**\\n     * @return - the escrowed deposit for this gateway\\n     */\\n    function gatewayDeposit(address gatewayOperator) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(gatewayDeposits1,gatewayOperator))];\\n    }\\n    \\n    /**\\n     * @return - the number of gateways\\n     */\\n    function gatewayCount() public view returns (uint32) {\\n        return uint32Storage[keccak256(abi.encodePacked(gatewayCount1))];\\n    }\\n    \\n}\\n\\n/**\\n * @author Quant Network\\n * @title Allows contracts to easily interface with an EscrowedDeposit contract without knowing the whole code\\n */\\ncontract EscrowedDepositAbstract {\\n    \\n    \\n    /**\\n     * The rule list contract can deduct QNT from this escrow and send it to the receiver (without closing the escrow)\\n     * @param tokenAmount - the amount to deduct\\n     * @param ruleAddress - the contract address detailing the specific rule that has been broken\\n     */\\n    function deductDeposit(uint256 tokenAmount, address ruleAddress) external;\\n\\n}\"},\"UpgradeableProxy.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./EternalStorageData.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title UpgradeableProxy\\n * @dev This contract allows the proxy to be upgradeable and owned\\n */\\ncontract UpgradeableProxy is EternalStorage {\\n    \\n    /**\\n   * Sets the admin of the proxy. Only the admin address can change this\\n   */\\n  function setAdmin() external {\\n      require(msg.sender ==admin(), \\u0027only admin can call this function\\u0027);\\n      uint256 sbTime = uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)];\\n      require(now \\u003e sbTime, \\\"this speed bump cannot be used yet\\\");\\n        require(sbTime \\u003e 0, \\\"use after time cannot be 0\\\");\\n      //change storage\\n      addressStorage[keccak256(\\u0027proxy.admin\\u0027)] = addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)];\\n      //remove speed bump\\n       addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)] = address(0);\\n  }\\n  \\n    /**\\n   * Sets the implementation of the proxy. Only the admin address can upgrade the smart contract logic\\n   */\\n  function setImplementation() external {\\n      require(msg.sender ==admin(), \\u0027only admin can call this function\\u0027);\\n      uint256 sbTime = uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)];\\n      require(now \\u003e sbTime, \\\"this speed bump cannot be used yet\\\");\\n      require(sbTime \\u003e 0, \\\"use after time cannot be 0\\\");\\n      addressStorage[keccak256(\\u0027proxy.implementation\\u0027)] = addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)]; \\n      addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)] = address(0); \\n  }\\n  \\n    /**\\n   * Adds a speed bump to change the admin or implementation. Only the admin address can change this\\n   */\\n  function changeProxyVariables(address nextAdmin, address nextImplementation) external {\\n      require(msg.sender == admin(), \\u0027only admin can call this function\\u0027);\\n        addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)] = nextAdmin;\\n        addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)] = nextImplementation;\\n        //note that admin and implementation functions are separate above to align with more upgradeability patterns\\n        uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)] = now + (speedBumpHours()*1 hours);\\n  }\\n\\n   /**\\n   * sets the contract as initialised\\n   */ \\n  function initializeNow() internal {\\n      boolStorage[keccak256(\\u0027proxy.initialized\\u0027)] = true;    \\n  }\\n  \\n    /**\\n    * set the speed bump time of this contract\\n    */        \\n    function speedBumpHours(uint16 newSpeedBumpHours) internal {\\n        uint16Storage[keccak256(\\u0027proxy.speedBumpHours\\u0027)] = newSpeedBumpHours;\\n    }\\n  \\n  /**\\n   * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n   */\\n  function admin() public view returns (address);\\n \\n  /**\\n   * @return - the address of the current smart contract logic\\n   */ \\n  function implementation() public view returns (address) {\\n      return addressStorage[keccak256(\\u0027proxy.implementation\\u0027)];    \\n  }\\n  \\n  /**\\n   * @return - whether the smart contract has  been initialized (true) or not (false)\\n   */ \\n  function initialized() public view returns (bool) {\\n      return boolStorage[keccak256(\\u0027proxy.initialized\\u0027)];    \\n  }\\n  \\n    /**\\n    * @return - the number of hours wait time for any critical update\\n    */        \\n    function speedBumpHours() public view returns (uint16);\\n  \\n    \\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"gateway\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStakeholderQNTAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStakeholderOperatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"QNTforChannel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"QNTforDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"}],\"name\":\"addedNewStakeholder\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"gateway\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"newStakeholderQNTAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newStakeholderOperatorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"QNTForPaymentChannel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"QNTForDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"}],\"name\":\"addNew\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nextImplementation\",\"type\":\"address\"}],\"name\":\"changeProxyVariables\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"gatewayOperator\",\"type\":\"address\"}],\"name\":\"gatewayChannel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gatewayCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"gatewayOperator\",\"type\":\"address\"}],\"name\":\"gatewayDeposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"linkedTreasuryContract\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"mappOperator\",\"type\":\"address\"}],\"name\":\"mappChannel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mappCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"mappOperator\",\"type\":\"address\"}],\"name\":\"mappDeposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"speedBumpHours\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TreasuryFactory","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://657790bf9f2b0cda42ffc915c86b631b193f3f91a18cb7d40f4695baa4b3402d"}]}