{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.12;\r\n\r\n\r\ninterface DharmaDaiExchangerInterface {\r\n  event Deposit(address indexed account, uint256 tokensReceived, uint256 daiSupplied, uint256 dDaiSupplied);\r\n  event Withdraw(address indexed account, uint256 tokensSupplied, uint256 daiReceived, uint256 dDaiReceived);\r\n\r\n  function deposit(uint256 dai, uint256 dDai) external returns (uint256 tokensMinted);\r\n  function withdraw(uint256 tokensToBurn) external returns (uint256 dai, uint256 dDai);\r\n  function mintTo(address account, uint256 daiToSupply) external returns (uint256 dDaiMinted);\r\n  function redeemUnderlyingTo(address account, uint256 daiToReceive) external returns (uint256 dDaiBurned);\r\n  \r\n  function name() external pure returns (string memory);\r\n  function symbol() external pure returns (string memory);\r\n  function decimals() external pure returns (uint8);\r\n}\r\n\r\n\r\ninterface DTokenInterface {\r\n  function mint(uint256 underlyingToSupply) external returns (uint256 dTokensMinted);\r\n  function redeemUnderlying(uint256 underlyingToReceive) external returns (uint256 dTokensBurned);\r\n  function transfer(address recipient, uint256 dTokenAmount) external returns (bool ok);\r\n  function transferFrom(address sender, address recipient, uint256 dTokenAmount) external returns (bool ok);\r\n  \r\n  function exchangeRateCurrent() external view returns (uint256 dTokenExchangeRate);\r\n  function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool ok);\r\n  function approve(address spender, uint256 amount) external returns (bool ok);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool ok);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 is ERC20Interface {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) external view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount, \"ERC20: burn amount exceeds total supply\");\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\n\r\n/// @author 0age\r\ncontract DharmaDaiExchanger is DharmaDaiExchangerInterface, ERC20 {\r\n  DTokenInterface private _DDAI = DTokenInterface(\r\n    0x00000000001876eB1444c986fD502e618c587430\r\n  );\r\n  \r\n  ERC20Interface private _DAI = ERC20Interface(\r\n    0x6B175474E89094C44Da98b954EedeAC495271d0F\r\n  );\r\n  \r\n  constructor() public {\r\n    // Approve Dharma Dai to move Dai on behalf of this contract to support minting.\r\n    require(\r\n      _DAI.approve(address(_DDAI), type(uint256).max),\r\n      \"DharmaDaiExchanger: Dai approval for Dharma Dai failed.\"\r\n    );\r\n\r\n    // Ensure that LP token balance is non-zero — at least 1 Dai must be \"donated\" as well.\r\n    _mint(address(this), 1e18);\r\n    emit Deposit(address(this), 1e18, 1e18, 0);\r\n  }\r\n\r\n  /**\r\n   * @notice Supply a specified Dai and/or Dharma Dai amount and receive back\r\n   * liquidity provider tokens in exchange. Approval must be given to this\r\n   * contract before calling this function.\r\n   * @param dai uint256 The amount of Dai to supply.\r\n   * @param dDai uint256 The amount of Dharma Dai to supply.\r\n   * @return tokensReceived The amount of LP tokens received.\r\n   */\r\n  function deposit(uint256 dai, uint256 dDai) external override returns (uint256 tokensReceived) {\r\n    require(dai > 0 || dDai > 0, \"DharmaDaiExchanger: No funds specified to deposit.\");\r\n    \r\n    // Get the current Dai <> dDai exchange rate.\r\n    uint256 exchangeRate = _DDAI.exchangeRateCurrent();\r\n\r\n    // Determine Dai-equivalent value of funds currently in the pool (rounded up).\r\n    uint256 originalLiquidityValue = _getCurrentLiquidityValue(exchangeRate, true);\r\n    require(\r\n      originalLiquidityValue >= 1e18,\r\n      \"DharmaDaiExchanger: Must seed contract with at least 1 Dai before depositing.\"\r\n    );\r\n    \r\n    // Transfer in supplied dai & dDai amounts.\r\n    if (dai > 0) {\r\n      require(\r\n        _DAI.transferFrom(msg.sender, address(this), dai),\r\n        \"DharmaDaiExchanger: Dai transfer in failed — ensure allowance is correctly set.\"\r\n      );\r\n    }\r\n\r\n    if (dDai > 0) {\r\n      require(\r\n        _DDAI.transferFrom(msg.sender, address(this), dDai),\r\n        \"DharmaDaiExchanger: Dharma Dai transfer in failed — ensure allowance is correctly set.\"\r\n      );\r\n    }\r\n    \r\n    // Determine the new Dai-equivalent liquidity value (rounded down).\r\n    uint256 newLiquidityValue = _getCurrentLiquidityValue(exchangeRate, false);\r\n    require(\r\n      newLiquidityValue > originalLiquidityValue,\r\n      \"DharmaDaiExchanger: Supplied funds did not sufficiently increase liquidity value.\"\r\n    );\r\n\r\n    // Determine LP tokens to mint by applying liquidity value ratio to current supply.\r\n    uint256 originalLPTokens = totalSupply();\r\n    uint256 newLPTokens = originalLPTokens.mul(newLiquidityValue) / originalLiquidityValue;\r\n    require(\r\n      newLPTokens > originalLPTokens,\r\n      \"DharmaDaiExchanger: Supplied funds are insufficient to mint LP tokens.\"\r\n    );\r\n    tokensReceived = newLPTokens - originalLPTokens;\r\n    \r\n    // Mint the LP tokens.\r\n    _mint(msg.sender, tokensReceived);\r\n    \r\n    emit Deposit(msg.sender, tokensReceived, dai, dDai);\r\n  }\r\n\r\n  /**\r\n   * @notice Supply a specified number of liquidity provider tokens and\r\n   * get back the proportion of Dai and/or Dharma Dai tokens currently held\r\n   * by this contract in exchange.\r\n   * @param tokensToSupply The amount of LP tokens to supply.\r\n   * @return dai uint256 The amount of Dai received.\r\n   * @return dDai uint256 The amount of Dharma Dai received.\r\n   */\r\n  function withdraw(uint256 tokensToSupply) external override returns (uint256 dai, uint256 dDai) {\r\n    require(tokensToSupply > 0, \"DharmaDaiExchanger: No funds specified to withdraw.\");\r\n    \r\n    // Get the total supply, as well as current Dai & dDai balances.\r\n    uint256 originalLPTokens = totalSupply();\r\n    uint256 daiBalance = _DAI.balanceOf(address(this));\r\n    uint256 dDaiBalance = _DDAI.balanceOf(address(this));\r\n \r\n     // Apply LP token ratio to Dai & dDai balances to determine amount to transfer out.\r\n    dai = daiBalance.mul(tokensToSupply) / originalLPTokens;\r\n    dDai = dDaiBalance.mul(tokensToSupply) / originalLPTokens;\r\n    require(\r\n      dai.add(dDai) > 0,\r\n      \"DharmaDaiExchanger: Supplied tokens are insufficient to withdraw liquidity.\"\r\n    );\r\n    \r\n    // Burn the LP tokens.\r\n    _burn(msg.sender, tokensToSupply);\r\n    \r\n    // Transfer out the proportion of Dai & dDai associated with the burned tokens.\r\n    if (dai > 0) {\r\n      require(\r\n        _DAI.transfer(msg.sender, dai),\r\n        \"DharmaDaiExchanger: Dai transfer out failed.\"\r\n      );\r\n    }\r\n\r\n    if (dDai > 0) {\r\n      require(\r\n        _DDAI.transfer(msg.sender, dDai),\r\n        \"DharmaDaiExchanger: Dharma Dai transfer out failed.\"\r\n      );\r\n    }\r\n    \r\n    emit Withdraw(msg.sender, tokensToSupply, dai, dDai);\r\n  }\r\n\r\n  /**\r\n   * @notice Supply a specified amount of Dai and receive Dharma Dai to\r\n   * the specified account in exchange. Dai approval must be given to\r\n   * this contract before calling this function.\r\n   * @param account The recipient of the minted Dharma Dai.\r\n   * @param daiToSupply uint256 The amount of Dai to supply.\r\n   * @return dDaiMinted uint256 The amount of Dharma Dai received.\r\n   */\r\n  function mintTo(address account, uint256 daiToSupply) external override returns (uint256 dDaiMinted) {\r\n    // Get the current Dai <> dDai exchange rate.\r\n    uint256 exchangeRate = _DDAI.exchangeRateCurrent();\r\n    \r\n    // Get the dDai to mint in exchange for the supplied Dai (round down).\r\n    dDaiMinted = _fromUnderlying(daiToSupply, exchangeRate, false);\r\n    require(\r\n      dDaiMinted > 0,\r\n      \"DharmaDaiExchanger: Supplied Dai is insufficient to mint Dharma Dai.\"\r\n    );\r\n      \r\n    // Get the current dDai balance.\r\n    uint256 dDaiBalance = _DDAI.balanceOf(address(this));\r\n    \r\n    // Transfer in Dai to supply.\r\n    require(\r\n      _DAI.transferFrom(msg.sender, address(this), daiToSupply),\r\n      \"DharmaDaiExchanger: Dai transfer in failed — ensure allowance is correctly set.\"\r\n    );\r\n    \r\n    // Only perform a mint if insufficient dDai is currently available.\r\n    if (dDaiBalance < dDaiMinted) {\r\n      // Provide enough Dai to leave equal Dai and dDai value after transfer.\r\n      uint256 daiBalance = _DAI.balanceOf(address(this));\r\n      uint256 dDaiBalanceInDai = _toUnderlying(dDaiBalance, exchangeRate, false);\r\n      uint256 daiToSupplyInBatch = (daiBalance.add(daiToSupply)).sub(dDaiBalanceInDai) / 2;\r\n      _DDAI.mint(daiToSupplyInBatch);\r\n    }\r\n\r\n    // Transfer the dDai to the specified recipient.\r\n    require(\r\n      _DDAI.transfer(account, dDaiMinted),\r\n      \"DharmaDaiExchanger: Dharma Dai transfer out failed.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Supply a specified amount of Dharma Dai (denominated in Dai)\r\n   * and receive Dai to the specified account in exchange. Dharma Dai\r\n   * approval must be given to this contract before calling this function.\r\n   * @param account The recipient of the received Dai.\r\n   * @param daiToReceive uint256 The amount of Dai to receive back in\r\n   * exchange for supplied Dharma Dai.\r\n   * @return dDaiBurned uint256 The amount of Dharma Dai redeemed.\r\n   */\r\n  function redeemUnderlyingTo(address account, uint256 daiToReceive) external override returns (uint256 dDaiBurned) {\r\n    // Get the current Dai <> dDai exchange rate.\r\n    uint256 exchangeRate = _DDAI.exchangeRateCurrent();\r\n    \r\n    // Get the dDai to burn in exchange for the received Dai (round up).\r\n    dDaiBurned = _fromUnderlying(daiToReceive, exchangeRate, true);\r\n    require(\r\n      dDaiBurned > 0,\r\n      \"DharmaDaiExchanger: Dai amount to receive is insufficient to redeem Dharma Dai.\"\r\n    );\r\n\r\n    // Get the current Dai balance.\r\n    uint256 daiBalance = _DAI.balanceOf(address(this));\r\n\r\n    // Transfer in required dDai to burn.\r\n    require(\r\n      _DDAI.transferFrom(msg.sender, address(this), dDaiBurned),\r\n      \"DharmaDaiExchanger: Dharma Dai transfer in failed — ensure allowance is correctly set.\"\r\n    );\r\n\r\n    // Only perform a redeem if insufficient Dai is currently available.\r\n    if (daiBalance < daiToReceive) {\r\n      // Provide enough Dai to leave equal Dai and dDai value after transfer.\r\n      uint256 dDaiBalance = _DDAI.balanceOf(address(this));\r\n      uint256 dDaiBalanceInDai = _toUnderlying(dDaiBalance, exchangeRate, false);\r\n      uint256 daiToReceiveInBatch = (dDaiBalanceInDai.add(daiToReceive)).sub(daiBalance) / 2;\r\n      _DDAI.redeemUnderlying(daiToReceiveInBatch);\r\n    }\r\n\r\n    // Transfer the Dai to the specified recipient.\r\n    require(\r\n      _DAI.transfer(account, daiToReceive),\r\n      \"DharmaDaiExchanger: Dai transfer out failed.\"\r\n    );\r\n  }\r\n\r\n  function name() external pure override returns (string memory) {\r\n    return \"Dai <> Dharma Dai Exchanger (Liquidity Provider token)\";\r\n  }\r\n\r\n  function symbol() external pure override returns (string memory) {\r\n    return \"Dai-dDai-LP\";\r\n  }\r\n\r\n  function decimals() external pure override returns (uint8) {\r\n    return 18;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to get the the current combined value of\r\n   * Dai and Dharma Dai held by this contract, denominated in Dai.\r\n   * @param exchangeRate uint256 The exchange rate (multiplied by 10^18).\r\n   * @param roundUp bool Whether the final amount should be rounded up - it will\r\n   * instead be truncated (rounded down) if this value is false.\r\n   * @return totalValueInDai The combined value in Dai held by this contract.\r\n   */  \r\n  function _getCurrentLiquidityValue(uint256 exchangeRate, bool roundUp) internal view returns (uint256 totalValueInDai) {\r\n    uint256 daiBalance = _DAI.balanceOf(address(this));\r\n    uint256 dDaiBalance = _DDAI.balanceOf(address(this));\r\n    uint256 dDaiBalanceInDai = _toUnderlying(dDaiBalance, exchangeRate, roundUp);\r\n    totalValueInDai = daiBalance.add(dDaiBalanceInDai);\r\n  }\r\n \r\n  /**\r\n   * @notice Internal pure function to convert an underlying amount to a dToken\r\n   * amount using an exchange rate and fixed-point arithmetic.\r\n   * @param underlying uint256 The underlying amount to convert.\r\n   * @param exchangeRate uint256 The exchange rate (multiplied by 10^18).\r\n   * @param roundUp bool Whether the final amount should be rounded up - it will\r\n   * instead be truncated (rounded down) if this value is false.\r\n   * @return amount The dToken amount.\r\n   */\r\n  function _fromUnderlying(\r\n    uint256 underlying, uint256 exchangeRate, bool roundUp\r\n  ) internal pure returns (uint256 amount) {\r\n    if (roundUp) {\r\n      amount = (\r\n        (underlying.mul(1e18)).add(exchangeRate.sub(1))\r\n      ).div(exchangeRate);\r\n    } else {\r\n      amount = (underlying.mul(1e18)).div(exchangeRate);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to convert a dToken amount to the\r\n   * underlying amount using an exchange rate and fixed-point arithmetic.\r\n   * @param amount uint256 The dToken amount to convert.\r\n   * @param exchangeRate uint256 The exchange rate (multiplied by 10^18).\r\n   * @param roundUp bool Whether the final amount should be rounded up - it will\r\n   * instead be truncated (rounded down) if this value is false.\r\n   * @return underlying The underlying amount.\r\n   */\r\n  function _toUnderlying(\r\n    uint256 amount, uint256 exchangeRate, bool roundUp\r\n  ) internal pure returns (uint256 underlying) {\r\n    if (roundUp) {\r\n      underlying = (\r\n        (amount.mul(exchangeRate).add(999999999999999999)\r\n      ) / 1e18);\r\n    } else {\r\n      underlying = amount.mul(exchangeRate) / 1e18;\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiSupplied\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dDaiSupplied\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSupplied\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dDaiReceived\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dDai\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensReceived\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daiToSupply\",\"type\":\"uint256\"}],\"name\":\"mintTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dDaiMinted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daiToReceive\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlyingTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dDaiBurned\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensToSupply\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dDai\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DharmaDaiExchanger","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1b5daa15a2ff18c44a52dfe2c086dbde88025955af86aabce3e3c0f74fdfa3d7"}]}