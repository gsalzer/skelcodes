{"status":"1","message":"OK","result":[{"SourceCode":"# @title KULAP Maker Pool V1\r\n# @notice Source code derive from https://github.com/uniswap\r\n# @notice To remove whitelist feature, need to implement re-entrancy guard on every state change public functions\r\n# @notice To remove whitelist feature, need to handle transferFrom properly (checking success / result)\r\n\r\ncontract ERC20_2():\r\n    def balanceOf(_owner : address) -> uint256: constant\r\n    def transfer(_to : address, _value : uint256): modifying\r\n    def transferFrom(_from : address, _to : address, _value : uint256): modifying\r\n\r\nTokenPurchase: event({buyer: indexed(address), eth_sold: indexed(uint256(wei)), tokens_bought: indexed(uint256)})\r\nEthPurchase: event({buyer: indexed(address), tokens_sold: indexed(uint256), eth_bought: indexed(uint256(wei))})\r\nAddLiquidity: event({provider: indexed(address), eth_amount: indexed(uint256(wei)), token_amount: indexed(uint256)})\r\nRemoveLiquidity: event({provider: indexed(address), eth_amount: indexed(uint256(wei)), token_amount: indexed(uint256)})\r\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\r\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\r\n\r\nUpdateProtocolWallet: event({wallet: indexed(address)})\r\nCollectFee: event({ethFee: uint256(wei), token1Fee: uint256})\r\nUpdateOwner: event({owner: indexed(address)})\r\nAddLiquidityProvider: event({provider: indexed(address)})\r\nRemoveLiquidityProvider: event({provider: indexed(address)})\r\nUpdateFee: event({poolFee: indexed(uint256), protocolFee: indexed(uint256)})\r\nAddTrader: event({trader: indexed(address)})\r\nRemoveTrader: event({trader: indexed(address)})\r\nShutdown: event({eth: uint256(wei), token1: uint256})\r\nDisableShutdown: event({})\r\n\r\n# Governance\r\nowner: public(address)                            # Owner of the system\r\nproviders: public(bool[address])                  # Liquidity providers\r\nproviderCount: public(uint256)                    # Number of providers\r\npoolFee: public(uint256)                          # Total fee In bps\r\nprotocolFee: public(uint256)                      # Protocol fee In bps\r\nprotocolWallet: public(address)                   # Protocol wallet address for fee collection\r\nethFeeBalance: public(uint256(wei))               # eth fee balance\r\ntoken1FeeBalance: public(uint256)                 # Token1 fee balance\r\ntraders: public(bool[address])                    # Trader whitelist\r\ntraderCount: public(uint256)                      # Number of traders\r\nallowShutdown: public(bool)                       # Can shutdown\r\n\r\nname: public(bytes[64])                           # KULAP Maker Pool V1\r\nsymbol: public(bytes[32])                         # KMP1\r\ndecimals: public(uint256)                         # 18\r\ntotalSupply: public(uint256)                      # total number of UNI in existence\r\nbalances: uint256[address]                        # UNI balance of an address\r\nallowances: (uint256[address])[address]           # UNI allowance of one address on another\r\ntoken: ERC20_2                                    # address of the ERC20 token traded on this contract\r\n\r\n# @dev This function acts as a contract constructor which is not currently supported in contracts deployed\r\n@public\r\ndef setup(token_addr: address, _owner: address):\r\n    assert self.token == ZERO_ADDRESS and token_addr != ZERO_ADDRESS\r\n    self.token = token_addr\r\n    self.name = 'KULAP Maker Pool V1'\r\n    self.symbol = 'KMP1'\r\n    self.decimals = 18\r\n    self.owner = _owner\r\n    self.poolFee = 30\r\n    self.protocolFee = 15\r\n    self.protocolWallet = _owner\r\n    self.allowShutdown = True\r\n\r\n# @dev whitelist Liquidity Providers.\r\n# @param provider a provider to be whitelisted.\r\n@public\r\ndef addLiquidityProvider(provider: address):\r\n    assert msg.sender == self.owner and provider != ZERO_ADDRESS\r\n    assert False == self.providers[provider]\r\n    self.providers[provider] = True\r\n    self.providerCount += 1\r\n    log.AddLiquidityProvider(provider)\r\n\r\n# @dev de-whitelist Liquidity Providers.\r\n# @param provider a provider to be removed from whitelists.\r\n@public\r\ndef removeLiquidityProvider(provider: address):\r\n    assert msg.sender == self.owner and provider != ZERO_ADDRESS\r\n    assert True == self.providers[provider]\r\n    self.providers[provider] = False\r\n    self.providerCount -= 1\r\n    log.RemoveLiquidityProvider(provider)\r\n\r\n# @dev whitelist Traders.\r\n# @param trader a trader to be whitelisted.\r\n@public\r\ndef addTrader(trader: address):\r\n    assert msg.sender == self.owner and trader != ZERO_ADDRESS\r\n    assert False == self.traders[trader]\r\n    self.traders[trader] = True\r\n    self.traderCount += 1\r\n    log.AddTrader(trader)\r\n\r\n# @dev de-whitelist Traders.\r\n# @param trader a trader to be removed from whitelists.\r\n@public\r\ndef removeTrader(trader: address):\r\n    assert msg.sender == self.owner and trader != ZERO_ADDRESS\r\n    assert True == self.traders[trader]\r\n    self.traders[trader] = False\r\n    self.traderCount -= 1\r\n    log.RemoveTrader(trader)\r\n\r\n# @notice Liquidity Provider fee = _poolFee - _protocolFee.\r\n# @dev Configure system fees.\r\n# @param _poolFee a fee in bps for overall fee.\r\n# @param _protocolFee a fee in bps for protocol fee.\r\n@public\r\ndef setFee(_poolFee: uint256, _protocolFee: uint256):\r\n    assert msg.sender == self.owner\r\n    assert _poolFee <= 1000 # no more than 10%\r\n    assert _protocolFee <= 1000 # no more than 10%\r\n    assert _protocolFee <= _poolFee\r\n    self.poolFee = _poolFee\r\n    self.protocolFee = _protocolFee\r\n    log.UpdateFee(_poolFee, _protocolFee)\r\n\r\n# @dev Configure a wallet for protocol fee.\r\n# @param wallet a wallet address for receiving protocol fee.\r\n@public\r\ndef setProtocolWallet(wallet: address):\r\n    assert msg.sender == self.owner and wallet != ZERO_ADDRESS\r\n    self.protocolWallet = wallet\r\n    log.UpdateProtocolWallet(wallet)\r\n\r\n# @dev Call to collect protocol fees.\r\n@public\r\ndef collectProtocolFee():\r\n    send(self.protocolWallet, self.ethFeeBalance)\r\n    self.token.transfer(self.protocolWallet, self.token1FeeBalance)\r\n    log.CollectFee(self.ethFeeBalance, self.token1FeeBalance)\r\n    self.ethFeeBalance = 0\r\n    self.token1FeeBalance = 0\r\n\r\n# @dev Change owner address.\r\n# @param newOwner new owner address.\r\n@public\r\ndef updateOwner(newOwner: address):\r\n    assert msg.sender == self.owner and newOwner != ZERO_ADDRESS\r\n    self.owner = newOwner\r\n    log.UpdateOwner(newOwner)\r\n\r\n# @dev Call only once when system need to be shutdown.\r\n@public\r\ndef emergencyShutdown():\r\n    assert msg.sender == self.owner\r\n    assert self.allowShutdown\r\n    eth_balance: uint256(wei) = self.balance\r\n    token1_balance: uint256 = self.token.balanceOf(self)\r\n    send(msg.sender, eth_balance)\r\n    self.token.transfer(msg.sender, token1_balance)\r\n    log.Shutdown(eth_balance, token1_balance)\r\n\r\n# @dev Permanently disable shutdown feature.\r\n@public\r\ndef disableEmergencyShutdown():\r\n    assert msg.sender == self.owner\r\n    assert self.allowShutdown\r\n    self.allowShutdown = False\r\n    log.DisableShutdown()\r\n\r\n# @notice Deposit ETH and Tokens (self.token) at current ratio to mint UNI tokens.\r\n# @dev min_liquidity does nothing when total UNI supply is 0.\r\n# @param min_liquidity Minimum number of UNI sender will mint if total UNI supply is greater than 0.\r\n# @param max_tokens Maximum number of tokens deposited. Deposits max amount if total UNI supply is 0.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return The amount of UNI minted.\r\n@public\r\n@payable\r\ndef addLiquidity(min_liquidity: uint256, max_tokens: uint256, deadline: timestamp) -> uint256:\r\n    assert self.providers[msg.sender]\r\n    assert deadline > block.timestamp and (max_tokens > 0 and msg.value > 0)\r\n    total_liquidity: uint256 = self.totalSupply\r\n    if total_liquidity > 0:\r\n        assert min_liquidity > 0\r\n        eth_reserve: uint256(wei) = self.balance - msg.value - self.ethFeeBalance\r\n        token_reserve: uint256 = self.token.balanceOf(self) - self.token1FeeBalance\r\n        token_amount: uint256 = msg.value * token_reserve / eth_reserve + 1\r\n        liquidity_minted: uint256 = msg.value * total_liquidity / eth_reserve\r\n        assert max_tokens >= token_amount and liquidity_minted >= min_liquidity\r\n        self.balances[msg.sender] += liquidity_minted\r\n        self.totalSupply = total_liquidity + liquidity_minted\r\n        self.token.transferFrom(msg.sender, self, token_amount)\r\n        log.AddLiquidity(msg.sender, msg.value, token_amount)\r\n        log.Transfer(ZERO_ADDRESS, msg.sender, liquidity_minted)\r\n        return liquidity_minted\r\n    else:\r\n        assert self.token != ZERO_ADDRESS and msg.value >= 1000000000\r\n        token_amount: uint256 = max_tokens\r\n        initial_liquidity: uint256 = as_unitless_number(self.balance)\r\n        self.totalSupply = initial_liquidity\r\n        self.balances[msg.sender] = initial_liquidity\r\n        self.token.transferFrom(msg.sender, self, token_amount)\r\n        log.AddLiquidity(msg.sender, msg.value, token_amount)\r\n        log.Transfer(ZERO_ADDRESS, msg.sender, initial_liquidity)\r\n        return initial_liquidity\r\n\r\n# @dev Burn UNI tokens to withdraw ETH and Tokens at current ratio.\r\n# @param amount Amount of UNI burned.\r\n# @param min_eth Minimum ETH withdrawn.\r\n# @param min_tokens Minimum Tokens withdrawn.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return The amount of ETH and Tokens withdrawn.\r\n@public\r\ndef removeLiquidity(amount: uint256, min_eth: uint256(wei), min_tokens: uint256, deadline: timestamp) -> (uint256(wei), uint256):\r\n    assert self.providers[msg.sender]\r\n    assert (amount > 0 and deadline > block.timestamp) and (min_eth > 0 and min_tokens > 0)\r\n    total_liquidity: uint256 = self.totalSupply\r\n    assert total_liquidity > 0\r\n    eth_reserve: uint256(wei) = self.balance - self.ethFeeBalance\r\n    token_reserve: uint256 = self.token.balanceOf(self) - self.token1FeeBalance\r\n    eth_amount: uint256(wei) = amount * eth_reserve / total_liquidity\r\n    token_amount: uint256 = amount * token_reserve / total_liquidity\r\n    assert eth_amount >= min_eth and token_amount >= min_tokens\r\n    self.balances[msg.sender] -= amount\r\n    self.totalSupply = total_liquidity - amount\r\n    send(msg.sender, eth_amount)\r\n    self.token.transfer(msg.sender, token_amount)\r\n    log.RemoveLiquidity(msg.sender, eth_amount, token_amount)\r\n    log.Transfer(msg.sender, ZERO_ADDRESS, amount)\r\n    return eth_amount, token_amount\r\n\r\n# @dev Pricing function for converting between ETH and Tokens.\r\n# @param input_amount Amount of ETH or Tokens being sold.\r\n# @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\r\n# @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\r\n# @return Amount of ETH or Tokens bought.\r\n@private\r\n@constant\r\ndef getInputPrice(input_amount: uint256, input_reserve: uint256, output_reserve: uint256) -> uint256:\r\n    assert input_reserve > 0 and output_reserve > 0\r\n    input_amount_with_fee: uint256 = input_amount * (10000 - self.poolFee)\r\n    numerator: uint256 = input_amount_with_fee * output_reserve\r\n    denominator: uint256 = (input_reserve * 10000) + input_amount_with_fee\r\n    return numerator / denominator\r\n\r\n# @dev Pricing function for converting between ETH and Tokens.\r\n# @param output_amount Amount of ETH or Tokens being bought.\r\n# @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\r\n# @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\r\n# @return Amount of ETH or Tokens sold.\r\n@private\r\n@constant\r\ndef getOutputPrice(output_amount: uint256, input_reserve: uint256, output_reserve: uint256) -> uint256:\r\n    assert input_reserve > 0 and output_reserve > 0\r\n    numerator: uint256 = input_reserve * output_amount * 10000\r\n    denominator: uint256 = (output_reserve - output_amount) * (10000 - self.poolFee)\r\n    return numerator / denominator + 1\r\n\r\n@private\r\ndef accountProtocolFee(input_amount: uint256, is_base: bool):\r\n    if self.protocolFee > 0:\r\n        fee: uint256 = input_amount * self.protocolFee / 10000\r\n        if is_base:\r\n            self.ethFeeBalance += as_wei_value(fee, 'wei')\r\n        else:\r\n            self.token1FeeBalance += fee\r\n\r\n@private\r\ndef ethToTokenInput(eth_sold: uint256(wei), min_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and (eth_sold > 0 and min_tokens > 0)\r\n    eth_reserve: uint256(wei) = self.balance - eth_sold - self.ethFeeBalance\r\n    token_reserve: uint256 = self.token.balanceOf(self) - self.token1FeeBalance\r\n    tokens_bought: uint256 = self.getInputPrice(as_unitless_number(eth_sold), as_unitless_number(eth_reserve), token_reserve)\r\n    assert tokens_bought >= min_tokens\r\n    self.token.transfer(recipient, tokens_bought)\r\n    self.accountProtocolFee(as_unitless_number(eth_sold), True)\r\n    log.TokenPurchase(buyer, eth_sold, tokens_bought)\r\n    return tokens_bought\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies exact input (msg.value).\r\n# @dev User cannot specify minimum output or deadline.\r\n@public\r\n@payable\r\ndef __default__():\r\n    assert self.traders[msg.sender]\r\n    self.ethToTokenInput(msg.value, 1, block.timestamp, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies exact input (msg.value) and minimum output.\r\n# @param min_tokens Minimum Tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Tokens bought.\r\n@public\r\n@payable\r\ndef ethToTokenSwapInput(min_tokens: uint256, deadline: timestamp) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    return self.ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens and transfers Tokens to recipient.\r\n# @dev User specifies exact input (msg.value) and minimum output\r\n# @param min_tokens Minimum Tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Tokens.\r\n# @return Amount of Tokens bought.\r\n@public\r\n@payable\r\ndef ethToTokenTransferInput(min_tokens: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef ethToTokenOutput(tokens_bought: uint256, max_eth: uint256(wei), deadline: timestamp, buyer: address, recipient: address) -> uint256(wei):\r\n    assert deadline >= block.timestamp and (tokens_bought > 0 and max_eth > 0)\r\n    eth_reserve: uint256(wei) = self.balance - max_eth - self.ethFeeBalance\r\n    token_reserve: uint256 = self.token.balanceOf(self) - self.token1FeeBalance\r\n    eth_sold: uint256 = self.getOutputPrice(tokens_bought, as_unitless_number(eth_reserve), token_reserve)\r\n    # Throws if eth_sold > max_eth\r\n    eth_refund: uint256(wei) = max_eth - as_wei_value(eth_sold, 'wei')\r\n    if eth_refund > 0:\r\n        send(buyer, eth_refund)\r\n    self.token.transfer(recipient, tokens_bought)\r\n    self.accountProtocolFee(eth_sold, True)\r\n    log.TokenPurchase(buyer, as_wei_value(eth_sold, 'wei'), tokens_bought)\r\n    return as_wei_value(eth_sold, 'wei')\r\n\r\n# @notice Convert ETH to Tokens.\r\n# @dev User specifies maximum input (msg.value) and exact output.\r\n# @param tokens_bought Amount of tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of ETH sold.\r\n@public\r\n@payable\r\ndef ethToTokenSwapOutput(tokens_bought: uint256, deadline: timestamp) -> uint256(wei):\r\n    assert self.traders[msg.sender]\r\n    return self.ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert ETH to Tokens and transfers Tokens to recipient.\r\n# @dev User specifies maximum input (msg.value) and exact output.\r\n# @param tokens_bought Amount of tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Tokens.\r\n# @return Amount of ETH sold.\r\n@public\r\n@payable\r\ndef ethToTokenTransferOutput(tokens_bought: uint256, deadline: timestamp, recipient: address) -> uint256(wei):\r\n    assert self.traders[msg.sender]\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToEthInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp, buyer: address, recipient: address) -> uint256(wei):\r\n    assert deadline >= block.timestamp and (tokens_sold > 0 and min_eth > 0)\r\n    eth_reserve: uint256(wei) = self.balance - self.ethFeeBalance\r\n    token_reserve: uint256 = self.token.balanceOf(self) - self.token1FeeBalance\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(eth_reserve))\r\n    wei_bought: uint256(wei) = as_wei_value(eth_bought, 'wei')\r\n    assert wei_bought >= min_eth\r\n    send(recipient, wei_bought)\r\n    self.token.transferFrom(buyer, self, tokens_sold)\r\n    self.accountProtocolFee(tokens_sold, False)\r\n    log.EthPurchase(buyer, tokens_sold, wei_bought)\r\n    return wei_bought\r\n\r\n\r\n# @notice Convert Tokens to ETH.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_eth Minimum ETH purchased.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of ETH bought.\r\n@public\r\ndef tokenToEthSwapInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp) -> uint256(wei):\r\n    assert self.traders[msg.sender]\r\n    return self.tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Tokens to ETH and transfers ETH to recipient.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_eth Minimum ETH purchased.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @return Amount of ETH bought.\r\n@public\r\ndef tokenToEthTransferInput(tokens_sold: uint256, min_eth: uint256(wei), deadline: timestamp, recipient: address) -> uint256(wei):\r\n    assert self.traders[msg.sender]\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToEthOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and eth_bought > 0\r\n    eth_reserve: uint256(wei) = self.balance - self.ethFeeBalance\r\n    token_reserve: uint256 = self.token.balanceOf(self) - self.token1FeeBalance\r\n    tokens_sold: uint256 = self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(eth_reserve))\r\n    # tokens sold is always > 0\r\n    assert max_tokens >= tokens_sold\r\n    send(recipient, eth_bought)\r\n    self.token.transferFrom(buyer, self, tokens_sold)\r\n    self.accountProtocolFee(tokens_sold, False)\r\n    log.EthPurchase(buyer, tokens_sold, eth_bought)\r\n    return tokens_sold\r\n\r\n# @notice Convert Tokens to ETH.\r\n# @dev User specifies maximum input and exact output.\r\n# @param eth_bought Amount of ETH purchased.\r\n# @param max_tokens Maximum Tokens sold.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Tokens sold.\r\n@public\r\ndef tokenToEthSwapOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    return self.tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Tokens to ETH and transfers ETH to recipient.\r\n# @dev User specifies maximum input and exact output.\r\n# @param eth_bought Amount of ETH purchased.\r\n# @param max_tokens Maximum Tokens sold.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output ETH.\r\n# @return Amount of Tokens sold.\r\n@public\r\ndef tokenToEthTransferOutput(eth_bought: uint256(wei), max_tokens: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, recipient)\r\n\r\n# @notice Public price function for ETH to Token trades with an exact input.\r\n# @param eth_sold Amount of ETH sold.\r\n# @return Amount of Tokens that can be bought with input ETH.\r\n@public\r\n@constant\r\ndef getEthToTokenInputPrice(eth_sold: uint256(wei)) -> uint256:\r\n    assert eth_sold > 0\r\n    eth_reserve: uint256(wei) = self.balance - self.ethFeeBalance\r\n    token_reserve: uint256 = self.token.balanceOf(self) - self.token1FeeBalance\r\n    return self.getInputPrice(as_unitless_number(eth_sold), as_unitless_number(eth_reserve), token_reserve)\r\n\r\n# @notice Public price function for ETH to Token trades with an exact output.\r\n# @param tokens_bought Amount of Tokens bought.\r\n# @return Amount of ETH needed to buy output Tokens.\r\n@public\r\n@constant\r\ndef getEthToTokenOutputPrice(tokens_bought: uint256) -> uint256(wei):\r\n    assert tokens_bought > 0\r\n    eth_reserve: uint256(wei) = self.balance - self.ethFeeBalance\r\n    token_reserve: uint256 = self.token.balanceOf(self) - self.token1FeeBalance\r\n    eth_sold: uint256 = self.getOutputPrice(tokens_bought, as_unitless_number(eth_reserve), token_reserve)\r\n    return as_wei_value(eth_sold, 'wei')\r\n\r\n# @notice Public price function for Token to ETH trades with an exact input.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @return Amount of ETH that can be bought with input Tokens.\r\n@public\r\n@constant\r\ndef getTokenToEthInputPrice(tokens_sold: uint256) -> uint256(wei):\r\n    assert tokens_sold > 0\r\n    eth_reserve: uint256(wei) = self.balance - self.ethFeeBalance\r\n    token_reserve: uint256 = self.token.balanceOf(self) - self.token1FeeBalance\r\n    eth_bought: uint256 = self.getInputPrice(tokens_sold, token_reserve, as_unitless_number(eth_reserve))\r\n    return as_wei_value(eth_bought, 'wei')\r\n\r\n# @notice Public price function for Token to ETH trades with an exact output.\r\n# @param eth_bought Amount of output ETH.\r\n# @return Amount of Tokens needed to buy output ETH.\r\n@public\r\n@constant\r\ndef getTokenToEthOutputPrice(eth_bought: uint256(wei)) -> uint256:\r\n    assert eth_bought > 0\r\n    eth_reserve: uint256(wei) = self.balance - self.ethFeeBalance\r\n    token_reserve: uint256 = self.token.balanceOf(self) - self.token1FeeBalance\r\n    return self.getOutputPrice(as_unitless_number(eth_bought), token_reserve, as_unitless_number(eth_reserve))\r\n\r\n# @return Address of Token that is sold on this exchange.\r\n@public\r\n@constant\r\ndef tokenAddress() -> address(ERC20_2):\r\n    return self.token\r\n\r\n# ERC20 compatibility for exchange liquidity modified from\r\n# https://github.com/ethereum/vyper/blob/master/examples/tokens/ERC20.vy\r\n@public\r\n@constant\r\ndef balanceOf(_owner : address) -> uint256:\r\n    return self.balances[_owner]\r\n\r\n@public\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    self.balances[msg.sender] -= _value\r\n    self.balances[_to] += _value\r\n    log.Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    self.balances[_from] -= _value\r\n    self.balances[_to] += _value\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log.Transfer(_from, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log.Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n@public\r\n@constant\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    return self.allowances[_owner][_spender]","ABI":"[{\"name\":\"TokenPurchase\",\"inputs\":[{\"type\":\"address\",\"name\":\"buyer\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"eth_sold\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"tokens_bought\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"EthPurchase\",\"inputs\":[{\"type\":\"address\",\"name\":\"buyer\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"tokens_sold\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"eth_bought\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"eth_amount\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"token_amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"eth_amount\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"token_amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_to\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateProtocolWallet\",\"inputs\":[{\"type\":\"address\",\"name\":\"wallet\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CollectFee\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"ethFee\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"token1Fee\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateOwner\",\"inputs\":[{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidityProvider\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityProvider\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateFee\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"poolFee\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"protocolFee\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddTrader\",\"inputs\":[{\"type\":\"address\",\"name\":\"trader\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveTrader\",\"inputs\":[{\"type\":\"address\",\"name\":\"trader\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Shutdown\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"eth\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"token1\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"DisableShutdown\",\"inputs\":[],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"setup\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"token_addr\"},{\"type\":\"address\",\"name\":\"_owner\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":386882},{\"name\":\"addLiquidityProvider\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"provider\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":73100},{\"name\":\"removeLiquidityProvider\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"provider\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":57924},{\"name\":\"addTrader\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"trader\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":73160},{\"name\":\"removeTrader\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"trader\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":57984},{\"name\":\"setFee\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_poolFee\"},{\"type\":\"uint256\",\"name\":\"_protocolFee\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":72589},{\"name\":\"setProtocolWallet\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"wallet\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":36965},{\"name\":\"collectProtocolFee\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":80792},{\"name\":\"updateOwner\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"newOwner\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37025},{\"name\":\"emergencyShutdown\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":42381},{\"name\":\"disableEmergencyShutdown\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":21914},{\"name\":\"addLiquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"min_liquidity\"},{\"type\":\"uint256\",\"name\":\"max_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":85192},{\"name\":\"removeLiquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"},{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"amount\"},{\"type\":\"uint256\",\"name\":\"min_eth\"},{\"type\":\"uint256\",\"name\":\"min_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":118098},{\"name\":\"__default__\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":true,\"type\":\"function\"},{\"name\":\"ethToTokenSwapInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"min_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":95904},{\"name\":\"ethToTokenTransferInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"min_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":96112},{\"name\":\"ethToTokenSwapOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":133634},{\"name\":\"ethToTokenTransferOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":true,\"type\":\"function\",\"gas\":133842},{\"name\":\"tokenToEthSwapInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"},{\"type\":\"uint256\",\"name\":\"min_eth\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":130102},{\"name\":\"tokenToEthTransferInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"},{\"type\":\"uint256\",\"name\":\"min_eth\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":130311},{\"name\":\"tokenToEthSwapOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"eth_bought\"},{\"type\":\"uint256\",\"name\":\"max_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":132762},{\"name\":\"tokenToEthTransferOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"eth_bought\"},{\"type\":\"uint256\",\"name\":\"max_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":132971},{\"name\":\"getEthToTokenInputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"eth_sold\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":9103},{\"name\":\"getEthToTokenOutputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":10433},{\"name\":\"getTokenToEthInputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":9198},{\"name\":\"getTokenToEthOutputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"eth_bought\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":10458},{\"name\":\"tokenAddress\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1443},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1645},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":75034},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":110907},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":38769},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"},{\"type\":\"address\",\"name\":\"_spender\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1925},{\"name\":\"owner\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1623},{\"name\":\"providers\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1825},{\"name\":\"providerCount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1683},{\"name\":\"poolFee\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1713},{\"name\":\"protocolFee\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1743},{\"name\":\"protocolWallet\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1773},{\"name\":\"ethFeeBalance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1803},{\"name\":\"token1FeeBalance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1833},{\"name\":\"traders\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2035},{\"name\":\"traderCount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1893},{\"name\":\"allowShutdown\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1923},{\"name\":\"name\",\"outputs\":[{\"type\":\"bytes\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":12859},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"bytes\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":7744},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2013},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2043}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.1.0b4","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}