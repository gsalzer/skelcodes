{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.6;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n  function factory() external pure returns (address);\r\n\r\n  function WETH() external pure returns (address);\r\n\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    returns (\r\n      uint256 amountA,\r\n      uint256 amountB,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function addLiquidityETH(\r\n    address token,\r\n    uint256 amountTokenDesired,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    payable\r\n    returns (\r\n      uint256 amountToken,\r\n      uint256 amountETH,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  function removeLiquidityETH(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  function removeLiquidityWithPermit(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  function removeLiquidityETHWithPermit(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactTokens(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactETHForTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactETH(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactTokensForETH(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapETHForExactTokens(\r\n    uint256 amountOut,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function quote(\r\n    uint256 amountA,\r\n    uint256 reserveA,\r\n    uint256 reserveB\r\n  ) external pure returns (uint256 amountB);\r\n\r\n  function getAmountOut(\r\n    uint256 amountIn,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut\r\n  ) external pure returns (uint256 amountOut);\r\n\r\n  function getAmountIn(\r\n    uint256 amountOut,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut\r\n  ) external pure returns (uint256 amountIn);\r\n\r\n  function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n\r\n  function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountETH);\r\n\r\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountETH);\r\n\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n\r\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable;\r\n\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) private _balances;\r\n\r\n  mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  /**\r\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n   * a default value of 18.\r\n   *\r\n   * To select a different value for {decimals}, use {_setupDecimals}.\r\n   *\r\n   * All three of these values are immutable: they can only be set once during\r\n   * construction.\r\n   */\r\n  constructor(string memory name, string memory symbol) public {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = 18;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name() public view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token, usually a shorter version of the\r\n   * name.\r\n   */\r\n  function symbol() public view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of decimals used to get its user representation.\r\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n   *\r\n   * Tokens usually opt for a value of 18, imitating the relationship between\r\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n   * called.\r\n   *\r\n   * NOTE: This information is only used for _display_ purposes: it in\r\n   * no way affects any of the arithmetic of the contract, including\r\n   * {IERC20-balanceOf} and {IERC20-transfer}.\r\n   */\r\n  function decimals() public view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-totalSupply}.\r\n   */\r\n  function totalSupply() public override view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-balanceOf}.\r\n   */\r\n  function balanceOf(address account) public override view returns (uint256) {\r\n    return _balances[account];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transfer}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `recipient` cannot be the zero address.\r\n   * - the caller must have a balance of at least `amount`.\r\n   */\r\n  function transfer(address recipient, uint256 amount)\r\n    public\r\n    override\r\n    returns (bool)\r\n  {\r\n    _transfer(msg.sender, recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-allowance}.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    public\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-approve}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function approve(address spender, uint256 amount)\r\n    public\r\n    override\r\n    returns (bool)\r\n  {\r\n    _approve(msg.sender, spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transferFrom}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance. This is not\r\n   * required by the EIP. See the note at the beginning of {ERC20};\r\n   *\r\n   * Requirements:\r\n   * - `sender` and `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   * - the caller must have allowance for ``sender``'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(\r\n      sender,\r\n      msg.sender,\r\n      _allowances[sender][msg.sender].sub(\r\n        amount,\r\n        'ERC20: transfer amount exceeds allowance'\r\n      )\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function increaseAllowance(address spender, uint256 addedValue)\r\n    public\r\n    returns (bool)\r\n  {\r\n    _approve(\r\n      msg.sender,\r\n      spender,\r\n      _allowances[msg.sender][spender].add(addedValue)\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   * - `spender` must have allowance for the caller of at least\r\n   * `subtractedValue`.\r\n   */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    _approve(\r\n      msg.sender,\r\n      spender,\r\n      _allowances[msg.sender][spender].sub(\r\n        subtractedValue,\r\n        'ERC20: decreased allowance below zero'\r\n      )\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n   *\r\n   * This is internal function is equivalent to {transfer}, and can be used to\r\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `sender` cannot be the zero address.\r\n   * - `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   */\r\n  function _transfer(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(sender != address(0), 'ERC20: transfer from the zero address');\r\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\r\n    _balances[sender] = _balances[sender].sub(\r\n      amount,\r\n      'ERC20: transfer amount exceeds balance'\r\n    );\r\n    _balances[recipient] = _balances[recipient].add(amount);\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n   * the total supply.\r\n   *\r\n   * Emits a {Transfer} event with `from` set to the zero address.\r\n   *\r\n   * Requirements\r\n   *\r\n   * - `to` cannot be the zero address.\r\n   */\r\n  function _mint(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), 'ERC20: mint to the zero address');\r\n    _totalSupply = _totalSupply.add(amount);\r\n    _balances[account] = _balances[account].add(amount);\r\n    emit Transfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`, reducing the\r\n   * total supply.\r\n   *\r\n   * Emits a {Transfer} event with `to` set to the zero address.\r\n   *\r\n   * Requirements\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   * - `account` must have at least `amount` tokens.\r\n   */\r\n  function _burn(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), 'ERC20: burn from the zero address');\r\n    _balances[account] = _balances[account].sub(\r\n      amount,\r\n      'ERC20: burn amount exceeds balance'\r\n    );\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n   *\r\n   * This is internal function is equivalent to `approve`, and can be used to\r\n   * e.g. set automatic allowances for certain subsystems, etc.\r\n   *\r\n   * Emits an {Approval} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `owner` cannot be the zero address.\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function _approve(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(owner != address(0), 'ERC20: approve from the zero address');\r\n    require(spender != address(0), 'ERC20: approve to the zero address');\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20Burnable is ERC20 {\r\n  /**\r\n   * @dev Destroys `amount` tokens from the caller.\r\n   *\r\n   * See {ERC20-_burn}.\r\n   */\r\n  function burn(uint256 amount) public virtual {\r\n    _burn(msg.sender, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n   * allowance.\r\n   *\r\n   * See {ERC20-_burn} and {ERC20-allowance}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have allowance for ``accounts``'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function burnFrom(address account, uint256 amount) public virtual {\r\n    uint256 decreasedAllowance = allowance(account, msg.sender).sub(\r\n      amount,\r\n      'ERC20: burn amount exceeds allowance'\r\n    );\r\n    _approve(account, msg.sender, decreasedAllowance);\r\n    _burn(account, amount);\r\n  }\r\n}\r\n\r\n\r\n/* \r\n * @dev Implementation of a token compliant with the ERC20 Token protocol;\r\n * The token has additional burn functionality. \r\n */\r\ncontract Token is ERC20Burnable {\r\n  using SafeMath for uint256;\r\n\r\n  /* \r\n * @dev Initialization of the token, \r\n * following arguments are provided via the constructor: name, symbol, recipient, totalSupply.\r\n * The total supply of tokens is minted to the specified recipient.\r\n */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    address recipient,\r\n    uint256 totalSupply\r\n  ) public ERC20(name, symbol) {\r\n    _mint(recipient, totalSupply);\r\n  }\r\n}\r\n\r\n\r\n/* \r\n * @dev Implementation of the Initial Stake Offering (ISO). \r\n * The ISO is a decentralized token offering with trustless liquidity provisioning, \r\n * dividend accumulation and bonus rewards from staking.\r\n */\r\ncontract UnistakeTokenSale {\r\n  using SafeMath for uint256;\r\n\r\n  struct Contributor {\r\n        uint256 phase;\r\n        uint256 remainder;\r\n        uint256 fromTotalDivs;\r\n    }\r\n  \r\n  address payable public immutable wallet;\r\n\r\n  uint256 public immutable totalSupplyR1;\r\n  uint256 public immutable totalSupplyR2;\r\n  uint256 public immutable totalSupplyR3;\r\n\r\n  uint256 public immutable totalSupplyUniswap;\r\n\r\n  uint256 public immutable rateR1;\r\n  uint256 public immutable rateR2;\r\n  uint256 public immutable rateR3;\r\n\r\n  uint256 public immutable periodDurationR3;\r\n\r\n  uint256 public immutable timeDelayR1;\r\n  uint256 public immutable timeDelayR2;\r\n\r\n  uint256 public immutable stakingPeriodR1;\r\n  uint256 public immutable stakingPeriodR2;\r\n  uint256 public immutable stakingPeriodR3;\r\n\r\n  Token public immutable token;\r\n  IUniswapV2Router02 public immutable uniswapRouter;\r\n\r\n  uint256 public immutable decreasingPctToken;\r\n  uint256 public immutable decreasingPctETH;\r\n  uint256 public immutable decreasingPctRate;\r\n  uint256 public immutable decreasingPctBonus;\r\n  \r\n  uint256 public immutable listingRate;\r\n  address public immutable platformStakingContract;\r\n\r\n  mapping(address => bool)        private _contributor;\r\n  mapping(address => Contributor) private _contributors;\r\n  mapping(address => uint256)[3]  private _contributions;\r\n  \r\n  bool[3]    private _hasEnded;\r\n  uint256[3] private _actualSupply;\r\n\r\n  uint256 private _startTimeR2 = 2**256 - 1;\r\n  uint256 private _startTimeR3 = 2**256 - 1;\r\n  uint256 private _endTimeR3   = 2**256 - 1;\r\n\r\n  mapping(address => bool)[3] private _hasWithdrawn;\r\n\r\n  bool    private _bonusOfferingActive;\r\n  uint256 private _bonusOfferingActivated;\r\n  uint256 private _bonusTotal;\r\n  \r\n  uint256 private _contributionsTotal;\r\n\r\n  uint256 private _contributorsTotal;\r\n  uint256 private _contributedFundsTotal;\r\n \r\n  uint256 private _bonusReductionFactor;\r\n  uint256 private _fundsWithdrawn;\r\n  \r\n  uint256 private _endedDayR3;\r\n  \r\n  uint256 private _latestStakingPlatformPayment;\r\n  \r\n  uint256 private _totalDividends;\r\n  uint256 private _scaledRemainder;\r\n  uint256 private _scaling = uint256(10) ** 12;\r\n  uint256 private _phase = 1;\r\n  uint256 private _totalRestakedDividends;\r\n  \r\n  mapping(address => uint256) private _restkedDividends;\r\n  mapping(uint256 => uint256) private _payouts;         \r\n\r\n  \r\n  event Staked(\r\n      address indexed account, \r\n      uint256 amount);\r\n      \r\n  event Claimed(\r\n      address indexed account, \r\n      uint256 amount);\r\n      \r\n  event Reclaimed(\r\n      address indexed account, \r\n      uint256 amount);\r\n      \r\n  event Withdrawn(\r\n      address indexed account, \r\n      uint256 amount); \r\n      \r\n  event Penalized(\r\n      address indexed account, \r\n      uint256 amount);\r\n      \r\n  event Ended(\r\n      address indexed account, \r\n      uint256 amount, \r\n      uint256 time);\r\n      \r\n  event Splitted(\r\n      address indexed account, \r\n      uint256 amount1, \r\n      uint256 amount2);  \r\n  \r\n  event Bought(\r\n      uint8 indexed round, \r\n      address indexed account,\r\n      uint256 amount);\r\n      \r\n  event Activated(\r\n      bool status, \r\n      uint256 time);\r\n\r\n\r\n  /* \r\n * @dev Initialization of the ISO,\r\n * following arguments are provided via the constructor: \r\n * ----------------------------------------------------\r\n * tokenArg                    - token offered in the ISO.\r\n * totalSupplyArg              - total amount of tokens allocated for each round.\r\n * totalSupplyUniswapArg       - amount of tokens that will be sent to uniswap.\r\n * ratesArg                    - contribution ratio ETH:Token for each round.\r\n * periodDurationR3            - duration of a day during round 3.\r\n * timeDelayR1Arg              - time delay between round 1 and round 2.\r\n * timeDelayR2Arg              - time delay between round 2 and round 3.\r\n * stakingPeriodArg            - staking duration required to get bonus tokens for each round.\r\n * uniswapRouterArg            - contract address of the uniswap router object.\r\n * decreasingPctArg            - decreasing percentages associated with: token, ETH, rate, and bonus.\r\n * listingRateArg              - initial listing rate of the offered token.\r\n * platformStakingContractArg  - contract address of the timed distribution contract.\r\n * walletArg                   - account address of the team wallet.\r\n * \r\n */\r\n  constructor(\r\n    address tokenArg,\r\n    uint256[3] memory totalSupplyArg,\r\n    uint256 totalSupplyUniswapArg,\r\n    uint256[3] memory ratesArg,\r\n    uint256 periodDurationR3Arg,\r\n    uint256 timeDelayR1Arg,\r\n    uint256 timeDelayR2Arg,\r\n    uint256[3] memory stakingPeriodArg,\r\n    address uniswapRouterArg,\r\n    uint256[4] memory decreasingPctArg,\r\n    uint256 listingRateArg,\r\n    address platformStakingContractArg,\r\n    address payable walletArg\r\n    ) public {\r\n    for (uint256 j = 0; j < 3; j++) {\r\n        require(totalSupplyArg[j] > 0, \r\n        \"The 'totalSupplyArg' argument must be larger than zero\");\r\n        require(ratesArg[j] > 0, \r\n        \"The 'ratesArg' argument must be larger than zero\");\r\n        require(stakingPeriodArg[j] > 0, \r\n        \"The 'stakingPeriodArg' argument must be larger than zero\");\r\n    }\r\n    for (uint256 j = 0; j < 4; j++) {\r\n        require(decreasingPctArg[j] < 10000, \r\n        \"The 'decreasingPctArg' arguments must be less than 100 percent\");\r\n    }\r\n    require(totalSupplyUniswapArg > 0, \r\n    \"The 'totalSupplyUniswapArg' argument must be larger than zero\");\r\n    require(periodDurationR3Arg > 0, \r\n    \"The 'slotDurationR3Arg' argument must be larger than zero\");\r\n    require(tokenArg != address(0), \r\n    \"The 'tokenArg' argument cannot be the zero address\");\r\n    require(uniswapRouterArg != address(0), \r\n    \"The 'uniswapRouterArg' argument cannot be the zero addresss\");\r\n    require(listingRateArg > 0,\r\n    \"The 'listingRateArg' argument must be larger than zero\");\r\n    require(platformStakingContractArg != address(0), \r\n    \"The 'vestingContractArg' argument cannot be the zero address\");\r\n    require(walletArg != address(0), \r\n    \"The 'walletArg' argument cannot be the zero address\");\r\n    \r\n    token = Token(tokenArg);\r\n    \r\n    totalSupplyR1 = totalSupplyArg[0];\r\n    totalSupplyR2 = totalSupplyArg[1];\r\n    totalSupplyR3 = totalSupplyArg[2];\r\n    \r\n    totalSupplyUniswap = totalSupplyUniswapArg;\r\n    \r\n    periodDurationR3 = periodDurationR3Arg;\r\n    \r\n    timeDelayR1 = timeDelayR1Arg;\r\n    timeDelayR2 = timeDelayR2Arg;\r\n    \r\n    rateR1 = ratesArg[0];\r\n    rateR2 = ratesArg[1];\r\n    rateR3 = ratesArg[2];\r\n    \r\n    stakingPeriodR1 = stakingPeriodArg[0];\r\n    stakingPeriodR2 = stakingPeriodArg[1];\r\n    stakingPeriodR3 = stakingPeriodArg[2];\r\n    \r\n    uniswapRouter = IUniswapV2Router02(uniswapRouterArg);\r\n    \r\n    decreasingPctToken = decreasingPctArg[0];\r\n    decreasingPctETH = decreasingPctArg[1];\r\n    decreasingPctRate = decreasingPctArg[2];\r\n    decreasingPctBonus = decreasingPctArg[3];\r\n    \r\n    listingRate = listingRateArg;\r\n    \r\n    platformStakingContract = platformStakingContractArg;\r\n    wallet = walletArg;\r\n  }\r\n  \r\n  /**\r\n   * @dev The fallback function is used for all contributions\r\n   * during the ISO. The function monitors the current \r\n   * round and manages token contributions accordingly.\r\n   */\r\n  receive() external payable {\r\n      if (token.balanceOf(address(this)) > 0) {\r\n          uint8 currentRound = _calculateCurrentRound();\r\n          \r\n          if (currentRound == 0) {\r\n              _buyTokenR1();\r\n          } else if (currentRound == 1) {\r\n              _buyTokenR2();\r\n          } else if (currentRound == 2) {\r\n              _buyTokenR3();\r\n          } else {\r\n              revert(\"The stake offering rounds are not active\");\r\n          }\r\n    } else {\r\n        revert(\"The stake offering must be active\");\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * @dev Wrapper around the round 3 closing function.\r\n   */     \r\n  function closeR3() external {\r\n      uint256 period = _calculatePeriod(block.timestamp);\r\n      _closeR3(period);\r\n  }\r\n  \r\n  /**\r\n   * @dev This function prepares the staking and bonus reward settings\r\n   * and it also provides liquidity to a freshly created uniswap pair.\r\n   */  \r\n  function activateStakesAndUniswapLiquidity() external {\r\n      require(_hasEnded[0] && _hasEnded[1] && _hasEnded[2], \r\n      \"all rounds must have ended\");\r\n      require(!_bonusOfferingActive, \r\n      \"the bonus offering and uniswap paring can only be done once per ISO\");\r\n      \r\n      uint256[3] memory bonusSupplies = [\r\n          (_actualSupply[0].mul(_bonusReductionFactor)).div(10000),\r\n          (_actualSupply[1].mul(_bonusReductionFactor)).div(10000),\r\n          (_actualSupply[2].mul(_bonusReductionFactor)).div(10000)\r\n          ];\r\n          \r\n      uint256 totalSupply = totalSupplyR1.add(totalSupplyR2).add(totalSupplyR3);\r\n      uint256 soldSupply = _actualSupply[0].add(_actualSupply[1]).add(_actualSupply[2]);\r\n      uint256 unsoldSupply = totalSupply.sub(soldSupply);\r\n          \r\n      uint256 exceededBonus = totalSupply\r\n      .sub(bonusSupplies[0])\r\n      .sub(bonusSupplies[1])\r\n      .sub(bonusSupplies[2]);\r\n      \r\n      uint256 exceededUniswapAmount = _createUniswapPair(_endedDayR3); \r\n      \r\n      _bonusOfferingActive = true;\r\n      _bonusOfferingActivated = block.timestamp;\r\n      _bonusTotal = bonusSupplies[0].add(bonusSupplies[1]).add(bonusSupplies[2]);\r\n      _contributionsTotal = soldSupply;\r\n      \r\n      _distribute(unsoldSupply.add(exceededBonus).add(exceededUniswapAmount));\r\n     \r\n      emit Activated(true, block.timestamp);\r\n  }\r\n  \r\n  /**\r\n   * @dev This function allows the caller to stake claimable dividends.\r\n   */   \r\n  function restakeDividends() external {\r\n      uint256 pending = _pendingDividends(msg.sender);\r\n      pending = pending.add(_contributors[msg.sender].remainder);\r\n      require(pending >= 0, \"You do not have dividends to restake\");\r\n      _restkedDividends[msg.sender] = _restkedDividends[msg.sender].add(pending);\r\n      _totalRestakedDividends = _totalRestakedDividends.add(pending);\r\n      _bonusTotal = _bonusTotal.sub(pending);\r\n\r\n      _contributors[msg.sender].phase = _phase;\r\n      _contributors[msg.sender].remainder = 0;\r\n      _contributors[msg.sender].fromTotalDivs = _totalDividends;\r\n      \r\n      emit Staked(msg.sender, pending);\r\n  }\r\n\r\n  /**\r\n   * @dev This function is called by contributors to \r\n   * withdraw round 1 tokens. \r\n   * -----------------------------------------------------\r\n   * Withdrawing tokens might result in bonus tokens, dividends,\r\n   * or similar (based on the staking duration of the contributor).\r\n   * \r\n   */  \r\n  function withdrawR1Tokens() external {\r\n      require(_bonusOfferingActive, \r\n      \"The bonus offering is not active yet\");\r\n      \r\n      _withdrawTokens(0);\r\n  }\r\n \r\n  /**\r\n   * @dev This function is called by contributors to \r\n   * withdraw round 2 tokens. \r\n   * -----------------------------------------------------\r\n   * Withdrawing tokens might result in bonus tokens, dividends,\r\n   * or similar (based on the staking duration of the contributor).\r\n   * \r\n   */      \r\n  function withdrawR2Tokens() external {\r\n      require(_bonusOfferingActive, \r\n      \"The bonus offering is not active yet\");\r\n      \r\n      _withdrawTokens(1);\r\n  }\r\n \r\n  /**\r\n   * @dev This function is called by contributors to \r\n   * withdraw round 3 tokens. \r\n   * -----------------------------------------------------\r\n   * Withdrawing tokens might result in bonus tokens, dividends,\r\n   * or similar (based on the staking duration of the contributor).\r\n   * \r\n   */   \r\n  function withdrawR3Tokens() external {\r\n      require(_bonusOfferingActive, \r\n      \"The bonus offering is not active yet\");  \r\n\r\n      _withdrawTokens(2);\r\n  }\r\n \r\n  /**\r\n   * @dev wrapper around the withdrawal of funds function. \r\n   */    \r\n  function withdrawFunds() external {\r\n      uint256 amount = ((address(this).balance).sub(_fundsWithdrawn)).div(2);\r\n      \r\n      _withdrawFunds(amount);\r\n  }  \r\n \r\n  /**\r\n   * @dev Returns the total amount of restaked dividends in the ISO.\r\n   */    \r\n  function getRestakedDividendsTotal() external view returns (uint256) { \r\n      return _totalRestakedDividends;\r\n  }\r\n  \r\n  /**\r\n   * @dev Returns the total staking bonuses in the ISO. \r\n   */     \r\n  function getStakingBonusesTotal() external view returns (uint256) {\r\n      return _bonusTotal;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the latest amount of tokens sent to the timed distribution contract.  \r\n   */    \r\n  function getLatestStakingPlatformPayment() external view returns (uint256) {\r\n      return _latestStakingPlatformPayment;\r\n  }\r\n \r\n  /**\r\n   * @dev Returns the current day of round 3.\r\n   */   \r\n  function getCurrentDayR3() external view returns (uint256) {\r\n      if (_endedDayR3 != 0) {\r\n          return _endedDayR3;\r\n      }\r\n      return _calculatePeriod(block.timestamp);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the ending day of round 3. \r\n   */    \r\n  function getEndedDayR3() external view returns (uint256) {\r\n      return _endedDayR3;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the start time of round 2. \r\n   */    \r\n  function getR2Start() external view returns (uint256) {\r\n      return _startTimeR2;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the start time of round 3. \r\n   */  \r\n  function getR3Start() external view returns (uint256) {\r\n      return _startTimeR3;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the end time of round 3. \r\n   */  \r\n  function getR3End() external view returns (uint256) {\r\n      return _endTimeR3;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total amount of contributors in the ISO. \r\n   */  \r\n  function getContributorsTotal() external view returns (uint256) {\r\n      return _contributorsTotal;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total amount of contributed funds (ETH) in the ISO \r\n   */  \r\n  function getContributedFundsTotal() external view returns (uint256) {\r\n      return _contributedFundsTotal;\r\n  }\r\n  \r\n  /**\r\n   * @dev Returns the current round of the ISO. \r\n   */  \r\n  function getCurrentRound() external view returns (uint8) {\r\n      uint8 round = _calculateCurrentRound();\r\n      \r\n      if (round == 0 && !_hasEnded[0]) {\r\n          return 1;\r\n      } \r\n      if (round == 1 && !_hasEnded[1] && _hasEnded[0]) {\r\n          if (block.timestamp <= _startTimeR2) {\r\n              return 0;\r\n          }\r\n          return 2;\r\n      }\r\n      if (round == 2 && !_hasEnded[2] && _hasEnded[1]) {\r\n          if (block.timestamp <= _startTimeR3) {\r\n              return 0;\r\n          }\r\n          return 3;\r\n      } \r\n      else {\r\n          return 0;\r\n      }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether round 1 has ended or not. \r\n   */   \r\n  function hasR1Ended() external view returns (bool) {\r\n      return _hasEnded[0];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether round 2 has ended or not. \r\n   */   \r\n  function hasR2Ended() external view returns (bool) {\r\n      return _hasEnded[1];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether round 3 has ended or not. \r\n   */   \r\n  function hasR3Ended() external view returns (bool) { \r\n      return _hasEnded[2];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remaining time delay between round 1 and round 2.\r\n   */    \r\n  function getRemainingTimeDelayR1R2() external view returns (uint256) {\r\n      if (timeDelayR1 > 0) {\r\n          if (_hasEnded[0] && !_hasEnded[1]) {\r\n              if (_startTimeR2.sub(block.timestamp) > 0) {\r\n                  return _startTimeR2.sub(block.timestamp);\r\n              } else {\r\n                  return 0;\r\n              }\r\n          } else {\r\n              return 0;\r\n          }\r\n      } else {\r\n          return 0;\r\n      }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remaining time delay between round 2 and round 3.\r\n   */  \r\n  function getRemainingTimeDelayR2R3() external view returns (uint256) {\r\n      if (timeDelayR2 > 0) {\r\n          if (_hasEnded[0] && _hasEnded[1] && !_hasEnded[2]) {\r\n              if (_startTimeR3.sub(block.timestamp) > 0) {\r\n                  return _startTimeR3.sub(block.timestamp);\r\n              } else {\r\n                  return 0;\r\n              }\r\n          } else {\r\n              return 0;\r\n          }\r\n      } else {\r\n          return 0;\r\n      }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total sales for round 1.\r\n   */  \r\n  function getR1Sales() external view returns (uint256) {\r\n      return _actualSupply[0];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total sales for round 2.\r\n   */  \r\n  function getR2Sales() external view returns (uint256) {\r\n      return _actualSupply[1];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total sales for round 3.\r\n   */  \r\n  function getR3Sales() external view returns (uint256) {\r\n      return _actualSupply[2];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the staking- and bonus functionality has been activated or not.\r\n   */    \r\n  function getStakingActivationStatus() external view returns (bool) {\r\n      return _bonusOfferingActive;\r\n  }\r\n  \r\n  /**\r\n   * @dev This function allows the caller to withdraw claimable dividends.\r\n   */    \r\n  function claimDividends() public {\r\n      if (_totalDividends > _contributors[msg.sender].fromTotalDivs) {\r\n          uint256 pending = _pendingDividends(msg.sender);\r\n          pending = pending.add(_contributors[msg.sender].remainder);\r\n          require(pending >= 0, \"You do not have dividends to claim\");\r\n          \r\n          _contributors[msg.sender].phase = _phase;\r\n          _contributors[msg.sender].remainder = 0;\r\n          _contributors[msg.sender].fromTotalDivs = _totalDividends;\r\n          \r\n          _bonusTotal = _bonusTotal.sub(pending);\r\n\r\n          require(token.transfer(msg.sender, pending), \"Error in sending reward from contract\");\r\n\r\n          emit Claimed(msg.sender, pending);\r\n\r\n      }\r\n  }\r\n\r\n  /**\r\n   * @dev This function allows the caller to withdraw restaked dividends.\r\n   */     \r\n  function withdrawRestakedDividends() public {\r\n      uint256 amount = _restkedDividends[msg.sender];\r\n      require(amount >= 0, \"You do not have restaked dividends to withdraw\");\r\n      \r\n      claimDividends();\r\n      \r\n      _restkedDividends[msg.sender] = 0;\r\n      _totalRestakedDividends = _totalRestakedDividends.sub(amount);\r\n      \r\n      token.transfer(msg.sender, amount);      \r\n      \r\n      emit Reclaimed(msg.sender, amount);\r\n  }    \r\n  \r\n  /**\r\n   * @dev Returns claimable dividends.\r\n   */    \r\n  function getDividends(address accountArg) public view returns (uint256) {\r\n      uint256 amount = ((_totalDividends.sub(_payouts[_contributors[accountArg].phase - 1])).mul(getContributionTotal(accountArg))).div(_scaling);\r\n      amount += ((_totalDividends.sub(_payouts[_contributors[accountArg].phase - 1])).mul(getContributionTotal(accountArg))) % _scaling ;\r\n      return (amount.add(_contributors[msg.sender].remainder));\r\n  }\r\n \r\n  /**\r\n   * @dev Returns restaked dividends.\r\n   */   \r\n  function getRestakedDividends(address accountArg) public view returns (uint256) { \r\n      return _restkedDividends[accountArg];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns round 1 contributions of an account. \r\n   */  \r\n  function getR1Contribution(address accountArg) public view returns (uint256) {\r\n      return _contributions[0][accountArg];\r\n  }\r\n  \r\n  /**\r\n   * @dev Returns round 2 contributions of an account. \r\n   */    \r\n  function getR2Contribution(address accountArg) public view returns (uint256) {\r\n      return _contributions[1][accountArg];\r\n  }\r\n  \r\n  /**\r\n   * @dev Returns round 3 contributions of an account. \r\n   */  \r\n  function getR3Contribution(address accountArg) public view returns (uint256) { \r\n      return _contributions[2][accountArg];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total contributions of an account. \r\n   */    \r\n  function getContributionTotal(address accountArg) public view returns (uint256) {\r\n      uint256 contributionR1 = getR1Contribution(accountArg);\r\n      uint256 contributionR2 = getR2Contribution(accountArg);\r\n      uint256 contributionR3 = getR3Contribution(accountArg);\r\n      uint256 restaked = getRestakedDividends(accountArg);\r\n\r\n      return contributionR1.add(contributionR2).add(contributionR3).add(restaked);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total contributions in the ISO (including restaked dividends). \r\n   */    \r\n  function getContributionsTotal() public view returns (uint256) {\r\n      return _contributionsTotal.add(_totalRestakedDividends);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns expected round 1 staking bonus for an account. \r\n   */  \r\n  function getStakingBonusR1(address accountArg) public view returns (uint256) {\r\n      uint256 contribution = _contributions[0][accountArg];\r\n      \r\n      return (contribution.mul(_bonusReductionFactor)).div(10000);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns expected round 2 staking bonus for an account. \r\n   */ \r\n  function getStakingBonusR2(address accountArg) public view returns (uint256) {\r\n      uint256 contribution = _contributions[1][accountArg];\r\n      \r\n      return (contribution.mul(_bonusReductionFactor)).div(10000);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns expected round 3 staking bonus for an account. \r\n   */ \r\n  function getStakingBonusR3(address accountArg) public view returns (uint256) {\r\n      uint256 contribution = _contributions[2][accountArg];\r\n      \r\n      return (contribution.mul(_bonusReductionFactor)).div(10000);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total expected staking bonuses for an account. \r\n   */   \r\n  function getStakingBonusTotal(address accountArg) public view returns (uint256) {\r\n      uint256 stakeR1 = getStakingBonusR1(accountArg);\r\n      uint256 stakeR2 = getStakingBonusR2(accountArg);\r\n      uint256 stakeR3 = getStakingBonusR3(accountArg);\r\n\r\n      return stakeR1.add(stakeR2).add(stakeR3);\r\n }   \r\n\r\n  /**\r\n   * @dev This function handles distribution of extra supply.\r\n   */    \r\n  function _distribute(uint256 amountArg) private {\r\n      uint256 vested = amountArg.div(2);\r\n      uint256 burned = amountArg.sub(vested);\r\n      \r\n      token.transfer(platformStakingContract, vested);\r\n      token.burn(burned);\r\n  }\r\n\r\n  /**\r\n   * @dev This function handles calculation of token withdrawals\r\n   * (it also withdraws dividends and restaked dividends \r\n   * during certain circumstances).\r\n   */    \r\n  function _withdrawTokens(uint8 indexArg) private {\r\n      require(_hasEnded[0] && _hasEnded[1] && _hasEnded[2], \r\n      \"The rounds must be inactive before any tokens can be withdrawn\");\r\n      require(!_hasWithdrawn[indexArg][msg.sender], \r\n      \"The caller must have withdrawable tokens available from this round\");\r\n      \r\n      claimDividends();\r\n      \r\n      uint256 amount = _contributions[indexArg][msg.sender];\r\n      uint256 amountBonus = (amount.mul(_bonusReductionFactor)).div(10000);\r\n      \r\n      _contributions[indexArg][msg.sender] = _contributions[indexArg][msg.sender].sub(amount);\r\n      _contributionsTotal = _contributionsTotal.sub(amount);\r\n      \r\n      uint256 contributions = getContributionTotal(msg.sender);\r\n      uint256 restaked = getRestakedDividends(msg.sender);\r\n      \r\n      if (contributions.sub(restaked) == 0) withdrawRestakedDividends();\r\n    \r\n      uint pending = _pendingDividends(msg.sender);\r\n      _contributors[msg.sender].remainder = (_contributors[msg.sender].remainder).add(pending);\r\n      _contributors[msg.sender].fromTotalDivs = _totalDividends;\r\n      _contributors[msg.sender].phase = _phase;\r\n      \r\n      _hasWithdrawn[indexArg][msg.sender] = true;\r\n      \r\n      token.transfer(msg.sender, amount);\r\n      \r\n      _endStake(indexArg, msg.sender, amountBonus);\r\n  }\r\n \r\n  /**\r\n   * @dev This function handles fund withdrawals.\r\n   */  \r\n  function _withdrawFunds(uint256 amountArg) private {\r\n      require(msg.sender == wallet, \r\n      \"The caller must be the specified funds wallet of the team\");\r\n      require(amountArg <= ((address(this).balance.sub(_fundsWithdrawn)).div(2)),\r\n      \"The 'amountArg' argument exceeds the limit\");\r\n      require(!_hasEnded[2], \r\n      \"The third round is not active\");\r\n      \r\n      _fundsWithdrawn = _fundsWithdrawn.add(amountArg);\r\n      \r\n      wallet.transfer(amountArg);\r\n  }  \r\n\r\n  /**\r\n   * @dev This function handles token purchases for round 1.\r\n   */ \r\n  function _buyTokenR1() private {\r\n      if (token.balanceOf(address(this)) > 0) {\r\n          require(!_hasEnded[0], \r\n          \"The first round must be active\");\r\n          \r\n          bool isRoundEnded = _buyToken(0, rateR1, totalSupplyR1);\r\n          \r\n          if (isRoundEnded == true) {\r\n              _startTimeR2 = block.timestamp.add(timeDelayR1);\r\n          }\r\n      } else {\r\n          revert(\"The stake offering must be active\");\r\n    }\r\n  }\r\n \r\n  /**\r\n   * @dev This function handles token purchases for round 2.\r\n   */   \r\n  function _buyTokenR2() private {\r\n      require(_hasEnded[0] && !_hasEnded[1],\r\n      \"The first round one must not be active while the second round must be active\");\r\n      require(block.timestamp >= _startTimeR2,\r\n      \"The time delay between the first round and the second round must be surpassed\");\r\n      \r\n      bool isRoundEnded = _buyToken(1, rateR2, totalSupplyR2);\r\n      \r\n      if (isRoundEnded == true) {\r\n          _startTimeR3 = block.timestamp.add(timeDelayR2);\r\n      }\r\n  }\r\n \r\n  /**\r\n   * @dev This function handles token purchases for round 3.\r\n   */   \r\n  function _buyTokenR3() private {\r\n      require(_hasEnded[1] && !_hasEnded[2],\r\n      \"The second round one must not be active while the third round must be active\");\r\n      require(block.timestamp >= _startTimeR3,\r\n      \"The time delay between the first round and the second round must be surpassed\"); \r\n      \r\n      uint256 period = _calculatePeriod(block.timestamp);\r\n      \r\n      (bool isRoundClosed, uint256 actualPeriodTotalSupply) = _closeR3(period);\r\n\r\n      if (!isRoundClosed) {\r\n          bool isRoundEnded = _buyToken(2, rateR3, actualPeriodTotalSupply);\r\n          \r\n          if (isRoundEnded == true) {\r\n              _endTimeR3 = block.timestamp;\r\n              uint256 endingPeriod = _calculateEndingPeriod();\r\n              uint256 reductionFactor = _calculateBonusReductionFactor(endingPeriod);\r\n              _bonusReductionFactor = reductionFactor;\r\n              _endedDayR3 = endingPeriod;\r\n          }\r\n      }\r\n  }\r\n  \r\n  /**\r\n   * @dev This function handles bonus payouts and the split of forfeited bonuses.\r\n   */     \r\n  function _endStake(uint256 indexArg, address accountArg, uint256 amountArg) private {\r\n      uint256 elapsedTime = (block.timestamp).sub(_bonusOfferingActivated);\r\n      uint256 payout;\r\n      \r\n      uint256 duration = _getDuration(indexArg);\r\n      \r\n      if (elapsedTime >= duration) {\r\n          payout = amountArg;\r\n      } else if (elapsedTime >= duration.mul(3).div(4) && elapsedTime < duration) {\r\n          payout = amountArg.mul(3).div(4);\r\n      } else if (elapsedTime >= duration.div(2) && elapsedTime < duration.mul(3).div(4)) {\r\n          payout = amountArg.div(2);\r\n      } else if (elapsedTime >= duration.div(4) && elapsedTime < duration.div(2)) {\r\n          payout = amountArg.div(4);\r\n      } else {\r\n          payout = 0;\r\n      }\r\n      \r\n      _split(amountArg.sub(payout));\r\n      \r\n      if (payout != 0) {\r\n          token.transfer(accountArg, payout);\r\n      }\r\n      \r\n      emit Ended(accountArg, amountArg, block.timestamp);\r\n  }\r\n \r\n  /**\r\n   * @dev This function splits forfeited bonuses into dividends \r\n   * and to timed distribution contract accordingly.\r\n   */     \r\n  function _split(uint256 amountArg) private {\r\n      if (amountArg == 0) {\r\n        return;\r\n      }\r\n      \r\n      uint256 dividends = amountArg.div(2);\r\n      uint256 platformStakingShare = amountArg.sub(dividends);\r\n      \r\n      _bonusTotal = _bonusTotal.sub(platformStakingShare);\r\n      _latestStakingPlatformPayment = platformStakingShare;\r\n      \r\n      token.transfer(platformStakingContract, platformStakingShare);\r\n      \r\n      _addDividends(_latestStakingPlatformPayment);\r\n      \r\n      emit Splitted(msg.sender, dividends, platformStakingShare);\r\n  }\r\n  \r\n   /**\r\n   * @dev this function handles addition of new dividends.\r\n   */   \r\n  function _addDividends(uint256 bonusArg) private {\r\n      uint256 latest = (bonusArg.mul(_scaling)).add(_scaledRemainder);\r\n      uint256 dividendPerToken = latest.div(_contributionsTotal.add(_totalRestakedDividends));\r\n      _scaledRemainder = latest.mod(_contributionsTotal.add(_totalRestakedDividends));\r\n      _totalDividends = _totalDividends.add(dividendPerToken);\r\n      _payouts[_phase] = _payouts[_phase-1].add(dividendPerToken);\r\n      _phase++;\r\n  }\r\n  \r\n   /**\r\n   * @dev returns pending dividend rewards.\r\n   */    \r\n  function _pendingDividends(address accountArg) private returns (uint256) {\r\n      uint256 amount = ((_totalDividends.sub(_payouts[_contributors[accountArg].phase - 1])).mul(getContributionTotal(accountArg))).div(_scaling);\r\n      _contributors[accountArg].remainder += ((_totalDividends.sub(_payouts[_contributors[accountArg].phase - 1])).mul(getContributionTotal(accountArg))) % _scaling ;\r\n      return amount;\r\n  }\r\n  \r\n  /**\r\n   * @dev This function creates a uniswap pair and handles liquidity provisioning.\r\n   * Returns the uniswap token leftovers.\r\n   */  \r\n  function _createUniswapPair(uint256 endingPeriodArg) private returns (uint256) {\r\n      uint256 listingPrice = endingPeriodArg.mul(decreasingPctRate);\r\n\r\n      uint256 ethDecrease = uint256(5000).sub(endingPeriodArg.mul(decreasingPctETH));\r\n      uint256 ethOnUniswap = (_contributedFundsTotal.mul(ethDecrease)).div(10000);\r\n      \r\n      ethOnUniswap = ethOnUniswap <= (address(this).balance)\r\n      ? ethOnUniswap\r\n      : (address(this).balance);\r\n      \r\n      uint256 tokensOnUniswap = ethOnUniswap\r\n      .mul(listingRate)\r\n      .mul(10000)\r\n      .div(uint256(10000).sub(listingPrice))\r\n      .div(100000);\r\n      \r\n      token.approve(address(uniswapRouter), tokensOnUniswap);\r\n      \r\n      uniswapRouter.addLiquidityETH.value(ethOnUniswap)(\r\n      address(token),\r\n      tokensOnUniswap,\r\n      0,\r\n      0,\r\n      wallet,\r\n      block.timestamp\r\n      );\r\n      \r\n      wallet.transfer(address(this).balance);\r\n      \r\n      return (totalSupplyUniswap.sub(tokensOnUniswap));\r\n  } \r\n \r\n  /**\r\n   * @dev this function will close round 3 if based on day and sold supply.\r\n   * Returns whether a particular round has ended or not and \r\n   * the max supply of a particular day during round 3.\r\n   */    \r\n  function _closeR3(uint256 periodArg) private returns (bool isRoundEnded, uint256 maxPeriodSupply) {\r\n      require(_hasEnded[0] && _hasEnded[1] && !_hasEnded[2],\r\n      'Round 3 has ended or Round 1 or 2 have not ended yet');\r\n      require(block.timestamp >= _startTimeR3,\r\n      'Pause period between Round 2 and 3');\r\n      \r\n      uint256 decreasingTokenNumber = totalSupplyR3.mul(decreasingPctToken).div(10000);\r\n      maxPeriodSupply = totalSupplyR3.sub(periodArg.mul(decreasingTokenNumber));\r\n      \r\n      if (maxPeriodSupply <= _actualSupply[2]) {\r\n          msg.sender.transfer(msg.value);\r\n          _hasEnded[2] = true;\r\n          \r\n          _endTimeR3 = block.timestamp;\r\n          \r\n          uint256 endingPeriod = _calculateEndingPeriod();\r\n          uint256 reductionFactor = _calculateBonusReductionFactor(endingPeriod);\r\n          \r\n          _endedDayR3 = endingPeriod;\r\n          \r\n          _bonusReductionFactor = reductionFactor;\r\n          return (true, maxPeriodSupply);\r\n          \r\n      } else {\r\n          return (false, maxPeriodSupply);\r\n      }\r\n  }\r\n \r\n  /**\r\n   * @dev this function handles low level token purchases. \r\n   * Returns whether a particular round has ended or not.\r\n   */     \r\n  function _buyToken(uint8 indexArg, uint256 rateArg, uint256 totalSupplyArg) private returns (bool isRoundEnded) {\r\n      uint256 tokensNumber = msg.value.mul(rateArg).div(100000);\r\n      uint256 actualTotalBalance = _actualSupply[indexArg];\r\n      uint256 newTotalRoundBalance = actualTotalBalance.add(tokensNumber);\r\n      \r\n      if (!_contributor[msg.sender]) {\r\n          _contributor[msg.sender] = true;\r\n          _contributorsTotal++;\r\n      }  \r\n      \r\n      if (newTotalRoundBalance < totalSupplyArg) {\r\n          _contributions[indexArg][msg.sender] = _contributions[indexArg][msg.sender].add(tokensNumber);\r\n          _actualSupply[indexArg] = newTotalRoundBalance;\r\n          _contributedFundsTotal = _contributedFundsTotal.add(msg.value);\r\n          \r\n          emit Bought(uint8(indexArg + 1), msg.sender, tokensNumber);\r\n          \r\n          return false;\r\n          \r\n      } else {\r\n          uint256 availableTokens = totalSupplyArg.sub(actualTotalBalance);\r\n          uint256 availableEth = availableTokens.mul(100000).div(rateArg);\r\n          \r\n          _contributions[indexArg][msg.sender] = _contributions[indexArg][msg.sender].add(availableTokens);\r\n          _actualSupply[indexArg] = totalSupplyArg;\r\n          _contributedFundsTotal = _contributedFundsTotal.add(availableEth);\r\n          _hasEnded[indexArg] = true;\r\n          \r\n          msg.sender.transfer(msg.value.sub(availableEth));\r\n\r\n          emit Bought(uint8(indexArg + 1), msg.sender, availableTokens);\r\n          \r\n          return true;\r\n      }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the staking duration of a particular round.\r\n   */   \r\n  function _getDuration(uint256 indexArg) private view returns (uint256) {\r\n      if (indexArg == 0) {\r\n          return stakingPeriodR1;\r\n      }\r\n      if (indexArg == 1) {\r\n          return stakingPeriodR2;\r\n      }\r\n      if (indexArg == 2) {\r\n          return stakingPeriodR3;\r\n      }\r\n    }\r\n \r\n  /**\r\n   * @dev Returns the bonus reduction factor.\r\n   */       \r\n  function _calculateBonusReductionFactor(uint256 periodArg) private view returns (uint256) {\r\n      uint256 reductionFactor = uint256(10000).sub(periodArg.mul(decreasingPctBonus));\r\n      return reductionFactor;\r\n  } \r\n \r\n  /**\r\n   * @dev Returns the current round.\r\n   */     \r\n  function _calculateCurrentRound() private view returns (uint8) {\r\n      if (!_hasEnded[0]) {\r\n          return 0;\r\n      } else if (_hasEnded[0] && !_hasEnded[1] && !_hasEnded[2]) {\r\n          return 1;\r\n      } else if (_hasEnded[0] && _hasEnded[1] && !_hasEnded[2]) {\r\n          return 2;\r\n      } else {\r\n          return 2**8 - 1;\r\n      }\r\n  }\r\n \r\n  /**\r\n   * @dev Returns the current day.\r\n   */     \r\n  function _calculatePeriod(uint256 timeArg) private view returns (uint256) {\r\n      uint256 period = ((timeArg.sub(_startTimeR3)).div(periodDurationR3));\r\n      uint256 maxPeriods = uint256(10000).div(decreasingPctToken);\r\n      \r\n      if (period > maxPeriods) {\r\n          return maxPeriods;\r\n      }\r\n      return period;\r\n  }\r\n \r\n  /**\r\n   * @dev Returns the ending day of round 3.\r\n   */     \r\n  function _calculateEndingPeriod() private view returns (uint256) {\r\n      require(_endTimeR3 != (2**256) - 1, \r\n      \"The third round must be active\");\r\n      \r\n      uint256 endingPeriod = _calculatePeriod(_endTimeR3);\r\n      return endingPeriod;\r\n  }\r\n \r\n\r\n  \r\n  \r\n  \r\n  \r\n  \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Token","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000065bac24ce57aa77a676193e9a9a2bbeeaa3313000000000000000000000000000000000000000000e79c4e6a3023e8180000000000000000000000000000000000000000000000000000000000000000000008556e697374616b650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008554e495354414b45000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6e9543d48130d748ae982f9a959ab3f2f7e55b1f7742f44d8c2544a59f6b4772"}]}