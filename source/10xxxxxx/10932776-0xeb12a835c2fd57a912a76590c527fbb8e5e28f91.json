{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.7.0;\r\n\r\n/**\r\n * website: https://govm.net\r\n * be owner of contract 0xaC5d7dFF150B195C97Fca77001f8AD596eda1761\r\n * fix the burn bug of WGOVM\r\n*/\r\ncontract WGOVM {\r\n    function transferFrom(address _from,address _to,uint256 _value) public  returns (bool) ;\r\n    function mint(address _to, uint256 _amount, bytes32 _trans) public returns (bool);\r\n    function burn(uint256 _value, bytes memory _addr) public;\r\n    function transferOwnership(address newOwner) public;\r\n    function allowance(address _owner, address _spender)public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    function recover(bytes32 hash, bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n        \r\n        if (\r\n            uint256(s) >\r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n        ) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    function toEthSignedMessageHash(bytes32 hash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n            );\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Manager {\r\n    using ECDSA for bytes32;\r\n    address public owner;\r\n    address public app = 0xaC5d7dFF150B195C97Fca77001f8AD596eda1761;\r\n    WGOVM govm = WGOVM(app);\r\n    \r\n    event NeedApprove(address indexed from, address indexed to, uint256 value);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function relayMint(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes32 _trans,\r\n        bytes memory approvalData\r\n    ) public returns (bool) {\r\n        bytes memory blob = abi.encodePacked(_to, _amount, _trans);\r\n        address who = keccak256(blob).toEthSignedMessageHash().recover(approvalData);\r\n        require(who == owner);\r\n        return govm.mint(_to, _amount, _trans);\r\n    }\r\n    \r\n    function burn(uint256 _value, bytes memory _addr) public returns (bool) {\r\n        require(_value > 0);\r\n        if (govm.allowance(msg.sender,address(this)) < _value){\r\n            emit NeedApprove(msg.sender,address(this),_value);\r\n            return false;\r\n        }\r\n        govm.transferFrom(msg.sender,address(this),_value);\r\n        govm.burn(_value, _addr);\r\n        return true;\r\n    }\r\n    \r\n    function mint(address _to,uint256 _amount, bytes32 _trans)public onlyOwner returns (bool){\r\n        return govm.mint(_to, _amount, _trans);\r\n    }\r\n \r\n    function transferAppOwnership() public onlyOwner {\r\n        govm.transferOwnership(owner);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_trans\",\"type\":\"bytes32\"},{\"name\":\"approvalData\",\"type\":\"bytes\"}],\"name\":\"relayMint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_trans\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferAppOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"app\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NeedApprove\",\"type\":\"event\"}]","ContractName":"Manager","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ce6cda246a8d79333118ab250e1857fee29b94cceeb16b2e96d8c85e88932a67"}]}