{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity = 0.7 .0;\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b *c + a % b);\t// There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns(address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns(bytes memory) {\r\n    this;\r\n    return msg.data;\r\n  }\r\n}\r\n\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\nabstract contract Token {\r\n\r\n  function balanceOf(address account) external view virtual returns(uint256 data);\r\n\r\n}\r\n\r\nabstract contract Router {\r\n\r\n  function extrenalRouterCall(string memory route, address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\r\n\r\n  function updateCurrentSupply(uint[2] memory uintArr) external virtual returns(bool success);\r\n}\r\n\r\n//===============================================================\r\n//MAIN CONTRACT\r\n//===============================================================\r\ncontract SoloMiner is Ownable {\r\n  using SafeMath\r\n  for uint;\r\n\r\n  address private tokenContract;\r\n  address private routerContract;\r\n  uint private totalBurned;\r\n  uint private totalMinted;\r\n  bool private active = true;\r\n\r\n  Token private token;\r\n  Router private router;\r\n  mapping(address => uint) private numerator;\r\n  mapping(address => uint) private denominator;\r\n  mapping(address => uint) private minimumReturn;\r\n  mapping(address => uint) private userBlocks;\r\n  mapping(address => uint) private miners;\r\n  mapping(uint => address) private addressFromId;\r\n  mapping(address => bool) private mutex;\r\n\r\n  uint private pivot = 0;\r\n  uint private rewardConstant = 100000000000000000000;\r\n  uint private totalConstant = 21000000000000000000000000; //we assume that there is a 21 million as a total supply\r\n  uint private currentConstant = 1050000000000000000000000; //we assume that the current supply is 10.5 million tokens\r\n  uint private inflationBuffer = 100000000000000000000; //we are allowing the automated inflation with this\r\n\r\n  address private contractAddress;\r\n\r\n  constructor() {\r\n    contractAddress = address(this);\r\n    setNewTokenContract(address(0x7C131Ab459b874b82f19cdc1254fB66840D021B6));\r\n    setNewRouterContract(address(0x1f773c9344E3caE0AA6fA3c89Ac90701fEa364Fe));\r\n  }\r\n\r\n  modifier isActive() {\r\n    require(active, \"Miner is not active.\");\r\n    _;\r\n  }\r\n\r\n  //+++++++++++VIEWS++++++++++++++++\r\n  //----------GETTERS---------------\r\n  \r\n  function getPivot() external view virtual returns(uint lastPivot) {\r\n    return pivot;\r\n  }\r\n\r\n  function getAddressFromId(uint id) external view virtual returns(address minerAddress) {\r\n    return addressFromId[id];\r\n  }\r\n\r\n  function getUserNumerator(address minerAddress) external view virtual returns(uint minerNumerator) {\r\n    return numerator[minerAddress];\r\n  }\r\n\r\n  function getUserDenominator(address minerAddress) external view virtual returns(uint minerDenominator) {\r\n    return denominator[minerAddress];\r\n  }\r\n\r\n  function getUserBlocks(address minerAddress) external view virtual returns(uint minerBlocks) {\r\n    return userBlocks[minerAddress];\r\n  }\r\n\r\n  function getContractAddress() external view virtual returns(address tokenAddress) {\r\n    return contractAddress;\r\n  }\r\n\r\n  function getTokenContract() external view virtual returns(address tokenAddress) {\r\n    return tokenContract;\r\n  }\r\n\r\n  function getTotalBurned() external view virtual returns(uint burned) {\r\n    return totalBurned;\r\n  }\r\n\r\n  function getTotalMinted() external view virtual returns(uint burned) {\r\n    return totalMinted;\r\n  }\r\n\r\n  function getLastBlockNumber(address minerAddress) public view virtual returns(uint lastBlock) {\r\n    return userBlocks[minerAddress];\r\n  }\r\n\r\n  function getRouterContract() external view virtual returns(address routerAddress) {\r\n    return routerContract;\r\n  }\r\n\r\n  function getCurrentBlockNumber() public view returns(uint256 blockNumber) {\r\n    return block.number;\r\n  }\r\n\r\n  function getGapSize() public view virtual returns(uint gapSize) {\r\n    return totalConstant.sub(currentConstant);\r\n  }\r\n\r\n  function getRewardConstant() external view virtual returns(uint routerAddress) {\r\n    return rewardConstant;\r\n  }\r\n\r\n  function getTotalConstant() external view virtual returns(uint routerAddress) {\r\n    return totalConstant;\r\n  }\r\n\r\n  function getCurrentConstant() external view virtual returns(uint routerAddress) {\r\n    return currentConstant;\r\n  }\r\n\r\n  function getinflationBuffer() external view virtual returns(uint routerAddress) {\r\n    return inflationBuffer;\r\n  }\r\n\r\n  //----------OTHER VIEWS---------------\r\n  function showReward(address minerAddress) public view virtual returns(uint reward) {\r\n    if (denominator[minerAddress] == 0) {\r\n      return 0;\r\n    } else if (!active) {\r\n      return 0;\r\n    }\r\n\r\n    uint previousBlock = getLastBlockNumber(minerAddress);\r\n    uint currentBlock = getCurrentBlockNumber();\r\n    uint diff = currentBlock.sub(previousBlock);\r\n    uint additionalReward = diff.mul(rewardConstant);\r\n    additionalReward = (numerator[minerAddress].mul(additionalReward)).div(denominator[minerAddress]);\r\n    uint rewardSize = (numerator[minerAddress].mul(getGapSize())).div(denominator[minerAddress]);\r\n\r\n    if (rewardSize.add(currentConstant) > totalConstant) {\r\n      rewardSize = totalConstant.sub(currentConstant);\r\n    }\r\n    if (rewardSize < showMyCurrentRewardTotal()) {\r\n      rewardSize = showMyCurrentRewardTotal();\r\n    }\r\n    rewardSize = rewardSize + additionalReward;\r\n\r\n    return rewardSize;\r\n  }\r\n\r\n  //+++++++++++EXTERNAL++++++++++++++++\r\n  function mine(uint depositAmount) isActive external virtual returns(bool success) {\r\n    require(!mutex[msg.sender]);\r\n    mutex[msg.sender] = true;\r\n\r\n    require(depositAmount > 0,\r\n      \"at: solo_miner.sol | contract: SoloMiner | function: mine | message: No zero deposits allowed\");\r\n\r\n    uint reward = showReward(msg.sender);\r\n    reward = reward.add(depositAmount);\r\n\r\n    uint gapSize = getGapSize().add(depositAmount);\r\n\r\n    numerator[msg.sender] = reward;\r\n    denominator[msg.sender] = gapSize;\r\n    minimumReturn[msg.sender] = minimumReturn[msg.sender].add(depositAmount);\r\n    userBlocks[msg.sender] = getCurrentBlockNumber();\r\n\r\n    registerMiner();\r\n\r\n    burn(depositAmount);\r\n\r\n    mutex[msg.sender] = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function getReward(uint tokenAmount) isActive public virtual returns(bool success) {\r\n\r\n    require(!mutex[msg.sender]);\r\n    mutex[msg.sender] = true;\r\n\r\n    uint reward = showReward(msg.sender);\r\n\r\n    require(tokenAmount <= reward,\r\n      \"at: solo_miner.sol | contract: SoloMiner | function: getReward | message: Amount too big\");\r\n\r\n    reward = reward.sub(tokenAmount);\r\n\r\n    uint gapSize = getGapSize().sub(tokenAmount);\r\n\r\n    numerator[msg.sender] = reward;\r\n    denominator[msg.sender] = gapSize;\r\n    if (minimumReturn[msg.sender] >= tokenAmount) {\r\n      minimumReturn[msg.sender] = minimumReturn[msg.sender].sub(tokenAmount);\r\n    } else {\r\n      minimumReturn[msg.sender] = 0;\r\n    }\r\n    userBlocks[msg.sender] = getCurrentBlockNumber();\r\n\r\n    registerMiner();\r\n\r\n    mint(tokenAmount);\r\n\r\n    mutex[msg.sender] = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function getFullReward() isActive public virtual returns(bool success) {\r\n\r\n    require(!mutex[msg.sender]);\r\n    mutex[msg.sender] = true;\r\n\r\n    uint amt = showReward(msg.sender);\r\n\r\n    require(amt > 0,\r\n      \"at: solo_miner.sol | contract: SoloMiner | function: getFullReward | message: No rewards to give\");\r\n\r\n    require(getLastBlockNumber(msg.sender) > 0,\r\n      \"at: solo_miner.sol | contract: SoloMiner | function: getFullReward | message: Must mine first\");\r\n\r\n    numerator[msg.sender] = 0;\r\n    denominator[msg.sender] = 0;\r\n    minimumReturn[msg.sender] = 0;\r\n    userBlocks[msg.sender] = 0;\r\n\r\n    mint(amt);\r\n\r\n    mutex[msg.sender] = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  //should miner become inactive, we can still get our tokens back\r\n  function recoverOnly() external virtual returns(bool success) {\r\n\r\n    require(!mutex[msg.sender]);\r\n    mutex[msg.sender] = true;\r\n\r\n    require(!active,\r\n      \"at: solo_miner.sol | contract: SoloMiner | function: recoverOnly | message: Contract must be deactivated\");\r\n    require(minimumReturn[msg.sender] > 0,\r\n      \"at: solo_miner.sol | contract: SoloMiner | function: recoverOnly | message: You cannot recover a zero amount\");\r\n\r\n    uint amt = minimumReturn[msg.sender];\r\n    minimumReturn[msg.sender] = 0;\r\n    mint(amt);\r\n\r\n    mutex[msg.sender] = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  //in case you want to burn tokens and increase miner rewards\r\n  function burnMyTokens(uint tokenAmount) isActive public virtual returns(bool success) {\r\n\r\n    require(!mutex[msg.sender]);\r\n    mutex[msg.sender] = true;\r\n\r\n    currentConstant = currentConstant.sub(tokenAmount);\r\n    burn(tokenAmount);\r\n\r\n    mutex[msg.sender] = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  //+++++++++++ONLY OWNER++++++++++++++++\r\n  //----------SETTERS--------------------\r\n  function setNewTokenContract(address newTokenAddress) onlyOwner public virtual returns(bool success) {\r\n    tokenContract = newTokenAddress;\r\n    token = Token(newTokenAddress);\r\n    return true;\r\n  }\r\n  \r\n  function setNewRouterContract(address newRouterAddress) onlyOwner public virtual returns(bool success) {\r\n    routerContract = newRouterAddress;\r\n    router = Router(newRouterAddress);\r\n    return true;\r\n  }\r\n\r\n  function setRewardConstant(uint newConstant) onlyOwner public virtual returns(bool success) {\r\n    rewardConstant = newConstant;\r\n    return true;\r\n  }\r\n\r\n  function setInflationBuffer(uint newConstant) onlyOwner public virtual returns(bool success) {\r\n    inflationBuffer = newConstant;\r\n    return true;\r\n  }\r\n\r\n  function setCurrentConstant(uint newConstant) onlyOwner public virtual returns(bool success) {\r\n    currentConstant = newConstant;\r\n    return true;\r\n  }\r\n\r\n  function setTotalConstant(uint newConstant) onlyOwner public virtual returns(bool success) {\r\n    totalConstant = newConstant;\r\n    return true;\r\n  }\r\n\r\n  //----------OTHER--------------------\r\n  function flipSwitch() external onlyOwner returns(bool success) {\r\n    active = !active;\r\n    return true;\r\n  }\r\n\r\n  //+++++++++++PRIVATE++++++++++++++++++++   \r\n  function registerMiner() private {\r\n    if (miners[msg.sender] == 0) {\r\n      pivot = pivot.add(1);\r\n      miners[msg.sender] = pivot;\r\n      addressFromId[pivot] = msg.sender;\r\n    }\r\n  }\r\n\r\n  function showMyCurrentRewardTotal() private view returns(uint reward) {\r\n\r\n    if (denominator[msg.sender] == 0) {\r\n      return 0;\r\n    } else if (!active) {\r\n      return 0;\r\n    }\r\n\r\n    uint gapSize = getGapSize();\r\n    uint rewardSize = (numerator[msg.sender].mul(gapSize)).div(denominator[msg.sender]);\r\n\r\n    if (rewardSize < minimumReturn[msg.sender]) {\r\n      rewardSize = minimumReturn[msg.sender];\r\n    }\r\n    if (rewardSize > getGapSize()) {\r\n      rewardSize = getGapSize();\r\n    }\r\n\r\n    return rewardSize;\r\n  }\r\n\r\n  function burn(uint burnAmount) isActive private returns(bool success) {\r\n    require(burnAmount <= currentConstant,\r\n      \"at: solo_miner.sol | contract: SoloMiner | function: burn | message: You cannot burn more tokens than the existing current supply\");\r\n    require(burnAmount <= token.balanceOf(msg.sender),\r\n      \"at: solo_miner.sol | contract: SoloMiner | function: burn | message: You are trying to burn more than you own\");\r\n\r\n    address toAddress = address(0);\r\n    address[2] memory addresseArr = [msg.sender, toAddress];\r\n    uint[2] memory uintArr = [burnAmount, 0];\r\n\r\n    totalBurned = totalBurned.add(burnAmount);\r\n    currentConstant = currentConstant.sub(burnAmount);\r\n\r\n    router.extrenalRouterCall(\"burn\", addresseArr, uintArr);\r\n\r\n    return true;\r\n  }\r\n\r\n  function mint(uint mintAmount) isActive private returns(bool success) {\r\n    address fromAddress = address(0);\r\n    address[2] memory addresseArr = [fromAddress, msg.sender];\r\n    uint[2] memory uintArr = [mintAmount, 0];\r\n\r\n    if (inflationBuffer >= mintAmount && currentConstant >= mintAmount) {\r\n      inflationBuffer = inflationBuffer.sub(mintAmount);\r\n    } else {\r\n      currentConstant = currentConstant.add(mintAmount);\r\n    }\r\n\r\n    totalMinted = totalMinted.add(mintAmount);\r\n\r\n    router.extrenalRouterCall(\"mint\", addresseArr, uintArr);\r\n\r\n    return true;\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"burnMyTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipSwitch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAddressFromId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"minerAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentConstant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"routerAddress\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFullReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGapSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gapSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minerAddress\",\"type\":\"address\"}],\"name\":\"getLastBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPivot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastPivot\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardConstant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"routerAddress\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouterContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"burned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalConstant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"routerAddress\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"burned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minerAddress\",\"type\":\"address\"}],\"name\":\"getUserBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minerBlocks\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minerAddress\",\"type\":\"address\"}],\"name\":\"getUserDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minerDenominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minerAddress\",\"type\":\"address\"}],\"name\":\"getUserNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minerNumerator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getinflationBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"routerAddress\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"mine\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverOnly\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newConstant\",\"type\":\"uint256\"}],\"name\":\"setCurrentConstant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newConstant\",\"type\":\"uint256\"}],\"name\":\"setInflationBuffer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouterAddress\",\"type\":\"address\"}],\"name\":\"setNewRouterContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTokenAddress\",\"type\":\"address\"}],\"name\":\"setNewTokenContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newConstant\",\"type\":\"uint256\"}],\"name\":\"setRewardConstant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newConstant\",\"type\":\"uint256\"}],\"name\":\"setTotalConstant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minerAddress\",\"type\":\"address\"}],\"name\":\"showReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SoloMiner","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ce4809183a7a6d746477c09a713660e0e6d219c2803a1971f60cfbdf953ed9f1"}]}