{"status":"1","message":"OK","result":[{"SourceCode":"{\"SafeMath.sol\":{\"content\":\"pragma solidity 0.6.4;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"Splitter.sol\":{\"content\":\"pragma solidity 0.6.4;\\r\\n\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ninterface Token {\\r\\n    function symbol()\\r\\n    external\\r\\n    view\\r\\n    returns (string memory);\\r\\n    \\r\\n    function totalSupply()\\r\\n    external\\r\\n    view\\r\\n    returns (uint256);\\r\\n    \\r\\n    function balanceOf (address account)\\r\\n    external\\r\\n    view\\r\\n    returns (uint256);\\r\\n\\r\\n    function transfer (address recipient, uint256 amount)\\r\\n    external\\r\\n    returns (bool);\\r\\n}\\r\\n\\r\\ncontract Splitter {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    ///////////////////\\r\\n    //EVENTS//\\r\\n    ///////////////////\\r\\n\\r\\n    event DistributedToken(\\r\\n        uint256 timestamp,\\r\\n        address indexed senderAddress,\\r\\n        uint256 distributed,\\r\\n        string indexed tokenSymbol\\r\\n    );\\r\\n    \\r\\n    event DistributedEth(\\r\\n        uint256 timestamp,\\r\\n        address indexed senderAddress,\\r\\n        uint256 distributed\\r\\n    );\\r\\n\\r\\n    /////////////////////\\r\\n    //SETUP//\\r\\n    /////////////////////\\r\\n    address[] public tokens;\\r\\n    uint256 public _maxTokens = 5;\\r\\n    mapping(address =\\u003e bool) public tokenAdded;\\r\\n    \\r\\n    uint256 public _gasLimit = 21000;\\r\\n    \\r\\n    address payable internal _p1 = 0x6c28dc6529ba78fA3a0FEf408F2c982b074E41A5;//19.5%\\r\\n    address payable internal _p2 = 0xe551072153c02fa33d4903CAb0435Fb86F1a80cb;//19.5%\\r\\n    address payable internal _p3 = 0x0CC501fFd20e865d85867Fb5fbFb1259D1CAfD13;//11%\\r\\n    address payable internal _p4 = 0x47705B509A4Fe6a0237c975F81030DAC5898Dc06;//10%\\r\\n    address payable internal _p5 = 0xb9F8e9dad5D985dF35036C61B6Aded2ad08bd53f;//10%\\r\\n    address payable internal _p6 = 0x4c7b5cB8240Dc5e5437FEf4AcC6445e47F3706A6;//5%\\r\\n    address payable internal _p7 = 0xe2Ef81dCe4a639187B5c550da4A2ad89DB434C00;//5%\\r\\n    address payable internal _p8 = 0xeC28143Fe252d0655C02768841Af4a7df1178ece;//3%\\r\\n    address payable internal _p9 = 0xD6968Da8725D30738f926B9DE940a997C16b9a86;//3%\\r\\n    address payable internal _p10 = 0x454f203260a74C0A8B5c0a78fbA5B4e8B31dCC63;//3%\\r\\n    address payable internal _p11 = 0x92CA5D94704089Bc7a75Cd1dF5bBDb2CaA2D6855;//3%\\r\\n    address payable internal _p12 = 0x5AFC90317463843b46c0645bf3fD1A82Bd3D8cFd;//3%\\r\\n    address payable internal _p13 = 0xF80A891c1A7600dDd84b1F9d54E0b092610Ed804;//2%\\r\\n    address payable internal _p14 = 0xf40e89F1e52A6b5e71B0e18365d539F5E424306f;//1%\\r\\n    address payable internal _p15 = 0x65fBE695FE29897ADdECA149aBc3c8eb742EB204;//1%\\r\\n    address payable internal _p16 = 0x860303910AF2519dE0945683c69620593818bC01;//1%\\r\\n\\r\\n    mapping(address =\\u003e bool) private admins;\\r\\n\\r\\n    modifier onlyAdmins(){\\r\\n        require(admins[msg.sender], \\\"not an admin\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    constructor() public {\\r\\n        admins[_p1] = true;\\r\\n        admins[_p2] = true;\\r\\n        admins[_p3] = true;\\r\\n    }\\r\\n    \\r\\n    ////////////////////\\r\\n    //DISTRIBUTE//\\r\\n    ////////////////////\\r\\n\\r\\n    //distribute all pre-defined tokens and eth\\r\\n    function distributeAll() public {\\r\\n        for(uint i = 0; i \\u003c tokens.length; i++){\\r\\n            if(Token(tokens[i]).balanceOf(address(this)) \\u003e 99){\\r\\n                distributeToken(tokens[i]);\\r\\n            }\\r\\n        }\\r\\n        if(address(this).balance \\u003e 99){\\r\\n            distributeEth();   \\r\\n        }\\r\\n    }\\r\\n\\r\\n    //distribute any token in contract via address\\r\\n    function distributeToken(address tokenAddress) public {\\r\\n        Token _token = Token(tokenAddress);\\r\\n        //get balance \\r\\n        uint256 balance = _token.balanceOf(address(this));\\r\\n        require(balance \\u003e 199, \\\"value too low to distribute\\\");\\r\\n        //distribute\\r\\n        uint256 percent = balance.div(100);\\r\\n        uint256 half_percent = balance.div(200);\\r\\n        uint256 two_percent = balance.mul(2).div(100);\\r\\n        uint256 three_percent = balance.mul(3).div(100);\\r\\n        uint256 five_percent = balance.mul(5).div(100);\\r\\n        uint256 ten_percent = balance.mul(10).div(100);\\r\\n        uint256 eleven_percent = balance.mul(11).div(100);\\r\\n        uint256 nineteen_percent = balance.mul(19).div(100);\\r\\n        require(_token.transfer(_p1, nineteen_percent.add(half_percent)));\\r\\n        require(_token.transfer(_p2, nineteen_percent.add(half_percent)));\\r\\n        require(_token.transfer(_p3, eleven_percent));\\r\\n        require(_token.transfer(_p4, ten_percent));\\r\\n        require(_token.transfer(_p5, ten_percent));\\r\\n        require(_token.transfer(_p6, five_percent));\\r\\n        require(_token.transfer(_p7, five_percent));\\r\\n        require(_token.transfer(_p8, three_percent));\\r\\n        require(_token.transfer(_p9, three_percent));\\r\\n        require(_token.transfer(_p10, three_percent));\\r\\n        require(_token.transfer(_p11, three_percent));\\r\\n        require(_token.transfer(_p12, three_percent));\\r\\n        require(_token.transfer(_p13, two_percent));\\r\\n        require(_token.transfer(_p14, percent));\\r\\n        require(_token.transfer(_p15, percent));\\r\\n        require(_token.transfer(_p16, percent));\\r\\n        emit DistributedToken(now, msg.sender, balance, _token.symbol());\\r\\n    }\\r\\n\\r\\n    //distribute ETH in contract\\r\\n    function distributeEth() public payable {\\r\\n        uint256 balance = 0;\\r\\n        if(msg.value \\u003e 0){\\r\\n            balance = msg.value.add(address(this).balance);\\r\\n        }\\r\\n        else{\\r\\n            balance = address(this).balance;\\r\\n        }\\r\\n        require(balance \\u003e 199, \\\"value too low to distribute\\\");\\r\\n        bool success = false;\\r\\n        //distribute\\r\\n        uint256 percent = balance.div(100);\\r\\n        uint256 half_percent = balance.div(200);\\r\\n        uint256 two_percent = balance.mul(2).div(100);\\r\\n        uint256 three_percent = balance.mul(3).div(100);\\r\\n        uint256 five_percent = balance.mul(5).div(100);\\r\\n        uint256 ten_percent = balance.mul(10).div(100);\\r\\n        uint256 eleven_percent = balance.mul(11).div(100);\\r\\n        uint256 nineteen_percent = balance.mul(19).div(100);\\r\\n        (success, ) =  _p1.call{value:nineteen_percent.add(half_percent)}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p2.call{value:nineteen_percent.add(half_percent)}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p3.call{value:eleven_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p4.call{value:ten_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p5.call{value:ten_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p6.call{value:five_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p7.call{value:five_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p8.call{value:three_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p9.call{value:three_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p10.call{value:three_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p11.call{value:three_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p12.call{value:three_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p13.call{value:two_percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p14.call{value:percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p15.call{value:percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        (success, ) =  _p16.call{value:percent}{gas:_gasLimit}(\\u0027\\u0027);\\r\\n        require(success, \\\"Transfer failed\\\");\\r\\n        emit DistributedEth(now, msg.sender, balance);\\r\\n    }\\r\\n\\r\\n    //optional fallback for eth sent to contract - auto distribute on payment\\r\\n    receive() external payable {\\r\\n        //distributeEth();    \\r\\n    }\\r\\n\\r\\n    /////////////////\\r\\n    //MUTABLE//\\r\\n    /////////////////\\r\\n\\r\\n//add new token to splitter - used for distribute all\\r\\n    function addToken(address tokenAddress)\\r\\n        public\\r\\n        onlyAdmins\\r\\n    {\\r\\n        require(tokenAddress != address(0), \\\"invalid address\\\");\\r\\n        require(Token(tokenAddress).totalSupply() \\u003e 0, \\\"invalid contract\\\");\\r\\n        require(!tokenAdded[tokenAddress], \\\"token already exists\\\");\\r\\n        require(tokens.length \\u003c _maxTokens, \\\"cannot add more tokens than _maxTokens\\\");\\r\\n        tokenAdded[tokenAddress] = true;\\r\\n        tokens.push(tokenAddress);\\r\\n    }\\r\\n\\r\\n//define gas limit for eth distribution per transfer\\r\\n    function setGasLimit(uint gasLimit)\\r\\n        public\\r\\n        onlyAdmins\\r\\n    {\\r\\n        require(gasLimit \\u003e 0, \\\"gasLimit must be greater than 0\\\");\\r\\n        _gasLimit = gasLimit;\\r\\n    }\\r\\n    \\r\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributed\",\"type\":\"uint256\"}],\"name\":\"DistributedEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"name\":\"DistributedToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_gasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"distributeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Splitter","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9900c952ad1af9336a4b26986b71674dd11229f6de6be6fefd3311cfb31f053d"}]}