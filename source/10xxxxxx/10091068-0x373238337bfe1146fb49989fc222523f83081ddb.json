{"status":"1","message":"OK","result":[{"SourceCode":"// DsrManager.sol\r\n// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.12;\r\n\r\ncontract VatLike {\r\n    function hope(address) external;\r\n}\r\n\r\ncontract PotLike {\r\n    function vat() external view returns (address);\r\n    function chi() external view returns (uint256);\r\n    function rho() external view returns (uint256);\r\n    function drip() external returns (uint256);\r\n    function join(uint256) external;\r\n    function exit(uint256) external;\r\n}\r\n\r\ncontract JoinLike {\r\n    function dai() external view returns (address);\r\n    function join(address, uint256) external;\r\n    function exit(address, uint256) external;\r\n}\r\n\r\ncontract GemLike {\r\n    function transferFrom(address,address,uint256) external returns (bool);\r\n    function approve(address,uint256) external returns (bool);\r\n}\r\n\r\ncontract DsrManager {\r\n    PotLike  public pot;\r\n    GemLike  public dai;\r\n    JoinLike public daiJoin;\r\n\r\n    uint256 public supply;\r\n\r\n    mapping (address => uint256) public pieOf;\r\n\r\n    event Join(address indexed dst, uint256 wad);\r\n    event Exit(address indexed dst, uint256 wad);\r\n\r\n    uint256 constant RAY = 10 ** 27;\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        // always rounds down\r\n        z = mul(x, y) / RAY;\r\n    }\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        // always rounds down\r\n        z = mul(x, RAY) / y;\r\n    }\r\n    function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        // always rounds up\r\n        z = add(mul(x, RAY), sub(y, 1)) / y;\r\n    }\r\n\r\n    constructor(address pot_, address daiJoin_) public {\r\n        pot = PotLike(pot_);\r\n        daiJoin = JoinLike(daiJoin_);\r\n        dai = GemLike(daiJoin.dai());\r\n\r\n        VatLike vat = VatLike(pot.vat());\r\n        vat.hope(address(daiJoin));\r\n        vat.hope(address(pot));\r\n        dai.approve(address(daiJoin), uint256(-1));\r\n    }\r\n\r\n    function daiBalance(address usr) external returns (uint256 wad) {\r\n        uint256 chi = (now > pot.rho()) ? pot.drip() : pot.chi();\r\n        wad = rmul(chi, pieOf[usr]);\r\n    }\r\n\r\n    // wad is denominated in dai\r\n    function join(address dst, uint256 wad) external {\r\n        uint256 chi = (now > pot.rho()) ? pot.drip() : pot.chi();\r\n        uint256 pie = rdiv(wad, chi);\r\n        pieOf[dst] = add(pieOf[dst], pie);\r\n        supply = add(supply, pie);\r\n\r\n        dai.transferFrom(msg.sender, address(this), wad);\r\n        daiJoin.join(address(this), wad);\r\n        pot.join(pie);\r\n        emit Join(dst, wad);\r\n    }\r\n\r\n    // wad is denominated in dai\r\n    function exit(address dst, uint256 wad) external {\r\n        uint256 chi = (now > pot.rho()) ? pot.drip() : pot.chi();\r\n        uint256 pie = rdivup(wad, chi);\r\n\r\n        require(pieOf[msg.sender] >= pie, \"insufficient-balance\");\r\n\r\n        pieOf[msg.sender] = sub(pieOf[msg.sender], pie);\r\n        supply = sub(supply, pie);\r\n\r\n        pot.exit(pie);\r\n        uint256 amt = rmul(chi, pie);\r\n        daiJoin.exit(dst, amt);\r\n        emit Exit(dst, amt);\r\n    }\r\n\r\n    function exitAll(address dst) external {\r\n        uint256 chi = (now > pot.rho()) ? pot.drip() : pot.chi();\r\n        uint256 pie = pieOf[msg.sender];\r\n\r\n        pieOf[msg.sender] = 0;\r\n        supply = sub(supply, pie);\r\n\r\n        pot.exit(pie);\r\n        uint256 amt = rmul(chi, pie);\r\n        daiJoin.exit(dst, amt);\r\n        emit Exit(dst, amt);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pot_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"daiJoin_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Exit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Join\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract GemLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"daiBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiJoin\",\"outputs\":[{\"internalType\":\"contract JoinLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"exitAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pieOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pot\",\"outputs\":[{\"internalType\":\"contract PotLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DsrManager","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000197e90f9fad81970ba7976f33cbd77088e5d7cf70000000000000000000000009759a6ac90977b93b58547b4a71c78317f391a28","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://13f365be0e6ec210fdf1e7f878cd6873c906ef88d752a7929ca5a3e1a74c0a9c"}]}