{"status":"1","message":"OK","result":[{"SourceCode":"{\"BerezkaTokenAdapterGovernance.sol\":{\"content\":\"// Copyright (C) 2020 Easy Chain. \\u003chttps://easychain.tech\\u003e\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nimport { EnumerableSet } from \\\"./EnumerableSet.sol\\\";\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev BerezkaTokenAdapterGovernance contract.\\n * Main function of this contract is to maintains a Structure of BerezkaDAO\\n * @author Vasin Denis \\u003cdenis.vasin@easychain.tech\\u003e\\n */\\ncontract BerezkaTokenAdapterGovernance is Ownable() {\\n\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /// @dev This is a set of plain assets (ERC20) used by DAO. \\n    /// This list also include addresses of Uniswap/Balancer tokenized pools.\\n    EnumerableSet.AddressSet private tokens;\\n\\n    /// @dev This is a set of debt protocol adapters that return debt in ETH\\n    EnumerableSet.AddressSet private ethProtocols;\\n\\n    /// @dev This is a set of debt protocol adapters that return debt for ERC20 tokens\\n    EnumerableSet.AddressSet private protocols;\\n\\n    /// @dev This is a mapping from Berezka DAO product to corresponding Vault addresses\\n    mapping(address =\\u003e address[]) private productVaults;\\n\\n    constructor(address[] memory _tokens, address[] memory _protocols, address[] memory _ethProtocols) public {\\n        _add(protocols, _protocols);\\n        _add(tokens, _tokens);\\n        _add(ethProtocols, _ethProtocols);\\n    }\\n\\n    // Modification functions (all only by owner)\\n\\n    function setProductVaults(address _product, address[] memory _vaults) public onlyOwner() {\\n        require(_product != address(0), \\\"_product is 0\\\");\\n        require(_vaults.length \\u003e 0, \\\"_vaults.length should be \\u003e 0\\\");\\n\\n        productVaults[_product] = _vaults;\\n    }\\n\\n    function removeProduct(address _product) public onlyOwner() {\\n        require(_product != address(0), \\\"_product is 0\\\");\\n\\n        delete productVaults[_product];\\n    }\\n\\n    function addTokens(address[] memory _tokens) public onlyOwner() {\\n        _add(tokens, _tokens);\\n    }\\n\\n    function addProtocols(address[] memory _protocols) public onlyOwner() {\\n        _add(protocols, _protocols);\\n    }\\n\\n    function removeTokens(address[] memory _tokens) public onlyOwner() {\\n        _remove(tokens, _tokens);\\n    }\\n\\n    function removeProtocols(address[] memory _protocols) public onlyOwner() {\\n        _remove(protocols, _protocols);\\n    }\\n\\n    function removeEthProtocols(address[] memory _ethProtocols) public onlyOwner() {\\n        _remove(ethProtocols, _ethProtocols);\\n    }\\n\\n    // View functions\\n\\n    function listTokens() external view returns (address[] memory) {\\n        return _list(tokens);\\n    }\\n\\n    function listProtocols() external view returns (address[] memory) {\\n        return _list(protocols);\\n    }\\n\\n    function listEthProtocols() external view returns (address[] memory) {\\n        return _list(ethProtocols);\\n    }\\n\\n    function getVaults(address _token) external view returns (address[] memory) {\\n        return productVaults[_token];\\n    }\\n\\n    // Internal functions\\n\\n    function _add(EnumerableSet.AddressSet storage _set, address[] memory _addresses) internal {\\n        for (uint i = 0; i \\u003c _addresses.length; i++) {\\n            _set.add(_addresses[i]);\\n        }\\n    }\\n\\n    function _remove(EnumerableSet.AddressSet storage _set, address[] memory _addresses) internal {\\n        for (uint i = 0; i \\u003c _addresses.length; i++) {\\n            _set.remove(_addresses[i]);\\n        }\\n    }\\n\\n    function _list(EnumerableSet.AddressSet storage _set) internal view returns(address[] memory) {\\n        address[] memory result = new address[](_set.length());\\n        for (uint i = 0; i \\u003c _set.length(); i++) {\\n            result[i] = _set.at(i);\\n        }\\n        return result;\\n    }\\n}\\n\"},\"EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.5;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"// Copyright (C) 2020 Zerion Inc. \\u003chttps://zerion.io\\u003e\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see \\u003chttps://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.6.5;\\npragma experimental ABIEncoderV2;\\n\\n\\nabstract contract Ownable {\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"O: onlyOwner function!\\\");\\n        _;\\n    }\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @notice Initializes owner variable with msg.sender address.\\n     */\\n    constructor() internal {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @notice Transfers ownership to the desired address.\\n     * The function is callable only by the owner.\\n     */\\n    function transferOwnership(address _owner) external onlyOwner {\\n        require(_owner != address(0), \\\"O: new owner is the zero address!\\\");\\n        emit OwnershipTransferred(owner, _owner);\\n        owner = _owner;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_protocols\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_ethProtocols\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_protocols\",\"type\":\"address[]\"}],\"name\":\"addProtocols\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"addTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getVaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listEthProtocols\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listProtocols\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_ethProtocols\",\"type\":\"address[]\"}],\"name\":\"removeEthProtocols\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_product\",\"type\":\"address\"}],\"name\":\"removeProduct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_protocols\",\"type\":\"address[]\"}],\"name\":\"removeProtocols\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"removeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_product\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_vaults\",\"type\":\"address[]\"}],\"name\":\"setProductVaults\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BerezkaTokenAdapterGovernance","CompilerVersion":"v0.6.5+commit.f956cc89","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000004a000000000000000000000000000000000000000000000000000000000000005200000000000000000000000000000000000000000000000000000000000000021000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000085d4780b73119b644ae5ecd22b3760000000000000000000000004fabb145d64652a948d72533023f6e7a623c7c530000000000000000000000008e870d67f660d95d5be530380d0ec0bd388289e100000000000000000000000057ab1ec28d129707052df4df418d58a2d46d5f510000000000000000000000009f8f72aa9304c8b593d555f12ef6589cc3a579a2000000000000000000000000e41d2489571d322189246dafa5ebde1f4699f4980000000000000000000000000d8775f648430679a709e98d2b0cb6250d2887ef000000000000000000000000c11b1268c1a384e55c48c2391d8d480264a3a7f4000000000000000000000000eb4c2781e4eba804ce9a9803c67d0893436bb27d0000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e00000000000000000000000080fb784b7ed66730e8b1dbd9820afd29931aab03000000000000000000000000c00e94cb662c3520282e6f5717214004a7f26888000000000000000000000000ba100000625a3754423978a60c9317c58a424e3d000000000000000000000000dd974d5c2e2928dea5f71b9825b8b646686bd200000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000c011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f000000000000000000000000f629cbd94d3791c9250152bd8dfbdf380e2a3b9c0000000000000000000000000000000000b3f879cb30fe243b4dfee438691c0400000000000000000000000004fa0d235c4abf4bcf4787af4cf447de572ef828000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd520000000000000000000000006b3595068778dd592e39a122f4f5a5cf09c90fe20000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000001f9840a85d5af5bf1d1762f925bdaddc4201f9840000000000000000000000000000000000004946c0e9f43f4dee607b0ef1fa1c000000000000000000000000b4e16d0168e52d35cacd2c6185b44281ec28c9dc0000000000000000000000003041cbd36888becc7bbcbc0045e3b1f144466f5f000000000000000000000000e036cce08cf4e23d33bc6b18e53caf532afa85130000000000000000000000005dbcf33d8c2e976c6b560249878e6f1491bca25c000000000000000000000000df5e0e81dff6faf3a7e52ba697820c5e32d806a80000000000000000000000009fc689ccada600b6df723d9e47d84d76664a1f230000000000000000000000000000000000000000000000000000000000000003000000000000000000000000ae61b0d0a562e5c1daf9c1ded4a8fd6a770b639a00000000000000000000000030f0bb7556159b0e812de4af7023dacfdd4f7110000000000000000000000000bf3fc291876707b2d0c8fc49bcd76fae00219d370000000000000000000000000000000000000000000000000000000000000001000000000000000000000000525a4259435682ab0d4bb6c8f0cdee25f5b6cd26","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cfcb7d8bb1995a251c15e1c2b0096b75029c359cc9bf3d17e0adc843fcc75504"}]}