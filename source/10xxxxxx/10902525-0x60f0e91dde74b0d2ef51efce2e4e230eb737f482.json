{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.12;\r\n\r\nlibrary SafeMath {\r\n   \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;}\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");}\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;}\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {return 0;}\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;}\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");}\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;}\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");}\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;}\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface Uniswap{\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\ninterface Kye {\r\n    function routerAddress() external view returns (address);\r\n    function primary() external view returns (address);\r\n}\r\n\r\ninterface Router {\r\n    function mint(address tokenAddress, uint toMint) external;\r\n}\r\n\r\ncontract Routerable{\r\n    \r\n    address private constant _KYEADDRESS = 0xD5A4dc51229774223e288528E03192e2342bDA00;\r\n    \r\n    function kyeAddress() public pure returns (address) {\r\n        return _KYEADDRESS;\r\n    }\r\n    \r\n    function routerAddress() public view returns (address payable) {\r\n        return toPayable( Kye(kyeAddress()).routerAddress() );\r\n    }\r\n    \r\n    function primary() public view returns (address ) {\r\n        return Kye(kyeAddress()).primary() ;\r\n    }\r\n    \r\n    modifier onlyRouter() {\r\n        require(msg.sender == routerAddress(), \"Caller is not Router\");\r\n        _;\r\n    }\r\n    \r\n    function toPayable(address input) internal pure returns (address payable){\r\n        return address(uint160(input));\r\n    }\r\n}\r\n\r\ninterface Staker {\r\n    function viewLPTokenAmount(address tokenAddress, address who) external view returns(uint);\r\n}\r\n\r\ncontract Minter is Routerable{\r\n    \r\n    using SafeMath for uint256;\r\n   \r\n    address constant public UNIROUTER         = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address constant public FACTORY           = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n    address          public WETHAddress       = Uniswap(UNIROUTER).WETH();\r\n    \r\n    mapping (address => mapping (address => bool)) public blacklisted;\r\n    \r\n    address staker1 = 0xCe90991255932cE3A19defBb288370023d264369;\r\n    address staker2 = 0x62A3bcF9E0163B34ffE925C0a20515a558e35dB5;\r\n    address staker3 = 0x0954b0165a31d24D6023fd4151464D84Ec87cD10;\r\n    \r\n    bool On = false;\r\n    \r\n    function mint(address token) public {\r\n        require(On                              || msg.sender == primary() );\r\n        require(!blacklisted[msg.sender][token] || msg.sender == primary(), \"You already called the function\"); //only call the function once per token\r\n        blacklisted[msg.sender][token] = true; //cant call function again per token\r\n        \r\n        //lptokens user has\r\n        uint lpAmount = Staker(staker1).viewLPTokenAmount(token, msg.sender) +\r\n                        Staker(staker2).viewLPTokenAmount(token, msg.sender) +\r\n                        Staker(staker3).viewLPTokenAmount(token, msg.sender);\r\n        \r\n        address poolAddress = Uniswap(FACTORY).getPair(token, WETHAddress);\r\n        \r\n        uint lpTokenTotal = IERC20(poolAddress).totalSupply();      //lptokens total\r\n        uint tokenInUniswap = IERC20(token).balanceOf(poolAddress); //token in uniswap\r\n        \r\n        uint usersTokens = (tokenInUniswap.mul(lpAmount)).div(lpTokenTotal); //token amount in uniswap that is the users\r\n        usersTokens = usersTokens*2; //value amount that user has in lp tokens\r\n        \r\n        Router(routerAddress()).mint(token, usersTokens);\r\n    }\r\n    \r\n    function turnOn() public {\r\n        require(msg.sender == primary());\r\n        On = true;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNIROUTER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETHAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"primary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"turnOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Minter","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://23af502610605d7f0d265314a2ab99425d80ee116efdcdafb8b7721c8bdc4dd0"}]}