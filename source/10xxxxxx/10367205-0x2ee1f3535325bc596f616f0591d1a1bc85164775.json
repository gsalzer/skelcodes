{"status":"1","message":"OK","result":[{"SourceCode":"{\"EternalStorageData.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n * @author Quant Network\\n * @title EternalStorage\\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\\n */\\ncontract EternalStorage {\\n\\n  mapping(bytes32 =\\u003e bool) internal boolStorage;\\n  mapping(bytes32 =\\u003e address) internal addressStorage;\\n  mapping(bytes32 =\\u003e string) internal stringStorage;\\n  mapping(bytes32 =\\u003e bytes) internal bytesStorage;\\n\\n  mapping(bytes32 =\\u003e bytes1) internal bytes1Storage;\\n  mapping(bytes32 =\\u003e bytes2) internal bytes2Storage;\\n  mapping(bytes32 =\\u003e bytes4) internal bytes4Storage;\\n  mapping(bytes32 =\\u003e bytes8) internal bytes8Storage;\\n  mapping(bytes32 =\\u003e bytes16) internal bytes16Storage;\\n  mapping(bytes32 =\\u003e bytes32) internal bytes32Storage;\\n  \\n  mapping(bytes32 =\\u003e int8) internal int8Storage;\\n  mapping(bytes32 =\\u003e int16) internal int16Storage;\\n  mapping(bytes32 =\\u003e int32) internal int32Storage;\\n  mapping(bytes32 =\\u003e int64) internal int64Storage;\\n  mapping(bytes32 =\\u003e int128) internal int128Storage;\\n  mapping(bytes32 =\\u003e int256) internal int256Storage;\\n  \\n  mapping(bytes32 =\\u003e uint8) internal uint8Storage;\\n  mapping(bytes32 =\\u003e uint16) internal uint16Storage;\\n  mapping(bytes32 =\\u003e uint32) internal uint32Storage;\\n  mapping(bytes32 =\\u003e uint64) internal uint64Storage;\\n  mapping(bytes32 =\\u003e uint128) internal uint128Storage;\\n  mapping(bytes32 =\\u003e uint256) internal uint256Storage;\\n\\n\\n}\"},\"Proxy.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./EternalStorageData.sol\\\";\\n\\n/**\\n * @title EternalStorage\\n * @dev This is a proxy pattern that holds all the necessary state variables to carry out the storage of any contract.\\n */\\ncontract EternalStorageProxy is EternalStorage {\\n    \\n    /**\\n     * @param contractLogic - the address of the first implementation of this contract\\u0027s logic\\n     */\\n    constructor(address contractLogic) public {\\n        // save the code address\\n        addressStorage[keccak256(\\u0027proxy.implementation\\u0027)] = contractLogic; \\n    }\\n    \\n    /**\\n     * This function runs every time a function is invoked on this contract, it is the \\\"fallback function\\\"\\n     */\\n    function() external payable {\\n        \\n        //get the address of the contract holding the logic implementation\\n        address contractLogic = addressStorage[keccak256(\\u0027proxy.implementation\\u0027)];\\n        assembly { \\n            //copy the data embedded in the function call that triggered the fallback\\n            calldatacopy(0x0, 0x0, calldatasize)\\n            //delegate this call to the linked contract\\n            let success := delegatecall(sub(gas, 10000), contractLogic, 0x0, calldatasize, 0, 0)\\n            let retSz := returndatasize\\n            //get the returned data\\n            returndatacopy(0, 0, retSz)\\n            switch success\\n            case 0 {\\n                revert(0, retSz)\\n            }\\n            default {\\n                return(0, retSz)\\n            }\\n        }\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractLogic\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"EternalStorageProxy","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000bd996392e1765bf9bff5b20d891e1bf498a59b8","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"1","Implementation":"0x0bd996392e1765bf9bff5b20d891e1bf498a59b8","SwarmSource":"bzzr://7a7847732b508c4552f2c302f7d7a82333fe137a7c14be1fb55cc889555d568b"}]}