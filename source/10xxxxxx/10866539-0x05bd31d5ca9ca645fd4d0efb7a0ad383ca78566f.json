{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/InterFaces/IAuctionRegistery.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract AuctionRegisteryContracts {\r\n    bytes32 internal constant MAIN_TOKEN = \"MAIN_TOKEN\";\r\n    bytes32 internal constant ETN_TOKEN = \"ETN_TOKEN\";\r\n    bytes32 internal constant STOCK_TOKEN = \"STOCK_TOKEN\";\r\n    bytes32 internal constant WHITE_LIST = \"WHITE_LIST\";\r\n    bytes32 internal constant AUCTION = \"AUCTION\";\r\n    bytes32 internal constant AUCTION_PROTECTION = \"AUCTION_PROTECTION\";\r\n    bytes32 internal constant LIQUIDITY = \"LIQUIDITY\";\r\n    bytes32 internal constant CURRENCY = \"CURRENCY\";\r\n    bytes32 internal constant VAULT = \"VAULT\";\r\n    bytes32 internal constant CONTRIBUTION_TRIGGER = \"CONTRIBUTION_TRIGGER\";\r\n    bytes32 internal constant COMPANY_FUND_WALLET = \"COMPANY_FUND_WALLET\";\r\n    bytes32 internal constant SMART_SWAP = \"SMART_SWAP\";\r\n    bytes32 internal constant SMART_SWAP_P2P = \"SMART_SWAP_P2P\";\r\n    bytes32 internal constant ESCROW = \"ESCROW\";\r\n}\r\n\r\ninterface IAuctionRegistery {\r\n    function getAddressOf(bytes32 _contractName)\r\n        external\r\n        view\r\n        returns (address payable);\r\n}\r\n\r\n// File: contracts/Protection/ProtectionStorage.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ncontract ProtectionStorage {\r\n    \r\n    IAuctionRegistery public contractsRegistry;\r\n\r\n    address payable public vaultAddress;\r\n    address payable public auctionAddress;\r\n    address payable public triggerAddress;\r\n    address payable public mainTokenAddress;\r\n    address payable public companyFundWalletAddress;\r\n    address payable public whiteListAddress;\r\n    \r\n    // timestamp for address where first lock happen\r\n    mapping(address => uint256) public lockedOn;\r\n\r\n    mapping(address => mapping(address => uint256)) public lockedFunds;\r\n\r\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public currentLockedFunds;\r\n\r\n    mapping(address => uint256) public lockedTokens;\r\n    \r\n    \r\n    event TokenUnLocked(address indexed _from, uint256 _tokenAmount);\r\n\r\n    event InvestMentCancelled(address indexed _from, uint256 _tokenAmount);\r\n\r\n    event FundLocked(address _token, address indexed _which, uint256 _amount);\r\n\r\n    event FundTransfer(address indexed _to, address _token, uint256 _amount);\r\n    \r\n    // We track Token only transfer by auction or downside\r\n    // Reason for tracking this bcz someone can send token direclty\r\n\r\n    uint256 public constant PERCENT_NOMINATOR = 10**6;\r\n\r\n    uint256 public constant DECIMAL_NOMINATOR = 10**18;\r\n\r\n    uint256 public totalTokenAmount;\r\n\r\n    uint256 public stackRoundId;\r\n\r\n    mapping(uint256 => uint256) dayWiseRatio;\r\n\r\n    mapping(address => uint256) lastRound;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) roundWiseToken;\r\n\r\n    mapping(address => uint256) stackBalance;\r\n    \r\n    uint256 public tokenLockDuration;\r\n    \r\n    mapping(address => bool) public unLockBlock;\r\n\r\n    uint256 public vaultRatio;\r\n    \r\n    event StackAdded(\r\n        uint256 indexed _roundId,\r\n        address indexed _whom,\r\n        uint256 _amount\r\n    );\r\n\r\n    event StackRemoved(\r\n        uint256 indexed _roundId,\r\n        address indexed _whom,\r\n        uint256 _amount\r\n    );\r\n}\r\n\r\n// File: contracts/common/Constant.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract Constant {\r\n    string constant ERR_CONTRACT_SELF_ADDRESS = \"ERR_CONTRACT_SELF_ADDRESS\";\r\n\r\n    string constant ERR_ZERO_ADDRESS = \"ERR_ZERO_ADDRESS\";\r\n\r\n    string constant ERR_NOT_OWN_ADDRESS = \"ERR_NOT_OWN_ADDRESS\";\r\n\r\n    string constant ERR_VALUE_IS_ZERO = \"ERR_VALUE_IS_ZERO\";\r\n\r\n    string constant ERR_SAME_ADDRESS = \"ERR_SAME_ADDRESS\";\r\n\r\n    string constant ERR_AUTHORIZED_ADDRESS_ONLY = \"ERR_AUTHORIZED_ADDRESS_ONLY\";\r\n\r\n    modifier notOwnAddress(address _which) {\r\n        require(msg.sender != _which, ERR_NOT_OWN_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // validates an address is not zero\r\n    modifier notZeroAddress(address _which) {\r\n        require(_which != address(0), ERR_ZERO_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThisAddress(address _which) {\r\n        require(_which != address(this), ERR_CONTRACT_SELF_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    modifier notZeroValue(uint256 _value) {\r\n        require(_value > 0, ERR_VALUE_IS_ZERO);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/common/ProxyOwnable.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\ncontract ProxyOwnable is Constant {\r\n    \r\n    address public primaryOwner;\r\n\r\n    address public authorityAddress;\r\n\r\n    address public newAuthorityAddress;\r\n\r\n    address public systemAddress;\r\n    \r\n    bool public isOwnerInitialize = false;\r\n\r\n    event OwnershipTransferred(\r\n        string ownerType,\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    \r\n    event AuthorityAddressChnageCall(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the `primaryOwner` and `systemAddress` and '_multisigAddress'\r\n     * account.\r\n     */\r\n\r\n    function initializeOwner(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress\r\n    ) internal notZeroAddress(_primaryOwner) notZeroAddress(_systemAddress) notZeroAddress(_authorityAddress) {\r\n        \r\n        require(!isOwnerInitialize,\"ERR_OWNER_INTIALIZED_ALREADY\");\r\n        \r\n        require(_primaryOwner != _systemAddress, ERR_SAME_ADDRESS);\r\n        \r\n        require(_systemAddress != _authorityAddress, ERR_SAME_ADDRESS);\r\n        \r\n        require(_primaryOwner != _authorityAddress, ERR_SAME_ADDRESS);\r\n        \r\n        primaryOwner = _primaryOwner;\r\n        systemAddress = _systemAddress;\r\n        authorityAddress = _authorityAddress;\r\n        isOwnerInitialize = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == primaryOwner, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    modifier onlySystem() {\r\n        require(msg.sender == systemAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOneOfOnwer() {\r\n        require(\r\n            msg.sender == primaryOwner || msg.sender == systemAddress,\r\n            ERR_AUTHORIZED_ADDRESS_ONLY\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == authorityAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev change primary ownership governance \r\n     */\r\n    function changePrimaryOwner()\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        emit OwnershipTransferred(\"PRIMARY_OWNER\", primaryOwner, authorityAddress);\r\n        primaryOwner = authorityAddress;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change system address\r\n     * @param _which The address to which is new system address\r\n     */\r\n    function changeSystemAddress(address _which)\r\n        public\r\n        onlyAuthorized()\r\n        notThisAddress(_which)\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _which != systemAddress &&\r\n                _which != authorityAddress &&\r\n                _which != primaryOwner,\r\n            ERR_SAME_ADDRESS\r\n        );\r\n        emit OwnershipTransferred(\"SYSTEM_ADDRESS\", systemAddress, _which);\r\n        systemAddress = _which;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change system address\r\n     * @param _which The address to which is new Authority address\r\n     */\r\n    function changeAuthorityAddress(address _which)\r\n        public\r\n        onlyAuthorized()\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _which != systemAddress &&\r\n                _which != authorityAddress,\r\n            ERR_SAME_ADDRESS\r\n        );\r\n        newAuthorityAddress = _which;\r\n        return true;\r\n    }\r\n\r\n    function acceptAuthorityAddress() public returns (bool) {\r\n        require(msg.sender == newAuthorityAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        emit OwnershipTransferred(\r\n            \"AUTHORITY_ADDRESS\",\r\n            authorityAddress,\r\n            newAuthorityAddress\r\n        );\r\n        authorityAddress = newAuthorityAddress;\r\n        newAuthorityAddress = address(0);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/common/SafeMath.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function safeExponent(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 result;\r\n        assembly {\r\n            result := exp(a, b)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // calculates a^(1/n) to dp decimal places\r\n    // maxIts bounds the number of iterations performed\r\n    function nthRoot(\r\n        uint256 _a,\r\n        uint256 _n,\r\n        uint256 _dp,\r\n        uint256 _maxIts\r\n    ) internal pure returns (uint256) {\r\n        assert(_n > 1);\r\n\r\n        // The scale factor is a crude way to turn everything into integer calcs.\r\n        // Actually do (a * (10 ^ ((dp + 1) * n))) ^ (1/n)\r\n        // We calculate to one extra dp and round at the end\r\n        uint256 one = 10**(1 + _dp);\r\n        uint256 a0 = one**_n * _a;\r\n\r\n        // Initial guess: 1.0\r\n        uint256 xNew = one;\r\n        uint256 x;\r\n\r\n        uint256 iter = 0;\r\n        while (xNew != x && iter < _maxIts) {\r\n            x = xNew;\r\n            uint256 t0 = x**(_n - 1);\r\n            if (x * t0 > a0) {\r\n                xNew = x - (x - a0 / t0) / _n;\r\n            } else {\r\n                xNew = x + (a0 / t0 - x) / _n;\r\n            }\r\n            ++iter;\r\n        }\r\n\r\n        // Round to nearest in the last dp.\r\n        return (xNew + 5) / 10;\r\n    }\r\n}\r\n\r\n// File: contracts/InterFaces/IERC20Token.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IERC20Token {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n}\r\n\r\n// File: contracts/common/TokenTransfer.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ncontract TokenTransfer {\r\n    function ensureTransferFrom(\r\n        IERC20Token _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal {\r\n        if (_from == address(this))\r\n            require(_token.transfer(_to, _amount), \"ERR_TOKEN_TRANSFER_FAIL\");\r\n        else\r\n            require(\r\n                _token.transferFrom(_from, _to, _amount),\r\n                \"ERR_TOKEN_TRANSFER_FAIL\"\r\n            );\r\n    }\r\n\r\n    function approveTransferFrom(\r\n        IERC20Token _token,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal {\r\n        require(_token.approve(_spender, _amount), \"ERR_TOKEN_APPROVAL_FAIL\");\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy/IRegistry.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * @title IRegistry\r\n * @dev This contract represents the interface of a registry contract\r\n */\r\ninterface IRegistry {\r\n    /**\r\n     * @dev This event will be emitted every time a new proxy is created\r\n     * @param proxy representing the address of the proxy created\r\n     */\r\n    event ProxyCreated(address proxy);\r\n\r\n    /**\r\n     * @dev This event will be emitted every time a new implementation is registered\r\n     * @param version representing the version name of the registered implementation\r\n     * @param implementation representing the address of the registered implementation\r\n     */\r\n    event VersionAdded(uint256 version, address implementation);\r\n\r\n    /**\r\n     * @dev Registers a new version with its implementation address\r\n     * @param version representing the version name of the new implementation to be registered\r\n     * @param implementation representing the address of the new implementation to be registered\r\n     */\r\n    function addVersion(uint256  version, address implementation)\r\n        external;\r\n\r\n    /**\r\n     * @dev Tells the address of the implementation for a given version\r\n     * @param version to query the implementation of\r\n     * @return address of the implementation registered for the given version\r\n     */\r\n    function getVersion(uint256 version)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/Proxy/Proxy.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n     * @dev Tells the address of the implementation where every call will be delegated.\r\n     * @return address of the implementation to which it will be delegated\r\n     */\r\n    function implementation() public view returns (address);\r\n\r\n    /**\r\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n     * This function will return whatever the implementation call returns\r\n     */\r\n    \r\n    function() external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0),\"ERR_IMPLEMENTEION_ZERO\");\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }  \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n}\r\n\r\n// File: contracts/Proxy/UpgradeabilityStorage.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityStorage\r\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\r\n */\r\ncontract UpgradeabilityStorage is Proxy {\r\n    // Versions registry\r\n    IRegistry public registry;\r\n\r\n    // Address of the current implementation\r\n    address internal _implementation;\r\n\r\n    /**\r\n     * @dev Tells the address of the current implementation\r\n     * @return address of the current implementation\r\n     */\r\n    function implementation() public view returns (address) {\r\n        return _implementation;\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy/Upgradeable.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title Upgradeable\r\n * @dev This contract holds all the minimum required functionality for a behavior to be upgradeable.\r\n * This means, required state variables for owned upgradeability purpose and simple initialization validation.\r\n */\r\ncontract Upgradeable is UpgradeabilityStorage {\r\n    /**\r\n     * @dev Validates the caller is the versions registry.\r\n     * THIS FUNCTION SHOULD BE OVERRIDDEN CALLING SUPER\r\n     */\r\n    function initialize() public view {\r\n        require(msg.sender == address(registry),\"ERR_ONLY_REGISTRERY_CAN_CALL\");\r\n    }\r\n}\r\n\r\n// File: contracts/InterFaces/IContributionTrigger.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IContributionTrigger {\r\n    function depositeToken(\r\n        IERC20Token _token,\r\n        address _from,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    function contributeTowardLiquidity(uint256 _amount)\r\n        external\r\n        returns (uint256);\r\n\r\n    function transferTokenLiquidity(\r\n        IERC20Token _token,\r\n        address _reciver,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/InterFaces/ITokenVault.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface ITokenVault {\r\n    function depositeToken(\r\n        IERC20Token _token,\r\n        address _from,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    function directTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transferEther(address payable _to, uint256 amount)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/InterFaces/IAuction.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ninterface IAuction {\r\n    \r\n    function dayWiseMarketPrice(uint256 dayId) external view returns(uint256);\r\n    \r\n    function dayWiseContribution(uint256 dayId) external view returns(uint256);\r\n    \r\n    function auctionDay() external returns(uint256);\r\n        \r\n}\r\n\r\n// File: contracts/InterFaces/IWhiteList.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ninterface IWhiteList {\r\n    function address_belongs(address _who) external view returns (address);\r\n\r\n    function isWhiteListed(address _who) external view returns (bool);\r\n\r\n    function isAllowedInAuction(address _which) external view returns (bool);\r\n\r\n    function isAddressByPassed(address _which) external view returns (bool);\r\n\r\n    function isExchangeAddress(address _which) external view returns (bool);\r\n\r\n    function main_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) external view returns (bool);\r\n\r\n    function etn_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) external view returns (bool);\r\n\r\n    function stock_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) external view returns (bool);\r\n\r\n    function addWalletBehalfExchange(address _mainWallet, address _subWallet)\r\n        external\r\n        returns (bool);\r\n\r\n    function main_isReceiveAllowed(address user) external view returns (bool);\r\n\r\n    function etn_isReceiveAllowed(address user) external view returns (bool);\r\n\r\n    function stock_isReceiveAllowed(address user) external view returns (bool);\r\n}\r\n\r\n// File: contracts/Protection/AuctionProtection.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface InitializeInterface {\r\n    function initialize(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress,\r\n        address _registeryAddress\r\n    ) external;\r\n}\r\n\r\ncontract ProtectionRegistery is ProxyOwnable,ProtectionStorage, AuctionRegisteryContracts {\r\n    \r\n\r\n    function updateRegistery(address _address)\r\n        external\r\n        onlyAuthorized()\r\n        notZeroAddress(_address)\r\n        returns (bool)\r\n    {\r\n        contractsRegistry = IAuctionRegistery(_address);\r\n        _updateAddresses();\r\n        return true;\r\n    }\r\n\r\n    function getAddressOf(bytes32 _contractName)\r\n        internal\r\n        view\r\n        returns (address payable)\r\n    {\r\n        return contractsRegistry.getAddressOf(_contractName);\r\n    }\r\n\r\n    /**@dev updates all the address from the registry contract\r\n    this decision was made to save gas that occurs from calling an external view function */\r\n\r\n    function _updateAddresses() internal {\r\n        vaultAddress = getAddressOf(VAULT);\r\n        mainTokenAddress = getAddressOf(MAIN_TOKEN);\r\n        companyFundWalletAddress = getAddressOf(COMPANY_FUND_WALLET);\r\n        triggerAddress = getAddressOf(CONTRIBUTION_TRIGGER);\r\n        auctionAddress = getAddressOf(AUCTION);\r\n        whiteListAddress = getAddressOf(WHITE_LIST);\r\n    }\r\n\r\n    function updateAddresses() external returns (bool) {\r\n        _updateAddresses();\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract Utils is SafeMath, ProtectionRegistery {\r\n    \r\n\r\n    modifier allowedAddressOnly(address _which) {\r\n        require(_which == auctionAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    function setVaultRatio(uint256 _vaultRatio)\r\n        external\r\n        onlyAuthorized()\r\n        returns (bool)\r\n    {\r\n        require(_vaultRatio < 100);\r\n        vaultRatio = _vaultRatio;\r\n        return true;\r\n    }\r\n\r\n    function setTokenLockDuration(uint256 _tokenLockDuration)\r\n        external\r\n        onlyAuthorized()\r\n        returns (bool)\r\n    {\r\n        tokenLockDuration = _tokenLockDuration;\r\n        return true;\r\n    }\r\n\r\n    function isTokenLockEndDay(uint256 _LockDay) internal returns (bool) {\r\n        uint256 auctionDay = IAuction(auctionAddress).auctionDay();\r\n        if (auctionDay > safeAdd(_LockDay, tokenLockDuration)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract Stacking is\r\n    Utils,\r\n    TokenTransfer,\r\n    InitializeInterface\r\n{\r\n    \r\n\r\n    // stack fund called from auction contacrt\r\n    // 1% of supply distributed among the stack token\r\n    // there is always more token than 1\r\n    function stackFund(uint256 _amount)\r\n        external\r\n        allowedAddressOnly(msg.sender)\r\n        returns (bool)\r\n    {\r\n        IERC20Token mainToken = IERC20Token(mainTokenAddress);\r\n\r\n        if (totalTokenAmount > PERCENT_NOMINATOR) {\r\n            ensureTransferFrom(mainToken, msg.sender, address(this), _amount);\r\n\r\n            uint256 ratio = safeDiv(\r\n                safeMul(_amount, safeMul(DECIMAL_NOMINATOR, PERCENT_NOMINATOR)),\r\n                totalTokenAmount\r\n            );\r\n\r\n            totalTokenAmount = safeAdd(totalTokenAmount, _amount);\r\n\r\n            dayWiseRatio[stackRoundId] = ratio;\r\n        } else\r\n            ensureTransferFrom(\r\n                mainToken,\r\n                msg.sender,\r\n                vaultAddress,\r\n                _amount\r\n            );\r\n\r\n        stackRoundId = safeAdd(stackRoundId, 1);\r\n        return true;\r\n    }\r\n\r\n    function addFundToStacking(address _whom, uint256 _amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        totalTokenAmount = safeAdd(totalTokenAmount, _amount);\r\n\r\n        roundWiseToken[_whom][stackRoundId] = safeAdd(\r\n            roundWiseToken[_whom][stackRoundId],\r\n            _amount\r\n        );\r\n\r\n        stackBalance[_whom] = safeAdd(stackBalance[_whom], _amount);\r\n\r\n        if (lastRound[_whom] == 0) {\r\n            lastRound[_whom] = stackRoundId;\r\n        }\r\n\r\n        emit StackAdded(stackRoundId, _whom, _amount);\r\n        return true;\r\n    }\r\n\r\n    // calulcate actul fund user have\r\n    function calulcateStackFund(address _whom) internal view returns (uint256) {\r\n        uint256 _lastRound = lastRound[_whom];\r\n        uint256 _token;\r\n        uint256 _stackToken = 0;\r\n        if (_lastRound > 0) {\r\n            for (uint256 x = _lastRound; x < stackRoundId; x++) {\r\n                _token = safeAdd(_token, roundWiseToken[_whom][x]);\r\n\r\n                uint256 _tempStack = safeDiv(\r\n                    safeMul(dayWiseRatio[x], _token),\r\n                    safeMul(DECIMAL_NOMINATOR, PERCENT_NOMINATOR)\r\n                );\r\n\r\n                _stackToken = safeAdd(_stackToken, _tempStack);\r\n\r\n                _token = safeAdd(_token, _tempStack);\r\n            }\r\n        }\r\n        return _stackToken;\r\n    }\r\n\r\n    // this method distribut token\r\n    function _claimTokens(address _which) internal returns (bool) {\r\n        uint256 _stackToken = calulcateStackFund(_which);\r\n        lastRound[_which] = stackRoundId;\r\n        stackBalance[_which] = safeAdd(stackBalance[_which], _stackToken);\r\n        return true;\r\n    }\r\n\r\n    // every 5th Round system call this so token distributed\r\n    // user also can call this\r\n    function distributionStackInBatch(address[] calldata _which)\r\n        external\r\n        returns (bool)\r\n    {\r\n        for (uint8 x = 0; x < _which.length; x++) {\r\n            _claimTokens(_which[x]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // show stack balace with what user get\r\n    function getStackBalance(address _whom) external view returns (uint256) {\r\n        uint256 _stackToken = calulcateStackFund(_whom);\r\n        return safeAdd(stackBalance[_whom], _stackToken);\r\n    }\r\n\r\n    // unlocking stack token\r\n    function _unlockTokenFromStack(address _whom) internal returns (bool) {\r\n        uint256 _stackToken = calulcateStackFund(_whom);\r\n        uint256 actulToken = safeAdd(stackBalance[_whom], _stackToken);\r\n        ensureTransferFrom(\r\n            IERC20Token(mainTokenAddress),\r\n            address(this),\r\n            _whom,\r\n            actulToken\r\n        );\r\n        totalTokenAmount = safeSub(totalTokenAmount, actulToken);\r\n        stackBalance[_whom] = 0;\r\n        lastRound[_whom] = 0;\r\n        emit StackRemoved(stackRoundId, _whom, actulToken);\r\n        return true;\r\n    }\r\n    \r\n    function unlockTokenFromStack() external returns (bool) {\r\n        return _unlockTokenFromStack(msg.sender);\r\n    }\r\n    \r\n    function unlockTokenFromStackBehalf(address _whom) external returns (bool) {\r\n        require(IWhiteList(whiteListAddress).address_belongs(_whom) == msg.sender,ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        return _unlockTokenFromStack(_whom);\r\n    }\r\n}\r\n\r\ncontract AuctionProtection is Upgradeable, Stacking {\r\n    \r\n    function initialize(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress,\r\n        address _registeryAddress\r\n    ) public {\r\n        super.initialize();\r\n\r\n        contractsRegistry = IAuctionRegistery(_registeryAddress);\r\n        tokenLockDuration = 365;\r\n        stackRoundId = 1;\r\n        initializeOwner(_primaryOwner, _systemAddress, _authorityAddress);\r\n        _updateAddresses();\r\n        vaultRatio = 90;\r\n    }\r\n\r\n   \r\n    function lockBalance(\r\n        uint256 _auctionDay,\r\n        address _token,\r\n        address _which,\r\n        uint256 _amount\r\n    ) internal returns (bool) {\r\n        if (lockedOn[_which] == 0) {\r\n            lockedOn[_which] = _auctionDay;\r\n        }\r\n        uint256 currentBalance = currentLockedFunds[_which][_auctionDay][_token];\r\n        currentLockedFunds[_which][_auctionDay][_token] = safeAdd(currentBalance, _amount);\r\n        emit FundLocked(_token, _which, _amount);\r\n        return true;\r\n    }\r\n\r\n    function lockEther(uint256 _auctionDay,address _which)\r\n        public\r\n        payable\r\n        allowedAddressOnly(msg.sender)\r\n        returns (bool)\r\n    {\r\n        return lockBalance(_auctionDay,address(0), _which, msg.value);\r\n    }\r\n\r\n  \r\n\r\n    function _cancelInvestment(address payable _whom) internal returns (bool) {\r\n        \r\n        require(\r\n            !isTokenLockEndDay(lockedOn[_whom]),\r\n            \"ERR_INVESTMENT_CANCEL_PERIOD_OVER\"\r\n        );\r\n\r\n        uint256 _tokenBalance = lockedFunds[_whom][address(0)];\r\n        if (_tokenBalance > 0) {\r\n            _whom.transfer(_tokenBalance);\r\n            emit FundTransfer(_whom, address(0), _tokenBalance);\r\n            lockedFunds[_whom][address(0)] = 0;\r\n        }\r\n\r\n        _tokenBalance = lockedTokens[_whom];\r\n        if (_tokenBalance > 0) {\r\n            IERC20Token _token = IERC20Token(mainTokenAddress);\r\n            approveTransferFrom(_token, vaultAddress, _tokenBalance);\r\n\r\n            ITokenVault(vaultAddress).depositeToken(\r\n                _token,\r\n                address(this),\r\n                _tokenBalance\r\n            );\r\n\r\n            emit FundTransfer(vaultAddress, address(_token), _tokenBalance);\r\n            lockedTokens[_whom] = 0;\r\n        }\r\n        lockedOn[_whom] = 0;\r\n        emit InvestMentCancelled(_whom, _tokenBalance);\r\n        return true;\r\n    }\r\n\r\n    function _unLockTokens(address _which, bool isStacking)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint256 _tokenBalance = lockedFunds[_which][address(0)];\r\n\r\n        if (_tokenBalance > 0) {\r\n            uint256 walletAmount = safeDiv(\r\n                safeMul(_tokenBalance, vaultRatio),\r\n                100\r\n            );\r\n            uint256 tagAlongAmount = safeSub(_tokenBalance, walletAmount);\r\n\r\n            triggerAddress.transfer(tagAlongAmount);\r\n            companyFundWalletAddress.transfer(walletAmount);\r\n            emit FundTransfer(triggerAddress, address(0), tagAlongAmount);\r\n            emit FundTransfer(\r\n                companyFundWalletAddress,\r\n                address(0),\r\n                walletAmount\r\n            );\r\n            lockedFunds[_which][address(0)] = 0;\r\n        }\r\n\r\n        _tokenBalance = lockedTokens[_which];\r\n\r\n        if (_tokenBalance > 0) {\r\n            IERC20Token _token = IERC20Token(mainTokenAddress);\r\n\r\n            if (isStacking) {\r\n                addFundToStacking(_which, _tokenBalance);\r\n            } else {\r\n                ensureTransferFrom(\r\n                    _token,\r\n                    address(this),\r\n                    _which,\r\n                    _tokenBalance\r\n                );\r\n                emit TokenUnLocked(_which, _tokenBalance);\r\n            }\r\n            emit FundTransfer(_which, address(_token), _tokenBalance);\r\n            lockedTokens[_which] = 0;\r\n        }\r\n        lockedOn[_which] = 0;\r\n        return true;\r\n    }\r\n\r\n    // user unlock tokens and funds goes to compnay wallet\r\n    function unLockTokens() external returns (bool) {\r\n        return _unLockTokens(msg.sender, false);\r\n    }\r\n\r\n    function stackToken() external returns (bool) {\r\n        return _unLockTokens(msg.sender, true);\r\n    }\r\n    \r\n    function cancelInvestment() external returns (bool) {\r\n        return _cancelInvestment(msg.sender);\r\n    }\r\n    \r\n    \r\n    function unLockTokensBehalf(address _whom) external returns (bool) {\r\n        require(IWhiteList(whiteListAddress).address_belongs(_whom) == msg.sender,ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        return _unLockTokens(_whom, false);\r\n    }\r\n\r\n    function stackTokenBehalf(address _whom) external returns (bool) {\r\n        require(IWhiteList(whiteListAddress).address_belongs(_whom) == msg.sender,ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        return _unLockTokens(_whom, true);\r\n    }\r\n    \r\n    function cancelInvestmentBehalf(address payable _whom) external returns (bool) {\r\n        require(IWhiteList(whiteListAddress).address_belongs(_whom) == msg.sender,ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        return _cancelInvestment(_whom);\r\n    }\r\n\r\n    function unLockFundByAdmin(address _which)\r\n        external\r\n        onlyOneOfOnwer()\r\n        returns (bool)\r\n    {\r\n        require(\r\n            isTokenLockEndDay(lockedOn[_which]),\r\n            \"ERR_ADMIN_CANT_UNLOCK_FUND\"\r\n        );\r\n        return _unLockTokens(_which, false);\r\n    }\r\n\r\n    function depositToken(\r\n        uint256 _auctionDay,\r\n        address _which,\r\n        uint256 _amount\r\n    ) external allowedAddressOnly(msg.sender) returns (bool) {\r\n        IERC20Token token = IERC20Token(mainTokenAddress);\r\n\r\n        ensureTransferFrom(token, msg.sender , address(this), _amount);\r\n\r\n        lockedTokens[_which] = safeAdd(lockedTokens[_which], _amount);\r\n\r\n        if (currentLockedFunds[_which][_auctionDay][address(0)] > 0) {\r\n            uint256 _currentTokenBalance = currentLockedFunds[_which][_auctionDay][address(\r\n                0\r\n            )];\r\n            lockedFunds[_which][address(0)] = safeAdd(\r\n                lockedFunds[_which][address(0)],\r\n                _currentTokenBalance\r\n            );\r\n            currentLockedFunds[_which][_auctionDay][address(0)] = 0;\r\n        }\r\n        emit FundLocked(address(token), _which, _amount);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"triggerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"getStackBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"changeSystemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"unLockFundByAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_auctionDay\",\"type\":\"uint256\"},{\"name\":\"_which\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedOn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unLockTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"unLockTokensBehalf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unLockBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"cancelInvestmentBehalf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockTokenFromStack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenLockDuration\",\"type\":\"uint256\"}],\"name\":\"setTokenLockDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changePrimaryOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address[]\"}],\"name\":\"distributionStackInBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMAL_NOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwnerInitialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteListAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stackToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyFundWalletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vaultRatio\",\"type\":\"uint256\"}],\"name\":\"setVaultRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"primaryOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"changeAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stackFund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"currentLockedFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENT_NOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateRegistery\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stackRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenLockDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_auctionDay\",\"type\":\"uint256\"},{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"lockEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"stackTokenBehalf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primaryOwner\",\"type\":\"address\"},{\"name\":\"_systemAddress\",\"type\":\"address\"},{\"name\":\"_authorityAddress\",\"type\":\"address\"},{\"name\":\"_registeryAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"unlockTokenFromStackBehalf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"TokenUnLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"InvestMentCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_which\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FundLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_whom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StackAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_whom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StackRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ownerType\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AuthorityAddressChnageCall\",\"type\":\"event\"}]","ContractName":"AuctionProtection","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bd5ebbea62c7656687dda067c0a1debe8456db272c39a6e367169354ad3c8844"}]}