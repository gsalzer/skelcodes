{"status":"1","message":"OK","result":[{"SourceCode":"{\"Container.sol\":{\"content\":\"pragma solidity ^0.5.11;\\n\\ncontract Container{\\n    struct Item{\\n        uint256 itemType;\\n        uint256 status;\\n        address[] addresses;\\n    }\\n    uint256 MaxItemAdressNum = 255;\\n\\n    mapping (bytes32 =\\u003e Item) private container;\\n\\n    function itemAddressExists(bytes32 id, address oneAddress) internal view returns(bool){\\n        for(uint256 i = 0; i \\u003c container[id].addresses.length; i++){\\n            if(container[id].addresses[i] == oneAddress)\\n                return true;\\n        }\\n        return false;\\n    }\\n    function getItemAddresses(bytes32 id) internal view returns(address[] memory){\\n        return container[id].addresses;\\n    }\\n\\n    function getItemInfo(bytes32 id) internal view returns(uint256, uint256, uint256){\\n        return (container[id].itemType, container[id].status, container[id].addresses.length);\\n    }\\n\\n    function getItemAddressCount(bytes32 id) internal view returns(uint256){\\n        return container[id].addresses.length;\\n    }\\n\\n    function setItemInfo(bytes32 id, uint256 itemType, uint256 status) internal{\\n        container[id].itemType = itemType;\\n        container[id].status = status;\\n    }\\n\\n    function addItemAddress(bytes32 id, address oneAddress) internal{\\n        require(!itemAddressExists(id, oneAddress), \\\"dup address added\\\");\\n        require(container[id].addresses.length \\u003c MaxItemAdressNum, \\\"too many addresses\\\");\\n        container[id].addresses.push(oneAddress);\\n    }\\n    function removeItemAddresses(bytes32 id) internal{\\n        container[id].addresses.length = 0;\\n    }\\n\\n    function removeOneItemAddress(bytes32 id, address oneAddress) internal{\\n        for(uint256 i = 0; i \\u003c container[id].addresses.length; i++){\\n            if(container[id].addresses[i] == oneAddress){\\n                container[id].addresses[i] = container[id].addresses[container[id].addresses.length - 1];\\n                container[id].addresses.length--;\\n                return;\\n            }\\n        }\\n        revert(\\\"not exist address\\\");\\n    }\\n\\n    function removeItem(bytes32 id) internal{\\n        delete container[id];\\n    }\\n\\n    function replaceItemAddress(bytes32 id, address oneAddress, address anotherAddress) internal{\\n        require(!itemAddressExists(id,anotherAddress),\\\"dup address added\\\");\\n        for(uint256 i = 0; i \\u003c container[id].addresses.length; i++){\\n            if(container[id].addresses[i] == oneAddress){\\n                container[id].addresses[i] = anotherAddress;\\n                return;\\n            }\\n        }\\n        revert(\\\"not exist address\\\");\\n    }\\n}\"},\"HDOTLogic.sol\":{\"content\":\"pragma solidity ^0.5.11;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./HDOTStorage.sol\\\";\\n\\ncontract HDOTLogic {\\n\\n    using SafeMath for uint256;\\n\\n    string public constant name = \\\"HDOTLogic\\\";\\n\\n    uint256 public constant TASKINIT = 0;\\n    uint256 public constant TASKPROCESSING = 1;\\n    uint256 public constant TASKCANCELLED = 2;\\n    uint256 public constant TASKDONE = 3;\\n    uint256 public constant MINTTASK = 1;\\n    uint256 public constant BURNTASK = 2;\\n\\n    address private caller;\\n    HDOTStorage private store;\\n\\n    constructor(address aCaller) public{\\n        caller = aCaller;\\n    }\\n\\n    modifier onlyCaller(){\\n        require(msg.sender == caller, \\\"only main contract can call\\\");\\n        _;\\n    }\\n\\n    function mintLogic(uint256 value,address to,string calldata proof,\\n        bytes32 taskHash, address supportAddress, uint256 requireNum)\\n        external onlyCaller returns(uint256){\\n        require(to != address(0), \\\"cannot be burned from zero address\\\");\\n        require(value \\u003e 0, \\\"value need \\u003e 0\\\");\\n        require(taskHash == keccak256((abi.encodePacked(to,value,proof))),\\\"taskHash is wrong\\\");\\n        uint256 status = supportTask(MINTTASK, taskHash, supportAddress, requireNum);\\n\\n        if( status == TASKDONE){\\n            uint256 totalSupply = store.getTotalSupply();\\n            uint256 balanceTo = store.balanceOf(to);\\n            balanceTo = balanceTo.safeAdd(value);\\n            totalSupply = totalSupply.safeAdd(value);\\n            store.setBalance(to,balanceTo);\\n            store.setTotalSupply(totalSupply);\\n        }\\n        return status;\\n    }\\n\\n    function burnLogic(address from, uint256 value,string calldata dotAddress,\\n        string calldata proof,bytes32 taskHash, address supportAddress, uint256 requireNum)\\n        external onlyCaller returns(uint256){\\n\\n        uint256 balance = store.balanceOf(from);\\n        require(balance \\u003e= value,\\\"sender address not have enough HDOT\\\");\\n        require(value \\u003e 0, \\\"value need \\u003e 0\\\");\\n        require(taskHash == keccak256((abi.encodePacked(from,value,dotAddress,proof))),\\\"taskHash is wrong\\\");\\n        uint256 status = supportTask(BURNTASK, taskHash, supportAddress, requireNum);\\n\\n        if ( status == TASKDONE ){\\n            uint256 totalSupply = store.getTotalSupply();\\n            totalSupply = totalSupply.safeSub(value);\\n            balance = balance.safeSub(value);\\n            store.setBalance(from,balance);\\n            store.setTotalSupply(totalSupply);\\n\\n        }\\n        return status;\\n    }\\n\\n    function transferLogic(address sender,address to,uint256 value) external onlyCaller returns(bool) {\\n        require(to != address(0), \\\"cannot transfer to address zero\\\");\\n        require(sender != to, \\\"sender need != to\\\");\\n        require(value \\u003e 0, \\\"value need \\u003e 0\\\");\\n        require(address(store) != address(0), \\\"dataStore address error\\\");\\n\\n        uint256 balanceFrom = store.balanceOf(sender);\\n        uint256 balanceTo = store.balanceOf(to);\\n        require(value \\u003c= balanceFrom, \\\"insufficient funds\\\");\\n        balanceFrom = balanceFrom.safeSub(value);\\n        balanceTo = balanceTo.safeAdd(value);\\n        store.setBalance(sender,balanceFrom);\\n        store.setBalance(to,balanceTo);\\n        return true;\\n    }\\n\\n    function transferFromLogic(address sender,address from,address to,uint256 value) external onlyCaller returns(bool) {\\n        require(from != address(0), \\\"cannot transfer from address zero\\\");\\n        require(to != address(0), \\\"cannot transfer to address zero\\\");\\n        require(value \\u003e 0, \\\"can not tranfer zero Token\\\");\\n        require(from!=to,\\\"from and to can not be be the same \\\");\\n        require(address(store) != address(0), \\\"dataStore address error\\\");\\n\\n        uint256 balanceFrom = store.balanceOf(from);\\n        uint256 balanceTo = store.balanceOf(to);\\n        uint256 allowedvalue = store.getAllowed(from,sender);\\n\\n        require(value \\u003c= allowedvalue, \\\"insufficient allowance\\\");\\n        require(value \\u003c= balanceFrom, \\\"insufficient funds\\\");\\n\\n        balanceFrom = balanceFrom.safeSub(value);\\n        balanceTo = balanceTo.safeAdd(value);\\n        allowedvalue = allowedvalue.safeSub(value);\\n\\n        store.setBalance(from,balanceFrom);\\n        store.setBalance(to,balanceTo);\\n        store.setAllowed(from,sender,allowedvalue);\\n        return true;\\n    }\\n\\n    function approveLogic(address sender,address spender,uint256 value)  external onlyCaller returns(bool success){\\n        require(spender != address(0), \\\"spender address zero\\\");\\n        require(value \\u003e 0, \\\"value need \\u003e 0\\\");\\n        require(address(store) != address(0), \\\"dataStore address error\\\");\\n\\n        store.setAllowed(sender,spender,value);\\n        return true;\\n    }\\n\\n    function resetStoreLogic(address storeAddress) external onlyCaller {\\n        store = HDOTStorage(storeAddress);\\n    }\\n\\n    function getTotalSupply() public view returns (uint256 supply) {\\n        return store.getTotalSupply();\\n    }\\n\\n    function balanceOf(address owner) public view returns (uint256 balance) {\\n        return store.balanceOf(owner);\\n    }\\n\\n    function getAllowed(address owner, address spender) public view returns (uint256 remaining){\\n        return store.getAllowed(owner,spender);\\n    }\\n\\n    function getStoreAddress() public view returns(address){\\n        return address(store);\\n    }\\n\\n    function supportTask(uint256 taskType, bytes32 taskHash, address oneAddress, uint256 requireNum) private returns(uint256){\\n        require(!store.supporterExists(taskHash, oneAddress), \\\"supporter already exists\\\");\\n        (uint256 theTaskType,uint256 theTaskStatus,uint256 theSupporterNum) = store.getTaskInfo(taskHash);\\n        require(theTaskStatus \\u003c TASKDONE, \\\"wrong status\\\");\\n\\n        if (theTaskStatus != TASKINIT)\\n            require(theTaskType == taskType, \\\"task type not match\\\");\\n        store.addSupporter(taskHash, oneAddress);\\n        theSupporterNum++;\\n        if(theSupporterNum \\u003e= requireNum)\\n            theTaskStatus = TASKDONE;\\n        else\\n            theTaskStatus = TASKPROCESSING;\\n        store.setTaskInfo(taskHash, taskType, theTaskStatus);\\n        return theTaskStatus;\\n    }\\n\\n    function cancelTask(bytes32 taskHash)  external onlyCaller returns(uint256){\\n        (uint256 theTaskType,uint256 theTaskStatus,uint256 theSupporterNum) = store.getTaskInfo(taskHash);\\n        require(theTaskStatus == TASKPROCESSING, \\\"wrong status\\\");\\n        if(theSupporterNum \\u003e 0) store.removeAllSupporter(taskHash);\\n        theTaskStatus = TASKCANCELLED;\\n        store.setTaskInfo(taskHash, theTaskType, theTaskStatus);\\n        return theTaskStatus;\\n    }\\n}\"},\"HDOTStorage.sol\":{\"content\":\"pragma solidity ^0.5.11;\\n\\nimport \\\"./Container.sol\\\";\\n\\ncontract HDOTStorage is Container{\\n\\n    string public constant name = \\\"HDOTStorage\\\";\\n\\n    address private caller;\\n\\n    constructor(address aCaller) public{\\n        totalSupply = 0;\\n        caller = aCaller;\\n    }\\n    uint256 public totalSupply;\\n\\n    mapping (address =\\u003e uint256) private balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private allowed;\\n\\n    function supporterExists(bytes32 taskHash, address user) public view returns(bool){\\n        return itemAddressExists(taskHash, user);\\n    }\\n\\n    function setTaskInfo(bytes32 taskHash, uint256 taskType, uint256 status) external onlyCaller{\\n        setItemInfo(taskHash, taskType, status);\\n    }\\n\\n    function getTaskInfo(bytes32 taskHash) public view returns(uint256, uint256, uint256){\\n        return getItemInfo(taskHash);\\n    }\\n\\n    function addSupporter(bytes32 taskHash, address oneAddress) external onlyCaller{\\n        addItemAddress(taskHash, oneAddress);\\n    }\\n\\n    function removeAllSupporter(bytes32 taskHash) external onlyCaller{\\n        removeItemAddresses(taskHash);\\n    }\\n\\n    modifier onlyCaller() {\\n        require(msg.sender == caller, \\\"only use main main contract to call\\\");\\n        _;\\n    }\\n\\n    function getTotalSupply() external view returns(uint256) {\\n        return totalSupply;\\n    }\\n\\n    function setTotalSupply(uint256 amount) external onlyCaller {\\n        totalSupply = amount;\\n    }\\n\\n    function balanceOf(address account) external view returns(uint256) {\\n        return balances[account];\\n    }\\n\\n    function setBalance(address account,uint256 amount) external onlyCaller {\\n        require(account != address(0),\\\"account address error\\\");\\n        balances[account] = amount;\\n    }\\n\\n    function getAllowed(address owner,address spender) external view returns(uint256) {\\n        return allowed[owner][spender];\\n    }\\n\\n    function setAllowed(address owner,address spender,uint256 amount) external onlyCaller {\\n        require(owner != address(0),\\\"owner address error\\\");\\n        require(spender != address(0),\\\"spender address error\\\");\\n        require(amount \\u003c= balances[owner], \\\"owner balance need \\u003e= amount\\\");\\n        allowed[owner][spender] = amount;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// solium-disable linebreak-style\\npragma solidity ^0.5.11;\\n\\nlibrary SafeMath {\\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\\n        c = a + b;\\n        require(c \\u003e= a,\\\"\\\");\\n    }\\n    function safeSub(uint a, uint b) public pure returns (uint c) {\\n        require(b \\u003c= a,\\\"\\\");\\n        c = a - b;\\n    }\\n    function safeMul(uint a, uint b) public pure returns (uint c) {\\n        c = a * b;\\n        require(a == 0 || c / a == b,\\\"\\\");\\n    }\\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\\n        require(b \\u003e 0,\\\"\\\");\\n        c = a / b;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aCaller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"BURNTASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINTTASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TASKCANCELLED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TASKDONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TASKINIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TASKPROCESSING\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveLogic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"dotAddress\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"proof\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"supportAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requireNum\",\"type\":\"uint256\"}],\"name\":\"burnLogic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"}],\"name\":\"cancelTask\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"getAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStoreAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"proof\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"supportAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requireNum\",\"type\":\"uint256\"}],\"name\":\"mintLogic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"storeAddress\",\"type\":\"address\"}],\"name\":\"resetStoreLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFromLogic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferLogic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"HDOTLogic","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009ffc3bcde7b68c46a6dc34f0718009925c1867cb","EVMVersion":"Default","Library":"SafeMath:26e93cd9d8a58f664c54606de6cca7c16991cab3","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://1179debca5812af3ff11b8ca1ee1c4251a7711f323e1393f82bd24ccd0e6b8d3"}]}