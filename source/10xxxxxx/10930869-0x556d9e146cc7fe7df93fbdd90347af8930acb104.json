{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256 c) {\r\n        require(b <= a, errorMessage);\r\n        c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256 c) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ninterface ERC20Basic {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value\r\n    );\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 totalSupply_;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint256 _value) public override returns (bool) {\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param _from The address to transfer from.\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\r\n        require(_to != address(0), \"transfer addr is the zero address\");\r\n        require(_value <= balances[_from], \"lack of balance\");\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _owner The address to query the the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _owner) public view override returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0), \"transfer addr is the zero address\");\r\n        require(_value <= balances[_from], \"lack of balance\");\r\n        require(_value <= allowed[_from][msg.sender], \"lack of transfer balance allowed\");\r\n        \r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public override returns (bool) {\r\n        // avoid race condition\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0), \"reset allowance to 0 before change it's value.\");\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n\r\ncontract Token_StandardToken is StandardToken {\r\n    // region{fields}\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    // region{Constructor}\r\n    // note : [(final)totalSupply] >> claimAmount * 10 ** decimals\r\n    // example : args << \"The Kh Token No.X\", \"ABC\", \"10000000000\", \"18\"\r\n    constructor(\r\n        string memory _token_name,\r\n        string memory _symbol,\r\n        uint256 _claim_amount,\r\n        uint8 _decimals,\r\n        address minaddr\r\n    ) public {\r\n        name = _token_name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply_ = _claim_amount.mul(10 ** uint256(decimals));\r\n        balances[minaddr] = totalSupply_;\r\n        emit Transfer(address(0), minaddr, totalSupply_);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n * USDT transfer and transferFrom not returns\r\n */\r\ninterface ITokenERC20_USDT {\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface ITokenERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title DB\r\n * @dev This Provide database support services\r\n */\r\ncontract DB  {\r\n    //lib using list\r\n\r\n\tstruct UserInfo {\r\n\t\tuint id;\r\n        address code;\r\n\t\taddress rCode;\r\n\t}\r\n\r\n\tuint _uid = 0;\r\n\tmapping(uint => address) indexMapping;//UID address Mapping\r\n    mapping(address => address) addressMapping;//inviteCode address Mapping\r\n    mapping(address => UserInfo) userInfoMapping;//address UserInfo Mapping\r\n\r\n    /**\r\n     * @dev Create store user information\r\n     * @param addr user addr\r\n     * @param code user invite Code\r\n     * @param rCode recommend code\r\n     */\r\n    function _registerUser(address addr, address code, address rCode)\r\n        internal\r\n    {\r\n\t\tUserInfo storage userInfo = userInfoMapping[addr];\r\n        if (userInfo.id == 0) {\r\n            if (_uid != 0) {\r\n                require(isUsedCode(rCode), \"DB: rCode not exist\");\r\n                address pAddr = addressMapping[rCode];\r\n                require(pAddr != msg.sender, \"DB: rCode can't be self\");\r\n                userInfo.rCode = rCode;\r\n            }\r\n\r\n            require(!isUsedCode(code), \"DB: code is used\");\r\n            require(code != address(0), \"DB: invalid invite code\");\r\n\r\n            _uid++;\r\n            userInfo.id = _uid;\r\n            userInfo.code = code;\r\n\r\n            addressMapping[code] = addr;\r\n            indexMapping[_uid] = addr;\r\n        }\r\n\t}\r\n\r\n    /**\r\n     * @dev determine if user invite code is use\r\n     * @param code user invite Code\r\n     * @return bool\r\n     */\r\n    function _isUsedCode(address code)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n\t\treturn addressMapping[code] != address(0);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user invite code\r\n     * Authorization Required\r\n     * @param code user invite Code\r\n     * @return address\r\n     */\r\n    function _getCodeMapping(address code)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n\t\treturn addressMapping[code];\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user id\r\n     * Authorization Required\r\n     * @param uid user id\r\n     * @return address\r\n     */\r\n    function _getIndexMapping(uint uid)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n\t\treturn indexMapping[uid];\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding User info\r\n     * Authorization Required or addr is owner\r\n     * @param addr user address\r\n     * @return info info[id,status,level,levelStatus]\r\n     * @return code code\r\n     * @return rCode rCode\r\n     */\r\n    function _getUserInfo(address addr)\r\n        internal\r\n        view\r\n        returns (uint[1] memory info, address code, address rCode)\r\n    {\r\n\t\tUserInfo memory userInfo = userInfoMapping[addr];\r\n\t\tinfo[0] = userInfo.id;\r\n\r\n\t\treturn (info, userInfo.code, userInfo.rCode);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the current latest ID\r\n     * Authorization Required\r\n     * @return current uid\r\n     */\r\n    function _getCurrentUserID()\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\treturn _uid;\r\n\t}\r\n\r\n    /**\r\n     * @dev determine if user invite code is use\r\n     * @param code user invite Code\r\n     * @return bool\r\n     */\r\n    function isUsedCode(address code)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n\t\treturn _isUsedCode(code);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title Utillibrary\r\n * @dev This integrates the basic functions.\r\n */\r\ncontract Utillibrary is Token_StandardToken {\r\n    //lib using list\r\n\tusing SafeMath for *;\r\n    using Address for address;\r\n\r\n    //base param setting\r\n    // uint internal ethWei = 1 ether;\r\n    uint internal USDTWei = 10 ** 6;\r\n    uint internal ETTWei = 10 ** 18;\r\n    uint internal USDT_ETTWei_Ratio = 10 ** 12;\r\n\r\n    constructor() \r\n        Token_StandardToken(\"EAS\", \"EAS\", 11000000, 18, address(this))\r\n        public\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev modifier to scope access to a Contract (uses tx.origin and msg.sender)\r\n     */\r\n\tmodifier isHuman() {\r\n\t\trequire(msg.sender == tx.origin, \"humans only\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check Zero Addr\r\n     */\r\n\tmodifier checkZeroAddr(address addr) {\r\n\t\trequire(addr != address(0), \"zero addr\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check Addr is Contract\r\n     */\r\n\tmodifier checkIsContract(address addr) {\r\n\t\trequire(addr.isContract(), \"not token addr\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check User ID\r\n     * @param uid user ID\r\n     */\r\n    function checkUserID(uint uid)\r\n        internal\r\n        pure\r\n    {\r\n        require(uid != 0, \"user not exist\");\r\n\t}\r\n\r\n    /**\r\n     * @dev Transfer to designated user\r\n     * @param _addr user address\r\n     * @param _val transfer-out amount\r\n     */\r\n\tfunction sendTokenToUser(address _addr, uint _val)\r\n        internal\r\n    {\r\n\t\tif (_val > 0) {\r\n            _transfer(address(this), _addr, _val);//erc20 internal Function\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Gets the amount from the specified user\r\n     * @param _addr user address\r\n     * @param _val transfer-get amount\r\n     */\r\n\tfunction getTokenFormUser(address _addr, uint _val)\r\n        internal\r\n    {\r\n\t\tif (_val > 0) {\r\n            _transfer(_addr, address(this), _val);//erc20 internal Function\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Transfer to designated user\r\n     * USDT transfer and transferFrom not returns\r\n     * @param _taddr token address\r\n     * @param _addr user address\r\n     * @param _val transfer-out amount\r\n     */\r\n\tfunction sendTokenToUser_USDT(address _taddr, address _addr, uint _val)\r\n        internal\r\n        checkZeroAddr(_addr)\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            ITokenERC20_USDT(_taddr).transfer(_addr, _val);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Gets the amount from the specified user\r\n     * USDT transfer and transferFrom not returns\r\n     * @param _taddr token address\r\n     * @param _addr user address\r\n     * @param _val transfer-get amount\r\n     */\r\n\tfunction getTokenFormUser_USDT(address _taddr, address _addr, uint _val)\r\n        internal\r\n        checkZeroAddr(_addr)\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            ITokenERC20_USDT(_taddr).transferFrom(_addr, address(this), _val);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Check and correct transfer amount\r\n     * @param sendMoney transfer-out amount\r\n     * @return bool,amount\r\n     */\r\n\tfunction isEnoughTokneBalance(address _taddr, uint sendMoney)\r\n        internal\r\n        view\r\n        returns (bool, uint tokneBalance)\r\n    {\r\n        tokneBalance = ITokenERC20(_taddr).balanceOf(address(this));\r\n\t\tif (sendMoney > tokneBalance) {\r\n\t\t\treturn (false, tokneBalance);\r\n\t\t} else {\r\n\t\t\treturn (true, sendMoney);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev get Resonance Ratio for the Resonance ID\r\n     * @param value Resonance ID\r\n     * @return Resonance Ratio\r\n     */\r\n\tfunction getResonanceRatio(uint value)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        // base 1U=10E\r\n        // 1.10U=100E => 10/100U=1E => 1U=100/10E\r\n        // 2.11U=100E => 11/100U=1E => 1U=100/11E\r\n        // 3.12U=100E => 12/100U=1E => 1U=100/12E\r\n        return USDT_ETTWei_Ratio * 100 / ((value - 1) + 10);\r\n\t}\r\n\r\n    /**\r\n     * @dev get scale for the level (*scale/1000)\r\n     * @param level level\r\n     * @return scale\r\n     */\r\n\tfunction getScaleByLevel(uint level)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n\t\tif (level == 1) {\r\n\t\t\treturn 10;\r\n\t\t}\r\n\t\tif (level == 2) {\r\n\t\t\treturn 12;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\treturn 15;\r\n\t\t}\r\n        if (level == 4) {\r\n\t\t\treturn 15;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n    /**\r\n     * @dev get scale for the DailyDividend (*scale/1000)\r\n     * @param level level\r\n     * @return scale algebra\r\n     */\r\n\tfunction getScaleByDailyDividend(uint level)\r\n        internal\r\n        pure\r\n        returns (uint scale, uint algebra)\r\n    {\r\n\t\tif (level == 1) {\r\n\t\t\treturn (100, 1);\r\n\t\t}\r\n\t\tif (level == 2) {\r\n\t\t\treturn (60, 5);\r\n\t\t}\r\n\t\tif (level == 3) {\r\n            return (80, 8);\r\n\t\t}\r\n        if (level == 4) {\r\n            return (100, 10);\r\n\t\t}\r\n\t\treturn (0, 0);\r\n\t}\r\n}\r\n\r\ncontract EASContract is Utillibrary, DB {\r\n    using SafeMath for *;\r\n\r\n    //struct\r\n\tstruct User {\r\n\t\tuint id;\r\n\r\n        uint investAmountAddup;//add up invest Amount\r\n        uint investAmountOut;//add up invest Amount Out\r\n\r\n        uint investMoney;//invest amount current\r\n        uint investAddupStaticBonus;//add up settlement static bonus amonut\r\n        uint investAddupDynamicBonus;//add up settlement dynamic bonus amonut\r\n        uint8 investOutMultiple;//invest Exit multiple of investment  n/10\r\n        uint8 investLevel;//invest level\r\n        uint40 investTime;//invest time\r\n        uint40 investLastRwTime;//last settlement time\r\n\r\n        uint bonusStaticAmount;//add up static bonus amonut (static bonus)\r\n\t\tuint bonusDynamicAmonut;//add up dynamic bonus amonut (dynamic bonus)\r\n\r\n        uint takeBonusWallet;//takeBonus Wallet\r\n        uint takeBonusAddup;//add up takeBonus\r\n\t}\r\n    struct ResonanceData {\r\n        uint40 time;//Resonance time\r\n        uint ratio;//Resonance amount\r\n        uint investMoney;//invest amount\r\n\t}\r\n\r\n    //Loglist\r\n    event InvestEvent(address indexed _addr, address indexed _code, address indexed _rCode, uint _value, uint time);\r\n    event TakeBonusEvent(address indexed _addr, uint _type, uint _value_USDT, uint _value_ETT, uint time);\r\n\r\n    //ERC Token addr\r\n    address USDTToken;//USDT contract\r\n\r\n    //base param setting\r\n\taddress devAddr;//The special account\r\n\r\n    //resonance\r\n    uint internal rid = 1;//sell Round id\r\n    mapping(uint => ResonanceData) internal resonanceDataMapping;//RoundID ResonanceData Mapping\r\n\r\n    //address User Mapping\r\n\tmapping(address => User) userMapping;\r\n\r\n    //addup\r\n    uint AddupInvestUSD = 0;\r\n\r\n    //ETT Token Pool\r\n    uint ETTPool_User = ETTWei * 9900000;\r\n\r\n    uint ETTPool_Dev = ETTWei * 1100000;\r\n    uint ETTPool_Dev_RwAddup = 0;\r\n    uint40 ETTPool_Dev_LastRwTime = uint40(now + 365 * 1 days);\r\n\r\n    /**\r\n     * @dev the content of contract is Beginning\r\n     */\r\n\tconstructor (\r\n        address _devAddr,\r\n        address _USDTAddr\r\n    )\r\n        public\r\n    {\r\n        //set addr\r\n        devAddr = _devAddr;\r\n        USDTToken = _USDTAddr;\r\n\r\n        //init ResonanceData\r\n        ResonanceData storage resonance = resonanceDataMapping[rid];\r\n        if (resonance.ratio == 0) {\r\n            resonance.time = uint40(now);\r\n            resonance.ratio = getResonanceRatio(rid);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev the invest of contract is Beginning\r\n     * @param money USDT amount for invest\r\n     * @param rCode recommend code\r\n     */\r\n\tfunction invest(uint money, address rCode)\r\n        public\r\n        isHuman()\r\n    {\r\n        address code = msg.sender;\r\n\r\n        //判断是投资范围\r\n        require(\r\n            money == USDTWei * 2000\r\n            || money == USDTWei * 1000\r\n            || money == USDTWei * 500\r\n            || money == USDTWei * 100\r\n            , \"invalid invest range\");\r\n\r\n        //init userInfo\r\n        uint[1] memory user_data;\r\n        (user_data, , ) = _getUserInfo(msg.sender);\r\n        uint user_id = user_data[0];\r\n\t\tif (user_id == 0) {\r\n\t\t\t_registerUser(msg.sender, code, rCode);\r\n            (user_data, , ) = _getUserInfo(msg.sender);\r\n            user_id = user_data[0];\r\n\t\t}\r\n\r\n\t\tUser storage user = userMapping[msg.sender];\r\n\t\tif (user.id == 0) {\r\n            user.id = user_id;\r\n\t\t}\r\n\r\n        //判断是已投资\r\n        require(user.investMoney == 0, \"Has been invested\");\r\n\r\n        //投资等级\r\n        uint8 investLevel = 0;\r\n        if(money == USDTWei * 2000) {\r\n            investLevel = 4;\r\n        } else if(money == USDTWei * 1000) {\r\n            investLevel = 3;\r\n        } else if(money == USDTWei * 500) {\r\n            investLevel = 2;\r\n        } else if(money == USDTWei * 100) {\r\n            investLevel = 1;\r\n        }\r\n        require(investLevel >= user.investLevel,\"invalid invest Level\");\r\n\r\n        if(AddupInvestUSD < USDTWei * 500000) {\r\n            //Transfer USDT Token to Contract\r\n            getTokenFormUser_USDT(USDTToken, msg.sender, money);\r\n        } else {\r\n            uint ETTMoney = money.mul(resonanceDataMapping[rid].ratio).mul(30).div(100);\r\n\r\n            //Transfer USDT Token to Contract\r\n            getTokenFormUser_USDT(USDTToken, msg.sender, money.mul(70).div(100));\r\n            //Transfer ETT Token to Contract\r\n            getTokenFormUser(msg.sender, ETTMoney);\r\n\r\n            //add user Token pool\r\n            ETTPool_User += ETTMoney;\r\n        }\r\n\r\n        //send USDT Token to dev addr\r\n        sendTokenToUser_USDT(USDTToken, devAddr, money.div(20));\r\n\r\n        //addup\r\n        AddupInvestUSD += money;\r\n\r\n        //user invest info\r\n        user.investAmountAddup += money;\r\n        user.investMoney = money;\r\n        user.investAddupStaticBonus = 0;\r\n        user.investAddupDynamicBonus = 0;\r\n        user.investOutMultiple = 22;\r\n        user.investLevel = investLevel;\r\n        user.investTime = uint40(now);\r\n        user.investLastRwTime = uint40(now);\r\n\r\n        //update Ratio\r\n        updateRatio(money);\r\n\r\n        //触发更新直推投资出局倍数\r\n        updateUser_Parent(rCode, money);\r\n\r\n        emit InvestEvent(msg.sender, code, rCode, money, now);\r\n\t}\r\n\r\n    /**\r\n     * @dev settlement\r\n     */\r\n    function settlement()\r\n        public\r\n        isHuman()\r\n    {\r\n\t\tUser storage user = userMapping[msg.sender];\r\n        checkUserID(user.id);\r\n\r\n        require(user.investMoney > 0, \"uninvested or out\");\r\n        require(now >= user.investLastRwTime, \"not release time\");\r\n\r\n        //reacquire rCode\r\n        address rCode;\r\n        (, , rCode) = _getUserInfo(msg.sender);\r\n\r\n        //-----------Static Start\r\n        uint settlementNumber_base = (now - user.investLastRwTime) / 1 days;\r\n        if (user.investMoney > 0 && settlementNumber_base > 0) \r\n        {\r\n            uint moneyBonus_base = user.investMoney * getScaleByLevel(user.investLevel) / 1000;\r\n            uint settlementNumber = settlementNumber_base;\r\n            uint settlementMaxMoney = 0;\r\n            if(user.investMoney * user.investOutMultiple / 10 >= user.investAddupStaticBonus + user.investAddupDynamicBonus) {\r\n                settlementMaxMoney = user.investMoney * user.investOutMultiple / 10 - (user.investAddupStaticBonus + user.investAddupDynamicBonus);\r\n            }\r\n            uint moneyBonus = 0;\r\n            if (moneyBonus_base * settlementNumber > settlementMaxMoney) \r\n            {\r\n                settlementNumber = settlementMaxMoney / moneyBonus_base;\r\n                if (moneyBonus_base * settlementNumber < settlementMaxMoney) {\r\n                    settlementNumber ++;\r\n                }\r\n                if (settlementNumber > settlementNumber_base) {\r\n                    settlementNumber = settlementNumber_base;\r\n                }\r\n                // moneyBonus = moneyBonus_base * settlementNumber;\r\n                moneyBonus = settlementMaxMoney;\r\n            } else {\r\n                moneyBonus = moneyBonus_base * settlementNumber;\r\n            }\r\n\r\n            user.takeBonusWallet += moneyBonus;\r\n            user.bonusStaticAmount += moneyBonus;\r\n\r\n            user.investAddupStaticBonus += moneyBonus;\r\n            user.investLastRwTime += uint40(settlementNumber * 1 days);\r\n            //check out\r\n            if (user.investAddupStaticBonus + user.investAddupDynamicBonus >= user.investMoney * user.investOutMultiple / 10) {\r\n                user.investAmountOut += user.investMoney;\r\n                user.investMoney = 0;//out\r\n            }\r\n\r\n            //Calculate the bonus (Daily Dividend)\r\n            // countBonus_DailyDividend(rCode, moneyBonus, user.investMoney);\r\n            countBonus_DailyDividend(rCode, moneyBonus_base * settlementNumber, user.investMoney);\r\n        }\r\n        //-----------Static End\r\n\t}\r\n\r\n    /**\r\n     * @dev the take bonus of contract is Beginning\r\n     * @param _type take type 0:default 100%USDT, 1:30%ETT 70%USDT, 2:50%ETT 50%USDT, 3:70%ETT 30%USDT, 4:100%ETT 0%USDT\r\n     */\r\n    function takeBonus(uint8 _type)\r\n        public\r\n        isHuman()\r\n    {\r\n\t\tUser storage user = userMapping[msg.sender];\r\n\t\tcheckUserID(user.id);\r\n\r\n\t\trequire(user.takeBonusWallet >= USDTWei * 1, \"invalid amount\");\r\n\r\n        uint sendDevMoney_USDT = user.takeBonusWallet.div(20);\r\n\t\tuint takeMoney_USDT = user.takeBonusWallet.sub(sendDevMoney_USDT);\r\n        uint takeMoney_USDT_ETT = 0;\r\n\r\n        //Calculation amount\r\n        (takeMoney_USDT, takeMoney_USDT_ETT) = calculationTakeBonus(_type, takeMoney_USDT);\r\n\r\n        bool isEnoughBalance = false;\r\n        uint resultMoney = 0;\r\n\r\n        //check send USDT\r\n        //check USDT Enough Balance\r\n        (isEnoughBalance, resultMoney) = isEnoughTokneBalance(USDTToken, takeMoney_USDT + sendDevMoney_USDT);\r\n        if(isEnoughBalance == false)\r\n        {\r\n            require(resultMoney > 0, \"not Enough Balance USDT\");\r\n            //correct\r\n            sendDevMoney_USDT = resultMoney.div(20);\r\n            takeMoney_USDT = resultMoney.sub(sendDevMoney_USDT);\r\n            //Calculation amount\r\n            (takeMoney_USDT, takeMoney_USDT_ETT) = calculationTakeBonus(_type, takeMoney_USDT);\r\n        }\r\n\r\n        //check send ETT\r\n        if(takeMoney_USDT_ETT > 0)\r\n        {\r\n            uint ETTMoney = takeMoney_USDT_ETT.mul(resonanceDataMapping[rid].ratio);\r\n            //check user Token pool\r\n            if(ETTMoney > ETTPool_User) {\r\n                ETTMoney = ETTPool_User;\r\n                require(ETTMoney > 0, \"not Enough Balance pool\");\r\n                //correct\r\n                uint ETTMoney_USDT = ETTMoney.div(resonanceDataMapping[rid].ratio);\r\n                sendDevMoney_USDT = sendDevMoney_USDT.mul(ETTMoney_USDT).div(takeMoney_USDT_ETT);\r\n                takeMoney_USDT = takeMoney_USDT.mul(ETTMoney_USDT).div(takeMoney_USDT_ETT);\r\n                takeMoney_USDT_ETT = ETTMoney_USDT;\r\n            }\r\n\r\n            //check ETT Enough Balance\r\n            (isEnoughBalance, resultMoney) = isEnoughTokneBalance(address(this), ETTMoney);\r\n            if(isEnoughBalance == false)\r\n            {\r\n                require(resultMoney > 0, \"not Enough Balance ETT\");\r\n                //correct\r\n                uint resultMoney_USDT = resultMoney.div(resonanceDataMapping[rid].ratio);\r\n                sendDevMoney_USDT = sendDevMoney_USDT.mul(resultMoney_USDT).div(takeMoney_USDT_ETT);\r\n                takeMoney_USDT = takeMoney_USDT.mul(resultMoney_USDT).div(takeMoney_USDT_ETT);\r\n                takeMoney_USDT_ETT = resultMoney_USDT;\r\n            }\r\n        }\r\n\r\n        if(sendDevMoney_USDT > 0)\r\n        {\r\n            //Transfer USDT Token to Dev\r\n            sendTokenToUser_USDT(USDTToken, devAddr, sendDevMoney_USDT);\r\n        }\r\n        if(takeMoney_USDT > 0)\r\n        {\r\n            //Transfer USDT Token to User\r\n            sendTokenToUser_USDT(USDTToken, msg.sender, takeMoney_USDT);\r\n        }\r\n        if(takeMoney_USDT_ETT > 0)\r\n        {\r\n            //Transfer ETT Token to User\r\n            sendTokenToUser(msg.sender, takeMoney_USDT_ETT.mul(resonanceDataMapping[rid].ratio));\r\n            ETTPool_User = ETTPool_User.sub(takeMoney_USDT_ETT.mul(resonanceDataMapping[rid].ratio));\r\n        }\r\n\r\n        user.takeBonusWallet = user.takeBonusWallet.sub(takeMoney_USDT).sub(takeMoney_USDT_ETT).sub(sendDevMoney_USDT);\r\n        user.takeBonusAddup = user.takeBonusAddup.add(takeMoney_USDT).add(takeMoney_USDT_ETT).add(sendDevMoney_USDT);\r\n\r\n        emit TakeBonusEvent(msg.sender, _type, takeMoney_USDT, takeMoney_USDT_ETT, now);\r\n\t}\r\n\r\n    /**\r\n     * @dev settlement ETT Pool Dev\r\n     */\r\n    function settlement_Dev()\r\n        public\r\n        isHuman()\r\n    {\r\n        require(now >= ETTPool_Dev_LastRwTime, \"not release time\");\r\n        require(ETTPool_Dev > ETTPool_Dev_RwAddup, \"release done\");\r\n        \r\n        uint settlementNumber_base =  (now - ETTPool_Dev_LastRwTime) / 1 days;\r\n        uint moneyBonus_base = ETTPool_Dev / 365;\r\n        uint settlementNumber = settlementNumber_base;\r\n        uint settlementMaxMoney = 0;\r\n        if(ETTPool_Dev >= ETTPool_Dev_RwAddup) {\r\n            settlementMaxMoney = ETTPool_Dev - ETTPool_Dev_RwAddup;\r\n        }\r\n        uint moneyBonus = 0;\r\n        if (moneyBonus_base * settlementNumber > settlementMaxMoney) \r\n        {\r\n            settlementNumber = settlementMaxMoney / moneyBonus_base;\r\n            if (moneyBonus_base * settlementNumber < settlementMaxMoney) {\r\n                settlementNumber ++;\r\n            }\r\n            if (settlementNumber > settlementNumber_base) {\r\n                settlementNumber = settlementNumber_base;\r\n            }\r\n            // moneyBonus = moneyBonus_base * settlementNumber;\r\n            moneyBonus = settlementMaxMoney;\r\n        } else {\r\n            moneyBonus = moneyBonus_base * settlementNumber;\r\n        }\r\n\r\n        //Transfer ETT Token to Dev\r\n        sendTokenToUser(devAddr, moneyBonus);\r\n\r\n        //update Dev_Rw\r\n        ETTPool_Dev_RwAddup += moneyBonus;\r\n        ETTPool_Dev_LastRwTime += uint40(settlementNumber * 1 days);\r\n\t}\r\n\r\n    /**\r\n     * @dev Show contract state view\r\n     * @return info contract state view\r\n     */\r\n    function stateView()\r\n        public\r\n        view\r\n        returns (uint[8] memory info)\r\n    {\r\n        info[0] = _getCurrentUserID();\r\n        info[1] = rid;\r\n        info[2] = resonanceDataMapping[rid].ratio;\r\n        info[3] = resonanceDataMapping[rid].investMoney;\r\n        info[4] = resonanceDataMapping[rid].time;\r\n        info[5] = AddupInvestUSD;\r\n        info[6] = ETTPool_Dev_RwAddup;\r\n        info[7] = ETTPool_Dev_LastRwTime;\r\n\r\n\t\treturn (info);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user info based\r\n     * @param addr user addressrd\r\n     * @return info user info\r\n     */\r\n\tfunction getUserByAddress(\r\n        address addr\r\n    )\r\n        public\r\n        view\r\n        returns (uint[14] memory info, address code, address rCode)\r\n    {\r\n        uint[1] memory user_data;\r\n        (user_data, code, rCode) = _getUserInfo(addr);\r\n        uint user_id = user_data[0];\r\n\r\n\t\tUser storage user = userMapping[addr];\r\n\r\n\t\tinfo[0] = user_id;\r\n        info[1] = user.investAmountAddup;\r\n        info[2] = user.investAmountOut;\r\n        info[3] = user.investMoney;\r\n        info[4] = user.investAddupStaticBonus;\r\n        info[5] = user.investAddupDynamicBonus;\r\n        info[6] = user.investOutMultiple;\r\n        info[7] = user.investLevel;\r\n        info[8] = user.investTime;\r\n        info[9] = user.investLastRwTime;\r\n        info[10] = user.bonusStaticAmount;\r\n        info[11] = user.bonusDynamicAmonut;\r\n        info[12] = user.takeBonusWallet;\r\n        info[13] = user.takeBonusAddup;\r\n\t\treturn (info, code, rCode);\r\n\t}\r\n\r\n    /**\r\n     * @dev update Resonance Ratio\r\n     * @param investMoney invest USDT amount\r\n     */\r\n\tfunction updateRatio(uint investMoney)\r\n        private\r\n    {\r\n        ResonanceData storage resonance = resonanceDataMapping[rid];\r\n        resonance.investMoney += investMoney;\r\n\r\n        //check\r\n        if(AddupInvestUSD >= USDTWei * 500000)\r\n        {\r\n            uint newRatio = 0;\r\n            uint newResonanceInvestMoney = 0;\r\n            if(rid == 1)\r\n            {\r\n                if(resonance.investMoney >= USDTWei * 600000)\r\n                {\r\n                    newResonanceInvestMoney = resonance.investMoney - USDTWei * 600000;\r\n                    resonance.investMoney = USDTWei * 600000;\r\n                    newRatio = getResonanceRatio(rid + 1);\r\n                }\r\n            } else {\r\n                if(resonance.investMoney >= USDTWei * 100000)\r\n                {\r\n                    newResonanceInvestMoney = resonance.investMoney - USDTWei * 100000;\r\n                    resonance.investMoney = USDTWei * 100000;\r\n                    newRatio = getResonanceRatio(rid + 1);\r\n                }\r\n            }\r\n\r\n            if (newRatio > 0) \r\n            {\r\n                rid ++;\r\n                resonance = resonanceDataMapping[rid];\r\n                resonance.time = uint40(now);\r\n                resonance.ratio = newRatio;\r\n                //Continuous rise\r\n                resonance.investMoney = newResonanceInvestMoney;\r\n                updateRatio(0);\r\n            }\r\n        }\r\n\t}\r\n\r\n        /**\r\n     * @dev update Parent User\r\n     * @param rCode user recommend code\r\n     * @param money invest money\r\n     */\r\n\tfunction updateUser_Parent(address rCode, uint money)\r\n        private\r\n    {\r\n\t\tif (rCode == address(0)) {\r\n            return;\r\n        }\r\n\r\n        User storage user = userMapping[rCode];\r\n\r\n        //-----------updateUser_Parent Start\r\n        if (user.investMoney > 0 && money >= user.investMoney) {\r\n            user.investOutMultiple = 30;\r\n        }\r\n        //-----------updateUser_Parent End\r\n\t}\r\n\r\n    /**\r\n     * @dev Calculate the bonus (Daily Dividend)\r\n     * @param rCode user recommend code\r\n     * @param money base money\r\n     * @param investMoney invest money\r\n     */\r\n\tfunction countBonus_DailyDividend(address rCode, uint money, uint investMoney)\r\n        private\r\n    {\r\n\t\taddress tmpReferrerCode = rCode;\r\n        address tmpUser_rCode;\r\n\r\n\t\tfor (uint i = 1; i <= 10; i++) {\r\n\t\t\tif (tmpReferrerCode == address(0)) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tUser storage user = userMapping[tmpReferrerCode];\r\n\r\n            //last rRcode and currUserInfo\r\n            (, , tmpUser_rCode) = _getUserInfo(tmpReferrerCode);\r\n\r\n            //-----------DailyDividend Start\r\n            if (user.investMoney > 0) \r\n            {\r\n                uint moneyBonusDailyDividend = 0;\r\n\r\n                (uint scale, uint algebra) = getScaleByDailyDividend(user.investLevel);\r\n                if (algebra >= i) \r\n                {\r\n                    moneyBonusDailyDividend = money * scale / 1000;\r\n                    //burns\r\n                    if (user.investMoney < investMoney) {\r\n                        moneyBonusDailyDividend = moneyBonusDailyDividend * user.investMoney / investMoney;\r\n                    }\r\n                    if (moneyBonusDailyDividend > 0) {\r\n                        //check out\r\n\r\n                        if (user.investAddupStaticBonus + user.investAddupDynamicBonus + moneyBonusDailyDividend >= user.investMoney * user.investOutMultiple / 10) {\r\n                            moneyBonusDailyDividend = user.investMoney * user.investOutMultiple / 10 - (user.investAddupStaticBonus + user.investAddupDynamicBonus);\r\n\r\n                            user.investAmountOut += user.investMoney;\r\n                            user.investMoney = 0;//out\r\n                        }\r\n                        user.takeBonusWallet += moneyBonusDailyDividend;\r\n                        user.bonusDynamicAmonut += moneyBonusDailyDividend;\r\n                        user.investAddupDynamicBonus += moneyBonusDailyDividend;\r\n                    }\r\n                }\r\n            }\r\n            //-----------DailyDividend End\r\n\r\n            tmpReferrerCode = tmpUser_rCode;\r\n\t\t}\r\n\t}\r\n\r\n\r\n    /**\r\n     * @dev Calculation amount\r\n     * @param _type take type\r\n     * @param takeMoney take Money\r\n     * @return takeMoney_USDT take Money USDT\r\n     * @return takeMoney_USDT_ETT take Money USDT(ETT)\r\n     */\r\n\tfunction calculationTakeBonus(uint8 _type, uint takeMoney)\r\n        internal\r\n        pure\r\n        returns (uint takeMoney_USDT, uint takeMoney_USDT_ETT)\r\n    {\r\n\t\ttakeMoney_USDT = takeMoney;\r\n\r\n        if(_type == 1) {\r\n            //ETT 30%\r\n            takeMoney_USDT_ETT = takeMoney_USDT.mul(30).div(100);\r\n        }\r\n        else if(_type == 2) {\r\n            //ETT 50%\r\n            takeMoney_USDT_ETT = takeMoney_USDT.div(2);\r\n        }\r\n        else if(_type == 3) {\r\n            //ETT 70%\r\n            takeMoney_USDT_ETT = takeMoney_USDT.mul(70).div(100);\r\n        }\r\n        else if(_type == 4) {\r\n            //ETT 100%\r\n            takeMoney_USDT_ETT = takeMoney_USDT;\r\n        }\r\n        takeMoney_USDT = takeMoney_USDT.sub(takeMoney_USDT_ETT);\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_USDTAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_code\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_rCode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"InvestEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value_USDT\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value_ETT\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TakeBonusEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserByAddress\",\"outputs\":[{\"internalType\":\"uint256[14]\",\"name\":\"info\",\"type\":\"uint256[14]\"},{\"internalType\":\"address\",\"name\":\"code\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rCode\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rCode\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"code\",\"type\":\"address\"}],\"name\":\"isUsedCode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlement_Dev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stateView\",\"outputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"info\",\"type\":\"uint256[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"takeBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EASContract","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d692d6626cad6d5bf6780660d6f4a2f1ca989f89000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6d02311a90b9127e1fde2853a5cac04a3e7838df8a507c97ac88de2bea740b6d"}]}