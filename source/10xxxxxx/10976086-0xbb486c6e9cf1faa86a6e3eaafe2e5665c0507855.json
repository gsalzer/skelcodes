{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(msg.sender), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/roles/WhitelistedRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title WhitelistedRole\r\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\r\n * it), and not Whitelisteds themselves.\r\n */\r\ncontract WhitelistedRole is WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(msg.sender), \"WhitelistedRole: caller does not have the Whitelisted role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(msg.sender);\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/roles/CapperRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract CapperRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event CapperAdded(address indexed account);\r\n    event CapperRemoved(address indexed account);\r\n\r\n    Roles.Role private _cappers;\r\n\r\n    constructor () internal {\r\n        _addCapper(msg.sender);\r\n    }\r\n\r\n    modifier onlyCapper() {\r\n        require(isCapper(msg.sender), \"CapperRole: caller does not have the Capper role\");\r\n        _;\r\n    }\r\n\r\n    function isCapper(address account) public view returns (bool) {\r\n        return _cappers.has(account);\r\n    }\r\n\r\n    function addCapper(address account) public onlyCapper {\r\n        _addCapper(account);\r\n    }\r\n\r\n    function renounceCapper() public {\r\n        _removeCapper(msg.sender);\r\n    }\r\n\r\n    function _addCapper(address account) internal {\r\n        _cappers.add(account);\r\n        emit CapperAdded(account);\r\n    }\r\n\r\n    function _removeCapper(address account) internal {\r\n        _cappers.remove(account);\r\n        emit CapperRemoved(account);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.5/interfaces/LinkTokenInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external view returns (string memory tokenName);\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\n// File: contracts/util/ERC677Receiver.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\ncontract ERC677Receiver {\r\n    /**\r\n    * @dev Method invoked when tokens transferred via transferAndCall method\r\n    * @param _sender Original token sender\r\n    * @param _value Tokens amount\r\n    * @param _data Additional data passed to contract\r\n    */\r\n    function onTokenTransfer(address _sender, uint256 _value, bytes calldata _data) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others (`ERC165Checker`).\r\n *\r\n * For an implementation, see `ERC165`.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * \r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either `approve` or `setApproveForAll`.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either `approve` or `setApproveForAll`.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: contracts/IRegistry.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ncontract IRegistry is IERC721Metadata {\r\n\r\n    event NewURI(uint256 indexed tokenId, string uri);\r\n\r\n    event NewURIPrefix(string prefix);\r\n\r\n    event Resolve(uint256 indexed tokenId, address indexed to);\r\n\r\n    event Sync(address indexed resolver, uint256 indexed updateId, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Controlled function to set the token URI Prefix for all tokens.\r\n     * @param prefix string URI to assign\r\n     */\r\n    function controlledSetTokenURIPrefix(string calldata prefix) external;\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID.\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Mints a new a child token.\r\n     * Calculates child token ID using a namehash function.\r\n     * Requires the msg.sender to be the owner, approved, or operator of tokenId.\r\n     * Requires the token not exist.\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the parent token\r\n     * @param label subdomain label of the child token ID\r\n     */\r\n    function mintChild(address to, uint256 tokenId, string calldata label) external;\r\n\r\n    /**\r\n     * @dev Controlled function to mint a given token ID.\r\n     * Requires the msg.sender to be controller.\r\n     * Requires the token ID to not exist.\r\n     * @param to address the given token ID will be minted to\r\n     * @param label string that is a subdomain\r\n     * @param tokenId uint256 ID of the parent token\r\n     */\r\n    function controlledMintChild(address to, uint256 tokenId, string calldata label) external;\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a child token ID to another address.\r\n     * Calculates child token ID using a namehash function.\r\n     * Requires the msg.sender to be the owner, approved, or operator of tokenId.\r\n     * Requires the token already exist.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param label subdomain label of the child token ID\r\n     */\r\n    function transferFromChild(address from, address to, uint256 tokenId, string calldata label) external;\r\n\r\n    /**\r\n     * @dev Controlled function to transfers the ownership of a token ID to\r\n     * another address.\r\n     * Requires the msg.sender to be controller.\r\n     * Requires the token already exist.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function controlledTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a child token ID to another address.\r\n     * Calculates child token ID using a namehash function.\r\n     * Implements a ERC721Reciever check unlike transferFromChild.\r\n     * Requires the msg.sender to be the owner, approved, or operator of tokenId.\r\n     * Requires the token already exist.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 parent ID of the token to be transferred\r\n     * @param label subdomain label of the child token ID\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFromChild(address from, address to, uint256 tokenId, string calldata label, bytes calldata _data) external;\r\n\r\n    /// Shorthand for calling the above ^^^ safeTransferFromChild function with an empty _data parameter. Similar to ERC721.safeTransferFrom.\r\n    function safeTransferFromChild(address from, address to, uint256 tokenId, string calldata label) external;\r\n\r\n    /**\r\n     * @dev Controlled frunction to safely transfers the ownership of a token ID\r\n     * to another address.\r\n     * Implements a ERC721Reciever check unlike controlledSafeTransferFrom.\r\n     * Requires the msg.sender to be controller.\r\n     * Requires the token already exist.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 parent ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function controlledSafeTransferFrom(address from, address to, uint256 tokenId, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @dev Burns a child token ID.\r\n     * Calculates child token ID using a namehash function.\r\n     * Requires the msg.sender to be the owner, approved, or operator of tokenId.\r\n     * Requires the token already exist.\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param label subdomain label of the child token ID\r\n     */\r\n    function burnChild(uint256 tokenId, string calldata label) external;\r\n\r\n    /**\r\n     * @dev Controlled function to burn a given token ID.\r\n     * Requires the msg.sender to be controller.\r\n     * Requires the token already exist.\r\n     * @param tokenId uint256 ID of the token to be burned\r\n     */\r\n    function controlledBurn(uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Sets the resolver of a given token ID to another address.\r\n     * Requires the msg.sender to be the owner, approved, or operator.\r\n     * @param to address the given token ID will resolve to\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function resolveTo(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gets the resolver of the specified token ID.\r\n     * @param tokenId uint256 ID of the token to query the resolver of\r\n     * @return address currently marked as the resolver of the given token ID\r\n     */\r\n    function resolverOf(uint256 tokenId) external view returns (address);\r\n\r\n    /**\r\n     * @dev Controlled function to sets the resolver of a given token ID.\r\n     * Requires the msg.sender to be controller.\r\n     * @param to address the given token ID will resolve to\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function controlledResolveTo(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Provides child token (subdomain) of provided tokenId.\r\n     * @param tokenId uint256 ID of the token\r\n     * @param label label of subdomain (for `aaa.bbb.crypto` it will be `aaa`)\r\n     */\r\n    function childIdOf(uint256 tokenId, string calldata label) external pure returns (uint256);\r\n\r\n    /**\r\n     * @dev Transfer domain ownership without resetting domain records.\r\n     * @param to address of new domain owner\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function setOwner(address to, uint256 tokenId) external;\r\n}\r\n\r\n// File: contracts/IResolver.sol\r\n\r\npragma solidity 0.5.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract IResolver {\r\n    /**\r\n     * @dev Reset all domain records and set new ones\r\n     * @param keys New record keys\r\n     * @param values New record values\r\n     * @param tokenId ERC-721 token id of the domain\r\n     */\r\n    function reconfigure(string[] memory keys, string[] memory values, uint256 tokenId) public;\r\n\r\n    /**\r\n     * @dev Set or update domain records\r\n     * @param keys New record keys\r\n     * @param values New record values\r\n     * @param tokenId ERC-721 token id of the domain\r\n     */\r\n    function setMany(string[] memory keys, string[] memory values, uint256 tokenId) public;\r\n\r\n    /**\r\n     * @dev Function to set record.\r\n     * @param key The key set the value of.\r\n     * @param value The value to set key to.\r\n     * @param tokenId ERC-721 token id to set.\r\n     */\r\n    function set(string calldata key, string calldata value, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Function to reset all existing records on a domain.\r\n     * @param tokenId ERC-721 token id to set.\r\n     */\r\n    function reset(uint256 tokenId) external;\r\n}\r\n\r\n// File: contracts/operators/TwitterValidationOperator.sol\r\n\r\npragma solidity 0.5.12;\r\n// pragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TwitterValidationOperator is WhitelistedRole, CapperRole, ERC677Receiver {\r\n    string public constant NAME = 'Chainlink Twitter Validation Operator';\r\n    string public constant VERSION = '0.2.0';\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event Validation(uint256 indexed tokenId, uint256 requestId, uint256 paymentAmount);\r\n    event ValidationRequest(uint256 indexed tokenId, address indexed owner, uint256 requestId, string code);\r\n    event PaymentSet(uint256 operatorPaymentPerValidation, uint256 userPaymentPerValidation);\r\n\r\n    uint256 public operatorPaymentPerValidation;\r\n    uint256 public userPaymentPerValidation;\r\n    uint256 public withdrawableTokens;\r\n\r\n    uint256 private frozenTokens;\r\n    uint256 private lastRequestId = 1;\r\n    mapping(uint256 => uint256) private userRequests;\r\n    IRegistry private registry;\r\n    LinkTokenInterface private linkToken;\r\n\r\n    /**\r\n    * @notice Deploy with the address of the LINK token, domains registry and payment amount in LINK for one valiation\r\n    * @dev Sets the LinkToken address, Registry address and payment in LINK tokens for one validation\r\n    * @param _registry The address of the .crypto Registry\r\n    * @param _linkToken The address of the LINK token\r\n    * @param _paymentCappers Addresses allowed to update payment amount per validation\r\n    */\r\n    constructor (IRegistry _registry, LinkTokenInterface _linkToken, address[] memory _paymentCappers) public {\r\n        require(address(_registry) != address(0), \"TwitterValidationOperator: INVALID_REGISTRY_ADDRESS\");\r\n        require(address(_linkToken) != address(0), \"TwitterValidationOperator: INVALID_LINK_TOKEN_ADDRESS\");\r\n        require(_paymentCappers.length > 0, \"TwitterValidationOperator: NO_CAPPERS_PROVIDED\");\r\n        registry = _registry;\r\n        linkToken = _linkToken;\r\n        uint256 cappersCount = _paymentCappers.length;\r\n        for (uint256 i = 0; i < cappersCount; i++) {\r\n            addCapper(_paymentCappers[i]);\r\n        }\r\n        renounceCapper();\r\n    }\r\n\r\n    /**\r\n    * @dev Reverts if amount requested is greater than withdrawable balance\r\n    * @param _amount The given amount to compare to `withdrawableTokens`\r\n    */\r\n    modifier hasAvailableFunds(uint256 _amount) {\r\n        require(withdrawableTokens >= _amount, \"TwitterValidationOperator: TOO_MANY_TOKENS_REQUESTED\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if contract doesn not have enough LINK tokens to fulfil validation\r\n     */\r\n    modifier hasAvailableBalance() {\r\n        require(\r\n            availableBalance() >= withdrawableTokens.add(operatorPaymentPerValidation),\r\n            \"TwitterValidationOperator: NOT_ENOUGH_TOKENS_ON_CONTRACT_BALANCE\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if method called not from LINK token contract\r\n     */\r\n    modifier linkTokenOnly() {\r\n        require(msg.sender == address(linkToken), \"TwitterValidationOperator: CAN_CALL_FROM_LINK_TOKEN_ONLY\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if user sent incorrect amount of LINK tokens\r\n     */\r\n    modifier correctTokensAmount(uint256 _value) {\r\n        require(_value == userPaymentPerValidation, \"TwitterValidationOperator: INCORRECT_TOKENS_AMOUNT\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Method will be called by Chainlink node in the end of the job. Provides user twitter name and validation signature\r\n     * @dev Sets twitter username and signature to .crypto domain records\r\n     * @param _username Twitter username\r\n     * @param _signature Signed twitter username. Ensures the validity of twitter username\r\n     * @param _tokenId Domain token ID\r\n     * @param _requestId Request id for validations were requested from Smart Contract. If validation was requested from operator `_requestId` should be equals to zero.\r\n     */\r\n    function setValidation(string calldata _username, string calldata _signature, uint256 _tokenId, uint256 _requestId)\r\n    external\r\n    onlyWhitelisted\r\n    hasAvailableBalance {\r\n        uint256 _payment = calculatePaymentForValidation(_requestId);\r\n        withdrawableTokens = withdrawableTokens.add(_payment);\r\n        IResolver Resolver = IResolver(registry.resolverOf(_tokenId));\r\n        Resolver.set(\"social.twitter.username\", _username, _tokenId);\r\n        Resolver.set(\"validation.social.twitter.username\", _signature, _tokenId);\r\n        emit Validation(_tokenId, _requestId, _payment);\r\n    }\r\n\r\n    /**\r\n    * @notice Method returns true if Node Operator able to set validation\r\n    * @dev Returns true or error\r\n    */\r\n    function canSetValidation() external view onlyWhitelisted hasAvailableBalance returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Method allows to update payments per one validation in LINK tokens\r\n     * @dev Sets operatorPaymentPerValidation and userPaymentPerValidation variables\r\n     * @param _operatorPaymentPerValidation Payment amount in LINK tokens when verification initiated via Operator\r\n     * @param _userPaymentPerValidation Payment amount in LINK tokens when verification initiated directly by user via Smart Contract call\r\n     */\r\n    function setPaymentPerValidation(uint256 _operatorPaymentPerValidation, uint256 _userPaymentPerValidation) external onlyCapper {\r\n        operatorPaymentPerValidation = _operatorPaymentPerValidation;\r\n        userPaymentPerValidation = _userPaymentPerValidation;\r\n        emit PaymentSet(operatorPaymentPerValidation, userPaymentPerValidation);\r\n    }\r\n\r\n    /**\r\n    * @notice Allows the node operator to withdraw earned LINK to a given address\r\n    * @dev The owner of the contract can be another wallet and does not have to be a Chainlink node\r\n    * @param _recipient The address to send the LINK token to\r\n    * @param _amount The amount to send (specified in wei)\r\n    */\r\n    function withdraw(address _recipient, uint256 _amount) external onlyWhitelistAdmin hasAvailableFunds(_amount) {\r\n        withdrawableTokens = withdrawableTokens.sub(_amount);\r\n        assert(linkToken.transfer(_recipient, _amount));\r\n    }\r\n\r\n    /**\r\n    * @notice Initiate Twitter validation\r\n    * @dev Method invoked when LINK tokens transferred via transferAndCall method. Requires additional encoded data\r\n    * @param _sender Original token sender\r\n    * @param _value Tokens amount\r\n    * @param _data Encoded additional data needed to initiate domain verification: `abi.encode(uint256 tokenId, string code)`\r\n    */\r\n    function onTokenTransfer(address _sender, uint256 _value, bytes calldata _data) external linkTokenOnly correctTokensAmount(_value) {\r\n        (uint256 _tokenId, string memory _code) = abi.decode(_data, (uint256, string));\r\n        require(registry.isApprovedOrOwner(_sender, _tokenId), \"TwitterValidationOperator: SENDER_DOES_NOT_HAVE_ACCESS_TO_DOMAIN\");\r\n        require(bytes(_code).length > 0, \"TwitterValidationOperator: CODE_IS_EMPTY\");\r\n        require(registry.isApprovedOrOwner(address(this), _tokenId), \"TwitterValidationOperator: OPERATOR_SHOULD_BE_APPROVED\");\r\n        frozenTokens = frozenTokens.add(_value);\r\n        userRequests[lastRequestId] = _value;\r\n\r\n        emit ValidationRequest(_tokenId, registry.ownerOf(_tokenId), lastRequestId, _code);\r\n        lastRequestId = lastRequestId.add(1);\r\n    }\r\n\r\n    /**\r\n    * @notice Method returns available LINK tokens balance minus held tokens\r\n    * @dev Returns tokens amount\r\n    */\r\n    function availableBalance() public view returns (uint256) {\r\n        return linkToken.balanceOf(address(this)).sub(frozenTokens);\r\n    }\r\n\r\n    function calculatePaymentForValidation(uint256 _requestId) private returns (uint256 _paymentPerValidation) {\r\n        if (_requestId > 0) {// Validation was requested from Smart Contract. We need to search for price in mapping\r\n            _paymentPerValidation = userRequests[_requestId];\r\n            frozenTokens = frozenTokens.sub(_paymentPerValidation);\r\n            delete userRequests[_requestId];\r\n        } else {\r\n            _paymentPerValidation = operatorPaymentPerValidation;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"_linkToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_paymentCappers\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"CapperAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"CapperRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operatorPaymentPerValidation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userPaymentPerValidation\",\"type\":\"uint256\"}],\"name\":\"PaymentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"}],\"name\":\"Validation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"ValidationRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedRemoved\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addCapper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canSetValidation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isCapper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operatorPaymentPerValidation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceCapper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_operatorPaymentPerValidation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userPaymentPerValidation\",\"type\":\"uint256\"}],\"name\":\"setPaymentPerValidation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_signature\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"setValidation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userPaymentPerValidation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TwitterValidationOperator","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d1e5b0ff1287aa9f9a268759062e4ab08b9dacbe000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d67a6512c5fce7830629e1f3d067115b57fdb333000000000000000000000000c2cc046e7f4f7a3e9715a853fc54907c12364b6b","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6dc5865dec1e85cab5d34bc96037f289720ae15bb37b90f483e4b4b6f0839ef2"}]}