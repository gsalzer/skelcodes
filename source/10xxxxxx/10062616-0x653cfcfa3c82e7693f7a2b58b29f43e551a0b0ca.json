{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.16 <0.7.0;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Register  {\r\n    \r\n    using SafeMath for *;\r\n    uint256 public id;\r\n    uint256 public deposit;\r\n    address private owner;\r\n\r\n    struct AddressList{\r\n        uint256 id;\r\n        address user;\r\n     //   string mat;\r\n        \r\n    }\r\n    \r\n    struct Account {\r\n    address referrer;\r\n    uint256 joinCount;\r\n    uint256 referredCount;\r\n    uint256 depositTotal;\r\n    uint256 joinDate;\r\n    uint256 withdrawHis;\r\n    uint256 currentCReward;\r\n    uint256 currentCUpdatetime;\r\n    uint256 championReward;\r\n    uint256 cWithdrawTime;\r\n    uint256 isAdminAccount;\r\n    }\r\n    \r\n    struct CheckIn{\r\n    address user;\r\n    uint256 totalCheck;\r\n    uint256 amt;\r\n    uint256 checkTime;\r\n    uint256 dynamic;\r\n    }\r\n\r\n    struct Limit{\r\n        uint256 special;\r\n    }\r\n    \r\n    struct RewardWinner{\r\n    uint256 winId;\r\n    uint256 time;\r\n    address winner;\r\n    uint256 totalRefer;\r\n    uint256 winPayment;\r\n    }\r\n    \r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (uint256 => RewardWinner) internal rewardHistory;\r\n    mapping (address => Account) public accounts;\r\n    mapping (address => CheckIn) public loginCount;\r\n    mapping (uint256 => AddressList) public idList;\r\n    mapping (address => AddressList) public userList;\r\n    mapping (address => Limit) public limitList;\r\n    \r\n    event RegisteredReferer(address referee, address referrer);\r\n    event RegisteredRefererRejoin(address referee, address referrer);\r\n    event RegisteredRefererFailed(address referee, address referrer);\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier isNotRegister(address _user) {\r\n        require(userList[_user].user==address(0), \"Address registered!\");\r\n        _;\r\n    }\r\n    \r\n    modifier isCorrectAddress(address _user) {\r\n        require(_user !=address(0), \"Invalid Address!\");\r\n        _;\r\n    }\r\n    \r\n    modifier isNotReferrer(address currentUser,address user) {\r\n        require(currentUser !=user, \"Referrer cannot register as its own Referee\");\r\n       \r\n        _;\r\n    }\r\n    modifier hasReferrer(address _user) {\r\n        require(accounts[_user].referrer !=address(0), \"Referee has registered!\");\r\n        _;\r\n    }\r\n    \r\n    modifier isRegister(address _user) {\r\n        require(userList[_user].user!=address(0), \"Address not register!\");\r\n        _;\r\n    }\r\n    \r\n    modifier hasDepositTotal(address _user) {\r\n        require(accounts[_user].depositTotal>=0.5 ether, \"No Deposit!\");\r\n        _;\r\n    }\r\n    \r\n    modifier hasCReward() {\r\n        require(accounts[msg.sender].currentCReward>0, \"No Champion Reward!\");\r\n        _;\r\n    }\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n    \r\n    function() external payable {\r\n        require(accounts[msg.sender].joinCount<0,\"Invalid Join\");\r\n        revert();\r\n    }\r\n    \r\n    function newReg(address referrer) public \r\n    isCorrectAddress(msg.sender) isRegister(referrer) isNotReferrer(msg.sender,referrer) \r\n    payable returns (bool){\r\n          require(checkJoinAmt(msg.sender,msg.value),\"Invalid participation deposit\");\r\n    if(checkJoinCount(msg.sender)==0 && checkJoinAmt(msg.sender,msg.value)){\r\n          require(userList[msg.sender].user==address(0), \"User registered!\");\r\n          deposit=deposit.add(msg.value);\r\n          accounts[msg.sender].joinCount=checkJoinCount(msg.sender);\r\n          accounts[msg.sender].referrer = referrer;\r\n          accounts[msg.sender].depositTotal = msg.value;\r\n          accounts[referrer].referredCount = accounts[referrer].referredCount.add(1);\r\n          accounts[msg.sender].joinDate=getTime();\r\n          id++;\r\n          userList[msg.sender].id = id;\r\n          userList[msg.sender].user=msg.sender;\r\n          idList[id].id = id;\r\n          idList[id].user=msg.sender;\r\n          loginCount[msg.sender].user=msg.sender;\r\n          emit RegisteredReferer(msg.sender, referrer);\r\n          return true;\r\n    }else if(checkJoinCount(msg.sender)>=1 && checkJoinAmt(msg.sender,msg.value)){\r\n          require(userList[msg.sender].user!=address(0), \"User not yet registered!\");\r\n          deposit=deposit.add(msg.value);\r\n            accounts[msg.sender].joinCount=checkJoinCount(msg.sender);\r\n            accounts[msg.sender].withdrawHis=0;\r\n            accounts[msg.sender].depositTotal=msg.value;\r\n            accounts[msg.sender].joinDate = getTime();\r\n            loginCount[msg.sender].checkTime=0;\r\n            loginCount[msg.sender].dynamic=0;\r\n            emit RegisteredRefererRejoin(msg.sender, referrer);\r\n            return true;\r\n    }else{\r\n        emit RegisteredRefererFailed(msg.sender, referrer);\r\n        require(accounts[msg.sender].joinCount<0,\"Invalid Join!\");\r\n        return false;\r\n        }\r\n    }\r\n    function checkIn() public hasDepositTotal(msg.sender) {\r\n        uint256 day1=checktime();\r\n        uint256 amount=payfixeduser(day1);\r\n        require(amount>0,\"Already Check In\");\r\n        uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\r\n          uint256 total=amount+loginCount[msg.sender].dynamic;\r\n          if((total+loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)>multi)\r\n          {\r\n              total=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis;\r\n          }\r\n          loginCount[msg.sender].checkTime=checkTimeExtra();\r\n          loginCount[msg.sender].dynamic=0;\r\n          loginCount[msg.sender].amt=loginCount[msg.sender].amt.add(total);\r\n           paydynamicparent(day1);\r\n    }\r\n      \r\n    function checkInspecial() public hasDepositTotal(msg.sender){\r\n          uint256 day1=checktime();\r\n        uint256 amount=payfixeduser(day1);\r\n        require(amount>0,\"Already Check In\");\r\n        uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\r\n          uint256 total=amount+limitdynamic(day1);\r\n          if((total+loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)>multi)\r\n          {\r\n              total=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis;\r\n          }\r\n          loginCount[msg.sender].checkTime=checkTimeExtra();\r\n          loginCount[msg.sender].amt=loginCount[msg.sender].amt.add(total);\r\n          loginCount[msg.sender].totalCheck=loginCount[msg.sender].totalCheck.add(1);\r\n    }\r\n    function cRewardWithdraw() public hasCReward payable{\r\n        uint256 amount=accounts[msg.sender].currentCReward;\r\n        accounts[msg.sender].championReward=accounts[msg.sender].championReward.add(amount);\r\n        accounts[msg.sender].cWithdrawTime=getTime();\r\n        msg.sender.transfer(amount);\r\n        accounts[msg.sender].currentCReward=0;\r\n    }\r\n    function WithdrawReward()public payable returns(uint256){\r\n        msg.sender.transfer(loginCount[msg.sender].amt);\r\n        accounts[msg.sender].withdrawHis=accounts[msg.sender].withdrawHis.add(loginCount[msg.sender].amt);\r\n        loginCount[msg.sender].amt=0;\r\n        return accounts[msg.sender].withdrawHis;\r\n    }\r\n    function countAMT() public view returns(uint){\r\n         uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\r\n          uint256 amt=loginCount[msg.sender].dynamic.add(payfixedpersonal());\r\n          if((amt+loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)>multi)\r\n          {\r\n              amt=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis;\r\n          }\r\n          return amt; \r\n    }\r\n    function checktime() public view returns(uint){\r\n        uint256 daystime=0;\r\n        uint256 starttime=0;\r\n        if(loginCount[msg.sender].checkTime!=0 && accounts[msg.sender].joinDate>0){\r\n          starttime= loginCount[msg.sender].checkTime;\r\n          daystime=getTime().sub(starttime);\r\n          daystime=daystime.div(43200);\r\n        }else if(accounts[msg.sender].joinDate>0){\r\n              starttime= accounts[msg.sender].joinDate;\r\n      daystime=getTime().sub(starttime);\r\n      daystime=daystime.div(43200);\r\n        }\r\n        if(daystime>=40)\r\n        {\r\n            daystime=40;\r\n        }\r\n      return daystime;\r\n    }\r\n    \r\n    function checkTimeExtra() public view returns(uint){\r\n        require(accounts[msg.sender].joinDate>0);\r\n        uint256 divtime=0;\r\n        uint256 second=0;\r\n        uint256 remainder=0;\r\n        if(loginCount[msg.sender].checkTime!=0){\r\n         divtime=getTime()-loginCount[msg.sender].checkTime;\r\n         second=SafeMath.mod(divtime,43200);\r\n         remainder=getTime()-second;\r\n        }else if(accounts[msg.sender].joinDate>0){\r\n         divtime=getTime()-accounts[msg.sender].joinDate;\r\n         second=SafeMath.mod(divtime,43200);\r\n         remainder=getTime()-second;\r\n        }\r\n      return remainder;\r\n    }\r\n    function calldynamic() public view returns(uint){\r\n           uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\r\n           uint256 total=0;\r\n           uint256 day=checktime();\r\n           if(payfixeduser(day)>payfixedpersonal())\r\n           {\r\n               return 0;\r\n           }else if((loginCount[msg.sender].dynamic+payfixedpersonal()+loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)>multi)\r\n          {\r\n           return total=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis-payfixedpersonal();\r\n          }else{\r\n            return loginCount[msg.sender].dynamic;\r\n          }\r\n    }\r\n    function showdynamic() public view returns(uint){\r\n        uint256 day=checktime();\r\n        uint256 amount=payfixeduser(day);\r\n        Limit memory checklimit=limitList[owner];\r\n       uint256 example=0;\r\n       if(special>0)\r\n       {\r\n            example=checklimit.special*day;\r\n       }\r\n     uint256 multi=accounts[msg.sender].depositTotal;\r\n     if(payfixeduser(day)>payfixedpersonal())\r\n     {\r\n         example=0;\r\n     }else  if((amount+example+loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)>multi)\r\n          {\r\n              example=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis-amount;\r\n          }\r\n         uint256 special=accounts[msg.sender].isAdminAccount;\r\n       \r\n       return example;\r\n    }\r\n    function payfixedpersonal() public view returns(uint){\r\n        uint256 day=checktime();\r\n        uint256 value=accounts[msg.sender].depositTotal;\r\n        uint256 a = value.mul(6).div(1000).mul(day);\r\n        uint256 withdrawNow=accounts[msg.sender].withdrawHis;\r\n        uint256 dynamic=loginCount[msg.sender].dynamic;\r\n        uint256 amtNow=loginCount[msg.sender].amt;\r\n        uint256 totalAll=withdrawNow.add(amtNow);\r\n        uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\r\n        if(totalAll+dynamic>=multi){\r\n            return a;\r\n        }else if(a>0 && totalAll<=multi){\r\n            return a;\r\n        }\r\n    }\r\n    \r\n    function countremain() public view returns(uint){\r\n          uint256 remaining=0;\r\n         uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\r\n         if((loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)<multi){\r\n        remaining=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis;\r\n         }else{\r\n             remaining=0;\r\n         }\r\n          return remaining;\r\n    }\r\n      \r\n    function checkJoinCount(address _user)internal view returns(uint){\r\n          uint256 joinVal=accounts[_user].joinCount;\r\n          uint256 currentDepo=accounts[_user].depositTotal;\r\n          uint256 currentWith=accounts[_user].withdrawHis;\r\n          uint256 multi=currentDepo.mul(32).div(10);\r\n              if(currentDepo>0 ){\r\n              require(currentWith>=multi,'must more than withdrawHis');\r\n                  joinVal=joinVal.add(1);\r\n              }else{\r\n              joinVal=0;\r\n              }\r\n          return joinVal;\r\n    }\r\n    function checkJoinAmt(address _user, uint256 _amt) internal isCorrectAddress(_user) view returns(bool){\r\n          if(accounts[_user].isAdminAccount!=0){\r\n              require(_amt<=2 ether);\r\n              return true;\r\n          }else if(accounts[_user].depositTotal==0 && accounts[_user].joinCount==0){\r\n              require(_amt==0.5 ether, \"Invalid amount join\");\r\n              return true;\r\n          }else if(accounts[_user].depositTotal>0 && accounts[_user].joinCount==0){\r\n              require(_amt<=1 ether, \"Invalid amount join\");\r\n              return true;\r\n          }else if(accounts[_user].joinCount>=1){\r\n              require(_amt<=2 ether,\"Invalid Amount join\");\r\n              return true;\r\n          }else\r\n          return false;\r\n    }\r\n      \r\n    function checkLevel(address _user) internal view returns(uint){\r\n        uint256 level=0;\r\n        uint256 ori=accounts[_user].referredCount;\r\n        if(accounts[_user].depositTotal==0.5 ether){\r\n            level = 10;\r\n        }else if(accounts[_user].depositTotal==1 ether){\r\n            level =15 ;\r\n        }else if(accounts[_user].depositTotal==2 ether){\r\n            level = 20;\r\n        }\r\n        if(ori<level)\r\n        {\r\n            return ori;\r\n        }else\r\n        {\r\n        return level;\r\n        }\r\n    }\r\n    \r\n    function checkRewardStatus(address _user) internal view returns(uint){\r\n        uint256 totalAll=accounts[_user].withdrawHis.add(loginCount[_user].amt);\r\n        uint256 multi=accounts[_user].depositTotal.mul(32).div(10);\r\n        if(totalAll>=multi){\r\n            return 0;\r\n        }else{\r\n            return 1;\r\n        }\r\n    }\r\n    \r\n    function countdynamic(uint256 day) internal view returns(uint){\r\n        uint256 value=accounts[msg.sender].depositTotal;\r\n        uint256 a=0;\r\n        if(day>=40){\r\n            day=40;\r\n        }\r\n         a = value.mul(36).div(100000).mul(day);\r\n            return a;\r\n    }\r\n    function limitdynamic(uint256 day) internal view returns(uint){\r\n         uint256 special=accounts[msg.sender].isAdminAccount;\r\n       uint256 example=0;\r\n       if(special>0)\r\n       {\r\n            example=limitList[owner].special*day;\r\n       }\r\n       return example;\r\n    }\r\n    function paydynamicparent(uint256 day) internal {\r\n        Account memory userAccount = accounts[msg.sender];\r\n        uint256 c=countdynamic(day);\r\n        for (uint256 i=1; i <= 20; i++) {\r\n        address  parent = userAccount.referrer;\r\n        uint256 ownlimit=checkLevel(parent);\r\n        \r\n        if (parent == address(0)) {\r\n            break;\r\n        }\r\n        if(i<=ownlimit)\r\n        {\r\n          loginCount[userAccount.referrer].dynamic = loginCount[userAccount.referrer].dynamic.add(c);\r\n        }\r\n        userAccount = accounts[userAccount.referrer];\r\n        }\r\n    }\r\n    \r\n    function payfixeduser(uint256 day) internal view returns (uint) {\r\n        uint256 value=accounts[msg.sender].depositTotal;\r\n        uint256 a=0;\r\n        if(day>=40){\r\n            day=40;\r\n        }\r\n         a = value.mul(36).div(100000).mul(day);\r\n         return a;\r\n    }\r\n    \r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n    \r\n    function getTime() public view returns(uint256) {\r\n        return block.timestamp; \r\n    }\r\n    \r\n    function declareLimit(uint256 spec)public onlyOwner {\r\n          limitList[owner].special=spec;\r\n    }\r\n    \r\n    function sendRewards(address _user,uint256 amount) public onlyOwner returns(bool) {\r\n        if(_user==address(0)){\r\n            _user=owner;\r\n        }\r\n        _user.transfer(amount);\r\n        return true;\r\n    }\r\n    \r\n    function withdraw(uint256 amount) public onlyOwner returns(bool) {\r\n        owner.transfer(amount);\r\n        return true;\r\n    }\r\n    \r\n    function updateDynamic(address _user,uint256 amount) public onlyOwner{\r\n        CheckIn storage updateDyn = loginCount[_user];\r\n        updateDyn.dynamic=loginCount[_user].dynamic.add(amount);\r\n    }\r\n    \r\n    function cRewardUpdate(address _user,uint256 amount,uint256 timestamp) public isCorrectAddress(_user) hasReferrer(_user) hasDepositTotal(_user) onlyOwner returns(bool){\r\n        Account storage cRewardUp=accounts[_user];\r\n        cRewardUp.currentCReward=accounts[_user].currentCReward.add(amount);\r\n        cRewardUp.currentCUpdatetime=timestamp;\r\n        return true;\r\n    }\r\n    \r\n    function updateRewardHis(uint256 rewardId,uint256 maxRefer, uint256 time,address _user,uint256 amt) public onlyOwner returns(bool) {\r\n       RewardWinner storage updateReward = rewardHistory[rewardId];\r\n       updateReward.winId = rewardId;\r\n       updateReward.time=time;\r\n       updateReward.winner=_user;\r\n       updateReward.totalRefer=maxRefer;\r\n       updateReward.winPayment= amt;\r\n        return true;\r\n    }\r\n    \r\n    function addDeposit() public payable onlyOwner returns (uint256){\r\n        balanceOf[msg.sender]=balanceOf[msg.sender].add(msg.value);\r\n        return balanceOf[msg.sender];\r\n    }\r\n    \r\n    function addReferrer(address _referrer,address _referee,uint256 _deposit,uint256 _time,uint256 _withdrawHis,uint256 _joinCount, uint256 _currentCReward,uint256 _special,uint256 _checkTime,uint256 _amt,uint256 _dynamic) \r\n    public payable onlyOwner returns(bool){\r\n          registerUser(_referrer,_referee,_time,_deposit);\r\n          updateUser(_referee,_withdrawHis,_currentCReward,_joinCount,_special);\r\n          newAddress(_referee);\r\n          newCheckIn(_referee,_amt,_dynamic,_checkTime);\r\n          emit RegisteredReferer(_referee, _referrer);\r\n          return true;\r\n    }\r\n    \r\n    function registerUser(address _referrer,address _referee,uint256 _time,uint256 _depositTotal) internal \r\n    isNotReferrer(_referee,_referrer) \r\n    isNotRegister(_referee)\r\n    onlyOwner \r\n    returns(bool){\r\n         accounts[_referrer].referredCount = 20;\r\n          accounts[_referee].referrer=_referrer;\r\n          accounts[_referee].joinDate=_time;\r\n          accounts[_referee].depositTotal=_depositTotal;\r\n          deposit=deposit.add(_depositTotal);\r\n          emit RegisteredReferer(_referee, _referrer);\r\n          return true;\r\n    }\r\n    \r\n    function updateUser(address _referee, uint256 _withdrawHis,uint256 _currentCReward,uint256 _joinCount,uint256 _special) internal hasReferrer(_referee) onlyOwner returns(bool){\r\n          accounts[_referee].withdrawHis=_withdrawHis;\r\n          accounts[_referee].joinCount=_joinCount;\r\n          accounts[_referee].currentCReward = _currentCReward;\r\n          accounts[_referee].isAdminAccount= _special;\r\n          return true;\r\n    }\r\n    \r\n    function newAddress(address _referee) internal isNotRegister(_referee) onlyOwner returns(bool){\r\n        id++;\r\n        userList[_referee].id = id;\r\n        userList[_referee].user=_referee;\r\n        idList[id].id = id;\r\n        idList[id].user=_referee;\r\n        return true;\r\n    }\r\n    \r\n    function newCheckIn(address _referee,uint256 _amt,uint256 _dynamic,uint256 _checkTime) internal onlyOwner returns(bool){\r\n          loginCount[_referee].user = _referee;\r\n          loginCount[_referee].amt = _amt;\r\n          loginCount[_referee].dynamic = _dynamic;\r\n          loginCount[_referee].checkTime = _checkTime;\r\n          return true;\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"countAMT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkInspecial\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spec\",\"type\":\"uint256\"}],\"name\":\"declareLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userList\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateDynamic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checktime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calldynamic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"},{\"name\":\"_referee\",\"type\":\"address\"},{\"name\":\"_deposit\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"},{\"name\":\"_withdrawHis\",\"type\":\"uint256\"},{\"name\":\"_joinCount\",\"type\":\"uint256\"},{\"name\":\"_currentCReward\",\"type\":\"uint256\"},{\"name\":\"_special\",\"type\":\"uint256\"},{\"name\":\"_checkTime\",\"type\":\"uint256\"},{\"name\":\"_amt\",\"type\":\"uint256\"},{\"name\":\"_dynamic\",\"type\":\"uint256\"}],\"name\":\"addReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkTimeExtra\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"joinCount\",\"type\":\"uint256\"},{\"name\":\"referredCount\",\"type\":\"uint256\"},{\"name\":\"depositTotal\",\"type\":\"uint256\"},{\"name\":\"joinDate\",\"type\":\"uint256\"},{\"name\":\"withdrawHis\",\"type\":\"uint256\"},{\"name\":\"currentCReward\",\"type\":\"uint256\"},{\"name\":\"currentCUpdatetime\",\"type\":\"uint256\"},{\"name\":\"championReward\",\"type\":\"uint256\"},{\"name\":\"cWithdrawTime\",\"type\":\"uint256\"},{\"name\":\"isAdminAccount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idList\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"loginCount\",\"outputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"totalCheck\",\"type\":\"uint256\"},{\"name\":\"amt\",\"type\":\"uint256\"},{\"name\":\"checkTime\",\"type\":\"uint256\"},{\"name\":\"dynamic\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payfixedpersonal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cRewardWithdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"newReg\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countremain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showdynamic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"cRewardUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rewardId\",\"type\":\"uint256\"},{\"name\":\"maxRefer\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"updateRewardHis\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"limitList\",\"outputs\":[{\"name\":\"special\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"RegisteredReferer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"RegisteredRefererRejoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"RegisteredRefererFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"}]","ContractName":"Register","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f8fd3006c013aaa0d99e26923a25ad803795ffe61a955c0b5de985e8cdd93b58"}]}