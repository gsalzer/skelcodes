{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\n/* \r\n\r\n\r\n    TestToken $TT is a goldpegged defi protocol that is based on Ampleforths elastic tokensupply model. \r\n    TT is designed to maintain its base price target of 0.01g of Gold with a progammed inflation adjustment (rebase).\r\n    \r\n    Forked from Ampleforth: https://github.com/ampleforth/uFragments (Credits to Ampleforth team for implementation of rebasing on the ethereum network)\r\n    \r\n    GPL 3.0 license\r\n    \r\n    TT_GoldPolicy.sol - TT Gold Orchestrator Policy\r\n  \r\n*/\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) << 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\r\n\r\n    /**\r\n     * @dev Multiplies two int256 variables and fails on overflow.\r\n     */\r\n    function mul(int256 a, int256 b)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        int256 c = a * b;\r\n\r\n        // Detect overflow when multiplying MIN_INT256 with -1\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Division of two int256 variables and fails on overflow.\r\n     */\r\n    function div(int256 a, int256 b)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        // Prevent overflow when dividing MIN_INT256 by -1\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        // Solidity already throws when dividing by 0.\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two int256 variables and fails on overflow.\r\n     */\r\n    function sub(int256 a, int256 b)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two int256 variables and fails on overflow.\r\n     */\r\n    function add(int256 a, int256 b)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts to absolute value, and fails on overflow.\r\n     */\r\n    function abs(int256 a)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Various utilities useful for uint256.\r\n */\r\nlibrary UInt256Lib {\r\n\r\n    uint256 private constant MAX_INT256 = ~(uint256(1) << 255);\r\n\r\n    /**\r\n     * @dev Safely converts a uint256 to an int256.\r\n     */\r\n    function toInt256Safe(uint256 a)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(a <= MAX_INT256);\r\n        return int256(a);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ninterface ITT {\r\n    function totalSupply() external view returns (uint256);\r\n    function rebaseGold(uint256 epoch, int256 supplyDelta) external returns (uint256);\r\n}\r\n\r\ninterface IOracle {\r\n    function getData() external view returns (uint256, bool);\r\n}\r\n\r\ninterface IGoldOracle {\r\n    function getGoldPrice() external view returns (uint256, bool);\r\n    function getMarketPrice() external view returns (uint256, bool);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  \r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(_owner);\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title TT $TT Gold Supply Policy\r\n * @dev This is the extended orchestrator version of the TT $TT Ideal Gold Pegged DeFi protocol aka Ampleforth Gold ($TT).\r\n *      TT operates symmetrically on expansion and contraction. It will both split and\r\n *      combine coins to maintain a stable gold unit price against PAX gold.\r\n *\r\n *      This component regulates the token supply of the TT ERC20 token in response to\r\n *      market oracles and gold price.\r\n */\r\ncontract TTGoldPolicy is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeMathInt for int256;\r\n    using UInt256Lib for uint256;\r\n\r\n    event LogRebase(\r\n        uint256 indexed epoch,\r\n        uint256 exchangeRate,\r\n        uint256 goldPrice,\r\n        int256 requestedSupplyAdjustment,\r\n        uint256 timestampSec\r\n    );\r\n\r\n    ITT public tt;\r\n\r\n    // Gold oracle provides the gold price and market price.\r\n    IGoldOracle public goldOracle;\r\n\r\n    // If the current exchange rate is within this fractional distance from the target, no supply\r\n    // update is performed. Fixed point number--same format as the rate.\r\n    // (ie) abs(rate - targetRate) / targetRate < deviationThreshold, then no supply change.\r\n    // DECIMALS Fixed point number.\r\n    uint256 public deviationThreshold;\r\n\r\n    // The rebase lag parameter, used to dampen the applied supply adjustment by 1 / rebaseLag\r\n    // Check setRebaseLag comments for more details.\r\n    // Natural number, no decimal places.\r\n    uint256 public rebaseLag;\r\n\r\n    // More than this much time must pass between rebase operations.\r\n    uint256 public minRebaseTimeIntervalSec;\r\n\r\n    // Block timestamp of last rebase operation\r\n    uint256 public lastRebaseTimestampSec;\r\n\r\n    // The number of rebase cycles since inception\r\n    uint256 public epoch;\r\n\r\n    uint256 private constant DECIMALS = 18;\r\n\r\n    // Due to the expression in computeSupplyDelta(), MAX_RATE * MAX_SUPPLY must fit into an int256.\r\n    // Both are 18 decimals fixed point numbers.\r\n    uint256 private constant MAX_RATE = 10**6 * 10**DECIMALS;\r\n    // MAX_SUPPLY = MAX_INT256 / MAX_RATE\r\n    uint256 private constant MAX_SUPPLY = ~(uint256(1) << 255) / MAX_RATE;\r\n\r\n    constructor() public {\r\n        deviationThreshold = 5 * 10 ** (DECIMALS-2);\r\n\r\n        rebaseLag = 6;\r\n        minRebaseTimeIntervalSec = 12 hours;\r\n        lastRebaseTimestampSec = 0;\r\n        epoch = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if at least minRebaseTimeIntervalSec seconds have passed since last rebase.\r\n     *\r\n     */\r\n     \r\n    function canRebase() public view returns (bool) {\r\n        return (lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) < now);\r\n    }\r\n\r\n    /**\r\n     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\r\n     *\r\n     */     \r\n    function rebase() external {\r\n\r\n        require(canRebase(), \"TT Error: Insufficient time has passed since last rebase.\");\r\n\r\n        require(tx.origin == msg.sender);\r\n\r\n        lastRebaseTimestampSec = now;\r\n\r\n        epoch = epoch.add(1);\r\n        \r\n        (uint256 curGoldPrice, uint256 marketPrice, int256 targetRate, int256 supplyDelta) = getRebaseValues();\r\n\r\n        uint256 supplyAfterRebase = tt.rebaseGold(epoch, supplyDelta);\r\n        assert(supplyAfterRebase <= MAX_SUPPLY);\r\n        \r\n        emit LogRebase(epoch, marketPrice, curGoldPrice, supplyDelta, now);\r\n    }\r\n    \r\n    /**\r\n     * @notice Calculates the supplyDelta and returns the current set of values for the rebase\r\n     *\r\n     * @dev The supply adjustment equals the formula \r\n     *      (current price – base target price in usd) * total supply / (base target price in usd * lag \r\n     *       factor)\r\n     */   \r\n    function getRebaseValues() public view returns (uint256, uint256, int256, int256) {\r\n        uint256 curGoldPrice;\r\n        bool goldValid;\r\n        (curGoldPrice, goldValid) = goldOracle.getGoldPrice();\r\n\r\n        require(goldValid);\r\n        \r\n        uint256 marketPrice;\r\n        bool marketValid;\r\n        (marketPrice, marketValid) = goldOracle.getMarketPrice();\r\n        \r\n        require(marketValid);\r\n        \r\n        int256 goldPriceSigned = curGoldPrice.toInt256Safe();\r\n        int256 marketPriceSigned = marketPrice.toInt256Safe();\r\n        \r\n        int256 rate = marketPriceSigned.sub(goldPriceSigned);\r\n              \r\n        if (marketPrice > MAX_RATE) {\r\n            marketPrice = MAX_RATE;\r\n        }\r\n\r\n        int256 supplyDelta = computeSupplyDelta(marketPrice, curGoldPrice);\r\n\r\n        if (supplyDelta > 0 && tt.totalSupply().add(uint256(supplyDelta)) > MAX_SUPPLY) {\r\n            supplyDelta = (MAX_SUPPLY.sub(tt.totalSupply())).toInt256Safe();\r\n        }\r\n\r\n       return (curGoldPrice, marketPrice, rate, supplyDelta);\r\n    }\r\n\r\n\r\n    /**\r\n     * @return Computes the total supply adjustment in response to the market price\r\n     *         and the current gold price. \r\n     */\r\n    function computeSupplyDelta(uint256 marketPrice, uint256 curGoldPrice)\r\n        internal\r\n        view\r\n        returns (int256)\r\n    {\r\n        if (withinDeviationThreshold(marketPrice, curGoldPrice)) {\r\n            return 0;\r\n        }\r\n        \r\n        //(current price – base target price in usd) * total supply / (base target price in usd * lag factor)\r\n        int256 goldPrice = curGoldPrice.toInt256Safe();\r\n        int256 marketPrice = marketPrice.toInt256Safe();\r\n        \r\n        int256 delta = marketPrice.sub(goldPrice);\r\n        int256 lagSpawn = goldPrice.mul(rebaseLag.toInt256Safe());\r\n        \r\n        return tt.totalSupply().toInt256Safe()\r\n            .mul(delta).div(lagSpawn);\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the rebase lag parameter.\r\n     * @param rebaseLag_ The new rebase lag parameter.\r\n     */\r\n    function setRebaseLag(uint256 rebaseLag_)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(rebaseLag_ > 0);\r\n        rebaseLag = rebaseLag_;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Sets the parameter which control the timing and frequency of\r\n     *         rebase operations the minimum time period that must elapse between rebase cycles.\r\n     * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\r\n     *        operations, in seconds.\r\n     */\r\n    function setRebaseTimingParameter(uint256 minRebaseTimeIntervalSec_)\r\n        external\r\n        onlyOwner\r\n    {\r\n        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\r\n    }\r\n\r\n    /**\r\n     * @param rate The current market price\r\n     * @param targetRate The current gold price\r\n     * @return If the rate is within the deviation threshold from the target rate, returns true.\r\n     *         Otherwise, returns false.\r\n     */\r\n    function withinDeviationThreshold(uint256 rate, uint256 targetRate)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold)\r\n            .div(10 ** DECIMALS);\r\n\r\n        return (rate >= targetRate && rate.sub(targetRate) < absoluteDeviationThreshold)\r\n            || (rate < targetRate && targetRate.sub(rate) < absoluteDeviationThreshold);\r\n    }\r\n    \r\n    /**\r\n     * @notice Sets the reference to the tt token governed.\r\n     *         Can only be called once during initialization.\r\n     * \r\n     * @param tt_ The address of the tt ERC20 token.\r\n     */\r\n\r\n\tfunction setTT(ITT tt_)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(tt == ITT(0)); \r\n        tt = tt_;    \r\n    }\r\n\r\n    /**\r\n     * @notice Sets the reference to the tt $tt oracle.\r\n     * @param _goldOracle The address of the tt oracle contract.\r\n     */\r\n    function setGoldOracle(IGoldOracle _goldOracle)\r\n        external\r\n        onlyOwner\r\n    {\r\n        goldOracle = _goldOracle;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"goldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"requestedSupplyAdjustment\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestampSec\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"canRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deviationThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRebaseValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goldOracle\",\"outputs\":[{\"internalType\":\"contract IGoldOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebaseTimestampSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRebaseTimeIntervalSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGoldOracle\",\"name\":\"_goldOracle\",\"type\":\"address\"}],\"name\":\"setGoldOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rebaseLag_\",\"type\":\"uint256\"}],\"name\":\"setRebaseLag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minRebaseTimeIntervalSec_\",\"type\":\"uint256\"}],\"name\":\"setRebaseTimingParameter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITT\",\"name\":\"tt_\",\"type\":\"address\"}],\"name\":\"setTT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tt\",\"outputs\":[{\"internalType\":\"contract ITT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TTGoldPolicy","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a51c49e67f555238bdec5349159fe24e96f5921e79dbe82ac8cfa939617caf48"}]}