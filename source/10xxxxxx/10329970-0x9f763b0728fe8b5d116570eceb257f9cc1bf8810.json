{"status":"1","message":"OK","result":[{"SourceCode":"/**************************************************************************\r\n *            ____        _                              \r\n *           / ___|      | |     __ _  _   _   ___  _ __ \r\n *          | |    _____ | |    / _` || | | | / _ \\| '__|\r\n *          | |___|_____|| |___| (_| || |_| ||  __/| |   \r\n *           \\____|      |_____|\\__,_| \\__, | \\___||_|   \r\n *                                     |___/             \r\n * \r\n **************************************************************************\r\n *\r\n *  The MIT License (MIT)\r\n *\r\n * Copyright (c) 2016-2020 Cyril Lapinte / C-Layer\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n **************************************************************************\r\n *\r\n * Flatten Contract: TokenFactory\r\n *\r\n * Git Commit:\r\n * https://github.com/c-layer/contracts/commit/0adcf9f214ae3f7b709cc41ec5dcb68e79d68772\r\n *\r\n * SPDX-License-Identifier: MIT\r\n **************************************************************************/\r\n\r\n// File: @c-layer/common/contracts/convert/BytesConvert.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title BytesConvert\r\n * @dev Convert bytes into different types\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error Messages:\r\n *   BC01: source must be a valid 32-bytes length\r\n *   BC02: source must not be greater than 32-bytes\r\n **/\r\nlibrary BytesConvert {\r\n\r\n  /**\r\n  * @dev toUint256\r\n  */\r\n  function toUint256(bytes memory _source) internal pure returns (uint256 result) {\r\n    require(_source.length == 32, \"BC01\");\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      result := mload(add(_source, 0x20))\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev toBytes32\r\n  */\r\n  function toBytes32(bytes memory _source) internal pure returns (bytes32 result) {\r\n    require(_source.length <= 32, \"BC02\");\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      result := mload(add(_source, 0x20))\r\n    }\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/factory/Factory.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Factory\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * FA01: No code was defined \r\n * FA02: Unable to deploy contract\r\n **/\r\ncontract Factory {\r\n  using BytesConvert for bytes;\r\n\r\n  mapping(uint256 => bytes) internal contractCodes_;\r\n\r\n  /**\r\n   * @dev contracctCode\r\n   */\r\n  function contractCode(uint256 _id) public view returns (bytes memory) {\r\n    return contractCodes_[_id];\r\n  }\r\n\r\n  /**\r\n   * @dev defineContractCodeInternal\r\n   */\r\n  function defineCodeInternal(\r\n    uint256 _id,\r\n    bytes memory _contractCode) internal returns (bool)\r\n  {\r\n    contractCodes_[_id] = _contractCode;\r\n    emit ContractCodeDefined(_id, keccak256(_contractCode));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev deployContractInternal\r\n   */\r\n  function deployContractInternal(\r\n    uint256 _id,\r\n    bytes memory _parameters) internal returns (address address_)\r\n  {\r\n    require(contractCodes_[_id].length != 0, \"FA01\");\r\n    bytes memory code = abi.encodePacked(contractCodes_[_id], _parameters);\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      address_ := create(0, add(code, 0x20), mload(code))\r\n    }\r\n    require(address_ != address(0), \"FA02\");\r\n    emit ContractDeployed(_id, address_);\r\n  }\r\n\r\n  event ContractCodeDefined(uint256 contractId, bytes32 codeHash);\r\n  event ContractDeployed(uint256 contractId, address address_);\r\n}\r\n\r\n// File: @c-layer/common/contracts/operable/Ownable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * @dev functions, this simplifies the implementation of \"user permissions\".\r\n *\r\n *\r\n * Error messages\r\n *   OW01: Message sender is not the owner\r\n *   OW02: New owner must be valid\r\n*/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"OW01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0), \"OW02\");\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/operable/Operable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Operable\r\n * @dev The Operable contract enable the restrictions of operations to a set of operators\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * OP01: Message sender must be an operator\r\n * OP02: Address must be an operator\r\n * OP03: Address must not be an operator\r\n */\r\ncontract Operable is Ownable {\r\n\r\n  mapping (address => bool) private operators_;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the operator\r\n   */\r\n  modifier onlyOperator {\r\n    require(operators_[msg.sender], \"OP01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor() public {\r\n    defineOperator(\"Owner\", msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev isOperator\r\n   * @param _address operator address\r\n   */\r\n  function isOperator(address _address) public view returns (bool) {\r\n    return operators_[_address];\r\n  }\r\n\r\n  /**\r\n   * @dev removeOperator\r\n   * @param _address operator address\r\n   */\r\n  function removeOperator(address _address) public onlyOwner {\r\n    require(operators_[_address], \"OP02\");\r\n    operators_[_address] = false;\r\n    emit OperatorRemoved(_address);\r\n  }\r\n\r\n  /**\r\n   * @dev defineOperator\r\n   * @param _role operator role\r\n   * @param _address operator address\r\n   */\r\n  function defineOperator(string memory _role, address _address)\r\n    public onlyOwner\r\n  {\r\n    require(!operators_[_address], \"OP03\");\r\n    operators_[_address] = true;\r\n    emit OperatorDefined(_role, _address);\r\n  }\r\n\r\n  event OperatorRemoved(address address_);\r\n  event OperatorDefined(\r\n    string role,\r\n    address address_\r\n  );\r\n}\r\n\r\n// File: @c-layer/common/contracts/interface/IAccessDefinitions.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IAccessDefinitions\r\n * @dev IAccessDefinitions\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\ncontract IAccessDefinitions {\r\n\r\n  // Hardcoded role granting all - non sysop - privileges\r\n  bytes32 internal constant ALL_PRIVILEGES = bytes32(\"AllPrivileges\");\r\n  address internal constant ALL_PROXIES = address(0x416c6C50726F78696573); // \"AllProxies\"\r\n\r\n  // Roles\r\n  bytes32 internal constant FACTORY_CORE_ROLE = bytes32(\"FactoryCoreRole\");\r\n  bytes32 internal constant FACTORY_PROXY_ROLE = bytes32(\"FactoryProxyRole\");\r\n\r\n  // Sys Privileges\r\n  bytes4 internal constant DEFINE_ROLE_PRIV =\r\n    bytes4(keccak256(\"defineRole(bytes32,bytes4[])\"));\r\n  bytes4 internal constant ASSIGN_OPERATORS_PRIV =\r\n    bytes4(keccak256(\"assignOperators(bytes32,address[])\"));\r\n  bytes4 internal constant REVOKE_OPERATORS_PRIV =\r\n    bytes4(keccak256(\"revokeOperators(address[])\"));\r\n  bytes4 internal constant ASSIGN_PROXY_OPERATORS_PRIV =\r\n    bytes4(keccak256(\"assignProxyOperators(address,bytes32,address[])\"));\r\n}\r\n\r\n// File: @c-layer/common/contracts/interface/IOperableStorage.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title IOperableStorage\r\n * @dev The Operable storage\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n */\r\nabstract contract IOperableStorage is IAccessDefinitions {\r\n\r\n  struct RoleData {\r\n    mapping(bytes4 => bool) privileges;\r\n  }\r\n\r\n  struct OperatorData {\r\n    bytes32 coreRole;\r\n    mapping(address => bytes32) proxyRoles;\r\n  }\r\n\r\n  function coreRole(address _address) virtual public view returns (bytes32);\r\n  function proxyRole(address _proxy, address _address) virtual public view returns (bytes32);\r\n  function rolePrivilege(bytes32 _role, bytes4 _privilege) virtual public view returns (bool);\r\n  function roleHasPrivilege(bytes32 _role, bytes4 _privilege) virtual public view returns (bool);\r\n  function hasCorePrivilege(address _address, bytes4 _privilege) virtual public view returns (bool);\r\n  function hasProxyPrivilege(address _address, address _proxy, bytes4 _privilege) virtual public view returns (bool);\r\n\r\n  event RoleDefined(bytes32 role);\r\n  event OperatorAssigned(bytes32 role, address operator);\r\n  event ProxyOperatorAssigned(address proxy, bytes32 role, address operator);\r\n  event OperatorRevoked(address operator);\r\n}\r\n\r\n// File: @c-layer/common/contracts/interface/IOperableCore.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title IOperableCore\r\n * @dev The Operable contract enable the restrictions of operations to a set of operators\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n */\r\nabstract contract IOperableCore is IOperableStorage {\r\n  function defineRole(bytes32 _role, bytes4[] memory _privileges) virtual public returns (bool);\r\n  function assignOperators(bytes32 _role, address[] memory _operators) virtual public returns (bool);\r\n  function assignProxyOperators(\r\n    address _proxy, bytes32 _role, address[] memory _operators) virtual public returns (bool);\r\n  function revokeOperators(address[] memory _operators) virtual public returns (bool);\r\n}\r\n\r\n// File: @c-layer/common/contracts/interface/IProxy.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title IProxy\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n **/\r\ninterface IProxy {\r\n\r\n  function core() external view returns (address);\r\n\r\n}\r\n\r\n// File: @c-layer/common/contracts/core/Proxy.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Proxy\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n *   PR01: Only accessible by core\r\n *   PR02: Core request should be successful\r\n **/\r\ncontract Proxy is IProxy {\r\n\r\n  address public override core;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than a core\r\n   */\r\n  modifier onlyCore {\r\n    require(core == msg.sender, \"PR01\");\r\n    _;\r\n  }\r\n\r\n  constructor(address _core) public {\r\n    core = _core;\r\n  }\r\n\r\n  /**\r\n   * @dev update the core\r\n   */\r\n  function updateCore(address _core)\r\n    public onlyCore returns (bool)\r\n  {\r\n    core = _core;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev enforce static immutability (view)\r\n   * @dev in order to read core value through internal core delegateCall\r\n   */\r\n  function staticCallUint256() internal view returns (uint256 result) {\r\n    (bool status, bytes memory value) = core.staticcall(msg.data);\r\n    require(status, \"PR02\");\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      result := mload(add(value, 0x20))\r\n    }\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/operable/OperableAsCore.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title OperableAsCore\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n *   OA01: Missing the core privilege\r\n *   OA02: Missing the proxy privilege\r\n **/\r\ncontract OperableAsCore {\r\n\r\n  modifier onlyCoreOperator(IOperableCore _core) {\r\n    require(_core.hasCorePrivilege(\r\n      msg.sender, msg.sig), \"OA01\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyProxyOperator(Proxy _proxy) {\r\n    IOperableCore core = IOperableCore(_proxy.core());\r\n    require(core.hasProxyPrivilege(\r\n      msg.sender, address(_proxy), msg.sig), \"OA02\");\r\n    _;\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/interface/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n *\r\n */\r\ninterface IERC20 {\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function decimals() external view returns (uint256);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    external view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    external returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n  function increaseApproval(address _spender, uint256 _addedValue)\r\n    external returns (bool);\r\n\r\n  function decreaseApproval(address _spender, uint256 _subtractedValue)\r\n    external returns (bool);\r\n}\r\n\r\n// File: @c-layer/oracle/contracts/interface/IUserRegistry.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IUserRegistry\r\n * @dev IUserRegistry interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n **/\r\nabstract contract IUserRegistry {\r\n\r\n  enum KeyCode {\r\n    KYC_LIMIT_KEY,\r\n    RECEPTION_LIMIT_KEY,\r\n    EMISSION_LIMIT_KEY\r\n  }\r\n\r\n  event UserRegistered(uint256 indexed userId, address address_, uint256 validUntilTime);\r\n  event AddressAttached(uint256 indexed userId, address address_);\r\n  event AddressDetached(uint256 indexed userId, address address_);\r\n  event UserSuspended(uint256 indexed userId);\r\n  event UserRestored(uint256 indexed userId);\r\n  event UserValidity(uint256 indexed userId, uint256 validUntilTime);\r\n  event UserExtendedKey(uint256 indexed userId, uint256 key, uint256 value);\r\n  event UserExtendedKeys(uint256 indexed userId, uint256[] values);\r\n  event ExtendedKeysDefinition(uint256[] keys);\r\n\r\n  function registerManyUsersExternal(address[] calldata _addresses, uint256 _validUntilTime)\r\n    virtual external returns (bool);\r\n  function registerManyUsersFullExternal(\r\n    address[] calldata _addresses,\r\n    uint256 _validUntilTime,\r\n    uint256[] calldata _values) virtual external returns (bool);\r\n  function attachManyAddressesExternal(uint256[] calldata _userIds, address[] calldata _addresses)\r\n    virtual external returns (bool);\r\n  function detachManyAddressesExternal(address[] calldata _addresses)\r\n    virtual external returns (bool);\r\n  function suspendManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\r\n  function restoreManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\r\n  function updateManyUsersExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _validUntilTime,\r\n    bool _suspended) virtual external returns (bool);\r\n  function updateManyUsersExtendedExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _key, uint256 _value) virtual external returns (bool);\r\n  function updateManyUsersAllExtendedExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256[] calldata _values) virtual external returns (bool);\r\n  function updateManyUsersFullExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _validUntilTime,\r\n    bool _suspended,\r\n    uint256[] calldata _values) virtual external returns (bool);\r\n\r\n  function name() virtual public view returns (string memory);\r\n  function currency() virtual public view returns (bytes32);\r\n\r\n  function userCount() virtual public view returns (uint256);\r\n  function userId(address _address) virtual public view returns (uint256);\r\n  function validUserId(address _address) virtual public view returns (uint256);\r\n  function validUser(address _address, uint256[] memory _keys)\r\n    virtual public view returns (uint256, uint256[] memory);\r\n  function validity(uint256 _userId) virtual public view returns (uint256, bool);\r\n\r\n  function extendedKeys() virtual public view returns (uint256[] memory);\r\n  function extended(uint256 _userId, uint256 _key)\r\n    virtual public view returns (uint256);\r\n  function manyExtended(uint256 _userId, uint256[] memory _key)\r\n    virtual public view returns (uint256[] memory);\r\n\r\n  function isAddressValid(address _address) virtual public view returns (bool);\r\n  function isValid(uint256 _userId) virtual public view returns (bool);\r\n\r\n  function defineExtendedKeys(uint256[] memory _extendedKeys) virtual public returns (bool);\r\n\r\n  function registerUser(address _address, uint256 _validUntilTime)\r\n    virtual public returns (bool);\r\n  function registerUserFull(\r\n    address _address,\r\n    uint256 _validUntilTime,\r\n    uint256[] memory _values) virtual public returns (bool);\r\n\r\n  function attachAddress(uint256 _userId, address _address) virtual public returns (bool);\r\n  function detachAddress(address _address) virtual public returns (bool);\r\n  function detachSelf() virtual public returns (bool);\r\n  function detachSelfAddress(address _address) virtual public returns (bool);\r\n  function suspendUser(uint256 _userId) virtual public returns (bool);\r\n  function restoreUser(uint256 _userId) virtual public returns (bool);\r\n  function updateUser(uint256 _userId, uint256 _validUntilTime, bool _suspended)\r\n    virtual public returns (bool);\r\n  function updateUserExtended(uint256 _userId, uint256 _key, uint256 _value)\r\n    virtual public returns (bool);\r\n  function updateUserAllExtended(uint256 _userId, uint256[] memory _values)\r\n    virtual public returns (bool);\r\n  function updateUserFull(\r\n    uint256 _userId,\r\n    uint256 _validUntilTime,\r\n    bool _suspended,\r\n    uint256[] memory _values) virtual public returns (bool);\r\n}\r\n\r\n// File: @c-layer/oracle/contracts/interface/IRatesProvider.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IRatesProvider\r\n * @dev IRatesProvider interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\nabstract contract IRatesProvider {\r\n\r\n  function defineRatesExternal(uint256[] calldata _rates) virtual external returns (bool);\r\n\r\n  function name() virtual public view returns (string memory);\r\n\r\n  function rate(bytes32 _currency) virtual public view returns (uint256);\r\n\r\n  function currencies() virtual public view\r\n    returns (bytes32[] memory, uint256[] memory, uint256);\r\n  function rates() virtual public view returns (uint256, uint256[] memory);\r\n\r\n  function convert(uint256 _amount, bytes32 _fromCurrency, bytes32 _toCurrency)\r\n    virtual public view returns (uint256);\r\n\r\n  function defineCurrencies(\r\n    bytes32[] memory _currencies,\r\n    uint256[] memory _decimals,\r\n    uint256 _rateOffset) virtual public returns (bool);\r\n  function defineRates(uint256[] memory _rates) virtual public returns (bool);\r\n\r\n  event RateOffset(uint256 rateOffset);\r\n  event Currencies(bytes32[] currencies, uint256[] decimals);\r\n  event Rate(bytes32 indexed currency, uint256 rate);\r\n}\r\n\r\n// File: contracts/interface/IRule.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IRule\r\n * @dev IRule interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n **/\r\ninterface IRule {\r\n  function isAddressValid(address _address) external view returns (bool);\r\n  function isTransferValid(address _from, address _to, uint256 _amount)\r\n    external view returns (bool);\r\n}\r\n\r\n// File: contracts/interface/ITokenStorage.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ITokenStorage\r\n * @dev Token storage interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\nabstract contract ITokenStorage {\r\n  enum TransferCode {\r\n    UNKNOWN,\r\n    OK,\r\n    INVALID_SENDER,\r\n    NO_RECIPIENT,\r\n    INSUFFICIENT_TOKENS,\r\n    LOCKED,\r\n    FROZEN,\r\n    RULE,\r\n    INVALID_RATE,\r\n    NON_REGISTRED_SENDER,\r\n    NON_REGISTRED_RECEIVER,\r\n    LIMITED_EMISSION,\r\n    LIMITED_RECEPTION\r\n  }\r\n\r\n  enum Scope {\r\n    DEFAULT\r\n  }\r\n\r\n  enum AuditStorageMode {\r\n    ADDRESS,\r\n    USER_ID,\r\n    SHARED\r\n  }\r\n\r\n  enum AuditMode {\r\n    NEVER,\r\n    ALWAYS,\r\n    ALWAYS_TRIGGERS_EXCLUDED,\r\n    WHEN_TRIGGERS_MATCHED\r\n  }\r\n\r\n  event OracleDefined(\r\n    IUserRegistry userRegistry,\r\n    IRatesProvider ratesProvider,\r\n    address currency);\r\n  event TokenDelegateDefined(uint256 indexed delegateId, address delegate, uint256[] configurations);\r\n  event TokenDelegateRemoved(uint256 indexed delegateId);\r\n  event AuditConfigurationDefined(\r\n    uint256 indexed configurationId,\r\n    uint256 scopeId,\r\n    AuditMode mode,\r\n    uint256[] senderKeys,\r\n    uint256[] receiverKeys,\r\n    IRatesProvider ratesProvider,\r\n    address currency);\r\n  event AuditTriggersDefined(uint256 indexed configurationId, address[] triggers, bool[] tokens, bool[] senders, bool[] receivers);\r\n  event AuditsRemoved(address scope, uint256 scopeId);\r\n  event SelfManaged(address indexed holder, bool active);\r\n\r\n  event Minted(address indexed token, uint256 amount);\r\n  event MintFinished(address indexed token);\r\n  event Burned(address indexed token, uint256 amount);\r\n  event RulesDefined(address indexed token, IRule[] rules);\r\n  event LockDefined(\r\n    address indexed token,\r\n    uint256 startAt,\r\n    uint256 endAt,\r\n    address[] exceptions\r\n  );\r\n  event Seize(address indexed token, address account, uint256 amount);\r\n  event Freeze(address address_, uint256 until);\r\n  event ClaimDefined(\r\n    address indexed token,\r\n    address indexed claim,\r\n    uint256 claimAt);\r\n  event TokenDefined(\r\n    address indexed token,\r\n    uint256 delegateId,\r\n    string name,\r\n    string symbol,\r\n    uint256 decimals);\r\n  event TokenMigrated(address indexed token, address newCore);\r\n  event TokenRemoved(address indexed token);\r\n  event LogTransferData(\r\n    address token, address caller, address sender, address receiver,\r\n    uint256 senderId, uint256[] senderKeys, bool senderFetched,\r\n    uint256 receiverId, uint256[] receiverKeys, bool receiverFetched,\r\n    uint256 value, uint256 convertedValue);\r\n  event LogTransferAuditData(\r\n    uint256 auditConfigurationId, uint256 scopeId,\r\n    address currency, IRatesProvider ratesProvider,\r\n    bool senderAuditRequired, bool receiverAuditRequired);\r\n  event LogAuditData(\r\n    uint64 createdAt, uint64 lastTransactionAt,\r\n    uint256 cumulatedEmission, uint256 cumulatedReception\r\n  );\r\n}\r\n\r\n// File: contracts/interface/ITokenCore.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ITokenCore\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n **/\r\nabstract contract ITokenCore is ITokenStorage, IOperableCore {\r\n\r\n  function name() virtual public view returns (string memory);\r\n  function oracle() virtual public view returns (\r\n    IUserRegistry userRegistry,\r\n    IRatesProvider ratesProvider,\r\n    address currency);\r\n\r\n  function auditConfiguration(uint256 _configurationId)\r\n    virtual public view returns (\r\n      uint256 scopeId,\r\n      AuditMode mode,\r\n      uint256[] memory senderKeys,\r\n      uint256[] memory receiverKeys,\r\n      IRatesProvider ratesProvider,\r\n      address currency);\r\n  function auditTriggers(\r\n    uint256 _configurationId,\r\n    address[] memory _triggers) virtual public view returns (\r\n    bool[] memory senders,\r\n    bool[] memory receivers,\r\n    bool[] memory tokens);\r\n  function delegatesConfigurations(uint256 _delegateId)\r\n    virtual public view returns (uint256[] memory);\r\n\r\n  function auditCurrency(\r\n    address _scope,\r\n    uint256 _scopeId\r\n  ) virtual external view returns (address currency);\r\n  function audit(\r\n    address _scope,\r\n    uint256 _scopeId,\r\n    AuditStorageMode _storageMode,\r\n    bytes32 _storageId) virtual external view returns (\r\n    uint64 createdAt,\r\n    uint64 lastTransactionAt,\r\n    uint256 cumulatedEmission,\r\n    uint256 cumulatedReception);\r\n\r\n  /**************  ERC20  **************/\r\n  function tokenName() virtual external view returns (string memory);\r\n  function tokenSymbol() virtual external view returns (string memory);\r\n\r\n  function decimals() virtual external returns (uint256);\r\n  function totalSupply() virtual external returns (uint256);\r\n  function balanceOf(address) virtual external returns (uint256);\r\n  function allowance(address, address) virtual external returns (uint256);\r\n  function transfer(address, address, uint256)\r\n    virtual external returns (bool status);\r\n  function transferFrom(address, address, address, uint256)\r\n    virtual external returns (bool status);\r\n  function approve(address, address, uint256)\r\n    virtual external returns (bool status);\r\n  function increaseApproval(address, address, uint256)\r\n    virtual external returns (bool status);\r\n  function decreaseApproval(address, address, uint256)\r\n    virtual external returns (bool status);\r\n\r\n  /***********  TOKEN DATA   ***********/\r\n  function token(address _token) external view virtual returns (\r\n    bool mintingFinished,\r\n    uint256 allTimeMinted,\r\n    uint256 allTimeBurned,\r\n    uint256 allTimeSeized,\r\n    uint256[2] memory lock,\r\n    address[] memory lockExceptions,\r\n    uint256 freezedUntil,\r\n    IRule[] memory);\r\n  function canTransfer(address, address, uint256)\r\n    virtual external returns (uint256);\r\n\r\n  /***********  TOKEN ADMIN  ***********/\r\n  function mint(address, address[] calldata, uint256[] calldata)\r\n    virtual external returns (bool);\r\n  function finishMinting(address)\r\n    virtual external returns (bool);\r\n  function burn(address, uint256)\r\n    virtual external returns (bool);\r\n  function seize(address _token, address, uint256)\r\n    virtual external returns (bool);\r\n  function freezeManyAddresses(\r\n    address _token,\r\n    address[] calldata _addresses,\r\n    uint256 _until) virtual external returns (bool);\r\n  function defineLock(address, uint256, uint256, address[] calldata)\r\n    virtual external returns (bool);\r\n  function defineRules(address, IRule[] calldata) virtual external returns (bool);\r\n\r\n  /************  CORE ADMIN  ************/\r\n  function defineToken(\r\n    address _token,\r\n    uint256 _delegateId,\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint256 _decimals) virtual external returns (bool);\r\n  function migrateToken(address _token, address _newCore)\r\n    virtual external returns (bool);\r\n  function removeToken(address _token) virtual external returns (bool);\r\n\r\n  function defineOracle(\r\n    IUserRegistry _userRegistry,\r\n    IRatesProvider _ratesProvider,\r\n    address _currency) virtual external returns (bool);\r\n  function defineTokenDelegate(\r\n    uint256 _delegateId,\r\n    address _delegate,\r\n    uint256[] calldata _configurations) virtual external returns (bool);\r\n  function defineAuditConfiguration(\r\n    uint256 _configurationId,\r\n    uint256 _scopeId,\r\n    AuditMode _mode,\r\n    uint256[] calldata _senderKeys,\r\n    uint256[] calldata _receiverKeys,\r\n    IRatesProvider _ratesProvider,\r\n    address _currency) virtual external returns (bool);\r\n  function removeAudits(address _scope, uint256 _scopeId)\r\n    virtual external returns (bool);\r\n  function defineAuditTriggers(\r\n    uint256 _configurationId,\r\n    address[] calldata _triggerAddresses,\r\n    bool[] calldata _triggerSenders,\r\n    bool[] calldata _triggerReceivers,\r\n    bool[] calldata _triggerTokens) virtual external returns (bool);\r\n\r\n  function isSelfManaged(address _owner)\r\n    virtual external view returns (bool);\r\n  function manageSelf(bool _active)\r\n    virtual external returns (bool);\r\n}\r\n\r\n// File: contracts/interface/ITokenProxy.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title IToken proxy\r\n * @dev Token proxy interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\nabstract contract ITokenProxy is IERC20, Proxy {\r\n\r\n  function canTransfer(address, address, uint256)\r\n    virtual public view returns (uint256);\r\n  \r\n  function emitTransfer(address _from, address _to, uint256 _value)\r\n    virtual public returns (bool);\r\n\r\n  function emitApproval(address _owner, address _spender, uint256 _value)\r\n    virtual public returns (bool);\r\n}\r\n\r\n// File: contracts/interface/ITokenAccessDefinitions.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title ITokenAccessDefinitions\r\n * @dev ITokenAccessDefinitions\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\nabstract contract ITokenAccessDefinitions is IAccessDefinitions {\r\n\r\n  // Roles\r\n  bytes32 internal constant COMPLIANCE_CORE_ROLE = bytes32(\"ComplianceCoreRole\");\r\n  bytes32 internal constant COMPLIANCE_PROXY_ROLE = bytes32(\"ComplianceProxyRole\");\r\n  bytes32 internal constant ISSUER_PROXY_ROLE = bytes32(\"IssuerProxyRole\");\r\n\r\n  // Core Privileges\r\n  bytes4 internal constant DEFINE_CORE_CONFIGURATION_PRIV =\r\n    bytes4(keccak256(\"defineCoreConfigurations(address,address,address[],address,address,address,address,address)\"));\r\n  bytes4 internal constant DEFINE_AUDIT_CONFIGURATION_PRIV =\r\n    bytes4(keccak256(\"defineAuditConfiguration(uint256,uint256,uint8,uint256[],uint256[],address,address)\"));\r\n  bytes4 internal constant DEFINE_TOKEN_DELEGATE_PRIV =\r\n    bytes4(keccak256(\"defineTokenDelegate(uint256,address,uint256[])\"));\r\n  bytes4 internal constant DEFINE_ORACLE_PRIV =\r\n    bytes4(keccak256(\"defineOracle(address,address,address)\"));\r\n  bytes4 internal constant DEFINE_TOKEN_PRIV =\r\n    bytes4(keccak256(\"defineToken(address,uint256,string,string,uint256)\"));\r\n\r\n  // Proxy Privileges\r\n  bytes4 internal constant MINT_PRIV =\r\n    bytes4(keccak256(\"mint(address,address[],uint256[])\"));\r\n  bytes4 internal constant BURN_PRIV =\r\n    bytes4(keccak256(\"burn(address,uint256)\"));\r\n  bytes4 internal constant FINISH_MINTING_PRIV =\r\n    bytes4(keccak256(\"finishMinting(address)\"));\r\n  bytes4 internal constant SEIZE_PRIV =\r\n    bytes4(keccak256(\"seize(address,address,uint256)\"));\r\n  bytes4 internal constant DEFINE_LOCK_PRIV =\r\n    bytes4(keccak256(\"defineLock(address,uint256,uint256,address[])\"));\r\n  bytes4 internal constant FREEZE_MANY_ADDRESSES_PRIV =\r\n    bytes4(keccak256(\"freezeManyAddresses(address,address[],uint256)\"));\r\n  bytes4 internal constant DEFINE_RULES_PRIV =\r\n    bytes4(keccak256(\"defineRules(address,address[])\"));\r\n\r\n  // Factory prilieges\r\n  bytes4 internal constant CONFIGURE_TOKENSALES_PRIV =\r\n    bytes4(keccak256(\"configureTokensales(address,address[],uint256[])\"));\r\n  bytes4 internal constant UPDATE_ALLOWANCE_PRIV =\r\n    bytes4(keccak256(\"updateAllowances(address,address[],uint256[])\"));\r\n}\r\n\r\n// File: contracts/interface/ITokenFactory.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ITokenFactory\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n **/\r\nabstract contract ITokenFactory is ITokenAccessDefinitions {\r\n\r\n  uint256 internal constant TOKEN_PROXY = 0;\r\n\r\n  // The definitions below should be considered as a constant\r\n  // Solidity 0.6.x do not provide ways to have arrays as constants\r\n  bytes4[] public requiredCorePrivileges = [\r\n    ASSIGN_PROXY_OPERATORS_PRIV,\r\n    DEFINE_TOKEN_PRIV\r\n  ];\r\n  bytes4[] public requiredProxyPrivileges = [\r\n    MINT_PRIV,\r\n    FINISH_MINTING_PRIV,\r\n    DEFINE_LOCK_PRIV,\r\n    DEFINE_RULES_PRIV\r\n  ];\r\n\r\n  function hasCoreAccess(ITokenCore _core) virtual public view returns (bool access);\r\n\r\n  function defineProxyCode(bytes memory _code) virtual public returns (bool);\r\n  function deployToken(\r\n    ITokenCore _core,\r\n    uint256 _delegateId,\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint256 _decimals,\r\n    uint256 _lockEnd,\r\n    bool _finishMinting,\r\n    address[] memory _vaults,\r\n    uint256[] memory _supplies,\r\n    address[] memory _proxyOperators\r\n  ) virtual public returns (IERC20);\r\n  function approveToken(ITokenCore _core,\r\n    ITokenProxy _token) virtual public returns (bool);\r\n  function configureTokensales(\r\n    ITokenProxy _token,\r\n    address[] memory _tokensales,\r\n    uint256[] memory _allowances) virtual public returns (bool);\r\n  function updateAllowances(\r\n    ITokenProxy _token,\r\n    address[] memory _spenders,\r\n    uint256[] memory _allowances) virtual public returns (bool);\r\n\r\n  event TokenDeployed(IERC20 token);\r\n  event TokenApproved(IERC20 token);\r\n  event TokensalesConfigured(IERC20 token, address[] tokensales);\r\n  event AllowanceUpdated(IERC20 token, address spender, uint256 allowance);\r\n}\r\n\r\n// File: contracts/rule/YesNoRule.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title YesNoRule\r\n * @dev YesNoRule\r\n * The rule always answer the same response through isValid\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\ncontract YesNoRule is IRule {\r\n  bool public yesNo;\r\n\r\n  constructor(bool _yesNo) public {\r\n    yesNo = _yesNo;\r\n  }\r\n\r\n  function isAddressValid(address /* _from */) override public view returns (bool) {\r\n    return yesNo;\r\n  }\r\n\r\n  function isTransferValid(\r\n    // solhint-disable-next-line space-after-comma\r\n    address /* _from */, address /*_to */, uint256 /*_amount */)\r\n    override public view returns (bool)\r\n  {\r\n    return yesNo;\r\n  }\r\n}\r\n\r\n// File: contracts/TokenFactory.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenFactory\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n *   TF01: required privileges must be granted from the core to the factory\r\n *   TF02: There must be the same number of vault and supplies\r\n *   TF03: A proxy code must be defined\r\n *   TF04: Token proxy must be deployed\r\n *   TF05: Token must be defined in the core\r\n *   TF06: Factory role must be granted on the proxy\r\n *   TF07: Issuer role must be granted on the proxy\r\n *   TF08: The rule must be set\r\n *   TF09: The token must be locked\r\n *   TF10: Token must be minted\r\n *   TF11: Token minting must be finished\r\n *   TF12: Incorrect core provided\r\n *   TF13: The rule must be removed\r\n *   TF14: Same number of tokensales and allowances must be provided\r\n *   TF15: Exceptions must be added to the lock\r\n *   TF16: Allowances must be lower than the token balance\r\n *   TF17: Allowance must be successful\r\n **/\r\ncontract TokenFactory is ITokenFactory, Factory, OperableAsCore, YesNoRule, Operable {\r\n\r\n  /*\r\n   * @dev constructor\r\n   */\r\n  constructor() public YesNoRule(false) {}\r\n\r\n  /*\r\n   * @dev has core access\r\n   */\r\n  function hasCoreAccess(ITokenCore _core) override public view returns (bool access) {\r\n    access = true;\r\n    for (uint256 i=0; i<requiredCorePrivileges.length; i++) {\r\n      access = access && _core.hasCorePrivilege(\r\n        address(this), requiredCorePrivileges[i]);\r\n    }\r\n\r\n    for (uint256 i=0; i<requiredProxyPrivileges.length; i++) {\r\n      access = access && _core.hasProxyPrivilege(\r\n        address(this), ALL_PROXIES, requiredProxyPrivileges[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev defineProxyCode\r\n   */\r\n  function defineProxyCode(bytes memory _code)\r\n    override public onlyOperator returns (bool)\r\n  {\r\n    return defineCodeInternal(uint256(TOKEN_PROXY), _code);\r\n  }\r\n\r\n  /**\r\n   * @dev deploy token\r\n   */\r\n  function deployToken(\r\n    ITokenCore _core,\r\n    uint256 _delegateId,\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint256 _decimals,\r\n    uint256 _lockEnd,\r\n    bool _finishMinting,\r\n    address[] memory _vaults,\r\n    uint256[] memory _supplies,\r\n    address[] memory _proxyOperators\r\n  ) override public returns (IERC20) {\r\n    require(hasCoreAccess(_core), \"TF01\");\r\n    require(_vaults.length == _supplies.length, \"TF02\");\r\n    require(contractCodes_[uint256(TOKEN_PROXY)].length != 0, \"TF03\");\r\n\r\n    // 1- Creating a proxy\r\n    IERC20 token = IERC20(deployContractInternal(\r\n      uint256(TOKEN_PROXY), abi.encode(address(_core))));\r\n    require(address(token) != address(0), \"TF04\");\r\n\r\n    // 2- Defining the token in the core\r\n    require(_core.defineToken(\r\n      address(token), _delegateId, _name, _symbol, _decimals), \"TF05\");\r\n\r\n    // 3- Assign roles\r\n    require(_core.assignProxyOperators(address(token), ISSUER_PROXY_ROLE, _proxyOperators), \"TF07\");\r\n\r\n    // 4- Define rules\r\n    // Token is blocked for review and approval by core operators\r\n    // This contract is used as a YesNo rule configured as No to prevent transfers\r\n    // Removing this contract from the rules will unlock the token\r\n    IRule[] memory factoryRules = new IRule[](1);\r\n    factoryRules[0] = IRule(address(this));\r\n    require(_core.defineRules(address(token), factoryRules), \"TF08\");\r\n\r\n    // 5- Locking the token\r\n    // solhint-disable-next-line not-rely-on-time\r\n    if (_lockEnd > now) {\r\n      require(_core.defineLock(address(token), 0, _lockEnd, new address[](0)), \"TF09\");\r\n    }\r\n\r\n    // 6- Minting the token\r\n    require(_core.mint(address(token), _vaults, _supplies), \"TF10\");\r\n\r\n    // 7 - Finish the minting\r\n    if(_finishMinting) {\r\n      require(_core.finishMinting(address(token)), \"TF11\");\r\n    }\r\n\r\n    emit TokenDeployed(token);\r\n    return token;\r\n  }\r\n\r\n  /**\r\n   * @dev approveToken\r\n   */\r\n  function approveToken(ITokenCore _core, ITokenProxy _token)\r\n    override public onlyCoreOperator(_core) returns (bool)\r\n  {\r\n    require(hasCoreAccess(_core), \"TF01\");\r\n    require(_token.core() == address(_core), \"TF12\");\r\n\r\n    // This ensure that the call does not change a custom made rules configuration\r\n    (,,,,,,,IRule[] memory rules) = _core.token(address(_token));\r\n    if (rules.length == 1 && rules[0] == IRule(this)) {\r\n      require(_core.defineRules(\r\n        address(_token), new IRule[](0)), \"TF13\");\r\n    }\r\n    emit TokenApproved(_token);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev configureTokensales\r\n   */\r\n  function configureTokensales(\r\n    ITokenProxy _token,\r\n    address[] memory _tokensales,\r\n    uint256[] memory _allowances)\r\n    override public onlyProxyOperator(Proxy(address(_token))) returns (bool)\r\n  {\r\n    ITokenCore core = ITokenCore(_token.core());\r\n    require(hasCoreAccess(core), \"TF01\");\r\n    require(_tokensales.length == _allowances.length, \"TF14\");\r\n\r\n    (,,,,uint256[2] memory schedule,,,) = core.token(address(_token));\r\n    require(core.defineLock(address(_token), schedule[0], schedule[1], _tokensales), \"TF15\");\r\n\r\n    updateAllowances(_token, _tokensales, _allowances);\r\n    emit TokensalesConfigured(_token, _tokensales);\r\n  }\r\n\r\n  /**\r\n   * @dev updateAllowance\r\n   */\r\n  function updateAllowances(\r\n    ITokenProxy _token,\r\n    address[] memory _spenders,\r\n    uint256[] memory _allowances)\r\n    override public onlyProxyOperator(_token) returns (bool)\r\n  {\r\n    uint256 balance = _token.balanceOf(address(this));\r\n    for(uint256 i=0; i < _spenders.length; i++) {\r\n      require(_allowances[i] <= balance, \"TF16\");\r\n      require(_token.approve(_spenders[i], _allowances[i]), \"TF17\");\r\n      emit AllowanceUpdated(_token, _spenders[i], _allowances[i]);\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"name\":\"AllowanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contractId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"codeHash\",\"type\":\"bytes32\"}],\"name\":\"ContractCodeDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contractId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"OperatorDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokensales\",\"type\":\"address[]\"}],\"name\":\"TokensalesConfigured\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract ITokenCore\",\"name\":\"_core\",\"type\":\"address\"},{\"internalType\":\"contract ITokenProxy\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"approveToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITokenProxy\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokensales\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_allowances\",\"type\":\"uint256[]\"}],\"name\":\"configureTokensales\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"contractCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"defineOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_code\",\"type\":\"bytes\"}],\"name\":\"defineProxyCode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITokenCore\",\"name\":\"_core\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delegateId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockEnd\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_finishMinting\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"_vaults\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supplies\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_proxyOperators\",\"type\":\"address[]\"}],\"name\":\"deployToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITokenCore\",\"name\":\"_core\",\"type\":\"address\"}],\"name\":\"hasCoreAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAddressValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTransferValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requiredCorePrivileges\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requiredProxyPrivileges\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITokenProxy\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_spenders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_allowances\",\"type\":\"uint256[]\"}],\"name\":\"updateAllowances\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yesNo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenFactory","CompilerVersion":"v0.6.9+commit.3e3065ac","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://267332780e7d52f457ab3bb3a0a01bc04726c65163e0aa6f1b74c279dec7847e"}]}