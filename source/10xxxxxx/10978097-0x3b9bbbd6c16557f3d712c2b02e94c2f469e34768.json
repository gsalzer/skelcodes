{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.7.2;\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\ninterface IUniswapV2Pair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function sync() external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n}\r\n\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\ncontract FlashCycle2 is IUniswapV2Callee {\r\n\r\n    address payable owner;\r\n    IUniswapV2Router02 constant uniswapV2Router02 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function _sortTokens(address tokenA, address tokenB) private pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    function _pairFor(address tokenA, address tokenB) private pure returns (address pair) {\r\n        (address token0, address token1) = _sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                uniswapV2Router02.factory(),\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) private {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = _sortTokens(input, output);\r\n            IUniswapV2Pair pair = IUniswapV2Pair(_pairFor(input, output));\r\n            uint amountInput;\r\n            uint amountOutput;\r\n            { // scope to avoid stack too deep errors\r\n            (uint reserve0, uint reserve1,) = pair.getReserves();\r\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n            amountInput = _safeBalanceOf(input, address(pair)) - reserveInput;\r\n            amountOutput = uniswapV2Router02.getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n            address to = i < path.length - 2 ? _pairFor(output, path[i + 2]) : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function _safeBalanceOf(address token, address who) private view returns (uint) {\r\n        (bool success, bytes memory returnData) = token.staticcall(abi.encodeWithSignature(\"balanceOf(address)\", who));\r\n        if (success && returnData.length == 32) {\r\n            return abi.decode(returnData, (uint));\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external override {\r\n\r\n        address[] memory _path = abi.decode(data, (address[]));\r\n        uint _amountOut        = amount0 + amount1;\r\n        IUniswapV2Pair _pair0  = IUniswapV2Pair(msg.sender);\r\n        address _pair1         = _pairFor(_path[0], _path[1]);\r\n\r\n        (address _t0, address _t1)                           = (_pair0.token0(), _pair0.token1());\r\n        (uint _r0, uint _r1,)                                = _pair0.getReserves();\r\n        (address _tIn, address _tOut, uint _rIn, uint _rOut) =\r\n            _path[0] == _t1 ? (_t0, _t1, _r0, _r1) : (_t1, _t0, _r1, _r0);\r\n\r\n        uint _payback  = uniswapV2Router02.getAmountIn(_amountOut, _rIn, _rOut);\r\n        uint _discount = _safeBalanceOf(_tIn, address(_pair0)) - _rIn;\r\n        _payback = _discount <= _payback ? _payback - _discount : 0;\r\n\r\n        IERC20(_tOut).transfer(_pair1, _safeBalanceOf(_tOut, address(this)));\r\n        _swapSupportingFeeOnTransferTokens(_path, address(this));\r\n        if (_payback > 0) {\r\n            IERC20(_tIn).transfer(msg.sender, _payback);\r\n        }\r\n\r\n        uint _profit = _safeBalanceOf(_tIn, address(this));\r\n        require(_profit > 0, \"no profit\");\r\n        IERC20(_tIn).transfer(owner, _profit);\r\n    }\r\n\r\n    function cycle(uint investment, address[] calldata path) external {\r\n\r\n        // sync all pairs in the path with lower balance than reserve\r\n        for (uint i; i <= path.length - 2; i++) {\r\n            IUniswapV2Pair _pair = IUniswapV2Pair(_pairFor(path[i], path[i + 1]));\r\n            (uint112 _r0, uint112 _r1,) = _pair.getReserves();\r\n            require(_r0 > 0 && _r1 > 0, \"pair without liquidity\");\r\n\r\n            uint _b0 = _safeBalanceOf(_pair.token0(), address(_pair));\r\n            uint _b1 = _safeBalanceOf(_pair.token1(), address(_pair));\r\n            if (_b0 < _r0 || _b1 < _r1) {\r\n                _pair.sync();\r\n            }\r\n        }\r\n\r\n        IUniswapV2Pair _pair    = IUniswapV2Pair(_pairFor(path[0], path[1]));\r\n        (uint _r0, uint _r1,)   = _pair.getReserves();\r\n        (uint _rIn, uint _rOut) = path[0] == _pair.token0() ? (_r0, _r1) : (_r1, _r0);\r\n        uint _aOut              = uniswapV2Router02.getAmountOut(investment, _rIn, _rOut);\r\n        (uint _a0, uint _a1)    = path[0] == _pair.token0() ? (uint(0), _aOut) : (_aOut, uint(0));\r\n\r\n        address[] memory _path = new address[](path.length - 1);\r\n        for (uint i = 1; i < path.length; i++) {\r\n            _path[i - 1] = path[i];\r\n        }\r\n\r\n        _pair.swap(_a0, _a1, address(this), abi.encode(_path));\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"cycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FlashCycle2","CompilerVersion":"v0.7.2+commit.51b20bc0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ed3e0fee49c1f3ebdc8afaf42b59527af5f9f17310788a4c47638e55a2b89867"}]}