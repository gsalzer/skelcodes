{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.1.0\r\n\r\nMAX_COINS: constant(int128) = 8\r\n\r\nZA: constant(address) = ZERO_ADDRESS\r\nEMPTY_ADDRESS_ARRAY: constant(address[MAX_COINS]) = [ZA, ZA, ZA, ZA, ZA, ZA, ZA, ZA]\r\n\r\nZERO: constant(uint256) = convert(0, uint256)\r\nEMPTY_UINT256_ARRAY: constant(uint256[MAX_COINS]) = [ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]\r\n\r\n\r\nstruct PoolArray:\r\n    location: uint256\r\n    decimals: bytes32\r\n    rate_method_id: bytes32\r\n    lp_token: address\r\n    coins: address[MAX_COINS]\r\n    ul_coins: address[MAX_COINS]\r\n\r\nstruct PoolCoins:\r\n    coins: address[MAX_COINS]\r\n    underlying_coins: address[MAX_COINS]\r\n    decimals: uint256[MAX_COINS]\r\n\r\nstruct PoolInfo:\r\n    balances: uint256[MAX_COINS]\r\n    underlying_balances: uint256[MAX_COINS]\r\n    decimals: uint256[MAX_COINS]\r\n    lp_token: address\r\n    A: uint256\r\n    fee: uint256\r\n\r\n\r\ncontract ERC20:\r\n    def decimals() -> uint256: constant\r\n    def balanceOf(addr: address) -> uint256: constant\r\n    def approve(spender: address, amount: uint256) -> bool: modifying\r\n    def transfer(to: address, amount: uint256) -> bool: modifying\r\n    def transferFrom(spender: address, to: address, amount: uint256) -> bool: modifying\r\n\r\ncontract CurvePool:\r\n    def A() -> uint256: constant\r\n    def fee() -> uint256: constant\r\n    def coins(i: int128) -> address: constant\r\n    def underlying_coins(i: int128) -> address: constant\r\n    def get_dy(i: int128, j: int128, dx: uint256) -> uint256: constant\r\n    def get_dy_underlying(i: int128, j: int128, dx: uint256) -> uint256: constant\r\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): modifying\r\n    def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256): modifying\r\n\r\ncontract GasEstimator:\r\n    def estimate_gas_used(_pool: address, _from: address, _to: address) -> uint256: constant\r\n\r\n\r\nCommitNewAdmin: event({deadline: indexed(uint256), admin: indexed(address)})\r\nNewAdmin: event({admin: indexed(address)})\r\nTokenExchange: event({\r\n    buyer: indexed(address),\r\n    pool: indexed(address),\r\n    token_sold: address,\r\n    token_bought: address,\r\n    amount_sold: uint256,\r\n    amount_bought: uint256\r\n})\r\nPoolAdded: event({pool: indexed(address), rate_method_id: bytes[4]})\r\nPoolRemoved: event({pool: indexed(address)})\r\n\r\n\r\nadmin: public(address)\r\ntransfer_ownership_deadline: uint256\r\nfuture_admin: address\r\n\r\npool_list: public(address[65536])   # master list of pools\r\npool_count: public(uint256)         # actual length of pool_list\r\n\r\npool_data: map(address, PoolArray)\r\nreturns_none: map(address, bool)\r\n\r\ngas_estimate_values: map(address, uint256)\r\ngas_estimate_contracts: map(address, address)\r\n\r\n# mapping of coin -> coin -> pools for trading\r\n# all addresses are converted to uint256 prior to storage. coin addresses are stored\r\n# using the smaller value first. within each pool address array, the first value\r\n# is shifted 16 bits to the left, and these 16 bits are used to store the array length.\r\n\r\nmarkets: map(uint256, map(uint256, uint256[65536]))\r\n\r\n\r\n@public\r\ndef __init__(_returns_none: address[4]):\r\n    \"\"\"\r\n    @notice Constructor function\r\n    @param _returns_none Token addresses that return None on a successful transfer\r\n    \"\"\"\r\n    self.admin = msg.sender\r\n    for _addr in _returns_none:\r\n        if _addr == ZERO_ADDRESS:\r\n            break\r\n        self.returns_none[_addr] = True\r\n\r\n\r\n@public\r\n@constant\r\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\r\n    \"\"\"\r\n    @notice Find an available pool for exchanging two coins\r\n    @dev For coins where there is no underlying coin, or where\r\n         the underlying coin cannot be swapped, the rate is\r\n         given as 1e18\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param i Index value. When multiple pools are available\r\n            this value is used to return the n'th address.\r\n    @return Pool address\r\n    \"\"\"\r\n\r\n    _first: uint256 = min(convert(_from, uint256), convert(_to, uint256))\r\n    _second: uint256 = max(convert(_from, uint256), convert(_to, uint256))\r\n\r\n    if i == 0:\r\n        _addr: uint256 = shift(self.markets[_first][_second][0], -16)\r\n        return convert(convert(_addr, bytes32), address)\r\n\r\n    return convert(convert(self.markets[_first][_second][i], bytes32), address)\r\n\r\n\r\n@public\r\n@constant\r\ndef get_pool_coins(_pool: address) -> PoolCoins:\r\n    \"\"\"\r\n    @notice Get information on coins in a pool\r\n    @dev Empty values in the returned arrays may be ignored\r\n    @param _pool Pool address\r\n    @return Coin addresses, underlying coin addresses, underlying coin decimals\r\n    \"\"\"\r\n    _coins: PoolCoins = PoolCoins({\r\n        coins: EMPTY_ADDRESS_ARRAY,\r\n        underlying_coins: EMPTY_ADDRESS_ARRAY,\r\n        decimals: EMPTY_UINT256_ARRAY\r\n    })\r\n    _decimals_packed: bytes32 = self.pool_data[_pool].decimals\r\n\r\n    for i in range(MAX_COINS):\r\n        _coins.coins[i] = self.pool_data[_pool].coins[i]\r\n        if _coins.coins[i] == ZERO_ADDRESS:\r\n            break\r\n        _coins.decimals[i] = convert(slice(_decimals_packed, 31 - i, 1), uint256)\r\n        _coins.underlying_coins[i] = self.pool_data[_pool].ul_coins[i]\r\n\r\n    return _coins\r\n\r\n\r\n@public\r\n@constant\r\ndef get_pool_info(_pool: address) -> PoolInfo:\r\n    \"\"\"\r\n    @notice Get information on a pool\r\n    @dev Reverts if the pool address is unknown\r\n    @param _pool Pool address\r\n    @return balances, underlying balances, underlying decimals, lp token, amplification coefficient, fees\r\n    \"\"\"\r\n    _pool_info: PoolInfo = PoolInfo({\r\n        balances: EMPTY_UINT256_ARRAY,\r\n        underlying_balances: EMPTY_UINT256_ARRAY,\r\n        decimals: EMPTY_UINT256_ARRAY,\r\n        lp_token: self.pool_data[_pool].lp_token,\r\n        A: CurvePool(_pool).A(),\r\n        fee: CurvePool(_pool).fee()\r\n    })\r\n\r\n    _decimals_packed: bytes32 = self.pool_data[_pool].decimals\r\n\r\n    for i in range(MAX_COINS):\r\n        _coin: address = self.pool_data[_pool].coins[i]\r\n        if _coin == ZERO_ADDRESS:\r\n            assert i != 0\r\n            break\r\n        _pool_info.decimals[i] = convert(slice(_decimals_packed, 31 - i, 1), uint256)\r\n        _pool_info.balances[i] = ERC20(_coin).balanceOf(_pool)\r\n        _underlying_coin: address = self.pool_data[_pool].ul_coins[i]\r\n        if _coin == _underlying_coin:\r\n            _pool_info.underlying_balances[i] = _pool_info.balances[i]\r\n        else:\r\n            _pool_info.underlying_balances[i] = ERC20(_underlying_coin).balanceOf(_pool)\r\n\r\n    return _pool_info\r\n\r\n\r\n@public\r\ndef get_pool_rates(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get rates between coins and underlying coins\r\n    @dev For coins where there is no underlying coin, or where\r\n         the underlying coin cannot be swapped, the rate is\r\n         given as 1e18\r\n    @param _pool Pool address\r\n    @return Rates between coins and underlying coins\r\n    \"\"\"\r\n    _rates: uint256[MAX_COINS] = EMPTY_UINT256_ARRAY\r\n    _rate_method_id: bytes[4] = slice(self.pool_data[_pool].rate_method_id, 0, 4)\r\n    for i in range(MAX_COINS):\r\n        _coin: address = self.pool_data[_pool].coins[i]\r\n        if _coin == ZERO_ADDRESS:\r\n            break\r\n        if _coin == self.pool_data[_pool].ul_coins[i]:\r\n            _rates[i] = 10 ** 18\r\n        else:\r\n            _response: bytes[32] = raw_call(_coin, _rate_method_id, outsize=32)  # dev: bad response\r\n            _rates[i] = convert(_response, uint256)\r\n\r\n    return _rates\r\n\r\n\r\n@public\r\n@constant\r\ndef estimate_gas_used(_pool: address, _from: address, _to: address) -> uint256:\r\n    \"\"\"\r\n    @notice Estimate the gas used in an exchange.\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @return Upper-bound gas estimate, in wei\r\n    \"\"\"\r\n    _total: uint256 = 0\r\n    _estimator: address = self.gas_estimate_contracts[_pool]\r\n    if _estimator != ZERO_ADDRESS:\r\n        return GasEstimator(_estimator).estimate_gas_used(_pool, _from, _to)\r\n\r\n    for _addr in [_from, _pool, _to]:\r\n        _gas: uint256 = self.gas_estimate_values[_addr]\r\n        assert _gas != 0  # dev: value not set\r\n        _total += _gas\r\n\r\n    return _total\r\n\r\n\r\n@private\r\n@constant\r\ndef _get_token_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> (int128, int128, bool):\r\n    \"\"\"\r\n    Convert coin addresses to indices for use with pool methods.\r\n    \"\"\"\r\n    i: int128 = -1\r\n    j: int128 = -1\r\n    _coin: address = ZERO_ADDRESS\r\n    _check_underlying: bool = True\r\n\r\n    # check coin markets\r\n    for x in range(MAX_COINS):\r\n        _coin = self.pool_data[_pool].coins[x]\r\n        if _coin == _from:\r\n            i = x\r\n        elif _coin == _to:\r\n            j = x\r\n        elif _coin == ZERO_ADDRESS:\r\n            break\r\n        else:\r\n            continue\r\n        if min(i, j) > -1:\r\n            return i, j, False\r\n        if _coin != self.pool_data[_pool].ul_coins[x]:\r\n            _check_underlying = False\r\n\r\n    assert _check_underlying, \"No available market\"\r\n\r\n    # check underlying coin markets\r\n    for x in range(MAX_COINS):\r\n        _coin = self.pool_data[_pool].ul_coins[x]\r\n        if _coin == _from:\r\n            i = x\r\n        elif _coin == _to:\r\n            j = x\r\n        elif _coin == ZERO_ADDRESS:\r\n            break\r\n        else:\r\n            continue\r\n        if i > -1 and j > -1:\r\n            return i, j, True\r\n\r\n    raise \"No available market\"\r\n\r\n\r\n@public\r\n@constant\r\ndef get_exchange_amount(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins received in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_from` to be sent\r\n    @return Quantity of `_to` to be received\r\n    \"\"\"\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    _is_underlying: bool = False\r\n    i, j, _is_underlying = self._get_token_indices(_pool, _from, _to)\r\n\r\n    if _is_underlying:\r\n        return CurvePool(_pool).get_dy_underlying(i, j, _amount)\r\n    else:\r\n        return CurvePool(_pool).get_dy(i, j, _amount)\r\n\r\n\r\n@public\r\n@nonreentrant(\"lock\")\r\ndef exchange(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Perform an exchange.\r\n    @dev Prior to calling this function you must approve\r\n         this contract to transfer `_amount` coins from `_from`\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @param _expected Minimum quantity of `_from` received\r\n           in order for the transaction to succeed\r\n    @return True\r\n    \"\"\"\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    _is_underlying: bool = False\r\n    i, j, _is_underlying = self._get_token_indices(_pool, _from, _to)\r\n\r\n    _initial_balance: uint256 = ERC20(_to).balanceOf(self)\r\n\r\n    if self.returns_none[_from]:\r\n        ERC20(_from).transferFrom(msg.sender, self, _amount)\r\n    else:\r\n        assert_modifiable(ERC20(_from).transferFrom(msg.sender, self, _amount))\r\n\r\n    if _is_underlying:\r\n        CurvePool(_pool).exchange_underlying(i, j, _amount, _expected)\r\n    else:\r\n        CurvePool(_pool).exchange(i, j, _amount, _expected)\r\n\r\n    _received: uint256 = ERC20(_to).balanceOf(self) - _initial_balance\r\n\r\n    if self.returns_none[_to]:\r\n        ERC20(_to).transfer(msg.sender, _received)\r\n    else:\r\n        assert_modifiable(ERC20(_to).transfer(msg.sender, _received))\r\n\r\n    log.TokenExchange(msg.sender, _pool, _from, _to, _amount, _received)\r\n\r\n    return True\r\n\r\n\r\n# Admin functions\r\n\r\n@public\r\ndef add_pool(\r\n    _pool: address,\r\n    _n_coins: int128,\r\n    _lp_token: address,\r\n    _decimals: uint256[MAX_COINS],\r\n    _rate_method_id: bytes[4],\r\n    _use_underlying: bool = True,\r\n    _use_rates: bool[MAX_COINS] = [False, False, False, False, False, False, False, False]\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to add\r\n    @param _n_coins Number of coins in the pool\r\n    @param _lp_token Pool deposit token address\r\n    @param _decimals Underlying coin decimal values\r\n    @param _rate_method_id Encoded function signature to query coin rates\r\n    @param _use_underlying Use underlying_coins array when lending is used\r\n    @param _use_rates If _use_underlying is False, define which coins should get lending rates\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.pool_data[_pool].coins[0] == ZERO_ADDRESS  # dev: pool exists\r\n\r\n    # add pool to pool_list\r\n    _length: uint256 = self.pool_count\r\n    self.pool_list[_length] = _pool\r\n    self.pool_count = _length + 1\r\n    self.pool_data[_pool].location = _length\r\n    self.pool_data[_pool].lp_token = _lp_token\r\n    self.pool_data[_pool].rate_method_id = convert(_rate_method_id, bytes32)\r\n\r\n    _decimals_packed: uint256 = 0\r\n\r\n    _coins: address[MAX_COINS] = EMPTY_ADDRESS_ARRAY\r\n    _ucoins: address[MAX_COINS] = EMPTY_ADDRESS_ARRAY\r\n\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n\r\n        # add coin\r\n        _coins[i] = CurvePool(_pool).coins(i)\r\n        ERC20(_coins[i]).approve(_pool, MAX_UINT256)\r\n        self.pool_data[_pool].coins[i] = _coins[i]\r\n\r\n        # add underlying coin\r\n        if _use_underlying:\r\n            _ucoins[i] = CurvePool(_pool).underlying_coins(i)\r\n            if _ucoins[i] != _coins[i]:\r\n                ERC20(_ucoins[i]).approve(_pool, MAX_UINT256)\r\n        else:\r\n            if not _use_rates[i]:\r\n                _ucoins[i] = _coins[i]\r\n\r\n        self.pool_data[_pool].ul_coins[i] = _ucoins[i]\r\n\r\n        # add decimals\r\n        _value: uint256 = _decimals[i]\r\n        if _value == 0:\r\n            if _ucoins[i] == ZERO_ADDRESS:\r\n                _value = ERC20(_coins[i]).decimals()\r\n            else:\r\n                _value = ERC20(_ucoins[i]).decimals()\r\n\r\n        assert _value < 256  # dev: decimal overflow\r\n        _decimals_packed += shift(_value, i * 8)\r\n\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n\r\n        # add pool to markets\r\n        for x in range(i, i + MAX_COINS):\r\n            if x == i:\r\n                continue\r\n            if x == _n_coins:\r\n                break\r\n\r\n            _first: uint256 = min(convert(_coins[i], uint256), convert(_coins[x], uint256))\r\n            _second: uint256 = max(convert(_coins[i], uint256), convert(_coins[x], uint256))\r\n\r\n            _pool_zero: uint256 = self.markets[_first][_second][0]\r\n            if _pool_zero != 0:\r\n                _length = _pool_zero % 65536\r\n                self.markets[_first][_second][_length] = convert(_pool, uint256)\r\n                self.markets[_first][_second][0] = _pool_zero + 1\r\n            else:\r\n                self.markets[_first][_second][0] = shift(convert(_pool, uint256), 16) + 1\r\n\r\n            if (_ucoins[i] == _coins[i] and _ucoins[x] == _coins[x]) or _ucoins[i] == ZERO_ADDRESS or _ucoins[x] == ZERO_ADDRESS:\r\n                continue\r\n\r\n            _first = min(convert(_ucoins[i], uint256), convert(_ucoins[x], uint256))\r\n            _second = max(convert(_ucoins[i], uint256), convert(_ucoins[x], uint256))\r\n\r\n            _pool_zero = self.markets[_first][_second][0]\r\n\r\n            if _pool_zero != 0:\r\n                _length = _pool_zero % 65536\r\n                self.markets[_first][_second][_length] = convert(_pool, uint256)\r\n                self.markets[_first][_second][0] = _pool_zero + 1\r\n            else:\r\n                self.markets[_first][_second][0] = shift(convert(_pool, uint256), 16) + 1\r\n\r\n    self.pool_data[_pool].decimals = convert(_decimals_packed, bytes32)\r\n    log.PoolAdded(_pool, _rate_method_id)\r\n\r\n\r\n@public\r\ndef remove_pool(_pool: address):\r\n    \"\"\"\r\n    @notice Remove a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to remove\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.pool_data[_pool].coins[0] != ZERO_ADDRESS  # dev: pool does not exist\r\n\r\n    # remove _pool from pool_list\r\n    _location: uint256 = self.pool_data[_pool].location\r\n    _length: uint256 = self.pool_count - 1\r\n\r\n    if _location < _length:\r\n        # replace _pool with final value in pool_list\r\n        _addr: address = self.pool_list[_length]\r\n        self.pool_list[_location] = _addr\r\n        self.pool_data[_addr].location = _location\r\n\r\n    # delete final pool_list value\r\n    self.pool_list[_length] = ZERO_ADDRESS\r\n    self.pool_count = _length\r\n\r\n    _coins: address[MAX_COINS] = EMPTY_ADDRESS_ARRAY\r\n    _ucoins: address[MAX_COINS] = EMPTY_ADDRESS_ARRAY\r\n\r\n    for i in range(MAX_COINS):\r\n        _coins[i] = self.pool_data[_pool].coins[i]\r\n        if _coins[i] == ZERO_ADDRESS:\r\n            break\r\n\r\n        # delete coin address from pool_data\r\n        self.pool_data[_pool].coins[i] = ZERO_ADDRESS\r\n\r\n        # delete underlying_coin from pool_data\r\n        _ucoins[i] = self.pool_data[_pool].ul_coins[i]\r\n        self.pool_data[_pool].ul_coins[i] = ZERO_ADDRESS\r\n\r\n    for i in range(MAX_COINS):\r\n        if _coins[i] == ZERO_ADDRESS:\r\n            break\r\n\r\n        # remove pool from markets\r\n        for x in range(i, i + MAX_COINS):\r\n            if x == i:\r\n                continue\r\n            if _coins[x] == ZERO_ADDRESS:\r\n                break\r\n\r\n            _first: uint256 = min(convert(_coins[i], uint256), convert(_coins[x], uint256))\r\n            _second: uint256 = max(convert(_coins[i], uint256), convert(_coins[x], uint256))\r\n\r\n            _pool_zero: uint256 = self.markets[_first][_second][0]\r\n            _length = _pool_zero % 65536 - 1\r\n            if _length == 0:\r\n                self.markets[_first][_second][0] = 0\r\n            elif shift(_pool_zero, -16) == convert(_pool, uint256):\r\n                self.markets[_first][_second][0] = shift(self.markets[_first][_second][_length], 16) + _length\r\n                self.markets[_first][_second][_length] = 0\r\n            else:\r\n                self.markets[_first][_second][0] = _pool_zero - 1\r\n                for n in range(1, 65536):\r\n                    if n == convert(_length, int128):\r\n                        break\r\n                    if self.markets[_first][_second][n] == convert(_pool, uint256):\r\n                        self.markets[_first][_second][n] = self.markets[_first][_second][_length]\r\n                self.markets[_first][_second][_length] = 0\r\n\r\n            if _ucoins[i] == _coins[i] and _ucoins[x] == _coins[x]:\r\n                continue\r\n\r\n            _first = min(convert(_ucoins[i], uint256), convert(_ucoins[x], uint256))\r\n            _second = max(convert(_ucoins[i], uint256), convert(_ucoins[x], uint256))\r\n            _pool_zero = self.markets[_first][_second][0]\r\n            _length = _pool_zero % 65536 - 1\r\n            if _length == 0:\r\n                self.markets[_first][_second][0] = 0\r\n            elif shift(_pool_zero, -16) == convert(_pool, uint256):\r\n                self.markets[_first][_second][0] = shift(self.markets[_first][_second][_length], 16) + _length\r\n                self.markets[_first][_second][_length] = 0\r\n            else:\r\n                self.markets[_first][_second][0] = _pool_zero - 1\r\n                for n in range(1, 65536):\r\n                    if n == convert(_length, int128):\r\n                        break\r\n                    if self.markets[_first][_second][n] == convert(_pool, uint256):\r\n                        self.markets[_first][_second][n] = self.markets[_first][_second][_length]\r\n                self.markets[_first][_second][_length] = 0\r\n\r\n    log.PoolRemoved(_pool)\r\n\r\n\r\n@public\r\ndef set_returns_none(_addr: address, _is_returns_none: bool):\r\n    \"\"\"\r\n    @notice Set `returns_none` value for a coin\r\n    @param _addr Coin address\r\n    @param _is_returns_none if True, coin returns None on a successful transfer\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    self.returns_none[_addr] = _is_returns_none\r\n\r\n\r\n@public\r\ndef set_gas_estimates(_addr: address[10], _amount: uint256[10]):\r\n    \"\"\"\r\n    @notice Set gas estimate amounts\r\n    @param _addr Array of pool or coin addresses\r\n    @param _amount Array of gas estimate amounts\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    for i in range(10):\r\n        if _addr[i] == ZERO_ADDRESS:\r\n            break\r\n        self.gas_estimate_values[_addr[i]] = _amount[i]\r\n\r\n\r\n@public\r\ndef set_gas_estimate_contract(_pool: address, _estimator: address):\r\n    \"\"\"\r\n    @notice Set gas estimate contract\r\n    @param _pool Pool address\r\n    @param _estimator GasEstimator address\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    self.gas_estimate_contracts[_pool] = _estimator\r\n\r\n\r\n@public\r\ndef commit_transfer_ownership(_new_admin: address):\r\n    \"\"\"\r\n    @notice Initiate a transfer of contract ownership\r\n    @dev Once initiated, the actual transfer may be performed three days later\r\n    @param _new_admin Address of the new owner account\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.transfer_ownership_deadline == 0  # dev: transfer already active\r\n\r\n    _deadline: uint256 = as_unitless_number(block.timestamp) + 3*86400\r\n    self.transfer_ownership_deadline = _deadline\r\n    self.future_admin = _new_admin\r\n\r\n    log.CommitNewAdmin(_deadline, _new_admin)\r\n\r\n\r\n@public\r\ndef apply_transfer_ownership():\r\n    \"\"\"\r\n    @notice Finalize a transfer of contract ownership\r\n    @dev May only be called by the current owner, three days after a\r\n         call to `commit_transfer_ownership`\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.transfer_ownership_deadline != 0  # dev: transfer not active\r\n    assert block.timestamp >= self.transfer_ownership_deadline  # dev: now < deadline\r\n\r\n    _new_admin: address = self.future_admin\r\n    self.admin = _new_admin\r\n    self.transfer_ownership_deadline = 0\r\n\r\n    log.NewAdmin(_new_admin)\r\n\r\n\r\n@public\r\ndef revert_transfer_ownership():\r\n    \"\"\"\r\n    @notice Revert a transfer of contract ownership\r\n    @dev May only be called by the current owner\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    self.transfer_ownership_deadline = 0\r\n\r\n\r\n@public\r\ndef claim_token_balance(_token: address):\r\n    \"\"\"\r\n    @notice Transfer any ERC20 balance held by this contract\r\n    @dev The entire balance is transferred to `self.admin`\r\n    @param _token Token address\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    _balance: uint256 = ERC20(_token).balanceOf(self)\r\n    ERC20(_token).transfer(msg.sender, _balance)","ABI":"[{\"name\":\"CommitNewAdmin\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"deadline\",\"indexed\":true},{\"type\":\"address\",\"name\":\"admin\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewAdmin\",\"inputs\":[{\"type\":\"address\",\"name\":\"admin\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenExchange\",\"inputs\":[{\"type\":\"address\",\"name\":\"buyer\",\"indexed\":true},{\"type\":\"address\",\"name\":\"pool\",\"indexed\":true},{\"type\":\"address\",\"name\":\"token_sold\",\"indexed\":false},{\"type\":\"address\",\"name\":\"token_bought\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount_sold\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount_bought\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PoolAdded\",\"inputs\":[{\"type\":\"address\",\"name\":\"pool\",\"indexed\":true},{\"type\":\"bytes\",\"name\":\"rate_method_id\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PoolRemoved\",\"inputs\":[{\"type\":\"address\",\"name\":\"pool\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address[4]\",\"name\":\"_returns_none\"}],\"constant\":false,\"payable\":false,\"type\":\"constructor\"},{\"name\":\"find_pool_for_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"}],\"constant\":true,\"payable\":false,\"type\":\"function\"},{\"name\":\"find_pool_for_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"i\"}],\"constant\":true,\"payable\":false,\"type\":\"function\"},{\"name\":\"get_pool_coins\",\"outputs\":[{\"type\":\"tuple\",\"name\":\"\",\"components\":[{\"type\":\"address[8]\",\"name\":\"coins\"},{\"type\":\"address[8]\",\"name\":\"underlying_coins\"},{\"type\":\"uint256[8]\",\"name\":\"decimals\"}]}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":35452},{\"name\":\"get_pool_info\",\"outputs\":[{\"type\":\"tuple\",\"name\":\"\",\"components\":[{\"type\":\"uint256[8]\",\"name\":\"balances\"},{\"type\":\"uint256[8]\",\"name\":\"underlying_balances\"},{\"type\":\"uint256[8]\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"lp_token\"},{\"type\":\"uint256\",\"name\":\"A\"},{\"type\":\"uint256\",\"name\":\"fee\"}]}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":58032},{\"name\":\"get_pool_rates\",\"outputs\":[{\"type\":\"uint256[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":44706},{\"name\":\"estimate_gas_used\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":6943},{\"name\":\"get_exchange_amount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":44966},{\"name\":\"exchange\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":133643},{\"name\":\"add_pool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"int128\",\"name\":\"_n_coins\"},{\"type\":\"address\",\"name\":\"_lp_token\"},{\"type\":\"uint256[8]\",\"name\":\"_decimals\"},{\"type\":\"bytes\",\"name\":\"_rate_method_id\"}],\"constant\":false,\"payable\":false,\"type\":\"function\"},{\"name\":\"add_pool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"int128\",\"name\":\"_n_coins\"},{\"type\":\"address\",\"name\":\"_lp_token\"},{\"type\":\"uint256[8]\",\"name\":\"_decimals\"},{\"type\":\"bytes\",\"name\":\"_rate_method_id\"},{\"type\":\"bool\",\"name\":\"_use_underlying\"}],\"constant\":false,\"payable\":false,\"type\":\"function\"},{\"name\":\"add_pool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"int128\",\"name\":\"_n_coins\"},{\"type\":\"address\",\"name\":\"_lp_token\"},{\"type\":\"uint256[8]\",\"name\":\"_decimals\"},{\"type\":\"bytes\",\"name\":\"_rate_method_id\"},{\"type\":\"bool\",\"name\":\"_use_underlying\"},{\"type\":\"bool[8]\",\"name\":\"_use_rates\"}],\"constant\":false,\"payable\":false,\"type\":\"function\"},{\"name\":\"remove_pool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":317792223380},{\"name\":\"set_returns_none\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_addr\"},{\"type\":\"bool\",\"name\":\"_is_returns_none\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":36698},{\"name\":\"set_gas_estimates\",\"outputs\":[],\"inputs\":[{\"type\":\"address[10]\",\"name\":\"_addr\"},{\"type\":\"uint256[10]\",\"name\":\"_amount\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":355926},{\"name\":\"set_gas_estimate_contract\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_estimator\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":36761},{\"name\":\"commit_transfer_ownership\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_new_admin\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":74242},{\"name\":\"apply_transfer_ownership\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":60380},{\"name\":\"revert_transfer_ownership\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":21655},{\"name\":\"claim_token_balance\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_token\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":4644},{\"name\":\"admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1661},{\"name\":\"pool_list\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"int128\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1890},{\"name\":\"pool_count\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1721}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.1.0b17","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}