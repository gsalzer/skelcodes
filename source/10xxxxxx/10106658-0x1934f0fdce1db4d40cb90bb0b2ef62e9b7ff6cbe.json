{"status":"1","message":"OK","result":[{"SourceCode":"# @title KULAP Maker Pool V1\r\n# @notice Source code derive from https://github.com/uniswap\r\n# @notice To remove whitelist feature, need to implement re-entrancy guard on every state change public functions\r\n# @notice To remove whitelist feature, need to handle transferFrom properly (checking success / result)\r\n\r\ncontract ERC20_2():\r\n    def balanceOf(_owner : address) -> uint256: constant\r\n    def transfer(_to : address, _value : uint256): modifying\r\n    def transferFrom(_from : address, _to : address, _value : uint256): modifying\r\n\r\n\r\nTokenPurchase: event({buyer: indexed(address), base_sold: indexed(uint256), tokens_bought: indexed(uint256)})\r\nBasePurchase: event({buyer: indexed(address), tokens_sold: indexed(uint256), base_bought: indexed(uint256)})\r\nAddLiquidity: event({provider: indexed(address), base_amount: indexed(uint256), token_amount: indexed(uint256)})\r\nRemoveLiquidity: event({provider: indexed(address), base_amount: indexed(uint256), token_amount: indexed(uint256)})\r\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\r\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\r\n\r\nUpdateProtocolWallet: event({wallet: indexed(address)})\r\nCollectFee: event({token0Fee: uint256, token1Fee: uint256})\r\nUpdateOwner: event({owner: indexed(address)})\r\nAddLiquidityProvider: event({provider: indexed(address)})\r\nRemoveLiquidityProvider: event({provider: indexed(address)})\r\nUpdateFee: event({poolFee: indexed(uint256), protocolFee: indexed(uint256)})\r\nAddTrader: event({trader: indexed(address)})\r\nRemoveTrader: event({trader: indexed(address)})\r\nShutdown: event({token0: uint256, token1: uint256})\r\nDisableShutdown: event({})\r\n\r\n# Governance\r\nowner: public(address)                            # Owner of the system\r\nproviders: public(bool[address])                  # Liquidity providers\r\nproviderCount: public(uint256)                    # Number of providers\r\npoolFee: public(uint256)                          # Total fee In bps\r\nprotocolFee: public(uint256)                      # Protocol fee In bps\r\nprotocolWallet: public(address)                   # Protocol wallet address for fee collection\r\ntoken0FeeBalance: public(uint256)                 # token0 (base) fee balance\r\ntoken1FeeBalance: public(uint256)                 # Token1 fee balance\r\ntraders: public(bool[address])                    # Trader whitelist\r\ntraderCount: public(uint256)                      # Number of traders\r\nallowShutdown: public(bool)                       # Can shutdown\r\n\r\nname: public(bytes[64])                           # KULAP Maker Pool V1\r\nsymbol: public(bytes[32])                         # KMP1\r\ndecimals: public(uint256)                         # 18\r\ntotalSupply: public(uint256)                      # total number of UNI in existence\r\nbalances: uint256[address]                        # UNI balance of an address\r\nallowances: (uint256[address])[address]           # UNI allowance of one address on another\r\ntoken0: ERC20_2                                   # address of the ERC20 token traded on this contract\r\ntoken1: ERC20_2                                   # address of the ERC20 token traded on this contract\r\n\r\n# @dev This function acts as a contract constructor which is not currently supported in contracts deployed\r\n@public\r\ndef setup(token0_addr: address, token1_addr: address, _owner: address):\r\n    assert self.token0 == ZERO_ADDRESS and token0_addr != ZERO_ADDRESS\r\n    assert self.token1 == ZERO_ADDRESS and token1_addr != ZERO_ADDRESS\r\n    self.token0 = token0_addr\r\n    self.token1 = token1_addr\r\n    self.name = 'KULAP Maker Pool V1'\r\n    self.symbol = 'KMP1'\r\n    self.decimals = 18\r\n    self.owner = _owner\r\n    self.poolFee = 30\r\n    self.protocolFee = 15\r\n    self.protocolWallet = _owner\r\n    self.allowShutdown = True\r\n\r\n# @dev whitelist Liquidity Providers.\r\n# @param provider a provider to be whitelisted.\r\n@public\r\ndef addLiquidityProvider(provider: address):\r\n    assert msg.sender == self.owner and provider != ZERO_ADDRESS\r\n    assert False == self.providers[provider]\r\n    self.providers[provider] = True\r\n    self.providerCount += 1\r\n    log.AddLiquidityProvider(provider)\r\n\r\n# @dev de-whitelist Liquidity Providers.\r\n# @param provider a provider to be removed from whitelists.\r\n@public\r\ndef removeLiquidityProvider(provider: address):\r\n    assert msg.sender == self.owner and provider != ZERO_ADDRESS\r\n    assert True == self.providers[provider]\r\n    self.providers[provider] = False\r\n    self.providerCount -= 1\r\n    log.RemoveLiquidityProvider(provider)\r\n\r\n# @dev whitelist Traders.\r\n# @param trader a trader to be whitelisted.\r\n@public\r\ndef addTrader(trader: address):\r\n    assert msg.sender == self.owner and trader != ZERO_ADDRESS\r\n    assert False == self.traders[trader]\r\n    self.traders[trader] = True\r\n    self.traderCount += 1\r\n    log.AddTrader(trader)\r\n\r\n# @dev de-whitelist Traders.\r\n# @param trader a trader to be removed from whitelists.\r\n@public\r\ndef removeTrader(trader: address):\r\n    assert msg.sender == self.owner and trader != ZERO_ADDRESS\r\n    assert True == self.traders[trader]\r\n    self.traders[trader] = False\r\n    self.traderCount -= 1\r\n    log.RemoveTrader(trader)\r\n\r\n# @notice Liquidity Provider fee = _poolFee - _protocolFee.\r\n# @dev Configure system fees.\r\n# @param _poolFee a fee in bps for overall fee.\r\n# @param _protocolFee a fee in bps for protocol fee.\r\n@public\r\ndef setFee(_poolFee: uint256, _protocolFee: uint256):\r\n    assert msg.sender == self.owner\r\n    assert _poolFee <= 1000 # no more than 10%\r\n    assert _protocolFee <= 1000 # no more than 10%\r\n    assert _protocolFee <= _poolFee\r\n    self.poolFee = _poolFee\r\n    self.protocolFee = _protocolFee\r\n    log.UpdateFee(_poolFee, _protocolFee)\r\n\r\n# @dev Configure a wallet for protocol fee.\r\n# @param wallet a wallet address for receiving protocol fee.\r\n@public\r\ndef setProtocolWallet(wallet: address):\r\n    assert msg.sender == self.owner and wallet != ZERO_ADDRESS\r\n    self.protocolWallet = wallet\r\n    log.UpdateProtocolWallet(wallet)\r\n\r\n# @dev Call to collect protocol fees.\r\n@public\r\ndef collectProtocolFee():\r\n    self.token0.transfer(self.protocolWallet, self.token0FeeBalance)\r\n    self.token1.transfer(self.protocolWallet, self.token1FeeBalance)\r\n    log.CollectFee(self.token0FeeBalance, self.token1FeeBalance)\r\n    self.token0FeeBalance = 0\r\n    self.token1FeeBalance = 0\r\n\r\n# @dev Change owner address.\r\n# @param newOwner new owner address.\r\n@public\r\ndef updateOwner(newOwner: address):\r\n    assert msg.sender == self.owner and newOwner != ZERO_ADDRESS\r\n    self.owner = newOwner\r\n    log.UpdateOwner(newOwner)\r\n\r\n# @dev Call only once when system need to be shutdown.\r\n@public\r\ndef emergencyShutdown():\r\n    assert msg.sender == self.owner\r\n    assert self.allowShutdown\r\n    token0_balance: uint256 = self.token0.balanceOf(self)\r\n    token1_balance: uint256 = self.token1.balanceOf(self)\r\n    self.token0.transfer(msg.sender, token0_balance)\r\n    self.token1.transfer(msg.sender, token1_balance)\r\n    log.Shutdown(token0_balance, token1_balance)\r\n\r\n# @dev Permanently disable shutdown feature.\r\n@public\r\ndef disableEmergencyShutdown():\r\n    assert msg.sender == self.owner\r\n    assert self.allowShutdown\r\n    self.allowShutdown = False\r\n    log.DisableShutdown()\r\n\r\n# @notice Deposit Base and Tokens at current ratio to mint UNI tokens.\r\n# @dev min_liquidity does nothing when total UNI supply is 0.\r\n# @param token0_amount Specific number of token0 deposited.\r\n# @param min_liquidity Minimum number of UNI sender will mint if total UNI supply is greater than 0.\r\n# @param max_tokens Maximum number of token1 deposited. Deposits max amount if total UNI supply is 0.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return The amount of UNI minted.\r\n@public\r\ndef addLiquidity(token0_amount: uint256, min_liquidity: uint256, max_tokens: uint256, deadline: timestamp) -> uint256:\r\n    assert self.providers[msg.sender]\r\n    assert deadline > block.timestamp and (max_tokens > 0 and token0_amount > 0)\r\n    total_liquidity: uint256 = self.totalSupply\r\n    if total_liquidity > 0:\r\n        assert min_liquidity > 0\r\n        token0_reserve: uint256 = self.token0.balanceOf(self) - self.token0FeeBalance\r\n        token1_reserve: uint256 = self.token1.balanceOf(self) - self.token1FeeBalance\r\n        token1_amount: uint256 = token0_amount * token1_reserve / token0_reserve + 1\r\n        liquidity_minted: uint256 = token0_amount * total_liquidity / token0_reserve\r\n        assert max_tokens >= token1_amount and liquidity_minted >= min_liquidity\r\n        self.balances[msg.sender] += liquidity_minted\r\n        self.totalSupply = total_liquidity + liquidity_minted\r\n        self.token0.transferFrom(msg.sender, self, token0_amount)\r\n        self.token1.transferFrom(msg.sender, self, token1_amount)\r\n        log.AddLiquidity(msg.sender, token0_amount, token1_amount)\r\n        log.Transfer(ZERO_ADDRESS, msg.sender, liquidity_minted)\r\n        return liquidity_minted\r\n    else:\r\n        assert (self.token1 != ZERO_ADDRESS) and token0_amount >= 1\r\n        token1_amount: uint256 = max_tokens\r\n        initial_liquidity: uint256 = token0_amount\r\n        self.totalSupply = initial_liquidity\r\n        self.balances[msg.sender] = initial_liquidity\r\n        self.token0.transferFrom(msg.sender, self, token0_amount)\r\n        self.token1.transferFrom(msg.sender, self, token1_amount)\r\n        log.AddLiquidity(msg.sender, token0_amount, token1_amount)\r\n        log.Transfer(ZERO_ADDRESS, msg.sender, initial_liquidity)\r\n        return initial_liquidity\r\n\r\n# @dev Burn UNI tokens to withdraw Base and Tokens at current ratio.\r\n# @param amount Amount of UNI burned.\r\n# @param min_tokens_0 Minimum Base withdrawn.\r\n# @param min_tokens_1 Minimum Tokens withdrawn.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return The amount of Base and Tokens withdrawn.\r\n@public\r\ndef removeLiquidity(amount: uint256, min_tokens_0: uint256, min_tokens_1: uint256, deadline: timestamp) -> (uint256, uint256):\r\n    assert self.providers[msg.sender]\r\n    assert (amount > 0 and deadline > block.timestamp) and (min_tokens_0 > 0 and min_tokens_1 > 0)\r\n    total_liquidity: uint256 = self.totalSupply\r\n    assert total_liquidity > 0\r\n    token0_reserve: uint256 = self.token0.balanceOf(self) - self.token0FeeBalance\r\n    token1_reserve: uint256 = self.token1.balanceOf(self) - self.token1FeeBalance\r\n    token0_amount: uint256 = amount * token0_reserve / total_liquidity\r\n    token1_amount: uint256 = amount * token1_reserve / total_liquidity\r\n    assert token0_amount >= min_tokens_0 and token1_amount >= min_tokens_1\r\n    self.balances[msg.sender] -= amount\r\n    self.totalSupply = total_liquidity - amount\r\n    self.token0.transfer(msg.sender, token0_amount)\r\n    self.token1.transfer(msg.sender, token1_amount)\r\n    log.RemoveLiquidity(msg.sender, token0_amount, token1_amount)\r\n    log.Transfer(msg.sender, ZERO_ADDRESS, amount)\r\n    return token0_amount, token1_amount\r\n\r\n# @dev Pricing function for converting between Base and Tokens.\r\n# @param input_amount Amount of Base or Tokens being sold.\r\n# @param input_reserve Amount of Base or Tokens (input type) in exchange reserves.\r\n# @param output_reserve Amount of Base or Tokens (output type) in exchange reserves.\r\n# @return Amount of Base or Tokens bought.\r\n@private\r\n@constant\r\ndef getInputPrice(input_amount: uint256, input_reserve: uint256, output_reserve: uint256) -> uint256:\r\n    assert input_reserve > 0 and output_reserve > 0\r\n    input_amount_with_fee: uint256 = input_amount * (10000 - self.poolFee)\r\n    numerator: uint256 = input_amount_with_fee * output_reserve\r\n    denominator: uint256 = (input_reserve * 10000) + input_amount_with_fee\r\n    return numerator / denominator\r\n\r\n# @dev Pricing function for converting between Base and Tokens.\r\n# @param output_amount Amount of Base or Tokens being bought.\r\n# @param input_reserve Amount of Base or Tokens (input type) in exchange reserves.\r\n# @param output_reserve Amount of Base or Tokens (output type) in exchange reserves.\r\n# @return Amount of Base or Tokens sold.\r\n@private\r\n@constant\r\ndef getOutputPrice(output_amount: uint256, input_reserve: uint256, output_reserve: uint256) -> uint256:\r\n    assert input_reserve > 0 and output_reserve > 0\r\n    numerator: uint256 = input_reserve * output_amount * 10000\r\n    denominator: uint256 = (output_reserve - output_amount) * (10000 - self.poolFee)\r\n    return numerator / denominator + 1\r\n\r\n@private\r\ndef accountProtocolFee(input_amount: uint256, is_base: bool):\r\n    if self.protocolFee > 0:\r\n        fee: uint256 = input_amount * self.protocolFee / 10000\r\n        if is_base:\r\n            self.token0FeeBalance += fee\r\n        else:\r\n            self.token1FeeBalance += fee\r\n\r\n@private\r\ndef baseToTokenInput(base_sold: uint256, min_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and (base_sold > 0 and min_tokens > 0)\r\n    token0_reserve: uint256 = self.token0.balanceOf(self) - self.token0FeeBalance\r\n    token1_reserve: uint256 = self.token1.balanceOf(self) - self.token1FeeBalance\r\n    tokens_bought: uint256 = self.getInputPrice(base_sold, token0_reserve, token1_reserve)\r\n    assert tokens_bought >= min_tokens\r\n    self.token0.transferFrom(buyer, self, base_sold)\r\n    self.token1.transfer(recipient, tokens_bought)\r\n    self.accountProtocolFee(base_sold, True)\r\n    log.TokenPurchase(buyer, base_sold, tokens_bought)\r\n    return tokens_bought\r\n\r\n# @notice Convert Base to Tokens.\r\n# @param base_sold specifies exact base input.\r\n# @param min_tokens Minimum Tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Tokens bought.\r\n@public\r\ndef baseToTokenSwapInput(base_sold: uint256, min_tokens: uint256, deadline: timestamp) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    return self.baseToTokenInput(base_sold, min_tokens, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Base to Tokens and transfers Tokens to recipient.\r\n# @param base_sold specifies exact base input.\r\n# @param min_tokens Minimum Tokens bought.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Tokens.\r\n# @return Amount of Tokens bought.\r\n@public\r\ndef baseToTokenTransferInput(base_sold: uint256, min_tokens: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.baseToTokenInput(base_sold, min_tokens, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef baseToTokenOutput(tokens_bought: uint256, max_base: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and (tokens_bought > 0 and max_base > 0)\r\n    token0_reserve: uint256 = self.token0.balanceOf(self) - self.token0FeeBalance\r\n    token1_reserve: uint256 = self.token1.balanceOf(self) - self.token1FeeBalance\r\n    base_sold: uint256 = self.getOutputPrice(tokens_bought, token0_reserve, token1_reserve)\r\n    assert max_base >= base_sold\r\n    self.token0.transferFrom(buyer, self, base_sold)\r\n    self.token1.transfer(recipient, tokens_bought)\r\n    self.accountProtocolFee(base_sold, True)\r\n    log.TokenPurchase(buyer, base_sold, tokens_bought)\r\n    return base_sold\r\n\r\n# @notice Convert Base to Tokens.\r\n# @param tokens_bought Amount of tokens bought.\r\n# @param max_base specifies the max base input.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Base sold.\r\n@public\r\ndef baseToTokenSwapOutput(tokens_bought: uint256, max_base: uint256, deadline: timestamp) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    return self.baseToTokenOutput(tokens_bought, max_base, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Base to Tokens and transfers Tokens to recipient.\r\n# @param tokens_bought Amount of tokens bought.\r\n# @param max_base specifies the max base input.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Tokens.\r\n# @return Amount of Base sold.\r\n@public\r\ndef baseToTokenTransferOutput(tokens_bought: uint256, max_base: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.baseToTokenOutput(tokens_bought, max_base, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToBaseInput(tokens_sold: uint256, min_base: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and (tokens_sold > 0 and min_base > 0)\r\n    token0_reserve: uint256 = self.token0.balanceOf(self) - self.token0FeeBalance\r\n    token1_reserve: uint256 = self.token1.balanceOf(self) - self.token1FeeBalance\r\n    base_bought: uint256 = self.getInputPrice(tokens_sold, token1_reserve, token0_reserve)\r\n    assert base_bought >= min_base\r\n    self.token0.transfer(recipient, base_bought)\r\n    self.token1.transferFrom(buyer, self, tokens_sold)\r\n    self.accountProtocolFee(tokens_sold, False)\r\n    log.BasePurchase(buyer, tokens_sold, base_bought)\r\n    return base_bought\r\n\r\n\r\n# @notice Convert Tokens to Base.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_base Minimum Base purchased.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Base bought.\r\n@public\r\ndef tokenToBaseSwapInput(tokens_sold: uint256, min_base: uint256, deadline: timestamp) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    return self.tokenToBaseInput(tokens_sold, min_base, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Tokens to Base and transfers Base to recipient.\r\n# @dev User specifies exact input and minimum output.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @param min_base Minimum Base purchased.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Base.\r\n# @return Amount of Base bought.\r\n@public\r\ndef tokenToBaseTransferInput(tokens_sold: uint256, min_base: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.tokenToBaseInput(tokens_sold, min_base, deadline, msg.sender, recipient)\r\n\r\n@private\r\ndef tokenToBaseOutput(base_bought: uint256, max_tokens: uint256, deadline: timestamp, buyer: address, recipient: address) -> uint256:\r\n    assert deadline >= block.timestamp and base_bought > 0\r\n    token0_reserve: uint256 = self.token0.balanceOf(self) - self.token0FeeBalance\r\n    token1_reserve: uint256 = self.token1.balanceOf(self) - self.token1FeeBalance\r\n    tokens_sold: uint256 = self.getOutputPrice(base_bought, token1_reserve, token0_reserve)\r\n    # tokens sold is always > 0\r\n    assert max_tokens >= tokens_sold\r\n    self.token0.transfer(recipient, base_bought)\r\n    self.token1.transferFrom(buyer, self, tokens_sold)\r\n    self.accountProtocolFee(tokens_sold, False)\r\n    log.BasePurchase(buyer, tokens_sold, base_bought)\r\n    return tokens_sold\r\n\r\n# @notice Convert Tokens to Base.\r\n# @dev User specifies maximum input and exact output.\r\n# @param base_bought Amount of Base purchased.\r\n# @param max_tokens Maximum Tokens sold.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @return Amount of Tokens sold.\r\n@public\r\ndef tokenToBaseSwapOutput(base_bought: uint256, max_tokens: uint256, deadline: timestamp) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    return self.tokenToBaseOutput(base_bought, max_tokens, deadline, msg.sender, msg.sender)\r\n\r\n# @notice Convert Tokens to Base and transfers Base to recipient.\r\n# @dev User specifies maximum input and exact output.\r\n# @param base_bought Amount of Base purchased.\r\n# @param max_tokens Maximum Tokens sold.\r\n# @param deadline Time after which this transaction can no longer be executed.\r\n# @param recipient The address that receives output Base.\r\n# @return Amount of Tokens sold.\r\n@public\r\ndef tokenToBaseTransferOutput(base_bought: uint256, max_tokens: uint256, deadline: timestamp, recipient: address) -> uint256:\r\n    assert self.traders[msg.sender]\r\n    assert recipient != self and recipient != ZERO_ADDRESS\r\n    return self.tokenToBaseOutput(base_bought, max_tokens, deadline, msg.sender, recipient)\r\n\r\n# @notice Public price function for Base to Token trades with an exact input.\r\n# @param base_sold Amount of Base sold.\r\n# @return Amount of Tokens that can be bought with input Base.\r\n@public\r\n@constant\r\ndef getBaseToTokenInputPrice(base_sold: uint256) -> uint256:\r\n    assert base_sold > 0\r\n    token0_reserve: uint256 = self.token0.balanceOf(self) - self.token0FeeBalance\r\n    token1_reserve: uint256 = self.token1.balanceOf(self) - self.token1FeeBalance\r\n    return self.getInputPrice(base_sold, token0_reserve, token1_reserve)\r\n\r\n# @notice Public price function for Base to Token trades with an exact output.\r\n# @param tokens_bought Amount of Tokens bought.\r\n# @return Amount of Base needed to buy output Tokens.\r\n@public\r\n@constant\r\ndef getBaseToTokenOutputPrice(tokens_bought: uint256) -> uint256:\r\n    assert tokens_bought > 0\r\n    token0_reserve: uint256 = self.token0.balanceOf(self) - self.token0FeeBalance\r\n    token1_reserve: uint256 = self.token1.balanceOf(self) - self.token1FeeBalance\r\n    base_sold: uint256 = self.getOutputPrice(tokens_bought, token0_reserve, token1_reserve)\r\n    return base_sold\r\n\r\n# @notice Public price function for Token to Base trades with an exact input.\r\n# @param tokens_sold Amount of Tokens sold.\r\n# @return Amount of Base that can be bought with input Tokens.\r\n@public\r\n@constant\r\ndef getTokenToBaseInputPrice(tokens_sold: uint256) -> uint256:\r\n    assert tokens_sold > 0\r\n    token0_reserve: uint256 = self.token0.balanceOf(self) - self.token0FeeBalance\r\n    token1_reserve: uint256 = self.token1.balanceOf(self) - self.token1FeeBalance\r\n    base_bought: uint256 = self.getInputPrice(tokens_sold, token1_reserve, token0_reserve)\r\n    return base_bought\r\n\r\n# @notice Public price function for Token to Base trades with an exact output.\r\n# @param base_bought Amount of output Base.\r\n# @return Amount of Tokens needed to buy output Base.\r\n@public\r\n@constant\r\ndef getTokenToBaseOutputPrice(base_bought: uint256) -> uint256:\r\n    assert base_bought > 0\r\n    token0_reserve: uint256 = self.token0.balanceOf(self) - self.token0FeeBalance\r\n    token1_reserve: uint256 = self.token1.balanceOf(self) - self.token1FeeBalance\r\n    return self.getOutputPrice(base_bought, token1_reserve, token0_reserve)\r\n\r\n# @return Address of Token0 that is sold on this exchange.\r\n@public\r\n@constant\r\ndef token0Address() -> address(ERC20_2):\r\n    return self.token0\r\n\r\n# @return Address of Token1 that is sold on this exchange.\r\n@public\r\n@constant\r\ndef token1Address() -> address(ERC20_2):\r\n    return self.token1\r\n\r\n# ERC20 compatibility for exchange liquidity modified from\r\n# https://github.com/ethereum/vyper/blob/master/examples/tokens/ERC20.vy\r\n@public\r\n@constant\r\ndef balanceOf(_owner : address) -> uint256:\r\n    return self.balances[_owner]\r\n\r\n@public\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    self.balances[msg.sender] -= _value\r\n    self.balances[_to] += _value\r\n    log.Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    self.balances[_from] -= _value\r\n    self.balances[_to] += _value\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log.Transfer(_from, _to, _value)\r\n    return True\r\n\r\n@public\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log.Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n@public\r\n@constant\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    return self.allowances[_owner][_spender]","ABI":"[{\"name\":\"TokenPurchase\",\"inputs\":[{\"type\":\"address\",\"name\":\"buyer\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"base_sold\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"tokens_bought\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BasePurchase\",\"inputs\":[{\"type\":\"address\",\"name\":\"buyer\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"tokens_sold\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"base_bought\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"base_amount\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"token_amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"base_amount\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"token_amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_to\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateProtocolWallet\",\"inputs\":[{\"type\":\"address\",\"name\":\"wallet\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CollectFee\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"token0Fee\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"token1Fee\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateOwner\",\"inputs\":[{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidityProvider\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityProvider\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateFee\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"poolFee\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"protocolFee\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddTrader\",\"inputs\":[{\"type\":\"address\",\"name\":\"trader\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveTrader\",\"inputs\":[{\"type\":\"address\",\"name\":\"trader\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Shutdown\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"token0\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"token1\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"DisableShutdown\",\"inputs\":[],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"setup\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"token0_addr\"},{\"type\":\"address\",\"name\":\"token1_addr\"},{\"type\":\"address\",\"name\":\"_owner\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":422245},{\"name\":\"addLiquidityProvider\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"provider\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":73100},{\"name\":\"removeLiquidityProvider\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"provider\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":57924},{\"name\":\"addTrader\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"trader\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":73160},{\"name\":\"removeTrader\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"trader\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":57984},{\"name\":\"setFee\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_poolFee\"},{\"type\":\"uint256\",\"name\":\"_protocolFee\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":72589},{\"name\":\"setProtocolWallet\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"wallet\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":36965},{\"name\":\"collectProtocolFee\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":48347},{\"name\":\"updateOwner\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"newOwner\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37025},{\"name\":\"emergencyShutdown\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":11264},{\"name\":\"disableEmergencyShutdown\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":21914},{\"name\":\"addLiquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"token0_amount\"},{\"type\":\"uint256\",\"name\":\"min_liquidity\"},{\"type\":\"uint256\",\"name\":\"max_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":87633},{\"name\":\"removeLiquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"},{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"amount\"},{\"type\":\"uint256\",\"name\":\"min_tokens_0\"},{\"type\":\"uint256\",\"name\":\"min_tokens_1\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":86600},{\"name\":\"baseToTokenSwapInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"base_sold\"},{\"type\":\"uint256\",\"name\":\"min_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":98412},{\"name\":\"baseToTokenTransferInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"base_sold\"},{\"type\":\"uint256\",\"name\":\"min_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":98621},{\"name\":\"baseToTokenSwapOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"},{\"type\":\"uint256\",\"name\":\"max_base\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":101122},{\"name\":\"baseToTokenTransferOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"},{\"type\":\"uint256\",\"name\":\"max_base\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":101331},{\"name\":\"tokenToBaseSwapInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"},{\"type\":\"uint256\",\"name\":\"min_base\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":98772},{\"name\":\"tokenToBaseTransferInput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"},{\"type\":\"uint256\",\"name\":\"min_base\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":98981},{\"name\":\"tokenToBaseSwapOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"base_bought\"},{\"type\":\"uint256\",\"name\":\"max_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":101467},{\"name\":\"tokenToBaseTransferOutput\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"base_bought\"},{\"type\":\"uint256\",\"name\":\"max_tokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"recipient\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":101676},{\"name\":\"getBaseToTokenInputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"base_sold\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":10122},{\"name\":\"getBaseToTokenOutputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_bought\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":11444},{\"name\":\"getTokenToBaseInputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"tokens_sold\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":10209},{\"name\":\"getTokenToBaseOutputPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"base_bought\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":11477},{\"name\":\"token0Address\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1443},{\"name\":\"token1Address\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1473},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1675},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":75064},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":110937},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":38799},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"},{\"type\":\"address\",\"name\":\"_spender\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1955},{\"name\":\"owner\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1653},{\"name\":\"providers\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1855},{\"name\":\"providerCount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1713},{\"name\":\"poolFee\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1743},{\"name\":\"protocolFee\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1773},{\"name\":\"protocolWallet\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1803},{\"name\":\"token0FeeBalance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1833},{\"name\":\"token1FeeBalance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1863},{\"name\":\"traders\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2065},{\"name\":\"traderCount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1923},{\"name\":\"allowShutdown\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1953},{\"name\":\"name\",\"outputs\":[{\"type\":\"bytes\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":12889},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"bytes\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":7774},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2043},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2073}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.1.0b4","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}