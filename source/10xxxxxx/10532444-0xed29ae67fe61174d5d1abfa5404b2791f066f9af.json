{"status":"1","message":"OK","result":[{"SourceCode":"{\"hyip.sol\":{\"content\":\"\\r\\npragma solidity ^0.4.20;\\r\\n\\r\\n\\r\\ncontract HYIP_Dapp_pool {\\r\\n\\r\\n    /*=================================\\r\\n    =            MODIFIERS            =\\r\\n    =================================*/\\r\\n    // only people with tokens\\r\\n    modifier onlybelievers () {\\r\\n        require(myTokens() \\u003e 0);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // only people with profits\\r\\n    modifier onlyhodler() {\\r\\n        require(myDividends(true) \\u003e 0);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // administrators can:\\r\\n    // -\\u003e change the name of the contract\\r\\n    // -\\u003e change the name of the token\\r\\n    // -\\u003e change the PoS difficulty\\r\\n    // they CANNOT:\\r\\n    // -\\u003e take funds\\r\\n    // -\\u003e disable withdrawals\\r\\n    // -\\u003e kill the contract\\r\\n    // -\\u003e change the price of tokens\\r\\n    modifier onlyAdministrator(){\\r\\n        address _customerAddress = msg.sender;\\r\\n        require(administrators[_customerAddress]);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    modifier antiEarlyWhale(uint256 _amountOfEthereum){\\r\\n        address _customerAddress = msg.sender;\\r\\n\\r\\n\\r\\n        if( onlyAmbassadors \\u0026\\u0026 ((totalEthereumBalance() - _amountOfEthereum) \\u003c= ambassadorQuota_ )){\\r\\n            require(\\r\\n                // is the customer in the ambassador list?\\r\\n                ambassadors_[_customerAddress] == true \\u0026\\u0026\\r\\n\\r\\n                // does the customer purchase exceed the max ambassador quota?\\r\\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) \\u003c= ambassadorMaxPurchase_\\r\\n\\r\\n            );\\r\\n\\r\\n            // updated the accumulated quota\\r\\n            ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\\r\\n\\r\\n            // execute\\r\\n            _;\\r\\n        } else {\\r\\n            // in case the ether count drops low, the ambassador phase won\\u0027t reinitiate\\r\\n            onlyAmbassadors = false;\\r\\n            _;\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    /*==============================\\r\\n    =            EVENTS            =\\r\\n    ==============================*/\\r\\n    event onTokenPurchase(\\r\\n        address indexed customerAddress,\\r\\n        uint256 incomingEthereum,\\r\\n        uint256 tokensMinted\\r\\n    );\\r\\n\\r\\n    event onTokenSell(\\r\\n        address indexed customerAddress,\\r\\n        uint256 tokensBurned,\\r\\n        uint256 ethereumEarned\\r\\n    );\\r\\n\\r\\n    event onReinvestment(\\r\\n        address indexed customerAddress,\\r\\n        uint256 ethereumReinvested,\\r\\n        uint256 tokensMinted\\r\\n    );\\r\\n\\r\\n    event onWithdraw(\\r\\n        address indexed customerAddress,\\r\\n        uint256 ethereumWithdrawn\\r\\n    );\\r\\n\\r\\n    // ERC20\\r\\n    event TransferToken(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 tokens\\r\\n    );\\r\\n\\r\\n\\r\\n    /*=====================================\\r\\n    =            CONFIGURABLES            =\\r\\n    =====================================*/\\r\\n    string public name = \\\"HYIP Dapp pool\\\";\\r\\n    string public symbol = \\\"HDAAP\\\";\\r\\n    uint8 constant public decimals = 18;\\r\\n    uint8 constant internal dividendFee_ = 10;\\r\\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\\r\\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\\r\\n    uint256 constant internal magnitude = 2**64;\\r\\n\\r\\n    // proof of stake (defaults at 1 token)\\r\\n    uint256 public stakingRequirement = 1e18;\\r\\n\\r\\n    // ambassador program\\r\\n    mapping(address =\\u003e bool) internal ambassadors_;\\r\\n    mapping(address =\\u003e bool) private investorExist;\\r\\n    uint256 constant internal ambassadorMaxPurchase_ = 1 ether;\\r\\n    uint256 constant internal ambassadorQuota_ = 1 ether;\\r\\n\\r\\n    /*This address is where the 3% goes to.\\r\\n    This address nor anywhere else in the contract can dump the contract. In other words.\\r\\n    No funny business can happen.Owner _toAddress*/\\r\\n    address private owner= 0x671D9276b848Eb4d03934592168BEF1Be4fcCcdE ;\\r\\n    // address private owner\\r\\n    address[] private investors;\\r\\n\\r\\n   /*================================\\r\\n    =            DATASETS            =\\r\\n    ================================*/\\r\\n    // amount of shares for each address (scaled number)\\r\\n    mapping(address =\\u003e uint256) private tokenBalanceLedger_;\\r\\n    mapping( uint256 =\\u003e address) private dividendOwner;\\r\\n    mapping(address =\\u003e uint256) internal referralBalance_;\\r\\n    mapping(address =\\u003e int256) internal payoutsTo_;\\r\\n    mapping(address =\\u003e uint256) internal ambassadorAccumulatedQuota_;\\r\\n    uint256 internal tokenSupply_ = 0;\\r\\n    uint256 internal profitPerShare_;\\r\\n\\r\\n    // administrator list (see above on what they can do)\\r\\n    mapping(address =\\u003e bool) public administrators;\\r\\n\\r\\n\\r\\n    bool public onlyAmbassadors = false;\\r\\n\\r\\n\\r\\n\\r\\n    /*=======================================\\r\\n    =            PUBLIC FUNCTIONS            =\\r\\n    =======================================*/\\r\\n    /*\\r\\n    * -- APPLICATION ENTRY POINTS --\\r\\n    */\\r\\n    function HYIP_Dapp_pool()\\r\\n        public\\r\\n    {\\r\\n        // add administrators here\\r\\n        administrators[0x7a0caA92C373481480249994eE7291671864bD27] = true;\\r\\n\\r\\n\\r\\n        ambassadors_[0x0000000000000000000000000000000000000000] = true;\\r\\n\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    Custom Function: Send ETH to all token holders\\r\\n    */\\r\\n    function sendEth()\\r\\n    public\\r\\n    payable\\r\\n    {\\r\\n\\r\\n\\r\\n      uint256  size = 0;\\r\\n    for(uint256 i = 0; i\\u003cinvestors.length;i = SafeMath.add(i,1)){\\r\\n\\r\\n      if(balanceOf(investors[i])\\u003e0){\\r\\n        dividendOwner[i] = investors[i];\\r\\n        size = SafeMath.add(size,1);\\r\\n      }\\r\\n    }\\r\\n    uint256 tokens = calculateTokensReceived(msg.value);\\r\\n    if(tokenSupply_ \\u003e 0){\\r\\n\\r\\n        // add tokens to the pool\\r\\n        tokenSupply_ = SafeMath.add(tokenSupply_, tokens);\\r\\n\\r\\n        // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\\r\\n\\r\\n    } else {\\r\\n        // add tokens to the pool\\r\\n        tokenSupply_ = tokens;\\r\\n    }\\r\\n\\r\\n    uint256 perShare = SafeMath.div(tokens,size);\\r\\n    for(i = 0; i\\u003csize;i = SafeMath.add(i,1)){\\r\\n      tokenBalanceLedger_[dividendOwner[i]] = SafeMath.add(tokenBalanceLedger_[dividendOwner[i]], perShare);\\r\\n      // calculate the amount of tokens the customer receives over his purchase\\r\\n    }\\r\\n\\r\\n    }\\r\\n    /**\\r\\n     * Converts all incoming Ethereum to tokens for the caller, and passes down the referral address (if any)\\r\\n     */\\r\\n    function buy(address _referredBy)\\r\\n        public\\r\\n        payable\\r\\n        returns(uint256)\\r\\n    {\\r\\n        purchaseTokens(msg.value, _referredBy);\\r\\n    }\\r\\n\\r\\n\\r\\n    function()\\r\\n        payable\\r\\n        public\\r\\n    {\\r\\n        purchaseTokens(msg.value, 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Converts all of caller\\u0027s dividends to tokens.\\r\\n     */\\r\\n    function reinvest()\\r\\n        onlyhodler()\\r\\n        public\\r\\n    {\\r\\n        // fetch dividends\\r\\n        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\\r\\n\\r\\n        // pay out the dividends virtually\\r\\n        address _customerAddress = msg.sender;\\r\\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\\r\\n\\r\\n        // retrieve ref. bonus\\r\\n        _dividends += referralBalance_[_customerAddress];\\r\\n        referralBalance_[_customerAddress] = 0;\\r\\n\\r\\n        // dispatch a buy order with the virtualized \\\"withdrawn dividends\\\"\\r\\n        uint256 _tokens = purchaseTokens(_dividends, 0x0);\\r\\n\\r\\n        // fire event\\r\\n        onReinvestment(_customerAddress, _dividends, _tokens);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Alias of sell() and withdraw().\\r\\n     */\\r\\n    function exit()\\r\\n        public\\r\\n    {\\r\\n        // get token count for caller \\u0026 sell them all\\r\\n        address _customerAddress = msg.sender;\\r\\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\\r\\n        if(_tokens \\u003e 0) sell(_tokens);\\r\\n\\r\\n\\r\\n        withdraw();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Withdraws all of the callers earnings.\\r\\n     */\\r\\n    function withdraw()\\r\\n        onlyhodler()\\r\\n        public\\r\\n    {\\r\\n        // setup data\\r\\n        address _customerAddress = msg.sender;\\r\\n        uint256 _dividends = myDividends(false); // get ref. bonus later in the code\\r\\n\\r\\n        // update dividend tracker\\r\\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\\r\\n\\r\\n        // add ref. bonus\\r\\n        _dividends += referralBalance_[_customerAddress];\\r\\n        referralBalance_[_customerAddress] = 0;\\r\\n\\r\\n        // delivery service\\r\\n        transferToken(_customerAddress,_dividends);\\r\\n\\r\\n        // fire event\\r\\n        onWithdraw(_customerAddress, _dividends);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Liquifies tokens to ethereum.\\r\\n     */\\r\\n    function sell(uint256 _amountOfTokens)\\r\\n        onlybelievers ()\\r\\n        public\\r\\n    {\\r\\n\\r\\n        address _customerAddress = msg.sender;\\r\\n\\r\\n        require(_amountOfTokens \\u003c= tokenBalanceLedger_[_customerAddress]);\\r\\n        uint256 _tokens = _amountOfTokens;\\r\\n        uint256 _ethereum = tokensToEthereum_(_tokens);\\r\\n        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\\r\\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\\r\\n        _customerAddress.transfer(_taxedEthereum);\\r\\n        // burn the sold tokens\\r\\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\\r\\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\\r\\n\\r\\n        // update dividends tracker\\r\\n          int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\\r\\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\\r\\n\\r\\n        // dividing by zero is a bad idea\\r\\n        if (tokenSupply_ \\u003e 0) {\\r\\n            // update the amount of dividends per token\\r\\n            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\\r\\n        }\\r\\n\\r\\n        // fire event\\r\\n        onTokenSell(_customerAddress, _tokens, _taxedEthereum);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * transferToken tokens from the caller to a new holder.\\r\\n     * Remember, there\\u0027s a 10% fee here as well.\\r\\n     */\\r\\n    function transferToken(address _toAddress, uint256 _amountOfTokens)\\r\\n        onlybelievers ()\\r\\n        public\\r\\n        returns(bool)\\r\\n    {\\r\\n        // setup\\r\\n        address _customerAddress = msg.sender;\\r\\n\\r\\n        // make sure we have the requested tokens\\r\\n\\r\\n        require(!onlyAmbassadors \\u0026\\u0026 _amountOfTokens \\u003c= tokenBalanceLedger_[_customerAddress]);\\r\\n\\r\\n        // withdraw all outstanding dividends first\\r\\n        if(myDividends(true) \\u003e 0) withdraw();\\r\\n\\r\\n        // liquify 10% of the tokens that are transferTokened\\r\\n        // these are dispersed to shareholders\\r\\n        uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\\r\\n        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\\r\\n        uint256 _dividends = tokensToEthereum_(_tokenFee);\\r\\n\\r\\n        // burn the fee tokens\\r\\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\\r\\n\\r\\n        // exchange tokens\\r\\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\\r\\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\\r\\n\\r\\n        // update dividend trackers\\r\\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\\r\\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\\r\\n\\r\\n        // disperse dividends among holders\\r\\n        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\\r\\n\\r\\n        // fire event\\r\\n        TransferToken(_customerAddress, _toAddress, _taxedTokens);\\r\\n\\r\\n        // ERC20\\r\\n        return true;\\r\\n\\r\\n    }\\r\\n\\r\\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\\r\\n    /**\\r\\n     * administrator can manually disable the ambassador phase.\\r\\n     */\\r\\n    function disableInitialStage()\\r\\n        onlyAdministrator()\\r\\n        public\\r\\n    {\\r\\n        onlyAmbassadors = false;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setAdministrator(address _identifier, bool _status)\\r\\n        onlyAdministrator()\\r\\n        public\\r\\n    {\\r\\n        administrators[_identifier] = _status;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setStakingRequirement(uint256 _amountOfTokens)\\r\\n        onlyAdministrator()\\r\\n        public\\r\\n    {\\r\\n        stakingRequirement = _amountOfTokens;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setName(string _name)\\r\\n        onlyAdministrator()\\r\\n        public\\r\\n    {\\r\\n        name = _name;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setSymbol(string _symbol)\\r\\n        onlyAdministrator()\\r\\n        public\\r\\n    {\\r\\n        symbol = _symbol;\\r\\n    }\\r\\n\\r\\n\\r\\n    /*----------  HELPERS AND CALCULATORS  ----------*/\\r\\n    /**\\r\\n     * Method to view the current Ethereum stored in the contract\\r\\n     * Example: totalEthereumBalance()\\r\\n     */\\r\\n    function totalEthereumBalance()\\r\\n        public\\r\\n        view\\r\\n        returns(uint)\\r\\n    {\\r\\n        return this.balance;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Retrieve the total token supply.\\r\\n     */\\r\\n    function totalSupply()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return tokenSupply_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Retrieve the tokens owned by the caller.\\r\\n     */\\r\\n    function myTokens()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        address _customerAddress = msg.sender;\\r\\n        return balanceOf(_customerAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Retrieve the dividends owned by the caller.\\r\\n       */\\r\\n    function myDividends(bool _includeReferralBonus)\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        address _customerAddress = msg.sender;\\r\\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Retrieve the token balance of any single address.\\r\\n     */\\r\\n    function balanceOf(address _customerAddress)\\r\\n        view\\r\\n        public\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return tokenBalanceLedger_[_customerAddress];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Retrieve the dividend balance of any single address.\\r\\n     */\\r\\n    function dividendsOf(address _customerAddress)\\r\\n        view\\r\\n        public\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Return the buy price of 1 individual token.\\r\\n     */\\r\\n    function sellPrice()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n\\r\\n        if(tokenSupply_ == 0){\\r\\n            return tokenPriceInitial_ - tokenPriceIncremental_;\\r\\n        } else {\\r\\n            uint256 _ethereum = tokensToEthereum_(1e18);\\r\\n            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );\\r\\n            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\\r\\n            return _taxedEthereum;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Return the sell price of 1 individual token.\\r\\n     */\\r\\n    function buyPrice()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n\\r\\n        if(tokenSupply_ == 0){\\r\\n            return tokenPriceInitial_ + tokenPriceIncremental_;\\r\\n        } else {\\r\\n            uint256 _ethereum = tokensToEthereum_(1e18);\\r\\n            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );\\r\\n            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\\r\\n            return _taxedEthereum;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function calculateTokensReceived(uint256 _ethereumToSpend)\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);\\r\\n        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\\r\\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\\r\\n\\r\\n        return _amountOfTokens;\\r\\n    }\\r\\n\\r\\n\\r\\n    function calculateEthereumReceived(uint256 _tokensToSell)\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        require(_tokensToSell \\u003c= tokenSupply_);\\r\\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\\r\\n        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\\r\\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\\r\\n        return _taxedEthereum;\\r\\n    }\\r\\n\\r\\n\\r\\n    /*==========================================\\r\\n    =            INTERNAL FUNCTIONS            =\\r\\n    ==========================================*/\\r\\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\\r\\n        antiEarlyWhale(_incomingEthereum)\\r\\n        internal\\r\\n        returns(uint256)\\r\\n    {\\r\\n        // data setup\\r\\n        address _customerAddress = msg.sender;\\r\\n        uint256 _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_);\\r\\n        uint256 _ownerDividend = SafeMath.div(SafeMath.mul(_incomingEthereum,3),100);\\r\\n        owner.transfer(_ownerDividend);\\r\\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\\r\\n        uint256 _dividends = SafeMath.sub(SafeMath.sub(_undividedDividends, _referralBonus),_ownerDividend);\\r\\n        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\\r\\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\\r\\n        uint256 _fee = _dividends * magnitude;\\r\\n\\r\\n\\r\\n        require(_amountOfTokens \\u003e 0 \\u0026\\u0026 (SafeMath.add(_amountOfTokens,tokenSupply_) \\u003e tokenSupply_));\\r\\n\\r\\n        // is the user referred by a karmalink?\\r\\n        if(\\r\\n            // is this a referred purchase?\\r\\n            _referredBy != 0x0000000000000000000000000000000000000000 \\u0026\\u0026\\r\\n\\r\\n            // no cheating!\\r\\n            _referredBy != _customerAddress \\u0026\\u0026\\r\\n\\r\\n\\r\\n            tokenBalanceLedger_[_referredBy] \\u003e= stakingRequirement\\r\\n        ){\\r\\n            // wealth redistribution\\r\\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\\r\\n        } else {\\r\\n            // no ref purchase\\r\\n            // add the referral bonus back to the global dividends cake\\r\\n            _dividends = SafeMath.add(_dividends, _referralBonus);\\r\\n            _fee = _dividends * magnitude;\\r\\n        }\\r\\n\\r\\n        // we can\\u0027t give people infinite ethereum\\r\\n        if(tokenSupply_ \\u003e 0){\\r\\n\\r\\n            // add tokens to the pool\\r\\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\\r\\n\\r\\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\\r\\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\\r\\n\\r\\n            // calculate the amount of tokens the customer receives over his purchase\\r\\n            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\\r\\n\\r\\n        } else {\\r\\n            // add tokens to the pool\\r\\n            tokenSupply_ = _amountOfTokens;\\r\\n        }\\r\\n\\r\\n        // update circulating supply \\u0026 the ledger address for the customer\\r\\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\\r\\n        // Check if new investor\\r\\n        if(investorExist[_customerAddress]==false){\\r\\n        investors.push(_customerAddress);\\r\\n        investorExist[_customerAddress] = true;}\\r\\n\\r\\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\\r\\n        payoutsTo_[_customerAddress] += _updatedPayouts;\\r\\n\\r\\n        // fire event\\r\\n        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens);\\r\\n\\r\\n        return _amountOfTokens;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate Token price based on an amount of incoming ethereum\\r\\n     * It\\u0027s an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\\r\\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\\r\\n     */\\r\\n    function ethereumToTokens_(uint256 _ethereum)\\r\\n        internal\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\\r\\n        uint256 _tokensReceived =\\r\\n         (\\r\\n            (\\r\\n                // underflow attempts BTFO\\r\\n                SafeMath.sub(\\r\\n                    (sqrt\\r\\n                        (\\r\\n                            (_tokenPriceInitial**2)\\r\\n                            +\\r\\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\\r\\n                            +\\r\\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\\r\\n                            +\\r\\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\\r\\n                        )\\r\\n                    ), _tokenPriceInitial\\r\\n                )\\r\\n            )/(tokenPriceIncremental_)\\r\\n        )-(tokenSupply_)\\r\\n        ;\\r\\n\\r\\n        return _tokensReceived;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate token sell value.\\r\\n          */\\r\\n     function tokensToEthereum_(uint256 _tokens)\\r\\n        internal\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n\\r\\n        uint256 tokens_ = (_tokens + 1e18);\\r\\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\\r\\n        uint256 _etherReceived =\\r\\n        (\\r\\n            // underflow attempts BTFO\\r\\n            SafeMath.sub(\\r\\n                (\\r\\n                    (\\r\\n                        (\\r\\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\\r\\n                        )-tokenPriceIncremental_\\r\\n                    )*(tokens_ - 1e18)\\r\\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\\r\\n            )\\r\\n        /1e18);\\r\\n        return _etherReceived;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function sqrt(uint x) internal pure returns (uint y) {\\r\\n        uint z = (x + 1) / 2;\\r\\n        y = x;\\r\\n        while (z \\u003c y) {\\r\\n            y = z;\\r\\n            z = (x / z + z) / 2;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a * b;\\r\\n        assert(c / a == b);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        assert(b \\u003c= a);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        assert(c \\u003e= a);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n/*\\r\\n  To the moon.\\r\\n*/\\r\\n\"},\"HyipForwarder.sol\":{\"content\":\"pragma solidity 0.4.20;\\n\\nimport \\u0027./hyip.sol\\u0027 ;\\n\\n/**\\n * \\n * HYIP DAPP POOL FORWARDER\\n * \\n**/\\ncontract HyipForwarder {\\n    \\n    // HYIP Contract address\\n    address hp = 0x4acdCD9Ad9D73235F104E52Df2BBfB8de61937Fc;\\n    \\n    // HYIP Moderator\\n    address moderator = 0xef280094dCdD73C0aF0B84AAe93ACFb8141a7931;\\n    \\n    function ()  public payable{\\n        \\n        HYIP_Dapp_pool hyip = HYIP_Dapp_pool(hp);\\n        \\n        hyip.sendEth.value(msg.value)();\\n    \\n        \\n    }\\n    \\n    function getBalance() external view returns(uint256){\\n        \\n        return address(this).balance;\\n    }\\n    \\n    //  Locked balance flus\\n    function flush() external {\\n        \\n        require(msg.sender == moderator);\\n        moderator.transfer(address(this).balance);\\n    \\n        \\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"flush\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"HyipForwarder","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://eb3cbf0d4729a7fa1539f66e602f39530ad8d4a20d32c4074cfd21ac34b57397"}]}