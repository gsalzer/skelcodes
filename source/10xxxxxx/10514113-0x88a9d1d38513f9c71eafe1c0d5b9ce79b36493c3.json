{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\r\n * @dev ERC-1155 interface for accepting safe transfers.\r\n */\ninterface IERC1155TokenReceiver {\r\n\r\n  /**\r\n   * @notice Handle the receipt of a single ERC1155 token type\r\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\r\n   * This function MAY throw to revert and reject the transfer\r\n   * Return of other amount than the magic value MUST result in the transaction being reverted\r\n   * Note: The token contract address is always the message sender\r\n   * @param _operator  The address which called the `safeTransferFrom` function\r\n   * @param _from      The address which previously owned the token\r\n   * @param _id        The id of the token being transferred\r\n   * @param _amount    The amount of tokens being transferred\r\n   * @param _data      Additional data with no specified format\r\n   * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n   */\r\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\r\n\r\n  /**\r\n   * @notice Handle the receipt of multiple ERC1155 token types\r\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\r\n   * This function MAY throw to revert and reject the transfer\r\n   * Return of other amount than the magic value WILL result in the transaction being reverted\r\n   * Note: The token contract address is always the message sender\r\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\r\n   * @param _from      The address which previously owned the token\r\n   * @param _ids       An array containing ids of each token being transferred\r\n   * @param _amounts   An array containing amounts of each token being transferred\r\n   * @param _data      Additional data with no specified format\r\n   * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n   */\r\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\r\n\r\n  /**\r\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\r\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\r\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\r\n   *      This function MUST NOT consume more than 5,000 gas.\r\n   * @return Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported.\r\n   */\r\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n\r\n}\n\nlibrary Strings {\r\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n  function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory) {\r\n      bytes memory _ba = bytes(_a);\r\n      bytes memory _bb = bytes(_b);\r\n      bytes memory _bc = bytes(_c);\r\n      bytes memory _bd = bytes(_d);\r\n      bytes memory _be = bytes(_e);\r\n      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n      bytes memory babcde = bytes(abcde);\r\n      uint k = 0;\r\n      for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n      for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n      for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n      for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n      for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n      return string(babcde);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\n\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\ninterface IERC165 {\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas\r\n     * @param _interfaceId The interface identifier, as specified in ERC-165\r\n     */\r\n    function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\n\ninterface ERC721Collection {\r\n    function issueToken(address _beneficiary, string calldata _wearableId) external;\r\n    function getWearableKey(string calldata _wearableId) external view returns (bytes32);\r\n    function issued(bytes32 _wearableKey) external view returns (uint256);\r\n    function maxIssuance(bytes32 _wearableKey) external view returns (uint256);\r\n    function issueTokens(address[] calldata _beneficiaries, bytes32[] calldata _wearableIds) external;\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\n\n/**\r\n * @title WearableCrafting\r\n * WearableCrafting - Receive ERC1155 voucher and mint ERC721 wearable\r\n */\ncontract WearableCrafting is IERC165, IERC1155TokenReceiver, Ownable {\r\n    using Strings for string;\r\n\r\n    ERC721Collection erc721WearableCollection;\r\n    address erc1155VouchersCollection;\r\n    mapping (uint256 => string) public wearableIds;\r\n\r\n    // onReceive function signatures\r\n    bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\r\n    bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\r\n\r\n    constructor(\r\n        address _vouchersCollection,\r\n        ERC721Collection _wearableCollection\r\n    ) public {\r\n        erc721WearableCollection = _wearableCollection;\r\n        erc1155VouchersCollection = _vouchersCollection;\r\n\r\n        wearableIds[64] = \"moonminer_helmet\";\r\n        wearableIds[65] = \"moonminer_goggles_eyewear\";\r\n        wearableIds[66] = \"moonminer_jacket_upper_body\";\r\n        wearableIds[67] = \"moonminer_pants_lower_body\";\r\n        wearableIds[68] = \"moonminer_boots_feet\";\r\n        wearableIds[69] = \"moonminer_neurahairs_hair\";\r\n    }\r\n\r\n    function mintWearables(address _beneficiary, uint256 _id, uint256 _amount) internal {\r\n        string memory wearableId = wearableIds[_id];\r\n        require(bytes(wearableId).length != 0, \"wearableId is not correct\");\r\n\r\n        for (uint256 i = 0; i < _amount; i++) {\r\n            erc721WearableCollection.issueToken(_beneficiary, wearableId);\r\n        }\r\n    }\r\n    /**\r\n     * @notice Handle the receipt of a single ERC1155 token type\r\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\r\n     * This function MAY throw to revert and reject the transfer\r\n     * Return of other amount than the magic value MUST result in the transaction being reverted\r\n     * Note: The token contract address is always the message sender\r\n     * param _operator  The address which called the `safeTransferFrom` function\r\n     * @param _from      The address which previously owned the token\r\n     * @param _id        The id of the token being transferred\r\n     * @param _amount    The amount of tokens being transferred\r\n     * param _data      Additional data with no specified format\r\n     * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     */\r\n    function onERC1155Received(address /*_operator*/, address _from, uint256 _id, uint256 _amount, bytes calldata /*_data*/) external returns(bytes4){\r\n        require(msg.sender == erc1155VouchersCollection, \"Only token contract allowed\");\r\n        mintWearables(_from, _id, _amount);\r\n        return ERC1155_RECEIVED_VALUE;\r\n    }\r\n\r\n    /**\r\n     * @notice Handle the receipt of multiple ERC1155 token types\r\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\r\n     * This function MAY throw to revert and reject the transfer\r\n     * Return of other amount than the magic value WILL result in the transaction being reverted\r\n     * Note: The token contract address is always the message sender\r\n     * param _operator  The address which called the `safeBatchTransferFrom` function\r\n     * @param _from      The address which previously owned the token\r\n     * @param _ids       An array containing ids of each token being transferred\r\n     * @param _amounts   An array containing amounts of each token being transferred\r\n     * param _data      Additional data with no specified format\r\n     * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     */\r\n    function onERC1155BatchReceived(address /*_operator*/, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata /*_data*/) external returns(bytes4){\r\n        require(msg.sender == erc1155VouchersCollection, \"Only token contract allowed\");\r\n        require(_ids.length == _amounts.length, \"Arrays must be same size\");\r\n\r\n        for (uint256 k = 0; k < _ids.length; k++) {\r\n            uint256 id = _ids[k];\r\n            uint256 amount = _amounts[k];\r\n            mintWearables(_from, id, amount);\r\n        }\r\n        return ERC1155_BATCH_RECEIVED_VALUE;\r\n    }\r\n\r\n    bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\r\n    bytes4 constant private INTERFACE_SIGNATURE_ERC1155TokenReceiver = 0x4fdcdb47;\r\n    /**\r\n     * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\r\n     * @param  _interfaceID The ERC-165 interface ID that is queried for support.s\r\n     * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\r\n     *      This function MUST NOT consume more than 5,000 gas.\r\n     * @return Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported.\r\n     */\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        if (_interfaceID == INTERFACE_SIGNATURE_ERC165 ||\r\n        _interfaceID == INTERFACE_SIGNATURE_ERC1155TokenReceiver) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setWearableCollection(\r\n        ERC721Collection _wearableCollection\r\n    ) public onlyOwner {\r\n        erc721WearableCollection = _wearableCollection;\r\n    }\r\n\r\n    function setWearableIds(\r\n        uint256 _voucherId,\r\n        string memory _wearableId\r\n    ) public onlyOwner {\r\n        wearableIds[_voucherId] = _wearableId;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vouchersCollection\",\"type\":\"address\"},{\"internalType\":\"contract ERC721Collection\",\"name\":\"_wearableCollection\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC721Collection\",\"name\":\"_wearableCollection\",\"type\":\"address\"}],\"name\":\"setWearableCollection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voucherId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_wearableId\",\"type\":\"string\"}],\"name\":\"setWearableIds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wearableIds\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WearableCrafting","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d997fe65d5f4259840a220e39b1e9a33b645459b0000000000000000000000001e1d4e6262787c8a8783a37fee698bd42aa42bec","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}