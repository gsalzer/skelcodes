{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\thirdParty\\interfaces\\IERC1820Registry.sol\r\n\r\n// From open https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/introspection/IERC1820Registry.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     *  @param account Address of the contract for which to update the cache.\r\n     *  @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\r\n     *  If the result is not cached a direct lookup on the contract address is performed.\r\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     *  {updateERC165Cache} with the contract address.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC777Sender.sol\r\n\r\npragma solidity 0.6.7;\r\n\r\n// As defined in the 'ERC777TokensSender And The tokensToSend Hook' section of https://eips.ethereum.org/EIPS/eip-777\r\ninterface IERC777Sender {\r\n  function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata data,\r\n      bytes calldata operatorData) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC777Recipient.sol\r\n\r\npragma solidity 0.6.7;\r\n\r\n// As defined in the 'ERC777TokensRecipient And The tokensReceived Hook' section of https://eips.ethereum.org/EIPS/eip-777\r\ninterface IERC777Recipient {\r\n  function tokensReceived(address operator, address from, address to, uint256 amount, bytes calldata data,\r\n      bytes calldata operatorData) external;\r\n}\r\n\r\n// File: contracts\\thirdParty\\SafeMath.sol\r\n\r\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\libraries\\LToken.sol\r\n\r\npragma solidity 0.6.7;\r\n\r\n\r\n\r\n\r\n\r\nstruct TokenState {\r\n  uint256 totalSupply;\r\n  mapping(address => uint256) balances;\r\n  mapping(address => mapping(address => uint256)) approvals;\r\n  mapping(address => mapping(address => bool)) authorizedOperators;\r\n  address[] defaultOperators;\r\n  mapping(address => bool) defaultOperatorIsRevoked;\r\n  mapping(address => bool) minters;\r\n}\r\n\r\nlibrary LToken {\r\n  using SafeMath for uint256;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Sent(address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data,\r\n      bytes operatorData);\r\n  event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n  event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n  event AuthorizedOperator(address indexed operator, address indexed holder);\r\n  event RevokedOperator(address indexed operator, address indexed holder);\r\n\r\n  // Universal address as defined in Registry Contract Address section of https://eips.ethereum.org/EIPS/eip-1820\r\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n  // precalculated hashes - see https://github.com/ethereum/solidity/issues/4024\r\n  // keccak256(\"ERC777TokensSender\")\r\n  bytes32 constant internal ERC777_TOKENS_SENDER_HASH = 0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\r\n  // keccak256(\"ERC777TokensRecipient\")\r\n  bytes32 constant internal ERC777_TOKENS_RECIPIENT_HASH = 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\r\n\r\n  modifier checkSenderNotOperator(address _operator) {\r\n    require(_operator != msg.sender, \"Cannot be operator for self\");\r\n    _;\r\n  }\r\n\r\n  function initState(TokenState storage _tokenState, uint8 _decimals, uint256 _initialSupply)\r\n    external\r\n  {\r\n    _tokenState.defaultOperators.push(address(this));\r\n    _tokenState.totalSupply = _initialSupply.mul(10**uint256(_decimals));\r\n    _tokenState.balances[msg.sender] = _tokenState.totalSupply;\r\n  }\r\n\r\n  function transferFrom(TokenState storage _tokenState, address _from, address _to, uint256 _value)\r\n    external\r\n  {\r\n    _tokenState.approvals[_from][msg.sender] = _tokenState.approvals[_from][msg.sender].sub(_value, \"Amount not approved\");\r\n    doSend(_tokenState, msg.sender, _from, _to, _value, \"\", \"\", false);\r\n  }\r\n\r\n  function approve(TokenState storage _tokenState, address _spender, uint256 _value)\r\n    external\r\n  {\r\n    require(_spender != address(0), \"Cannot approve to zero address\");\r\n    _tokenState.approvals[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  function authorizeOperator(TokenState storage _tokenState, address _operator)\r\n    checkSenderNotOperator(_operator)\r\n    external\r\n  {\r\n    if (_operator == address(this))\r\n      _tokenState.defaultOperatorIsRevoked[msg.sender] = false;\r\n    else\r\n      _tokenState.authorizedOperators[_operator][msg.sender] = true;\r\n    emit AuthorizedOperator(_operator, msg.sender);\r\n  }\r\n\r\n  function revokeOperator(TokenState storage _tokenState, address _operator)\r\n    checkSenderNotOperator(_operator)\r\n    external\r\n  {\r\n    if (_operator == address(this))\r\n      _tokenState.defaultOperatorIsRevoked[msg.sender] = true;\r\n    else\r\n      _tokenState.authorizedOperators[_operator][msg.sender] = false;\r\n    emit RevokedOperator(_operator, msg.sender);\r\n  }\r\n\r\n  function authorizeMinter(TokenState storage _tokenState, address _minter)\r\n    external\r\n  {\r\n    _tokenState.minters[_minter] = true;\r\n  }\r\n\r\n  function revokeMinter(TokenState storage _tokenState, address _minter)\r\n    external\r\n  {\r\n    _tokenState.minters[_minter] = false;\r\n  }\r\n\r\n  function doMint(TokenState storage _tokenState, address _to, uint256 _amount)\r\n    external\r\n  {\r\n    assert(_to != address(0));\r\n\r\n    _tokenState.totalSupply = _tokenState.totalSupply.add(_amount);\r\n    _tokenState.balances[_to] = _tokenState.balances[_to].add(_amount);\r\n\r\n    // From ERC777: The token contract MUST call the tokensReceived hook after updating the state.\r\n    receiveHook(address(this), address(0), _to, _amount, \"\", \"\", true);\r\n\r\n    emit Minted(address(this), _to, _amount, \"\", \"\");\r\n    emit Transfer(address(0), _to, _amount);\r\n  }\r\n\r\n  function doBurn(TokenState storage _tokenState, address _operator, address _from, uint256 _amount, bytes calldata _data,\r\n      bytes calldata _operatorData)\r\n    external\r\n  {\r\n    assert(_from != address(0));\r\n    // From ERC777: The token contract MUST call the tokensToSend hook before updating the state.\r\n    sendHook(_operator, _from, address(0), _amount, _data, _operatorData);\r\n\r\n    _tokenState.balances[_from] = _tokenState.balances[_from].sub(_amount, \"Cannot burn more than balance\");\r\n    _tokenState.totalSupply = _tokenState.totalSupply.sub(_amount);\r\n\r\n    emit Burned(_operator, _from, _amount, _data, _operatorData);\r\n    emit Transfer(_from, address(0), _amount);\r\n  }\r\n\r\n  function doSend(TokenState storage _tokenState, address _operator, address _from, address _to, uint256 _amount,\r\n      bytes memory _data, bytes memory _operatorData, bool _enforceERC777)\r\n    public\r\n  {\r\n    assert(_from != address(0));\r\n\r\n    require(_to != address(0), \"Cannot send funds to 0 address\");\r\n    // From ERC777: The token contract MUST call the tokensToSend hook before updating the state.\r\n    sendHook(_operator, _from, _to, _amount, _data, _operatorData);\r\n\r\n    _tokenState.balances[_from] = _tokenState.balances[_from].sub(_amount, \"Amount exceeds available funds\");\r\n    _tokenState.balances[_to] = _tokenState.balances[_to].add(_amount);\r\n\r\n    emit Sent(_operator, _from, _to, _amount, _data, _operatorData);\r\n    emit Transfer(_from, _to, _amount);\r\n\r\n    // From ERC777: The token contract MUST call the tokensReceived hook after updating the state.\r\n    receiveHook(_operator, _from, _to, _amount, _data, _operatorData, _enforceERC777);\r\n  }\r\n\r\n  function receiveHook(address _operator, address _from, address _to, uint256 _amount, bytes memory _data,\r\n      bytes memory _operatorData, bool _enforceERC777)\r\n    public\r\n  {\r\n    address implementer = ERC1820_REGISTRY.getInterfaceImplementer(_to, ERC777_TOKENS_RECIPIENT_HASH);\r\n    if (implementer != address(0))\r\n      IERC777Recipient(implementer).tokensReceived(_operator, _from, _to, _amount, _data, _operatorData);\r\n    else if (_enforceERC777)\r\n      require(!isContract(_to), \"Must be registered with ERC1820\");\r\n  }\r\n\r\n  function sendHook(address _operator, address _from, address _to, uint256 _amount, bytes memory _data,\r\n      bytes memory _operatorData)\r\n    public\r\n  {\r\n    address implementer = ERC1820_REGISTRY.getInterfaceImplementer(_from, ERC777_TOKENS_SENDER_HASH);\r\n    if (implementer != address(0))\r\n      IERC777Sender(implementer).tokensToSend(_operator, _from, _to, _amount, _data, _operatorData);\r\n  }\r\n\r\n  function isContract(address _account)\r\n    private\r\n    view\r\n    returns (bool isContract_)\r\n  {\r\n    uint256 size;\r\n\r\n    assembly {\r\n      size := extcodesize(_account)\r\n    }\r\n\r\n    isContract_ = size != 0;\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"LToken","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"petersburg","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5b1bc9e7c526dd6814ae06bf1421b5e5b7b06e5ca3918259e44f1bc8e5be34a5"}]}