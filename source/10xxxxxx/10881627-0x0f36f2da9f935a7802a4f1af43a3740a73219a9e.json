{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.12; // optimization runs: 200, evm version: istanbul\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface DharmaTradeBotV1Interface {\r\n  event LimitOrderProcessed(\r\n    address indexed account,\r\n    address indexed suppliedAsset, // Ether = address(0)\r\n    address indexed receivedAsset, // Ether = address(0)\r\n    uint256 suppliedAmount,\r\n    uint256 receivedAmount,\r\n    bytes32 orderID\r\n  );\r\n\r\n  event LimitOrderCancelled(bytes32 orderID);\r\n  event RoleModified(Role indexed role, address account);\r\n  event RolePaused(Role indexed role);\r\n  event RoleUnpaused(Role indexed role);\r\n\r\n  enum Role {\r\n    BOT_COMMANDER,\r\n    CANCELLER,\r\n    PAUSER\r\n  }\r\n\r\n  struct RoleStatus {\r\n    address account;\r\n    bool paused;\r\n  }\r\n\r\n  struct LimitOrderArguments {\r\n    address account;\r\n    address assetToSupply;        // Ether = address(0)\r\n    address assetToReceive;       // Ether = address(0)\r\n    uint256 maximumAmountToSupply;\r\n    uint256 maximumPriceToAccept; // represented as a mantissa (n * 10^18)\r\n    uint256 expiration;\r\n    bytes32 salt;\r\n  }\r\n\r\n  struct LimitOrderExecutionArguments {\r\n    uint256 amountToSupply; // will be lower than maximum for partial fills\r\n    bytes signatures;\r\n    address tradeTarget;\r\n    bytes tradeData;\r\n  }\r\n\r\n  function processLimitOrder(\r\n    LimitOrderArguments calldata args,\r\n    LimitOrderExecutionArguments calldata executionArgs\r\n  ) external returns (uint256 amountReceived);\r\n\r\n  function cancelLimitOrder(LimitOrderArguments calldata args) external;\r\n\r\n  function setRole(Role role, address account) external;\r\n\r\n  function removeRole(Role role) external;\r\n\r\n  function pause(Role role) external;\r\n\r\n  function unpause(Role role) external;\r\n\r\n  function isPaused(Role role) external view returns (bool paused);\r\n\r\n  function isRole(Role role) external view returns (bool hasRole);\r\n  \r\n  function getOrderID(\r\n    LimitOrderArguments calldata args\r\n  ) external view returns (bytes32 orderID, bool valid);\r\n\r\n  function getBotCommander() external view returns (address botCommander);\r\n  \r\n  function getCanceller() external view returns (address canceller);\r\n\r\n  function getPauser() external view returns (address pauser);\r\n}\r\n\r\n\r\ninterface SupportingContractInterface {\r\n  function setApproval(address token, uint256 amount) external;\r\n}\r\n\r\n\r\ninterface ERC1271Interface {\r\n  function isValidSignature(\r\n    bytes calldata data, bytes calldata signatures\r\n  ) external view returns (bytes4 magicValue);\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n  function transfer(address, uint256) external returns (bool);\r\n  function transferFrom(address, address, uint256) external returns (bool);\r\n  function approve(address, uint256) external returns (bool);\r\n  function balanceOf(address) external view returns (uint256);\r\n  function allowance(address, address) external view returns (uint256);\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n\r\n    return a - b;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    return a / b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @notice Contract module which provides a basic access control mechanism,\r\n * where there is an account (an owner) that can be granted exclusive access\r\n * to specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n *\r\n * In order to transfer ownership, a recipient must be specified, at which point\r\n * the specified recipient can call `acceptOwnership` and take ownership.\r\n */\r\ncontract TwoStepOwnable {\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  address private _owner;\r\n\r\n  address private _newPotentialOwner;\r\n\r\n  /**\r\n   * @notice Initialize contract with transaction submitter as initial owner.\r\n   */\r\n  constructor() internal {\r\n    _owner = tx.origin;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows a new account (`newOwner`) to accept ownership.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    require(\r\n      newOwner != address(0),\r\n      \"TwoStepOwnable: new potential owner is the zero address.\"\r\n    );\r\n\r\n    _newPotentialOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @notice Cancel a transfer of ownership to a new account.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function cancelOwnershipTransfer() external onlyOwner {\r\n    delete _newPotentialOwner;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers ownership of the contract to the caller.\r\n   * Can only be called by a new potential owner set by the current owner.\r\n   */\r\n  function acceptOwnership() external {\r\n    require(\r\n      msg.sender == _newPotentialOwner,\r\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\r\n    );\r\n\r\n    delete _newPotentialOwner;\r\n\r\n    emit OwnershipTransferred(_owner, msg.sender);\r\n\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the current owner.\r\n   */\r\n  function owner() external view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaTradeBotV1Staging\r\n * @author 0age\r\n * @notice DharmaTradeBot is a contract for performing meta-transaction-enabled\r\n * limit orders against external automated money markets or other sources of\r\n * on-chain liquidity. Eth-to-Token trades require that `triggerEtherTransfer`\r\n * is implemented on the account making the trade, and all trades require\r\n * that the account implements `isValidSignature` as specified by ERC-1271,\r\n * as well as a `setApproval` function, in order to enable meta-transactions.\r\n * For Eth-to-token trades, the Eth amount is forwarded as part of the trade.\r\n */\r\ncontract DharmaTradeBotV1Staging is DharmaTradeBotV1Interface, TwoStepOwnable {\r\n  using SafeMath for uint256;\r\n\r\n  // Maintain a role status mapping with assigned accounts and paused states.\r\n  mapping(uint256 => RoleStatus) private _roles;\r\n\r\n  // Maintain a mapping of invalid meta-transaction order IDs.\r\n  mapping (bytes32 => bool) private _invalidMetaTxHashes;\r\n\r\n  ERC20Interface private constant _ETHERIZER = ERC20Interface(\r\n    0x723B51b72Ae89A3d0c2a2760f0458307a1Baa191\r\n  );\r\n  \r\n  bool public constant staging = true;\r\n\r\n  receive() external payable {}\r\n\r\n  /**\r\n   * @notice Only callable by the bot commander or the owner. Enforces the\r\n   * expiration (or skips if it is set to zero) and trade size, validates\r\n   * the execution signatures using ERC-1271 against the account, sets\r\n   * approval to transfer the supplied token on behalf of that account,\r\n   * pulls in the necessary supplied tokens, sets an allowance for the\r\n   * provided trade target, calls the trade target with supplied data,\r\n   * ensures that the call was successful, calculates the required amount\r\n   * that must be received back based on the supplied amount and price,\r\n   * ensures that at least that amount was returned, sends it to the\r\n   * account, and emits an event. Use the null address to signify that\r\n   * the supplied or retained asset is Ether.\r\n   * @return amountReceived The amount received back from the trade.\r\n   */\r\n  function processLimitOrder(\r\n    LimitOrderArguments calldata args,\r\n    LimitOrderExecutionArguments calldata executionArgs\r\n  ) external override onlyOwnerOr(Role.BOT_COMMANDER) returns (\r\n    uint256 amountReceived\r\n  ) {\r\n    _enforceExpiration(args.expiration);\r\n\r\n    require(\r\n      executionArgs.amountToSupply <= args.maximumAmountToSupply,\r\n      \"Cannot supply more than the maximum authorized amount.\"\r\n    );\r\n    \r\n    require(\r\n      args.assetToSupply != args.assetToReceive,\r\n      \"Asset to supply and asset to receive cannot be identical.\"\r\n    );\r\n\r\n    if (executionArgs.tradeData.length >= 4) {\r\n      require(\r\n        abi.decode(\r\n          abi.encodePacked(executionArgs.tradeData[:4], bytes28(0)), (bytes4)\r\n        ) != SupportingContractInterface.setApproval.selector,\r\n        \"Trade data has a prohibited function selector.\"\r\n      );\r\n    }\r\n\r\n    // Construct order's \"context\" and use it to validate meta-transaction.\r\n    bytes memory context = _constructLimitOrderContext(args);\r\n    bytes32 orderID = _validateMetaTransaction(\r\n      args.account, context, executionArgs.signatures\r\n    );\r\n\r\n    // Determine asset supplied (use Etherizer for Ether) and ether value.\r\n    ERC20Interface assetToSupply;\r\n    uint256 etherValue;\r\n    \r\n    if (args.assetToSupply == address(0)) {\r\n      assetToSupply = _ETHERIZER;\r\n      etherValue = executionArgs.amountToSupply;\r\n    } else {\r\n      assetToSupply = ERC20Interface(args.assetToSupply);\r\n      etherValue = 0;\r\n\r\n      // Ensure that target has allowance to transfer tokens.\r\n      _grantApprovalIfNecessary(\r\n        assetToSupply, executionArgs.tradeTarget, executionArgs.amountToSupply\r\n      );\r\n    }\r\n\r\n    // Call `setApproval` on the supplying account.\r\n    SupportingContractInterface(args.account).setApproval(\r\n      address(assetToSupply), executionArgs.amountToSupply\r\n    );\r\n\r\n    // Make the transfer in.\r\n    _transferInToken(\r\n      assetToSupply, args.account, executionArgs.amountToSupply\r\n    );\r\n\r\n    // Call into target, supplying data and value, and revert on failure.\r\n    _performCallToTradeTarget(\r\n      executionArgs.tradeTarget, executionArgs.tradeData, etherValue\r\n    );\r\n\r\n    // Determine amount expected back using supplied amount and price.\r\n    uint256 amountExpected = (\r\n      executionArgs.amountToSupply.mul(1e18)\r\n    ).div(\r\n      args.maximumPriceToAccept\r\n    );\r\n \r\n    if (args.assetToReceive == address(0)) {\r\n      // Determine ether balance held by this contract.\r\n      amountReceived = address(this).balance;  \r\n      \r\n      // Ensure that enough Ether was received.\r\n      require(\r\n        amountReceived >= amountExpected,\r\n        \"Trade did not result in the expected amount of Ether.\"\r\n      );\r\n      \r\n      // Transfer the Ether out and revert on failure.\r\n      _transferEther(args.account, amountReceived);\r\n    } else {\r\n      ERC20Interface assetToReceive = ERC20Interface(args.assetToReceive);\r\n\r\n      // Determine balance of received tokens held by this contract.\r\n      amountReceived = assetToReceive.balanceOf(address(this));\r\n      \r\n      // Ensure that enough tokens were received.\r\n      require(\r\n        amountReceived >= amountExpected,\r\n        \"Trade did not result in the expected amount of tokens.\"\r\n      );\r\n\r\n      // Transfer the tokens and revert on failure.\r\n      _transferOutToken(assetToReceive, args.account, amountReceived);\r\n    }\r\n\r\n    emit LimitOrderProcessed(\r\n      args.account,\r\n      args.assetToSupply,\r\n      args.assetToReceive,\r\n      executionArgs.amountToSupply,\r\n      amountReceived,\r\n      orderID\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Cancels a potential limit order. Only the owner, the account\r\n   * in question, or the canceller role may call this function.\r\n   */\r\n  function cancelLimitOrder(\r\n    LimitOrderArguments calldata args\r\n  ) external override onlyOwnerOrAccountOr(Role.CANCELLER, args.account) {\r\n    _enforceExpiration(args.expiration);\r\n\r\n    // Construct the order ID using relevant \"context\" of the limit order.\r\n    bytes32 orderID = keccak256(_constructLimitOrderContext(args));\r\n\r\n    // Ensure the order ID has not been used or cancelled and invalidate it.\r\n    require(\r\n      !_invalidMetaTxHashes[orderID], \"Meta-transaction already invalid.\"\r\n    );\r\n    _invalidMetaTxHashes[orderID] = true;\r\n    \r\n    emit LimitOrderCancelled(orderID);\r\n  }\r\n\r\n  /**\r\n   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\r\n   * the owner or the designated pauser may call this function. Also, bear in\r\n   * mind that only the owner may unpause a role once paused.\r\n   * @param role The role to pause.\r\n   */\r\n  function pause(Role role) external override onlyOwnerOr(Role.PAUSER) {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n    require(!storedRoleStatus.paused, \"Role in question is already paused.\");\r\n    storedRoleStatus.paused = true;\r\n    emit RolePaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\r\n   * Only the owner may call this function.\r\n   * @param role The role to pause.\r\n   */\r\n  function unpause(Role role) external override onlyOwner {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n    require(storedRoleStatus.paused, \"Role in question is already unpaused.\");\r\n    storedRoleStatus.paused = false;\r\n    emit RoleUnpaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new account on a given role and emit a `RoleModified` event\r\n   * if the role holder has changed. Only the owner may call this function.\r\n   * @param role The role that the account will be set for.\r\n   * @param account The account to set as the designated role bearer.\r\n   */\r\n  function setRole(Role role, address account) external override onlyOwner {\r\n    require(account != address(0), \"Must supply an account.\");\r\n    _setRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove any current role bearer for a given role and emit a\r\n   * `RoleModified` event if a role holder was previously set. Only the owner\r\n   * may call this function.\r\n   * @param role The role that the account will be removed from.\r\n   */\r\n  function removeRole(Role role) external override onlyOwner {\r\n    _setRole(role, address(0));\r\n  }\r\n\r\n  /**\r\n   * @notice View function to determine an order's meta-transaction message hash\r\n   * and to determine if it is still valid (i.e. it has not yet been used and is\r\n   * not expired). The returned order ID will need to be prefixed using EIP-191\r\n   * 0x45 and hashed again in order to generate a final digest for the required\r\n   * signature - in other words, the same procedure utilized by `eth_Sign`.\r\n   * @return orderID The ID corresponding to the limit order's meta-transaction.\r\n   */\r\n  function getOrderID(\r\n    LimitOrderArguments calldata args\r\n  ) external view override returns (bytes32 orderID, bool valid) {\r\n    // Construct the order ID based on relevant context.\r\n    orderID = keccak256(_constructLimitOrderContext(args));\r\n\r\n    // The meta-transaction is valid if it has not been used and is not expired.\r\n    valid = (\r\n      !_invalidMetaTxHashes[orderID] && (\r\n        args.expiration == 0 || block.timestamp <= args.expiration\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether or not the functionality\r\n   * associated with a given role is currently paused or not. The owner or the\r\n   * pauser may pause any given role (including the pauser itself), but only the\r\n   * owner may unpause functionality. Additionally, the owner may call paused\r\n   * functions directly.\r\n   * @param role The role to check the pause status on.\r\n   * @return paused A boolean to indicate if the functionality associated with\r\n   * the role in question is currently paused.\r\n   */\r\n  function isPaused(Role role) external view override returns (bool paused) {\r\n    paused = _isPaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether the caller is the current\r\n   * role holder.\r\n   * @param role The role to check for.\r\n   * @return hasRole A boolean indicating if the caller has the specified role.\r\n   */\r\n  function isRole(Role role) external view override returns (bool hasRole) {\r\n    hasRole = _isRole(role);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * bot commander role. The bot commander can execute limit orders.\r\n   * @return botCommander The address of the current bot commander, or the null\r\n   * address if none is set.\r\n   */\r\n  function getBotCommander() external view override returns (\r\n    address botCommander\r\n  ) {\r\n    botCommander = _roles[uint256(Role.BOT_COMMANDER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * canceller role. The canceller can cancel limit orders.\r\n   * @return canceller The address of the current canceller, or the null\r\n   * address if none is set.\r\n   */\r\n  function getCanceller() external view override returns (\r\n    address canceller\r\n  ) {\r\n    canceller = _roles[uint256(Role.CANCELLER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * pauser role. The pauser can pause any role from taking its standard action,\r\n   * though the owner will still be able to call the associated function in the\r\n   * interim and is the only entity able to unpause the given role once paused.\r\n   * @return pauser The address of the current pauser, or the null address if\r\n   * none is set.\r\n   */\r\n  function getPauser() external view override returns (address pauser) {\r\n    pauser = _roles[uint256(Role.PAUSER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to enforce that a given meta-transaction\r\n   * has not been used before and that the signature is valid according\r\n   * to the account in question (using ERC-1271).\r\n   * @param account address The account originating the meta-transaction.\r\n   * @param context bytes Information about the meta-transaction.\r\n   * @param signatures bytes Signature or signatures used to validate\r\n   * the meta-transaction.\r\n   */\r\n  function _validateMetaTransaction(\r\n    address account, bytes memory context, bytes memory signatures\r\n  ) private returns (bytes32 orderID) {\r\n    // Construct the order ID using the provided context.\r\n    orderID = keccak256(context);\r\n\r\n    // Ensure ID has not been used or cancelled and invalidate it.\r\n    require(\r\n      !_invalidMetaTxHashes[orderID], \"Order is no longer valid.\"\r\n    );\r\n    _invalidMetaTxHashes[orderID] = true;\r\n\r\n    // Construct the digest to compare signatures against using EIP-191 0x45.\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", orderID)\r\n    );\r\n\r\n    // Validate via ERC-1271 against the specified account.\r\n    bytes memory data = abi.encode(digest, context);\r\n    bytes4 magic = ERC1271Interface(account).isValidSignature(data, signatures);\r\n    require(magic == bytes4(0x20c13b0b), \"Invalid signatures.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to set a new account on a given role and emit a\r\n   * `RoleModified` event if the role holder has changed.\r\n   * @param role The role that the account will be set for.\r\n   * @param account The account to set as the designated role bearer.\r\n   */\r\n  function _setRole(Role role, address account) private {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n\r\n    if (account != storedRoleStatus.account) {\r\n      storedRoleStatus.account = account;\r\n      emit RoleModified(role, account);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to perform a call to a given trade target, supplying\r\n   * given data and value, and revert with reason on failure.\r\n   */\r\n  function _performCallToTradeTarget(\r\n    address target, bytes memory data, uint256 etherValue\r\n  ) private {\r\n    // Call into the provided target, supplying provided data.\r\n    (bool tradeTargetCallSuccess,) = target.call{value: etherValue}(data);\r\n\r\n    // Revert with reason if the call was not successful.\r\n    if (!tradeTargetCallSuccess) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    } else {\r\n      // Ensure that the target is a contract.\r\n      uint256 returnSize;\r\n      assembly { returnSize := returndatasize() }\r\n      if (returnSize == 0) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(target) }\r\n        require(size > 0, \"Specified target does not have contract code.\");\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to set approval for a given target to transfer tokens\r\n   * on behalf of this contract. It should generally be assumed that this contract\r\n   * is highly permissive when it comes to approvals.\r\n   */\r\n  function _grantApprovalIfNecessary(\r\n    ERC20Interface token, address target, uint256 amount\r\n  ) private {\r\n    if (token.allowance(address(this), target) < amount) {\r\n      // Try removing approval first as a workaround for unusual tokens.\r\n      (bool success, bytes memory returnData) = address(token).call(\r\n        abi.encodeWithSelector(\r\n          token.approve.selector, target, uint256(0)\r\n        )\r\n      );\r\n\r\n      // Grant approval to transfer tokens on behalf of this contract.\r\n      (success, returnData) = address(token).call(\r\n        abi.encodeWithSelector(\r\n          token.approve.selector, target, type(uint256).max\r\n        )\r\n      );\r\n\r\n      if (!success) {\r\n        // Some really janky tokens only allow setting approval up to current balance.\r\n        (success, returnData) = address(token).call(\r\n          abi.encodeWithSelector(\r\n            token.approve.selector, target, amount\r\n          )\r\n        );\r\n      }\r\n\r\n      require(\r\n        success && (returnData.length == 0 || abi.decode(returnData, (bool))),\r\n        \"Token approval to trade against the target failed.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to transfer tokens out of this contract.\r\n   */\r\n  function _transferOutToken(ERC20Interface token, address to, uint256 amount) private {\r\n    (bool success, bytes memory returnData) = address(token).call(\r\n      abi.encodeWithSelector(token.transfer.selector, to, amount)\r\n    );\r\n\r\n    if (!success) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n    \r\n    if (returnData.length == 0) {\r\n      uint256 size;\r\n      assembly { size := extcodesize(token) }\r\n      require(size > 0, \"Token specified to transfer out does not have contract code.\");\r\n    } else {\r\n      require(abi.decode(returnData, (bool)), 'Token transfer out failed.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to transfer Ether out of this contract.\r\n   */\r\n  function _transferEther(address recipient, uint256 etherAmount) private {\r\n    // Send Ether to recipient and revert with reason on failure.\r\n    (bool ok, ) = recipient.call{value: etherAmount}(\"\");\r\n    if (!ok) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to transfer tokens into this contract.\r\n   */\r\n  function _transferInToken(ERC20Interface token, address from, uint256 amount) private {\r\n    (bool success, bytes memory returnData) = address(token).call(\r\n      abi.encodeWithSelector(token.transferFrom.selector, from, address(this), amount)\r\n    );\r\n\r\n    if (!success) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n    \r\n    if (returnData.length == 0) {\r\n      uint256 size;\r\n      assembly { size := extcodesize(token) }\r\n      require(size > 0, \"Token specified to transfer in does not have contract code.\");\r\n    } else {\r\n      require(abi.decode(returnData, (bool)), 'Token transfer in failed.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to check whether the caller is the current\r\n   * role holder.\r\n   * @param role The role to check for.\r\n   * @return hasRole A boolean indicating if the caller has the specified role.\r\n   */\r\n  function _isRole(Role role) private view returns (bool hasRole) {\r\n    hasRole = msg.sender == _roles[uint256(role)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to check whether the given role is paused or\r\n   * not.\r\n   * @param role The role to check for.\r\n   * @return paused A boolean indicating if the specified role is paused or not.\r\n   */\r\n  function _isPaused(Role role) private view returns (bool paused) {\r\n    paused = _roles[uint256(role)].paused;\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to construct the \"context\" or details that\r\n   * need to be included when generating the order ID.\r\n   * @return context bytes The context.\r\n   */\r\n  function _constructLimitOrderContext(\r\n    LimitOrderArguments memory args\r\n  ) private view returns (bytes memory context) {\r\n    context = abi.encode(\r\n      address(this),\r\n      args.account,\r\n      args.assetToSupply,\r\n      args.assetToReceive,\r\n      args.maximumAmountToSupply,\r\n      args.maximumPriceToAccept,\r\n      args.expiration,\r\n      args.salt\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to ensure that a given expiration has\r\n   * not elapsed, or is set to zero (signifying no expiration).\r\n   */\r\n  function _enforceExpiration(uint256 expiration) private view {\r\n    require(\r\n      expiration == 0 || block.timestamp <= expiration,\r\n      \"Order has expired.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier that throws if called by any account other than the owner\r\n   * or the supplied role, or if the caller is not the owner and the role in\r\n   * question is paused.\r\n   * @param role The role to require unless the caller is the owner. Permitted\r\n   * roles are bot commander (0), and canceller (1), and pauser (2).\r\n   */\r\n  modifier onlyOwnerOr(Role role) {\r\n    if (!isOwner()) {\r\n      require(_isRole(role), \"Caller does not have a required role.\");\r\n      require(!_isPaused(role), \"Role in question is currently paused.\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier that throws if called by any account other than the owner,\r\n   * a specified account, or the supplied role, or if the caller is not the\r\n   * owner or the specified account and the role in question is paused.\r\n   * @param role The role to require unless the caller is the owner or the\r\n   * specified account. Permitted roles are bot commander (0), and canceller (1),\r\n   * and pauser (2).\r\n   */\r\n  modifier onlyOwnerOrAccountOr(Role role, address account) {\r\n    if (!isOwner() && !(msg.sender == account)) {\r\n      require(_isRole(role), \"Caller does not have a required role.\");\r\n      require(!_isPaused(role), \"Role in question is currently paused.\");\r\n    }\r\n    _;\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderID\",\"type\":\"bytes32\"}],\"name\":\"LimitOrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"suppliedAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receivedAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"suppliedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderID\",\"type\":\"bytes32\"}],\"name\":\"LimitOrderProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DharmaTradeBotV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RoleModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DharmaTradeBotV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"RolePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DharmaTradeBotV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"RoleUnpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToSupply\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToReceive\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumAmountToSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumPriceToAccept\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"internalType\":\"struct DharmaTradeBotV1Interface.LimitOrderArguments\",\"name\":\"args\",\"type\":\"tuple\"}],\"name\":\"cancelLimitOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBotCommander\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"botCommander\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCanceller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"canceller\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToSupply\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToReceive\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumAmountToSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumPriceToAccept\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"internalType\":\"struct DharmaTradeBotV1Interface.LimitOrderArguments\",\"name\":\"args\",\"type\":\"tuple\"}],\"name\":\"getOrderID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderID\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pauser\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DharmaTradeBotV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DharmaTradeBotV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"isRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasRole\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DharmaTradeBotV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToSupply\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToReceive\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumAmountToSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumPriceToAccept\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"internalType\":\"struct DharmaTradeBotV1Interface.LimitOrderArguments\",\"name\":\"args\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountToSupply\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"tradeTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct DharmaTradeBotV1Interface.LimitOrderExecutionArguments\",\"name\":\"executionArgs\",\"type\":\"tuple\"}],\"name\":\"processLimitOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DharmaTradeBotV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"removeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DharmaTradeBotV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staging\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DharmaTradeBotV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DharmaTradeBotV1Staging","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://09e7b5ce5f72529264f324d73ddcd86de78abea1db0c8c84c647d497b32b35d5"}]}