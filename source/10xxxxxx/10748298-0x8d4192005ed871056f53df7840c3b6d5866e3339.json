{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract LockIdGen {\r\n\r\n    uint256 public requestCount;\r\n\r\n    constructor() public {\r\n        requestCount = 0;\r\n    }\r\n\r\n    function generateLockId() internal returns (bytes32 lockId) {\r\n        return keccak256(abi.encodePacked(blockhash(block.number-1), address(this), ++requestCount));\r\n    }\r\n}\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(StandardToken token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(StandardToken token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(StandardToken token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(StandardToken token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(StandardToken token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ManagerUpgradeable is LockIdGen {\r\n\r\n    struct ChangeRequest {\r\n        address proposedNew;\r\n        address proposedClear;\r\n    }\r\n\r\n    // address public custodian;\r\n    mapping (address => address) public managers;\r\n\r\n    mapping (bytes32 => ChangeRequest) public changeReqs;\r\n\r\n    uint256     public    mancount  ;\r\n\r\n    // CONSTRUCTOR\r\n    constructor(\r\n         address  [] memory _mans\r\n    )\r\n      LockIdGen()\r\n      public\r\n    {\r\n        uint256 numMans = _mans.length;\r\n        for (uint256 i = 0; i < numMans; i++) {\r\n          address pto = _mans[i];\r\n          require(pto != address(0));\r\n          managers[pto] = pto;\r\n        }\r\n        mancount = 0;\r\n    }\r\n\r\n    modifier onlyManager {\r\n        require(msg.sender == managers[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    // for manager change\r\n    function requestChange(address _new,address _clear) public onlyManager returns (bytes32 lockId) {\r\n        require( _clear != address(0) || _new != address(0) );\r\n\r\n        require( _clear == address(0) || managers[_clear] == _clear);\r\n\r\n        lockId = generateLockId();\r\n\r\n        changeReqs[lockId] = ChangeRequest({\r\n            proposedNew: _new,\r\n            proposedClear: _clear\r\n        });\r\n\r\n        emit ChangeRequested(lockId, msg.sender, _new,_clear);\r\n    }\r\n\r\n    event ChangeRequested(\r\n        bytes32 _lockId,\r\n        address _msgSender,\r\n        address _new,\r\n        address _clear\r\n    );\r\n\r\n   function confirmChange(bytes32 _lockId) public onlyManager {\r\n        ChangeRequest storage changeRequest = changeReqs[_lockId];\r\n        require( changeRequest.proposedNew != address(0) || changeRequest.proposedClear != address(0));\r\n\r\n        if(changeRequest.proposedNew != address(0))\r\n        {\r\n            managers[changeRequest.proposedNew] = changeRequest.proposedNew;\r\n            mancount = mancount + 1;\r\n        }\r\n\r\n        if(changeRequest.proposedClear != address(0))\r\n        {\r\n            delete managers[changeRequest.proposedClear];\r\n            mancount = mancount - 1;\r\n        }\r\n\r\n        delete changeReqs[_lockId];\r\n\r\n        emit ChangeConfirmed(_lockId, changeRequest.proposedNew,changeRequest.proposedClear);\r\n    }\r\n    event ChangeConfirmed(bytes32 _lockId, address _newCustodian, address _clearCustodian);\r\n\r\n    function sweepChange(bytes32 _lockId) public onlyManager {\r\n        ChangeRequest storage changeRequest=changeReqs[_lockId];\r\n        require((changeRequest.proposedNew != address(0) || changeRequest.proposedClear != address(0) ));\r\n        delete changeReqs[_lockId];\r\n        emit ChangeSweep(_lockId, msg.sender);\r\n    }\r\n    event ChangeSweep(bytes32 _lockId, address _sender);\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n    // events\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // public functions\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address addr) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    // events\r\n    event Approval(address indexed owner, address indexed agent, uint256 value);\r\n\r\n    // public functions\r\n    function allowance(address owner, address agent) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address agent, uint256 value) public returns (bool);\r\n\r\n}\r\n\r\ncontract DFK is ManagerUpgradeable {\r\n            \r\n    //liquidity +\r\n    function stakingDeposit(uint256 value) public payable returns (bool);\r\n\r\n    //profit +\r\n    function profit2Staking(uint256 value)public  returns (bool success);\r\n    \r\n\t\r\n    function withdrawProfit(address to)public  returns (bool success);\r\n    \r\n\t\r\n    function withdrawStaking(address to,uint256 value)public  returns (bool success);\r\n    \r\n\t\r\n    function withdrawAll(address to)public  returns (bool success);\r\n\r\n    \r\n\t\r\n    function totalMiners() public view returns (uint256);\r\n\r\n    function totalStaking() public view returns (uint256);\r\n\r\n\t\r\n    function poolBalance() public view returns (uint256);\r\n\r\n\t\r\n    function minedBalance() public view returns (uint256);\r\n\r\n\t\r\n    function stakingBalance(address miner) public view returns (uint256);\r\n\r\n\r\n    function profitBalance(address miner) public view returns (uint256);\r\n\r\n    \r\n    \r\n    function pauseStaking()public  returns (bool success);\r\n    \r\n    \r\n    function resumeStaking()public  returns (bool success);\r\n\r\n}\r\n\r\ncontract DFKProxy is DFK {\r\n            \r\n    DFK  public impl;\r\n\r\n\r\n    constructor(address [] memory _mans) public ManagerUpgradeable(_mans){\r\n        impl = DFK(0x0);\r\n    }\r\n\r\n\r\n    function requestImplChange(address _newDFK) public onlyManager returns (bytes32 ) {\r\n        require(_newDFK != address(0));\r\n        impl = DFK(_newDFK);\r\n    }\r\n\r\n\r\n\r\n    function stakingDeposit(uint256 value) public payable returns (bool){\r\n        return impl.stakingDeposit(value);\r\n    }\r\n\r\n\r\n\r\n    function profit2Staking(uint256 value)public  returns (bool success){\r\n        return impl.profit2Staking(value);\r\n    }\r\n\r\n\r\n    function withdrawProfit(address to)public  returns (bool success){\r\n        return impl.withdrawProfit(to);\r\n    }\r\n\r\n\r\n    function withdrawStaking(address to,uint256 value)public  returns (bool success){\r\n        return impl.withdrawStaking(to,value);\r\n    }\r\n    \r\n    \r\n    function withdrawAll(address to)public  returns (bool success){\r\n        return impl.withdrawAll(to);\r\n    }\r\n    \r\n\r\n\r\n    function totalMiners() public view returns (uint256)\r\n    {\r\n        return impl.totalMiners();\r\n    }\r\n\r\n\r\n    function totalStaking() public view returns (uint256)\r\n    {\r\n        return impl.totalStaking();\r\n    }\r\n\r\n\r\n    function poolBalance() public view returns (uint256)\r\n    {\r\n        return impl.poolBalance();\r\n    }\r\n\r\n\r\n    function minedBalance() public view returns (uint256)\r\n    {\r\n        return impl.minedBalance();\r\n    }\r\n\r\n\r\n    function stakingBalance(address miner) public view returns (uint256)\r\n    {\r\n        return impl.stakingBalance(miner);\r\n    }\r\n\r\n\r\n\r\n    function profitBalance(address miner) public view returns (uint256)\r\n    {\r\n        return impl.profitBalance(miner);\r\n    }\r\n\r\n\r\n\r\n    function pauseStaking()public  returns (bool success)\r\n    {\r\n        return impl.pauseStaking();\r\n    }\r\n    \r\n    \r\n    function resumeStaking()public  returns (bool success)\r\n    {\r\n        return impl.resumeStaking();\r\n    }\r\n\r\n}\r\n\r\ncontract DFKImplement is DFK {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for StandardToken;\r\n\r\n    int public status; \r\n\r\n    struct StakingLog{\r\n        uint256   staking_time;\r\n        uint256   profit_time;\r\n        uint256   staking_value;\r\n        uint256   unstaking_value; \r\n    }\r\n    mapping(address => StakingLog) public stakings;\r\n\r\n    uint256  public cleanup_time;\r\n\r\n    uint256  public profit_period;\r\n\r\n    uint256  public period_bonus; \r\n\r\n    mapping(address => uint256) public balanceProfit;\r\n    mapping(address => uint256) public balanceStaking;\r\n\r\n    StandardToken    public     dfkToken;\r\n\r\n    uint256 public  _totalMiners;\r\n    uint256 public  _totalStaking; \r\n    uint256 public  totalProfit;\r\n\r\n    uint256 public  minePoolBalance; \r\n\r\n    modifier onStaking {\r\n        require(status == 1,\"please start minner\");\r\n        _;\r\n    }\r\n    event ProfitLog(\r\n        address indexed from,\r\n        uint256 profit_time, \r\n        uint256 staking_value,\r\n        uint256 unstaking_value,\r\n        uint256 profit_times, \r\n        uint256 profit\r\n    );\r\n\r\n    constructor(address _dfkToken,int decimals,address  [] memory _mans) public ManagerUpgradeable(_mans){\r\n        status = 0;\r\n        cleanup_time = now;\r\n        profit_period = 24*3600; \r\n        period_bonus = 100000*(10 ** uint256(decimals));\r\n        cleanup_time = now;\r\n        dfkToken = StandardToken(_dfkToken);\r\n    }\r\n\r\n     \r\n    function addMinePool(uint256 stakevalue) public onStaking payable returns (uint256){\r\n        require(stakevalue>0);\r\n\r\n        // user must call prove first.\r\n        dfkToken.safeTransferFrom(msg.sender,address(this),stakevalue);\r\n\r\n        minePoolBalance = minePoolBalance.add(stakevalue);\r\n\r\n        return minePoolBalance;\r\n    }\r\n\r\n\r\n      \r\n    function stakingDeposit(uint256 stakevalue) public onStaking payable returns (bool){\r\n        require(stakevalue>0,\"stakevalue is gt zero\");\r\n\r\n        // user must call prove first.\r\n        dfkToken.transferFrom(msg.sender,address(this),stakevalue);\r\n\r\n        _totalStaking = _totalStaking.add(stakevalue);\r\n         \r\n        return addMinerStaking(msg.sender,stakevalue);\r\n    }\r\n\r\n\r\n    function addMinerStaking(address miner,uint256 stakevalue) internal  returns (bool){\r\n        balanceStaking[miner] = balanceStaking[miner].add(stakevalue);\r\n        \r\n        StakingLog memory slog=stakings[miner];\r\n\r\n        if(slog.profit_time < cleanup_time){ \r\n            stakings[miner] = StakingLog({\r\n                staking_time:now,\r\n                profit_time:now,\r\n                staking_value:0,\r\n                unstaking_value:stakevalue\r\n            });\r\n            _totalMiners = _totalMiners.add(1);\r\n        }else if(now.sub(slog.profit_time) >= profit_period){ \r\n            uint256   profit_times = now.sub(slog.profit_time).div(profit_period); \r\n            \r\n            stakings[miner] = StakingLog({\r\n                staking_time:now,\r\n                profit_time:now,\r\n                staking_value:slog.staking_value.add(slog.unstaking_value),\r\n                unstaking_value:stakevalue\r\n            });\r\n            \r\n            \r\n            uint256   profit =  period_bonus.mul(stakings[miner].staking_value).mul(profit_times).div(_totalStaking);\r\n            emit ProfitLog(miner,stakings[miner].profit_time,stakings[miner].staking_value,stakings[miner].unstaking_value,profit_times,profit);\r\n            require(minePoolBalance>=profit,\"minePoolBalance lt profit\");\r\n            minePoolBalance = minePoolBalance.sub(profit);\r\n\r\n             \r\n            balanceProfit[miner]=balanceProfit[miner].add(profit);\r\n            totalProfit = totalProfit.add(profit);\r\n\r\n        }else { \r\n            stakings[miner] = StakingLog({\r\n                staking_time:now,\r\n                profit_time:slog.profit_time,\r\n                staking_value:slog.staking_value,\r\n                unstaking_value:slog.unstaking_value.add(stakevalue)\r\n            });\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n     \r\n    function profit2Staking(uint256 value)public onStaking returns (bool success){\r\n        \r\n        require(balanceProfit[msg.sender]>=value);\r\n        balanceProfit[msg.sender] = balanceProfit[msg.sender].sub(value);\r\n        return addMinerStaking(msg.sender,value);\r\n\r\n    }\r\n\r\n     \r\n    function withdrawProfit(address to)public  returns (bool success){\r\n        \r\n        require(to != address(0));\r\n\r\n        addMinerStaking(msg.sender,0);\r\n\r\n        uint256 profit = balanceProfit[msg.sender];\r\n        balanceProfit[msg.sender] = 0;\r\n\r\n        require(dfkToken.transfer(to,profit));\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n     \r\n    function withdrawStaking(address to,uint256 value)public  returns (bool success){\r\n        require(value>0);\r\n        require(to != address(0));\r\n        require(balanceStaking[msg.sender]>=value);\r\n        require(_totalStaking>=value);\r\n        \r\n        _totalStaking=_totalStaking.sub(value);\r\n        \r\n        balanceStaking[msg.sender] = balanceStaking[msg.sender].sub(value);\r\n        StakingLog memory slog=stakings[msg.sender];\r\n        \r\n         \r\n        stakings[msg.sender] = StakingLog({\r\n            staking_time:now,\r\n            profit_time:slog.profit_time,\r\n            staking_value:0,\r\n            unstaking_value:balanceStaking[msg.sender]\r\n        });\r\n        \r\n        require(dfkToken.transfer(to,value));\r\n        \r\n        return true;\r\n    }\r\n\r\n      \r\n    function withdrawAll(address to)public  returns (bool success){\r\n        require(to != address(0));\r\n        \r\n        addMinerStaking(msg.sender,0);\r\n        \r\n        _totalStaking=_totalStaking.sub(balanceStaking[msg.sender]);\r\n        \r\n        uint256 total=balanceStaking[msg.sender].add(balanceProfit[msg.sender]);\r\n\r\n        balanceProfit[msg.sender]=0;\r\n        balanceStaking[msg.sender] = 0;\r\n         \r\n        stakings[msg.sender] = StakingLog({\r\n            staking_time:0,\r\n            profit_time:0,\r\n            staking_value:0,\r\n            unstaking_value:0\r\n        });\r\n        // _totalMiners=_totalMiners.sub(1);\r\n        require(dfkToken.transfer(to,total));\r\n        \r\n        return true;\r\n    }\r\n    \r\n    \r\n    function totalMiners() public view returns (uint256){\r\n        return _totalMiners;\r\n    }\r\n\r\n     \r\n    function totalStaking() public view returns (uint256){\r\n        return _totalStaking;\r\n\r\n    }\r\n     \r\n    function poolBalance() public view returns (uint256){\r\n        return minePoolBalance;\r\n    }\r\n\r\n     \r\n    function minedBalance() public view returns (uint256){\r\n        return totalProfit;\r\n    }\r\n\r\n     \r\n    function stakingBalance(address miner) public view returns (uint256){\r\n        return balanceStaking[miner];\r\n    }\r\n\r\n\r\n     \r\n    function profitBalance(address miner) public view returns (uint256){\r\n        return balanceProfit[miner];\r\n    }\r\n\r\n     \r\n    function pauseStaking()public onlyManager  returns (bool ){\r\n        status = 0;\r\n    }\r\n    \r\n     \r\n    function resumeStaking()public onlyManager returns (bool ){\r\n       status = 1;\r\n    }\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  // public variables\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals = 18;\r\n\r\n  // internal variables\r\n  uint256 _totalSupply;\r\n  mapping(address => uint256) _balances;\r\n\r\n  // events\r\n\r\n  // public functions\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address addr) public view returns (uint256 balance) {\r\n    return _balances[addr];\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    require(to != address(0));\r\n    require(value <= _balances[msg.sender]);\r\n\r\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  // internal functions\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n  // public variables\r\n\r\n  // internal variables\r\n  mapping (address => mapping (address => uint256)) _allowances;\r\n\r\n  // events\r\n\r\n  // public functions\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n    require(to != address(0));\r\n    require(value <= _balances[from],\"value lt from\");\r\n    require(value <= _allowances[from][msg.sender],\"value lt _allowances from \");\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\r\n    emit Transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address agent, uint256 value) public returns (bool) {\r\n    _allowances[msg.sender][agent] = value;\r\n    emit Approval(msg.sender, agent, value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address owner, address agent) public view returns (uint256) {\r\n    return _allowances[owner][agent];\r\n  }\r\n\r\n  function increaseApproval(address agent, uint value) public returns (bool) {\r\n    _allowances[msg.sender][agent] = _allowances[msg.sender][agent].add(value);\r\n    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address agent, uint value) public returns (bool) {\r\n    uint allowanceValue = _allowances[msg.sender][agent];\r\n    if (value > allowanceValue) {\r\n      _allowances[msg.sender][agent] = 0;\r\n    } else {\r\n      _allowances[msg.sender][agent] = allowanceValue.sub(value);\r\n    }\r\n    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);\r\n    return true;\r\n  }\r\n  // internal functions\r\n}\r\n\r\ncontract DFKToken is StandardToken {\r\n  // public variables\r\n  string public name = \"Defiking\";\r\n  string public symbol = \"DFK\";\r\n  uint8 public decimals = 18;\r\n\r\n  // internal variables\r\n \r\n  // events\r\n\r\n  // public functions\r\n  constructor() public {\r\n    //init _totalSupply\r\n    _totalSupply = 1000000000 * (10 ** uint256(decimals));\r\n\r\n    _balances[msg.sender] = _totalSupply;\r\n    emit Transfer(address(0x0), msg.sender, _totalSupply);\r\n  }\r\n\r\n  // internal functions\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dfkToken\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"decimals\",\"type\":\"int256\"},{\"internalType\":\"address[]\",\"name\":\"_mans\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newCustodian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_clearCustodian\",\"type\":\"address\"}],\"name\":\"ChangeConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_clear\",\"type\":\"address\"}],\"name\":\"ChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"ChangeSweep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"staking_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unstaking_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit_times\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"ProfitLog\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakevalue\",\"type\":\"uint256\"}],\"name\":\"addMinePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"changeReqs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proposedNew\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposedClear\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cleanup_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"}],\"name\":\"confirmChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dfkToken\",\"outputs\":[{\"internalType\":\"contract StandardToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mancount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minePoolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period_bonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"profit2Staking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"profitBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profit_period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_clear\",\"type\":\"address\"}],\"name\":\"requestChange\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"lockId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"stakingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakevalue\",\"type\":\"uint256\"}],\"name\":\"stakingDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"staking_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staking_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstaking_value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"}],\"name\":\"sweepChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawProfit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DFKImplement","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a17de0ab0a97bc5e56fa8b39ebfc81cc3f1f349e000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000001000000000000000000000000b9d6404311e1c95cbc092796a5a0dd067572c7a1","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e4a9a1ca1680f4c96aba9d6770f466d3ce95b23e76b21bdf17719e364a32925b"}]}