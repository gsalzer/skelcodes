{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Created on 2020-05-11\r\n * @summary: SE Auction Master Contract\r\n * @author: Fazri Zubair & Farhan Khwaja\r\n */\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require (c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require (_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require (_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require (c >= _a);\r\n\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n  * Returns whether the target address is a contract\r\n  * @dev This function will return false if invoked during the constructor of a contract,\r\n  *  as the code is not actually created until after the constructor finishes.\r\n  * @param addr address to check\r\n  * @return whether the target address is a contract\r\n  */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      size := extcodesize(addr) \r\n    }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the\r\n    /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n    /// of other than the magic value MUST result in the transaction being reverted.\r\n    /// @notice The contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    /// unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes32 _data) external returns(bytes4);\r\n}\r\n\r\n/* basic Interface to access any ERC721 standard functions\r\n * @title ERC721Token\r\n */\r\ninterface ERC721Token {\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    \r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    \r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function implementsERC721() external pure returns (bool);\r\n}\r\n\r\n/** Controls state and access rights for contract functions\r\n * @title Operational Control\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n * Inspired and adapted from contract created by OpenZeppelin \r\n * Ref: https://github.com/OpenZeppelin/zeppelin-solidity/\r\n */\r\ncontract OperationalControl {\r\n  /// Facilitates access & control for the game.\r\n  /// Roles:\r\n  ///  -The Managers (Primary/Secondary): Has universal control of all elements (No ability to withdraw)\r\n  ///  -The Banker: The Bank can withdraw funds and adjust fees / prices.\r\n  ///  -otherManagers: Contracts that need access to functions for gameplay\r\n\r\n  /// @dev Emited when contract is upgraded\r\n  event ContractUpgrade(address newContract);\r\n\r\n  /// @dev The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n  address public managerPrimary;\r\n  address public managerSecondary;\r\n  address payable public bankManager;\r\n\r\n  // Contracts that require access for gameplay\r\n  mapping(address => uint8) public otherManagers;\r\n\r\n  // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n  bool public paused = false;\r\n\r\n  // @dev Keeps track whether the contract erroredOut. When that is true, most actions are blocked & \r\n  // refund can be claimed\r\n  bool public error = false;\r\n\r\n  /**\r\n  * @dev Operation modifiers for limiting access only to Managers\r\n  */\r\n  modifier onlyManager() {\r\n    require (msg.sender == managerPrimary || msg.sender == managerSecondary || otherManagers[msg.sender] == 1);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Operation modifiers for limiting access only to Bank Manager\r\n  */\r\n  modifier onlyBanker() {\r\n    require (msg.sender == bankManager);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Operation modifiers for any Operators\r\n  */\r\n  modifier anyOperator() {\r\n    require (\r\n        msg.sender == managerPrimary ||\r\n        msg.sender == managerSecondary ||\r\n        msg.sender == bankManager ||\r\n        otherManagers[msg.sender] == 1\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Assigns a new address to act as the Primary Manager.\r\n  * @param _newGM    New primary manager address\r\n  */\r\n  function setPrimaryManager(address _newGM) external onlyManager {\r\n    require (_newGM != address(0));\r\n\r\n    managerPrimary = _newGM;\r\n  }\r\n\r\n  /**\r\n  * @dev Assigns a new address to act as the Secondary Manager.\r\n  * @param _newGM    New Secondary Manager Address\r\n  */\r\n  function setSecondaryManager(address _newGM) external onlyManager {\r\n    require (_newGM != address(0));\r\n\r\n    managerSecondary = _newGM;\r\n  }\r\n\r\n  /**\r\n    * @dev Assigns a new address to act as the Bank Manager.\r\n    * @param _newBM    New Bank Manager Address\r\n    */\r\n  function setBankManager(address payable _newBM) external onlyManager {\r\n    require (_newBM != address(0));\r\n\r\n    bankManager = _newBM;\r\n  }\r\n\r\n  /// @dev Assigns a new address to act as the Other Manager. (State = 1 is active, 0 is disabled)\r\n  function setOtherManager(address _newOp, uint8 _state) external onlyManager {\r\n    require (_newOp != address(0));\r\n\r\n    otherManagers[_newOp] = _state;\r\n  }\r\n\r\n  /// @dev Batch function assigns a new address to act as the Other Manager. (State = 1 is active, 0 is disabled)\r\n  function batchSetOtherManager(address[] calldata _newOp, uint8[] calldata _state) external onlyManager {\r\n\t  for (uint ii = 0; ii < _newOp.length; ii++){\r\n\t\trequire (_newOp[ii] != address(0));\r\n\r\n    \totherManagers[_newOp[ii]] = _state[ii];\r\n\t  }\r\n  }\r\n\r\n  /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n  /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n  modifier whenNotPaused() {\r\n    require (!paused);\r\n    _;\r\n  }\r\n\r\n  /// @dev Modifier to allow actions only when the contract IS paused\r\n  modifier whenPaused {\r\n    require (paused);\r\n    _;\r\n  }\r\n\r\n  /// @dev Modifier to allow actions only when the contract has Error\r\n  modifier whenError {\r\n    require (error);\r\n    _;\r\n  }\r\n\r\n  /**\r\n    * @dev Called by any Operator role to pause the contract.\r\n    * Used only if a bug or exploit is discovered (Here to limit losses / damage)\r\n    */\r\n  function pause() external onlyManager whenNotPaused {\r\n    paused = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Unpauses the smart contract. Can only be called by the Game Master\r\n  */\r\n  function unpause() public onlyManager whenPaused {\r\n    // can't unpause if contract was upgraded\r\n    paused = false;\r\n  }\r\n\r\n  /**\r\n  * @dev Errors out the contract thus mkaing the contract non-functionable\r\n  */\r\n  function hasError() public onlyManager whenPaused {\r\n    error = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Removes the Error Hold from the contract and resumes it for working\r\n  */\r\n  function noError() public onlyManager whenPaused whenError {\r\n    error = false;\r\n  }\r\n}\r\n\r\n/**\r\n * @title      SEAuction\r\n * @dev        Scarcity Engine Auction Contract\r\n * @notice     This helps in creating auctions for items for Scarcity Engine\r\n */\r\ncontract SEAuction is OperationalControl {\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  /*** EVENTS ***/\r\n  \r\n  /// @dev Event Fired a user bids for an item\r\n  event SEBidPlaced(address userWallet, uint256 ethBid);\r\n\r\n  /// @dev This event is fired when an ETH winner is decalred \r\n  event SEAuctionETHWinner(address userAddress, uint256 buyingPrice, uint256 assetId);\r\n\r\n  /// @dev This event is fired when a GFC winner is decalred. userAddressc can ScarcityEngine address\r\n  /// thus bytes32. can be transformed to string\r\n  event SEAuctionGFCWinner(bytes32 userAddress, uint256 buyingPrice, uint256 assetId);\r\n\r\n  /// @dev This event is fired when we do a refund when a buy request can't be fulfilled\r\n  event SEAuctionRefund(address to, uint256 ethValue);\r\n\r\n  mapping(address => uint256) public userETHBalance;\r\n  address[] private allBidders;\r\n  \r\n  // AuctionId associated with SEAuctionMaster\r\n  uint256 public auctionId;\r\n  // Current winner of Auction\r\n  address public winner;\r\n  // Winner Price\r\n  uint256 public winningBid;\r\n  // NFT Contract Address\r\n  address public nftAddress;\r\n  // Price (in wei) at beginning of sale\r\n  uint256 public startingPrice;\r\n  // Duration (in seconds) of sale\r\n  uint256 public duration;\r\n  // Time when sale started\r\n  // NOTE: 0 if this sale has been concluded\r\n  uint256 public startedAt;\r\n  // ERC721 AssetID\r\n  uint256 public assetId;\r\n  // DApp Name\r\n  bytes32 public dAppName;\r\n  // Bool for transfer tokenId\r\n  bool public transferToken;\r\n\r\n  uint256 private maxBid;\r\n\r\n  /**\r\n  * @dev Constructor function\r\n  */\r\n  constructor (uint256 _auctionId, address payable _owner, uint256 _startingPrice, uint256 _startedAt, \r\n    uint256 _duration, uint256 _assetId, bytes32 _dAppName, address _nftAddress) public {\r\n    require (_owner != address(0));\r\n    paused = true;\r\n    error = false;\r\n    managerPrimary = _owner;\r\n    managerSecondary = _owner;\r\n    bankManager = _owner;\r\n    otherManagers[_owner] = 1;\r\n    \r\n    auctionId = _auctionId;\r\n    startingPrice = _startingPrice;\r\n    maxBid = _startingPrice;\r\n    duration = _duration;\r\n    assetId = _assetId;\r\n    dAppName = _dAppName;\r\n    startedAt = _startedAt;\r\n    nftAddress = _nftAddress;\r\n    transferToken = false;\r\n  }\r\n  \r\n  function isAuctionActive() external view returns(bool){\r\n      return (now <= (startedAt.add(duration)) && winner == address(0));\r\n  }\r\n\r\n    // This function is called for all messages sent to\r\n    // this contract, except plain Ether transfers\r\n    // (there is no other function except the receive function).\r\n    // Any call with non-empty calldata to this contract will execute\r\n    // the fallback function (even if Ether is sent along with the call).\r\n    fallback() external payable {  }\r\n\r\n    /// @dev allows the contract to accept ETH\r\n    receive() external payable {\r\n\t    // Auctions needs to be Open to allow ETH to be passed\r\n      require (this.isAuctionActive());\r\n      \r\n      uint256 _potentialUserBalance = userETHBalance[msg.sender].add(msg.value);\r\n      // Checking Sender Addr & ETH\r\n      require (address(msg.sender) != address(0));\r\n      require (_potentialUserBalance > maxBid);\r\n      \r\n      _incrementBalance(msg.sender, msg.value);\r\n      uint256 _userBalance = userETHBalance[msg.sender];\r\n      maxBid = _userBalance;\r\n    \r\n\t  emit SEBidPlaced(msg.sender, msg.value);\r\n    }\r\n\r\n  function _incrementBalance(address bidder, uint256 ethValue) private {\r\n    if(userETHBalance[bidder] == 0){\r\n      userETHBalance[bidder] = ethValue;\r\n      allBidders.push(bidder);\r\n    }else{\r\n      uint256 _userBalance = userETHBalance[bidder];\r\n      userETHBalance[bidder] = _userBalance.add(ethValue);\r\n    }\r\n  }\r\n\r\n  function auctionWinner(address _winner, address _nftAddress) external anyOperator {\r\n    require(address(_winner) != address(0), \"Winner cannot be 0x0\");\r\n    \r\n    uint256 _userBalance = userETHBalance[_winner];\r\n    userETHBalance[_winner] = 0;\r\n    bankManager.transfer(_userBalance);\r\n    winner = _winner;\r\n    if(transferToken){\r\n      require(address(_nftAddress) != address(0), \"NFT Address cannot be 0x0\");\r\n      ERC721Token _nft = ERC721Token(_nftAddress);\r\n      require(_nft.ownerOf(assetId) == address(this));\r\n\t  _nft.transferFrom(address(this), _winner, assetId);\r\n    }\r\n    emit SEAuctionETHWinner(_winner, _userBalance, assetId);\r\n  }\r\n\r\n  function auctionWinnerWithGFC(bytes32 winnerBytes32, uint256 gfcToETH) external anyOperator {\r\n    require(gfcToETH > 0, \"Winning GFC-ETH cannot be 0\");\r\n    winner = address(bankManager);\r\n    emit SEAuctionGFCWinner(winnerBytes32, gfcToETH, assetId);\r\n  }\r\n  \r\n  function refundETH(address payable [] calldata refundAddresses) external anyOperator{\r\n    for(uint i=0;i< refundAddresses.length;i++){\r\n        require(refundAddresses[i] != address(0));\r\n        uint256 _userBalance = userETHBalance[refundAddresses[i]];\r\n        userETHBalance[refundAddresses[i]] = 0;\r\n        refundAddresses[i].transfer(_userBalance);\r\n        emit SEAuctionRefund(refundAddresses[i], _userBalance);\r\n    }\r\n  }\r\n  \r\n  function getAuctionDetails() external view returns(address winnerAddress, uint256 startPrice, uint256 startingTime, \r\n    uint256 endingTime, uint256 auctionDuration, uint256 assetID, bytes32 dApp, address nftContractAddress){\r\n    return (\r\n        winner,\r\n        startingPrice,\r\n        startedAt, \r\n        startedAt.add(duration), \r\n        duration,\r\n        assetId, \r\n        dAppName, \r\n        nftAddress\r\n    );\r\n  }\r\n  \r\n  function totalNumberOfBidders() external view returns(uint256){\r\n      return allBidders.length;\r\n  }\r\n  \r\n  function updateTransferBool(bool flag) external anyOperator {\r\n      transferToken = flag;\r\n  }\r\n  \r\n  function getMaxBidValue() external view returns(uint256){\r\n      return maxBid;\r\n  }\r\n  \r\n  function transferAssetFromContract(address to, address nftAddress, uint256 assetId) external anyOperator{\r\n    require(nftAddress != address(0), \"NFT Contract Cannot be 0x0\");\r\n    \r\n    ERC721Token _nft = ERC721Token(nftAddress);\r\n    \r\n    _nft.transferFrom(address(this), to, assetId);\r\n  }\r\n  \r\n  function withdrawBalance() public onlyBanker {\r\n      bankManager.transfer(address(this).balance);\r\n  }\r\n}\r\n\r\n/**\r\n * @title      SEAuctionMaster\r\n * @dev        Scarcity Engine Master Auction Contract\r\n * @notice     Master auction Contract for Scarcity Engine\r\n */\r\ncontract SEAuctionMaster is OperationalControl {\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n  \r\n  /// @dev Auction Created\r\n  event SEAuctionCreated(address newAuctionContract, uint256 assetId, uint256 startPrice, bytes32 indexed dAppName, uint256 startDate, uint256 endDate, uint256 seAuctionID);\r\n\r\n  /**\r\n  * @dev Constructor function\r\n  */\r\n  constructor () public {\r\n    require (msg.sender != address(0));\r\n    paused = true;\r\n    error = false;\r\n    managerPrimary = msg.sender;\r\n    managerSecondary = msg.sender;\r\n    bankManager = msg.sender;\r\n    otherManagers[msg.sender] = 1;\r\n  }\r\n  \r\n  struct Auction {\r\n    uint256 auctionId;\r\n    address payable contractAddress;\r\n    uint256 assetId;\r\n    address nftAddress;\r\n    uint256 startPrice;\r\n    uint256 startedAt;\r\n    uint256 duration;\r\n    bytes32 dAppName;\r\n    uint256 winningPrice;\r\n  }\r\n  \r\n  bool public canTransferOnAuction = false;\r\n  Auction[] public auctions;\r\n  \r\n  function createAuction(uint256 assetId, address nftAddress, uint256 startPrice, uint256 duration, bytes32 dAppName) external onlyManager{\r\n    require(nftAddress != address(0), \"NFT Contract Cannot be 0x0\");\r\n    \r\n    ERC721Token _nft = ERC721Token(nftAddress);\r\n    require(duration != 0, \"Duration cannot be zero\");\r\n    \r\n    uint256 _currentTime = now;\r\n    SEAuction _itemAuctionContract = new SEAuction(auctions.length, msg.sender, startPrice, _currentTime, duration, assetId, dAppName, nftAddress);\r\n    \r\n    address payable _contractAddress = address(_itemAuctionContract);\r\n    \r\n    Auction memory _itemAuction = Auction(\r\n      auctions.length,\r\n      _contractAddress,\r\n      assetId,\r\n      nftAddress,\r\n      startPrice,\r\n      _currentTime,\r\n      duration,\r\n      dAppName,\r\n      0\r\n    );\r\n\r\n    auctions.push(_itemAuction);\r\n    \r\n    if(canTransferOnAuction){\r\n        require(_nft.ownerOf(assetId) == address(this), \"Auction Contract is not the owner\");\r\n        _nft.transferFrom(address(this), _contractAddress, assetId);\r\n    }\r\n    emit SEAuctionCreated(_contractAddress, assetId, startPrice, dAppName, _currentTime, _currentTime.add(duration), auctions.length - 1);\r\n  }\r\n  \r\n  function refundFromAuction(address payable auctionContract, address payable [] calldata refundAddresses) external anyOperator {\r\n    require(auctionContract != address(0));\r\n    SEAuction _auctionContract = SEAuction(auctionContract);\r\n    _auctionContract.refundETH(refundAddresses);\r\n  }\r\n  \r\n  function getAuctionDetail(uint256 auctionID) external view returns(address winnerAddress, uint256 startPrice, uint256 startingTime, \r\n    uint256 endingTime, uint256 auctionDuration, uint256 assetId, bytes32 dApp, bytes32 auctionData, address nftContractAddress){\r\n      Auction memory _auctionData = auctions[auctionID];\r\n      SEAuction _auctionContract = SEAuction(_auctionData.contractAddress);\r\n      _auctionContract.getAuctionDetails();\r\n  }\r\n  \r\n  function updateAssetTransferForAuction(uint256 auctionID, bool flag) external {\r\n      Auction memory _auctionData = auctions[auctionID];\r\n      SEAuction _auctionContract = SEAuction(_auctionData.contractAddress);\r\n      _auctionContract.updateTransferBool(flag);\r\n  }\r\n  \r\n  function batchUpdateAssetTransferForAuction(uint256 [] calldata auctionIDs, bool flag) external {\r\n      for(uint8 i=0;i<auctionIDs.length;i++){\r\n        Auction memory _auctionData = auctions[auctionIDs[i]];\r\n        SEAuction _auctionContract = SEAuction(_auctionData.contractAddress);\r\n        _auctionContract.updateTransferBool(flag);\r\n      }\r\n  }\r\n  \r\n  function approveManager(uint256 auctionID, address approvedAddress) external anyOperator {\r\n    Auction memory _auctionData = auctions[auctionID];\r\n    ERC721Token _nft = ERC721Token(_auctionData.nftAddress);\r\n    _nft.approve(approvedAddress, _auctionData.assetId);\r\n  }\r\n  \r\n  function updateCanTransferOnAuction(bool flag) external anyOperator{\r\n      canTransferOnAuction = flag;\r\n  }\r\n  \r\n  function checkOwner(uint256 assetId, address nftAddress) external view returns (address){\r\n    require(nftAddress != address(0), \"NFT Contract Cannot be 0x0\");\r\n    \r\n    ERC721Token _nft = ERC721Token(nftAddress);\r\n    \r\n    return _nft.ownerOf(assetId);\r\n  }\r\n  \r\n  function transferStuckAsset(address to, address nftAddress, uint256 assetId) external anyOperator{\r\n    require(nftAddress != address(0), \"NFT Contract Cannot be 0x0\");\r\n    \r\n    ERC721Token _nft = ERC721Token(nftAddress);\r\n    \r\n    _nft.transferFrom(address(this), to, assetId);\r\n  }\r\n    \r\n  function withdrawBalance() public onlyBanker {\r\n      bankManager.transfer(address(this).balance);\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_auctionId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_dAppName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"SEAuctionETHWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"userAddress\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"SEAuctionGFCWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"}],\"name\":\"SEAuctionRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethBid\",\"type\":\"uint256\"}],\"name\":\"SEBidPlaced\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"assetId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"auctionWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"winnerBytes32\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"gfcToETH\",\"type\":\"uint256\"}],\"name\":\"auctionWinnerWithGFC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bankManager\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newOp\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_state\",\"type\":\"uint8[]\"}],\"name\":\"batchSetOtherManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dAppName\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"error\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuctionDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"winnerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetID\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dApp\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBidValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasError\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAuctionActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managerPrimary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managerSecondary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noError\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"otherManagers\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"refundAddresses\",\"type\":\"address[]\"}],\"name\":\"refundETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newBM\",\"type\":\"address\"}],\"name\":\"setBankManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOp\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"setOtherManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGM\",\"type\":\"address\"}],\"name\":\"setPrimaryManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGM\",\"type\":\"address\"}],\"name\":\"setSecondaryManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNumberOfBidders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"transferAssetFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"updateTransferBool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userETHBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winningBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SEAuction","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000d414e7355378ff9be9589eff757ff985dd398755000000000000000000000000000000000000000000000000000ffcb9e57d4000000000000000000000000000000000000000000000000000000000005ed14d6e00000000000000000000000000000000000000000000000000000000000bddbc0000000000000000000000000000000000000000000000000000000000134bf243534300000000000000000000000000000000000000000000000000000000000000000000000000000000004d3814d4da8083b41861dec2f45b4840e8b72d68","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3e65eef414cff3def693117806b304aff6cfa0011181c2bd5c6ba6f1a02e575d"}]}