{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.11; // 5ef660b1\r\n/**\r\n * @title BAEX - Binary Assets EXchange DeFi token v.1.0.1 (Â© 2020 - baex.com)\r\n *\r\n * The source code of the BAEX token, which provides liquidity for the open binary options platform https://baex.com\r\n * \r\n * THIS SOURCE CODE CONFIRMS THE \"NEVER FALL\" MATHEMATICAL MODEL USED IN THE BAEX TOKEN.\r\n * \r\n * 9 facts about the BAEX token:\r\n * \r\n * 1) Locked on the BAEX smart-contract, Ethereum is always collateral of the tokens value and can be transferred\r\n *  from it only when the user burns his BAEX tokens.\r\n * \r\n * 2) The total supply of BAEX increases only when Ethereum is sent on hold on the BAEX smart-contract\r\n * \tand decreases when the BAEX holder burns his tokens to get ETH.\r\n * \r\n * 3) Any BAEX tokens holder at any time can burn them and receive a part of the Ethereum held\r\n * \ton BAEX smart-contract based on the formula tokens_to_burn * current_burn_price - (5% burning_fee).\r\n * \r\n * 4) current_burn_price is calculated by the formula (amount_of_holded_eth / total_supply) * 0.9\r\n * \r\n * 5) Based on the facts above, the value of the BAEX tokens remaining after the burning increases every time\r\n * \tsomeone burns their BAEX tokens and receives Ethereum for them.\r\n * \r\n * 6) BAEX tokens issuance price calculated as (amount_of_holded_eth / total_supply) + (amount_of_holded_eth / total_supply) * 14%\r\n *  that previously purchased BAEX tokens are always increased in their price.\r\n * \r\n * 7) BAEX token holders can participate as liquidity providers or traders on the baex.com hence, any withdrawal of\r\n *  profit in ETH will increase the value of previously purchased BAEX tokens.\r\n * \r\n * 8) There is a referral program, running on the blockchain, in the BAEX token that allows you to receive up to 80% of the system's \r\n *  commissions as a reward, you can find out more details and get your referral link at https://baex.com/#referral\r\n *\r\n * 9) There is an integrated automatic bonus pool distribution system in the BAEX token https://baex.com/#bonus\r\n * \r\n * Read more about all the possible ways of earning and using the BAEX token on https://baex.com/#token\r\n */\r\n\r\n/* Abstract contracts */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface with allowance\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\nabstract contract ERC20 {\r\n    uint public _totalSupply;\r\n    function totalSupply() public view virtual returns (uint);\r\n    function balanceOf(address who) public view virtual returns (uint);\r\n    function transfer(address to, uint value) virtual public returns (bool);\r\n    function allowance(address owner, address spender) public view virtual returns (uint);\r\n    function transferFrom(address from, address to, uint value) virtual public returns (bool);\r\n    function approve(address spender, uint value) virtual public;\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * @title Implementation of the basic standard ERC20 token.\r\n * @dev ERC20 with allowance\r\n */\r\nabstract contract StandardToken is ERC20 {\r\n    using SafeMath for uint;\r\n    mapping(address => uint) public balances;\r\n    mapping (address => mapping (address => uint)) public allowed;\r\n    uint private constant MAX_UINT = 2**256 - 1;\r\n\r\n    /**\r\n    * @dev Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(!(msg.data.length < size + 4));\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @dev Fix for the ERC20 short address attack.\r\n    */\r\n    function totalSupply() public view override virtual returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint _value) override virtual public onlyPayloadSize(2 * 32) returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Get the balance of the specified address.\r\n    * @param _owner The address to query the balance of.\r\n    * @return balance An uint representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) view override public returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint _value) override virtual public onlyPayloadSize(3 * 32) returns (bool) {\r\n        uint _allowance = allowed[_from][msg.sender];\r\n        require(_allowance>=_value,\"Not enought allowed amount\");\r\n        require(_allowance<MAX_UINT);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint _value) override public onlyPayloadSize(2 * 32) {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return remaining A uint specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) override public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title OptionsContract\r\n * @dev Abstract contract of BAEX options\r\n */\r\nabstract contract OptionsContract {\r\n    function onTransferTokens(address _from, address _to, uint256 _value) public virtual returns (bool);\r\n}\r\n/* END of: Abstract contracts */\r\n\r\n/**\r\n * @title BAEX\r\n * @dev BAEX token contract\r\n */\r\ncontract BAEX is StandardToken {\r\n    address constant internal super_owner = 0x2B2fD898888Fa3A97c7560B5ebEeA959E1Ca161A;\r\n    // Fixed point math factor is 10^8\r\n    uint256 constant public fmkd = 8;\r\n    uint256 constant public fmk = 10**fmkd;\r\n    // Burn price ratio is 0.9\r\n    uint256 constant burn_ratio = 9 * fmk / 10;\r\n    // Burning fee is 5%\r\n    uint256 constant burn_fee = 5 * fmk / 100;\r\n    // Minimum amount of issue tokens transacion is 0.1 ETH\r\n    uint256 constant min_eth_to_send = 10**17;\r\n    // Issuing price increase ratio vs locked_amount/supply is 14 %\r\n    uint256 public issue_increase_ratio = 140 * fmk / 1000;\r\n    \r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint public decimals;\r\n\t\r\n\tuint256 public issue_price;\r\n\tuint256 public burn_price;\r\n\t\r\n\t// Counters of transactions\r\n\tuint256 public issue_counter;\r\n\tuint256 public burn_counter;\r\n\t\r\n\t// Issued & burned volumes\r\n\tuint256 public issued_volume;\r\n\tuint256 public burned_volume;\r\n\t\r\n\t// Bonus pool is 1% from income\r\n    uint256 public bonus_pool_perc;\r\n    // Bonus pool\r\n    uint256 public bonus_pool_eth;\r\n    // Bonus sharing start block\r\n    uint256 public bonus_sharing_block;\r\n    // Share bonus game from min_bonus_pool_eth_amount \r\n    uint256 public min_bonus_pool_eth_amount;\r\n\t\r\n\tmapping (address => bool) optionsContracts;\r\n\taddress payable referral_program_contract;\r\n\t\r\n\taddress private owner;\r\n\r\n    /**\r\n    * @dev constructor, initialization of starting values\r\n    */\r\n\tconstructor() public {\r\n\t\tname = \"Binary Assets EXchange\";\r\n\t\tsymbol = \"BAEX\";\r\n\t\tdecimals = 8;\r\n\t\t\r\n\t\towner = msg.sender;\t\t\r\n\r\n\t\t// Initial Supply of BAEX is ZERO\r\n\t\t_totalSupply = 0;\r\n\t\tbalances[address(this)] = _totalSupply;\r\n\t\t\r\n\t\t// Initial issue price of BAEX is 0.1 ETH per 1.0 BAEX\r\n\t\tissue_price = 1 * fmk / 10;\r\n\t\t\r\n\t\t// 1% from income to the bonus pool\r\n\t\tbonus_pool_perc = 1 * fmk / 100;\r\n\t\t// 2 ETH is the minimum amount to share the bonus pool\r\n\t\tmin_bonus_pool_eth_amount = 2 * 10**18;\r\n\t\tbonus_pool_eth = 0;\r\n\t}\r\n\t\r\n\tfunction issuePrice() public view returns (uint256) {\r\n\t\treturn issue_price;\r\n\t}\r\n\t\r\n\tfunction burnPrice() public view returns (uint256) {\r\n\t\treturn burn_price;\r\n\t}\r\n\r\n\tfunction ethAmountInBonusPool() public view returns (uint256) {\r\n\t\treturn bonus_pool_eth;\r\n\t}\r\n\t\r\n\t/**\r\n    * @dev ERC20 transfer with burning of BAEX when it will be sent to the BAEX smart-contract\r\n    * @dev and with the placing liquidity to the binary options when tokens will be sent to the BAEXOptions contracts.\r\n    */\r\n\tfunction transfer(address _to, uint256 _value) public override returns (bool) {\r\n\t    require(_to != address(0),\"Destination address can't be empty\");\r\n\t    require(_value > 0,\"Value for transfer should be more than zero\");\r\n\t\tif ( super.transfer(_to, _value) ) {\r\n\t\t    if ( _to == address(this) ) {\r\n    \t\t    return burnBAEX( msg.sender, _value );\r\n    \t\t} else if ( optionsContracts[_to] ) {\r\n    \t\t    OptionsContract(_to).onTransferTokens( msg.sender, _to, _value );\r\n    \t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n    /**\r\n    * @dev ERC20 transferFrom with burning of BAEX when it will be sent to the BAEX smart-contract\r\n    * @dev and with the placing liquidity to the binary options when tokens will be sent to the BAEXOptions contracts.\r\n\t*/\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {\r\n\t    require(_to != address(0),\"Destination address can't be empty\");\r\n\t    require(_value > 0,\"Value for transfer should be more than zero\");\r\n\t\tif ( super.transferFrom(_from, _to, _value) ) {\r\n\t\t    if ( _to == address(this) ) {\r\n    \t\t    return burnBAEX( _from, _value );\r\n    \t\t} else if ( optionsContracts[_to] ) {\r\n    \t\t    OptionsContract(_to).onTransferTokens( _from, _to, _value );\r\n    \t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n    /**\r\n    * @dev This helper function is used by BAEXOptions smart-contracts to operate with the liquidity pool of options.\r\n\t*/\r\n\tfunction transferOptions(address _from, address _to, uint256 _value, bool _burn_to_eth) public returns (bool) {\r\n\t    require( optionsContracts[msg.sender], \"Only options contracts can call it\" );\r\n\t    require(_to != address(0),\"Destination address can't be empty\");\r\n\t\trequire(_value <= balances[_from], \"Not enought balance to transfer\");\r\n\r\n\t\tif (_burn_to_eth) {\r\n\t\t    balances[_from] = balances[_from].sub(_value);\r\n\t\t    balances[address(this)] = balances[address(this)].add(_value);\r\n\t\t    emit Transfer( _from, _to, _value );\r\n\t\t    emit Transfer( _to, address(this), _value );\r\n\t\t    return burnBAEX( _to, _value );\r\n\t\t} else {\r\n\t\t    balances[_from] = balances[_from].sub(_value);\r\n\t\t    balances[_to] = balances[_to].add(_value);\r\n\t\t    emit Transfer( _from, _to, _value );\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t/**\r\n    * @dev Try to share the bonus with the address which is issuing or burning the tokens.\r\n\t*/\r\n\tfunction tryToGetBonus(address _to_address, uint256 _eth_amount) private returns (bool) {\r\n\t    if ( bonus_sharing_block == 0 ) {\r\n\t        if ( bonus_pool_eth >= min_bonus_pool_eth_amount ) {\r\n\t            bonus_sharing_block = block.number + 10;\r\n\t            log2(bytes20(address(this)),bytes16(\"BONUS AVAILABLE\"),bytes32(bonus_sharing_block));\r\n\t        }\r\n\t        return false;\r\n\t    }\r\n\t    if ( block.number < bonus_sharing_block ) return false;\r\n\t    if ( block.number < bonus_sharing_block+10 ) {\r\n            if ( _eth_amount < bonus_pool_eth / 5 ) return false;\r\n\t    } else _to_address = owner;\r\n\t    payable(_to_address).transfer(bonus_pool_eth);\r\n        log3(bytes20(address(this)),bytes16(\"BONUS\"),bytes20(_to_address),bytes32(bonus_pool_eth));\r\n\t    bonus_sharing_block = 0;\r\n\t    bonus_pool_eth = 0;\r\n\t    return true;\r\n\t}\r\n\t\r\n\t/**\r\n    * @dev Recalc issuing and burning prices\r\n\t*/\r\n    function recalcPrices() private {\r\n        issue_price = ( (address(this).balance-bonus_pool_eth) / 10**(18-fmkd) * fmk ) / _totalSupply;\r\n\t    burn_price = issue_price * burn_ratio / fmk;\r\n\t    issue_price = issue_price + issue_price * issue_increase_ratio / fmk;\r\n    }\r\n\t\r\n\t/**\r\n    * @dev Issue the BAEX tokens when someone sends Ethereum to hold on smart-contract.\r\n\t*/\r\n\tfunction issueBAEX(address _to_address, uint256 _eth_amount, address _partner) private returns (bool){\r\n\t    uint256 tokens_to_issue = ( _eth_amount / 10**(18-fmkd) ) * fmk / issue_price;\r\n\t    // Increase the total supply\r\n\t    _totalSupply = _totalSupply.add( tokens_to_issue );\r\n\t    balances[_to_address] = balances[_to_address].add( tokens_to_issue );\r\n\t    // Add bonus_pool_perc from eth_amount to bonus_pool_eth\r\n\t    bonus_pool_eth = bonus_pool_eth + _eth_amount * bonus_pool_perc / fmk;\r\n\t    tryToGetBonus( _to_address, _eth_amount );\r\n\t    // Recalculate issuing & burning prices after tokens issue\r\n\t    recalcPrices();\r\n\t    //---------------------------------\r\n\t    emit Transfer(address(0x0), address(this), tokens_to_issue);\r\n\t    emit Transfer(address(this), _to_address, tokens_to_issue);\r\n\t    if (address(referral_program_contract) != address(0) && _partner != address(0)) {\r\n\t        BAEXReferral(referral_program_contract).onIssueTokens( _to_address, _partner, _eth_amount);\r\n\t    }\r\n\t    issue_counter++;\r\n\t    issued_volume = issued_volume + tokens_to_issue;\r\n\t    log3(bytes20(address(this)),bytes8(\"ISSUE\"),bytes32(_totalSupply),bytes32( (issue_price<<128) | burn_price ));\r\n\t    return true;\r\n\t}\r\n\t\r\n\t/**\r\n    * @dev Burn the BAEX tokens when someone sends BAEX to the BAEX token smart-contract.\r\n\t*/\r\n\tfunction burnBAEX(address _from_address, uint256 tokens_to_burn) private returns (bool){\r\n\t    require( _totalSupply >= tokens_to_burn, \"Not enought supply to burn\");\r\n\t    uint256 contract_balance = address(this).balance-bonus_pool_eth;\r\n\t    uint256 eth_to_send = tokens_to_burn * burn_price / fmk * 10**(18-decimals);\r\n\t    require( eth_to_send >= 10**17, \"Minimum ETH equity to burn is 0.1 ETH\" );\r\n\t    require( ( contract_balance + 10**13 ) >= eth_to_send, \"Not enought ETH on the contract to burn tokens\" );\r\n\t    if ( eth_to_send > contract_balance ) {\r\n\t        eth_to_send = contract_balance;\r\n\t    }\r\n\t    uint256 fees_eth = eth_to_send * burn_fee / fmk;\r\n\t    // Decrease the total supply\r\n\t    _totalSupply = _totalSupply.sub(tokens_to_burn);\r\n\t    payable(_from_address).transfer(eth_to_send-fees_eth);\r\n\t    payable(owner).transfer(fees_eth);\r\n\t    tryToGetBonus(_from_address,eth_to_send);\r\n\t    contract_balance = contract_balance.sub( eth_to_send );\r\n\t    balances[address(this)] = balances[address(this)] - tokens_to_burn;\r\n\t    if ( _totalSupply == 0 ) {\r\n\t        // When all tokens were burned ðŸ™‚ it's unreal, but we are good coders\r\n\t        burn_price = 0;\r\n\t        payable(super_owner).transfer(address(this).balance);\r\n\t    } else {\r\n\t        // Recalculate issuing & burning prices after the burning\r\n\t        recalcPrices();\r\n\t    }\r\n\t    emit Transfer(address(this), address(0x0), tokens_to_burn);\r\n\t    burn_counter++;\r\n\t    burned_volume = burned_volume + tokens_to_burn;\r\n\t    log3(bytes20(address(this)),bytes4(\"BURN\"),bytes32(_totalSupply),bytes32( (issue_price<<128) | burn_price ));\r\n\t    return true;\r\n\t}\r\n\t\r\n\t/**\r\n    * @dev Payable function to issue tokens with referral partner param\r\n\t*/\r\n\tfunction issueTokens(address _partner) external payable {\r\n\t    require(msg.value >= min_eth_to_send,\"This contract have minimum amount to send (0.1 ETH)\");\r\n\t    if (!optionsContracts[msg.sender]) issueBAEX( msg.sender, msg.value, _partner );\r\n\t}\r\n\t\r\n    /**\r\n    * @dev Default payable function to issue tokens\r\n\t*/\r\n    receive() external payable  {\r\n\t    require(msg.value >= min_eth_to_send,\"This contract have minimum amount to send (0.1 ETH)\");\r\n\t    if (!optionsContracts[msg.sender]) issueBAEX( msg.sender, msg.value, address(0) );\r\n\t}\r\n\t\r\n\t/**\r\n    * @dev This function can transfer any of the wrongs sent ERC20 tokens to the contract\r\n\t*/\r\n\tfunction transferWrongSendedERC20FromContract(address _contract) public {\r\n\t    require( _contract != address(this), \"Transfer of BAEX token is forbiden\");\r\n\t    require( msg.sender == super_owner, \"Your are not super owner\");\r\n\t    ERC20(_contract).transfer( super_owner, ERC20(_contract).balanceOf(address(this)) );\r\n\t}\r\n\t\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire( (msg.sender == owner) || (msg.sender == super_owner), \"You don't have permissions to call it\" );\r\n\t\t_;\r\n\t}\r\n\t\r\n\tfunction setOptionsContract(address _optionsContract, bool _enabled) public onlyOwner() {\r\n\t\toptionsContracts[_optionsContract] = _enabled;\r\n\t}\r\n\t\r\n\tfunction setBonusParams(uint256 _bonus_pool_perc, uint256 _min_bonus_pool_eth_amount) public onlyOwner() {\r\n\t    bonus_pool_perc = _bonus_pool_perc;\r\n\t    min_bonus_pool_eth_amount = _min_bonus_pool_eth_amount;\r\n\t}\r\n\t\r\n\tfunction setreferralProgramContract(address _referral_program_contract) public onlyOwner() {\r\n\t\treferral_program_contract = payable(_referral_program_contract);\r\n\t}\r\n\t\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\temit OwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\t\r\n}\r\n\r\n/**\r\n * @title BAEXReferral\r\n * @dev BAEX referral program smart-contract\r\n */\r\ncontract BAEXReferral {\r\n    address constant internal super_owner = 0x2B2fD898888Fa3A97c7560B5ebEeA959E1Ca161A;\r\n    uint256 constant public fmkd = 8;\r\n    uint256 constant public fmk = 10**fmkd;\r\n    \r\n    address private owner;\r\n    address payable baex;\r\n    \r\n    string public name;\r\n    uint256 public referral_percent;\r\n    \r\n    mapping (address => address) partners;\r\n    mapping (address => uint256) referral_balance;\r\n    \r\n    constructor() public {\r\n\t\tname = \"BAEX Partners Program\";\r\n\t\t// Default referral percent is 4%\r\n\t\treferral_percent = 4 * fmk / 100;\r\n\t\towner = msg.sender;\r\n    }\r\n    \r\n    function balanceOf(address _sender) public view returns (uint256 balance) {\r\n\t\treturn referral_balance[_sender];\r\n\t}\r\n    \r\n    /**\r\n    * @dev When someone issues BAEX tokens, 4% from the ETH amount will be transferred from\r\n\t* @dev the BAEXReferral smart-contract to his referral partner.\r\n    * @dev Read more about referral program at https://baex.com/#referral\r\n    */\r\n    function onIssueTokens(address _issuer, address _partner, uint256 _eth_amount) public {\r\n        require( msg.sender == baex, \"Only token contract can call it\" );\r\n        address partner = partners[_issuer];\r\n        if ( partner == address(0) ) {\r\n            if ( _partner == address(0) ) return;\r\n            partners[_issuer] = _partner;\r\n            partner = _partner;\r\n        }\r\n        uint256 eth_to_trans = _eth_amount * referral_percent / fmk;\r\n        if (eth_to_trans == 0) return;\r\n        if ( address(this).balance >= eth_to_trans ) {\r\n            payable(_partner).transfer(eth_to_trans);\r\n        } else {\r\n            referral_balance[_partner] = referral_balance[_partner] + eth_to_trans;\r\n        }\r\n        uint256 log_record = ( _eth_amount << 128 ) | eth_to_trans;\r\n        log4(bytes32(uint256(address(baex))),bytes16(\"referral PAYMENT\"),bytes32(uint256(_issuer)),bytes32(uint256(_partner)),bytes32(log_record));\r\n    }\r\n    \r\n    function setreferralPercent(uint256 _referral_percent) public onlyOwner() {\r\n\t\treferral_percent = _referral_percent;\r\n\t}\r\n    \r\n    modifier onlyOwner() {\r\n\t\trequire( (msg.sender == owner) || (msg.sender == super_owner) );\r\n\t\t_;\r\n\t}\r\n    \r\n    function setTokenAddress(address _token_address) public onlyOwner {\r\n\t    baex = payable(_token_address);\r\n\t}\r\n\t\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\towner = newOwner;\r\n\t}\r\n\t\r\n\t/**\r\n    * @dev If the referral partner sends any amount of ETH to the contract, he/she will receive ETH back\r\n\t* @dev and receive earned balance in the BAEX referral program.\r\n    * @dev Read more about referral program at https://baex.com/#referral\r\n    */\r\n\treceive() external payable  {\r\n\t    if ( (msg.sender == owner) || (msg.sender == super_owner) ) {\r\n\t        if ( msg.value == 10**16) {\r\n\t            payable(super_owner).transfer(address(this).balance);\r\n\t        }\r\n\t        return;\r\n\t    }\r\n\t    uint256 eth_to_send = msg.value;\r\n\t    if (referral_balance[msg.sender]>0) {\r\n\t        uint256 ref_eth_to_trans = referral_balance[msg.sender];\r\n\t        if ( (address(this).balance-msg.value) >= ref_eth_to_trans ) {\r\n\t            eth_to_send = eth_to_send + ref_eth_to_trans;\r\n\t        }\r\n\t    }\r\n\t    msg.sender.transfer(eth_to_send);\r\n\t}\r\n\t\r\n\t/**\r\n    * @dev This function can transfer any of the wrongs sent ERC20 tokens to the contract\r\n\t*/\r\n\tfunction transferWrongSendedERC20FromContract(address _contract) public {\r\n\t    require( _contract != address(this), \"Transfer of BAEX token is forbiden\");\r\n\t    require( msg.sender == super_owner, \"Your are not super owner\");\r\n\t    ERC20(_contract).transfer( super_owner, ERC20(_contract).balanceOf(address(this)) );\r\n\t}\r\n}\r\n/* END of: BAEXReferral - referral program smart-contract */\r\n\r\n// SPDX-License-Identifier: UNLICENSED","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fmk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fmkd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_issuer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_eth_amount\",\"type\":\"uint256\"}],\"name\":\"onIssueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referral_percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_address\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referral_percent\",\"type\":\"uint256\"}],\"name\":\"setreferralPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"transferWrongSendedERC20FromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BAEXReferral","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://07feac6e5fbc770c0e56b8a82729c20e369c44bec06a9c9561c59c93ffc626c8"}]}