{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// This is the ETH/ERC20 multisig contract for Ownbit.\r\n//\r\n// For 2-of-3 multisig, to authorize a spend, two signtures must be provided by 2 of the 3 owners.\r\n// To generate the message to be signed, provide the destination address and\r\n// spend amount (in wei) to the generateMessageToSign method.\r\n// The signatures must be provided as the (v, r, s) hex-encoded coordinates.\r\n// The S coordinate must be 0x00 or 0x01 corresponding to 0x1b and 0x1c, respectively.\r\n//\r\n// WARNING: The generated message is only valid until the next spend is executed.\r\n//          after that, a new message will need to be calculated.\r\n//\r\n//\r\n// INFO: This contract is ERC20 compatible.\r\n// This contract can both receive ETH and ERC20 tokens.\r\n// Notice that NFT (ERC721/ERC1155) is not supported yet.\r\n// Add support for DeFi (Compound)\r\n\r\ninterface Erc20 {\r\n    function approve(address, uint256);\r\n\r\n    function transfer(address, uint256);\r\n}\r\n\r\ninterface CErc20 {\r\n    function mint(uint256) external returns (uint256);\r\n\r\n    function redeem(uint) external returns (uint);\r\n\r\n    function redeemUnderlying(uint) external returns (uint);\r\n}\r\n\r\ninterface CEth {\r\n    function mint() external payable;\r\n\r\n    function redeem(uint) external returns (uint);\r\n\r\n    function redeemUnderlying(uint) external returns (uint);\r\n}\r\n\r\ncontract OwnbitMultiSig {\r\n    \r\n    uint constant public MAX_OWNER_COUNT = 9;\r\n\r\n  // The N addresses which control the funds in this contract.  The\r\n  // owners of M of these addresses will need to both sign a message\r\n  // allowing the funds in this contract to be spent.\r\n  mapping(address => bool) private isOwner;\r\n  address[] private owners;\r\n  uint private required;\r\n\r\n  // The contract nonce is not accessible to the contract so we\r\n  // implement a nonce-like variable for replay protection.\r\n  uint256 private spendNonce = 0;\r\n  \r\n  // An event sent when funds are received.\r\n  event Funded(uint new_balance);\r\n  \r\n  // An event sent when a spend is triggered to the given address.\r\n  event Spent(address to, uint transfer);\r\n  \r\n  // An event sent when a spend is triggered to the given address.\r\n  event SpentErc20(address erc20contract, address to, uint transfer);\r\n\r\n  modifier validRequirement(uint ownerCount, uint _required) {\r\n        require (ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required > 0);\r\n        _;\r\n    }\r\n  \r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    constructor(address[] _owners, uint _required) public validRequirement(_owners.length, _required) {\r\n        for (uint i = 0; i < _owners.length; i++) {\r\n            //onwer should be distinct, and non-zero\r\n            if (isOwner[_owners[i]] || _owners[i] == 0) {\r\n                revert();\r\n            }\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n\r\n    // The fallback function for this contract.\r\n    function() public payable {\r\n        emit Funded(address(this).balance);\r\n    }\r\n  \r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners() public constant returns (address[]) {\r\n        return owners;\r\n    }\r\n    \r\n    function getSpendNonce() public constant returns (uint256) {\r\n        return spendNonce;\r\n    }\r\n    \r\n    function getRequired() public constant returns (uint) {\r\n        return required;\r\n    }\r\n\r\n  // Generates the message to sign given the output destination address and amount.\r\n  // includes this contract's address and a nonce for replay protection.\r\n  // One option to independently verify: https://leventozturk.com/engineering/sha3/ and select keccak\r\n  function generateMessageToSign(address erc20Contract, address destination, uint256 value) public constant returns (bytes32) {\r\n    require(destination != address(this));\r\n    //the sequence should match generateMultiSigV2 in JS\r\n    bytes32 message = keccak256(this, erc20Contract, destination, value, spendNonce);\r\n    return message;\r\n  }\r\n  \r\n  function _messageToRecover(address erc20Contract, address destination, uint256 value) private constant returns (bytes32) {\r\n    bytes32 hashedUnsignedMessage = generateMessageToSign(erc20Contract, destination, value);\r\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n    return keccak256(prefix,hashedUnsignedMessage);\r\n  }\r\n  \r\n  function spend(address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) public {\r\n    // This require is handled by generateMessageToSign()\r\n    // require(destination != address(this));\r\n    require(address(this).balance >= value);\r\n    require(_validSignature(0x0000000000000000000000000000000000000000, destination, value, vs, rs, ss));\r\n    spendNonce = spendNonce + 1;\r\n    //transfer will throw if fails\r\n    destination.transfer(value);\r\n    emit Spent(destination, value);\r\n  }\r\n  \r\n  // @erc20contract: the erc20 contract address.\r\n  // @destination: the token or ether receiver address.\r\n  // @value: the token or ether value, in wei or token minimum unit.\r\n  // @vs, rs, ss: the signatures\r\n  function spendERC20(address destination, address erc20contract, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) public {\r\n    // This require is handled by generateMessageToSign()\r\n    // require(destination != address(this));\r\n    //transfer erc20 token\r\n    //require(ERC20Interface(erc20contract).balanceOf(address(this)) >= value);\r\n    require(_validSignature(erc20contract, destination, value, vs, rs, ss));\r\n    spendNonce = spendNonce + 1;\r\n    // transfer tokens from this contract to the destination address\r\n    Erc20(erc20contract).transfer(destination, value);\r\n    emit SpentErc20(erc20contract, destination, value);\r\n  }\r\n\r\n\r\n    //cErc20Contract is just like the destination\r\n    function compoundAction(address cErc20Contract, address erc20contract, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) public {\r\n        CEth ethToken;\r\n        CErc20 erc20Token;\r\n        \r\n        if (erc20contract == 0x0000000000000000000000000000000000000001) {\r\n            require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss));\r\n            spendNonce = spendNonce + 1;\r\n            \r\n            //supply ETH\r\n            ethToken = CEth(cErc20Contract);\r\n            ethToken.mint.value(value).gas(250000)();\r\n        } else if (erc20contract == 0x0000000000000000000000000000000000000003) {\r\n            require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss));\r\n            spendNonce = spendNonce + 1;\r\n            \r\n            //redeem ETH\r\n            ethToken = CEth(cErc20Contract);\r\n            ethToken.redeem(value);\r\n        } else if (erc20contract == 0x0000000000000000000000000000000000000004) {\r\n            require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss));\r\n            spendNonce = spendNonce + 1;\r\n            \r\n            //redeem token\r\n            erc20Token = CErc20(cErc20Contract);\r\n            erc20Token.redeem(value);\r\n        } else if (erc20contract == 0x0000000000000000000000000000000000000005) {\r\n            require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss));\r\n            spendNonce = spendNonce + 1;\r\n            \r\n            //redeemUnderlying ETH\r\n            ethToken = CEth(cErc20Contract);\r\n            ethToken.redeemUnderlying(value);\r\n        } else if (erc20contract == 0x0000000000000000000000000000000000000006) {\r\n            require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss));\r\n            spendNonce = spendNonce + 1;\r\n            \r\n            //redeemUnderlying token\r\n            erc20Token = CErc20(cErc20Contract);\r\n            erc20Token.redeemUnderlying(value);\r\n        } else {\r\n            //Do not conflict with spendERC20\r\n            require(_validSignature(0x0000000000000000000000000000000000000002, cErc20Contract, value, vs, rs, ss));\r\n            spendNonce = spendNonce + 1;\r\n            \r\n            //supply token\r\n            // Create a reference to the underlying asset contract, like DAI.\r\n            Erc20 underlying = Erc20(erc20contract);\r\n            // Create a reference to the corresponding cToken contract, like cDAI\r\n            erc20Token = CErc20(cErc20Contract);\r\n            // Approve transfer on the ERC20 contract\r\n            underlying.approve(cErc20Contract, value);\r\n            // Mint cTokens\r\n            erc20Token.mint(value);\r\n        } \r\n    }\r\n    \r\n\r\n  // Confirm that the signature triplets (v1, r1, s1) (v2, r2, s2) ...\r\n  // authorize a spend of this contract's funds to the given\r\n  // destination address.\r\n  function _validSignature(address erc20Contract, address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) private constant returns (bool) {\r\n    require(vs.length == rs.length);\r\n    require(rs.length == ss.length);\r\n    require(vs.length <= owners.length);\r\n    require(vs.length >= required);\r\n    bytes32 message = _messageToRecover(erc20Contract, destination, value);\r\n    address[] memory addrs = new address[](vs.length);\r\n    for (uint i = 0; i < vs.length; i++) {\r\n        //recover the address associated with the public key from elliptic curve signature or return zero on error \r\n        addrs[i] = ecrecover(message, vs[i]+27, rs[i], ss[i]);\r\n    }\r\n    require(_distinctOwners(addrs));\r\n    return true;\r\n  }\r\n  \r\n  // Confirm the addresses as distinct owners of this contract.\r\n  function _distinctOwners(address[] addrs) private constant returns (bool) {\r\n    if (addrs.length > owners.length) {\r\n        return false;\r\n    }\r\n    for (uint i = 0; i < addrs.length; i++) {\r\n        if (!isOwner[addrs[i]]) {\r\n            return false;\r\n        }\r\n        //address should be distinct\r\n        for (uint j = 0; j < i; j++) {\r\n            if (addrs[i] == addrs[j]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"erc20contract\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"vs\",\"type\":\"uint8[]\"},{\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"name\":\"ss\",\"type\":\"bytes32[]\"}],\"name\":\"spendERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRequired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"vs\",\"type\":\"uint8[]\"},{\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"name\":\"ss\",\"type\":\"bytes32[]\"}],\"name\":\"spend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cErc20Contract\",\"type\":\"address\"},{\"name\":\"erc20contract\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"vs\",\"type\":\"uint8[]\"},{\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"name\":\"ss\",\"type\":\"bytes32[]\"}],\"name\":\"compoundAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSpendNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"erc20Contract\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"generateMessageToSign\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"new_balance\",\"type\":\"uint256\"}],\"name\":\"Funded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transfer\",\"type\":\"uint256\"}],\"name\":\"Spent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transfer\",\"type\":\"uint256\"}],\"name\":\"SpentErc20\",\"type\":\"event\"}]","ContractName":"OwnbitMultiSig","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000003c3f9ca2ea3b9261e153ee28e58e1c1d7a58603400000000000000000000000030e7e496285473958fcccba8b36977012145b2320000000000000000000000003750a96c88718568dcc8d7f71f35cf0d2ed4bee1","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a2ccf7247ba566f659b58f7d23539524a71175fd326a4dac4542735f863c5309"}]}