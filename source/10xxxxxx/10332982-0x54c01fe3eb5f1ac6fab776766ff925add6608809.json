{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.6;\r\n\r\ninterface AccessControllerInterface {\r\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title The Owned contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract Owned {\r\n\r\n  address payable public owner;\r\n  address private pendingOwner;\r\n\r\n  event OwnershipTransferRequested(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n  event OwnershipTransferred(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(address _to)\r\n    external\r\n    onlyOwner()\r\n  {\r\n    pendingOwner = _to;\r\n\r\n    emit OwnershipTransferRequested(owner, _to);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership()\r\n    external\r\n  {\r\n    require(msg.sender == pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = owner;\r\n    owner = msg.sender;\r\n    pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Only callable by owner\");\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function getRoundData(uint256 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint256 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint256 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint256 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint256 answeredInRound\r\n    );\r\n  function version() external view returns (uint256);\r\n}\r\n\r\n\r\ninterface AggregatorInterface {\r\n  function latestAnswer() external view returns (int256);\r\n  function latestTimestamp() external view returns (uint256);\r\n  function latestRound() external view returns (uint256);\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\r\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\r\n}\r\n\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external view returns (string memory tokenName);\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n\r\nlibrary SignedSafeMath {\r\n  int256 constant private _INT256_MIN = -2**255;\r\n\r\n  /**\r\n   * @dev Multiplies two signed integers, reverts on overflow.\r\n   */\r\n  function mul(int256 a, int256 b) internal pure returns (int256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n    int256 c = a * b;\r\n    require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n   */\r\n  function div(int256 a, int256 b) internal pure returns (int256) {\r\n    require(b != 0, \"SignedSafeMath: division by zero\");\r\n    require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n    int256 c = a / b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two signed integers, reverts on overflow.\r\n   */\r\n  function sub(int256 a, int256 b) internal pure returns (int256) {\r\n    int256 c = a - b;\r\n    require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two signed integers, reverts on overflow.\r\n   */\r\n  function add(int256 a, int256 b) internal pure returns (int256) {\r\n    int256 c = a + b;\r\n    require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @notice Computes average of two signed integers, ensuring that the computation\r\n   * doesn't overflow.\r\n   * @dev If the result is not an integer, it is rounded towards zero. For example,\r\n   * avg(-3, -4) = -3\r\n   */\r\n  function avg(int256 _a, int256 _b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n  {\r\n    if ((_a < 0 && _b > 0) || (_a > 0 && _b < 0)) {\r\n      return add(_a, _b) / 2;\r\n    }\r\n    int256 remainder = (_a % 2 + _b % 2) / 2;\r\n    return add(add(_a / 2, _b / 2), remainder);\r\n  }\r\n}\r\n\r\n\r\nlibrary Median {\r\n  using SignedSafeMath for int256;\r\n\r\n  int256 constant INT_MAX = 2**255-1;\r\n\r\n  /**\r\n   * @notice Returns the sorted middle, or the average of the two middle indexed items if the\r\n   * array has an even number of elements.\r\n   * @dev The list passed as an argument isn't modified.\r\n   * @dev This algorithm has expected runtime O(n), but for adversarially chosen inputs\r\n   * the runtime is O(n^2).\r\n   * @param list The list of elements to compare\r\n   */\r\n  function calculate(int256[] memory list)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n  {\r\n    return calculateInplace(copy(list));\r\n  }\r\n\r\n  /**\r\n   * @notice See documentation for function calculate.\r\n   * @dev The list passed as an argument may be permuted.\r\n   */\r\n  function calculateInplace(int256[] memory list)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n  {\r\n    require(0 < list.length, \"list must not be empty\");\r\n    uint256 len = list.length;\r\n    uint256 middleIndex = len / 2;\r\n    if (len % 2 == 0) {\r\n      int256 median1;\r\n      int256 median2;\r\n      (median1, median2) = quickselectTwo(list, 0, len - 1, middleIndex - 1, middleIndex);\r\n      return SignedSafeMath.avg(median1, median2);\r\n    } else {\r\n      return quickselect(list, 0, len - 1, middleIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Maximum length of list that shortSelectTwo can handle\r\n   */\r\n  uint256 constant SHORTSELECTTWO_MAX_LENGTH = 7;\r\n\r\n  /**\r\n   * @notice Select the k1-th and k2-th element from list of length at most 7\r\n   * @dev Uses an optimal sorting network\r\n   */\r\n  function shortSelectTwo(\r\n    int256[] memory list,\r\n    uint256 lo,\r\n    uint256 hi,\r\n    uint256 k1,\r\n    uint256 k2\r\n  )\r\n    private\r\n    pure\r\n    returns (int256 k1th, int256 k2th)\r\n  {\r\n    // Uses an optimal sorting network (https://en.wikipedia.org/wiki/Sorting_network)\r\n    // for lists of length 7. Network layout is taken from\r\n    // http://jgamble.ripco.net/cgi-bin/nw.cgi?inputs=7&algorithm=hibbard&output=svg\r\n\r\n    uint256 len = hi + 1 - lo;\r\n    int256 x0 = list[lo + 0];\r\n    int256 x1 = 1 < len ? list[lo + 1] : INT_MAX;\r\n    int256 x2 = 2 < len ? list[lo + 2] : INT_MAX;\r\n    int256 x3 = 3 < len ? list[lo + 3] : INT_MAX;\r\n    int256 x4 = 4 < len ? list[lo + 4] : INT_MAX;\r\n    int256 x5 = 5 < len ? list[lo + 5] : INT_MAX;\r\n    int256 x6 = 6 < len ? list[lo + 6] : INT_MAX;\r\n\r\n    if (x0 > x1) {(x0, x1) = (x1, x0);}\r\n    if (x2 > x3) {(x2, x3) = (x3, x2);}\r\n    if (x4 > x5) {(x4, x5) = (x5, x4);}\r\n    if (x0 > x2) {(x0, x2) = (x2, x0);}\r\n    if (x1 > x3) {(x1, x3) = (x3, x1);}\r\n    if (x4 > x6) {(x4, x6) = (x6, x4);}\r\n    if (x1 > x2) {(x1, x2) = (x2, x1);}\r\n    if (x5 > x6) {(x5, x6) = (x6, x5);}\r\n    if (x0 > x4) {(x0, x4) = (x4, x0);}\r\n    if (x1 > x5) {(x1, x5) = (x5, x1);}\r\n    if (x2 > x6) {(x2, x6) = (x6, x2);}\r\n    if (x1 > x4) {(x1, x4) = (x4, x1);}\r\n    if (x3 > x6) {(x3, x6) = (x6, x3);}\r\n    if (x2 > x4) {(x2, x4) = (x4, x2);}\r\n    if (x3 > x5) {(x3, x5) = (x5, x3);}\r\n    if (x3 > x4) {(x3, x4) = (x4, x3);}\r\n\r\n    uint256 index1 = k1 - lo;\r\n    if (index1 == 0) {k1th = x0;}\r\n    else if (index1 == 1) {k1th = x1;}\r\n    else if (index1 == 2) {k1th = x2;}\r\n    else if (index1 == 3) {k1th = x3;}\r\n    else if (index1 == 4) {k1th = x4;}\r\n    else if (index1 == 5) {k1th = x5;}\r\n    else if (index1 == 6) {k1th = x6;}\r\n    else {revert(\"k1 out of bounds\");}\r\n\r\n    uint256 index2 = k2 - lo;\r\n    if (k1 == k2) {return (k1th, k1th);}\r\n    else if (index2 == 0) {return (k1th, x0);}\r\n    else if (index2 == 1) {return (k1th, x1);}\r\n    else if (index2 == 2) {return (k1th, x2);}\r\n    else if (index2 == 3) {return (k1th, x3);}\r\n    else if (index2 == 4) {return (k1th, x4);}\r\n    else if (index2 == 5) {return (k1th, x5);}\r\n    else if (index2 == 6) {return (k1th, x6);}\r\n    else {revert(\"k2 out of bounds\");}\r\n  }\r\n\r\n  /**\r\n   * @notice Selects the k-th ranked element from list, looking only at indices between lo and hi\r\n   * (inclusive). Modifies list in-place.\r\n   */\r\n  function quickselect(int256[] memory list, uint256 lo, uint256 hi, uint256 k)\r\n    private\r\n    pure\r\n    returns (int256 kth)\r\n  {\r\n    require(lo <= k);\r\n    require(k <= hi);\r\n    while (lo < hi) {\r\n      if (hi - lo < SHORTSELECTTWO_MAX_LENGTH) {\r\n        int256 ignore;\r\n        (kth, ignore) = shortSelectTwo(list, lo, hi, k, k);\r\n        return kth;\r\n      }\r\n      uint256 pivotIndex = partition(list, lo, hi);\r\n      if (k <= pivotIndex) {\r\n        // since pivotIndex < (original hi passed to partition),\r\n        // termination is guaranteed in this case\r\n        hi = pivotIndex;\r\n      } else {\r\n        // since (original lo passed to partition) <= pivotIndex,\r\n        // termination is guaranteed in this case\r\n        lo = pivotIndex + 1;\r\n      }\r\n    }\r\n    return list[lo];\r\n  }\r\n\r\n  /**\r\n   * @notice Selects the k1-th and k2-th ranked elements from list, looking only at indices between\r\n   * lo and hi (inclusive). Modifies list in-place.\r\n   */\r\n  function quickselectTwo(\r\n    int256[] memory list,\r\n    uint256 lo,\r\n    uint256 hi,\r\n    uint256 k1,\r\n    uint256 k2\r\n  )\r\n    internal // for testing\r\n    pure\r\n    returns (int256 k1th, int256 k2th)\r\n  {\r\n    require(k1 < k2);\r\n    require(lo <= k1 && k1 <= hi);\r\n    require(lo <= k2 && k2 <= hi);\r\n\r\n    while (true) {\r\n      if (hi - lo < SHORTSELECTTWO_MAX_LENGTH) {\r\n        return shortSelectTwo(list, lo, hi, k1, k2);\r\n      }\r\n      uint256 pivotIdx = partition(list, lo, hi);\r\n      if (k2 <= pivotIdx) {\r\n        hi = pivotIdx;\r\n      } else if (pivotIdx < k1) {\r\n        lo = pivotIdx + 1;\r\n      } else {\r\n        assert(k1 <= pivotIdx && pivotIdx < k2);\r\n        k1th = quickselect(list, lo, pivotIdx, k1);\r\n        k2th = quickselect(list, pivotIdx + 1, hi, k2);\r\n        return (k1th, k2th);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Partitions list in-place using Hoare's partitioning scheme.\r\n   * Only elements of list between indices lo and hi (inclusive) will be modified.\r\n   * Returns an index i, such that:\r\n   * - lo <= i < hi\r\n   * - forall j in [lo, i]. list[j] <= list[i]\r\n   * - forall j in [i, hi]. list[i] <= list[j]\r\n   */\r\n  function partition(int256[] memory list, uint256 lo, uint256 hi)\r\n    private\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    // We don't care about overflow of the addition, because it would require a list\r\n    // larger than any feasible computer's memory.\r\n    int256 pivot = list[(lo + hi) / 2];\r\n    lo -= 1; // this can underflow. that's intentional.\r\n    hi += 1;\r\n    while (true) {\r\n      do {\r\n        lo += 1;\r\n      } while (list[lo] < pivot);\r\n      do {\r\n        hi -= 1;\r\n      } while (list[hi] > pivot);\r\n      if (lo < hi) {\r\n        (list[lo], list[hi]) = (list[hi], list[lo]);\r\n      } else {\r\n        // Let orig_lo and orig_hi be the original values of lo and hi passed to partition.\r\n        // Then, hi < orig_hi, because hi decreases *strictly* monotonically\r\n        // in each loop iteration and\r\n        // - either list[orig_hi] > pivot, in which case the first loop iteration\r\n        //   will achieve hi < orig_hi;\r\n        // - or list[orig_hi] <= pivot, in which case at least two loop iterations are\r\n        //   needed:\r\n        //   - lo will have to stop at least once in the interval\r\n        //     [orig_lo, (orig_lo + orig_hi)/2]\r\n        //   - (orig_lo + orig_hi)/2 < orig_hi\r\n        return hi;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Makes an in-memory copy of the array passed in\r\n   * @param list Reference to the array to be copied\r\n   */\r\n  function copy(int256[] memory list)\r\n    private\r\n    pure\r\n    returns(int256[] memory)\r\n  {\r\n    int256[] memory list2 = new int256[](list.length);\r\n    for (uint256 i = 0; i < list.length; i++) {\r\n      list2[i] = list[i];\r\n    }\r\n    return list2;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * This library is a version of Open Zeppelin's SafeMath, modified to support\r\n * unsigned 128 bit integers.\r\n */\r\nlibrary SafeMath128 {\r\n  /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n  function add(uint128 a, uint128 b) internal pure returns (uint128) {\r\n    uint128 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint128 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n  function mul(uint128 a, uint128 b) internal pure returns (uint128) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint128 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint128 a, uint128 b) internal pure returns (uint128) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint128 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint128 a, uint128 b) internal pure returns (uint128) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * This library is a version of Open Zeppelin's SafeMath, modified to support\r\n * unsigned 64 bit integers.\r\n */\r\nlibrary SafeMath64 {\r\n  /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n  function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    uint64 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint64 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n  function mul(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint64 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint64 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * This library is a version of Open Zeppelin's SafeMath, modified to support\r\n * unsigned 32 bit integers.\r\n */\r\nlibrary SafeMath32 {\r\n  /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint32 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint32 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint32 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The Prepaid Aggregator contract\r\n * @notice Node handles aggregating data pushed in from off-chain, and unlocks\r\n * payment for oracles as they report. Oracles' submissions are gathered in\r\n * rounds, with each round aggregating the submissions for each oracle into a\r\n * single answer. The latest aggregated answer is exposed as well as historical\r\n * answers and their updated at timestamp.\r\n */\r\ncontract FluxAggregator is AggregatorInterface, AggregatorV3Interface, Owned {\r\n  using SafeMath for uint256;\r\n  using SafeMath128 for uint128;\r\n  using SafeMath64 for uint64;\r\n  using SafeMath32 for uint32;\r\n\r\n  struct Round {\r\n    int256 answer;\r\n    uint64 startedAt;\r\n    uint64 updatedAt;\r\n    uint32 answeredInRound;\r\n    RoundDetails details;\r\n  }\r\n\r\n  struct RoundDetails {\r\n    int256[] submissions;\r\n    uint32 maxSubmissions;\r\n    uint32 minSubmissions;\r\n    uint32 timeout;\r\n    uint128 paymentAmount;\r\n  }\r\n\r\n  struct OracleStatus {\r\n    uint128 withdrawable;\r\n    uint32 startingRound;\r\n    uint32 endingRound;\r\n    uint32 lastReportedRound;\r\n    uint32 lastStartedRound;\r\n    int256 latestSubmission;\r\n    uint16 index;\r\n    address admin;\r\n    address pendingAdmin;\r\n  }\r\n\r\n  struct Requester {\r\n    bool authorized;\r\n    uint32 delay;\r\n    uint32 lastStartedRound;\r\n  }\r\n\r\n\r\n  LinkTokenInterface public linkToken;\r\n  uint128 public allocatedFunds;\r\n  uint128 public availableFunds;\r\n\r\n  // Round related params\r\n  uint128 public paymentAmount;\r\n  uint32 public maxSubmissionCount;\r\n  uint32 public minSubmissionCount;\r\n  uint32 public restartDelay;\r\n  uint32 public timeout;\r\n  uint8 public override decimals;\r\n  string public override description;\r\n\r\n  int256 immutable public minSubmissionValue;\r\n  int256 immutable public maxSubmissionValue;\r\n\r\n  uint256 constant public override version = 3;\r\n\r\n  /**\r\n   * @notice To ensure owner isn't withdrawing required funds as oracles are\r\n   * submitting updates, we enforce that the contract maintains a minimum\r\n   * reserve of RESERVE_ROUNDS * oracleCount() LINK earmarked for payment to\r\n   * oracles. (Of course, this doesn't prevent the contract from running out of\r\n   * funds without the owner's intervention.)\r\n   */\r\n  uint256 constant private RESERVE_ROUNDS = 2;\r\n  uint256 constant private MAX_ORACLE_COUNT = 77;\r\n  uint32 constant private ROUND_MAX = 2**32-1;\r\n\r\n  uint32 private reportingRoundId;\r\n  uint32 internal latestRoundId;\r\n  mapping(address => OracleStatus) private oracles;\r\n  mapping(uint32 => Round) internal rounds;\r\n  mapping(address => Requester) internal requesters;\r\n  address[] private oracleAddresses;\r\n\r\n  event AvailableFundsUpdated(\r\n    uint256 indexed amount\r\n  );\r\n  event RoundDetailsUpdated(\r\n    uint128 indexed paymentAmount,\r\n    uint32 indexed minSubmissionCount,\r\n    uint32 indexed maxSubmissionCount,\r\n    uint32 restartDelay,\r\n    uint32 timeout // measured in seconds\r\n  );\r\n  event OraclePermissionsUpdated(\r\n    address indexed oracle,\r\n    bool indexed whitelisted\r\n  );\r\n  event OracleAdminUpdated(\r\n    address indexed oracle,\r\n    address indexed newAdmin\r\n  );\r\n  event OracleAdminUpdateRequested(\r\n    address indexed oracle,\r\n    address admin,\r\n    address newAdmin\r\n  );\r\n  event SubmissionReceived(\r\n    int256 indexed submission,\r\n    uint32 indexed round,\r\n    address indexed oracle\r\n  );\r\n  event RequesterPermissionsSet(\r\n    address indexed requester,\r\n    bool authorized,\r\n    uint32 delay\r\n  );\r\n\r\n  /**\r\n   * @notice Deploy with the address of the LINK token and initial payment amount\r\n   * @dev Sets the LinkToken address and amount of LINK paid\r\n   * @param _link The address of the LINK token\r\n   * @param _paymentAmount The amount paid of LINK paid to each oracle per submission, in wei (units of 10⁻¹⁸ LINK)\r\n   * @param _timeout is the number of seconds after the previous round that are\r\n   * allowed to lapse before allowing an oracle to skip an unfinished round\r\n   */\r\n  constructor(\r\n    address _link,\r\n    uint128 _paymentAmount,\r\n    uint32 _timeout,\r\n    int256 _minSubmissionValue,\r\n    int256 _maxSubmissionValue,\r\n    uint8 _decimals,\r\n    string memory _description\r\n  ) public {\r\n    linkToken = LinkTokenInterface(_link);\r\n    paymentAmount = _paymentAmount;\r\n    timeout = _timeout;\r\n    minSubmissionValue = _minSubmissionValue;\r\n    maxSubmissionValue = _maxSubmissionValue;\r\n    decimals = _decimals;\r\n    description = _description;\r\n    rounds[0].updatedAt = uint64(block.timestamp.sub(uint256(_timeout)));\r\n  }\r\n\r\n  /**\r\n   * @notice called by oracles when they have witnessed a need to update\r\n   * @param _roundId is the ID of the round this submission pertains to\r\n   * @param _submission is the updated data that the oracle is submitting\r\n   */\r\n  function submit(uint256 _roundId, int256 _submission)\r\n    external\r\n  {\r\n    bytes memory error = validateOracleRound(msg.sender, uint32(_roundId));\r\n    require(_submission >= minSubmissionValue, \"value below minSubmissionValue\");\r\n    require(_submission <= maxSubmissionValue, \"value above maxSubmissionValue\");\r\n    require(error.length == 0, string(error));\r\n\r\n    oracleInitializeNewRound(uint32(_roundId));\r\n    recordSubmission(_submission, uint32(_roundId));\r\n    updateRoundAnswer(uint32(_roundId));\r\n    payOracle(uint32(_roundId));\r\n    deleteRoundDetails(uint32(_roundId));\r\n  }\r\n\r\n  /**\r\n   * @notice called by the owner to add new Oracles and update the round\r\n   * related parameters\r\n   * @param _oracles is the list of addresses of the new Oracles being added\r\n   * @param _admins is the admin addresses of the new respective _oracles list.\r\n   * Only this address is allowed to access the respective oracle's funds.\r\n   * @param _minSubmissions is the new minimum submission count for each round\r\n   * @param _maxSubmissions is the new maximum submission count for each round\r\n   * @param _restartDelay is the number of rounds an Oracle has to wait before\r\n   * they can initiate a round\r\n   */\r\n  function addOracles(\r\n    address[] calldata _oracles,\r\n    address[] calldata _admins,\r\n    uint32 _minSubmissions,\r\n    uint32 _maxSubmissions,\r\n    uint32 _restartDelay\r\n  )\r\n    external\r\n    onlyOwner()\r\n  {\r\n    require(_oracles.length == _admins.length, \"need same oracle and admin count\");\r\n    require(uint256(oracleCount()).add(_oracles.length) <= MAX_ORACLE_COUNT, \"max oracles allowed\");\r\n\r\n    for (uint256 i = 0; i < _oracles.length; i++) {\r\n      addOracle(_oracles[i], _admins[i]);\r\n    }\r\n\r\n    updateFutureRounds(paymentAmount, _minSubmissions, _maxSubmissions, _restartDelay, timeout);\r\n  }\r\n\r\n  /**\r\n   * @notice called by the owner to remove Oracles and update the round\r\n   * related parameters\r\n   * @param _oracles is the address of the Oracles being removed\r\n   * @param _minSubmissions is the new minimum submission count for each round\r\n   * @param _maxSubmissions is the new maximum submission count for each round\r\n   * @param _restartDelay is the number of rounds an Oracle has to wait before\r\n   * they can initiate a round\r\n   */\r\n  function removeOracles(\r\n    address[] calldata _oracles,\r\n    uint32 _minSubmissions,\r\n    uint32 _maxSubmissions,\r\n    uint32 _restartDelay\r\n  )\r\n    external\r\n    onlyOwner()\r\n  {\r\n    for (uint256 i = 0; i < _oracles.length; i++) {\r\n      removeOracle(_oracles[i]);\r\n    }\r\n\r\n    updateFutureRounds(paymentAmount, _minSubmissions, _maxSubmissions, _restartDelay, timeout);\r\n  }\r\n\r\n  /**\r\n   * @notice update the round and payment related parameters for subsequent\r\n   * rounds\r\n   * @param _paymentAmount is the payment amount for subsequent rounds\r\n   * @param _minSubmissions is the new minimum submission count for each round\r\n   * @param _maxSubmissions is the new maximum submission count for each round\r\n   * @param _restartDelay is the number of rounds an Oracle has to wait before\r\n   * they can initiate a round\r\n   */\r\n  function updateFutureRounds(\r\n    uint128 _paymentAmount,\r\n    uint32 _minSubmissions,\r\n    uint32 _maxSubmissions,\r\n    uint32 _restartDelay,\r\n    uint32 _timeout\r\n  )\r\n    public\r\n    onlyOwner()\r\n  {\r\n    uint32 oracleNum = oracleCount(); // Save on storage reads\r\n    require(_maxSubmissions >= _minSubmissions, \"max must equal/exceed min\");\r\n    require(oracleNum >= _maxSubmissions, \"max cannot exceed total\");\r\n    require(oracleNum == 0 || oracleNum > _restartDelay, \"delay cannot exceed total\");\r\n    require(availableFunds >= requiredReserve(_paymentAmount), \"insufficient funds for payment\");\r\n    if (oracleCount() > 0) {\r\n      require(_minSubmissions > 0, \"min must be greater than 0\");\r\n    }\r\n\r\n    paymentAmount = _paymentAmount;\r\n    minSubmissionCount = _minSubmissions;\r\n    maxSubmissionCount = _maxSubmissions;\r\n    restartDelay = _restartDelay;\r\n    timeout = _timeout;\r\n\r\n    emit RoundDetailsUpdated(\r\n      paymentAmount,\r\n      _minSubmissions,\r\n      _maxSubmissions,\r\n      _restartDelay,\r\n      _timeout\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice recalculate the amount of LINK available for payouts\r\n   */\r\n  function updateAvailableFunds()\r\n    public\r\n  {\r\n    uint128 pastAvailableFunds = availableFunds;\r\n\r\n    uint256 available = linkToken.balanceOf(address(this)).sub(allocatedFunds);\r\n    availableFunds = uint128(available);\r\n\r\n    if (pastAvailableFunds != available) {\r\n      emit AvailableFundsUpdated(available);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice returns the number of oracles\r\n   */\r\n  function oracleCount() public view returns (uint32) {\r\n    return uint32(oracleAddresses.length);\r\n  }\r\n\r\n  /**\r\n   * @notice returns an array of addresses containing the oracles on contract\r\n   */\r\n  function getOracles() external view returns (address[] memory) {\r\n    return oracleAddresses;\r\n  }\r\n\r\n  /**\r\n   * @notice get the most recently reported answer\r\n   * @dev deprecated. Use latestRoundData instead.\r\n   */\r\n  function latestAnswer()\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (int256)\r\n  {\r\n    return rounds[latestRoundId].answer;\r\n  }\r\n\r\n  /**\r\n   * @notice get the most recent updated at timestamp\r\n   * @dev deprecated. Use latestRoundData instead.\r\n   */\r\n  function latestTimestamp()\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return rounds[latestRoundId].updatedAt;\r\n  }\r\n\r\n  /**\r\n   * @notice get the ID of the last updated round\r\n   * @dev deprecated. Use latestRoundData instead.\r\n   */\r\n  function latestRound()\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return latestRoundId;\r\n  }\r\n\r\n  /**\r\n   * @notice get the ID of the round most recently reported on\r\n   */\r\n  function reportingRound()\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return reportingRoundId;\r\n  }\r\n\r\n  /**\r\n   * @notice get past rounds answers\r\n   * @param _roundId the round number to retrieve the answer for\r\n   * @dev deprecated. Use getRoundData instead.\r\n   */\r\n  function getAnswer(uint256 _roundId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (int256)\r\n  {\r\n    return rounds[uint32(_roundId)].answer;\r\n  }\r\n\r\n  /**\r\n   * @notice get timestamp when an answer was last updated\r\n   * @param _roundId the round number to retrieve the updated timestamp for\r\n   * @dev deprecated. Use getRoundData instead.\r\n   */\r\n  function getTimestamp(uint256 _roundId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return rounds[uint32(_roundId)].updatedAt;\r\n  }\r\n\r\n  /**\r\n   * @notice get data about a round. Consumers are encouraged to check\r\n   * that they're receiving fresh data by inspecting the updatedAt and\r\n   * answeredInRound return values.\r\n   * @param _roundId the round ID to retrieve the round data for\r\n   * @return roundId is the round ID for which data was retrieved\r\n   * @return answer is the answer for the given round\r\n   * @return startedAt is the timestamp when the round was started. This is 0\r\n   * if the round hasn't been started yet.\r\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\r\n   * answer was last computed)\r\n   * @return answeredInRound is the round ID of the round in which the answer\r\n   * was computed. answeredInRound may be smaller than roundId when the round\r\n   * timed out. answerInRound is equal to roundId when the round didn't time out\r\n   * and was completed regularly.\r\n   * @dev Note that for in-progress rounds (i.e. rounds that haven't yet received\r\n   * maxSubmissions) answer and updatedAt may change between queries.\r\n   */\r\n  function getRoundData(uint256 _roundId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (\r\n      uint256 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint256 answeredInRound\r\n    )\r\n  {\r\n    Round memory r = rounds[uint32(_roundId)];\r\n    return (\r\n      _roundId,\r\n      r.answer,\r\n      r.startedAt,\r\n      r.updatedAt,\r\n      r.answeredInRound\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice get data about the latest round. Consumers are encouraged to check\r\n   * that they're receiving fresh data by inspecting the updatedAt and\r\n   * answeredInRound return values. Consumers are encouraged to\r\n   * use this more fully featured method over the \"legacy\" getAnswer/\r\n   * latestAnswer/getTimestamp/latestTimestamp functions.\r\n   * @return roundId is the round ID for which data was retrieved\r\n   * @return answer is the answer for the given round\r\n   * @return startedAt is the timestamp when the round was started. This is 0\r\n   * if the round hasn't been started yet.\r\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\r\n   * answer was last computed)\r\n   * @return answeredInRound is the round ID of the round in which the answer\r\n   * was computed. answeredInRound may be smaller than roundId when the round\r\n   * timed out. answerInRound is equal to roundId when the round didn't time out\r\n   * and was completed regularly.\r\n   * @dev Note that for in-progress rounds (i.e. rounds that haven't yet received\r\n   * maxSubmissions) answer and updatedAt may change between queries.\r\n   */\r\n   function latestRoundData()\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (\r\n      uint256 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint256 answeredInRound\r\n    )\r\n  {\r\n    return getRoundData(latestRoundId);\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice query the available amount of LINK for an oracle to withdraw\r\n   */\r\n  function withdrawablePayment(address _oracle)\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return oracles[_oracle].withdrawable;\r\n  }\r\n\r\n  /**\r\n   * @notice transfers the oracle's LINK to another address. Can only be called\r\n   * by the oracle's admin.\r\n   * @param _oracle is the oracle whose LINK is transferred\r\n   * @param _recipient is the address to send the LINK to\r\n   * @param _amount is the amount of LINK to send\r\n   */\r\n  function withdrawPayment(address _oracle, address _recipient, uint256 _amount)\r\n    external\r\n  {\r\n    require(oracles[_oracle].admin == msg.sender, \"only callable by admin\");\r\n\r\n    // Safe to downcast _amount because the total amount of LINK is less than 2^128.\r\n    uint128 amount = uint128(_amount);\r\n    uint128 available = oracles[_oracle].withdrawable;\r\n    require(available >= amount, \"insufficient withdrawable funds\");\r\n\r\n    oracles[_oracle].withdrawable = available.sub(amount);\r\n    allocatedFunds = allocatedFunds.sub(amount);\r\n\r\n    assert(linkToken.transfer(_recipient, uint256(amount)));\r\n  }\r\n\r\n  /**\r\n   * @notice transfers the owner's LINK to another address\r\n   * @param _recipient is the address to send the LINK to\r\n   * @param _amount is the amount of LINK to send\r\n   */\r\n  function withdrawFunds(address _recipient, uint256 _amount)\r\n    external\r\n    onlyOwner()\r\n  {\r\n    require(uint256(availableFunds).sub(requiredReserve(paymentAmount)) >= _amount, \"insufficient reserve funds\");\r\n    require(linkToken.transfer(_recipient, _amount), \"token transfer failed\");\r\n    updateAvailableFunds();\r\n  }\r\n\r\n  /**\r\n   * @notice get the latest submission for any oracle\r\n   * @param _oracle is the address to lookup the latest submission for\r\n   */\r\n  function latestSubmission(address _oracle)\r\n    external\r\n    view\r\n    returns (int256, uint256)\r\n  {\r\n    return (oracles[_oracle].latestSubmission, oracles[_oracle].lastReportedRound);\r\n  }\r\n\r\n  /**\r\n   * @notice get the admin address of an oracle\r\n   * @param _oracle is the address of the oracle whose admin is being queried\r\n   */\r\n  function getAdmin(address _oracle)\r\n    external\r\n    view\r\n    returns (address)\r\n  {\r\n    return oracles[_oracle].admin;\r\n  }\r\n\r\n  /**\r\n   * @notice transfer the admin address for an oracle\r\n   * @param _oracle is the address of the oracle whose admin is being transfered\r\n   * @param _newAdmin is the new admin address\r\n   */\r\n  function transferAdmin(address _oracle, address _newAdmin)\r\n    external\r\n  {\r\n    require(oracles[_oracle].admin == msg.sender, \"only callable by admin\");\r\n    oracles[_oracle].pendingAdmin = _newAdmin;\r\n\r\n    emit OracleAdminUpdateRequested(_oracle, msg.sender, _newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @notice accept the admin address transfer for an oracle\r\n   * @param _oracle is the address of the oracle whose admin is being transfered\r\n   */\r\n  function acceptAdmin(address _oracle)\r\n    external\r\n  {\r\n    require(oracles[_oracle].pendingAdmin == msg.sender, \"only callable by pending admin\");\r\n    oracles[_oracle].pendingAdmin = address(0);\r\n    oracles[_oracle].admin = msg.sender;\r\n\r\n    emit OracleAdminUpdated(_oracle, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice allows non-oracles to request a new round\r\n   */\r\n  function requestNewRound()\r\n    external\r\n  {\r\n    require(requesters[msg.sender].authorized, \"not authorized requester\");\r\n\r\n    uint32 current = reportingRoundId;\r\n    require(rounds[current].updatedAt > 0 || timedOut(current), \"prev round must be supersedable\");\r\n\r\n    requesterInitializeNewRound(current.add(1));\r\n  }\r\n\r\n  /**\r\n   * @notice allows the owner to specify new non-oracles to start new rounds\r\n   * @param _requester is the address to set permissions for\r\n   * @param _authorized is a boolean specifying whether they can start new rounds or not\r\n   * @param _delay is the number of rounds the requester must wait before starting another round\r\n   */\r\n  function setRequesterPermissions(address _requester, bool _authorized, uint32 _delay)\r\n    external\r\n    onlyOwner()\r\n  {\r\n    if (requesters[_requester].authorized == _authorized) return;\r\n\r\n    if (_authorized) {\r\n      requesters[_requester].authorized = _authorized;\r\n      requesters[_requester].delay = _delay;\r\n    } else {\r\n      delete requesters[_requester];\r\n    }\r\n\r\n    emit RequesterPermissionsSet(_requester, _authorized, _delay);\r\n  }\r\n\r\n  /**\r\n   * @notice called through LINK's transferAndCall to update available funds\r\n   * in the same transaction as the funds were transfered to the aggregator\r\n   * @param _data is mostly ignored. It is checked for length, to be sure\r\n   * nothing strange is passed in.\r\n   */\r\n  function onTokenTransfer(address, uint256, bytes calldata _data)\r\n    external\r\n  {\r\n    require(_data.length == 0, \"transfer doesn't accept calldata\");\r\n    updateAvailableFunds();\r\n  }\r\n\r\n  /**\r\n   * @notice a method to provide all current info oracles need. Intended only\r\n   * only to be callable by oracles. Not for use by contracts to read state.\r\n   * @param _oracle the address to look up information for.\r\n   */\r\n  function oracleRoundState(address _oracle, uint32 _queriedRoundId)\r\n    external\r\n    view\r\n    returns (\r\n      bool _eligibleToSubmit,\r\n      uint32 _roundId,\r\n      int256 _latestSubmission,\r\n      uint64 _startedAt,\r\n      uint64 _timeout,\r\n      uint128 _availableFunds,\r\n      uint32 _oracleCount,\r\n      uint128 _paymentAmount\r\n    )\r\n  {\r\n    require(msg.sender == tx.origin, \"off-chain reading only\");\r\n\r\n    if (_queriedRoundId > 0) {\r\n      Round storage round = rounds[_queriedRoundId];\r\n      return (\r\n        eligibleForSpecificRound(_oracle, _queriedRoundId),\r\n        _queriedRoundId,\r\n        oracles[_oracle].latestSubmission,\r\n        round.startedAt,\r\n        round.details.timeout,\r\n        availableFunds,\r\n        oracleCount(),\r\n        (round.startedAt > 0 ? round.details.paymentAmount : paymentAmount)\r\n      );\r\n    } else {\r\n      return oracleRoundStateSuggestRound(_oracle);\r\n    }\r\n  }\r\n\r\n  function eligibleForSpecificRound(address _oracle, uint32 _queriedRoundId)\r\n    private\r\n    view\r\n    returns (bool _eligible)\r\n  {\r\n    if (rounds[_queriedRoundId].startedAt > 0) {\r\n      return acceptingSubmissions(_queriedRoundId) && validateOracleRound(_oracle, _queriedRoundId).length == 0;\r\n    } else {\r\n      return delayed(_oracle, _queriedRoundId) && validateOracleRound(_oracle, _queriedRoundId).length == 0;\r\n    }\r\n  }\r\n\r\n  function oracleRoundStateSuggestRound(address _oracle)\r\n    private\r\n    view\r\n    returns (\r\n      bool _eligibleToSubmit,\r\n      uint32 _roundId,\r\n      int256 _latestSubmission,\r\n      uint64 _startedAt,\r\n      uint64 _timeout,\r\n      uint128 _availableFunds,\r\n      uint32 _oracleCount,\r\n      uint128 _paymentAmount\r\n    )\r\n  {\r\n    Round storage round = rounds[0];\r\n    OracleStatus storage oracle = oracles[_oracle];\r\n\r\n    bool shouldSupersede = oracle.lastReportedRound == reportingRoundId || !acceptingSubmissions(reportingRoundId);\r\n    // Instead of nudging oracles to submit to the next round, the inclusion of\r\n    // the shouldSupersede bool in the if condition pushes them towards\r\n    // submitting in a currently open round.\r\n    if (supersedable(reportingRoundId) && shouldSupersede) {\r\n      _roundId = reportingRoundId.add(1);\r\n      round = rounds[_roundId];\r\n\r\n      _paymentAmount = paymentAmount;\r\n      _eligibleToSubmit = delayed(_oracle, _roundId);\r\n    } else {\r\n      _roundId = reportingRoundId;\r\n      round = rounds[_roundId];\r\n\r\n      _paymentAmount = round.details.paymentAmount;\r\n      _eligibleToSubmit = acceptingSubmissions(_roundId);\r\n    }\r\n\r\n    if (validateOracleRound(_oracle, _roundId).length != 0) {\r\n      _eligibleToSubmit = false;\r\n    }\r\n\r\n    return (\r\n      _eligibleToSubmit,\r\n      _roundId,\r\n      oracle.latestSubmission,\r\n      round.startedAt,\r\n      round.details.timeout,\r\n      availableFunds,\r\n      oracleCount(),\r\n      _paymentAmount\r\n    );\r\n  }\r\n\r\n\r\n  /**\r\n   * Private\r\n   */\r\n\r\n  function initializeNewRound(uint32 _roundId)\r\n    private\r\n  {\r\n    updateTimedOutRoundInfo(_roundId.sub(1));\r\n\r\n    reportingRoundId = _roundId;\r\n    rounds[_roundId].details.maxSubmissions = maxSubmissionCount;\r\n    rounds[_roundId].details.minSubmissions = minSubmissionCount;\r\n    rounds[_roundId].details.paymentAmount = paymentAmount;\r\n    rounds[_roundId].details.timeout = timeout;\r\n    rounds[_roundId].startedAt = uint64(block.timestamp);\r\n\r\n    emit NewRound(_roundId, msg.sender, rounds[_roundId].startedAt);\r\n  }\r\n\r\n  function oracleInitializeNewRound(uint32 _roundId)\r\n    private\r\n  {\r\n    if (!newRound(_roundId)) return;\r\n    uint256 lastStarted = oracles[msg.sender].lastStartedRound; // cache storage reads\r\n    if (_roundId <= lastStarted + restartDelay && lastStarted != 0) return;\r\n\r\n    initializeNewRound(_roundId);\r\n\r\n    oracles[msg.sender].lastStartedRound = _roundId;\r\n  }\r\n\r\n  function requesterInitializeNewRound(uint32 _roundId)\r\n    private\r\n  {\r\n    if (!newRound(_roundId)) return;\r\n    uint256 lastStarted = requesters[msg.sender].lastStartedRound; // cache storage reads\r\n    require(_roundId > lastStarted + requesters[msg.sender].delay || lastStarted == 0, \"must delay requests\");\r\n\r\n    initializeNewRound(_roundId);\r\n\r\n    requesters[msg.sender].lastStartedRound = _roundId;\r\n  }\r\n\r\n  function updateTimedOutRoundInfo(uint32 _roundId)\r\n    private\r\n  {\r\n    if (!timedOut(_roundId)) return;\r\n\r\n    uint32 prevId = _roundId.sub(1);\r\n    rounds[_roundId].answer = rounds[prevId].answer;\r\n    rounds[_roundId].answeredInRound = rounds[prevId].answeredInRound;\r\n    rounds[_roundId].updatedAt = uint64(block.timestamp);\r\n\r\n    delete rounds[_roundId].details;\r\n  }\r\n\r\n  function updateRoundAnswer(uint32 _roundId)\r\n    private\r\n  {\r\n    if (rounds[_roundId].details.submissions.length < rounds[_roundId].details.minSubmissions) return;\r\n\r\n    int256 newAnswer = Median.calculateInplace(rounds[_roundId].details.submissions);\r\n    rounds[_roundId].answer = newAnswer;\r\n    rounds[_roundId].updatedAt = uint64(block.timestamp);\r\n    rounds[_roundId].answeredInRound = _roundId;\r\n    latestRoundId = _roundId;\r\n\r\n    emit AnswerUpdated(newAnswer, _roundId, now);\r\n  }\r\n\r\n  function payOracle(uint32 _roundId)\r\n    private\r\n  {\r\n    uint128 payment = rounds[_roundId].details.paymentAmount;\r\n    uint128 available = availableFunds.sub(payment);\r\n\r\n    availableFunds = available;\r\n    allocatedFunds = allocatedFunds.add(payment);\r\n    oracles[msg.sender].withdrawable = oracles[msg.sender].withdrawable.add(payment);\r\n\r\n    emit AvailableFundsUpdated(available);\r\n  }\r\n\r\n  function recordSubmission(int256 _submission, uint32 _roundId)\r\n    private\r\n  {\r\n    require(acceptingSubmissions(_roundId), \"round not accepting submissions\");\r\n\r\n    rounds[_roundId].details.submissions.push(_submission);\r\n    oracles[msg.sender].lastReportedRound = _roundId;\r\n    oracles[msg.sender].latestSubmission = _submission;\r\n\r\n    emit SubmissionReceived(_submission, _roundId, msg.sender);\r\n  }\r\n\r\n  function deleteRoundDetails(uint32 _roundId)\r\n    private\r\n  {\r\n    if (rounds[_roundId].details.submissions.length < rounds[_roundId].details.maxSubmissions) return;\r\n\r\n    delete rounds[_roundId].details;\r\n  }\r\n\r\n  function timedOut(uint32 _roundId)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    uint64 startedAt = rounds[_roundId].startedAt;\r\n    uint32 roundTimeout = rounds[_roundId].details.timeout;\r\n    return startedAt > 0 && roundTimeout > 0 && startedAt.add(roundTimeout) < block.timestamp;\r\n  }\r\n\r\n  function getStartingRound(address _oracle)\r\n    private\r\n    view\r\n    returns (uint32)\r\n  {\r\n    uint32 currentRound = reportingRoundId;\r\n    if (currentRound != 0 && currentRound == oracles[_oracle].endingRound) {\r\n      return currentRound;\r\n    }\r\n    return currentRound.add(1);\r\n  }\r\n\r\n  function previousAndCurrentUnanswered(uint32 _roundId, uint32 _rrId)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _roundId.add(1) == _rrId && rounds[_rrId].updatedAt == 0;\r\n  }\r\n\r\n  function requiredReserve(uint256 payment)\r\n    private\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return payment.mul(oracleCount()).mul(RESERVE_ROUNDS);\r\n  }\r\n\r\n  function addOracle(\r\n    address _oracle,\r\n    address _admin\r\n  )\r\n    private\r\n  {\r\n    require(!oracleEnabled(_oracle), \"oracle already enabled\");\r\n\r\n    require(_admin != address(0), \"cannot set admin to 0\");\r\n    require(oracles[_oracle].admin == address(0) || oracles[_oracle].admin == _admin, \"owner cannot overwrite admin\");\r\n\r\n    oracles[_oracle].startingRound = getStartingRound(_oracle);\r\n    oracles[_oracle].endingRound = ROUND_MAX;\r\n    oracles[_oracle].index = uint16(oracleAddresses.length);\r\n    oracleAddresses.push(_oracle);\r\n    oracles[_oracle].admin = _admin;\r\n\r\n    emit OraclePermissionsUpdated(_oracle, true);\r\n    emit OracleAdminUpdated(_oracle, _admin);\r\n  }\r\n\r\n  function removeOracle(\r\n    address _oracle\r\n  )\r\n    private\r\n  {\r\n    require(oracleEnabled(_oracle), \"oracle not enabled\");\r\n\r\n    oracles[_oracle].endingRound = reportingRoundId.add(1);\r\n    address tail = oracleAddresses[oracleCount().sub(1)];\r\n    uint16 index = oracles[_oracle].index;\r\n    oracles[tail].index = index;\r\n    delete oracles[_oracle].index;\r\n    oracleAddresses[index] = tail;\r\n    oracleAddresses.pop();\r\n\r\n    emit OraclePermissionsUpdated(_oracle, false);\r\n  }\r\n\r\n  function validateOracleRound(address _oracle, uint32 _roundId)\r\n    private\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    // cache storage reads\r\n    uint32 startingRound = oracles[_oracle].startingRound;\r\n    uint32 rrId = reportingRoundId;\r\n\r\n    if (startingRound == 0) return \"not enabled oracle\";\r\n    if (startingRound > _roundId) return \"not yet enabled oracle\";\r\n    if (oracles[_oracle].endingRound < _roundId) return \"no longer allowed oracle\";\r\n    if (oracles[_oracle].lastReportedRound >= _roundId) return \"cannot report on previous rounds\";\r\n    if (_roundId != rrId && _roundId != rrId.add(1) && !previousAndCurrentUnanswered(_roundId, rrId)) return \"invalid round to report\";\r\n    if (_roundId != 1 && !supersedable(_roundId.sub(1))) return \"previous round not supersedable\";\r\n  }\r\n\r\n  function supersedable(uint32 _roundId)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    return rounds[_roundId].updatedAt > 0 || timedOut(_roundId);\r\n  }\r\n\r\n  function oracleEnabled(address _oracle)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    return oracles[_oracle].endingRound == ROUND_MAX;\r\n  }\r\n\r\n  function acceptingSubmissions(uint32 _roundId)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    return rounds[_roundId].details.maxSubmissions != 0;\r\n  }\r\n\r\n  function delayed(address _oracle, uint32 _roundId)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    uint256 lastStarted = oracles[_oracle].lastStartedRound;\r\n    return _roundId > lastStarted + restartDelay || lastStarted == 0;\r\n  }\r\n\r\n  function newRound(uint32 _roundId)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _roundId == reportingRoundId.add(1);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SimpleAccessControl\r\n * @notice Allows the owner to set access for addresses\r\n */\r\ncontract SimpleAccessControl is AccessControllerInterface, Owned {\r\n\r\n  bool public checkEnabled;\r\n  mapping(address => bool) internal accessList;\r\n\r\n  event AddedAccess(address user);\r\n  event RemovedAccess(address user);\r\n  event CheckAccessEnabled();\r\n  event CheckAccessDisabled();\r\n\r\n  constructor()\r\n    public\r\n  {\r\n    checkEnabled = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the access of an address\r\n   * @param _user The address to query\r\n   */\r\n  function hasAccess(\r\n    address _user,\r\n    bytes memory\r\n  )\r\n    public\r\n    view\r\n    override\r\n    returns (bool)\r\n  {\r\n    return accessList[_user] || !checkEnabled || _user == tx.origin;\r\n  }\r\n\r\n  /**\r\n   * @notice Adds an address to the access list\r\n   * @param _user The address to add\r\n   */\r\n  function addAccess(address _user)\r\n    external\r\n    onlyOwner()\r\n  {\r\n    accessList[_user] = true;\r\n    emit AddedAccess(_user);\r\n  }\r\n\r\n  /**\r\n   * @notice Removes an address from the access list\r\n   * @param _user The address to remove\r\n   */\r\n  function removeAccess(address _user)\r\n    external\r\n    onlyOwner()\r\n  {\r\n    delete accessList[_user];\r\n    emit RemovedAccess(_user);\r\n  }\r\n\r\n  /**\r\n   * @notice makes the access check enforced\r\n   */\r\n  function enableAccessCheck()\r\n    external\r\n    onlyOwner()\r\n  {\r\n    checkEnabled = true;\r\n\r\n    emit CheckAccessEnabled();\r\n  }\r\n\r\n  /**\r\n   * @notice makes the access check unenforced\r\n   */\r\n  function disableAccessCheck()\r\n    external\r\n    onlyOwner()\r\n  {\r\n    checkEnabled = false;\r\n\r\n    emit CheckAccessDisabled();\r\n  }\r\n\r\n  /**\r\n   * @dev reverts if the caller does not have access\r\n   * @dev WARNING: This modifier should only be used on view methods\r\n   */\r\n  modifier checkAccess() {\r\n    require(hasAccess(msg.sender, msg.data), \"No access\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title AccessControlled FluxAggregator contract\r\n * @notice This contract requires addresses to be added to a controller\r\n * in order to read the answers stored in the FluxAggregator contract\r\n */\r\ncontract AccessControlledAggregator is FluxAggregator, SimpleAccessControl {\r\n\r\n  constructor(\r\n    address _link,\r\n    uint128 _paymentAmount,\r\n    uint32 _timeout,\r\n    int256 _minSubmissionValue,\r\n    int256 _maxSubmissionValue,\r\n    uint8 _decimals,\r\n    string memory _description\r\n  ) public FluxAggregator(\r\n    _link,\r\n    _paymentAmount,\r\n    _timeout,\r\n    _minSubmissionValue,\r\n    _maxSubmissionValue,\r\n    _decimals,\r\n    _description\r\n  ){}\r\n\r\n  /**\r\n   * @notice get the most recently reported answer\r\n   * @dev overridden funcion to add the checkAccess() modifier\r\n   * @dev deprecated. Use latestRoundData instead.\r\n   */\r\n  function latestAnswer()\r\n    public\r\n    view\r\n    override\r\n    checkAccess()\r\n    returns (int256)\r\n  {\r\n    return super.latestAnswer();\r\n  }\r\n\r\n  /**\r\n   * @notice get the most recent updated at timestamp\r\n   * @dev overridden funcion to add the checkAccess() modifier\r\n   * @dev deprecated. Use latestRoundData instead.\r\n   */\r\n  function latestTimestamp()\r\n    public\r\n    view\r\n    override\r\n    checkAccess()\r\n    returns (uint256)\r\n  {\r\n    return super.latestTimestamp();\r\n  }\r\n\r\n  /**\r\n   * @notice get past rounds answers\r\n   * @dev overridden funcion to add the checkAccess() modifier\r\n   * @param _roundId the round number to retrieve the answer for\r\n   * @dev deprecated. Use getRoundData instead.\r\n   */\r\n  function getAnswer(uint256 _roundId)\r\n    public\r\n    view\r\n    override\r\n    checkAccess()\r\n    returns (int256)\r\n  {\r\n    return super.getAnswer(_roundId);\r\n  }\r\n\r\n  /**\r\n   * @notice get timestamp when an answer was last updated\r\n   * @dev overridden funcion to add the checkAccess() modifier\r\n   * @param _roundId the round number to retrieve the updated timestamp for\r\n   * @dev deprecated. Use getRoundData instead.\r\n   */\r\n  function getTimestamp(uint256 _roundId)\r\n    public\r\n    view\r\n    override\r\n    checkAccess()\r\n    returns (uint256)\r\n  {\r\n    return super.getTimestamp(_roundId);\r\n  }\r\n\r\n  /**\r\n   * @notice get data about a round. Consumers are encouraged to check\r\n   * that they're receiving fresh data by inspecting the updatedAt and\r\n   * answeredInRound return values.\r\n   * @param _roundId the round ID to retrieve the round data for\r\n   * @return roundId is the round ID for which data was retrieved\r\n   * @return answer is the answer for the given round\r\n   * @return startedAt is the timestamp when the round was started. This is 0\r\n   * if the round hasn't been started yet.\r\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\r\n   * answer was last computed)\r\n   * @return answeredInRound is the round ID of the round in which the answer\r\n   * was computed. answeredInRound may be smaller than roundId when the round\r\n   * timed out. answerInRound is equal to roundId when the round didn't time out\r\n   * and was completed regularly.\r\n   * @dev Note that for in-progress rounds (i.e. rounds that haven't yet received\r\n   * maxSubmissions) answer and updatedAt may change between queries.\r\n   */\r\n  function getRoundData(uint256 _roundId)\r\n    public\r\n    view\r\n    override\r\n    checkAccess()\r\n    returns (\r\n      uint256 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint256 answeredInRound\r\n    )\r\n  {\r\n    return super.getRoundData(_roundId);\r\n  }\r\n\r\n  /**\r\n   * @notice get data about the latest round. Consumers are encouraged to check\r\n   * that they're receiving fresh data by inspecting the updatedAt and\r\n   * answeredInRound return values. Consumers are encouraged to\r\n   * use this more fully featured method over the \"legacy\" getAnswer/\r\n   * latestAnswer/getTimestamp/latestTimestamp functions. Consumers are\r\n   * encouraged to check that they're receiving fresh data by inspecting the\r\n   * updatedAt and answeredInRound return values.\r\n   * @return roundId is the round ID for which data was retrieved\r\n   * @return answer is the answer for the given round\r\n   * @return startedAt is the timestamp when the round was started. This is 0\r\n   * if the round hasn't been started yet.\r\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\r\n   * answer was last computed)\r\n   * @return answeredInRound is the round ID of the round in which the answer\r\n   * was computed. answeredInRound may be smaller than roundId when the round\r\n   * timed out. answerInRound is equal to roundId when the round didn't time out\r\n   * and was completed regularly.\r\n   * @dev Note that for in-progress rounds (i.e. rounds that haven't yet received\r\n   * maxSubmissions) answer and updatedAt may change between queries.\r\n   */\r\n  function latestRoundData()\r\n    public\r\n    view\r\n    override\r\n    checkAccess()\r\n    returns (\r\n      uint256 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint256 answeredInRound\r\n    )\r\n  {\r\n    return super.latestRoundData();\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_link\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_paymentAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_timeout\",\"type\":\"uint32\"},{\"internalType\":\"int256\",\"name\":\"_minSubmissionValue\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_maxSubmissionValue\",\"type\":\"int256\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AnswerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AvailableFundsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"startedBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"OracleAdminUpdateRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"OracleAdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"OraclePermissionsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RemovedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"authorized\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"delay\",\"type\":\"uint32\"}],\"name\":\"RequesterPermissionsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"paymentAmount\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"minSubmissionCount\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"maxSubmissionCount\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"restartDelay\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"}],\"name\":\"RoundDetailsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"submission\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"SubmissionReceived\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_oracles\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_admins\",\"type\":\"address[]\"},{\"internalType\":\"uint32\",\"name\":\"_minSubmissions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_maxSubmissions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_restartDelay\",\"type\":\"uint32\"}],\"name\":\"addOracles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocatedFunds\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableFunds\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOracles\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"answeredInRound\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"hasAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"answeredInRound\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"latestSubmission\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkToken\",\"outputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSubmissionCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSubmissionValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSubmissionCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSubmissionValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_queriedRoundId\",\"type\":\"uint32\"}],\"name\":\"oracleRoundState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_eligibleToSubmit\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"_roundId\",\"type\":\"uint32\"},{\"internalType\":\"int256\",\"name\":\"_latestSubmission\",\"type\":\"int256\"},{\"internalType\":\"uint64\",\"name\":\"_startedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_timeout\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"_availableFunds\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_oracleCount\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"_paymentAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentAmount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_oracles\",\"type\":\"address[]\"},{\"internalType\":\"uint32\",\"name\":\"_minSubmissions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_maxSubmissions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_restartDelay\",\"type\":\"uint32\"}],\"name\":\"removeOracles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reportingRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestNewRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restartDelay\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_requester\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_authorized\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"_delay\",\"type\":\"uint32\"}],\"name\":\"setRequesterPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"_submission\",\"type\":\"int256\"}],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeout\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAvailableFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_paymentAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_minSubmissions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_maxSubmissions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_restartDelay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_timeout\",\"type\":\"uint32\"}],\"name\":\"updateFutureRounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"withdrawablePayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AccessControlledAggregator","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000258000000000000000000000000000000000000000000000000000000174876e800000000000000000000000000000000000000000000000000000009184e72a000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000c2246545345202f20474250220000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fee95a6f210e458d4885d51dc069e62dac9ef4de46bcde85ea7ce9998f056088"}]}