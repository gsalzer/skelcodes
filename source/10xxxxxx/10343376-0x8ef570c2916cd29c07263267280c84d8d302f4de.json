{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/ReentrancyGuardEmber.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuardEmber is Initializable {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    function initialize() public initializer {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/upgrades/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Elliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n *\r\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/79dd498b16b957399f84b9aa7e720f98f9eb83e3/contracts/cryptography/ECDSA.sol\r\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\r\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\r\n * build/artifacts folder) as well as the vanilla implementation from an openzeppelin version.\r\n */\r\n\r\nlibrary OpenZeppelinUpgradesECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/access/roles/WhitelistAdminRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole is Initializable, Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    function initialize(address sender) public initializer {\r\n        if (!isWhitelistAdmin(sender)) {\r\n            _addWhitelistAdmin(sender);\r\n        }\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(_msgSender()), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/access/roles/WhitelistedRoleEmber.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import \"./WhitelistAdminRoleEmber.sol\";\r\n\r\n/**\r\n * @title WhitelistedRole\r\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\r\n * it), and not Whitelisteds themselves.\r\n */\r\ncontract WhitelistedRoleEmber is Initializable, Context, WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(_msgSender()), \"WhitelistedRole: caller does not have the Whitelisted role\");\r\n        _;\r\n    }\r\n\r\n    function initialize(address sender) public initializer {\r\n        WhitelistAdminRole.initialize(sender);\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function addSignedWhitelisted(address account, bytes memory signature) public {\r\n        address signer = getWhitelistedRoleActionSigner('addSignedWhitelisted', account, signature);\r\n        require(signer != address(0), \"Invalid signature\");\r\n        require(isWhitelistAdmin(signer), \"signer is not an admin\");\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function addSignedWhitelistAdmin(address account, bytes memory signature) public {\r\n        address signer = getWhitelistedRoleActionSigner('addSignedWhitelistAdmin', account, signature);\r\n        require(signer != address(0), \"Invalid signature\");\r\n        require(isWhitelistAdmin(signer), \"signer is not an admin\");\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function getWhitelistedRoleActionSigner(string memory action, address account, bytes memory _signature) private view returns (address) {\r\n      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(\r\n      keccak256(\r\n          abi.encodePacked(\r\n            action,\r\n            account,\r\n            address(this)\r\n          )\r\n        )\r\n      );\r\n      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(_msgSender());\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n *\r\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\r\n * metering changes introduced in the Istanbul hardfork.\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: set-protocol-contract-utils/contracts/lib/CommonMath.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\nlibrary CommonMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant SCALE_FACTOR = 10 ** 18;\r\n    uint256 public constant MAX_UINT_256 = 2 ** 256 - 1;\r\n\r\n    /**\r\n     * Returns scale factor equal to 10 ** 18\r\n     *\r\n     * @return  10 ** 18\r\n     */\r\n    function scaleFactor()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return SCALE_FACTOR;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUInt256()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return MAX_UINT_256;\r\n    }\r\n\r\n    /**\r\n     * Increases a value by the scale factor to allow for additional precision\r\n     * during mathematical operations\r\n     */\r\n    function scale(\r\n        uint256 a\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a.mul(SCALE_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * Divides a value by the scale factor to allow for additional precision\r\n     * during mathematical operations\r\n    */\r\n    function deScale(\r\n        uint256 a\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a.div(SCALE_FACTOR);\r\n    }\r\n\r\n    /**\r\n    * @dev Performs the power on a specified value, reverts on overflow.\r\n    */\r\n    function safePower(\r\n        uint256 a,\r\n        uint256 pow\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(a > 0);\r\n\r\n        uint256 result = 1;\r\n        for (uint256 i = 0; i < pow; i++){\r\n            uint256 previousResult = result;\r\n\r\n            // Using safemath multiplication prevents overflows\r\n            result = previousResult.mul(a);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n    * @dev Performs division where if there is a modulo, the value is rounded up\r\n    */\r\n    function divCeil(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return a.mod(b) > 0 ? a.div(b).add(1) : a.div(b);\r\n    }\r\n\r\n    /**\r\n     * Checks for rounding errors and returns value of potential partial amounts of a principal\r\n     *\r\n     * @param  _principal       Number fractional amount is derived from\r\n     * @param  _numerator       Numerator of fraction\r\n     * @param  _denominator     Denominator of fraction\r\n     * @return uint256          Fractional amount of principal calculated\r\n     */\r\n    function getPartialAmount(\r\n        uint256 _principal,\r\n        uint256 _numerator,\r\n        uint256 _denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Get remainder of partial amount (if 0 not a partial amount)\r\n        uint256 remainder = mulmod(_principal, _numerator, _denominator);\r\n\r\n        // Return if not a partial amount\r\n        if (remainder == 0) {\r\n            return _principal.mul(_numerator).div(_denominator);\r\n        }\r\n\r\n        // Calculate error percentage\r\n        uint256 errPercentageTimes1000000 = remainder.mul(1000000).div(_numerator.mul(_principal));\r\n\r\n        // Require error percentage is less than 0.1%.\r\n        require(\r\n            errPercentageTimes1000000 < 1000,\r\n            \"CommonMath.getPartialAmount: Rounding error exceeds bounds\"\r\n        );\r\n\r\n        return _principal.mul(_numerator).div(_denominator);\r\n    }\r\n\r\n    /*\r\n     * Gets the rounded up log10 of passed value\r\n     *\r\n     * @param  _value         Value to calculate ceil(log()) on\r\n     * @return uint256        Output value\r\n     */\r\n    function ceilLog10(\r\n        uint256 _value\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Make sure passed value is greater than 0\r\n        require (\r\n            _value > 0,\r\n            \"CommonMath.ceilLog10: Value must be greater than zero.\"\r\n        );\r\n\r\n        // Since log10(1) = 0, if _value = 1 return 0\r\n        if (_value == 1) return 0;\r\n\r\n        // Calcualte ceil(log10())\r\n        uint256 x = _value - 1;\r\n\r\n        uint256 result = 0;\r\n\r\n        if (x >= 10 ** 64) {\r\n            x /= 10 ** 64;\r\n            result += 64;\r\n        }\r\n        if (x >= 10 ** 32) {\r\n            x /= 10 ** 32;\r\n            result += 32;\r\n        }\r\n        if (x >= 10 ** 16) {\r\n            x /= 10 ** 16;\r\n            result += 16;\r\n        }\r\n        if (x >= 10 ** 8) {\r\n            x /= 10 ** 8;\r\n            result += 8;\r\n        }\r\n        if (x >= 10 ** 4) {\r\n            x /= 10 ** 4;\r\n            result += 4;\r\n        }\r\n        if (x >= 100) {\r\n            x /= 100;\r\n            result += 2;\r\n        }\r\n        if (x >= 10) {\r\n            result += 1;\r\n        }\r\n\r\n        return result + 1;\r\n    }\r\n}\r\n\r\n// File: set-protocol-contract-utils/contracts/lib/AddressArrayUtils.sol\r\n\r\n// Pulled in from Cryptofin Solidity package in order to control Solidity compiler version\r\n// https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\nlibrary AddressArrayUtils {\r\n\r\n    /**\r\n     * Finds the index of the first occurrence of the given element.\r\n     * @param A The input array to search\r\n     * @param a The value to find\r\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\r\n     */\r\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\r\n        uint256 length = A.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (A[i] == a) {\r\n                return (i, true);\r\n            }\r\n        }\r\n        return (0, false);\r\n    }\r\n\r\n    /**\r\n    * Returns true if the value is present in the list. Uses indexOf internally.\r\n    * @param A The input array to search\r\n    * @param a The value to find\r\n    * @return Returns isIn for the first occurrence starting from index 0\r\n    */\r\n    function contains(address[] memory A, address a) internal pure returns (bool) {\r\n        bool isIn;\r\n        (, isIn) = indexOf(A, a);\r\n        return isIn;\r\n    }\r\n\r\n    /**\r\n     * Returns the combination of the two arrays\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return Returns A extended by B\r\n     */\r\n    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        uint256 aLength = A.length;\r\n        uint256 bLength = B.length;\r\n        address[] memory newAddresses = new address[](aLength + bLength);\r\n        for (uint256 i = 0; i < aLength; i++) {\r\n            newAddresses[i] = A[i];\r\n        }\r\n        for (uint256 j = 0; j < bLength; j++) {\r\n            newAddresses[aLength + j] = B[j];\r\n        }\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n     * Returns the array with a appended to A.\r\n     * @param A The first array\r\n     * @param a The value to append\r\n     * @return Returns A appended by a\r\n     */\r\n    function append(address[] memory A, address a) internal pure returns (address[] memory) {\r\n        address[] memory newAddresses = new address[](A.length + 1);\r\n        for (uint256 i = 0; i < A.length; i++) {\r\n            newAddresses[i] = A[i];\r\n        }\r\n        newAddresses[A.length] = a;\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n     * Returns the intersection of two arrays. Arrays are treated as collections, so duplicates are kept.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return The intersection of the two arrays\r\n     */\r\n    function intersect(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        uint256 length = A.length;\r\n        bool[] memory includeMap = new bool[](length);\r\n        uint256 newLength = 0;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (contains(B, A[i])) {\r\n                includeMap[i] = true;\r\n                newLength++;\r\n            }\r\n        }\r\n        address[] memory newAddresses = new address[](newLength);\r\n        uint256 j = 0;\r\n        for (uint256 k = 0; k < length; k++) {\r\n            if (includeMap[k]) {\r\n                newAddresses[j] = A[k];\r\n                j++;\r\n            }\r\n        }\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n     * Returns the union of the two arrays. Order is not guaranteed.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return The union of the two arrays\r\n     */\r\n    function union(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        address[] memory leftDifference = difference(A, B);\r\n        address[] memory rightDifference = difference(B, A);\r\n        address[] memory intersection = intersect(A, B);\r\n        return extend(leftDifference, extend(intersection, rightDifference));\r\n    }\r\n\r\n    /**\r\n     * Computes the difference of two arrays. Assumes there are no duplicates.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return The difference of the two arrays\r\n     */\r\n    function difference(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\r\n        uint256 length = A.length;\r\n        bool[] memory includeMap = new bool[](length);\r\n        uint256 count = 0;\r\n        // First count the new length because can't push for in-memory arrays\r\n        for (uint256 i = 0; i < length; i++) {\r\n            address e = A[i];\r\n            if (!contains(B, e)) {\r\n                includeMap[i] = true;\r\n                count++;\r\n            }\r\n        }\r\n        address[] memory newAddresses = new address[](count);\r\n        uint256 j = 0;\r\n        for (uint256 k = 0; k < length; k++) {\r\n            if (includeMap[k]) {\r\n                newAddresses[j] = A[k];\r\n                j++;\r\n            }\r\n        }\r\n        return newAddresses;\r\n    }\r\n\r\n    /**\r\n    * Removes specified index from array\r\n    * Resulting ordering is not guaranteed\r\n    * @return Returns the new array and the removed entry\r\n    */\r\n    function pop(address[] memory A, uint256 index)\r\n        internal\r\n        pure\r\n        returns (address[] memory, address)\r\n    {\r\n        uint256 length = A.length;\r\n        address[] memory newAddresses = new address[](length - 1);\r\n        for (uint256 i = 0; i < index; i++) {\r\n            newAddresses[i] = A[i];\r\n        }\r\n        for (uint256 j = index + 1; j < length; j++) {\r\n            newAddresses[j - 1] = A[j];\r\n        }\r\n        return (newAddresses, A[index]);\r\n    }\r\n\r\n    /**\r\n     * @return Returns the new array\r\n     */\r\n    function remove(address[] memory A, address a)\r\n        internal\r\n        pure\r\n        returns (address[] memory)\r\n    {\r\n        (uint256 index, bool isIn) = indexOf(A, a);\r\n        if (!isIn) {\r\n            revert();\r\n        } else {\r\n            (address[] memory _A,) = pop(A, index);\r\n            return _A;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not there's a duplicate. Runs in O(n^2).\r\n     * @param A Array to search\r\n     * @return Returns true if duplicate, false otherwise\r\n     */\r\n    function hasDuplicate(address[] memory A) internal pure returns (bool) {\r\n        if (A.length == 0) {\r\n            return false;\r\n        }\r\n        for (uint256 i = 0; i < A.length - 1; i++) {\r\n            for (uint256 j = i + 1; j < A.length; j++) {\r\n                if (A[i] == A[j]) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the two arrays are equal.\r\n     * @param A The first array\r\n     * @param B The second array\r\n     * @return True is the arrays are equal, false if not.\r\n     */\r\n    function isEqual(address[] memory A, address[] memory B) internal pure returns (bool) {\r\n        if (A.length != B.length) {\r\n            return false;\r\n        }\r\n        for (uint256 i = 0; i < A.length; i++) {\r\n            if (A[i] != B[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/interfaces/ICore.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title ICore\r\n * @author Set Protocol\r\n *\r\n * The ICore Contract defines all the functions exposed in the Core through its\r\n * various extensions and is a light weight way to interact with the contract.\r\n */\r\ninterface ICore {\r\n    /**\r\n     * Return transferProxy address.\r\n     *\r\n     * @return address       transferProxy address\r\n     */\r\n    function transferProxy()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Return vault address.\r\n     *\r\n     * @return address       vault address\r\n     */\r\n    function vault()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Return address belonging to given exchangeId.\r\n     *\r\n     * @param  _exchangeId       ExchangeId number\r\n     * @return address           Address belonging to given exchangeId\r\n     */\r\n    function exchangeIds(\r\n        uint8 _exchangeId\r\n    )\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Returns if valid set\r\n     *\r\n     * @return  bool      Returns true if Set created through Core and isn't disabled\r\n     */\r\n    function validSets(address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /*\r\n     * Returns if valid module\r\n     *\r\n     * @return  bool      Returns true if valid module\r\n     */\r\n    function validModules(address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Return boolean indicating if address is a valid Rebalancing Price Library.\r\n     *\r\n     * @param  _priceLibrary    Price library address\r\n     * @return bool             Boolean indicating if valid Price Library\r\n     */\r\n    function validPriceLibraries(\r\n        address _priceLibrary\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Exchanges components for Set Tokens\r\n     *\r\n     * @param  _set          Address of set to issue\r\n     * @param  _quantity     Quantity of set to issue\r\n     */\r\n    function issue(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Issues a specified Set for a specified quantity to the recipient\r\n     * using the caller's components from the wallet and vault.\r\n     *\r\n     * @param  _recipient    Address to issue to\r\n     * @param  _set          Address of the Set to issue\r\n     * @param  _quantity     Number of tokens to issue\r\n     */\r\n    function issueTo(\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Converts user's components into Set Tokens held directly in Vault instead of user's account\r\n     *\r\n     * @param _set          Address of the Set\r\n     * @param _quantity     Number of tokens to redeem\r\n     */\r\n    function issueInVault(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Function to convert Set Tokens into underlying components\r\n     *\r\n     * @param _set          The address of the Set token\r\n     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\r\n     */\r\n    function redeem(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Redeem Set token and return components to specified recipient. The components\r\n     * are left in the vault\r\n     *\r\n     * @param _recipient    Recipient of Set being issued\r\n     * @param _set          Address of the Set\r\n     * @param _quantity     Number of tokens to redeem\r\n     */\r\n    function redeemTo(\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Function to convert Set Tokens held in vault into underlying components\r\n     *\r\n     * @param _set          The address of the Set token\r\n     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\r\n     */\r\n    function redeemInVault(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Composite method to redeem and withdraw with a single transaction\r\n     *\r\n     * Normally, you should expect to be able to withdraw all of the tokens.\r\n     * However, some have central abilities to freeze transfers (e.g. EOS). _toExclude\r\n     * allows you to optionally specify which component tokens to exclude when\r\n     * redeeming. They will remain in the vault under the users' addresses.\r\n     *\r\n     * @param _set          Address of the Set\r\n     * @param _to           Address to withdraw or attribute tokens to\r\n     * @param _quantity     Number of tokens to redeem\r\n     * @param _toExclude    Mask of indexes of tokens to exclude from withdrawing\r\n     */\r\n    function redeemAndWithdrawTo(\r\n        address _set,\r\n        address _to,\r\n        uint256 _quantity,\r\n        uint256 _toExclude\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deposit multiple tokens to the vault. Quantities should be in the\r\n     * order of the addresses of the tokens being deposited.\r\n     *\r\n     * @param  _tokens           Array of the addresses of the ERC20 tokens\r\n     * @param  _quantities       Array of the number of tokens to deposit\r\n     */\r\n    function batchDeposit(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Withdraw multiple tokens from the vault. Quantities should be in the\r\n     * order of the addresses of the tokens being withdrawn.\r\n     *\r\n     * @param  _tokens            Array of the addresses of the ERC20 tokens\r\n     * @param  _quantities        Array of the number of tokens to withdraw\r\n     */\r\n    function batchWithdraw(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deposit any quantity of tokens into the vault.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _quantity        The number of tokens to deposit\r\n     */\r\n    function deposit(\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Withdraw a quantity of tokens from the vault.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _quantity        The number of tokens to withdraw\r\n     */\r\n    function withdraw(\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfer tokens associated with the sender's account in vault to another user's\r\n     * account in vault.\r\n     *\r\n     * @param  _token           Address of token being transferred\r\n     * @param  _to              Address of user receiving tokens\r\n     * @param  _quantity        Amount of tokens being transferred\r\n     */\r\n    function internalTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deploys a new Set Token and adds it to the valid list of SetTokens\r\n     *\r\n     * @param  _factory              The address of the Factory to create from\r\n     * @param  _components           The address of component tokens\r\n     * @param  _units                The units of each component token\r\n     * @param  _naturalUnit          The minimum unit to be issued or redeemed\r\n     * @param  _name                 The bytes32 encoded name of the new Set\r\n     * @param  _symbol               The bytes32 encoded symbol of the new Set\r\n     * @param  _callData             Byte string containing additional call parameters\r\n     * @return setTokenAddress       The address of the new Set\r\n     */\r\n    function createSet(\r\n        address _factory,\r\n        address[] calldata _components,\r\n        uint256[] calldata _units,\r\n        uint256 _naturalUnit,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes calldata _callData\r\n    )\r\n        external\r\n        returns (address);\r\n\r\n    /**\r\n     * Exposes internal function that deposits a quantity of tokens to the vault and attributes\r\n     * the tokens respectively, to system modules.\r\n     *\r\n     * @param  _from            Address to transfer tokens from\r\n     * @param  _to              Address to credit for deposit\r\n     * @param  _token           Address of token being deposited\r\n     * @param  _quantity        Amount of tokens to deposit\r\n     */\r\n    function depositModule(\r\n        address _from,\r\n        address _to,\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that withdraws a quantity of tokens from the vault and\r\n     * deattributes the tokens respectively, to system modules.\r\n     *\r\n     * @param  _from            Address to decredit for withdraw\r\n     * @param  _to              Address to transfer tokens to\r\n     * @param  _token           Address of token being withdrawn\r\n     * @param  _quantity        Amount of tokens to withdraw\r\n     */\r\n    function withdrawModule(\r\n        address _from,\r\n        address _to,\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that deposits multiple tokens to the vault, to system\r\n     * modules. Quantities should be in the order of the addresses of the tokens being\r\n     * deposited.\r\n     *\r\n     * @param  _from              Address to transfer tokens from\r\n     * @param  _to                Address to credit for deposits\r\n     * @param  _tokens            Array of the addresses of the tokens being deposited\r\n     * @param  _quantities        Array of the amounts of tokens to deposit\r\n     */\r\n    function batchDepositModule(\r\n        address _from,\r\n        address _to,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that withdraws multiple tokens from the vault, to system\r\n     * modules. Quantities should be in the order of the addresses of the tokens being withdrawn.\r\n     *\r\n     * @param  _from              Address to decredit for withdrawals\r\n     * @param  _to                Address to transfer tokens to\r\n     * @param  _tokens            Array of the addresses of the tokens being withdrawn\r\n     * @param  _quantities        Array of the amounts of tokens to withdraw\r\n     */\r\n    function batchWithdrawModule(\r\n        address _from,\r\n        address _to,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose internal function that exchanges components for Set tokens,\r\n     * accepting any owner, to system modules\r\n     *\r\n     * @param  _owner        Address to use tokens from\r\n     * @param  _recipient    Address to issue Set to\r\n     * @param  _set          Address of the Set to issue\r\n     * @param  _quantity     Number of tokens to issue\r\n     */\r\n    function issueModule(\r\n        address _owner,\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose internal function that exchanges Set tokens for components,\r\n     * accepting any owner, to system modules\r\n     *\r\n     * @param  _burnAddress         Address to burn token from\r\n     * @param  _incrementAddress    Address to increment component tokens to\r\n     * @param  _set                 Address of the Set to redeem\r\n     * @param  _quantity            Number of tokens to redeem\r\n     */\r\n    function redeemModule(\r\n        address _burnAddress,\r\n        address _incrementAddress,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that increments user's balance in the vault.\r\n     * Available to system modules\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchIncrementTokenOwnerModule(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that decrement user's balance in the vault\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchDecrementTokenOwnerModule(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that transfer vault balances between users\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens           Addresses of tokens being transferred\r\n     * @param  _from             Address tokens being transferred from\r\n     * @param  _to               Address tokens being transferred to\r\n     * @param  _quantities       Amounts of tokens being transferred\r\n     */\r\n    function batchTransferBalanceModule(\r\n        address[] calldata _tokens,\r\n        address _from,\r\n        address _to,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfers token from one address to another using the transfer proxy.\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _quantity       The number of tokens to transfer\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     */\r\n    function transferModule(\r\n        address _token,\r\n        uint256 _quantity,\r\n        address _from,\r\n        address _to\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose transfer proxy function to transfer tokens from one address to another\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens         The addresses of the ERC20 token\r\n     * @param  _quantities     The numbers of tokens to transfer\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     */\r\n    function batchTransferModule(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities,\r\n        address _from,\r\n        address _to\r\n    )\r\n        external;\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/interfaces/ISetToken.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title ISetToken\r\n * @author Set Protocol\r\n *\r\n * The ISetToken interface provides a light-weight, structured way to interact with the\r\n * SetToken contract from another contract.\r\n */\r\ninterface ISetToken {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /*\r\n     * Get natural unit of Set\r\n     *\r\n     * @return  uint256       Natural unit of Set\r\n     */\r\n    function naturalUnit()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get addresses of all components in the Set\r\n     *\r\n     * @return  componentAddresses       Array of component tokens\r\n     */\r\n    function getComponents()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /*\r\n     * Get units of all tokens in Set\r\n     *\r\n     * @return  units       Array of component units\r\n     */\r\n    function getUnits()\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /*\r\n     * Checks to make sure token is component of Set\r\n     *\r\n     * @param  _tokenAddress     Address of token being checked\r\n     * @return  bool             True if token is component of Set\r\n     */\r\n    function tokenIsComponent(\r\n        address _tokenAddress\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /*\r\n     * Mint set token for given address.\r\n     * Can only be called by authorized contracts.\r\n     *\r\n     * @param  _issuer      The address of the issuing account\r\n     * @param  _quantity    The number of sets to attribute to issuer\r\n     */\r\n    function mint(\r\n        address _issuer,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Burn set token for given address\r\n     * Can only be called by authorized contracts\r\n     *\r\n     * @param  _from        The address of the redeeming account\r\n     * @param  _quantity    The number of sets to burn from redeemer\r\n     */\r\n    function burn(\r\n        address _from,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n    * Transfer token for a specified address\r\n    *\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/interfaces/IVault.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title IVault\r\n * @author Set Protocol\r\n *\r\n * The IVault interface provides a light-weight, structured way to interact with the Vault\r\n * contract from another contract.\r\n */\r\ninterface IVault {\r\n\r\n    /*\r\n     * Withdraws user's unassociated tokens to user account. Can only be\r\n     * called by authorized core contracts.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _to             The address to transfer token to\r\n     * @param  _quantity       The number of tokens to transfer\r\n     */\r\n    function withdrawTo(\r\n        address _token,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Increment quantity owned of a token for a given address. Can\r\n     * only be called by authorized core contracts.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantity        The number of tokens to attribute to owner\r\n     */\r\n    function incrementTokenOwner(\r\n        address _token,\r\n        address _owner,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Decrement quantity owned of a token for a given address. Can only\r\n     * be called by authorized core contracts.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantity        The number of tokens to deattribute to owner\r\n     */\r\n    function decrementTokenOwner(\r\n        address _token,\r\n        address _owner,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfers tokens associated with one account to another account in the vault\r\n     *\r\n     * @param  _token          Address of token being transferred\r\n     * @param  _from           Address token being transferred from\r\n     * @param  _to             Address token being transferred to\r\n     * @param  _quantity       Amount of tokens being transferred\r\n     */\r\n\r\n    function transferBalance(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n\r\n    /*\r\n     * Withdraws user's unassociated tokens to user account. Can only be\r\n     * called by authorized core contracts.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchWithdrawTo(\r\n        address[] calldata _tokens,\r\n        address _to,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Increment quantites owned of a collection of tokens for a given address. Can\r\n     * only be called by authorized core contracts.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchIncrementTokenOwner(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Decrements quantites owned of a collection of tokens for a given address. Can\r\n     * only be called by authorized core contracts.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchDecrementTokenOwner(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n   /**\r\n     * Transfers tokens associated with one account to another account in the vault\r\n     *\r\n     * @param  _tokens           Addresses of tokens being transferred\r\n     * @param  _from             Address tokens being transferred from\r\n     * @param  _to               Address tokens being transferred to\r\n     * @param  _quantities       Amounts of tokens being transferred\r\n     */\r\n    function batchTransferBalance(\r\n        address[] calldata _tokens,\r\n        address _from,\r\n        address _to,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Get balance of particular contract for owner.\r\n     *\r\n     * @param  _token    The address of the ERC20 token\r\n     * @param  _owner    The address of the token owner\r\n     */\r\n    function getOwnerBalance(\r\n        address _token,\r\n        address _owner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/modules/lib/ExchangeIssuanceLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ExchangeIssuanceLibrary\r\n * @author Set Protocol\r\n *\r\n * The ExchangeIssuanceLibrary contains functions for validating exchange order data\r\n */\r\nlibrary ExchangeIssuanceLibrary {\r\n    using SafeMath for uint256;\r\n    using AddressArrayUtils for address[];\r\n\r\n    // ============ Structs ============\r\n\r\n    struct ExchangeIssuanceParams {\r\n        address setAddress;\r\n        uint256 quantity;\r\n        uint8[] sendTokenExchangeIds;\r\n        address[] sendTokens;\r\n        uint256[] sendTokenAmounts;\r\n        address[] receiveTokens;\r\n        uint256[] receiveTokenAmounts;\r\n    }\r\n\r\n    /**\r\n     * Validates that the quantity to issue is positive and a multiple of the Set natural unit.\r\n     *\r\n     * @param _set                The address of the Set\r\n     * @param _quantity           The quantity of Sets to issue or redeem\r\n     */\r\n    function validateQuantity(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        // Make sure quantity to issue is greater than 0\r\n        require(\r\n            _quantity > 0,\r\n            \"ExchangeIssuanceLibrary.validateQuantity: Quantity must be positive\"\r\n        );\r\n\r\n        // Make sure Issue quantity is multiple of the Set natural unit\r\n        require(\r\n            _quantity.mod(ISetToken(_set).naturalUnit()) == 0,\r\n            \"ExchangeIssuanceLibrary.validateQuantity: Quantity must be multiple of natural unit\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Validates that the required Components and amounts are valid components and positive.\r\n     * Duplicate receive token values are not allowed\r\n     *\r\n     * @param _receiveTokens           The addresses of components required for issuance\r\n     * @param _receiveTokenAmounts     The quantities of components required for issuance\r\n     */\r\n    function validateReceiveTokens(\r\n        address[] memory _receiveTokens,\r\n        uint256[] memory _receiveTokenAmounts\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        uint256 receiveTokensCount = _receiveTokens.length;\r\n\r\n        // Make sure required components array is non-empty\r\n        require(\r\n            receiveTokensCount > 0,\r\n            \"ExchangeIssuanceLibrary.validateReceiveTokens: Receive tokens must not be empty\"\r\n        );\r\n\r\n        // Ensure the receive tokens has no duplicates\r\n        require(\r\n            !_receiveTokens.hasDuplicate(),\r\n            \"ExchangeIssuanceLibrary.validateReceiveTokens: Receive tokens must not have duplicates\"\r\n        );\r\n\r\n        // Make sure required components and required component amounts are equal length\r\n        require(\r\n            receiveTokensCount == _receiveTokenAmounts.length,\r\n            \"ExchangeIssuanceLibrary.validateReceiveTokens: Receive tokens and amounts must be equal length\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < receiveTokensCount; i++) {\r\n            // Make sure all required component amounts are non-zero\r\n            require(\r\n                _receiveTokenAmounts[i] > 0,\r\n                \"ExchangeIssuanceLibrary.validateReceiveTokens: Component amounts must be positive\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates that the tokens received exceeds what we expect\r\n     *\r\n     * @param _vault                        The address of the Vault\r\n     * @param _receiveTokens                The addresses of components required for issuance\r\n     * @param _requiredBalances             The quantities of components required for issuance\r\n     * @param _userToCheck                  The address of the user\r\n     */\r\n    function validatePostExchangeReceiveTokenBalances(\r\n        address _vault,\r\n        address[] memory _receiveTokens,\r\n        uint256[] memory _requiredBalances,\r\n        address _userToCheck\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        // Get vault instance\r\n        IVault vault = IVault(_vault);\r\n\r\n        // Check that caller's receive tokens in Vault have been incremented correctly\r\n        for (uint256 i = 0; i < _receiveTokens.length; i++) {\r\n            uint256 currentBal = vault.getOwnerBalance(\r\n                _receiveTokens[i],\r\n                _userToCheck\r\n            );\r\n\r\n            require(\r\n                currentBal >= _requiredBalances[i],\r\n                \"ExchangeIssuanceLibrary.validatePostExchangeReceiveTokenBalances: Insufficient receive token acquired\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates that the send tokens inputs are valid. Since tokens are sent to various exchanges,\r\n     * duplicate send tokens are valid\r\n     *\r\n     * @param _core                         The address of Core\r\n     * @param _sendTokenExchangeIds         List of exchange wrapper enumerations corresponding to\r\n     *                                          the wrapper that will handle the component\r\n     * @param _sendTokens                   The address of the send tokens\r\n     * @param _sendTokenAmounts             The quantities of send tokens\r\n     */\r\n    function validateSendTokenParams(\r\n        address _core,\r\n        uint8[] memory _sendTokenExchangeIds,\r\n        address[] memory _sendTokens,\r\n        uint256[] memory _sendTokenAmounts\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            _sendTokens.length > 0,\r\n            \"ExchangeIssuanceLibrary.validateSendTokenParams: Send token inputs must not be empty\"\r\n        );\r\n\r\n        require(\r\n            _sendTokenExchangeIds.length == _sendTokens.length &&\r\n            _sendTokens.length == _sendTokenAmounts.length,\r\n            \"ExchangeIssuanceLibrary.validateSendTokenParams: Send token inputs must be of the same length\"\r\n        );\r\n\r\n        ICore core = ICore(_core);\r\n\r\n        for (uint256 i = 0; i < _sendTokenExchangeIds.length; i++) {\r\n            // Make sure all exchanges are valid\r\n            require(\r\n                core.exchangeIds(_sendTokenExchangeIds[i]) != address(0),\r\n                \"ExchangeIssuanceLibrary.validateSendTokenParams: Must be valid exchange\"\r\n            );\r\n\r\n            // Make sure all send token amounts are non-zero\r\n            require(\r\n                _sendTokenAmounts[i] > 0,\r\n                \"ExchangeIssuanceLibrary.validateSendTokenParams: Send amounts must be positive\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/lib/IERC20.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title IERC20\r\n * @author Set Protocol\r\n *\r\n * Interface for using ERC20 Tokens. This interface is needed to interact with tokens that are not\r\n * fully ERC20 compliant and return something other than true on successful transfers.\r\n */\r\ninterface IERC20 {\r\n    function balanceOf(\r\n        address _owner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function totalSupply()\r\n        external\r\n        returns (uint256);\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/lib/ERC20Wrapper.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Wrapper\r\n * @author Set Protocol\r\n *\r\n * This library contains functions for interacting wtih ERC20 tokens, even those not fully compliant.\r\n * For all functions we will only accept tokens that return a null or true value, any other values will\r\n * cause the operation to revert.\r\n */\r\nlibrary ERC20Wrapper {\r\n\r\n    // ============ Internal Functions ============\r\n\r\n    /**\r\n     * Check balance owner's balance of ERC20 token\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _owner          The owner who's balance is being checked\r\n     * @return  uint256        The _owner's amount of tokens\r\n     */\r\n    function balanceOf(\r\n        address _token,\r\n        address _owner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return IERC20(_token).balanceOf(_owner);\r\n    }\r\n\r\n    /**\r\n     * Checks spender's allowance to use token's on owner's behalf.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _owner          The token owner address\r\n     * @param  _spender        The address the allowance is being checked on\r\n     * @return  uint256        The spender's allowance on behalf of owner\r\n     */\r\n    function allowance(\r\n        address _token,\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return IERC20(_token).allowance(_owner, _spender);\r\n    }\r\n\r\n    /**\r\n     * Transfers tokens from an address. Handle's tokens that return true or null.\r\n     * If other value returned, reverts.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _to             The address to transfer to\r\n     * @param  _quantity       The amount of tokens to transfer\r\n     */\r\n    function transfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n    {\r\n        IERC20(_token).transfer(_to, _quantity);\r\n\r\n        // Check that transfer returns true or null\r\n        require(\r\n            checkSuccess(),\r\n            \"ERC20Wrapper.transfer: Bad return value\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Transfers tokens from an address (that has set allowance on the proxy).\r\n     * Handle's tokens that return true or null. If other value returned, reverts.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     * @param  _quantity       The number of tokens to transfer\r\n     */\r\n    function transferFrom(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n    {\r\n        IERC20(_token).transferFrom(_from, _to, _quantity);\r\n\r\n        // Check that transferFrom returns true or null\r\n        require(\r\n            checkSuccess(),\r\n            \"ERC20Wrapper.transferFrom: Bad return value\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Grants spender ability to spend on owner's behalf.\r\n     * Handle's tokens that return true or null. If other value returned, reverts.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _spender        The address to approve for transfer\r\n     * @param  _quantity       The amount of tokens to approve spender for\r\n     */\r\n    function approve(\r\n        address _token,\r\n        address _spender,\r\n        uint256 _quantity\r\n    )\r\n        internal\r\n    {\r\n        IERC20(_token).approve(_spender, _quantity);\r\n\r\n        // Check that approve returns true or null\r\n        require(\r\n            checkSuccess(),\r\n            \"ERC20Wrapper.approve: Bad return value\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Ensure's the owner has granted enough allowance for system to\r\n     * transfer tokens.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _owner          The address of the token owner\r\n     * @param  _spender        The address to grant/check allowance for\r\n     * @param  _quantity       The amount to see if allowed for\r\n     */\r\n    function ensureAllowance(\r\n        address _token,\r\n        address _owner,\r\n        address _spender,\r\n        uint256 _quantity\r\n    )\r\n        internal\r\n    {\r\n        uint256 currentAllowance = allowance(_token, _owner, _spender);\r\n        if (currentAllowance < _quantity) {\r\n            approve(\r\n                _token,\r\n                _spender,\r\n                CommonMath.maxUInt256()\r\n            );\r\n        }\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    /**\r\n     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\r\n     * function returned 0 bytes or 1.\r\n     */\r\n    function checkSuccess(\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // default to failure\r\n        uint256 returnValue = 0;\r\n\r\n        assembly {\r\n            // check number of bytes returned from last function call\r\n            switch returndatasize\r\n\r\n            // no bytes returned: assume success\r\n            case 0x0 {\r\n                returnValue := 1\r\n            }\r\n\r\n            // 32 bytes returned\r\n            case 0x20 {\r\n                // copy 32 bytes into scratch space\r\n                returndatacopy(0x0, 0x0, 0x20)\r\n\r\n                // load those bytes into returnValue\r\n                returnValue := mload(0x0)\r\n            }\r\n\r\n            // not sure what was returned: dont mark as success\r\n            default { }\r\n        }\r\n\r\n        // check if returned value is one or nothing\r\n        return returnValue == 1;\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/interfaces/IExchangeIssuanceModule.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\npragma experimental \"ABIEncoderV2\";\r\n\r\n\r\n/**\r\n * @title IExchangeIssuanceModule\r\n * @author Set Protocol\r\n *\r\n * Interface for executing orders and issuing and redeeming a Set\r\n */\r\ninterface IExchangeIssuanceModule {\r\n\r\n    function exchangeIssue(\r\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams calldata _exchangeIssuanceParams,\r\n        bytes calldata _orderData\r\n    )\r\n        external;\r\n\r\n\r\n    function exchangeRedeem(\r\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams calldata _exchangeIssuanceParams,\r\n        bytes calldata _orderData\r\n    )\r\n        external;\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/lib/RebalancingLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title RebalancingLibrary\r\n * @author Set Protocol\r\n *\r\n * The RebalancingLibrary contains functions for facilitating the rebalancing process for\r\n * Rebalancing Set Tokens. Removes the old calculation functions\r\n *\r\n */\r\nlibrary RebalancingLibrary {\r\n\r\n    /* ============ Enums ============ */\r\n\r\n    enum State { Default, Proposal, Rebalance, Drawdown }\r\n\r\n    /* ============ Structs ============ */\r\n\r\n    struct AuctionPriceParameters {\r\n        uint256 auctionStartTime;\r\n        uint256 auctionTimeToPivot;\r\n        uint256 auctionStartPrice;\r\n        uint256 auctionPivotPrice;\r\n    }\r\n\r\n    struct BiddingParameters {\r\n        uint256 minimumBid;\r\n        uint256 remainingCurrentSets;\r\n        uint256[] combinedCurrentUnits;\r\n        uint256[] combinedNextSetUnits;\r\n        address[] combinedTokenArray;\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/interfaces/IRebalancingSetToken.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title IRebalancingSetToken\r\n * @author Set Protocol\r\n *\r\n * The IRebalancingSetToken interface provides a light-weight, structured way to interact with the\r\n * RebalancingSetToken contract from another contract.\r\n */\r\n\r\ninterface IRebalancingSetToken {\r\n\r\n    /*\r\n     * Get the auction library contract used for the current rebalance\r\n     *\r\n     * @return address    Address of auction library used in the upcoming auction\r\n     */\r\n    function auctionLibrary()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Get totalSupply of Rebalancing Set\r\n     *\r\n     * @return  totalSupply\r\n     */\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get proposalTimeStamp of Rebalancing Set\r\n     *\r\n     * @return  proposalTimeStamp\r\n     */\r\n    function proposalStartTime()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get lastRebalanceTimestamp of Rebalancing Set\r\n     *\r\n     * @return  lastRebalanceTimestamp\r\n     */\r\n    function lastRebalanceTimestamp()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get rebalanceInterval of Rebalancing Set\r\n     *\r\n     * @return  rebalanceInterval\r\n     */\r\n    function rebalanceInterval()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get rebalanceState of Rebalancing Set\r\n     *\r\n     * @return RebalancingLibrary.State    Current rebalance state of the RebalancingSetToken\r\n     */\r\n    function rebalanceState()\r\n        external\r\n        view\r\n        returns (RebalancingLibrary.State);\r\n\r\n    /*\r\n     * Get the starting amount of current SetToken for the current auction\r\n     *\r\n     * @return  rebalanceState\r\n     */\r\n    function startingCurrentSetAmount()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Gets the balance of the specified address.\r\n     *\r\n     * @param owner      The address to query the balance of.\r\n     * @return           A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(\r\n        address owner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Function used to set the terms of the next rebalance and start the proposal period\r\n     *\r\n     * @param _nextSet                      The Set to rebalance into\r\n     * @param _auctionLibrary               The library used to calculate the Dutch Auction price\r\n     * @param _auctionTimeToPivot           The amount of time for the auction to go ffrom start to pivot price\r\n     * @param _auctionStartPrice            The price to start the auction at\r\n     * @param _auctionPivotPrice            The price at which the price curve switches from linear to exponential\r\n     */\r\n    function propose(\r\n        address _nextSet,\r\n        address _auctionLibrary,\r\n        uint256 _auctionTimeToPivot,\r\n        uint256 _auctionStartPrice,\r\n        uint256 _auctionPivotPrice\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Get natural unit of Set\r\n     *\r\n     * @return  uint256       Natural unit of Set\r\n     */\r\n    function naturalUnit()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Returns the address of the current base SetToken with the current allocation\r\n     *\r\n     * @return           A address representing the base SetToken\r\n     */\r\n    function currentSet()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Returns the address of the next base SetToken with the post auction allocation\r\n     *\r\n     * @return  address    Address representing the base SetToken\r\n     */\r\n    function nextSet()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Get the unit shares of the rebalancing Set\r\n     *\r\n     * @return  unitShares       Unit Shares of the base Set\r\n     */\r\n    function unitShares()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Burn set token for given address.\r\n     * Can only be called by authorized contracts.\r\n     *\r\n     * @param  _from        The address of the redeeming account\r\n     * @param  _quantity    The number of sets to burn from redeemer\r\n     */\r\n    function burn(\r\n        address _from,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Place bid during rebalance auction. Can only be called by Core.\r\n     *\r\n     * @param _quantity                 The amount of currentSet to be rebalanced\r\n     * @return combinedTokenArray       Array of token addresses invovled in rebalancing\r\n     * @return inflowUnitArray          Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray         Array of amount of tokens taken out of system in bid\r\n     */\r\n    function placeBid(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        returns (address[] memory, uint256[] memory, uint256[] memory);\r\n\r\n    /*\r\n     * Get combinedTokenArray of Rebalancing Set\r\n     *\r\n     * @return  combinedTokenArray\r\n     */\r\n    function getCombinedTokenArrayLength()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get combinedTokenArray of Rebalancing Set\r\n     *\r\n     * @return  combinedTokenArray\r\n     */\r\n    function getCombinedTokenArray()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /*\r\n     * Get failedAuctionWithdrawComponents of Rebalancing Set\r\n     *\r\n     * @return  failedAuctionWithdrawComponents\r\n     */\r\n    function getFailedAuctionWithdrawComponents()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /*\r\n     * Get auctionPriceParameters for current auction\r\n     *\r\n     * @return uint256[4]    AuctionPriceParameters for current rebalance auction\r\n     */\r\n    function getAuctionPriceParameters()\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /*\r\n     * Get biddingParameters for current auction\r\n     *\r\n     * @return uint256[2]    BiddingParameters for current rebalance auction\r\n     */\r\n    function getBiddingParameters()\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /*\r\n     * Get token inflows and outflows required for bid. Also the amount of Rebalancing\r\n     * Sets that would be generated.\r\n     *\r\n     * @param _quantity               The amount of currentSet to be rebalanced\r\n     * @return inflowUnitArray        Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray       Array of amount of tokens taken out of system in bid\r\n     */\r\n    function getBidPrice(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        view\r\n        returns (uint256[] memory, uint256[] memory);\r\n\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/interfaces/ITransferProxy.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title ITransferProxy\r\n * @author Set Protocol\r\n *\r\n * The ITransferProxy interface provides a light-weight, structured way to interact with the\r\n * TransferProxy contract from another contract.\r\n */\r\ninterface ITransferProxy {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * Transfers tokens from an address (that has set allowance on the proxy).\r\n     * Can only be called by authorized core contracts.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _quantity       The number of tokens to transfer\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     */\r\n    function transfer(\r\n        address _token,\r\n        uint256 _quantity,\r\n        address _from,\r\n        address _to\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfers tokens from an address (that has set allowance on the proxy).\r\n     * Can only be called by authorized core contracts.\r\n     *\r\n     * @param  _tokens         The addresses of the ERC20 token\r\n     * @param  _quantities     The numbers of tokens to transfer\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     */\r\n    function batchTransfer(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities,\r\n        address _from,\r\n        address _to\r\n    )\r\n        external;\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/lib/IWETH.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title IWETH\r\n * @author Set Protocol\r\n *\r\n * Interface for Wrapped Ether. This interface allows for interaction for wrapped ether's deposit and withdrawal\r\n * functionality.\r\n */\r\ninterface IWETH {\r\n    function deposit()\r\n        external\r\n        payable;\r\n\r\n    function withdraw(\r\n        uint256 wad\r\n    )\r\n        external;\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/modules/lib/ModuleCoreStateV2.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ModuleCoreStateV2\r\n * @author Set Protocol\r\n *\r\n * The ModuleCoreStateV2 library maintains Core-related state for modules.\r\n *\r\n * CHANGELOG\r\n * - Adds transferProxy to the tracked state\r\n * - Removes address variables\r\n *\r\n */\r\ncontract ModuleCoreStateV2 {\r\n\r\n    /* ============ State Variables ============ */\r\n\r\n    // Address of core contract\r\n    ICore public coreInstance;\r\n\r\n    // Address of vault contract\r\n    IVault public vaultInstance;\r\n\r\n    // Address of transferProxy contract\r\n    ITransferProxy public transferProxyInstance;\r\n\r\n    /* ============ Public Getters ============ */\r\n\r\n    /**\r\n     * Constructor function for ModuleCoreStateV2\r\n     *\r\n     * @param _core                The address of Core\r\n     * @param _vault               The address of Vault\r\n     * @param _transferProxy       The address of TransferProxy\r\n     */\r\n    constructor(\r\n        ICore _core,\r\n        IVault _vault,\r\n        ITransferProxy _transferProxy\r\n    )\r\n        public\r\n    {\r\n        // Commit passed address to core state variable\r\n        coreInstance = _core;\r\n\r\n        // Commit passed address to vault state variable\r\n        vaultInstance = _vault;\r\n\r\n        // Commit passed address to vault state variable\r\n        transferProxyInstance = _transferProxy;\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/modules/lib/TokenFlush.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenFlush\r\n * @author Set Protocol\r\n *\r\n * The TokenFlush contains utility functions to send tokens and base SetTokens from the\r\n * Vault or Contract to a specified user address\r\n */\r\ncontract TokenFlush is\r\n    ModuleCoreStateV2\r\n{\r\n    using SafeMath for uint256;\r\n    using AddressArrayUtils for address[];\r\n\r\n    // ============ Internal ============\r\n\r\n    /**\r\n     * Checks the base SetToken balances on the contract and sends\r\n     * any positive quantity to the user directly or into the Vault\r\n     * depending on the keepChangeInVault flag.\r\n     *\r\n     * @param _baseSetAddress             The address of the base SetToken\r\n     * @param _returnAddress              The address to send excess tokens to\r\n     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function returnExcessBaseSetFromContract(\r\n        address _baseSetAddress,\r\n        address _returnAddress,\r\n        bool _keepChangeInVault\r\n    )\r\n        internal\r\n    {\r\n        uint256 baseSetQuantity = ERC20Wrapper.balanceOf(_baseSetAddress, address(this));\r\n\r\n        if (baseSetQuantity > 0) {\r\n            if (_keepChangeInVault) {\r\n                // Ensure base SetToken allowance\r\n                ERC20Wrapper.ensureAllowance(\r\n                    _baseSetAddress,\r\n                    address(this),\r\n                    address(transferProxyInstance),\r\n                    baseSetQuantity\r\n                );\r\n\r\n                // Deposit base SetToken to the user\r\n                coreInstance.depositModule(\r\n                    address(this),\r\n                    _returnAddress,\r\n                    _baseSetAddress,\r\n                    baseSetQuantity\r\n                );\r\n            } else {\r\n                // Transfer directly to the user\r\n                ERC20Wrapper.transfer(\r\n                    _baseSetAddress,\r\n                    _returnAddress,\r\n                    baseSetQuantity\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks the base SetToken balances in the Vault and sends\r\n     * any positive quantity to the user directly or into the Vault\r\n     * depending on the keepChangeInVault flag.\r\n     *\r\n     * @param _baseSetAddress             The address of the base SetToken\r\n     * @param _returnAddress              The address to send excess tokens to\r\n     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function returnExcessBaseSetInVault(\r\n        address _baseSetAddress,\r\n        address _returnAddress,\r\n        bool _keepChangeInVault\r\n    )\r\n        internal\r\n    {\r\n        // Return base SetToken if any that are in the Vault\r\n        uint256 baseSetQuantityInVault = vaultInstance.getOwnerBalance(\r\n            _baseSetAddress,\r\n            address(this)\r\n        );\r\n\r\n        if (baseSetQuantityInVault > 0) {\r\n            if (_keepChangeInVault) {\r\n                // Transfer ownership within the vault to the user\r\n                coreInstance.internalTransfer(\r\n                    _baseSetAddress,\r\n                    _returnAddress,\r\n                    baseSetQuantityInVault\r\n                );\r\n            } else {\r\n                // Transfer ownership directly to the user\r\n                coreInstance.withdrawModule(\r\n                    address(this),\r\n                    _returnAddress,\r\n                    _baseSetAddress,\r\n                    baseSetQuantityInVault\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Withdraw any base Set components to the user from the contract.\r\n     *\r\n     * @param _baseSetToken               Instance of the Base SetToken\r\n     * @param _returnAddress              The address to send excess tokens to\r\n     */\r\n    function returnExcessComponentsFromContract(\r\n        ISetToken _baseSetToken,\r\n        address _returnAddress\r\n    )\r\n        internal\r\n    {\r\n        // Return base Set components\r\n        address[] memory baseSetComponents = _baseSetToken.getComponents();\r\n        for (uint256 i = 0; i < baseSetComponents.length; i++) {\r\n            uint256 withdrawQuantity = ERC20Wrapper.balanceOf(baseSetComponents[i], address(this));\r\n            if (withdrawQuantity > 0) {\r\n                ERC20Wrapper.transfer(\r\n                    baseSetComponents[i],\r\n                    _returnAddress,\r\n                    withdrawQuantity\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Any base Set components in the Vault are returned to the caller.\r\n     *\r\n     * @param _baseSetToken               Instance of the Base SetToken\r\n     * @param _returnAddress              The address to send excess tokens to\r\n     */\r\n    function returnExcessComponentsFromVault(\r\n        ISetToken _baseSetToken,\r\n        address _returnAddress\r\n    )\r\n        internal\r\n    {\r\n        // Return base Set components not used in issuance of base set\r\n        address[] memory baseSetComponents = _baseSetToken.getComponents();\r\n        for (uint256 i = 0; i < baseSetComponents.length; i++) {\r\n            uint256 vaultQuantity = vaultInstance.getOwnerBalance(baseSetComponents[i], address(this));\r\n            if (vaultQuantity > 0) {\r\n                coreInstance.withdrawModule(\r\n                    address(this),\r\n                    _returnAddress,\r\n                    baseSetComponents[i],\r\n                    vaultQuantity\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/modules/RebalancingSetExchangeIssuanceModule.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingSetExchangeIssuanceModule\r\n * @author Set Protocol\r\n *\r\n * The RebalancingSetExchangeIssuanceModule supplementary smart contract allows a user to issue and redeem a Rebalancing Set\r\n * using a payment token or receiving a receive token atomically in a single transaction using liquidity from\r\n * decentralized exchanges.\r\n */\r\ncontract RebalancingSetExchangeIssuanceModule is\r\n    ModuleCoreStateV2,\r\n    TokenFlush,\r\n    ReentrancyGuard\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    /* ============ State Variables ============ */\r\n\r\n    // Address and instance of ExchangeIssuance Module contract\r\n    IExchangeIssuanceModule public exchangeIssuanceModuleInstance;\r\n\r\n    // Address and instance of Wrapped Ether contract\r\n    IWETH public wethInstance;\r\n\r\n    /* ============ Events ============ */\r\n\r\n    event LogPayableExchangeIssue(\r\n        address indexed rebalancingSetAddress,\r\n        address indexed callerAddress,\r\n        address paymentTokenAddress,\r\n        uint256 rebalancingSetQuantity,\r\n        uint256 paymentTokenReturned\r\n    );\r\n\r\n    event LogPayableExchangeRedeem(\r\n        address indexed rebalancingSetAddress,\r\n        address indexed callerAddress,\r\n        address outputTokenAddress,\r\n        uint256 rebalancingSetQuantity,\r\n        uint256 outputTokenQuantity\r\n    );\r\n\r\n    /* ============ Constructor ============ */\r\n\r\n    /**\r\n     * Constructor function for RebalancingSetExchangeIssuanceModule\r\n     *\r\n     * @param _core                     The address of Core\r\n     * @param _transferProxy            The address of the TransferProxy\r\n     * @param _exchangeIssuanceModule   The address of ExchangeIssuanceModule\r\n     * @param _wrappedEther             The address of wrapped ether\r\n     * @param _vault                    The address of Vault\r\n     */\r\n    constructor(\r\n        ICore _core,\r\n        ITransferProxy _transferProxy,\r\n        IExchangeIssuanceModule _exchangeIssuanceModule,\r\n        IWETH _wrappedEther,\r\n        IVault _vault\r\n    )\r\n        public\r\n        ModuleCoreStateV2(\r\n            _core,\r\n            _vault,\r\n            _transferProxy\r\n        )\r\n    {\r\n        // Commit the instance of ExchangeIssuanceModule to state variables\r\n        exchangeIssuanceModuleInstance = _exchangeIssuanceModule;\r\n\r\n        // Commit the address and instance of Wrapped Ether to state variables\r\n        wethInstance = _wrappedEther;\r\n\r\n        // Add approvals of Wrapped Ether to the Transfer Proxy\r\n        ERC20Wrapper.approve(\r\n            address(_wrappedEther),\r\n            address(_transferProxy),\r\n            CommonMath.maxUInt256()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Fallback function. Disallows ether to be sent to this contract without data except when\r\n     * unwrapping WETH.\r\n     */\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        require(\r\n            msg.sender == address(wethInstance),\r\n            \"RebalancingSetExchangeIssuanceModule.fallback: Cannot receive ETH directly unless unwrapping WETH\"\r\n        );\r\n    }\r\n\r\n    /* ============ Public Functions ============ */\r\n\r\n    /**\r\n     * Issue a Rebalancing Set using Wrapped Ether to acquire the base components of the Base Set.\r\n     * The Base Set is then issued using ExchangeIssue and reissued into the Rebalancing Set.\r\n     * All remaining tokens / change are flushed and returned to the user.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing Set to issue\r\n     * @param  _rebalancingSetQuantity   Quantity of the rebalancing Set\r\n     * @param  _exchangeIssuanceParams   Struct containing data around the base Set issuance\r\n     * @param  _orderData                Bytecode encoding exchange data for acquiring base set components\r\n     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transferred to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function issueRebalancingSetWithEther(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\r\n        bytes memory _orderData,\r\n        bool _keepChangeInVault\r\n    )\r\n        public\r\n        payable\r\n        nonReentrant\r\n    {\r\n        // Wrap all Ether; Wrapped Ether could be a component of the Set being issued.\r\n        wethInstance.deposit.value(msg.value)();\r\n\r\n        // Perform exchange transactions, mint the base SetToken, and issue the Rebalancing Set to the sender\r\n        issueRebalancingSetInternal(\r\n            _rebalancingSetAddress,\r\n            _rebalancingSetQuantity,\r\n            address(wethInstance),\r\n            msg.value,\r\n            _exchangeIssuanceParams,\r\n            _orderData,\r\n            _keepChangeInVault\r\n        );\r\n\r\n        // unwrap any leftover WETH and transfer to sender\r\n        uint256 leftoverWeth = ERC20Wrapper.balanceOf(address(wethInstance), address(this));\r\n        if (leftoverWeth > 0) {\r\n            // Withdraw wrapped Ether\r\n            wethInstance.withdraw(leftoverWeth);\r\n\r\n            // Transfer ether to user\r\n            msg.sender.transfer(leftoverWeth);\r\n        }\r\n\r\n        emit LogPayableExchangeIssue(\r\n            _rebalancingSetAddress,\r\n            msg.sender,\r\n            address(wethInstance),\r\n            _rebalancingSetQuantity,\r\n            leftoverWeth\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Issue a Rebalancing Set using a specified ERC20 payment token. The payment token is used in ExchangeIssue\r\n     * to acquire the base SetToken components and issue the base SetToken. The base SetToken is then used to\r\n     * issue the Rebalancing SetToken. The payment token can be utilized as a component of the base SetToken.\r\n     * All remaining tokens / change are flushed and returned to the user.\r\n     * Ahead of calling this function, the user must approve their paymentToken to the transferProxy.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing Set to issue\r\n     * @param  _rebalancingSetQuantity   Quantity of the rebalancing Set\r\n     * @param  _paymentTokenAddress      Address of the ERC20 token to pay with\r\n     * @param  _paymentTokenQuantity     Quantity of the payment token\r\n     * @param  _exchangeIssuanceParams   Struct containing data around the base Set issuance\r\n     * @param  _orderData                Bytecode formatted data with exchange data for acquiring base set components\r\n     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function issueRebalancingSetWithERC20(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        address _paymentTokenAddress,\r\n        uint256 _paymentTokenQuantity,\r\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\r\n        bytes memory _orderData,\r\n        bool _keepChangeInVault\r\n    )\r\n        public\r\n        nonReentrant\r\n    {\r\n        // Deposit the erc20 to this contract. The token must be approved the caller to the transferProxy\r\n        coreInstance.transferModule(\r\n            _paymentTokenAddress,\r\n            _paymentTokenQuantity,\r\n            msg.sender,\r\n            address(this)\r\n        );\r\n\r\n        // Perform exchange transactions, mint the base SetToken, and issue the Rebalancing Set to the sender\r\n        issueRebalancingSetInternal(\r\n            _rebalancingSetAddress,\r\n            _rebalancingSetQuantity,\r\n            _paymentTokenAddress,\r\n            _paymentTokenQuantity,\r\n            _exchangeIssuanceParams,\r\n            _orderData,\r\n            _keepChangeInVault\r\n        );\r\n\r\n        // Send back any unused payment token\r\n        uint256 leftoverPaymentTokenQuantity = ERC20Wrapper.balanceOf(_paymentTokenAddress, address(this));\r\n        if (leftoverPaymentTokenQuantity > 0) {\r\n            ERC20Wrapper.transfer(\r\n                _paymentTokenAddress,\r\n                msg.sender,\r\n                leftoverPaymentTokenQuantity\r\n            );\r\n        }\r\n\r\n        emit LogPayableExchangeIssue(\r\n            _rebalancingSetAddress,\r\n            msg.sender,\r\n            _paymentTokenAddress,\r\n            _rebalancingSetQuantity,\r\n            leftoverPaymentTokenQuantity\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Redeems a Rebalancing Set into ether. The Rebalancing Set is redeemed into the Base Set, and\r\n     * Base Set components are traded for WETH. The WETH is then withdrawn into ETH and the ETH sent to the caller.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing Set\r\n     * @param  _rebalancingSetQuantity   Quantity of rebalancing Set to redeem\r\n     * @param  _exchangeIssuanceParams   Struct containing data around the base Set issuance\r\n     * @param  _orderData                Bytecode encoding exchange data for disposing base set components\r\n     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function redeemRebalancingSetIntoEther(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\r\n        bytes memory _orderData,\r\n        bool _keepChangeInVault\r\n    )\r\n        public\r\n        nonReentrant\r\n    {\r\n        // Redeems the rebalancing Set into the base SetToken, redeems the base SetToken into its components,\r\n        // and exchanges the components into wrapped ether to this contract.\r\n        redeemRebalancingSetIntoComponentsInternal(\r\n            _rebalancingSetAddress,\r\n            _rebalancingSetQuantity,\r\n            address(wethInstance),\r\n            _exchangeIssuanceParams,\r\n            _orderData\r\n        );\r\n\r\n        // In the event that exchangeIssue returns more receiveTokens or wrappedEth than\r\n        // specified in receiveToken quantity, those tokens are also retrieved into this contract.\r\n        // We also call this ahead of returnRedemptionChange to allow the unwrapping of the wrappedEther\r\n        uint256 wethQuantityInVault = vaultInstance.getOwnerBalance(address(wethInstance), address(this));\r\n        if (wethQuantityInVault > 0) {\r\n            coreInstance.withdrawModule(\r\n                address(this),\r\n                address(this),\r\n                address(wethInstance),\r\n                wethQuantityInVault\r\n            );\r\n        }\r\n\r\n        // Unwrap wrapped Ether and transfer Eth to user\r\n        uint256 wethBalance = ERC20Wrapper.balanceOf(address(wethInstance), address(this));\r\n        if (wethBalance > 0) {\r\n            wethInstance.withdraw(wethBalance);\r\n            msg.sender.transfer(wethBalance);\r\n        }\r\n\r\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\r\n\r\n        // Send excess base Set to the user\r\n        returnExcessBaseSetFromContract(\r\n            baseSetAddress,\r\n            msg.sender,\r\n            _keepChangeInVault\r\n        );\r\n\r\n        // Return non-exchanged components to the user\r\n        returnExcessComponentsFromContract(ISetToken(baseSetAddress), msg.sender);\r\n\r\n        emit LogPayableExchangeRedeem(\r\n            _rebalancingSetAddress,\r\n            msg.sender,\r\n            address(wethInstance),\r\n            _rebalancingSetQuantity,\r\n            wethBalance\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Redeems a Rebalancing Set into a specified ERC20 token. The Rebalancing Set is redeemed into the Base Set, and\r\n     * Base Set components are traded for the ERC20 and sent to the caller.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing Set\r\n     * @param  _rebalancingSetQuantity   Quantity of rebalancing Set to redeem\r\n     * @param  _outputTokenAddress       Address of the resulting ERC20 token sent to the user\r\n     * @param  _exchangeIssuanceParams   Struct containing data around the base Set issuance\r\n     * @param  _orderData                Bytecode formatted data with exchange data for disposing base set components\r\n     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function redeemRebalancingSetIntoERC20(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        address _outputTokenAddress,\r\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\r\n        bytes memory _orderData,\r\n        bool _keepChangeInVault\r\n    )\r\n        public\r\n        nonReentrant\r\n    {\r\n        // Redeems the rebalancing Set into the base SetToken, redeems the base SetToken into its components,\r\n        // and exchanges the components into the receiveToken to this contract.\r\n        redeemRebalancingSetIntoComponentsInternal(\r\n            _rebalancingSetAddress,\r\n            _rebalancingSetQuantity,\r\n            _outputTokenAddress,\r\n            _exchangeIssuanceParams,\r\n            _orderData\r\n        );\r\n\r\n        // In the event that exchangeIssue returns more outputTokens than\r\n        // specified in receiveToken quantity, those tokens are also retrieved into this contract.\r\n        uint256 outputTokenInVault = vaultInstance.getOwnerBalance(_outputTokenAddress, address(this));\r\n        if (outputTokenInVault > 0) {\r\n            coreInstance.withdrawModule(\r\n                address(this),\r\n                address(this),\r\n                _outputTokenAddress,\r\n                outputTokenInVault\r\n            );\r\n        }\r\n\r\n        // Transfer outputToken to the caller\r\n        uint256 outputTokenBalance = ERC20Wrapper.balanceOf(_outputTokenAddress, address(this));\r\n        ERC20Wrapper.transfer(\r\n            _outputTokenAddress,\r\n            msg.sender,\r\n            outputTokenBalance\r\n        );\r\n\r\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\r\n\r\n        // Send excess base SetToken to the user\r\n        returnExcessBaseSetFromContract(\r\n            baseSetAddress,\r\n            msg.sender,\r\n            _keepChangeInVault\r\n        );\r\n\r\n        // Non-exchanged base SetToken components are returned to the user\r\n        returnExcessComponentsFromContract(ISetToken(baseSetAddress), msg.sender);\r\n\r\n        emit LogPayableExchangeRedeem(\r\n            _rebalancingSetAddress,\r\n            msg.sender,\r\n            _outputTokenAddress,\r\n            _rebalancingSetQuantity,\r\n            outputTokenBalance\r\n        );\r\n    }\r\n\r\n\r\n    /* ============ Private Functions ============ */\r\n\r\n    /**\r\n     * Validate that the issuance parameters and inputs are congruent.\r\n     *\r\n     * @param  _transactTokenAddress     Address of the sendToken (issue) or receiveToken (redeem)\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken\r\n     * @param  _rebalancingSetQuantity   Quantity of rebalancing SetToken to issue or redeem\r\n     * @param  _baseSetAddress           Address of base SetToken in ExchangeIssueanceParams\r\n     * @param  _transactTokenArray       List of addresses of send tokens (during issuance) and\r\n     *                                     receive tokens (during redemption)\r\n     */\r\n    function validateExchangeIssuanceInputs(\r\n        address _transactTokenAddress,\r\n        IRebalancingSetToken _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        address _baseSetAddress,\r\n        address[] memory _transactTokenArray\r\n    )\r\n        private\r\n        view\r\n    {\r\n        // Expect rebalancing SetToken to be valid and enabled SetToken\r\n        require(\r\n            coreInstance.validSets(address(_rebalancingSetAddress)),\r\n            \"RebalancingSetExchangeIssuance.validateExchangeIssuanceInputs: Invalid or disabled SetToken address\"\r\n        );\r\n\r\n        require(\r\n            _rebalancingSetQuantity > 0,\r\n            \"RebalancingSetExchangeIssuance.validateExchangeIssuanceInputs: Quantity must be > 0\"\r\n        );\r\n\r\n        // Make sure Issuance quantity is multiple of the rebalancing SetToken natural unit\r\n        require(\r\n            _rebalancingSetQuantity.mod(_rebalancingSetAddress.naturalUnit()) == 0,\r\n            \"RebalancingSetExchangeIssuance.validateExchangeIssuanceInputs: Quantity must be multiple of natural unit\"\r\n        );\r\n\r\n        // Multiple items are allowed on the transactTokenArray. Specifically, this allows there to be\r\n        // multiple sendToken items that are directed to the various exchangeWrappers.\r\n        // The receiveTokenArray is implicitly limited to a single item, as the exchangeIssuanceModuleInstance\r\n        // checks that the receive tokens do not have duplicates\r\n        for (uint256 i = 0; i < _transactTokenArray.length; i++) {\r\n            // The transact token array tokens must match the transact token.\r\n            require(\r\n                _transactTokenAddress == _transactTokenArray[i],\r\n                \"RebalancingSetExchangeIssuance.validateExchangeIssuanceInputs: Send/Receive token must match transact token\"\r\n            );\r\n        }\r\n\r\n        // Validate that the base Set address matches the issuanceParams Set Address\r\n        address baseSet = _rebalancingSetAddress.currentSet();\r\n        require(\r\n            baseSet == _baseSetAddress,\r\n            \"RebalancingSetExchangeIssuance.validateExchangeIssuanceInputs: Base Set addresses must match\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Issue a Rebalancing Set using a specified ERC20 payment token. The payment token is used in ExchangeIssue\r\n     * to acquire the base SetToken components and issue the base SetToken. The base SetToken is then used to\r\n     * issue the Rebalancing SetToken. The payment token can be utilized as a component of the base SetToken.\r\n     * All remaining tokens / change are flushed and returned to the user.\r\n     *\r\n     * Note: We do not validate the rebalancing SetToken quantity and the exchangeIssuanceParams base SetToken\r\n     * quantity. Thus there could be extra base SetToken (or change) generated.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing Set to issue\r\n     * @param  _rebalancingSetQuantity   Quantity of the rebalancing Set\r\n     * @param  _paymentTokenAddress      Address of the ERC20 token to pay with\r\n     * @param  _paymentTokenQuantity     Quantity of the payment token\r\n     * @param  _exchangeIssuanceParams   Struct containing data around the base Set issuance\r\n     * @param  _orderData                Bytecode formatted data with exchange data for acquiring base set components\r\n     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function issueRebalancingSetInternal(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        address _paymentTokenAddress,\r\n        uint256 _paymentTokenQuantity,\r\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\r\n        bytes memory _orderData,\r\n        bool _keepChangeInVault\r\n    )\r\n        private\r\n    {\r\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\r\n        uint256 baseSetIssueQuantity = _exchangeIssuanceParams.quantity;\r\n\r\n        // Validate parameters\r\n        validateExchangeIssuanceInputs(\r\n            _paymentTokenAddress,\r\n            IRebalancingSetToken(_rebalancingSetAddress),\r\n            _rebalancingSetQuantity,\r\n            baseSetAddress,\r\n            _exchangeIssuanceParams.sendTokens\r\n        );\r\n\r\n        // Ensure payment token allowance to the TransferProxy\r\n        // Note that the paymentToken may also be used as a component to issue the Set\r\n        // So the paymentTokenQuantity must be used vs. the exchangeIssuanceParams sendToken quantity\r\n        ERC20Wrapper.ensureAllowance(\r\n            _paymentTokenAddress,\r\n            address(this),\r\n            address(transferProxyInstance),\r\n            _paymentTokenQuantity\r\n        );\r\n\r\n        // Atomically trade paymentToken for base SetToken components and mint the base SetToken\r\n        exchangeIssuanceModuleInstance.exchangeIssue(\r\n            _exchangeIssuanceParams,\r\n            _orderData\r\n        );\r\n\r\n        // Approve base SetToken to transferProxy for minting rebalancing SetToken\r\n        ERC20Wrapper.ensureAllowance(\r\n            baseSetAddress,\r\n            address(this),\r\n            address(transferProxyInstance),\r\n            baseSetIssueQuantity\r\n        );\r\n\r\n        // Issue rebalancing SetToken to the caller\r\n        coreInstance.issueTo(\r\n            msg.sender,\r\n            _rebalancingSetAddress,\r\n            _rebalancingSetQuantity\r\n        );\r\n\r\n        // Send excess base Set held in this contract to the user\r\n        // If keepChangeInVault is true, the baseSetToken is held in the Vault\r\n        // which is a UX improvement\r\n        returnExcessBaseSetFromContract(\r\n            baseSetAddress,\r\n            msg.sender,\r\n            _keepChangeInVault\r\n        );\r\n\r\n        // Return any extra components acquired during exchangeIssue to the user\r\n        returnExcessComponentsFromVault(ISetToken(baseSetAddress), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Redeems a Rebalancing Set into the receiveToken. The Rebalancing Set is redeemed into the Base Set, and\r\n     * Base Set components are traded for the receiveToken located in this contract.\r\n     *\r\n     * Note: We do not validate the rebalancing SetToken quantity and the exchangeIssuanceParams base SetToken\r\n     * quantity. Thus there could be extra base SetToken (or change) generated.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing Set\r\n     * @param  _rebalancingSetQuantity   Quantity of rebalancing Set to redeem\r\n     * @param  _receiveTokenAddress      Address of the receiveToken\r\n     * @param  _exchangeIssuanceParams   Struct containing data around the base Set issuance\r\n     * @param  _orderData                Bytecode formatted data with exchange data for disposing base set components\r\n     */\r\n    function redeemRebalancingSetIntoComponentsInternal(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        address _receiveTokenAddress,\r\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\r\n        bytes memory _orderData\r\n    )\r\n        private\r\n    {\r\n        // Validate Params\r\n        validateExchangeIssuanceInputs(\r\n            _receiveTokenAddress,\r\n            IRebalancingSetToken(_rebalancingSetAddress),\r\n            _rebalancingSetQuantity,\r\n            _exchangeIssuanceParams.setAddress,\r\n            _exchangeIssuanceParams.receiveTokens\r\n        );\r\n\r\n        // Redeem rebalancing Set into the base SetToken from the user to this contract in the Vault\r\n        coreInstance.redeemModule(\r\n            msg.sender,\r\n            address(this),\r\n            _rebalancingSetAddress,\r\n            _rebalancingSetQuantity\r\n        );\r\n\r\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\r\n        uint256 baseSetVaultQuantity = vaultInstance.getOwnerBalance(baseSetAddress, address(this));\r\n\r\n        // Withdraw base SetToken from Vault to this contract\r\n        coreInstance.withdrawModule(\r\n            address(this),\r\n            address(this),\r\n            baseSetAddress,\r\n            baseSetVaultQuantity\r\n        );\r\n\r\n        // Redeem base SetToken into components and perform trades / exchanges\r\n        // into the receiveToken. The receiveTokens are transferred to this contract\r\n        // as well as the remaining non-exchanged components\r\n        exchangeIssuanceModuleInstance.exchangeRedeem(\r\n            _exchangeIssuanceParams,\r\n            _orderData\r\n        );\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/modules/lib/ModuleCoreState.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ModuleCoreState\r\n * @author Set Protocol\r\n *\r\n * The ModuleCoreState library maintains Core-related state for modules\r\n */\r\ncontract ModuleCoreState {\r\n\r\n    /* ============ State Variables ============ */\r\n\r\n    // Address of core contract\r\n    address public core;\r\n\r\n    // Address of vault contract\r\n    address public vault;\r\n\r\n    // Instance of core contract\r\n    ICore public coreInstance;\r\n\r\n    // Instance of vault contract\r\n    IVault public vaultInstance;\r\n\r\n    /* ============ Public Getters ============ */\r\n\r\n    /**\r\n     * Constructor function for ModuleCoreState\r\n     *\r\n     * @param _core                The address of Core\r\n     * @param _vault               The address of Vault\r\n     */\r\n    constructor(\r\n        address _core,\r\n        address _vault\r\n    )\r\n        public\r\n    {\r\n        // Commit passed address to core state variable\r\n        core = _core;\r\n\r\n        // Commit passed address to coreInstance state variable\r\n        coreInstance = ICore(_core);\r\n\r\n        // Commit passed address to vault state variable\r\n        vault = _vault;\r\n\r\n        // Commit passed address to vaultInstance state variable\r\n        vaultInstance = IVault(_vault);\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/modules/lib/RebalancingSetIssuance.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingSetIssuance\r\n * @author Set Protocol\r\n *\r\n * The RebalancingSetIssuance contains utility functions used in rebalancing SetToken\r\n * issuance\r\n */\r\ncontract RebalancingSetIssuance is\r\n    ModuleCoreState\r\n{\r\n    using SafeMath for uint256;\r\n    using AddressArrayUtils for address[];\r\n\r\n    // ============ Internal ============\r\n\r\n    /**\r\n     * Validates that wrapped Ether is a component of the SetToken\r\n     *\r\n     * @param  _setAddress            Address of the SetToken\r\n     * @param  _wrappedEtherAddress   Address of wrapped Ether\r\n     */\r\n    function validateWETHIsAComponentOfSet(\r\n        address _setAddress,\r\n        address _wrappedEtherAddress\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            ISetToken(_setAddress).tokenIsComponent(_wrappedEtherAddress),\r\n            \"RebalancingSetIssuance.validateWETHIsAComponentOfSet: Components must contain weth\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Validates that the passed in address is tracked by Core and that the quantity\r\n     * is a multiple of the natural unit\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue/redeem\r\n     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\r\n     */\r\n    function validateRebalancingSetIssuance(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        // Expect rebalancing SetToken to be valid and enabled SetToken\r\n        require(\r\n            coreInstance.validSets(_rebalancingSetAddress),\r\n            \"RebalancingSetIssuance.validateRebalancingIssuance: Invalid or disabled SetToken address\"\r\n        );\r\n\r\n        // Make sure Issuance quantity is multiple of the rebalancing SetToken natural unit\r\n        require(\r\n            _rebalancingSetQuantity.mod(ISetToken(_rebalancingSetAddress).naturalUnit()) == 0,\r\n            \"RebalancingSetIssuance.validateRebalancingIssuance: Quantity must be multiple of natural unit\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Given a rebalancing SetToken and a desired issue quantity, calculates the\r\n     * minimum issuable quantity of the base SetToken. If the calculated quantity is initially\r\n     * not a multiple of the base SetToken's natural unit, the quantity is rounded up\r\n     * to the next base set natural unit.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\r\n     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\r\n     * @return requiredBaseSetQuantity   The quantity of base SetToken to issue\r\n     */\r\n    function getBaseSetIssuanceRequiredQuantity(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        IRebalancingSetToken rebalancingSet = IRebalancingSetToken(_rebalancingSetAddress);\r\n\r\n        uint256 unitShares = rebalancingSet.unitShares();\r\n        uint256 naturalUnit = rebalancingSet.naturalUnit();\r\n\r\n        uint256 requiredBaseSetQuantity = _rebalancingSetQuantity.div(naturalUnit).mul(unitShares);\r\n\r\n        address baseSet = rebalancingSet.currentSet();\r\n        uint256 baseSetNaturalUnit = ISetToken(baseSet).naturalUnit();\r\n\r\n        // If there is a mismatch between the required quantity and the base SetToken natural unit,\r\n        // round up to the next base SetToken natural unit if required.\r\n        uint256 roundDownQuantity = requiredBaseSetQuantity.mod(baseSetNaturalUnit);\r\n        if (roundDownQuantity > 0) {\r\n            requiredBaseSetQuantity = requiredBaseSetQuantity.sub(roundDownQuantity).add(baseSetNaturalUnit);\r\n        }\r\n\r\n        return requiredBaseSetQuantity;\r\n    }\r\n\r\n\r\n    /**\r\n     * Given a rebalancing SetToken address, retrieve the base SetToken quantity redeem quantity based on the quantity\r\n     * held in the Vault. Rounds down to the nearest base SetToken natural unit\r\n     *\r\n     * @param _baseSetAddress             The address of the base SetToken\r\n     * @return baseSetRedeemQuantity      The quantity of base SetToken to redeem\r\n     */\r\n    function getBaseSetRedeemQuantity(\r\n        address _baseSetAddress\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Get base SetToken Details from the rebalancing SetToken\r\n        uint256 baseSetNaturalUnit = ISetToken(_baseSetAddress).naturalUnit();\r\n        uint256 baseSetBalance = vaultInstance.getOwnerBalance(\r\n            _baseSetAddress,\r\n            address(this)\r\n        );\r\n\r\n        // Round the balance down to the base SetToken natural unit and return\r\n        return baseSetBalance.sub(baseSetBalance.mod(baseSetNaturalUnit));\r\n    }\r\n\r\n    /**\r\n     * Checks the base SetToken balances in the Vault and on the contract.\r\n     * Sends any positive quantity to the user directly or into the Vault\r\n     * depending on the keepChangeInVault flag.\r\n     *\r\n     * @param _baseSetAddress             The address of the base SetToken\r\n     * @param _transferProxyAddress       The address of the TransferProxy\r\n     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transferred to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function returnExcessBaseSet(\r\n        address _baseSetAddress,\r\n        address _transferProxyAddress,\r\n        bool _keepChangeInVault\r\n    )\r\n        internal\r\n    {\r\n        returnExcessBaseSetFromContract(_baseSetAddress, _transferProxyAddress, _keepChangeInVault);\r\n\r\n        returnExcessBaseSetInVault(_baseSetAddress, _keepChangeInVault);\r\n    }\r\n\r\n    /**\r\n     * Checks the base SetToken balances on the contract and sends\r\n     * any positive quantity to the user directly or into the Vault\r\n     * depending on the keepChangeInVault flag.\r\n     *\r\n     * @param _baseSetAddress             The address of the base SetToken\r\n     * @param _transferProxyAddress       The address of the TransferProxy\r\n     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function returnExcessBaseSetFromContract(\r\n        address _baseSetAddress,\r\n        address _transferProxyAddress,\r\n        bool _keepChangeInVault\r\n    )\r\n        internal\r\n    {\r\n        uint256 baseSetQuantity = ERC20Wrapper.balanceOf(_baseSetAddress, address(this));\r\n\r\n        if (baseSetQuantity == 0) {\r\n            return;\r\n        } else if (_keepChangeInVault) {\r\n            // Ensure base SetToken allowance\r\n            ERC20Wrapper.ensureAllowance(\r\n                _baseSetAddress,\r\n                address(this),\r\n                _transferProxyAddress,\r\n                baseSetQuantity\r\n            );\r\n\r\n            // Deposit base SetToken to the user\r\n            coreInstance.depositModule(\r\n                address(this),\r\n                msg.sender,\r\n                _baseSetAddress,\r\n                baseSetQuantity\r\n            );\r\n        } else {\r\n            // Transfer directly to the user\r\n            ERC20Wrapper.transfer(\r\n                _baseSetAddress,\r\n                msg.sender,\r\n                baseSetQuantity\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks the base SetToken balances in the Vault and sends\r\n     * any positive quantity to the user directly or into the Vault\r\n     * depending on the keepChangeInVault flag.\r\n     *\r\n     * @param _baseSetAddress             The address of the base SetToken\r\n     * @param  _keepChangeInVault         Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function returnExcessBaseSetInVault(\r\n        address _baseSetAddress,\r\n        bool _keepChangeInVault\r\n    )\r\n        internal\r\n    {\r\n        // Return base SetToken if any that are in the Vault\r\n        uint256 baseSetQuantityInVault = vaultInstance.getOwnerBalance(\r\n            _baseSetAddress,\r\n            address(this)\r\n        );\r\n\r\n        if (baseSetQuantityInVault == 0) {\r\n            return;\r\n        } else if (_keepChangeInVault) {\r\n            // Transfer ownership within the vault to the user\r\n            coreInstance.internalTransfer(\r\n                _baseSetAddress,\r\n                msg.sender,\r\n                baseSetQuantityInVault\r\n            );\r\n        } else {\r\n            // Transfer ownership directly to the user\r\n            coreInstance.withdrawModule(\r\n                address(this),\r\n                msg.sender,\r\n                _baseSetAddress,\r\n                baseSetQuantityInVault\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/modules/RebalancingSetIssuanceModule.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RebalancingSetIssuanceModule\r\n * @author Set Protocol\r\n *\r\n * A module that includes functions for issuing / redeeming rebalancing SetToken to/from its base components and ether.\r\n */\r\ncontract RebalancingSetIssuanceModule is\r\n    ModuleCoreState,\r\n    RebalancingSetIssuance,\r\n    ReentrancyGuard\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    // Address and instance of TransferProxy contract\r\n    address public transferProxy;\r\n\r\n    // Address and instance of Wrapped Ether contract\r\n    IWETH public weth;\r\n\r\n    /* ============ Events ============ */\r\n\r\n    event LogRebalancingSetIssue(\r\n        address indexed rebalancingSetAddress,\r\n        address indexed callerAddress,\r\n        uint256 rebalancingSetQuantity\r\n    );\r\n\r\n    event LogRebalancingSetRedeem(\r\n        address indexed rebalancingSetAddress,\r\n        address indexed callerAddress,\r\n        uint256 rebalancingSetQuantity\r\n    );\r\n\r\n    /* ============ Constructor ============ */\r\n\r\n    /**\r\n     * Constructor function for RebalancingSetIssuanceModule\r\n     *\r\n     * @param _core                The address of Core\r\n     * @param _vault               The address of Vault\r\n     * @param _transferProxy       The address of TransferProxy\r\n     * @param _weth                The address of Wrapped Ether\r\n     */\r\n    constructor(\r\n        address _core,\r\n        address _vault,\r\n        address _transferProxy,\r\n        IWETH _weth\r\n    )\r\n        public\r\n        ModuleCoreState(\r\n            _core,\r\n            _vault\r\n        )\r\n    {\r\n        // Commit the WETH instance\r\n        weth = _weth;\r\n\r\n        // Commit the transferProxy instance\r\n        transferProxy = _transferProxy;\r\n    }\r\n\r\n    /**\r\n     * Fallback function. Disallows ether to be sent to this contract without data except when\r\n     * unwrapping WETH.\r\n     */\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        require(\r\n            msg.sender == address(weth),\r\n            \"RebalancingSetIssuanceModule.fallback: Cannot receive ETH directly unless unwrapping WETH\"\r\n        );\r\n    }\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * Issue a rebalancing SetToken using the base components of the base SetToken.\r\n     * The base SetToken is then issued into the rebalancing SetToken. The base SetToken quantity issued is calculated\r\n     * by taking the rebalancing SetToken's quantity, unit shares, and natural unit. If the calculated quantity is not\r\n     * a multiple of the natural unit of the base SetToken, the quantity is rounded up to the base SetToken natural unit.\r\n     * NOTE: Potential to receive more baseSet than expected if someone transfers some to this module.\r\n     * Be careful with balance checks.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\r\n     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\r\n     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function issueRebalancingSet(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        bool _keepChangeInVault\r\n    )\r\n        external\r\n        nonReentrant\r\n    {\r\n        // Get baseSet address and quantity required for issuance of Rebalancing Set\r\n        (\r\n            address baseSetAddress,\r\n            uint256 requiredBaseSetQuantity\r\n        ) = getBaseSetAddressAndQuantity(_rebalancingSetAddress, _rebalancingSetQuantity);\r\n\r\n        // Issue base SetToken to this contract, held in this contract\r\n        coreInstance.issueModule(\r\n            msg.sender,\r\n            address(this),\r\n            baseSetAddress,\r\n            requiredBaseSetQuantity\r\n        );\r\n\r\n        // Ensure base SetToken allowance to the transferProxy\r\n        ERC20Wrapper.ensureAllowance(\r\n            baseSetAddress,\r\n            address(this),\r\n            transferProxy,\r\n            requiredBaseSetQuantity\r\n        );\r\n\r\n        // Issue rebalancing SetToken to the sender and return any excess base to sender\r\n        issueRebalancingSetAndReturnExcessBase(\r\n            _rebalancingSetAddress,\r\n            baseSetAddress,\r\n            _rebalancingSetQuantity,\r\n            _keepChangeInVault\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Issue a rebalancing SetToken using the base components and ether of the base SetToken. The ether is wrapped\r\n     * into wrapped Ether and utilized in issuance.\r\n     * The base SetToken is then issued and reissued into the rebalancing SetToken. Read more about base SetToken quantity\r\n     * in the issueRebalancingSet function.\r\n     * NOTE: Potential to receive more baseSet and ether dust than expected if someone transfers some to this module.\r\n     * Be careful with balance checks.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\r\n     * @param  _rebalancingSetQuantity   The issuance quantity of rebalancing SetToken\r\n     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function issueRebalancingSetWrappingEther(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        bool _keepChangeInVault\r\n    )\r\n        external\r\n        payable\r\n        nonReentrant\r\n    {\r\n        // Get baseSet address and quantity required for issuance of Rebalancing Set\r\n        (\r\n            address baseSetAddress,\r\n            uint256 requiredBaseSetQuantity\r\n        ) = getBaseSetAddressAndQuantity(_rebalancingSetAddress, _rebalancingSetQuantity);\r\n\r\n        // Validate that WETH is a component of baseSet\r\n        validateWETHIsAComponentOfSet(baseSetAddress, address(weth));\r\n\r\n        // Deposit all the required non-weth components to the vault under the name of this contract\r\n        // The required ether is wrapped and approved to the transferProxy\r\n        depositComponentsAndHandleEth(\r\n            baseSetAddress,\r\n            requiredBaseSetQuantity\r\n        );\r\n\r\n        // Issue base SetToken to this contract, with the base SetToken held in the Vault\r\n        coreInstance.issueInVault(\r\n            baseSetAddress,\r\n            requiredBaseSetQuantity\r\n        );\r\n\r\n        // Note: Don't need to set allowance of the base SetToken as the base SetToken is already in the vault\r\n\r\n        // Issue rebalancing SetToken to the sender and return any excess base to sender\r\n        issueRebalancingSetAndReturnExcessBase(\r\n            _rebalancingSetAddress,\r\n            baseSetAddress,\r\n            _rebalancingSetQuantity,\r\n            _keepChangeInVault\r\n        );\r\n\r\n        // Any eth that is not wrapped is sent back to the user\r\n        // Only the amount required for the base SetToken issuance is wrapped.\r\n        uint256 leftoverEth = address(this).balance;\r\n        if (leftoverEth > 0) {\r\n            msg.sender.transfer(leftoverEth);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Redeems a rebalancing SetToken into the base components of the base SetToken.\r\n     * NOTE: Potential to receive more baseSet than expected if someone transfers some to this module.\r\n     * Be careful with balance checks.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to redeem\r\n     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to redeem\r\n     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transfered to the user\r\n     *                                     or left in the vault\r\n     */\r\n    function redeemRebalancingSet(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        bool _keepChangeInVault\r\n    )\r\n        external\r\n        nonReentrant\r\n    {\r\n        // Validate the rebalancing SetToken is valid and the quantity is a multiple of the natural unit\r\n        validateRebalancingSetIssuance(_rebalancingSetAddress, _rebalancingSetQuantity);\r\n\r\n        // Redeem RB Set to the vault attributed to this contract\r\n        coreInstance.redeemModule(\r\n            msg.sender,\r\n            address(this),\r\n            _rebalancingSetAddress,\r\n            _rebalancingSetQuantity\r\n        );\r\n\r\n        // Calculate the base SetToken Redeem quantity\r\n        address baseSetAddress = IRebalancingSetToken(_rebalancingSetAddress).currentSet();\r\n        uint256 baseSetRedeemQuantity = getBaseSetRedeemQuantity(baseSetAddress);\r\n\r\n        // Withdraw base SetToken to this contract\r\n        coreInstance.withdraw(\r\n            baseSetAddress,\r\n            baseSetRedeemQuantity\r\n        );\r\n\r\n        // Redeem base SetToken and send components to the the user\r\n        // Set exclude to 0, as tokens in rebalancing SetToken are already whitelisted\r\n        coreInstance.redeemAndWithdrawTo(\r\n            baseSetAddress,\r\n            msg.sender,\r\n            baseSetRedeemQuantity,\r\n            0\r\n        );\r\n\r\n        // Transfer any change of the base SetToken to the end user\r\n        returnExcessBaseSet(baseSetAddress, transferProxy, _keepChangeInVault);\r\n\r\n        // Log RebalancingSetRedeem\r\n        emit LogRebalancingSetRedeem(\r\n            _rebalancingSetAddress,\r\n            msg.sender,\r\n            _rebalancingSetQuantity\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Redeems a rebalancing SetToken into the base components of the base SetToken. Unwraps\r\n     * wrapped ether and sends eth to the user. If no wrapped ether in Set then will REVERT.\r\n     * NOTE: Potential to receive more baseSet and ether dust than expected if someone transfers some to this module.\r\n     * Be careful with balance checks.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to redeem\r\n     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to redeem\r\n     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transferred to the user\r\n     *                                   or left in the vault\r\n     */\r\n    function redeemRebalancingSetUnwrappingEther(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        bool _keepChangeInVault\r\n    )\r\n        external\r\n        nonReentrant\r\n    {\r\n        // Validate the rebalancing SetToken is valid and the quantity is a multiple of the natural unit\r\n        validateRebalancingSetIssuance(_rebalancingSetAddress, _rebalancingSetQuantity);\r\n\r\n        address baseSetAddress = IRebalancingSetToken(_rebalancingSetAddress).currentSet();\r\n\r\n        validateWETHIsAComponentOfSet(baseSetAddress, address(weth));\r\n\r\n        // Redeem rebalancing SetToken to the vault attributed to this contract\r\n        coreInstance.redeemModule(\r\n            msg.sender,\r\n            address(this),\r\n            _rebalancingSetAddress,\r\n            _rebalancingSetQuantity\r\n        );\r\n\r\n        // Calculate the base SetToken Redeem quantity\r\n        uint256 baseSetRedeemQuantity = getBaseSetRedeemQuantity(baseSetAddress);\r\n\r\n        // Withdraw base SetToken to this contract\r\n        coreInstance.withdraw(\r\n            baseSetAddress,\r\n            baseSetRedeemQuantity\r\n        );\r\n\r\n        // Redeem the base SetToken. The components stay in the vault\r\n        coreInstance.redeem(\r\n            baseSetAddress,\r\n            baseSetRedeemQuantity\r\n        );\r\n\r\n        // Loop through the base SetToken components and transfer to sender.\r\n        withdrawComponentsToSenderWithEther(baseSetAddress);\r\n\r\n        // Transfer any change of the base SetToken to the end user\r\n        returnExcessBaseSet(baseSetAddress, transferProxy, _keepChangeInVault);\r\n\r\n        // Log RebalancingSetRedeem\r\n        emit LogRebalancingSetRedeem(\r\n            _rebalancingSetAddress,\r\n            msg.sender,\r\n            _rebalancingSetQuantity\r\n        );\r\n    }\r\n\r\n    /* ============ Private Functions ============ */\r\n\r\n    /**\r\n     * Gets base set address from rebalancing set token and calculates amount of base set needed\r\n     * for issuance.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the RebalancingSetToken to issue\r\n     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to issue\r\n     * @return baseSetAddress            The address of RebalancingSet's base SetToken\r\n     * @return requiredBaseSetQuantity   The quantity of base SetToken to issue\r\n     */\r\n    function getBaseSetAddressAndQuantity(\r\n        address _rebalancingSetAddress,\r\n        uint256 _rebalancingSetQuantity\r\n    )\r\n        internal\r\n        view\r\n        returns (address, uint256)\r\n    {\r\n        // Validate the rebalancing SetToken is valid and the quantity is a multiple of the natural unit\r\n        validateRebalancingSetIssuance(_rebalancingSetAddress, _rebalancingSetQuantity);\r\n\r\n        address baseSetAddress = IRebalancingSetToken(_rebalancingSetAddress).currentSet();\r\n\r\n        // Calculate required base SetToken quantity\r\n        uint256 requiredBaseSetQuantity = getBaseSetIssuanceRequiredQuantity(\r\n            _rebalancingSetAddress,\r\n            _rebalancingSetQuantity\r\n        );\r\n\r\n        return (baseSetAddress, requiredBaseSetQuantity);\r\n    }\r\n\r\n    /**\r\n     * Issues the rebalancing set token to sender and returns any excess baseSet.\r\n     *\r\n     * @param  _rebalancingSetAddress    Address of the rebalancing SetToken to issue\r\n     * @param  _baseSetAddress           Address of the rebalancing SetToken's base set\r\n     * @param  _rebalancingSetQuantity   The Quantity of the rebalancing SetToken to redeem\r\n     * @param  _keepChangeInVault        Boolean signifying whether excess base SetToken is transferred to the user\r\n     *                                   or left in the vault\r\n     */\r\n    function issueRebalancingSetAndReturnExcessBase(\r\n        address _rebalancingSetAddress,\r\n        address _baseSetAddress,\r\n        uint256 _rebalancingSetQuantity,\r\n        bool _keepChangeInVault\r\n    )\r\n        internal\r\n    {\r\n        // Issue rebalancing SetToken to the sender\r\n        coreInstance.issueTo(\r\n            msg.sender,\r\n            _rebalancingSetAddress,\r\n            _rebalancingSetQuantity\r\n        );\r\n\r\n        // Return any excess base SetToken token to the sender\r\n        returnExcessBaseSet(_baseSetAddress, transferProxy, _keepChangeInVault);\r\n\r\n        // Log RebalancingSetIssue\r\n        emit LogRebalancingSetIssue(\r\n            _rebalancingSetAddress,\r\n            msg.sender,\r\n            _rebalancingSetQuantity\r\n        );\r\n    }\r\n\r\n    /**\r\n     * During issuance, deposit the required quantity of base SetToken, wrap Ether, and deposit components\r\n     * (excluding Ether, which is deposited during issuance) to the Vault in the name of the module.\r\n     *\r\n     * @param  _baseSetAddress           Address of the base SetToken token\r\n     * @param  _baseSetQuantity          The Quantity of the base SetToken token to issue\r\n     */\r\n    function depositComponentsAndHandleEth(\r\n        address _baseSetAddress,\r\n        uint256 _baseSetQuantity\r\n    )\r\n        private\r\n    {\r\n        ISetToken baseSet = ISetToken(_baseSetAddress);\r\n\r\n        address[] memory baseSetComponents = baseSet.getComponents();\r\n        uint256[] memory baseSetUnits = baseSet.getUnits();\r\n        uint256 baseSetNaturalUnit = baseSet.naturalUnit();\r\n\r\n       // Loop through the base SetToken components and deposit components\r\n        for (uint256 i = 0; i < baseSetComponents.length; i++) {\r\n            address currentComponent = baseSetComponents[i];\r\n            uint256 currentUnit = baseSetUnits[i];\r\n\r\n            // Calculate required component quantity\r\n            uint256 currentComponentQuantity = _baseSetQuantity.div(baseSetNaturalUnit).mul(currentUnit);\r\n\r\n            // If address is weth, deposit weth and transfer eth\r\n            if (currentComponent == address(weth)) {\r\n                // Expect the ether included exceeds the required Weth quantity\r\n                require(\r\n                    msg.value >= currentComponentQuantity,\r\n                    \"RebalancingSetIssuanceModule.depositComponentsAndHandleEth: Not enough ether included for base SetToken\"\r\n                );\r\n\r\n                // wrap the required ether quantity\r\n                weth.deposit.value(currentComponentQuantity)();\r\n\r\n                // Ensure weth allowance\r\n                ERC20Wrapper.ensureAllowance(\r\n                    address(weth),\r\n                    address(this),\r\n                    transferProxy,\r\n                    currentComponentQuantity\r\n                );\r\n            } else {\r\n                // Deposit components to the vault in the name of the contract\r\n                coreInstance.depositModule(\r\n                    msg.sender,\r\n                    address(this),\r\n                    currentComponent,\r\n                    currentComponentQuantity\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * During redemption, withdraw the required quantity of base SetToken, unwrapping Ether, and withdraw\r\n     * components to the sender\r\n     *\r\n     * @param  _baseSetAddress           Address of the base SetToken\r\n     */\r\n    function withdrawComponentsToSenderWithEther(\r\n        address _baseSetAddress\r\n    )\r\n        private\r\n    {\r\n        address[] memory baseSetComponents = ISetToken(_baseSetAddress).getComponents();\r\n\r\n        // Loop through the base SetToken components.\r\n        for (uint256 i = 0; i < baseSetComponents.length; i++) {\r\n            address currentComponent = baseSetComponents[i];\r\n            uint256 currentComponentQuantity = vaultInstance.getOwnerBalance(\r\n                currentComponent,\r\n                address(this)\r\n            );\r\n\r\n            // If address is weth, withdraw weth and transfer eth to sender\r\n            if (currentComponent == address(weth)) {\r\n                // Transfer the wrapped ether to this address from the Vault\r\n                coreInstance.withdrawModule(\r\n                    address(this),\r\n                    address(this),\r\n                    address(weth),\r\n                    currentComponentQuantity\r\n                );\r\n\r\n                // Unwrap wrapped ether\r\n                weth.withdraw(currentComponentQuantity);\r\n\r\n                // Transfer to recipient\r\n                msg.sender.transfer(currentComponentQuantity);\r\n            } else {\r\n                // Withdraw component from the Vault and send to the user\r\n                coreInstance.withdrawModule(\r\n                    address(this),\r\n                    msg.sender,\r\n                    currentComponent,\r\n                    currentComponentQuantity\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/interfaces/IAddressToAddressWhiteList.sol\r\n\r\n/*\r\n    Copyright 2020 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title IAddressToAddressWhiteList\r\n * @author Set Protocol\r\n *\r\n * The IAddressToAddressWhiteList interface exposes the whitelist mapping to check components\r\n */\r\ninterface IAddressToAddressWhiteList {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * Returns value of key type address passed in (not in array form)\r\n     *\r\n     * @param  _key     Address to check\r\n     * @return bool                Whether passed in address is whitelisted\r\n     */\r\n    function whitelist(\r\n        address _key\r\n    )\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Verifies an array of addresses against the whitelist\r\n     *\r\n     * @param  _keys                Array of key type addresses to check if value exists\r\n     * @return bool                 Whether all addresses in the list are whitelisted\r\n     */\r\n    function areValidAddresses(\r\n        address[] calldata _keys\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Return array of value type addresses based on passed in key type addresses\r\n     *\r\n     * @param  _key                Array of key type addresses to get value type addresses for\r\n     * @return address[]           Array of value type addresses\r\n     */\r\n    function getValues(\r\n        address[] calldata _key\r\n    )\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /**\r\n     * Return value type address associated with a passed key type address\r\n     *\r\n     * @param  _key               Address of key type\r\n     * @return address            Address associated with _key\r\n     */\r\n    function getValue(\r\n        address _key\r\n    )\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Return array of all whitelisted addresses\r\n     *\r\n     * @return address[]      Array of key type addresses\r\n     */\r\n    function validAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n}\r\n\r\n// File: contracts/SmartWalletProd.sol\r\n\r\n// contracts/SmartWalletProd.sol\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SmartWalletProd is Initializable, ReentrancyGuardEmber, WhitelistedRoleEmber {\r\n    using SafeMath for uint256;\r\n\r\n    address constant public transfersProxy = 0x882d80D3a191859d64477eb78Cca46599307ec1C;\r\n    address payable constant public rebalancingSetExchangeIssuanceModule = 0xde697AC56b1bD9C0987c08911020f2341e274813;\r\n    address payable constant public rebalancingSetIssuanceModule = 0xDA6786379FF88729264d31d472FA917f5E561443;\r\n    address payable constant public cTokenaddressToAddressWhiteList = 0x5BA020a8835ed40936941562bdF42D66F65fc00f;\r\n\r\n    // Nonces to prevent replay attacks\r\n    mapping(uint256 => bool) private issueRebalancingSetUsedNonces;\r\n    mapping(uint256 => bool) private redeemRebalancingSetUsedNonces;\r\n\r\n    uint16 public constant version = 1;\r\n\r\n    event IssueRebalancingSetFromERC20Token(uint256 quantity);\r\n    event IssueRebalancingSetFromComponents(uint256 quantity);\r\n    event IssueBaseSetFromComponents(uint256 quantity, uint256 roundedQuantity);\r\n    event RedeemedRebalancingSetIntoERC20(address erc20, uint256 quantity);\r\n    event MissingComponentForIssueRebalancingSetFromAllComponents(address componentMissing);\r\n\r\n    function initialize(address _owner) public initializer {\r\n      WhitelistedRoleEmber.initialize(_owner);\r\n      ReentrancyGuardEmber.initialize();\r\n    }\r\n\r\n    function() external payable { }\r\n\r\n    function withdrawAllAdmin(address [] calldata _tokenAddresses)\r\n      external\r\n      nonReentrant\r\n      onlyWhitelistAdmin\r\n    {\r\n      for (uint i=0; i<_tokenAddresses.length; i++) {\r\n          uint256 tokenBalance = ERC20Wrapper.balanceOf(_tokenAddresses[i], address(this));\r\n          ERC20Wrapper.transfer(\r\n              _tokenAddresses[i],\r\n              msg.sender,\r\n              tokenBalance\r\n          );\r\n      }\r\n    }\r\n\r\n    function withdrawERC20(address _tokenAddress, address _to, uint256 _withdrawalAmount)\r\n      external\r\n      nonReentrant\r\n      onlyWhitelisted\r\n    {\r\n      uint256 tokenBalance = ERC20Wrapper.balanceOf(_tokenAddress, address(this));\r\n      require(tokenBalance >= _withdrawalAmount, \"Withdrawal amount is too high\");\r\n      require(this.isWhitelistAdmin(_to), \"You can only withdraw to an owner address\");\r\n      ERC20Wrapper.transfer(\r\n          _tokenAddress,\r\n          _to,\r\n          _withdrawalAmount\r\n      );\r\n    }\r\n\r\n    function withdrawETH(address payable _to, uint256 _withdrawalAmount)\r\n      external\r\n      nonReentrant\r\n      onlyWhitelisted\r\n    {\r\n      uint256 ethBalance = address(this).balance;\r\n      require(ethBalance >= _withdrawalAmount, \"Withdrawal amount is too high\");\r\n      require(this.isWhitelistAdmin(_to), \"You can only withdraw to an owner address\");\r\n      _to.transfer(_withdrawalAmount);\r\n    }\r\n\r\n\r\n    function getIssueRebalancingSetSigner(address _rebalancingSetAddress, address _paymentTokenAddress, uint256 _nonce, bytes memory _signature) private view returns (address) {\r\n      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(\r\n      keccak256(\r\n          abi.encodePacked(\r\n            _rebalancingSetAddress,\r\n            _paymentTokenAddress,\r\n            _nonce,\r\n            address(this)\r\n          )\r\n        )\r\n      );\r\n      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);\r\n    }\r\n\r\n    /**\r\n    * https://github.com/SetProtocol/set-protocol-contracts/blob/bb4f12cd07c7ba3adb8682e6b0f0f8b37953700c/contracts/core/modules/RebalancingSetExchangeIssuanceModule.sol\r\n    */\r\n    function issueRebalancingSetFromERC20(\r\n       address _rebalancingSetAddress,\r\n       uint256 _rebalancingSetQuantity,\r\n       address _paymentTokenAddress,\r\n       uint256 _paymentTokenQuantity,\r\n       ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\r\n       bytes memory _orderData,\r\n       uint256 _nonce,\r\n       bytes memory _signature\r\n    )\r\n      public\r\n      nonReentrant\r\n    {\r\n      require(!issueRebalancingSetUsedNonces[_nonce], \"Replay attack detected.\");\r\n      issueRebalancingSetUsedNonces[_nonce] = true;\r\n      address signer = getIssueRebalancingSetSigner(_rebalancingSetAddress, _paymentTokenAddress, _nonce, _signature);\r\n      require(signer != address(0), \"Invalid signature\");\r\n      require(isWhitelistAdmin(signer), \"signer is not an admin\");\r\n\r\n      uint256 paymentTokenBalance = ERC20Wrapper.balanceOf(_paymentTokenAddress, address(this));\r\n      require(paymentTokenBalance > 0, \"Zero payment token balance\");\r\n\r\n      // Need to approve transferProxy to move our payment erc20 token\r\n      ERC20Wrapper.approve(_paymentTokenAddress, transfersProxy, uint256(-1));\r\n\r\n      // Check if we already have all components\r\n      ISetToken baseSet = ISetToken(IRebalancingSetToken(_rebalancingSetAddress).currentSet());\r\n      if (baseSet.getComponents().length == 1 &&\r\n          (_paymentTokenAddress == baseSet.getComponents()[0]\r\n          || _paymentTokenAddress == IAddressToAddressWhiteList(cTokenaddressToAddressWhiteList).whitelist(baseSet.getComponents()[0])\r\n      )) {\r\n            // we have all base set components\r\n            RebalancingSetIssuanceModule(rebalancingSetIssuanceModule).issueRebalancingSet(\r\n              _rebalancingSetAddress, _rebalancingSetQuantity, true);\r\n      } else {\r\n        RebalancingSetExchangeIssuanceModule(rebalancingSetExchangeIssuanceModule).issueRebalancingSetWithERC20(\r\n          _rebalancingSetAddress,\r\n          _rebalancingSetQuantity,\r\n          _paymentTokenAddress,\r\n          _paymentTokenQuantity,\r\n          _exchangeIssuanceParams,\r\n          _orderData,\r\n          true\r\n        );\r\n      }\r\n\r\n      uint256 rebalancingTokenSetBalance = ERC20Wrapper.balanceOf(_rebalancingSetAddress, address(this));\r\n\r\n      emit IssueRebalancingSetFromERC20Token(rebalancingTokenSetBalance);\r\n\r\n      issueRebalancingSetFromRemainingComponents(_rebalancingSetAddress);\r\n    }\r\n\r\n    function issueRebalancingSetFromRemainingComponents(address _rebalancingSetAddress) private {\r\n      IRebalancingSetToken rebalancingSet = IRebalancingSetToken(_rebalancingSetAddress);\r\n      address baseSetAddress = rebalancingSet.currentSet();\r\n      ISetToken baseSet = ISetToken(baseSetAddress);\r\n\r\n      // We need to check we have all components\r\n      uint256 minPossibleBaseSetQuantity = 2**256 - 1;\r\n      bool missingComponents = false;\r\n      for (uint256 i = 0; i < baseSet.getComponents().length; i++) {\r\n        uint256 componentBalance = ERC20Wrapper.balanceOf(baseSet.getComponents()[i], address(this));\r\n        if (componentBalance == 0) {\r\n          // Nothing to do\r\n          emit MissingComponentForIssueRebalancingSetFromAllComponents(baseSet.getComponents()[i]);\r\n          missingComponents = true;\r\n          break;\r\n        }\r\n\r\n        ERC20Wrapper.approve(baseSet.getComponents()[i], transfersProxy, uint256(-1));\r\n\r\n        uint256 possibleBaseSetQuantity = baseSet.naturalUnit().div(baseSet.getUnits()[i]).mul(componentBalance);\r\n        if(possibleBaseSetQuantity < minPossibleBaseSetQuantity) {\r\n          minPossibleBaseSetQuantity = possibleBaseSetQuantity;\r\n        }\r\n      }\r\n\r\n      if (!missingComponents) {\r\n        // Need to round\r\n        uint256 rationalBaseSetQuantity = minPossibleBaseSetQuantity.div(baseSet.naturalUnit());\r\n        uint256 roundedBaseSetQuantity = rationalBaseSetQuantity.mul(baseSet.naturalUnit());\r\n\r\n        emit IssueBaseSetFromComponents(minPossibleBaseSetQuantity, roundedBaseSetQuantity);\r\n        uint256 rebalancingSetUnitShares = rebalancingSet.unitShares();\r\n        uint256 rebalancingSetNaturalUnits = rebalancingSet.naturalUnit();\r\n        uint256 impliedRebalancingSetQuantityFromBaseSet = roundedBaseSetQuantity\r\n          .mul(rebalancingSetNaturalUnits)\r\n          .div(rebalancingSetUnitShares);\r\n\r\n        uint256 rationalRebalancingSetQuantity = impliedRebalancingSetQuantityFromBaseSet.div(rebalancingSet.naturalUnit());\r\n        uint256 roundedRebalancingSetQuantity = rationalRebalancingSetQuantity.mul(rebalancingSet.naturalUnit());\r\n\r\n        RebalancingSetIssuanceModule(rebalancingSetIssuanceModule).issueRebalancingSet(\r\n          _rebalancingSetAddress, roundedRebalancingSetQuantity, true);\r\n\r\n        // Transfer outputToken to the caller\r\n        uint256 rebalancingTokenSetBalance = ERC20Wrapper.balanceOf(_rebalancingSetAddress, address(this));\r\n\r\n        emit IssueRebalancingSetFromComponents(rebalancingTokenSetBalance);\r\n\r\n      }\r\n    }\r\n\r\n    function getRedeemRebalancingSetSigner(address _rebalancingSetAddress, address _outputTokenAddress, address _to, uint256 _nonce, bytes memory _signature) private view returns (address) {\r\n      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(\r\n      keccak256(\r\n          abi.encodePacked(\r\n            _rebalancingSetAddress,\r\n            _outputTokenAddress,\r\n            _to,\r\n            _nonce,\r\n            address(this)\r\n          )\r\n        )\r\n      );\r\n      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);\r\n    }\r\n\r\n    function redeemRebalancingSetIntoERC20(\r\n      address _rebalancingSetAddress,\r\n      uint256 _rebalancingSetQuantity,\r\n      address _outputTokenAddress,\r\n      ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\r\n      bytes memory _orderData,\r\n      address _to,\r\n      uint256 _nonce,\r\n      bytes memory _signature\r\n    )\r\n        public\r\n        nonReentrant\r\n    {\r\n\r\n      require(!redeemRebalancingSetUsedNonces[_nonce], \"Replay attack detected.\");\r\n      redeemRebalancingSetUsedNonces[_nonce] = true;\r\n      address signer = getRedeemRebalancingSetSigner(_rebalancingSetAddress, _outputTokenAddress, _to, _nonce, _signature);\r\n      require(signer != address(0), \"Invalid signature\");\r\n      require(isWhitelistAdmin(signer), \"signer is not an admin\");\r\n\r\n      // Check if we already have the output token as a component of the set\r\n      ISetToken baseSet = ISetToken(IRebalancingSetToken(_rebalancingSetAddress).currentSet());\r\n      if (baseSet.getComponents().length == 1 &&\r\n          (_outputTokenAddress == baseSet.getComponents()[0]\r\n          ||\r\n          _outputTokenAddress == IAddressToAddressWhiteList(cTokenaddressToAddressWhiteList).whitelist(baseSet.getComponents()[0])\r\n      )) {\r\n        // we already have the output token as a base set component. no need to use exchanges.\r\n        RebalancingSetIssuanceModule(rebalancingSetIssuanceModule).redeemRebalancingSet(\r\n          _rebalancingSetAddress, _rebalancingSetQuantity, false);\r\n      } else {\r\n        RebalancingSetExchangeIssuanceModule(rebalancingSetExchangeIssuanceModule).redeemRebalancingSetIntoERC20(\r\n          _rebalancingSetAddress,\r\n          _rebalancingSetQuantity,\r\n          _outputTokenAddress,\r\n          _exchangeIssuanceParams,\r\n          _orderData,\r\n          false\r\n        );\r\n      }\r\n\r\n      // Transfer outputToken out of the smart wallet back to the owner\r\n      uint256 outputTokenBalance = ERC20Wrapper.balanceOf(_outputTokenAddress, address(this));\r\n\r\n      ERC20Wrapper.transfer(\r\n          _outputTokenAddress,\r\n          _to,\r\n          outputTokenBalance\r\n      );\r\n\r\n      emit RedeemedRebalancingSetIntoERC20(_outputTokenAddress, outputTokenBalance);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"withdrawAllAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cTokenaddressToAddressWhiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_withdrawalAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_withdrawalAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebalancingSetExchangeIssuanceModule\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebalancingSetIssuanceModule\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rebalancingSetAddress\",\"type\":\"address\"},{\"name\":\"_rebalancingSetQuantity\",\"type\":\"uint256\"},{\"name\":\"_paymentTokenAddress\",\"type\":\"address\"},{\"name\":\"_paymentTokenQuantity\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"setAddress\",\"type\":\"address\"},{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"sendTokenExchangeIds\",\"type\":\"uint8[]\"},{\"name\":\"sendTokens\",\"type\":\"address[]\"},{\"name\":\"sendTokenAmounts\",\"type\":\"uint256[]\"},{\"name\":\"receiveTokens\",\"type\":\"address[]\"},{\"name\":\"receiveTokenAmounts\",\"type\":\"uint256[]\"}],\"name\":\"_exchangeIssuanceParams\",\"type\":\"tuple\"},{\"name\":\"_orderData\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"issueRebalancingSetFromERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rebalancingSetAddress\",\"type\":\"address\"},{\"name\":\"_rebalancingSetQuantity\",\"type\":\"uint256\"},{\"name\":\"_outputTokenAddress\",\"type\":\"address\"},{\"components\":[{\"name\":\"setAddress\",\"type\":\"address\"},{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"sendTokenExchangeIds\",\"type\":\"uint8[]\"},{\"name\":\"sendTokens\",\"type\":\"address[]\"},{\"name\":\"sendTokenAmounts\",\"type\":\"uint256[]\"},{\"name\":\"receiveTokens\",\"type\":\"address[]\"},{\"name\":\"receiveTokenAmounts\",\"type\":\"uint256[]\"}],\"name\":\"_exchangeIssuanceParams\",\"type\":\"tuple\"},{\"name\":\"_orderData\",\"type\":\"bytes\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"redeemRebalancingSetIntoERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"addSignedWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"addSignedWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"IssueRebalancingSetFromERC20Token\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"IssueRebalancingSetFromComponents\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"roundedQuantity\",\"type\":\"uint256\"}],\"name\":\"IssueBaseSetFromComponents\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"RedeemedRebalancingSetIntoERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"componentMissing\",\"type\":\"address\"}],\"name\":\"MissingComponentForIssueRebalancingSetFromAllComponents\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"}]","ContractName":"SmartWalletProd","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"ERC20Wrapper:117fc64fe66cc14ab01e3fd46eb24a80c1201cad","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6bcc06e156bc2ee2a71e6c4af3b90e6aa89595b46d097362b8a01cdd84a5e07d"}]}