{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\nlibrary DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        // assert(y > 0); // Solidity automatically throws when dividing by 0\r\n        z = x / y;\r\n        // assert(x == y * z + x % y); // There is no case in which this doesn't hold\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title Staking and delegation contract\r\n * @author Dos Network\r\n */\r\n\r\ncontract ERC20I {\r\n    function balanceOf(address who) public view returns (uint);\r\n    function decimals() public view returns (uint);\r\n    function transfer(address to, uint value) public returns (bool);\r\n    function transferFrom(address from, address to, uint value) public returns (bool);\r\n    function approve(address spender, uint value) public returns (bool);\r\n}\r\n\r\ncontract DOSAddressBridgeInterface {\r\n    function getProxyAddress() public view returns(address);\r\n}\r\n\r\ncontract Staking {\r\n    using DSMath for *;\r\n\r\n    uint public constant ONEYEAR = 365 days;\r\n    uint public constant DOSDECIMAL = 18;\r\n    uint public constant DBDECIMAL = 0;\r\n    uint public constant LISTHEAD = 0x1;\r\n    uint public initBlkN;\r\n    address public admin;\r\n    address public DOSTOKEN;\r\n    address public DBTOKEN ;\r\n    address public stakingRewardsVault;\r\n    address public bridgeAddr;  // DOS address bridge\r\n    uint public minStakePerNode;\r\n    uint public dropburnMaxQuota;\r\n    uint public totalStakedTokens;\r\n    uint public circulatingSupply;\r\n    uint public unbondDuration;\r\n    uint public lastRateUpdatedTime;    // in seconds\r\n    uint public accumulatedRewardIndex; // Multiplied by 1e10\r\n\r\n    struct Node {\r\n        address ownerAddr;\r\n        uint rewardCut;  // %, [0, 100).\r\n        uint stakedDB;   // [0, dropburnMaxQuota]\r\n        uint selfStakedAmount;\r\n        uint totalOtherDelegatedAmount;\r\n        uint accumulatedRewards;\r\n        uint accumulatedRewardIndex;\r\n        uint pendingWithdrawToken;\r\n        uint pendingWithdrawDB;\r\n        uint lastStartTime;\r\n        bool running;\r\n        string description;\r\n        address[] nodeDelegators;\r\n        // release time => UnbondRequest metadata\r\n        mapping (uint => UnbondRequest) unbondRequests;\r\n        // LISTHEAD => release time 1 => ... => release time m => LISTHEAD\r\n        mapping (uint => uint) releaseTime;\r\n    }\r\n\r\n    struct UnbondRequest {\r\n        uint dosAmount;\r\n        uint dbAmount;\r\n    }\r\n\r\n    struct Delegation {\r\n        address delegatedNode;\r\n        uint delegatedAmount;\r\n        uint accumulatedRewards; // in tokens\r\n        uint accumulatedRewardIndex;\r\n        uint pendingWithdraw;\r\n\r\n        // release time => UnbondRequest metadata\r\n        mapping (uint => UnbondRequest) unbondRequests;\r\n        // LISTHEAD => release time 1 => ... => release time m => LISTHEAD\r\n        mapping (uint => uint) releaseTime;\r\n    }\r\n\r\n    // 1:1 node address => Node metadata\r\n    mapping (address => Node) public nodes;\r\n    address[] public nodeAddrs;\r\n\r\n    // node runner's main address => {node addresses}\r\n    mapping (address => mapping(address => bool)) public nodeRunners;\r\n    // 1:n token holder address => {delegated node 1 : Delegation, ..., delegated node n : Delegation}\r\n    mapping (address => mapping(address => Delegation)) public delegators;\r\n\r\n    event UpdateStakingAdmin(address oldAdmin, address newAdmin);\r\n    event UpdateDropBurnMaxQuota(uint oldQuota, uint newQuota);\r\n    event UpdateUnbondDuration(uint oldDuration, uint newDuration);\r\n    event UpdateCirculatingSupply(uint oldCirculatingSupply, uint newCirculatingSupply);\r\n    event UpdateMinStakePerNode(uint oldMinStakePerNode, uint newMinStakePerNode);\r\n    event NewNode(address indexed owner, address indexed nodeAddress, uint selfStakedAmount, uint stakedDB, uint rewardCut);\r\n    event Delegate(address indexed from, address indexed to, uint amount);\r\n    event Withdraw(address indexed from, address indexed to, bool nodeRunner, uint tokenAmount, uint dbAmount);\r\n    event Unbond(address indexed from, address indexed to, bool nodeRunner, uint tokenAmount, uint dropburnAmount);\r\n    event ClaimReward(address indexed to, bool nodeRunner, uint amount);\r\n\r\n    constructor(address _dostoken, address _dbtoken, address _vault, address _bridgeAddr) public {\r\n        initialize(_dostoken, _dbtoken, _vault, _bridgeAddr);\r\n    }\r\n\r\n    function initialize(address _dostoken, address _dbtoken, address _vault, address _bridgeAddr) public {\r\n        require(initBlkN == 0, \"already-initialized\");\r\n\r\n        initBlkN = block.number;\r\n        admin = msg.sender;\r\n        DOSTOKEN = _dostoken;\r\n        DBTOKEN = _dbtoken;\r\n        stakingRewardsVault = _vault;\r\n        bridgeAddr = _bridgeAddr;\r\n        minStakePerNode = 800000 * (10 ** DOSDECIMAL);\r\n        dropburnMaxQuota = 3;\r\n        circulatingSupply = 345000000 * (10 ** DOSDECIMAL);\r\n        unbondDuration = 7 days;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin, \"onlyAdmin\");\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit UpdateStakingAdmin(admin, newAdmin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    /// @dev used when drop burn max quota duration is changed\r\n    function setDropBurnMaxQuota(uint _quota) public onlyAdmin {\r\n        require(_quota != dropburnMaxQuota && _quota < 10, \"valid-dropburnMaxQuota-0-to-9\");\r\n        emit UpdateDropBurnMaxQuota(dropburnMaxQuota, _quota);\r\n        dropburnMaxQuota = _quota;\r\n    }\r\n\r\n    /// @dev used when withdraw duration is changed\r\n    function setUnbondDuration(uint _duration) public onlyAdmin {\r\n        emit UpdateUnbondDuration(unbondDuration, _duration);\r\n        unbondDuration = _duration;\r\n    }\r\n\r\n    /// @dev used when locked token is unlocked\r\n    function setCirculatingSupply(uint _newSupply) public onlyAdmin {\r\n        require(circulatingSupply >= totalStakedTokens,\"CirculatingSupply < totalStakedTokens\");\r\n\r\n        updateGlobalRewardIndex();\r\n        emit UpdateCirculatingSupply(circulatingSupply, _newSupply);\r\n        circulatingSupply = _newSupply;\r\n    }\r\n\r\n    /// @dev used when minStakePerNode is updated\r\n    function setMinStakePerNode(uint _minStake) public onlyAdmin {\r\n        emit UpdateMinStakePerNode(minStakePerNode, _minStake);\r\n        minStakePerNode = _minStake;\r\n    }\r\n\r\n    function getNodeAddrs() public view returns(address[] memory) {\r\n        return nodeAddrs;\r\n    }\r\n\r\n    modifier checkStakingValidity(uint _tokenAmount, uint _dropburnAmount, uint _rewardCut) {\r\n        require(0 <= _rewardCut && _rewardCut < 100, \"not-valid-rewardCut-in-0-to-99\");\r\n        require(_tokenAmount >= minStakePerNode.mul(10.sub(DSMath.min(_dropburnAmount, dropburnMaxQuota))).div(10),\r\n                \"not-enough-dos-token-to-start-node\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFromProxy() {\r\n        require(msg.sender == DOSAddressBridgeInterface(bridgeAddr).getProxyAddress(), \"not-from-dos-proxy\");\r\n        _;\r\n    }\r\n\r\n    function isValidStakingNode(address nodeAddr) public view returns(bool) {\r\n        Node storage node = nodes[nodeAddr];\r\n        uint _tokenAmount = node.selfStakedAmount;\r\n        uint _dropburnAmount = node.stakedDB;\r\n        if (_tokenAmount >= minStakePerNode.mul(10.sub(DSMath.min(_dropburnAmount, dropburnMaxQuota))).div(10)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function newNode(address _nodeAddr, uint _tokenAmount, uint _dropburnAmount, uint _rewardCut, string memory _desc)\r\n        public checkStakingValidity(_tokenAmount, _dropburnAmount, _rewardCut)\r\n    {\r\n        require(!nodeRunners[msg.sender][_nodeAddr], \"node-already-registered\");\r\n        require(nodes[_nodeAddr].ownerAddr == address(0), \"node-already-registered\");\r\n\r\n        nodeRunners[msg.sender][_nodeAddr] = true;\r\n        address[] memory nodeDelegators;\r\n        nodes[_nodeAddr] = Node(msg.sender, _rewardCut, _dropburnAmount, _tokenAmount, 0, 0, 0, 0, 0, 0, false, _desc, nodeDelegators);\r\n        nodes[_nodeAddr].releaseTime[LISTHEAD] = LISTHEAD;\r\n        nodeAddrs.push(_nodeAddr);\r\n        // This would change interest rate\r\n        totalStakedTokens = totalStakedTokens.add(_tokenAmount);\r\n        // Deposit tokens.\r\n        ERC20I(DOSTOKEN).transferFrom(msg.sender, address(this), _tokenAmount);\r\n        if (_dropburnAmount > 0) {\r\n            ERC20I(DBTOKEN).transferFrom(msg.sender, address(this), _dropburnAmount);\r\n        }\r\n        emit NewNode(msg.sender, _nodeAddr, _tokenAmount, _dropburnAmount, _rewardCut);\r\n    }\r\n\r\n    function nodeStart(address _nodeAddr) public onlyFromProxy {\r\n        require(nodes[_nodeAddr].ownerAddr != address(0), \"node-not-registered\");\r\n        Node storage node = nodes[_nodeAddr];\r\n        if (!node.running) {\r\n            node.running = true;\r\n            node.lastStartTime = now;\r\n            updateGlobalRewardIndex();\r\n            node.accumulatedRewardIndex = accumulatedRewardIndex;\r\n            for (uint i = 0; i < node.nodeDelegators.length; i++) {\r\n                Delegation storage delegator = delegators[node.nodeDelegators[i]][_nodeAddr];\r\n                delegator.accumulatedRewardIndex = accumulatedRewardIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    function nodeStop(address _nodeAddr) public onlyFromProxy {\r\n        require(nodes[_nodeAddr].ownerAddr != address(0), \"node-not-registered\");\r\n        nodeStopInternal(_nodeAddr);\r\n    }\r\n\r\n    function nodeStopInternal(address _nodeAddr) internal {\r\n        Node storage node = nodes[_nodeAddr];\r\n        if (node.running) {\r\n            updateGlobalRewardIndex();\r\n            node.accumulatedRewards = getNodeRewardTokens(_nodeAddr);\r\n            node.accumulatedRewardIndex = accumulatedRewardIndex;\r\n            for (uint i = 0; i < node.nodeDelegators.length; i++) {\r\n                Delegation storage delegator = delegators[node.nodeDelegators[i]][_nodeAddr];\r\n                delegator.accumulatedRewards = getDelegatorRewardTokens(node.nodeDelegators[i], _nodeAddr);\r\n                delegator.accumulatedRewardIndex = accumulatedRewardIndex;\r\n            }\r\n            node.running = false;\r\n        }\r\n    }\r\n\r\n    // For node runners to configure new staking settings.\r\n    function updateNodeStaking(address _nodeAddr, uint _newTokenAmount, uint _newDropburnAmount, uint _newCut) public {\r\n        require(nodeRunners[msg.sender][_nodeAddr], \"node-not-owned-by-msgSender\");\r\n\r\n        Node storage node = nodes[_nodeAddr];\r\n        // _newCut with value uint(-1) means skipping this config.\r\n        if (_newCut != uint(-1)) {\r\n            require(_newCut >= 0 && _newCut < 100, \"not-valid-rewardCut-in-0-to-99\");\r\n            // TODO: Update rewardCut affects delegators' reward calculation.\r\n            node.rewardCut = _newCut;\r\n        }\r\n        if (_newDropburnAmount != 0) {\r\n            node.stakedDB = node.stakedDB.add(_newDropburnAmount);\r\n            ERC20I(DBTOKEN).transferFrom(msg.sender, address(this), _newDropburnAmount);\r\n        }\r\n        if (_newTokenAmount != 0) {\r\n            node.selfStakedAmount = node.selfStakedAmount.add(_newTokenAmount);\r\n            if (node.running) {\r\n                // Update global accumulated interest index.\r\n                updateGlobalRewardIndex();\r\n                node.accumulatedRewards = getNodeRewardTokens(_nodeAddr);\r\n                node.accumulatedRewardIndex = accumulatedRewardIndex;\r\n            }\r\n            // This would change interest rate\r\n            totalStakedTokens = totalStakedTokens.add(_newTokenAmount);\r\n            ERC20I(DOSTOKEN).transferFrom(msg.sender, address(this), _newTokenAmount);\r\n        }\r\n    }\r\n\r\n    // Token holders (delegators) call this function. It's allowed to delegate to the same node multiple times if possible.\r\n    // Note: Re-delegate is not supported.\r\n    function delegate(uint _tokenAmount, address _nodeAddr) public {\r\n        Node storage node = nodes[_nodeAddr];\r\n        require(node.ownerAddr != address(0), \"node-not-exist\");\r\n        require(msg.sender != node.ownerAddr, \"node-owner-cannot-self-delegate\");\r\n\r\n        Delegation storage delegator = delegators[msg.sender][_nodeAddr];\r\n        require(delegator.delegatedNode == address(0) || delegator.delegatedNode == _nodeAddr, \"invalid-delegated-node-addr\");\r\n\r\n        node.nodeDelegators.push(msg.sender);\r\n        node.totalOtherDelegatedAmount = node.totalOtherDelegatedAmount.add(_tokenAmount);\r\n        if (node.running) {\r\n            // Update global accumulated interest index.\r\n            updateGlobalRewardIndex();\r\n            node.accumulatedRewards = getNodeRewardTokens(_nodeAddr);\r\n            node.accumulatedRewardIndex = accumulatedRewardIndex;\r\n            delegator.accumulatedRewards = getDelegatorRewardTokens(msg.sender, _nodeAddr);\r\n            delegator.accumulatedRewardIndex = accumulatedRewardIndex;\r\n        }\r\n        delegator.delegatedAmount = delegator.delegatedAmount.add(_tokenAmount);\r\n        if (delegator.delegatedNode == address(0)) {\r\n            // New delegation\r\n            delegator.delegatedNode = _nodeAddr;\r\n            delegator.releaseTime[LISTHEAD] = LISTHEAD;\r\n        }\r\n        // This would change interest rate\r\n        totalStakedTokens = totalStakedTokens.add(_tokenAmount);\r\n        ERC20I(DOSTOKEN).transferFrom(msg.sender, address(this), _tokenAmount);\r\n        emit Delegate(msg.sender, _nodeAddr, _tokenAmount);\r\n    }\r\n\r\n    function nodeUnregister(address _nodeAddr) public {\r\n        require(nodeRunners[msg.sender][_nodeAddr], \"node-not-owned-by-msgSender\");\r\n        Node storage node = nodes[_nodeAddr];\r\n        nodeStopInternal(_nodeAddr);\r\n        nodeUnbondInternal(node.selfStakedAmount, node.stakedDB, _nodeAddr);\r\n    }\r\n\r\n    function nodeTryDelete(address _nodeAddr) internal {\r\n        if (!nodes[_nodeAddr].running &&\r\n            nodes[_nodeAddr].selfStakedAmount == 0 &&\r\n            nodes[_nodeAddr].stakedDB == 0 &&\r\n            nodes[_nodeAddr].totalOtherDelegatedAmount == 0 &&\r\n            nodes[_nodeAddr].accumulatedRewards == 0 &&\r\n            nodes[_nodeAddr].nodeDelegators.length == 0 &&\r\n            nodes[_nodeAddr].pendingWithdrawToken == 0 &&\r\n            nodes[_nodeAddr].pendingWithdrawDB == 0\r\n        ) {\r\n            delete nodeRunners[nodes[_nodeAddr].ownerAddr][_nodeAddr];\r\n            delete nodes[_nodeAddr];\r\n            for (uint idx = 0; idx < nodeAddrs.length; idx++) {\r\n                if (nodeAddrs[idx] == _nodeAddr) {\r\n                    nodeAddrs[idx] = nodeAddrs[nodeAddrs.length - 1];\r\n                    nodeAddrs.length--;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Used by node runners to unbond their stakes.\r\n    // Unbonded tokens are locked for 7 days, during the unbonding period they're not eligible for staking rewards.\r\n    function nodeUnbond(uint _tokenAmount, uint _dropburnAmount, address _nodeAddr) public {\r\n        require(nodeRunners[msg.sender][_nodeAddr], \"node-not-owned-by-msgSender\");\r\n        Node storage node = nodes[_nodeAddr];\r\n\r\n        require(_tokenAmount <= node.selfStakedAmount, \"invalid-to-unbond-more-than-staked-amount\");\r\n        require(_dropburnAmount <= node.stakedDB, \"invalid-to-unbond-more-than-staked-DropBurn-amount\");\r\n        require(node.selfStakedAmount.sub(_tokenAmount) >=\r\n                minStakePerNode.mul(10.sub(DSMath.min(node.stakedDB.sub(_dropburnAmount), dropburnMaxQuota))).div(10),\r\n                \"invalid-unbond-to-maintain-staking-requirement\");\r\n        nodeUnbondInternal(_tokenAmount, _dropburnAmount, _nodeAddr);\r\n    }\r\n    // Used by node runners to unbond their stakes.\r\n    // Unbonded tokens are locked for 7 days, during the unbonding period they're not eligible for staking rewards.\r\n    function nodeUnbondInternal(uint _tokenAmount, uint _dropburnAmount, address _nodeAddr) internal {\r\n        require(nodeRunners[msg.sender][_nodeAddr], \"node-not-owned-by-msgSender\");\r\n        Node storage node = nodes[_nodeAddr];\r\n        if (node.running) {\r\n            updateGlobalRewardIndex();\r\n            node.accumulatedRewards = getNodeRewardTokens(_nodeAddr);\r\n            node.accumulatedRewardIndex = accumulatedRewardIndex;\r\n        }\r\n        // This would change interest rate\r\n        totalStakedTokens = totalStakedTokens.sub(_tokenAmount);\r\n        node.selfStakedAmount = node.selfStakedAmount.sub(_tokenAmount);\r\n        node.pendingWithdrawToken = node.pendingWithdrawToken.add(_tokenAmount);\r\n        node.stakedDB = node.stakedDB.sub(_dropburnAmount);\r\n        node.pendingWithdrawDB = node.pendingWithdrawDB.add(_dropburnAmount);\r\n\r\n        if (_tokenAmount > 0 || _dropburnAmount > 0) {\r\n            // create an UnbondRequest\r\n            uint releaseTime = now.add(unbondDuration);\r\n            node.unbondRequests[releaseTime] = UnbondRequest(_tokenAmount, _dropburnAmount);\r\n            node.releaseTime[releaseTime] = node.releaseTime[LISTHEAD];\r\n            node.releaseTime[LISTHEAD] = releaseTime;\r\n        }\r\n\r\n        emit Unbond(msg.sender, _nodeAddr, true, _tokenAmount, _dropburnAmount);\r\n    }\r\n\r\n    // Used by token holders (delegators) to unbond their delegations.\r\n    function delegatorUnbond(uint _tokenAmount, address _nodeAddr) public {\r\n        Delegation storage delegator = delegators[msg.sender][_nodeAddr];\r\n        require(nodes[_nodeAddr].ownerAddr != address(0), \"node-not-exist\");\r\n        require(delegator.delegatedNode == _nodeAddr, \"invalid-unbond-from-non-delegated-node\");\r\n        require(_tokenAmount <= delegator.delegatedAmount, \"invalid-unbond-more-than-delegated-amount\");\r\n        if (nodes[_nodeAddr].running) {\r\n            updateGlobalRewardIndex();\r\n            delegator.accumulatedRewards = getDelegatorRewardTokens(msg.sender, _nodeAddr);\r\n            delegator.accumulatedRewardIndex = accumulatedRewardIndex;\r\n            nodes[_nodeAddr].accumulatedRewards = getNodeRewardTokens(_nodeAddr);\r\n            nodes[_nodeAddr].accumulatedRewardIndex = accumulatedRewardIndex;\r\n        }\r\n        // This would change interest rate\r\n        totalStakedTokens = totalStakedTokens.sub(_tokenAmount);\r\n        delegator.delegatedAmount = delegator.delegatedAmount.sub(_tokenAmount);\r\n        delegator.pendingWithdraw = delegator.pendingWithdraw.add(_tokenAmount);\r\n        nodes[_nodeAddr].totalOtherDelegatedAmount = nodes[_nodeAddr].totalOtherDelegatedAmount.sub(_tokenAmount);\r\n\r\n        if (_tokenAmount > 0) {\r\n            // create a UnbondRequest\r\n            uint releaseTime = now.add(unbondDuration);\r\n            delegator.unbondRequests[releaseTime] = UnbondRequest(_tokenAmount, 0);\r\n            delegator.releaseTime[releaseTime] = delegator.releaseTime[LISTHEAD];\r\n            delegator.releaseTime[LISTHEAD] = releaseTime;\r\n        }\r\n\r\n        emit Unbond(msg.sender, _nodeAddr, false, _tokenAmount, 0);\r\n    }\r\n\r\n    function withdrawAll(mapping(uint => uint) storage releaseTimeList, mapping(uint => UnbondRequest) storage requestList)\r\n        internal\r\n        returns(uint, uint)\r\n    {\r\n        uint accumulatedDos = 0;\r\n        uint accumulatedDropburn = 0;\r\n        uint prev = LISTHEAD;\r\n        uint curr = releaseTimeList[prev];\r\n        while (curr != LISTHEAD && curr > now) {\r\n            prev = curr;\r\n            curr = releaseTimeList[prev];\r\n        }\r\n        if (releaseTimeList[prev] != LISTHEAD) {\r\n            releaseTimeList[prev] = LISTHEAD;\r\n        }\r\n        // All next items are withdrawable.\r\n        while (curr != LISTHEAD) {\r\n            accumulatedDos = accumulatedDos.add(requestList[curr].dosAmount);\r\n            accumulatedDropburn = accumulatedDropburn.add(requestList[curr].dbAmount);\r\n            prev = curr;\r\n            curr = releaseTimeList[prev];\r\n            delete releaseTimeList[prev];\r\n            delete requestList[prev];\r\n        }\r\n        return (accumulatedDos, accumulatedDropburn);\r\n    }\r\n\r\n    /// @dev A view version of above call with equivalent functionality, used by other view functions.\r\n    function withdrawable(mapping(uint => uint) storage releaseTimeList, mapping(uint => UnbondRequest) storage requestList)\r\n        internal\r\n        view\r\n        returns(uint, uint)\r\n    {\r\n        uint accumulatedDos = 0;\r\n        uint accumulatedDropburn = 0;\r\n        uint prev = LISTHEAD;\r\n        uint curr = releaseTimeList[prev];\r\n        while (curr != LISTHEAD && curr > now) {\r\n            prev = curr;\r\n            curr = releaseTimeList[prev];\r\n        }\r\n        // All next items are withdrawable.\r\n        while (curr != LISTHEAD) {\r\n            accumulatedDos = accumulatedDos.add(requestList[curr].dosAmount);\r\n            accumulatedDropburn = accumulatedDropburn.add(requestList[curr].dbAmount);\r\n            prev = curr;\r\n            curr = releaseTimeList[prev];\r\n\r\n        }\r\n        return (accumulatedDos, accumulatedDropburn);\r\n    }\r\n\r\n    // Node runners call this function to withdraw available unbonded tokens after unbond period.\r\n    function nodeWithdraw(address _nodeAddr) public {\r\n        Node storage node = nodes[_nodeAddr];\r\n        require(node.ownerAddr == msg.sender, \"non-owner-not-authorized-to-withdraw\");\r\n\r\n        (uint tokenAmount, uint dropburnAmount) = withdrawAll(node.releaseTime, node.unbondRequests);\r\n        node.pendingWithdrawToken = node.pendingWithdrawToken.sub(tokenAmount);\r\n        node.pendingWithdrawDB = node.pendingWithdrawDB.sub(dropburnAmount);\r\n\r\n        nodeTryDelete(_nodeAddr);\r\n\r\n        if (tokenAmount > 0) {\r\n            ERC20I(DOSTOKEN).transfer(msg.sender, tokenAmount);\r\n        }\r\n        if (dropburnAmount > 0) {\r\n            ERC20I(DBTOKEN).transfer(msg.sender, dropburnAmount);\r\n        }\r\n        emit Withdraw(_nodeAddr, msg.sender, true, tokenAmount, dropburnAmount);\r\n    }\r\n\r\n    // Delegators call this function to withdraw available unbonded tokens from a specific node after unbond period.\r\n    function delegatorWithdraw(address _nodeAddr) public {\r\n        Delegation storage delegator = delegators[msg.sender][_nodeAddr];\r\n        require(nodes[_nodeAddr].ownerAddr != address(0), \"node-not-exist\");\r\n        require(delegator.delegatedNode == _nodeAddr, \"cannot-withdraw-from-non-delegated-node\");\r\n\r\n        (uint tokenAmount, ) = withdrawAll(delegator.releaseTime, delegator.unbondRequests);\r\n        if (tokenAmount > 0) {\r\n            delegator.pendingWithdraw = delegator.pendingWithdraw.sub(tokenAmount);\r\n            if (delegator.delegatedAmount == 0 && delegator.pendingWithdraw == 0 && delegator.accumulatedRewards == 0) {\r\n                delete delegators[msg.sender][_nodeAddr];\r\n                uint idx = 0;\r\n                for (; idx < nodes[_nodeAddr].nodeDelegators.length; idx++) {\r\n                    if (nodes[_nodeAddr].nodeDelegators[idx] == msg.sender) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (idx < nodes[_nodeAddr].nodeDelegators.length) {\r\n                    nodes[_nodeAddr].nodeDelegators[idx] = nodes[_nodeAddr].nodeDelegators[nodes[_nodeAddr].nodeDelegators.length - 1];\r\n                    nodes[_nodeAddr].nodeDelegators.length--;\r\n                }\r\n                nodeTryDelete(_nodeAddr);\r\n            }\r\n\r\n            ERC20I(DOSTOKEN).transfer(msg.sender, tokenAmount);\r\n        }\r\n        emit Withdraw(_nodeAddr, msg.sender, false, tokenAmount, 0);\r\n    }\r\n\r\n    function nodeWithdrawable(address _owner, address _nodeAddr) public view returns(uint, uint) {\r\n        Node storage node = nodes[_nodeAddr];\r\n        if (node.ownerAddr != _owner) return (0, 0);\r\n        return withdrawable(node.releaseTime, node.unbondRequests);\r\n    }\r\n\r\n    function delegatorWithdrawable(address _owner, address _nodeAddr) public view returns(uint) {\r\n        Delegation storage delegator = delegators[_owner][_nodeAddr];\r\n        if (delegator.delegatedNode != _nodeAddr) return 0;\r\n        uint tokenAmount = 0;\r\n        (tokenAmount, ) = withdrawable(delegator.releaseTime, delegator.unbondRequests);\r\n        return tokenAmount;\r\n    }\r\n\r\n    function nodeClaimReward(address _nodeAddr) public {\r\n        Node storage node = nodes[_nodeAddr];\r\n        require(node.ownerAddr == msg.sender, \"non-owner-not-authorized-to-claim\");\r\n        updateGlobalRewardIndex();\r\n        uint claimedReward = getNodeRewardTokens(_nodeAddr);\r\n        node.accumulatedRewards = 0;\r\n        node.accumulatedRewardIndex = accumulatedRewardIndex;\r\n        // This would change interest rate\r\n        circulatingSupply = circulatingSupply.add(claimedReward);\r\n        ERC20I(DOSTOKEN).transferFrom(stakingRewardsVault, msg.sender, claimedReward);\r\n        emit ClaimReward(msg.sender, true, claimedReward);\r\n    }\r\n\r\n    function delegatorClaimReward(address _nodeAddr) public {\r\n        Delegation storage delegator = delegators[msg.sender][_nodeAddr];\r\n        require(nodes[_nodeAddr].ownerAddr != address(0), \"node-not-exist\");\r\n        require(delegator.delegatedNode == _nodeAddr, \"cannot-claim-from-non-delegated-node\");\r\n        updateGlobalRewardIndex();\r\n        uint claimedReward = getDelegatorRewardTokens(msg.sender, _nodeAddr);\r\n\r\n        if (delegator.delegatedAmount == 0 && delegator.pendingWithdraw == 0) {\r\n            delete delegators[msg.sender][_nodeAddr];\r\n        } else {\r\n            delegator.accumulatedRewards = 0;\r\n            delegator.accumulatedRewardIndex = accumulatedRewardIndex;\r\n        }\r\n        // This would change interest rate\r\n        circulatingSupply = circulatingSupply.add(claimedReward);\r\n        ERC20I(DOSTOKEN).transferFrom(stakingRewardsVault, msg.sender, claimedReward);\r\n        emit ClaimReward(msg.sender, false, claimedReward);\r\n    }\r\n\r\n    function getNodeUptime(address nodeAddr) public view returns(uint) {\r\n        Node storage node = nodes[nodeAddr];\r\n        if (node.running) {\r\n            return now.sub(node.lastStartTime);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // return a percentage in [4.00, 80.00] (400, 8000)\r\n    function getCurrentAPR() public view returns (uint) {\r\n        if (totalStakedTokens == 0) {\r\n            return 8000;\r\n        }\r\n        uint localinverseStakeRatio = circulatingSupply.mul(1e4).div(totalStakedTokens);\r\n        if (localinverseStakeRatio > 20 * 1e4) {\r\n            // staking rate <= 5%, APR 80%\r\n            return 8000;\r\n        } else {\r\n            return localinverseStakeRatio.div(25);\r\n        }\r\n    }\r\n\r\n    function rewardRateDelta() internal view returns (uint) {\r\n        return now.sub(lastRateUpdatedTime).mul(getCurrentAPR()).mul(1e6).div(ONEYEAR);\r\n    }\r\n\r\n    function updateGlobalRewardIndex() internal {\r\n        accumulatedRewardIndex = accumulatedRewardIndex.add(rewardRateDelta());\r\n        lastRateUpdatedTime = now;\r\n    }\r\n\r\n    function getNodeRewardsCore(Node storage _n, uint _indexRT) internal view returns(uint) {\r\n        if (!_n.running) return _n.accumulatedRewards;\r\n        return\r\n            _n.accumulatedRewards.add(\r\n                _n.selfStakedAmount.add(_n.totalOtherDelegatedAmount.mul(_n.rewardCut).div(100)).mul(\r\n                    _indexRT.sub(_n.accumulatedRewardIndex)\r\n                ).div(1e10)\r\n            );\r\n    }\r\n\r\n    function getDelegatorRewardsCore(Node storage _n, Delegation storage _d, uint _indexRT) internal view returns(uint) {\r\n        if (!_n.running) return _d.accumulatedRewards;\r\n        return\r\n            _d.accumulatedRewards.add(\r\n                _d.delegatedAmount.mul(100.sub(_n.rewardCut)).div(100).mul(\r\n                    _indexRT.sub(_d.accumulatedRewardIndex)\r\n                ).div(1e10)\r\n            );\r\n    }\r\n\r\n    function getNodeRewardTokens(address _nodeAddr) internal view returns(uint) {\r\n        return getNodeRewardsCore(nodes[_nodeAddr], accumulatedRewardIndex);\r\n    }\r\n\r\n    /// @dev returns realtime node staking rewards without any state change (specifically the global accumulatedRewardIndex)\r\n    function getNodeRewardTokensRT(address _nodeAddr) public view returns(uint) {\r\n        uint indexRT = accumulatedRewardIndex.add(rewardRateDelta());\r\n        return getNodeRewardsCore(nodes[_nodeAddr], indexRT);\r\n    }\r\n\r\n    function getDelegatorRewardTokens(address _delegator, address _nodeAddr) internal view returns(uint) {\r\n        return getDelegatorRewardsCore(nodes[_nodeAddr], delegators[_delegator][_nodeAddr], accumulatedRewardIndex);\r\n    }\r\n\r\n    /// @dev returns realtime delegator's staking rewards without any state change (specifically the global accumulatedRewardIndex)\r\n    function getDelegatorRewardTokensRT(address _delegator, address _nodeAddr) public view returns(uint) {\r\n        uint indexRT = accumulatedRewardIndex.add(rewardRateDelta());\r\n        return getDelegatorRewardsCore(nodes[_nodeAddr], delegators[_delegator][_nodeAddr], indexRT);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dostoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dbtoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bridgeAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"nodeRunner\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"selfStakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedDB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCut\",\"type\":\"uint256\"}],\"name\":\"NewNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"nodeRunner\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dropburnAmount\",\"type\":\"uint256\"}],\"name\":\"Unbond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCirculatingSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCirculatingSupply\",\"type\":\"uint256\"}],\"name\":\"UpdateCirculatingSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldQuota\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newQuota\",\"type\":\"uint256\"}],\"name\":\"UpdateDropBurnMaxQuota\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinStakePerNode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinStakePerNode\",\"type\":\"uint256\"}],\"name\":\"UpdateMinStakePerNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"UpdateStakingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"UpdateUnbondDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"nodeRunner\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DBDECIMAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DBTOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOSDECIMAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOSTOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LISTHEAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONEYEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accumulatedRewardIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridgeAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"delegatorClaimReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"delegatorUnbond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"delegatorWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"delegatorWithdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"delegatedNode\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delegatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedRewardIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dropburnMaxQuota\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentAPR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"getDelegatorRewardTokensRT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNodeAddrs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"getNodeRewardTokensRT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeAddr\",\"type\":\"address\"}],\"name\":\"getNodeUptime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initBlkN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dostoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dbtoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bridgeAddr\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeAddr\",\"type\":\"address\"}],\"name\":\"isValidStakingNode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRateUpdatedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minStakePerNode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dropburnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardCut\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_desc\",\"type\":\"string\"}],\"name\":\"newNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeAddrs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeClaimReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeRunners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dropburnAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeUnbond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeUnregister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeWithdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardCut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedDB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfStakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOtherDelegatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedRewardIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingWithdrawToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingWithdrawDB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStartTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"running\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSupply\",\"type\":\"uint256\"}],\"name\":\"setCirculatingSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quota\",\"type\":\"uint256\"}],\"name\":\"setDropBurnMaxQuota\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStake\",\"type\":\"uint256\"}],\"name\":\"setMinStakePerNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setUnbondDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRewardsVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unbondDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newDropburnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newCut\",\"type\":\"uint256\"}],\"name\":\"updateNodeStaking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000070861e862e1ac0c96f853c8231826e469ead37b100000000000000000000000068423b3b0769c739d1fe4c398c3d91f0d646424f00000000000000000000000076cec0b88fd0f109c04f0475ebdf1648df1c60b400000000000000000000000098a0e7026778840aacd28b9c03137d32e06f5ff1","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e28fd4ef77745286fd22f5722bcc26c7512cc44c980fdd1eb908fbf2bcde93d2"}]}