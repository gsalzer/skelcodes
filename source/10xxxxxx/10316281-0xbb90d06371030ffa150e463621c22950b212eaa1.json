{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface MassetStructs {\r\n\r\n    /** @dev Stores high level basket info */\r\n    struct Basket {\r\n\r\n        /** @dev Array of Bassets currently active */\r\n        Basset[] bassets;\r\n\r\n        /** @dev Max number of bAssets that can be present in any Basket */\r\n        uint8 maxBassets;\r\n\r\n        /** @dev Some bAsset is undergoing re-collateralisation */\r\n        bool undergoingRecol;\r\n\r\n        /**\r\n         * @dev In the event that we do not raise enough funds from the auctioning of a failed Basset,\r\n         * The Basket is deemed as failed, and is undercollateralised to a certain degree.\r\n         * The collateralisation ratio is used to calc Masset burn rate.\r\n         */\r\n        bool failed;\r\n        uint256 collateralisationRatio;\r\n\r\n    }\r\n\r\n    /** @dev Stores bAsset info. The struct takes 5 storage slots per Basset */\r\n    struct Basset {\r\n\r\n        /** @dev Address of the bAsset */\r\n        address addr;\r\n\r\n        /** @dev Status of the basset,  */\r\n        BassetStatus status; // takes uint8 datatype (1 byte) in storage\r\n\r\n        /** @dev An ERC20 can charge transfer fee, for example USDT, DGX tokens. */\r\n        bool isTransferFeeCharged; // takes a byte in storage\r\n\r\n        /**\r\n         * @dev 1 Basset * ratio / ratioScale == x Masset (relative value)\r\n         *      If ratio == 10e8 then 1 bAsset = 10 mAssets\r\n         *      A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\r\n         */\r\n        uint256 ratio;\r\n\r\n        /** @dev Target weights of the Basset (100% == 1e18) */\r\n        uint256 maxWeight;\r\n\r\n        /** @dev Amount of the Basset that is held in Collateral */\r\n        uint256 vaultBalance;\r\n\r\n    }\r\n\r\n    /** @dev Status of the Basset - has it broken its peg? */\r\n    enum BassetStatus {\r\n        Default,\r\n        Normal,\r\n        BrokenBelowPeg,\r\n        BrokenAbovePeg,\r\n        Blacklisted,\r\n        Liquidating,\r\n        Liquidated,\r\n        Failed\r\n    }\r\n\r\n    /** @dev Internal details on Basset */\r\n    struct BassetDetails {\r\n        Basset bAsset;\r\n        address integrator;\r\n        uint8 index;\r\n    }\r\n\r\n    /** @dev All details needed to Forge with multiple bAssets */\r\n    struct ForgePropsMulti {\r\n        bool isValid; // Flag to signify that forge bAssets have passed validity check\r\n        Basset[] bAssets;\r\n        address[] integrators;\r\n        uint8[] indexes;\r\n    }\r\n\r\n    /** @dev All details needed for proportionate Redemption */\r\n    struct RedeemPropsMulti {\r\n        uint256 colRatio;\r\n        Basset[] bAssets;\r\n        address[] integrators;\r\n        uint8[] indexes;\r\n    }\r\n}\r\n\r\ncontract IForgeValidator is MassetStructs {\r\n    function validateMint(uint256 _totalVault, Basset calldata _basset, uint256 _bAssetQuantity)\r\n        external pure returns (bool, string memory);\r\n    function validateMintMulti(uint256 _totalVault, Basset[] calldata _bassets, uint256[] calldata _bAssetQuantities)\r\n        external pure returns (bool, string memory);\r\n    function validateSwap(uint256 _totalVault, Basset calldata _inputBasset, Basset calldata _outputBasset, uint256 _quantity)\r\n        external pure returns (bool, string memory, uint256, bool);\r\n    function validateRedemption(\r\n        bool basketIsFailed,\r\n        uint256 _totalVault,\r\n        Basset[] calldata _allBassets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _bassetQuantities) external pure returns (bool, string memory, bool);\r\n    function calculateRedemptionMulti(\r\n        uint256 _mAssetQuantity,\r\n        Basset[] calldata _allBassets) external pure returns (bool, string memory, uint256[] memory);\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary StableMath {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @notice Token Ratios are used when converting between units of bAsset, mAsset and MTA\r\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\r\n     * @dev bAsset ratio unit for use in exact calculations,\r\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\r\n     */\r\n    uint256 private constant RATIO_SCALE = 1e8;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides an interface to the ratio unit\r\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\r\n     */\r\n    function getRatioScale() internal pure returns (uint256) {\r\n        return RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x.mul(FULL_SCALE);\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(uint256 x, uint256 y, uint256 scale)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        uint256 z = x.mul(y);\r\n        // return 9e38 / 1e18 = 9e18\r\n        return z.div(scale);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x.mul(y);\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil.div(FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        uint256 z = x.mul(FULL_SCALE);\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return z.div(y);\r\n    }\r\n\r\n\r\n    /***************************************\r\n                  RATIO FUNCS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the ratio scale\r\n     */\r\n    function mulRatioTruncate(uint256 x, uint256 ratio)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, rounding up the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              ratio scale, rounded up to the closest base unit.\r\n     */\r\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. How much mAsset should I burn for this bAsset (x)?\r\n        // 1e18 * 1e8 = 1e26\r\n        uint256 scaled = x.mul(ratio);\r\n        // 1e26 + 9.99e7 = 100..00.999e8\r\n        uint256 ceil = scaled.add(RATIO_SCALE.sub(1));\r\n        // return 100..00.999e8 / 1e8 = 1e18\r\n        return ceil.div(RATIO_SCALE);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\r\n     *      i.e. How much bAsset is this mAsset worth?\r\n     * @param x     Left hand operand in division\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divRatioPrecisely(uint256 x, uint256 ratio)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        // e.g. 1e14 * 1e8 = 1e22\r\n        uint256 y = x.mul(RATIO_SCALE);\r\n        // return 1e22 / 1e12 = 1e10\r\n        return y.div(ratio);\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\n/**\r\n * @title   ForgeValidator\r\n * @author  Stability Labs Pty. Ltd.\r\n * @notice  Calculates whether or not minting or redemption is valid, based\r\n *          on how it affects the underlying basket collateral weightings\r\n * @dev     VERSION: 1.1\r\n *          DATE:    2020-06-22\r\n */\r\ncontract ForgeValidator is IForgeValidator {\r\n\r\n    using SafeMath for uint256;\r\n    using StableMath for uint256;\r\n\r\n    /***************************************\r\n                    MINT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Checks whether a given mint is valid and returns the result\r\n     * @dev Is the resulting weighting of the max bAsset beyond it's implicit max weight?\r\n     * Max weight is determined as max weight (in units)\r\n     * @param _totalVault       Current sum of basket collateral\r\n     * @param _bAsset           Struct containing relevant data on the bAsset\r\n     * @param _bAssetQuantity   Number of bAsset units that will be used to mint\r\n     * @return isValid          Bool to signify that the mint does not move our weightings the wrong way\r\n     * @return reason           If the mint is invalid, this is the reason\r\n     */\r\n    function validateMint(\r\n        uint256 _totalVault,\r\n        Basset calldata _bAsset,\r\n        uint256 _bAssetQuantity\r\n    )\r\n        external\r\n        pure\r\n        returns (bool isValid, string memory reason)\r\n    {\r\n        if(\r\n            _bAsset.status == BassetStatus.BrokenBelowPeg ||\r\n            _bAsset.status == BassetStatus.Liquidating ||\r\n            _bAsset.status == BassetStatus.Blacklisted\r\n        ) {\r\n            return (false, \"bAsset not allowed in mint\");\r\n        }\r\n\r\n        // How much mAsset is this _bAssetQuantity worth?\r\n        uint256 mintAmountInMasset = _bAssetQuantity.mulRatioTruncate(_bAsset.ratio);\r\n        // How much of this bAsset do we have in the vault, in terms of mAsset?\r\n        uint256 newBalanceInMasset = _bAsset.vaultBalance.mulRatioTruncate(_bAsset.ratio).add(mintAmountInMasset);\r\n        // What is the max weight of this bAsset in the basket?\r\n        uint256 maxWeightInUnits = (_totalVault.add(mintAmountInMasset)).mulTruncate(_bAsset.maxWeight);\r\n\r\n        if(newBalanceInMasset > maxWeightInUnits) {\r\n            return (false, \"bAssets used in mint cannot exceed their max weight\");\r\n        }\r\n\r\n        return (true, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks whether a given mint using more than one asset is valid and returns the result\r\n     * @dev Is the resulting weighting of the max bAssets beyond their implicit max weight?\r\n     * Max weight is determined as max weight (in units)\r\n     * @param _totalVault       Current sum of basket collateral\r\n     * @param _bAssets          Array of Struct containing relevant data on the bAssets\r\n     * @param _bAssetQuantities Number of bAsset units that will be used to mint (aligned with above)\r\n     * @return isValid          Bool to signify that the mint does not move our weightings the wrong way\r\n     * @return reason           If the mint is invalid, this is the reason\r\n     */\r\n    function validateMintMulti(\r\n        uint256 _totalVault,\r\n        Basset[] calldata _bAssets,\r\n        uint256[] calldata _bAssetQuantities\r\n    )\r\n        external\r\n        pure\r\n        returns (bool isValid, string memory reason)\r\n    {\r\n        uint256 bAssetCount = _bAssets.length;\r\n        if(bAssetCount != _bAssetQuantities.length) return (false, \"Input length should be equal\");\r\n\r\n        uint256[] memory newBalances = new uint256[](bAssetCount);\r\n        uint256 newTotalVault = _totalVault;\r\n\r\n        // Theoretically add the mint quantities to the vault\r\n        for(uint256 j = 0; j < bAssetCount; j++){\r\n            Basset memory b = _bAssets[j];\r\n            BassetStatus bAssetStatus = b.status;\r\n\r\n            if(\r\n                bAssetStatus == BassetStatus.BrokenBelowPeg ||\r\n                bAssetStatus == BassetStatus.Liquidating ||\r\n                bAssetStatus == BassetStatus.Blacklisted\r\n            ) {\r\n                return (false, \"bAsset not allowed in mint\");\r\n            }\r\n\r\n            // How much mAsset is this bassetquantity worth?\r\n            uint256 mintAmountInMasset = _bAssetQuantities[j].mulRatioTruncate(b.ratio);\r\n            // How much of this bAsset do we have in the vault, in terms of mAsset?\r\n            newBalances[j] = b.vaultBalance.mulRatioTruncate(b.ratio).add(mintAmountInMasset);\r\n\r\n            newTotalVault = newTotalVault.add(mintAmountInMasset);\r\n        }\r\n\r\n        for(uint256 k = 0; k < bAssetCount; k++){\r\n            // What is the max weight of this bAsset in the basket?\r\n            uint256 maxWeightInUnits = newTotalVault.mulTruncate(_bAssets[k].maxWeight);\r\n\r\n            if(newBalances[k] > maxWeightInUnits) {\r\n                return (false, \"bAssets used in mint cannot exceed their max weight\");\r\n            }\r\n        }\r\n\r\n        return (true, \"\");\r\n    }\r\n\r\n    /***************************************\r\n                    SWAP\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Checks whether a given swap is valid and calculates the output\r\n     * @dev Input bAsset must not exceed max weight, output bAsset must have sufficient liquidity\r\n     * @param _totalVault       Current sum of basket collateral\r\n     * @param _inputBasset      Input bAsset details\r\n     * @param _outputBasset     Output bAsset details\r\n     * @param _quantity         Number of bAsset units on the input side\r\n     * @return isValid          Bool to signify that the mint does not move our weightings the wrong way\r\n     * @return reason           If the swap is invalid, this is the reason\r\n     * @return output           Units of output bAsset, before fee is applied\r\n     * @return applySwapFee     Bool to signify that the swap fee is applied\r\n     */\r\n    function validateSwap(\r\n        uint256 _totalVault,\r\n        Basset calldata _inputBasset,\r\n        Basset calldata _outputBasset,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        pure\r\n        returns (bool isValid, string memory reason, uint256 output, bool applySwapFee)\r\n    {\r\n        if(_inputBasset.status != BassetStatus.Normal || _outputBasset.status != BassetStatus.Normal) {\r\n            return (false, \"bAsset not allowed in swap\", 0, false);\r\n        }\r\n\r\n        // How much mAsset is this _bAssetQuantity worth?\r\n        uint256 inputAmountInMasset = _quantity.mulRatioTruncate(_inputBasset.ratio);\r\n\r\n        // 1. Determine output bAsset valid\r\n        //  - Enough units in the bank\r\n        uint256 outputAmount = inputAmountInMasset.divRatioPrecisely(_outputBasset.ratio);\r\n        if(outputAmount > _outputBasset.vaultBalance) {\r\n            return (false, \"Not enough liquidity\", 0, false);\r\n        }\r\n\r\n        // 1.1. If it is currently overweight, then no fee\r\n        applySwapFee = true;\r\n        uint256 outputBalanceMasset = _outputBasset.vaultBalance.mulRatioTruncate(_outputBasset.ratio);\r\n        uint256 outputMaxWeightUnits = _totalVault.mulTruncate(_outputBasset.maxWeight);\r\n        if(outputBalanceMasset > outputMaxWeightUnits) {\r\n            applySwapFee = false;\r\n        }\r\n\r\n        // 2. Calculate input bAsset valid - If incoming basket goes above weight, then fail\r\n        // How much of this bAsset do we have in the vault, in terms of mAsset?\r\n        uint256 newInputBalanceInMasset = _inputBasset.vaultBalance.mulRatioTruncate(_inputBasset.ratio).add(inputAmountInMasset);\r\n        // What is the max weight of this bAsset in the basket?\r\n        uint256 inputMaxWeightInUnits = _totalVault.mulTruncate(_inputBasset.maxWeight);\r\n        if(newInputBalanceInMasset > inputMaxWeightInUnits) {\r\n            return (false, \"Input must remain below max weighting\", 0, false);\r\n        }\r\n\r\n        // 3. Return swap output\r\n        return (true, \"\", outputAmount, applySwapFee);\r\n    }\r\n\r\n\r\n    /***************************************\r\n                    REDEEM\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Checks whether a given redemption is valid and returns the result\r\n     * @dev A redemption is valid if it does not push any untouched bAssets above their\r\n     * max weightings. In addition, if bAssets are currently above their max weight\r\n     * (i.e. during basket composition changes) they must be redeemed\r\n     * @param _basketIsFailed   Bool to suggest that the basket has failed a recollateralisation attempt\r\n     * @param _totalVault       Sum of collateral units in the basket\r\n     * @param _allBassets       Array of all bAsset information\r\n     * @param _indices          Indexes of the bAssets to redeem\r\n     * @param _bAssetQuantities Quantity of bAsset to redeem\r\n     * @return isValid          Bool to signify that the redemption is allowed\r\n     * @return reason           If the redemption is invalid, this is the reason\r\n     * @return feeRequired      Does this redemption require the swap fee to be applied\r\n     */\r\n    function validateRedemption(\r\n        bool _basketIsFailed,\r\n        uint256 _totalVault,\r\n        Basset[] calldata _allBassets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _bAssetQuantities\r\n    )\r\n        external\r\n        pure\r\n        returns (bool, string memory, bool)\r\n    {\r\n        uint256 idxCount = _indices.length;\r\n        if(idxCount != _bAssetQuantities.length) return (false, \"Input arrays must have equal length\", false);\r\n\r\n        // Get current weightings, and cache some outputs from the loop to avoid unecessary recursion\r\n        BasketStateResponse memory data = _getBasketState(_totalVault, _allBassets);\r\n        if(!data.isValid) return (false, data.reason, false);\r\n\r\n        // If the basket is in an affected state, enforce proportional redemption\r\n        if(\r\n            _basketIsFailed ||\r\n            data.atLeastOneBroken\r\n        ) {\r\n            return (false, \"Must redeem proportionately\", false);\r\n        } else if (data.overWeightCount > idxCount) {\r\n            return (false, \"Redemption must contain all overweight bAssets\", false);\r\n        }\r\n\r\n        uint256 newTotalVault = _totalVault;\r\n\r\n        // Simulate the redemption on the ratioedBassetVaults and totalSupply\r\n        for(uint256 i = 0; i < idxCount; i++){\r\n            uint8 idx = _indices[i];\r\n            if(idx >= _allBassets.length) return (false, \"Basset does not exist\", false);\r\n\r\n            Basset memory bAsset = _allBassets[idx];\r\n            uint256 quantity = _bAssetQuantities[i];\r\n            if(quantity > bAsset.vaultBalance) return (false, \"Cannot redeem more bAssets than are in the vault\", false);\r\n\r\n            // Calculate ratioed redemption amount in mAsset terms\r\n            uint256 ratioedRedemptionAmount = quantity.mulRatioTruncate(bAsset.ratio);\r\n            // Subtract ratioed redemption amount from both vault and total supply\r\n            data.ratioedBassetVaults[idx] = data.ratioedBassetVaults[idx].sub(ratioedRedemptionAmount);\r\n\r\n            newTotalVault = newTotalVault.sub(ratioedRedemptionAmount);\r\n        }\r\n\r\n        // Get overweight after\r\n        bool atLeastOneBecameOverweight =\r\n            _getOverweightBassetsAfter(newTotalVault, _allBassets, data.ratioedBassetVaults, data.isOverWeight);\r\n\r\n        bool applySwapFee = true;\r\n        // If there are any bAssets overweight, we must redeem them all\r\n        if(data.overWeightCount > 0) {\r\n            for(uint256 j = 0; j < idxCount; j++) {\r\n                if(!data.isOverWeight[_indices[j]]) return (false, \"Must redeem overweight bAssets\", false);\r\n            }\r\n            applySwapFee = false;\r\n        }\r\n        // Since no bAssets were overweight before, if one becomes overweight, throw\r\n        if(atLeastOneBecameOverweight) return (false, \"bAssets must remain below max weight\", false);\r\n\r\n        return (true, \"\", applySwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the relative quantities of bAssets to redeem, with current basket state\r\n     * @dev Sum the value of the bAssets, and then find the proportions relative to the desired\r\n     * mAsset quantity.\r\n     * @param _mAssetQuantity   Quantity of mAsset to redeem\r\n     * @param _allBassets       Array of all bAsset information\r\n     * @return isValid          Bool to signify that the redemption is allowed\r\n     * @return reason           If the redemption is invalid, this is the reason\r\n     * @return quantities       Array of bAsset quantities to redeem\r\n     */\r\n    function calculateRedemptionMulti(\r\n        uint256 _mAssetQuantity,\r\n        Basset[] calldata _allBassets\r\n    )\r\n        external\r\n        pure\r\n        returns (bool, string memory, uint256[] memory)\r\n    {\r\n        // e.g. mAsset = 1e20 (100)\r\n        // e.g. bAsset: [   A,   B,    C,    D]\r\n        // e.g. vaults: [  80,  60,   60,    0]\r\n        // e.g. ratio:  [1e12, 1e8, 1e20, 1e18]\r\n        // expectedM:    4e19 3e19  3e19     0\r\n        // expectedB:    4e15 3e19   3e7     0\r\n        uint256 len = _allBassets.length;\r\n        uint256[] memory redeemQuantities = new uint256[](len);\r\n        uint256[] memory ratioedBassetVaults = new uint256[](len);\r\n        uint256 totalBassetVault = 0;\r\n        // 1. Add up total vault & ratioedBassets, fail if blacklisted\r\n        for(uint256 i = 0; i < len; i++) {\r\n            if(_allBassets[i].status == BassetStatus.Blacklisted) {\r\n                return (false, \"Basket contains blacklisted bAsset\", redeemQuantities);\r\n            } else if(_allBassets[i].status == BassetStatus.Liquidating) {\r\n                return (false, \"Basket contains liquidating bAsset\", redeemQuantities);\r\n            }\r\n            // e.g. (80e14 * 1e12) / 1e8 = 80e18\r\n            // e.g. (60e18 * 1e8) / 1e8 = 60e18\r\n            uint256 ratioedBasset = _allBassets[i].vaultBalance.mulRatioTruncate(_allBassets[i].ratio);\r\n            ratioedBassetVaults[i] = ratioedBasset;\r\n            totalBassetVault = totalBassetVault.add(ratioedBasset);\r\n        }\r\n        if(totalBassetVault == 0) return (false, \"Nothing in the basket to redeem\", redeemQuantities);\r\n        if(_mAssetQuantity > totalBassetVault) return (false, \"Not enough liquidity\", redeemQuantities);\r\n        // 2. Calculate proportional weighting & non-ratioed amount\r\n        for(uint256 i = 0; i < len; i++) {\r\n            // proportional weighting\r\n            // e.g. (8e19 * 1e18) / 2e20 = 8e37 / 2e20 = 4e17 (40%)\r\n            uint256 percentageOfVault = ratioedBassetVaults[i].divPrecisely(totalBassetVault);\r\n            // e.g. (1e20 * 4e17) / 1e18 = 4e37 / 1e18 = 4e19 (40)\r\n            uint256 ratioedProportionalBasset = _mAssetQuantity.mulTruncate(percentageOfVault);\r\n            // convert back to bAsset amount\r\n             // e.g. (4e19 * 1e8) / 1e12 = 4e27 / 1e12 = 4e15\r\n            redeemQuantities[i] = ratioedProportionalBasset.divRatioPrecisely(_allBassets[i].ratio);\r\n        }\r\n        // 3. Return\r\n        return (true, \"\", redeemQuantities);\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    struct BasketStateResponse {\r\n        bool isValid;\r\n        string reason;\r\n        bool atLeastOneBroken;\r\n        uint256 overWeightCount;\r\n        bool[] isOverWeight;\r\n        uint256[] ratioedBassetVaults;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the currently overweight bAssets, and capitalises on the for loop to\r\n     * produce some other useful data. Loops through, validating the bAsset, and determining\r\n     * if it is overweight, returning the ratioed bAsset.\r\n     * @param _total         Sum of collateral units in the basket\r\n     * @param _bAssets       Array of all bAsset information\r\n     * @return response      Struct containing calculated data\r\n     */\r\n    function _getBasketState(uint256 _total, Basset[] memory _bAssets)\r\n        private\r\n        pure\r\n        returns (BasketStateResponse memory response)\r\n    {\r\n        uint256 len = _bAssets.length;\r\n        response = BasketStateResponse({\r\n            isValid: true,\r\n            reason: \"\",\r\n            atLeastOneBroken: false,\r\n            overWeightCount: 0,\r\n            isOverWeight: new bool[](len),\r\n            ratioedBassetVaults: new uint256[](len)\r\n        });\r\n\r\n        for(uint256 i = 0; i < len; i++) {\r\n            BassetStatus status = _bAssets[i].status;\r\n            if(status == BassetStatus.Blacklisted) {\r\n                response.isValid = false;\r\n                response.reason = \"Basket contains blacklisted bAsset\";\r\n                return response;\r\n            } else if(\r\n                status == BassetStatus.Liquidating ||\r\n                status == BassetStatus.BrokenBelowPeg ||\r\n                status == BassetStatus.BrokenAbovePeg\r\n            ) {\r\n                response.atLeastOneBroken = true;\r\n            }\r\n\r\n            uint256 ratioedBasset = _bAssets[i].vaultBalance.mulRatioTruncate(_bAssets[i].ratio);\r\n            response.ratioedBassetVaults[i] = ratioedBasset;\r\n            uint256 maxWeightInUnits = _total.mulTruncate(_bAssets[i].maxWeight);\r\n\r\n            bool bAssetOverWeight = ratioedBasset > maxWeightInUnits;\r\n            if(bAssetOverWeight){\r\n                response.isOverWeight[i] = true;\r\n                response.overWeightCount += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev After the redeemed bAssets have been removed from the basket, determine\r\n     * if there are any resulting overweight, or underweight\r\n     * @param _newTotal                 Sum of collateral units in the basket\r\n     * @param _bAssets                  Array of all bAsset information\r\n     * @param _ratioedBassetVaultsAfter Array of all new bAsset vaults\r\n     * @param _previouslyOverWeight     Array of bools - was this bAsset already overweight\r\n     * @return underWeight              Array of bools - is this bAsset now under min weight\r\n     */\r\n    function _getOverweightBassetsAfter(\r\n        uint256 _newTotal,\r\n        Basset[] memory _bAssets,\r\n        uint256[] memory _ratioedBassetVaultsAfter,\r\n        bool[] memory _previouslyOverWeight\r\n    )\r\n        private\r\n        pure\r\n        returns (bool atLeastOneBecameOverweight)\r\n    {\r\n        uint256 len = _ratioedBassetVaultsAfter.length;\r\n\r\n        for(uint256 i = 0; i < len; i++) {\r\n            uint256 maxWeightInUnits = _newTotal.mulTruncate(_bAssets[i].maxWeight);\r\n\r\n            bool isOverweight = _ratioedBassetVaultsAfter[i] > maxWeightInUnits;\r\n            // If it was not previously overweight, and now it, then it became overweight\r\n            bool becameOverweight = !_previouslyOverWeight[i] && isOverweight;\r\n            atLeastOneBecameOverweight = atLeastOneBecameOverweight || becameOverweight;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mAssetQuantity\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isTransferFeeCharged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct MassetStructs.Basset[]\",\"name\":\"_allBassets\",\"type\":\"tuple[]\"}],\"name\":\"calculateRedemptionMulti\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalVault\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isTransferFeeCharged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct MassetStructs.Basset\",\"name\":\"_bAsset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_bAssetQuantity\",\"type\":\"uint256\"}],\"name\":\"validateMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalVault\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isTransferFeeCharged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct MassetStructs.Basset[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_bAssetQuantities\",\"type\":\"uint256[]\"}],\"name\":\"validateMintMulti\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_basketIsFailed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_totalVault\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isTransferFeeCharged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct MassetStructs.Basset[]\",\"name\":\"_allBassets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_indices\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_bAssetQuantities\",\"type\":\"uint256[]\"}],\"name\":\"validateRedemption\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalVault\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isTransferFeeCharged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct MassetStructs.Basset\",\"name\":\"_inputBasset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isTransferFeeCharged\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct MassetStructs.Basset\",\"name\":\"_outputBasset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"validateSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"applySwapFee\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ForgeValidator","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bf65b675271773e95e7a6bcda774bb2ebe6726e94481b892ac67da8d3e4d74fc"}]}