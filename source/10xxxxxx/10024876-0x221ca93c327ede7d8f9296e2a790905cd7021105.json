{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.3;\r\n \r\n// Solidity Interface\r\n \r\ninterface UniswapExchangeInterface {\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n \r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n \r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n \r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n}\r\n \r\ncontract RateCrawlerHelper {\r\n \r\n    function getTokenRates(UniswapExchangeInterface uniswapExchangeContract, uint[] memory amounts)\r\n    public view\r\n    returns (uint[] memory inputPrices, uint[] memory outputPrices)\r\n    {\r\n        inputPrices = new uint[](amounts.length);\r\n        outputPrices = new uint[](amounts.length);\r\n        bool didReverted = true;\r\n \r\n        for (uint i = 0; i < amounts.length; i++) {\r\n            (didReverted, inputPrices[i]) = assemblyGetEthToToken(address(uniswapExchangeContract), amounts[i], bytes4(keccak256(\"getEthToTokenInputPrice(uint256)\")));\r\n            if (didReverted) {\r\n                inputPrices[i] = 0;\r\n            }\r\n            (didReverted, outputPrices[i]) = assemblyGetEthToToken(address(uniswapExchangeContract), amounts[i], bytes4(keccak256(\"getTokenToEthOutputPrice(uint256)\")));\r\n            if (didReverted) {\r\n                outputPrices[i] = 0;\r\n            }\r\n        }\r\n    }\r\n \r\n    function assemblyGetEthToToken(address exh, uint amount, bytes4 sig)\r\n    internal view\r\n    returns (bool, uint)\r\n    {\r\n        uint success;\r\n        uint rate;\r\n        assembly {\r\n            let x := mload(0x40)        // \"free memory pointer\"\r\n            mstore(x, sig)               // function signature\r\n            mstore(add(x, 0x04), amount)  // src address padded to 32 bytes\r\n            mstore(0x40, add(x, 0x44))    // set free storage pointer to empty space after output\r\n \r\n        // input size = sig + uint\r\n        // = 4 + 32 = 36 = 0x24\r\n            success := staticcall(\r\n            gas(),\r\n            exh, // contract addr\r\n            x, // Inputs at location x\r\n            0x24, // Inputs size bytes\r\n            add(x, 0x24), // output storage after input\r\n            0x20) // Output size are (uint, uint) = 64 bytes\r\n \r\n            rate := mload(add(x, 0x24))  //Assign output to rate.\r\n            mstore(0x40, x)    // Set empty storage pointer back to start position\r\n        }\r\n \r\n        return (success != 1, rate);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract UniswapExchangeInterface\",\"name\":\"uniswapExchangeContract\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"getTokenRates\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputPrices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RateCrawlerHelper","CompilerVersion":"v0.6.3+commit.8dda9521","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://914922072503ab6b0ce9f8c3003295d6fa9fea834b13ca6b0affe6d706895a1a"}]}