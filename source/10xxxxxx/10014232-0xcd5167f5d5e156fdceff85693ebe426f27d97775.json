{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title KeyMap\r\n * @author https://github.com/d1ll0n\r\n * This contracts maps addresses to public keys.\r\n * Public keys for Secp256k1 are always 64 bytes.\r\n * To save gas, this contract stores them as an array of two bytes32 words.\r\n */\r\ncontract KeyMap {\r\n  mapping(address => bytes32[2]) private mappedKeys;\r\n\r\n  /**\r\n   * @dev mapKey\r\n   * Calculates the address for a public key, then saves the mapping from address to public key.\r\n   * @notice This overload reduces the calldata cost of submission.\r\n   * @param slice0 - first 32 bytes of the public key\r\n   * @param slice1 - second 32 bytes of the public key\r\n   * @return _address - calculated address\r\n   */\r\n  function mapKey(bytes32 slice0, bytes32 slice1) external returns(address _address) {\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0x04, 0x40)\r\n      let mask := 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\r\n      _address := and(mask, keccak256(ptr, 0x40))\r\n      calldatacopy(ptr, calldatasize(), 0x40)\r\n    }\r\n    mappedKeys[_address][0] = slice0;\r\n    mappedKeys[_address][1] = slice1;\r\n  }\r\n\r\n  /**\r\n   * @dev mapKey\r\n   * Calculates the address for a public key, then saves the mapping from address to public key.\r\n   * @notice This overload is somewhat simpler to use, but has a higher calldata cost.\r\n   * @param _pubKey - ABI encoded 64 byte public key\r\n   * @return _address - calculated address\r\n   */\r\n  function mapKey(bytes calldata _pubKey) external returns(address _address) {\r\n    require(_pubKey.length == 64, \"Invalid public key.\");\r\n    bytes32[2] memory pubKey;\r\n    assembly {\r\n      calldatacopy(pubKey, 0x44, 0x40)\r\n      let mask := 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\r\n      _address := and(mask, keccak256(pubKey, 0x40))\r\n    }\r\n    mappedKeys[_address][0] = pubKey[0];\r\n    mappedKeys[_address][1] = pubKey[1];\r\n  }\r\n\r\n  /**\r\n   * @dev getKey\r\n   * Retrieves the public key for the given address.\r\n   * @notice Throws an error if the key is not registered.\r\n   * @param _address - address to query\r\n   * @return pubKey - ABI encoded public key retrieved from storage\r\n   */\r\n  function getKey(address _address) public view returns (bytes memory pubKey) {\r\n    pubKey = new bytes(64);\r\n    bytes32[2] memory key = mappedKeys[_address];\r\n    require(key[0] != bytes32(0), \"Key not mapped.\");\r\n    assembly {\r\n      mstore(add(pubKey, 32), mload(key))\r\n      mstore(add(pubKey, 64), mload(add(key, 32)))\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getKey\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"pubKey\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slice0\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slice1\",\"type\":\"bytes32\"}],\"name\":\"mapKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_pubKey\",\"type\":\"bytes\"}],\"name\":\"mapKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KeyMap","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f5a6b7ff4e60c946f02bd570a20285661055cf0241bc1ab51808d920672602b6"}]}