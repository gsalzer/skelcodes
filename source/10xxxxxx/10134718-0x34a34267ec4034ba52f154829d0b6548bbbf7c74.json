{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Submitted for verification at etherscan.io on 2020-05-25\r\n *\r\n *   ________            ____                           _ __    __        ______________\r\n *  /_  __/ /_  ___     / __ \\___ _   _____  __________(_) /_  / /__     /  _/ ____/ __ \\\r\n *   / / / __ \\/ _ \\   / /_/ / _ \\ | / / _ \\/ ___/ ___/ / __ \\/ / _ \\    / // /   / / / /\r\n *  / / / / / /  __/  / _, _/  __/ |/ /  __/ /  (__  ) / /_/ / /  __/  _/ // /___/ /_/ /\r\n * /_/ /_/ /_/\\___/  /_/ |_|\\___/|___/\\___/_/  /____/_/_.___/_/\\___/  /___/\\____/\\____/\r\n *\r\n *\r\n * source      https://github.com/lukso-network/rICO-smart-contracts\r\n * @name       Reversible ICO\r\n * @author     Fabian Vogelsteller <@frozeman>, Micky Socaci <micky@binarzone.com>, Marjorie Hernandez <marjorie@lukso.io>\r\n * @license    Apache 2.0\r\n *\r\n * Readme more about it here https://medium.com/lukso/rico-the-reversible-ico-5392bf64318b\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n        \r\n        \r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        \r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC777 {\r\n    \r\n    function name() external view returns (string memory);\r\n\r\n    \r\n    function symbol() external view returns (string memory);\r\n\r\n    \r\n    function granularity() external view returns (uint256);\r\n\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    \r\n    function send(address recipient, uint256 amount, bytes calldata data) external;\r\n\r\n    \r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    \r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n\r\n    \r\n    function authorizeOperator(address operator) external;\r\n\r\n    \r\n    function revokeOperator(address operator) external;\r\n\r\n    \r\n    function defaultOperators() external view returns (address[] memory);\r\n\r\n    \r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    \r\n    function operatorBurn(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\ninterface IERC777Recipient {\r\n    \r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\ninterface IERC1820Registry {\r\n    \r\n    function setManager(address account, address newManager) external;\r\n\r\n    \r\n    function getManager(address account) external view returns (address);\r\n\r\n    \r\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\r\n\r\n    \r\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\r\n\r\n    \r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    \r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    \r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    \r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\r\n\r\ncontract ReversibleICO is IERC777Recipient {\r\n\r\n\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    \r\n    IERC1820Registry private ERC1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\r\n\r\n\r\n    \r\n    \r\n    bool public initialized;\r\n\r\n    \r\n    bool public frozen;\r\n    uint256 public frozenPeriod;\r\n    uint256 public freezeStart;\r\n\r\n\r\n    \r\n    \r\n    address public deployingAddress;\r\n    \r\n    address public tokenAddress;\r\n    \r\n    address public projectAddress;\r\n    \r\n    address public whitelistingAddress;\r\n    \r\n    address public freezerAddress;\r\n    \r\n    address public rescuerAddress;\r\n\r\n\r\n    \r\n    \r\n    uint256 public initialTokenSupply;\r\n    \r\n    uint256 public tokenSupply;\r\n    \r\n    uint256 public committedETH;\r\n    \r\n    uint256 public pendingETH;\r\n    \r\n    uint256 public canceledETH;\r\n    \r\n    uint256 public withdrawnETH;\r\n    \r\n    uint256 public projectWithdrawCount;\r\n    \r\n    uint256 public projectWithdrawnETH;\r\n\r\n    \r\n    uint256 public minContribution = 0.001 ether;\r\n    uint256 public maxContribution = 4000 ether;\r\n\r\n    mapping(uint8 => Stage) public stages;\r\n    uint256 public stageBlockCount;\r\n    uint8 public stageCount;\r\n\r\n    \r\n    mapping(address => Participant) public participants;\r\n    \r\n    mapping(uint256 => address) public participantsById;\r\n    \r\n    uint256 public participantCount;\r\n\r\n    \r\n    \r\n    uint256 public commitPhasePrice;\r\n    \r\n    uint256 public commitPhaseStartBlock;\r\n    \r\n    uint256 public commitPhaseEndBlock;\r\n    \r\n    uint256 public commitPhaseBlockCount;\r\n\r\n\r\n    \r\n    \r\n    uint256 public buyPhaseStartBlock;\r\n    \r\n    uint256 public buyPhaseEndBlock;\r\n    \r\n    uint256 public buyPhaseBlockCount;\r\n\r\n    \r\n    \r\n    uint256 internal _projectCurrentlyReservedETH;\r\n    \r\n    uint256 internal _projectUnlockedETH;\r\n    \r\n    uint256 internal _projectLastBlock;\r\n\r\n\r\n    \r\n\r\n    \r\n    struct Stage {\r\n        uint128 startBlock;\r\n        uint128 endBlock;\r\n        uint256 tokenPrice;\r\n    }\r\n\r\n    \r\n    struct Participant {\r\n        bool whitelisted;\r\n        uint32 contributions;\r\n        uint32 withdraws;\r\n        uint256 firstContributionBlock;\r\n        uint256 reservedTokens;\r\n        uint256 committedETH;\r\n        uint256 pendingETH;\r\n\r\n        uint256 _currentReservedTokens;\r\n        uint256 _unlockedTokens;\r\n        uint256 _lastBlock;\r\n\r\n        mapping(uint8 => ParticipantStageDetails) stages;\r\n    }\r\n\r\n    struct ParticipantStageDetails {\r\n        uint256 pendingETH;\r\n    }\r\n\r\n    \r\n    event PendingContributionAdded(address indexed participantAddress, uint256 indexed amount, uint32 indexed contributionId);\r\n    event PendingContributionsCanceled(address indexed participantAddress, uint256 indexed amount, uint32 indexed contributionId);\r\n\r\n    event WhitelistApproved(address indexed participantAddress, uint256 indexed pendingETH, uint32 indexed contributions);\r\n    event WhitelistRejected(address indexed participantAddress, uint256 indexed pendingETH, uint32 indexed contributions);\r\n\r\n    event ContributionsAccepted(address indexed participantAddress, uint256 indexed ethAmount, uint256 indexed tokenAmount, uint8 stageId);\r\n\r\n    event ProjectWithdraw(address indexed projectAddress, uint256 indexed amount, uint32 indexed withdrawCount);\r\n    event ParticipantWithdraw(address indexed participantAddress, uint256 indexed ethAmount, uint256 indexed tokenAmount, uint32 withdrawCount);\r\n\r\n    event SecurityFreeze(address indexed freezerAddress, uint8 indexed stageId, uint256 indexed effectiveBlockNumber);\r\n    event SecurityUnfreeze(address indexed freezerAddress, uint8 indexed stageId, uint256 indexed effectiveBlockNumber);\r\n    event SecurityDisableEscapeHatch(address indexed freezerAddress, uint8 indexed stageId, uint256 indexed effectiveBlockNumber);\r\n    event SecurityEscapeHatch(address indexed rescuerAddress, address indexed to, uint8 indexed stageId, uint256 effectiveBlockNumber);\r\n\r\n\r\n    event TransferEvent (\r\n        uint8 indexed typeId,\r\n        address indexed relatedAddress,\r\n        uint256 indexed value\r\n    );\r\n\r\n    enum TransferTypes {\r\n        NOT_SET, \r\n        WHITELIST_REJECTED, \r\n        CONTRIBUTION_CANCELED, \r\n        CONTRIBUTION_ACCEPTED_OVERFLOW, \r\n        PARTICIPANT_WITHDRAW, \r\n        PARTICIPANT_WITHDRAW_OVERFLOW, \r\n        PROJECT_WITHDRAWN, \r\n        FROZEN_ESCAPEHATCH_TOKEN, \r\n        FROZEN_ESCAPEHATCH_ETH \r\n    }\r\n\r\n\r\n    \r\n\r\n    \r\n    constructor() public {\r\n        deployingAddress = msg.sender;\r\n        ERC1820.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\r\n    }\r\n\r\n    \r\n    function init(\r\n        address _tokenAddress,\r\n        address _whitelistingAddress,\r\n        address _freezerAddress,\r\n        address _rescuerAddress,\r\n        address _projectAddress,\r\n        uint256 _commitPhaseStartBlock,\r\n        uint256 _commitPhaseBlockCount,\r\n        uint256 _commitPhasePrice,\r\n        uint8 _stageCount, \r\n        uint256 _stageBlockCount,\r\n        uint256 _stagePriceIncrease\r\n    )\r\n    public\r\n    onlyDeployingAddress\r\n    isNotInitialized\r\n    {\r\n        require(_tokenAddress != address(0), \"_tokenAddress cannot be 0x\");\r\n        require(_whitelistingAddress != address(0), \"_whitelistingAddress cannot be 0x\");\r\n        require(_freezerAddress != address(0), \"_freezerAddress cannot be 0x\");\r\n        require(_rescuerAddress != address(0), \"_rescuerAddress cannot be 0x\");\r\n        require(_projectAddress != address(0), \"_projectAddress cannot be 0x\");\r\n        require(_commitPhaseStartBlock > getCurrentBlockNumber(), \"Start block cannot be set in the past.\");\r\n\r\n        \r\n        tokenAddress = _tokenAddress;\r\n        whitelistingAddress = _whitelistingAddress;\r\n        freezerAddress = _freezerAddress;\r\n        rescuerAddress = _rescuerAddress;\r\n        projectAddress = _projectAddress;\r\n\r\n        \r\n        commitPhaseStartBlock = _commitPhaseStartBlock;\r\n        commitPhaseBlockCount = _commitPhaseBlockCount;\r\n        commitPhaseEndBlock = _commitPhaseStartBlock.add(_commitPhaseBlockCount).sub(1);\r\n        commitPhasePrice = _commitPhasePrice;\r\n\r\n        stageBlockCount = _stageBlockCount;\r\n        stageCount = _stageCount;\r\n\r\n        \r\n        Stage storage commitPhase = stages[0];\r\n\r\n        commitPhase.startBlock = uint128(_commitPhaseStartBlock);\r\n        commitPhase.endBlock = uint128(commitPhaseEndBlock);\r\n        commitPhase.tokenPrice = _commitPhasePrice;\r\n\r\n        \r\n        \r\n        uint256 previousStageEndBlock = commitPhase.endBlock;\r\n\r\n        \r\n        for (uint8 i = 1; i <= _stageCount; i++) {\r\n            \r\n            Stage storage byStage = stages[i];\r\n            \r\n            byStage.startBlock = uint128(previousStageEndBlock.add(1));\r\n            \r\n            byStage.endBlock = uint128(previousStageEndBlock.add(_stageBlockCount));\r\n            \r\n            previousStageEndBlock = byStage.endBlock;\r\n            \r\n            byStage.tokenPrice = _commitPhasePrice.add(_stagePriceIncrease.mul(i));\r\n        }\r\n\r\n        \r\n        \r\n        buyPhaseStartBlock = commitPhaseEndBlock.add(1);\r\n        \r\n        buyPhaseEndBlock = previousStageEndBlock;\r\n        \r\n        buyPhaseBlockCount = buyPhaseEndBlock.sub(buyPhaseStartBlock).add(1);\r\n\r\n        \r\n        initialized = true;\r\n    }\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n    function()\r\n    external\r\n    payable\r\n    isInitialized\r\n    isNotFrozen\r\n    {\r\n        Participant storage participantStats = participants[msg.sender];\r\n\r\n        \r\n        if (participantStats.whitelisted == true && participantStats.contributions > 0) {\r\n            commit();\r\n\r\n        \r\n        } else {\r\n            require(msg.value < minContribution, 'To contribute call commit() [0x3c7a3aff] and send ETH along.');\r\n\r\n            \r\n            cancelPendingContributions(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    \r\n    function tokensReceived(\r\n        address,\r\n        address _from,\r\n        address,\r\n        uint256 _amount,\r\n        bytes calldata,\r\n        bytes calldata\r\n    )\r\n    external\r\n    isInitialized\r\n    isNotFrozen\r\n    {\r\n        \r\n        \r\n        require(msg.sender == tokenAddress, \"Invalid token contract sent tokens.\");\r\n\r\n        \r\n        if (_from == projectAddress) {\r\n            \r\n            tokenSupply = tokenSupply.add(_amount);\r\n            initialTokenSupply = initialTokenSupply.add(_amount);\r\n\r\n            \r\n        } else {\r\n            withdraw(_from, _amount);\r\n        }\r\n    }\r\n\r\n    \r\n    function commit()\r\n    public\r\n    payable\r\n    isInitialized\r\n    isNotFrozen\r\n    isRunning\r\n    {\r\n        \r\n        require(msg.value >= minContribution, \"Value sent is less than the minimum contribution.\");\r\n\r\n        \r\n        Participant storage participantStats = participants[msg.sender];\r\n        ParticipantStageDetails storage byStage = participantStats.stages[getCurrentStage()];\r\n\r\n        require(participantStats.committedETH.add(msg.value) <= maxContribution, \"Value sent is more than the maximum contribution.\");\r\n\r\n        \r\n        if (participantStats.contributions == 0) {\r\n            \r\n            participantsById[participantCount] = msg.sender;\r\n            \r\n            participantCount++;\r\n        }\r\n\r\n        \r\n        participantStats.contributions++;\r\n        participantStats.pendingETH = participantStats.pendingETH.add(msg.value);\r\n        byStage.pendingETH = byStage.pendingETH.add(msg.value);\r\n\r\n        \r\n        pendingETH = pendingETH.add(msg.value);\r\n\r\n        emit PendingContributionAdded(\r\n            msg.sender,\r\n            msg.value,\r\n            uint32(participantStats.contributions)\r\n        );\r\n\r\n        \r\n        if (participantStats.whitelisted == true) {\r\n            acceptContributions(msg.sender);\r\n        }\r\n    }\r\n\r\n    \r\n    function cancel()\r\n    external\r\n    payable\r\n    isInitialized\r\n    isNotFrozen\r\n    {\r\n        cancelPendingContributions(msg.sender, msg.value);\r\n    }\r\n\r\n    \r\n    function whitelist(address[] calldata _addresses, bool _approve)\r\n    external\r\n    onlyWhitelistingAddress\r\n    isInitialized\r\n    isNotFrozen\r\n    isRunning\r\n    {\r\n        \r\n        require(_addresses.length > 0, \"No addresses given to whitelist.\");\r\n\r\n        for (uint256 i = 0; i < _addresses.length; i++) {\r\n            address participantAddress = _addresses[i];\r\n\r\n            Participant storage participantStats = participants[participantAddress];\r\n\r\n            if (_approve) {\r\n                if (participantStats.whitelisted == false) {\r\n                    \r\n                    participantStats.whitelisted = true;\r\n                    emit WhitelistApproved(participantAddress, participantStats.pendingETH, uint32(participantStats.contributions));\r\n                }\r\n\r\n                \r\n                acceptContributions(participantAddress);\r\n\r\n            } else {\r\n                participantStats.whitelisted = false;\r\n                emit WhitelistRejected(participantAddress, participantStats.pendingETH, uint32(participantStats.contributions));\r\n\r\n                \r\n                cancelPendingContributions(participantAddress, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    function projectWithdraw(uint256 _ethAmount)\r\n    external\r\n    onlyProjectAddress\r\n    isInitialized\r\n    isNotFrozen\r\n    {\r\n        \r\n        calcProjectAllocation();\r\n\r\n        \r\n        uint256 availableForWithdraw = _projectUnlockedETH.sub(projectWithdrawnETH);\r\n\r\n        require(_ethAmount <= availableForWithdraw, \"Requested amount too high, not enough ETH unlocked.\");\r\n\r\n        \r\n        projectWithdrawCount++;\r\n        projectWithdrawnETH = projectWithdrawnETH.add(_ethAmount);\r\n\r\n        \r\n        emit ProjectWithdraw(\r\n            projectAddress,\r\n            _ethAmount,\r\n            uint32(projectWithdrawCount)\r\n        );\r\n        emit TransferEvent(\r\n            uint8(TransferTypes.PROJECT_WITHDRAWN),\r\n            projectAddress,\r\n            _ethAmount\r\n        );\r\n\r\n        \r\n        address(uint160(projectAddress)).transfer(_ethAmount);\r\n    }\r\n\r\n\r\n    \r\n\r\n    \r\n    function freeze()\r\n    external\r\n    onlyFreezerAddress\r\n    isNotFrozen\r\n    {\r\n        frozen = true;\r\n        freezeStart = getCurrentEffectiveBlockNumber();\r\n\r\n        \r\n        emit SecurityFreeze(freezerAddress, getCurrentStage(), freezeStart);\r\n    }\r\n\r\n    \r\n    function unfreeze()\r\n    external\r\n    onlyFreezerAddress\r\n    isFrozen\r\n    {\r\n        uint256 currentBlock = getCurrentEffectiveBlockNumber();\r\n\r\n        frozen = false;\r\n        frozenPeriod = frozenPeriod.add(\r\n            currentBlock.sub(freezeStart)\r\n        );\r\n\r\n        \r\n        emit SecurityUnfreeze(freezerAddress, getCurrentStage(), currentBlock);\r\n    }\r\n\r\n    \r\n    function disableEscapeHatch()\r\n    external\r\n    onlyFreezerAddress\r\n    isNotFrozen\r\n    {\r\n        freezerAddress = address(0);\r\n        rescuerAddress = address(0);\r\n\r\n        \r\n        emit SecurityDisableEscapeHatch(freezerAddress, getCurrentStage(), getCurrentEffectiveBlockNumber());\r\n    }\r\n\r\n    \r\n    function escapeHatch(address _to)\r\n    external\r\n    onlyRescuerAddress\r\n    isFrozen\r\n    {\r\n        require(getCurrentEffectiveBlockNumber() == freezeStart.add(18000), 'Let it cool.. Wait at least ~3 days (18000 blk) before moving anything.');\r\n\r\n        uint256 tokenBalance = IERC777(tokenAddress).balanceOf(address(this));\r\n        uint256 ethBalance = address(this).balance;\r\n\r\n        \r\n        \r\n        IERC777(tokenAddress).send(_to, tokenBalance, \"\");\r\n\r\n        \r\n        address(uint160(_to)).transfer(ethBalance);\r\n\r\n        \r\n        emit SecurityEscapeHatch(rescuerAddress, _to, getCurrentStage(), getCurrentEffectiveBlockNumber());\r\n\r\n        emit TransferEvent(uint8(TransferTypes.FROZEN_ESCAPEHATCH_TOKEN), _to, tokenBalance);\r\n        emit TransferEvent(uint8(TransferTypes.FROZEN_ESCAPEHATCH_ETH), _to, ethBalance);\r\n    }\r\n\r\n\r\n    \r\n\r\n    \r\n    function getUnlockedProjectETH() public view returns (uint256) {\r\n\r\n        \r\n        uint256 newlyUnlockedEth = calcUnlockedAmount(_projectCurrentlyReservedETH, _projectLastBlock);\r\n\r\n        return _projectUnlockedETH\r\n        .add(newlyUnlockedEth);\r\n    }\r\n\r\n    \r\n    function getAvailableProjectETH() public view returns (uint256) {\r\n        return getUnlockedProjectETH()\r\n            .sub(projectWithdrawnETH);\r\n    }\r\n\r\n    \r\n    function getParticipantReservedTokens(address _participantAddress) public view returns (uint256) {\r\n        Participant storage participantStats = participants[_participantAddress];\r\n\r\n        if(participantStats._currentReservedTokens == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return participantStats._currentReservedTokens.sub(\r\n            calcUnlockedAmount(participantStats._currentReservedTokens, participantStats._lastBlock)\r\n        );\r\n    }\r\n\r\n    \r\n    function getParticipantUnlockedTokens(address _participantAddress) public view returns (uint256) {\r\n        Participant storage participantStats = participants[_participantAddress];\r\n\r\n        return participantStats._unlockedTokens.add(\r\n            calcUnlockedAmount(participantStats._currentReservedTokens, participantStats._lastBlock)\r\n        );\r\n    }\r\n\r\n    \r\n    function getCurrentStage() public view returns (uint8) {\r\n        uint blockNumber;\r\n        if (frozen) {\r\n            blockNumber = freezeStart;\r\n        } else {\r\n            blockNumber = getCurrentBlockNumber(); \r\n        }\r\n        return getStageAtBlock(blockNumber);\r\n    }\r\n\r\n    \r\n    function getCurrentPrice() public view returns (uint256) {\r\n        uint blockNumber;\r\n        if (frozen) {\r\n            blockNumber = freezeStart;\r\n        } else {\r\n            blockNumber = getCurrentBlockNumber(); \r\n        }\r\n        return getPriceAtBlock(blockNumber);\r\n    }\r\n\r\n    \r\n    function getPriceAtBlock(uint256 _blockNumber) public view returns (uint256) {\r\n        return getPriceAtStage(getStageAtBlock(_blockNumber));\r\n    }\r\n\r\n    \r\n    function getPriceAtStage(uint8 _stageId) public view returns (uint256) {\r\n        if (_stageId <= stageCount) {\r\n            return stages[_stageId].tokenPrice;\r\n        }\r\n        revert(\"No price data found.\");\r\n    }\r\n\r\n    \r\n    function getStageAtBlock(uint256 _blockNumber) public view returns (uint8) {\r\n\r\n        \r\n        uint256 blockNumber = _blockNumber.sub(frozenPeriod);\r\n\r\n        \r\n        require(blockNumber >= commitPhaseStartBlock && blockNumber <= buyPhaseEndBlock, \"Block outside of rICO period.\");\r\n\r\n        if (blockNumber <= commitPhaseEndBlock) {\r\n            return 0;\r\n        }\r\n\r\n        \r\n        uint256 distance = blockNumber - (commitPhaseEndBlock + 1);\r\n        \r\n        \r\n        uint256 stageID = 1 + (distance / stageBlockCount);\r\n\r\n        return uint8(stageID);\r\n    }\r\n\r\n    \r\n    function committableEthAtStage(uint8 _stageId) public view returns (uint256) {\r\n        return getEthAmountForTokensAtStage(\r\n            tokenSupply \r\n        , _stageId);\r\n    }\r\n\r\n    \r\n    function getTokenAmountForEthAtStage(uint256 _ethAmount, uint8 _stageId) public view returns (uint256) {\r\n        return _ethAmount\r\n        .mul(10 ** 18)\r\n        .div(stages[_stageId].tokenPrice);\r\n    }\r\n\r\n    \r\n    function getEthAmountForTokensAtStage(uint256 _tokenAmount, uint8 _stageId) public view returns (uint256) {\r\n        return _tokenAmount\r\n        .mul(stages[_stageId].tokenPrice)\r\n        .div(10 ** 18);\r\n    }\r\n\r\n    \r\n    function getCurrentBlockNumber() public view returns (uint256) {\r\n        return uint256(block.number);\r\n    }\r\n\r\n    \r\n    function getCurrentEffectiveBlockNumber() public view returns (uint256) {\r\n        return uint256(block.number)\r\n        .sub(frozenPeriod); \r\n    }\r\n\r\n    \r\n    function calcUnlockedAmount(uint256 _amount, uint256 _lastBlock) public view returns (uint256) {\r\n\r\n        uint256 currentBlock = getCurrentEffectiveBlockNumber();\r\n\r\n        if(_amount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        \r\n        if (currentBlock >= buyPhaseStartBlock && currentBlock < buyPhaseEndBlock) {\r\n\r\n            \r\n            uint256 lastBlock = _lastBlock;\r\n            if(lastBlock < buyPhaseStartBlock) {\r\n                lastBlock = buyPhaseStartBlock.sub(1); \r\n            }\r\n\r\n            \r\n            uint256 passedBlocks = currentBlock.sub(lastBlock);\r\n\r\n            \r\n            uint256 totalBlockCount = buyPhaseEndBlock.sub(lastBlock);\r\n\r\n            return _amount.mul(\r\n                passedBlocks.mul(10 ** 20)\r\n                .div(totalBlockCount)\r\n            ).div(10 ** 20);\r\n\r\n            \r\n        } else if (currentBlock >= buyPhaseEndBlock) {\r\n            return _amount;\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n\r\n    \r\n\r\n\r\n    \r\n    function sanityCheckProject() internal view {\r\n        \r\n        require(\r\n            committedETH == _projectCurrentlyReservedETH.add(_projectUnlockedETH),\r\n            'Project Sanity check failed! Reserved + Unlock must equal committedETH'\r\n        );\r\n\r\n        \r\n        require(\r\n            address(this).balance == _projectUnlockedETH.add(_projectCurrentlyReservedETH).add(pendingETH).sub(projectWithdrawnETH),\r\n            'Project sanity check failed! balance = Unlock + Reserved - Withdrawn'\r\n        );\r\n    }\r\n\r\n    \r\n    function sanityCheckParticipant(address _participantAddress) internal view {\r\n        Participant storage participantStats = participants[_participantAddress];\r\n\r\n        \r\n        require(\r\n            participantStats.reservedTokens == participantStats._currentReservedTokens.add(participantStats._unlockedTokens),\r\n            'Participant Sanity check failed! Reser. + Unlock must equal totalReser'\r\n        );\r\n    }\r\n\r\n    \r\n    function calcProjectAllocation() internal {\r\n\r\n        uint256 newlyUnlockedEth = calcUnlockedAmount(_projectCurrentlyReservedETH, _projectLastBlock);\r\n\r\n        \r\n        _projectCurrentlyReservedETH = _projectCurrentlyReservedETH.sub(newlyUnlockedEth);\r\n        _projectUnlockedETH = _projectUnlockedETH.add(newlyUnlockedEth);\r\n        _projectLastBlock = getCurrentEffectiveBlockNumber();\r\n\r\n        sanityCheckProject();\r\n    }\r\n\r\n    \r\n    function calcParticipantAllocation(address _participantAddress) internal {\r\n        Participant storage participantStats = participants[_participantAddress];\r\n\r\n        \r\n        participantStats._unlockedTokens = getParticipantUnlockedTokens(_participantAddress);\r\n        participantStats._currentReservedTokens = getParticipantReservedTokens(_participantAddress);\r\n\r\n        \r\n        participantStats._lastBlock = getCurrentEffectiveBlockNumber();\r\n\r\n        \r\n        calcProjectAllocation();\r\n    }\r\n\r\n    \r\n    function cancelPendingContributions(address _participantAddress, uint256 _sentValue)\r\n    internal\r\n    isInitialized\r\n    isNotFrozen\r\n    {\r\n        Participant storage participantStats = participants[_participantAddress];\r\n        uint256 participantPendingEth = participantStats.pendingETH;\r\n\r\n        \r\n        if(participantPendingEth == 0) {\r\n            \r\n            if(_sentValue > 0) {\r\n                address(uint160(_participantAddress)).transfer(_sentValue);\r\n            }\r\n            return;\r\n        }\r\n\r\n        \r\n        for (uint8 stageId = 0; stageId <= getCurrentStage(); stageId++) {\r\n            ParticipantStageDetails storage byStage = participantStats.stages[stageId];\r\n            byStage.pendingETH = 0;\r\n        }\r\n\r\n        \r\n        participantStats.pendingETH = 0;\r\n\r\n        \r\n        canceledETH = canceledETH.add(participantPendingEth);\r\n        pendingETH = pendingETH.sub(participantPendingEth);\r\n\r\n        \r\n        emit PendingContributionsCanceled(_participantAddress, participantPendingEth, uint32(participantStats.contributions));\r\n        emit TransferEvent(\r\n            uint8(TransferTypes.CONTRIBUTION_CANCELED),\r\n            _participantAddress,\r\n            participantPendingEth\r\n        );\r\n\r\n\r\n        \r\n        address(uint160(_participantAddress)).transfer(participantPendingEth.add(_sentValue));\r\n\r\n        \r\n        sanityCheckParticipant(_participantAddress);\r\n        sanityCheckProject();\r\n    }\r\n\r\n\r\n    \r\n    function acceptContributions(address _participantAddress)\r\n    internal\r\n    isInitialized\r\n    isNotFrozen\r\n    isRunning\r\n    {\r\n        Participant storage participantStats = participants[_participantAddress];\r\n\r\n        \r\n        if (participantStats.pendingETH == 0) {\r\n            return;\r\n        }\r\n\r\n        uint8 currentStage = getCurrentStage();\r\n        uint256 totalRefundedETH;\r\n        uint256 totalNewReservedTokens;\r\n\r\n        calcParticipantAllocation(_participantAddress);\r\n\r\n        \r\n        if(participantStats.committedETH == 0) {\r\n            participantStats.firstContributionBlock = participantStats._lastBlock; \r\n        }\r\n\r\n        \r\n        for (uint8 stageId = 0; stageId <= currentStage; stageId++) {\r\n            ParticipantStageDetails storage byStage = participantStats.stages[stageId];\r\n\r\n            \r\n            if (byStage.pendingETH == 0) {\r\n                continue;\r\n            }\r\n\r\n            uint256 maxCommittableEth = committableEthAtStage(stageId);\r\n            uint256 newlyCommittedEth = byStage.pendingETH;\r\n            uint256 returnEth = 0;\r\n\r\n            \r\n            \r\n            if (newlyCommittedEth > maxCommittableEth) {\r\n                returnEth = newlyCommittedEth.sub(maxCommittableEth);\r\n                newlyCommittedEth = maxCommittableEth;\r\n\r\n                totalRefundedETH = totalRefundedETH.add(returnEth);\r\n            }\r\n\r\n            \r\n            uint256 newTokenAmount = getTokenAmountForEthAtStage(\r\n                newlyCommittedEth, stageId\r\n            );\r\n\r\n            totalNewReservedTokens = totalNewReservedTokens.add(newTokenAmount);\r\n\r\n            \r\n            participantStats._currentReservedTokens = participantStats._currentReservedTokens.add(newTokenAmount);\r\n            participantStats.reservedTokens = participantStats.reservedTokens.add(newTokenAmount);\r\n            participantStats.committedETH = participantStats.committedETH.add(newlyCommittedEth);\r\n            participantStats.pendingETH = participantStats.pendingETH.sub(newlyCommittedEth).sub(returnEth);\r\n\r\n            byStage.pendingETH = byStage.pendingETH.sub(newlyCommittedEth).sub(returnEth);\r\n\r\n            \r\n            tokenSupply = tokenSupply.sub(newTokenAmount);\r\n            pendingETH = pendingETH.sub(newlyCommittedEth).sub(returnEth);\r\n            committedETH = committedETH.add(newlyCommittedEth);\r\n            _projectCurrentlyReservedETH = _projectCurrentlyReservedETH.add(newlyCommittedEth);\r\n\r\n            \r\n            emit ContributionsAccepted(_participantAddress, newlyCommittedEth, newTokenAmount, stageId);\r\n        }\r\n\r\n        \r\n        if (totalRefundedETH > 0) {\r\n            emit TransferEvent(uint8(TransferTypes.CONTRIBUTION_ACCEPTED_OVERFLOW), _participantAddress, totalRefundedETH);\r\n            address(uint160(_participantAddress)).transfer(totalRefundedETH);\r\n        }\r\n\r\n        \r\n        \r\n        IERC777(tokenAddress).send(_participantAddress, totalNewReservedTokens, \"\");\r\n\r\n        \r\n        sanityCheckParticipant(_participantAddress);\r\n        sanityCheckProject();\r\n    }\r\n\r\n\r\n    \r\n    function withdraw(address _participantAddress, uint256 _returnedTokenAmount)\r\n    internal\r\n    isInitialized\r\n    isNotFrozen\r\n    isRunning\r\n    {\r\n\r\n        Participant storage participantStats = participants[_participantAddress];\r\n\r\n        calcParticipantAllocation(_participantAddress);\r\n\r\n        require(_returnedTokenAmount > 0, 'You can not withdraw without sending tokens.');\r\n        require(participantStats._currentReservedTokens > 0 && participantStats.reservedTokens > 0, 'You can not withdraw, you have no locked tokens.');\r\n\r\n        uint256 returnedTokenAmount = _returnedTokenAmount;\r\n        uint256 overflowingTokenAmount;\r\n        uint256 returnEthAmount;\r\n\r\n        \r\n        if (returnedTokenAmount > participantStats._currentReservedTokens) {\r\n            overflowingTokenAmount = returnedTokenAmount.sub(participantStats._currentReservedTokens);\r\n            returnedTokenAmount = participantStats._currentReservedTokens;\r\n        }\r\n\r\n        \r\n        if(getCurrentStage() == 0) {\r\n\r\n            returnEthAmount = getEthAmountForTokensAtStage(returnedTokenAmount, 0);\r\n\r\n        \r\n        } else {\r\n            returnEthAmount = participantStats.committedETH.mul(\r\n                returnedTokenAmount.mul(10 ** 20)\r\n                .div(participantStats.reservedTokens)\r\n            ).div(10 ** 20);\r\n        }\r\n\r\n\r\n        \r\n        participantStats.withdraws++;\r\n        participantStats._currentReservedTokens = participantStats._currentReservedTokens.sub(returnedTokenAmount);\r\n        participantStats.reservedTokens = participantStats.reservedTokens.sub(returnedTokenAmount);\r\n        participantStats.committedETH = participantStats.committedETH.sub(returnEthAmount);\r\n\r\n        \r\n        tokenSupply = tokenSupply.add(returnedTokenAmount);\r\n        withdrawnETH = withdrawnETH.add(returnEthAmount);\r\n        committedETH = committedETH.sub(returnEthAmount);\r\n\r\n        _projectCurrentlyReservedETH = _projectCurrentlyReservedETH.sub(returnEthAmount);\r\n\r\n\r\n        \r\n        if (overflowingTokenAmount > 0) {\r\n            \r\n            bytes memory data;\r\n\r\n            \r\n            IERC777(tokenAddress).send(_participantAddress, overflowingTokenAmount, data);\r\n\r\n            \r\n            emit TransferEvent(uint8(TransferTypes.PARTICIPANT_WITHDRAW_OVERFLOW), _participantAddress, overflowingTokenAmount);\r\n        }\r\n\r\n        \r\n        emit ParticipantWithdraw(_participantAddress, returnEthAmount, returnedTokenAmount, uint32(participantStats.withdraws));\r\n        emit TransferEvent(uint8(TransferTypes.PARTICIPANT_WITHDRAW), _participantAddress, returnEthAmount);\r\n\r\n        \r\n        address(uint160(_participantAddress)).transfer(returnEthAmount);\r\n\r\n        \r\n        sanityCheckParticipant(_participantAddress);\r\n        sanityCheckProject();\r\n    }\r\n\r\n    \r\n\r\n    \r\n    modifier onlyProjectAddress() {\r\n        require(msg.sender == projectAddress, \"Only the project can call this method.\");\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier onlyDeployingAddress() {\r\n        require(msg.sender == deployingAddress, \"Only the deployer can call this method.\");\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier onlyWhitelistingAddress() {\r\n        require(msg.sender == whitelistingAddress, \"Only the whitelist controller can call this method.\");\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier onlyFreezerAddress() {\r\n        require(msg.sender == freezerAddress, \"Only the freezer address can call this method.\");\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier onlyRescuerAddress() {\r\n        require(msg.sender == rescuerAddress, \"Only the rescuer address can call this method.\");\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier isInitialized() {\r\n        require(initialized == true, \"Contract must be initialized.\");\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier isNotInitialized() {\r\n        require(initialized == false, \"Contract can not be initialized.\");\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier isFrozen() {\r\n        require(frozen == true, \"rICO has to be frozen!\");\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier isNotFrozen() {\r\n        require(frozen == false, \"rICO is frozen!\");\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier isRunning() {\r\n        uint256 blockNumber = getCurrentEffectiveBlockNumber();\r\n        require(blockNumber >= commitPhaseStartBlock && blockNumber <= buyPhaseEndBlock, \"Current block is outside the rICO period.\");\r\n        _;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participantAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"stageId\",\"type\":\"uint8\"}],\"name\":\"ContributionsAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participantAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"withdrawCount\",\"type\":\"uint32\"}],\"name\":\"ParticipantWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participantAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"contributionId\",\"type\":\"uint32\"}],\"name\":\"PendingContributionAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participantAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"contributionId\",\"type\":\"uint32\"}],\"name\":\"PendingContributionsCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"projectAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"withdrawCount\",\"type\":\"uint32\"}],\"name\":\"ProjectWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"freezerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"stageId\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"effectiveBlockNumber\",\"type\":\"uint256\"}],\"name\":\"SecurityDisableEscapeHatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rescuerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"stageId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"effectiveBlockNumber\",\"type\":\"uint256\"}],\"name\":\"SecurityEscapeHatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"freezerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"stageId\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"effectiveBlockNumber\",\"type\":\"uint256\"}],\"name\":\"SecurityFreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"freezerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"stageId\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"effectiveBlockNumber\",\"type\":\"uint256\"}],\"name\":\"SecurityUnfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"typeId\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relatedAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participantAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pendingETH\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"contributions\",\"type\":\"uint32\"}],\"name\":\"WhitelistApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participantAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pendingETH\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"contributions\",\"type\":\"uint32\"}],\"name\":\"WhitelistRejected\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPhaseBlockCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPhaseEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPhaseStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastBlock\",\"type\":\"uint256\"}],\"name\":\"calcUnlockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canceledETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"commit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commitPhaseBlockCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commitPhaseEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commitPhasePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commitPhaseStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_stageId\",\"type\":\"uint8\"}],\"name\":\"committableEthAtStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"committedETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freezeStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freezerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozenPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableProjectETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentEffectiveBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_stageId\",\"type\":\"uint8\"}],\"name\":\"getEthAmountForTokensAtStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_participantAddress\",\"type\":\"address\"}],\"name\":\"getParticipantReservedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_participantAddress\",\"type\":\"address\"}],\"name\":\"getParticipantUnlockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPriceAtBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_stageId\",\"type\":\"uint8\"}],\"name\":\"getPriceAtStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getStageAtBlock\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_stageId\",\"type\":\"uint8\"}],\"name\":\"getTokenAmountForEthAtStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUnlockedProjectETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistingAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_freezerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rescuerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_projectAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_commitPhaseStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_commitPhaseBlockCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_commitPhasePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_stageCount\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_stageBlockCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stagePriceIncrease\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participantCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"participants\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"contributions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"withdraws\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"firstContributionBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"committedETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentReservedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlockedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participantsById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"name\":\"projectWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectWithdrawCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectWithdrawnETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rescuerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stageBlockCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stageCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"stages\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"startBlock\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endBlock\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_approve\",\"type\":\"bool\"}],\"name\":\"whitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawnETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ReversibleICO","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"petersburg","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://27f83826ad8d06c4bdcaa7f4976f76e82480ceae598862ccbe08905af0b9c2e9"}]}