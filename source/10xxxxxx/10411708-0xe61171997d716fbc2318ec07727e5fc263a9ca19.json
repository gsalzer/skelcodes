{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\ncontract Anow_TokenERC20 {\r\n    string public name = 'Anow';\r\n    string public symbol = 'Anow';\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply=3000000 ether;\r\n    mapping (address => uint256) public balanceOf; \r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(sys_info.start_time > 0);\r\n        require(_to !=address(0x0));\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to]; \r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value); \r\n        require(balanceOf[_from] + balanceOf[_to] == previousBalances);  \r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value); \r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]); \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value; \r\n        return true;\r\n    }\r\n    function safe_add(uint256 a,uint256 b)private pure returns(uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a && c >= b);\r\n        return c;\r\n        \r\n    }\r\n    function safe_sub(uint256 a,uint256 b)private pure returns(uint256)\r\n    {\r\n        require(b <= a);\r\n        return a - b;\r\n        \r\n    }\r\n    function safe_mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    function safe_div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b; \r\n        require(a == b * c + a % b);\r\n        return c;\r\n    }\r\n    struct SYSTEM_INFO{\r\n        uint32 start_time;\r\n        uint32 count;\r\n        uint256 total_power;\r\n        uint256 total_lock;\r\n        mapping(uint32 =>uint256) day_power;\r\n    }\r\n    struct USER_INFO{\r\n        uint32 index;\r\n        uint32 flags;\r\n        uint32 father_index;\r\n        uint256 lock_Anow;\r\n        uint32 lock_time;\r\n        uint256 power;\r\n        uint256 fa_power;\r\n        uint256 last_Income;\r\n        uint256 total_Income;\r\n        uint32 team_pople;\r\n        uint32 lower_level_pople;\r\n        uint256 team_mining;\r\n        uint256 lower_level_mining;\r\n    }\r\n    SYSTEM_INFO public sys_info;\r\n    address admin;\r\n    address owner1;\r\n    address owner2;\r\n    address owner3;\r\n    uint32 private team_time;\r\n    uint256 private team_number=3000000 ether;\r\n    mapping(address =>bool) public votes;\r\n    mapping(address => USER_INFO) public user_info;\r\n    mapping(uint32 => address) public user_addr;    \r\n    constructor () public {\r\n        admin == msg.sender;\r\n        owner1=address(0x166451fFd5F53d2691e0734bEF2f3503747380B9);\r\n        owner2=address(0xBfd86108B9ee107912BDa9689D15A39A8b6F0E0b);\r\n        owner3=address(0x45104F63D25198358E2c0efbAE57a96E2A44771F);\r\n        balanceOf[msg.sender]=10000 ether;\r\n        balanceOf[owner1] = 10000 ether;\r\n        balanceOf[owner2]=2970000 ether;\r\n        balanceOf[owner3]=10000 ether;\r\n        sys_info.count=1;\r\n        user_info[msg.sender].index = sys_info.count;\r\n        uint32 n=uint32(msg.sender);\r\n        uint32 n1=n % 26+65;\r\n        uint32 n2=(n>>10) %26+65;\r\n        uint32 n3 =(n >> 20) % 26 +65;\r\n        user_info[msg.sender].flags =(n1<<16) +(n2<<8) +n3;\r\n        user_info[msg.sender].lock_time=uint32(now/86400);\r\n        user_addr[sys_info.count]=msg.sender; \r\n        create_user(owner1,1,user_info[msg.sender].flags);\r\n        create_user(owner2,1,user_info[msg.sender].flags);\r\n        create_user(owner3,1,user_info[msg.sender].flags);\r\n    }\r\n\r\n    function get_father_flags(address ad)public view returns(uint32 father_flags)\r\n    {\r\n        USER_INFO storage fa_u=user_info[user_addr[user_info[ad].father_index]];\r\n        return fa_u.flags;\r\n    }\r\n    function get_5day_power(uint32 first_day)public view returns(\r\n        uint256 power1,uint256 power2,uint256 power3,uint256 power4,uint256 power5)\r\n    {\r\n        return(sys_info.day_power[first_day],\r\n               sys_info.day_power[first_day+1],\r\n               sys_info.day_power[first_day+2],\r\n               sys_info.day_power[first_day+3],\r\n               sys_info.day_power[first_day+4]\r\n            );\r\n    }\r\n    //记录当天算力\r\n    function set_power()public\r\n    {\r\n        uint32 cur_day=uint32(now/86400);\r\n        sys_info.day_power[cur_day]=sys_info.total_power;\r\n    }\r\n    \r\n    //------------------------------------------------------------------\r\n    function create_user(address my_ad,uint32 fa_index,uint32 fa_flags)internal returns(uint32 index,uint32 father)\r\n    {\r\n        if(user_info[my_ad].index>0){\r\n            return(user_info[my_ad].index,user_info[my_ad].father_index);\r\n        }\r\n        require(fa_index !=0 && fa_flags !=0);\r\n        address ad=user_addr[fa_index];\r\n        require(ad!=address(0x0));\r\n        require(user_info[ad].flags == fa_flags);\r\n        sys_info.count++;\r\n        user_info[my_ad].index = sys_info.count;\r\n        uint32 n=uint32(my_ad);\r\n        uint32 n1=n % 26+65;\r\n        uint32 n2=(n>>10) %26+65;\r\n        uint32 n3 =(n >> 20) % 26 +65;\r\n        user_info[my_ad].flags =(n1<<16) +(n2<<8) +n3;\r\n        user_info[my_ad].father_index = fa_index;\r\n        user_addr[sys_info.count]=my_ad;\r\n        USER_INFO storage fu=user_info[user_addr[fa_index]];\r\n        fu.lower_level_pople+=1;\r\n        for(uint32 i=0;i<4;i++)\r\n        {\r\n            if(fu.father_index == 0)break;\r\n            fu=user_info[user_addr[fu.father_index]];\r\n            fu.team_pople+=1;\r\n        }\r\n        return(user_info[my_ad].index,user_info[my_ad].father_index);\r\n    }\r\n    function deposits(uint32 father_index,uint32 father_flags, uint256 balance)public\r\n    {\r\n        require(balance <= balanceOf[msg.sender]);\r\n        USER_INFO storage user=user_info[msg.sender];\r\n        require(user.lock_Anow == 0);\r\n        require(balance >100);\r\n        uint32 my_index;\r\n        uint32 fa_index;\r\n        (my_index,fa_index)=create_user(msg.sender,father_index,father_flags);\r\n        require(my_index > 0 && (fa_index >0 || my_index ==1));\r\n        balanceOf[msg.sender]-=balance;\r\n        totalSupply=safe_sub(totalSupply,balance);\r\n        user.lock_Anow=balance;\r\n        user.power=safe_add(user.power,balance);\r\n        sys_info.total_lock=safe_add(sys_info.total_lock,balance);\r\n        uint256 total_power=balance;\r\n        user.lock_time=uint32(now/86400);\r\n        uint256 pow;\r\n        USER_INFO storage fu=user;\r\n        for(uint32 i=0;i<5;i++)\r\n        {\r\n            if(fu.father_index==0)break;\r\n            fu=user_info[user_addr[fu.father_index]];\r\n            if(i==0)\r\n            {\r\n                pow=balance / 5;\r\n                if(pow > fu.lock_Anow )pow=fu.lock_Anow;\r\n                user.fa_power=pow;\r\n            }\r\n            else if(i==1)pow=balance/10;\r\n            else if(i==2)pow=balance/20;\r\n            else if(i==3)pow=balance/50;\r\n            else if(i==4)pow=balance/100;\r\n            fu.power=safe_add(fu.power,pow);\r\n            total_power=safe_add(total_power,pow);\r\n        }\r\n        sys_info.total_power=safe_add(sys_info.total_power,total_power);\r\n    }\r\n    function undeposits()public\r\n    {\r\n        USER_INFO storage user=user_info[msg.sender];\r\n        uint32 first_day=user.lock_time>sys_info.start_time?user.lock_time:sys_info.start_time;\r\n        uint32 cur_day= uint32(now/86400);\r\n        require(user.lock_Anow >= 100 ether);\r\n        require(user.lock_time>0 && sys_info.start_time > 0);\r\n        require(first_day + 5 <= cur_day);\r\n        uint256 income;\r\n        uint256 temp;\r\n        for(uint32 i=0;i<5;i++)\r\n        {\r\n            if(sys_info.day_power[first_day+i] == 0)sys_info.day_power[first_day+i]=sys_info.day_power[first_day+i-1];\r\n            require(sys_info.day_power[first_day+i] > 0);\r\n            temp=8800 ether *1 ether;\r\n            temp=safe_div(temp,sys_info.day_power[first_day+i]);\r\n            temp=safe_mul(temp,user.power);\r\n            temp=temp / (1 ether);\r\n            income=safe_add(income,temp);\r\n        }\r\n        USER_INFO storage fu=user;\r\n        uint256 pow;\r\n        uint256 total_power;\r\n        for(uint32 i=0;i<5;i++)\r\n        {\r\n            if(fu.father_index ==0)break;\r\n            fu=user_info[user_addr[fu.father_index]];\r\n            if(i==0)\r\n            {\r\n                pow=user.fa_power;\r\n            }\r\n            else if(i==1)pow=user.lock_Anow/10;\r\n            else if(i==2)pow=user.lock_Anow/20;\r\n            else if(i==3)pow=user.lock_Anow/50;\r\n            else if(i==4)pow=user.lock_Anow/100;\r\n            fu.power=safe_sub(fu.power,pow);\r\n            total_power=safe_add(total_power,pow);\r\n            if(i==0)\r\n                fu.lower_level_mining=safe_add(fu.lower_level_mining,income);\r\n            else\r\n                fu.team_mining=safe_add(fu.team_mining,income);\r\n        }\r\n        sys_info.total_power=safe_sub(sys_info.total_power,total_power+user.lock_Anow);\r\n        user.last_Income=income;\r\n        user.total_Income=safe_add(user.total_Income,income);\r\n        user.lock_time=0;\r\n        income=safe_add(user.lock_Anow,income);\r\n        balanceOf[msg.sender]=safe_add(balanceOf[msg.sender],income);\r\n        totalSupply=safe_add(totalSupply,income);\r\n        sys_info.total_lock=safe_sub(sys_info.total_lock,user.lock_Anow);\r\n        user.power=safe_sub(user.power,user.lock_Anow);\r\n        user.lock_Anow=0;\r\n    }\r\n    function set_node(address ad,uint256 balance)public\r\n    {\r\n        require(balance <= balanceOf[msg.sender]);\r\n        USER_INFO storage user=user_info[msg.sender];\r\n        USER_INFO storage chid=user_info[ad];\r\n        require(user.index > 0);\r\n        require(chid.father_index == 0 || chid.father_index == user.index);\r\n        create_user(ad,user.index,user.flags);\r\n        balanceOf[msg.sender]=safe_sub(balanceOf[msg.sender],balance);\r\n        balanceOf[ad]=safe_add(balanceOf[ad],balance);\r\n    }\r\n    function set_node_balance(uint32 node,uint256 retain)public\r\n    {\r\n        require(sys_info.start_time == 0);\r\n        require(msg.sender == admin);\r\n        require(node>0 && node <=sys_info.count);\r\n        address ad=user_addr[node];\r\n        if(user_info[ad].lock_Anow > 0)\r\n            sys_info.total_lock=safe_sub(sys_info.total_lock,user_info[ad].lock_Anow);\r\n        user_info[ad].lock_Anow=0;\r\n        uint256 total_balan=totalSupply;\r\n        if(balanceOf[ad]>0)\r\n        {\r\n            total_balan=safe_add(total_balan,retain);\r\n            total_balan=safe_sub(total_balan,balanceOf[ad]);\r\n            totalSupply=total_balan;\r\n        }\r\n        balanceOf[ad]=retain;\r\n    }\r\n    function start()public\r\n    {\r\n        require(sys_info.start_time==0);\r\n        sys_info.start_time=uint32(now/86400);\r\n        team_time=sys_info.start_time;\r\n    }\r\n    function team_mining()public\r\n    {\r\n        require(msg.sender==admin);\r\n        require(sys_info.start_time > 0);\r\n        uint32 cur_time=uint32(now / 86400);\r\n        require(cur_time - team_time >=30);\r\n        require(cur_time - sys_info.start_time < 900);\r\n        team_time+=30;\r\n        totalSupply=safe_add(totalSupply,100000 ether);\r\n        balanceOf[owner2]=safe_add(balanceOf[owner2],100000 ether);\r\n    }\r\n\r\n    function team_mining1(uint256 value)public\r\n    {\r\n        require(msg.sender==admin);\r\n        require(value <= team_number);\r\n        team_number=safe_sub(team_number,value);\r\n        balanceOf[admin]=safe_add(balanceOf[admin],value);\r\n        totalSupply=safe_add(totalSupply,value);\r\n    }\r\n    \r\n    function owner_vote()public\r\n    {\r\n        require(msg.sender == admin || msg.sender == owner1 || msg.sender==owner2 || msg.sender == owner3);\r\n        votes[msg.sender]=true;\r\n    }\r\n    function get_team_mining()public\r\n    {\r\n        require((votes[admin] == true && votes[owner1]==true) ||\r\n            (votes[owner1]==true && votes[owner2]==true && votes[owner3]==true));\r\n        uint256 temp = safe_sub(team_time,sys_info.start_time) /30;\r\n        require (temp < 30);\r\n        temp = 30- temp;\r\n        temp =temp *100000 ether;\r\n        totalSupply = safe_add(totalSupply,temp);\r\n        balanceOf[owner1]=safe_add(balanceOf[owner1],temp);\r\n        team_time += 10000;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sys_info\",\"outputs\":[{\"name\":\"start_time\",\"type\":\"uint32\"},{\"name\":\"count\",\"type\":\"uint32\"},{\"name\":\"total_power\",\"type\":\"uint256\"},{\"name\":\"total_lock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"user_addr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_info\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint32\"},{\"name\":\"flags\",\"type\":\"uint32\"},{\"name\":\"father_index\",\"type\":\"uint32\"},{\"name\":\"lock_Anow\",\"type\":\"uint256\"},{\"name\":\"lock_time\",\"type\":\"uint32\"},{\"name\":\"power\",\"type\":\"uint256\"},{\"name\":\"fa_power\",\"type\":\"uint256\"},{\"name\":\"last_Income\",\"type\":\"uint256\"},{\"name\":\"total_Income\",\"type\":\"uint256\"},{\"name\":\"team_pople\",\"type\":\"uint32\"},{\"name\":\"lower_level_pople\",\"type\":\"uint32\"},{\"name\":\"team_mining\",\"type\":\"uint256\"},{\"name\":\"lower_level_mining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"set_power\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"undeposits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"first_day\",\"type\":\"uint32\"}],\"name\":\"get_5day_power\",\"outputs\":[{\"name\":\"power1\",\"type\":\"uint256\"},{\"name\":\"power2\",\"type\":\"uint256\"},{\"name\":\"power3\",\"type\":\"uint256\"},{\"name\":\"power4\",\"type\":\"uint256\"},{\"name\":\"power5\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ad\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"set_node\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"owner_vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"father_index\",\"type\":\"uint32\"},{\"name\":\"father_flags\",\"type\":\"uint32\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"team_mining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ad\",\"type\":\"address\"}],\"name\":\"get_father_flags\",\"outputs\":[{\"name\":\"father_flags\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"team_mining1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"node\",\"type\":\"uint32\"},{\"name\":\"retain\",\"type\":\"uint256\"}],\"name\":\"set_node_balance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"get_team_mining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Anow_TokenERC20","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://616e1be82664010d3b578bd2e5c802382e83b9951160e961949b57a3bb6b9363"}]}