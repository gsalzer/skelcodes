{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FundFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD 3-Clause\\n\\npragma solidity ^0.6.10;\\n\\nimport \\\"./EndaomentAdminStorage.sol\\\";\\nimport \\\"./Fund.sol\\\";\\nimport \\\"./ProxyFactory.sol\\\";\\n\\n// FUND FACTORY CONTRACT\\n/**\\n * @title FundFactory\\n * @author rheeger\\n * @notice FundFactory is a contract that allows the Endaoment ADMIN or ACCOUNTANT to\\n * instantiate new Fund contracts.\\n */\\ncontract FundFactory is ProxyFactory, EndaomentAdminStorage {\\n  // ========== EVENTS ==========\\n  event FundCreated(address indexed newAddress);\\n  event FundLogicDeployed(address logicAddress);\\n\\n  // ========== STATE VARIABLES==========\\n\\n  address public immutable fundLogic; // logic template for all Fund contracts\\n\\n  // ========== CONSTRUCTOR ==========\\n  /**\\n   * @notice Create new Fund Factory\\n   * @param adminContractAddress Address of EndaomentAdmin contract.\\n   */\\n  constructor(address adminContractAddress) public {\\n    // Set endaoment admin\\n    require(adminContractAddress != address(0), \\\"FundFactory: Admin cannot be the zero address\\\");\\n    endaomentAdmin = adminContractAddress;\\n    emit EndaomentAdminChanged(address(0), adminContractAddress);\\n\\n    // Deploy and initialize Fund logic contract (used to deploy minimal proxies in createFund)\\n    // We set the address of the fund manager to whoever deployed this contract. Since this\\n    // instance will not be used as anything other than a logic template, the address used\\n    // as the fund manager does not matter much\\n    Fund fundLogicContract = new Fund();\\n    fundLogicContract.initializeFund(msg.sender, address(this));\\n\\n    // Save off address so we can reference for all future deployments\\n    fundLogic = address(fundLogicContract);\\n    emit FundLogicDeployed(address(fundLogicContract));\\n  }\\n\\n  // ========== Fund Creation & Management ==========\\n  /**\\n   * @notice Creates new Fund and emits a `FundCreated` event.\\n   * @param managerAddress The address of the Fund's Primary Advisor\\n   */\\n  function createFund(address managerAddress)\\n    public\\n    onlyAdminOrRole(endaomentAdmin, IEndaomentAdmin.Role.ACCOUNTANT)\\n  {\\n    require(managerAddress != address(0), \\\"FundFactory: Manager cannot be the zero address\\\");\\n    bytes memory payload = abi.encodeWithSignature(\\n      \\\"initializeFund(address,address)\\\",\\n      managerAddress,\\n      address(this)\\n    );\\n    address newFund = deployMinimal(fundLogic, payload);\\n    emit FundCreated(newFund);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/EndaomentAdminStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD 3-Clause\\n\\npragma solidity ^0.6.10;\\n\\nimport \\\"./Administratable.sol\\\";\\n\\n// ENDAOMENT ADMIN STORAGE CONTRACT\\n/**\\n * @title EndaomentAdminStorage\\n * @author rheeger\\n * @notice Stores the contract address of the EndaomentAdmin,\\n * for use in references by the Org and Fund factories and\\n * subsequently deployed Org and Fund contracts.\\n */\\ncontract EndaomentAdminStorage is Administratable {\\n  address public endaomentAdmin;\\n  event EndaomentAdminChanged(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @notice Updates address of the endaomentAdmin contract and emits `EndaomentAdminChanged` event.\\n   * @param newAdmin New address of the endaomentAdmin contract\\n   */\\n  function updateEndaomentAdmin(address newAdmin) public onlyAdmin(endaomentAdmin) {\\n    // Validate that contract has a valid admin address set\\n    require(newAdmin != address(0), \\\"EndaomentAdminStorage: New admin cannot be the zero address\\\");\\n    EndaomentAdmin endaomentAdminContract = EndaomentAdmin(newAdmin);\\n\\n    address admin = endaomentAdminContract.getRoleAddress(IEndaomentAdmin.Role.ADMIN);\\n    require(admin != address(0), \\\"EndaomentAdminStorage: Admin cannot be the zero address\\\");\\n\\n    emit EndaomentAdminChanged(endaomentAdmin, newAdmin);\\n    endaomentAdmin = newAdmin;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Fund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD 3-Clause\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Administratable.sol\\\";\\nimport \\\"./OrgFactory.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\n// FUND CONTRACT\\n/**\\n * @title Fund\\n * @author rheeger\\n * @notice Fund is a contract that serves as an on-chain US Donor-Advised Fund.\\n * It holds the proceeds of gifted cryptocurrency as ERC20 tokens,\\n * and allows for the manager to submit Grant recommendations to the contract.\\n * The EndaomentAdmin can then chose to approve the Grant recommendation, triggering\\n * a SafeMath transfer of a 1% fee to the EndaomentAdmin and the remainder to the\\n * recipient Org contract.\\n */\\ncontract Fund is Initializable, Administratable {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  // ========== STRUCTS & EVENTS ==========\\n\\n  struct Grant {\\n    string description;\\n    uint256 value;\\n    address recipient;\\n    bool complete;\\n  }\\n\\n  event ManagerChanged(address newManager);\\n  event GrantCreated(string grantId, Grant grant);\\n  event GrantUpdated(string grantId, Grant grant);\\n  event GrantRejected(string grantId);\\n  event GrantFinalized(string grantId, Grant grant);\\n\\n  // ========== STATE VARIABLES ==========\\n\\n  address public manager;\\n  IFactory public fundFactoryContract;\\n  mapping(string => Grant) public pendingGrants; // grant UUID to Grant\\n\\n  // ========== CONSTRUCTOR ==========\\n  /**\\n   * @notice Create new Fund\\n   * @dev Using initializer instead of constructor for minimal proxy support. This function\\n   * can only be called once in the contract's lifetime\\n   * @param fundManager Address of the Fund's Primary Advisor\\n   * @param fundFactory Address of the Factory contract.\\n   */\\n  function initializeFund(address fundManager, address fundFactory) public initializer {\\n    require(fundManager != address(0), \\\"Fund: Creator cannot be null address.\\\");\\n    require(fundFactory != address(0), \\\"Fund: Factory cannot be null address.\\\");\\n    manager = fundManager;\\n    fundFactoryContract = IFactory(fundFactory);\\n  }\\n\\n  // ========== Fund Management & Info ==========\\n  /**\\n   * @notice Changes Fund Primary Advisor and emits a `ManagerChanged` event\\n   * @param  newManager The address of the new PrimaryAdvisor.\\n   */\\n  function changeManager(address newManager)\\n    public\\n    onlyAdminOrRole(fundFactoryContract.endaomentAdmin(), IEndaomentAdmin.Role.REVIEWER)\\n  {\\n    require(newManager != address(0), \\\"Fund: New manager cannot be the zero address\\\");\\n    emit ManagerChanged(newManager);\\n    manager = newManager;\\n  }\\n\\n  /**\\n   * @notice Checks recipient of a Grant is an address created by the OrgFactory\\n   * @param  recipient The address of the Grant recipient.\\n   * @param  orgFactoryContractAddress Address of the OrgFactory contract.\\n   * @return Boolean of status of given recipient status.\\n   */\\n  function checkRecipient(address recipient, address orgFactoryContractAddress)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    require(recipient != address(0), \\\"Fund: Recipient cannot be the zero address\\\");\\n    require(orgFactoryContractAddress != address(0), \\\"Fund: OrgFactory cannot be the zero address\\\");\\n    OrgFactory orgFactory = OrgFactory(orgFactoryContractAddress);\\n\\n    return orgFactory.allowedOrgs(recipient);\\n  }\\n\\n  /**\\n   * @notice Returns summary of details about the fund [tokenBalance, number of grants, managerAddress].\\n   * @param  tokenAddress The token address of the ERC20 being used by the web-server.\\n   * @return Returns the token balance of the given tokenAddress and the address of the Fund's manager.\\n   */\\n  function getSummary(address tokenAddress) external view returns (uint256, address) {\\n    require(tokenAddress != address(0), \\\"Fund: Token address cannot be the zero address\\\");\\n    IERC20 tokenContract = IERC20(tokenAddress);\\n    uint256 balance = tokenContract.balanceOf(address(this));\\n\\n    return (balance, manager);\\n  }\\n\\n  /**\\n   * @notice Creates new Grant Recommendation and emits a `GrantCreated` event.\\n   * @param  grantId UUID representing this grant\\n   * @param  description The address of the Owner.\\n   * @param  value The value of the grant in base units.\\n   * @param  recipient The address of the recieving organization's contract.\\n   */\\n  function createGrant(\\n    string calldata grantId,\\n    string calldata description,\\n    uint256 value,\\n    address recipient\\n  )\\n    public\\n    onlyAddressOrAdminOrRole(\\n      manager,\\n      fundFactoryContract.endaomentAdmin(),\\n      IEndaomentAdmin.Role.REVIEWER\\n    )\\n  {\\n    require(!isEqual(grantId, \\\"\\\"), \\\"Fund: Must provide a grantId\\\");\\n    require(!isEqual(description, \\\"\\\"), \\\"Fund: Must provide a description\\\");\\n    EndaomentAdmin endaomentAdmin = EndaomentAdmin(fundFactoryContract.endaomentAdmin());\\n    require(\\n      checkRecipient(recipient, endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ORG_FACTORY)) ==\\n        true,\\n      \\\"Fund: Recipient contract was not created by the OrgFactory and is not allowed.\\\"\\n    );\\n    require(pendingGrants[grantId].recipient == address(0), \\\"Fund: Grant was already created.\\\");\\n\\n    Grant memory newGrant = Grant({\\n      description: description,\\n      value: value,\\n      recipient: recipient,\\n      complete: false\\n    });\\n    emit GrantCreated(grantId, newGrant);\\n    pendingGrants[grantId] = newGrant;\\n  }\\n\\n  /**\\n   * @notice Updates Grant Recommendation and emits a `GrantUpdated` event.\\n   * @param  grantId UUID representing this grant\\n   * @param  description The address of the Owner.\\n   * @param  value The value of the grant in base units.\\n   * @param  recipient The address of the recieving organization's contract.\\n   */\\n  function updateGrant(\\n    string calldata grantId,\\n    string calldata description,\\n    uint256 value,\\n    address recipient\\n  )\\n    public\\n    onlyAddressOrAdminOrRole(\\n      manager,\\n      fundFactoryContract.endaomentAdmin(),\\n      IEndaomentAdmin.Role.REVIEWER\\n    )\\n  {\\n    require(!isEqual(grantId, \\\"\\\"), \\\"Fund: Must provide a grantId\\\");\\n    require(!isEqual(description, \\\"\\\"), \\\"Fund: Must provide a description\\\");\\n    EndaomentAdmin endaomentAdmin = EndaomentAdmin(fundFactoryContract.endaomentAdmin());\\n    require(\\n      checkRecipient(recipient, endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ORG_FACTORY)) ==\\n        true,\\n      \\\"Fund: Recipient contract was not created by the OrgFactory and is not allowed.\\\"\\n    );\\n    require(pendingGrants[grantId].recipient != address(0), \\\"Fund: Grant does not exist.\\\");\\n    require(!pendingGrants[grantId].complete, \\\"Fund: Grant is already finalized.\\\");\\n    Grant memory replacementGrant = Grant({\\n      description: description,\\n      value: value,\\n      recipient: recipient,\\n      complete: false\\n    });\\n    pendingGrants[grantId] = replacementGrant;\\n    emit GrantUpdated(grantId, replacementGrant);\\n  }\\n\\n  /**\\n   * @notice Rejects Grant Recommendation and emits a `GrantRejected` event.\\n   * @param  grantId UUID representing this grant\\n   */\\n  function rejectGrant(string calldata grantId)\\n    public\\n    onlyAddressOrAdminOrRole(\\n      manager,\\n      fundFactoryContract.endaomentAdmin(),\\n      IEndaomentAdmin.Role.REVIEWER\\n    )\\n  {\\n    require(!isEqual(grantId, \\\"\\\"), \\\"Fund: Must provide a grantId\\\");\\n    require(pendingGrants[grantId].recipient != address(0), \\\"Fund: Grant does not exist.\\\");\\n    require(!pendingGrants[grantId].complete, \\\"Fund: Grant is already finalized.\\\");\\n\\n    delete pendingGrants[grantId];\\n    emit GrantRejected(grantId);\\n  }\\n\\n  /**\\n   * @notice Approves Grant Recommendation and emits a `GrantFinalized` event.\\n   * @param  grantId UUID of the grant being finalized\\n   * @param  tokenAddress The ERC20 token address of the token prescribed by the web-server.\\n   */\\n  function finalizeGrant(string calldata grantId, address tokenAddress)\\n    public\\n    onlyAdminOrRole(fundFactoryContract.endaomentAdmin(), IEndaomentAdmin.Role.REVIEWER)\\n  {\\n    require(!isEqual(grantId, \\\"\\\"), \\\"Fund: Must provide a grantId\\\");\\n    require(tokenAddress != address(0), \\\"Fund: Token address cannot be the zero address\\\");\\n    Grant storage grant = pendingGrants[grantId];\\n    require(grant.recipient != address(0), \\\"Fund: Grant does not exist\\\");\\n    // Checks\\n    require(!grant.complete, \\\"Fund: Grant is already finalized.\\\");\\n    // Effects\\n    IERC20 tokenContract = IERC20(tokenAddress);\\n    // Process fees:\\n    uint256 fee = grant.value.div(100);\\n    uint256 finalGrant = grant.value.sub(fee);\\n    grant.complete = true;\\n    emit GrantFinalized(grantId, grant);\\n    // Interactions\\n    address endaomentAdminAdminAddress = EndaomentAdmin(fundFactoryContract.endaomentAdmin())\\n      .getRoleAddress(IEndaomentAdmin.Role.ADMIN);\\n    tokenContract.safeTransfer(endaomentAdminAdminAddress, fee);\\n    tokenContract.safeTransfer(grant.recipient, finalGrant);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\ncontract ProxyFactory {\\n  /**\\n   * @dev This function enables deployment of EIP-1167 minimal proxies. The code below\\n   * was copied from the OpenZeppelin ProxyFactory.sol contract, as there is currently\\n   * no package that has a version compatible with Solidity ^0.6.0. At the time of writing\\n   * copy/pasting the file in this manner is considered the best practice for ^0.6.0:\\n   *   https://forum.openzeppelin.com/t/best-practice-for-using-proxyfactory-sol-in-a-solidity-0-6-project-deploying-minimal-proxies/3478\\n   *\\n   * EIP-1167 references:\\n   *   The EIP and associated CloneFactory repo\\n   *     - https://eips.ethereum.org/EIPS/eip-1167\\n   *   Open Zeppelin blog post and discussion\\n   *     - https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\\n   *     - https://forum.openzeppelin.com/t/deep-dive-into-the-minimal-proxy-contract/1928\\n   */\\n  function deployMinimal(address _logic, bytes memory _data) public returns (address proxy) {\\n    // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\\n    bytes20 targetBytes = bytes20(_logic);\\n    assembly {\\n      let clone := mload(0x40)\\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n      mstore(add(clone, 0x14), targetBytes)\\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n      proxy := create(0, clone, 0x37)\\n    }\\n\\n    if (_data.length > 0) {\\n      (bool success, ) = proxy.call(_data);\\n      require(success, \\\"ProxyFactory: Initialization of proxy failed\\\");\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Administratable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD 3-Clause\\n\\npragma solidity ^0.6.10;\\n\\nimport \\\"./EndaomentAdmin.sol\\\";\\n\\n//ADMINISTRATABLE\\n/**\\n * @title Administratable\\n * @author rheeger\\n * @notice Provides two modifiers allowing contracts administered\\n * by the EndaomentAdmin contract to properly restrict method calls\\n * based on the a given role. Also provides a utility function for\\n * validating string input arguments.\\n */\\ncontract Administratable {\\n  /**\\n   * @notice onlyAdmin checks that the caller is the EndaomentAdmin\\n   * @param adminContractAddress is the supplied EndaomentAdmin contract address\\n   */\\n  modifier onlyAdmin(address adminContractAddress) {\\n    require(\\n      adminContractAddress != address(0),\\n      \\\"Administratable: Admin must not be the zero address\\\"\\n    );\\n    EndaomentAdmin endaomentAdmin = EndaomentAdmin(adminContractAddress);\\n\\n    require(\\n      msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ADMIN),\\n      \\\"Administratable: only ADMIN can access.\\\"\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @notice onlyAdminOrRole checks that the caller is either the Admin or the provided role.\\n   * @param adminContractAddress supplied EndaomentAdmin address\\n   * @param role The role to require unless the caller is the owner. Permitted\\n   * roles are ADMIN (6), ACCOUNTANT (2), REVIEWER (3), FUND_FACTORY (4) and ORG_FACTORY(5).\\n   */\\n  modifier onlyAdminOrRole(address adminContractAddress, IEndaomentAdmin.Role role) {\\n    _onlyAdminOrRole(adminContractAddress, role);\\n    _;\\n  }\\n\\n  /**\\n   * @notice _onlyAdminOrRole checks that the caller is either the Admin or the provided role.\\n   * @param adminContractAddress supplied EndaomentAdmin address\\n   * @param role The role to require unless the caller is the owner. Permitted\\n   * roles are ADMIN (6), ACCOUNTANT (2), REVIEWER (3), FUND_FACTORY (4) and ORG_FACTORY(5).\\n   */\\n  function _onlyAdminOrRole(address adminContractAddress, IEndaomentAdmin.Role role) private view {\\n    require(\\n      adminContractAddress != address(0),\\n      \\\"Administratable: Admin must not be the zero address\\\"\\n    );\\n    EndaomentAdmin endaomentAdmin = EndaomentAdmin(adminContractAddress);\\n    bool isAdmin = (msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ADMIN));\\n\\n    if (!isAdmin) {\\n      if (endaomentAdmin.isPaused(role)) {\\n        revert(\\\"Administratable: requested role is paused\\\");\\n      }\\n\\n      if (role == IEndaomentAdmin.Role.ACCOUNTANT) {\\n        require(\\n          msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ACCOUNTANT),\\n          \\\"Administratable: only ACCOUNTANT can access\\\"\\n        );\\n      }\\n      if (role == IEndaomentAdmin.Role.REVIEWER) {\\n        require(\\n          msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.REVIEWER),\\n          \\\"Administratable: only REVIEWER can access\\\"\\n        );\\n      }\\n      if (role == IEndaomentAdmin.Role.FUND_FACTORY) {\\n        require(\\n          msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.FUND_FACTORY),\\n          \\\"Administratable: only FUND_FACTORY can access\\\"\\n        );\\n      }\\n      if (role == IEndaomentAdmin.Role.ORG_FACTORY) {\\n        require(\\n          msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ORG_FACTORY),\\n          \\\"Administratable: only ORG_FACTORY can access\\\"\\n        );\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Checks that the caller is either a provided address, admin or role.\\n   * @param allowedAddress An exempt address provided that shall be allowed to proceed.\\n   * @param adminContractAddress The EndaomentAdmin contract address.\\n   * @param role The desired IEndaomentAdmin.Role to check against. Permitted\\n   * roles are ADMIN (6), ACCOUNTANT (2), REVIEWER (3), FUND_FACTORY (4) and ORG_FACTORY(5).\\n   */\\n  modifier onlyAddressOrAdminOrRole(\\n    address allowedAddress,\\n    address adminContractAddress,\\n    IEndaomentAdmin.Role role\\n  ) {\\n    require(\\n      allowedAddress != address(0),\\n      \\\"Administratable: Allowed address must not be the zero address\\\"\\n    );\\n\\n    bool isAllowed = (msg.sender == allowedAddress);\\n\\n    if (!isAllowed) {\\n      _onlyAdminOrRole(adminContractAddress, role);\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice Returns true if two strings are equal, false otherwise\\n   * @param s1 First string to compare\\n   * @param s2 Second string to compare\\n   */\\n  function isEqual(string memory s1, string memory s2) internal pure returns (bool) {\\n    return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/EndaomentAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD 3-Clause\\n\\npragma solidity ^0.6.10;\\n\\nimport \\\"./interfaces/IEndaomentAdmin.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n *\\n * In order to transfer ownership, a recipient must be specified, at which point\\n * the specified recipient can call `acceptOwnership` and take ownership.\\n */\\ncontract TwoStepOwnable {\\n  address private _owner;\\n  address private _newPotentialOwner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  event TransferInitiated(address indexed newOwner);\\n\\n  event TransferCancelled(address indexed newPotentialOwner);\\n\\n  /**\\n   * @dev Initialize contract by setting transaction submitter as initial owner.\\n   */\\n  constructor() internal {\\n    _owner = tx.origin;\\n    emit OwnershipTransferred(address(0), _owner);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function getOwner() external view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current potential new owner.\\n   */\\n  function getNewPotentialOwner() external view returns (address) {\\n    return _newPotentialOwner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(isOwner(), \\\"TwoStepOwnable: caller is not the owner.\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns true if the caller is the current owner.\\n   */\\n  function isOwner() public view returns (bool) {\\n    return msg.sender == _owner;\\n  }\\n\\n  /**\\n   * @dev Allows a new account (`newOwner`) to accept ownership.\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newPotentialOwner) public onlyOwner {\\n    require(\\n      newPotentialOwner != address(0),\\n      \\\"TwoStepOwnable: new potential owner is the zero address.\\\"\\n    );\\n\\n    _newPotentialOwner = newPotentialOwner;\\n    emit TransferInitiated(address(newPotentialOwner));\\n  }\\n\\n  /**\\n   * @dev Cancel a transfer of ownership to a new account.\\n   * Can only be called by the current owner.\\n   */\\n  function cancelOwnershipTransfer() public onlyOwner {\\n    emit TransferCancelled(address(_newPotentialOwner));\\n    delete _newPotentialOwner;\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to the caller.\\n   * Can only be called by a new potential owner set by the current owner.\\n   */\\n  function acceptOwnership() public {\\n    require(\\n      msg.sender == _newPotentialOwner,\\n      \\\"TwoStepOwnable: current owner must set caller as new potential owner.\\\"\\n    );\\n\\n    delete _newPotentialOwner;\\n\\n    emit OwnershipTransferred(_owner, msg.sender);\\n\\n    _owner = msg.sender;\\n  }\\n}\\n\\n/**\\n * @title EndaomentAdmin\\n * @author rheeger\\n * @notice Provides admin controls for the Endaoment contract ecosystem using\\n * a roles-based system. Available roles are PAUSER (1), ACCOUNTANT (2),\\n * REVIEWER (3), FUND_FACTORY (4), ORG_FACTORY (5), and ADMIN (6).\\n */\\ncontract EndaomentAdmin is IEndaomentAdmin, TwoStepOwnable {\\n  // Maintain a role status mapping with assigned accounts and paused states.\\n  mapping(uint256 => RoleStatus) private _roles;\\n\\n  /**\\n   * @notice Set a new account on a given role and emit a `RoleModified` event\\n   * if the role holder has changed. Only the owner may call this function.\\n   * @param role The role that the account will be set for.\\n   * @param account The account to set as the designated role bearer.\\n   */\\n  function setRole(Role role, address account) public override onlyOwner {\\n    require(account != address(0), \\\"EndaomentAdmin: Must supply an account.\\\");\\n    _setRole(role, account);\\n  }\\n\\n  /**\\n   * @notice Remove any current role bearer for a given role and emit a\\n   * `RoleModified` event if a role holder was previously set. Only the owner\\n   * may call this function.\\n   * @param role The role that the account will be removed from.\\n   */\\n  function removeRole(Role role) public override onlyOwner {\\n    _setRole(role, address(0));\\n  }\\n\\n  /**\\n   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\\n   * the owner or the designated pauser may call this function. Also, bear in\\n   * mind that only the owner may unpause a role once paused.\\n   * @param role The role to pause.\\n   */\\n  function pause(Role role) public override onlyAdminOr(Role.PAUSER) {\\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\\n    require(!storedRoleStatus.paused, \\\"EndaomentAdmin: Role in question is already paused.\\\");\\n    storedRoleStatus.paused = true;\\n    emit RolePaused(role);\\n  }\\n\\n  /**\\n   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\\n   * Only the owner may call this function.\\n   * @param role The role to pause.\\n   */\\n  function unpause(Role role) public override onlyOwner {\\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\\n    require(storedRoleStatus.paused, \\\"EndaomentAdmin: Role in question is already unpaused.\\\");\\n    storedRoleStatus.paused = false;\\n    emit RoleUnpaused(role);\\n  }\\n\\n  /**\\n   * @notice External view function to check whether or not the functionality\\n   * associated with a given role is currently paused or not. The owner or the\\n   * pauser may pause any given role (including the pauser itself), but only the\\n   * owner may unpause functionality. Additionally, the owner may call paused\\n   * functions directly.\\n   * @param role The role to check the pause status on.\\n   * @return A boolean to indicate if the functionality associated with\\n   * the role in question is currently paused.\\n   */\\n  function isPaused(Role role) external override view returns (bool) {\\n    return _isPaused(role);\\n  }\\n\\n  /**\\n   * @notice External view function to check whether the caller is the current\\n   * role holder.\\n   * @param role The role to check for.\\n   * @return A boolean indicating if the caller has the specified role.\\n   */\\n  function isRole(Role role) external override view returns (bool) {\\n    return _isRole(role);\\n  }\\n\\n  /**\\n   * @notice External view function to check the account currently holding the\\n   * given role.\\n   * @param role The desired role to fetch the current address of.\\n   * @return The address of the requested role, or the null\\n   * address if none is set.\\n   */\\n  function getRoleAddress(Role role) external override view returns (address) {\\n    require(\\n      _roles[uint256(role)].account != address(0),\\n      \\\"EndaomentAdmin: Role bearer is null address.\\\"\\n    );\\n    return _roles[uint256(role)].account;\\n  }\\n\\n  /**\\n   * @notice Private function to set a new account on a given role and emit a\\n   * `RoleModified` event if the role holder has changed.\\n   * @param role The role that the account will be set for.\\n   * @param account The account to set as the designated role bearer.\\n   */\\n  function _setRole(Role role, address account) private {\\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\\n\\n    if (account != storedRoleStatus.account) {\\n      storedRoleStatus.account = account;\\n      emit RoleModified(role, account);\\n    }\\n  }\\n\\n  /**\\n   * @notice Private view function to check whether the caller is the current\\n   * role holder.\\n   * @param role The role to check for.\\n   * @return A boolean indicating if the caller has the specified role.\\n   */\\n  function _isRole(Role role) private view returns (bool) {\\n    return msg.sender == _roles[uint256(role)].account;\\n  }\\n\\n  /**\\n   * @notice Private view function to check whether the given role is paused or\\n   * not.\\n   * @param role The role to check for.\\n   * @return A boolean indicating if the specified role is paused or not.\\n   */\\n  function _isPaused(Role role) private view returns (bool) {\\n    return _roles[uint256(role)].paused;\\n  }\\n\\n  /**\\n   * @notice Modifier that throws if called by any account other than the owner\\n   * or the supplied role, or if the caller is not the owner and the role in\\n   * question is paused.\\n   * @param role The role to require unless the caller is the owner.\\n   */\\n  modifier onlyAdminOr(Role role) {\\n    if (!isOwner()) {\\n      require(_isRole(role), \\\"EndaomentAdmin: Caller does not have a required role.\\\");\\n      require(!_isPaused(role), \\\"EndaomentAdmin: Role in question is currently paused.\\\");\\n    }\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEndaomentAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD 3-Clause\\n\\npragma solidity ^0.6.10;\\n\\n/**\\n * @dev Interface of the EndaomentAdmin contract\\n */\\ninterface IEndaomentAdmin {\\n  event RoleModified(Role indexed role, address account);\\n  event RolePaused(Role indexed role);\\n  event RoleUnpaused(Role indexed role);\\n\\n  enum Role {\\n    EMPTY,\\n    PAUSER,\\n    ACCOUNTANT,\\n    REVIEWER,\\n    FUND_FACTORY,\\n    ORG_FACTORY,\\n    ADMIN\\n  }\\n\\n  struct RoleStatus {\\n    address account;\\n    bool paused;\\n  }\\n\\n  function setRole(Role role, address account) external;\\n\\n  function removeRole(Role role) external;\\n\\n  function pause(Role role) external;\\n\\n  function unpause(Role role) external;\\n\\n  function isPaused(Role role) external view returns (bool);\\n\\n  function isRole(Role role) external view returns (bool);\\n\\n  function getRoleAddress(Role role) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/OrgFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD 3-Clause\\n\\npragma solidity ^0.6.10;\\n\\nimport \\\"./EndaomentAdminStorage.sol\\\";\\nimport \\\"./Org.sol\\\";\\nimport \\\"./ProxyFactory.sol\\\";\\n\\n//ORG FACTORY CONTRACT\\n/**\\n * @title OrgFactory\\n * @author rheeger\\n * @notice OrgFactory is a contract that allows the EndaomentAdmin to\\n * instantiate new Org contracts. It also provides for fetching of\\n * individual Org contract addresses as well as a list of all\\n * allowedOrgs.\\n */\\ncontract OrgFactory is ProxyFactory, EndaomentAdminStorage {\\n  // ========== EVENTS===================\\n\\n  event OrgCreated(address indexed newAddress);\\n  event OrgStatusChanged(address indexed orgAddress, bool indexed isAllowed);\\n  event OrgLogicDeployed(address logicAddress);\\n\\n  // ========== STATE VARIABLES==========\\n\\n  mapping(address => bool) public allowedOrgs;\\n  address public immutable orgLogic; // logic template for all Org contracts\\n\\n  // ========== CONSTRUCTOR ==========\\n  /**\\n   * @notice Creates new Org Factory and emits a `EndaomentAdminChanged` event\\n   * @param adminContractAddress Address of EndaomentAdmin contract.\\n   */\\n  constructor(address adminContractAddress) public {\\n    // Set endaoment admin\\n    require(adminContractAddress != address(0), \\\"OrgFactory: Admin cannot be the zero address\\\");\\n    endaomentAdmin = adminContractAddress;\\n    emit EndaomentAdminChanged(address(0), adminContractAddress);\\n\\n    // Deploy and initialize Org logic contract (used to deploy minimal proxies in createOrg)\\n    // We set the EIN to 999999999, since it is unlikely to be a real EIN. Even if it is a real\\n    // EIN, that is ok because (1) there is no check against duplicate EINs, and (2) this instance\\n    // is not used as anything other than a logic template, so the EIN value doesn't matter\\n    Org orgLogicContract = new Org();\\n    orgLogicContract.initializeOrg(999999999, address(this));\\n\\n    // Save off address so we can reference for all future deployments\\n    orgLogic = address(orgLogicContract);\\n    emit OrgLogicDeployed(address(orgLogicContract));\\n  }\\n\\n  // ========== Org Creation & Management ==========\\n  /**\\n   * @notice Creates new Org Contract and emits a `OrgCreated` event\\n   * @param ein The U.S. Tax Identification Number for the Organization\\n   */\\n  function createOrg(uint256 ein)\\n    public\\n    onlyAdminOrRole(endaomentAdmin, IEndaomentAdmin.Role.ACCOUNTANT)\\n  {\\n    require(ein >= 10000000 && ein <= 999999999, \\\"Org: Must provide a valid EIN\\\");\\n    bytes memory payload = abi.encodeWithSignature(\\n      \\\"initializeOrg(uint256,address)\\\",\\n      ein,\\n      address(this)\\n    );\\n    address newOrg = deployMinimal(orgLogic, payload);\\n\\n    allowedOrgs[newOrg] = true;\\n    emit OrgCreated(newOrg);\\n  }\\n\\n  /**\\n   * @notice Toggles whether Org is allowed and emits a `OrgStatusChanged` event\\n   * @param orgAddress THe address of the Org contract.\\n   */\\n  function toggleOrg(address orgAddress)\\n    public\\n    onlyAdminOrRole(endaomentAdmin, IEndaomentAdmin.Role.REVIEWER)\\n  {\\n    require(Org(orgAddress).taxId() != 0, \\\"OrgFactory: Not a valid org.\\\");\\n    allowedOrgs[orgAddress] = !allowedOrgs[orgAddress];\\n    emit OrgStatusChanged(orgAddress, allowedOrgs[orgAddress]);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD 3-Clause\\n\\npragma solidity ^0.6.10;\\n\\ninterface IFactory {\\n  function endaomentAdmin() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/upgrades/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/Org.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD 3-Clause\\n\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Administratable.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\n//ORG CONTRACT\\n/**\\n * @title Org\\n * @author rheeger\\n * @notice Org is a contract that serves as a smart wallet for US nonprofit\\n * organizations. It holds the organization's federal Tax ID number as taxID,\\n * and allows for an address to submit a Claim struct to the contract whereby\\n * the organization can directly receive grant awards from Endaoment Funds.\\n */\\ncontract Org is Initializable, Administratable {\\n  using SafeERC20 for IERC20;\\n\\n  // ========== STRUCTS & EVENTS ==========\\n\\n  struct Claim {\\n    string firstName;\\n    string lastName;\\n    string eMail;\\n    address desiredWallet;\\n  }\\n  event CashOutComplete(uint256 cashOutAmount);\\n  event ClaimCreated(string claimId, Claim claim);\\n  event ClaimApproved(string claimId, Claim claim);\\n  event ClaimRejected(string claimId, Claim claim);\\n\\n  // ========== STATE VARIABLES ==========\\n\\n  IFactory public orgFactoryContract;\\n  uint256 public taxId;\\n  mapping(string => Claim) public pendingClaims; // claim UUID to Claim\\n  Claim public activeClaim;\\n\\n  // ========== CONSTRUCTOR ==========\\n\\n  /**\\n   * @notice Create new Organization Contract\\n   * @dev Using initializer instead of constructor for minimal proxy support. This function\\n   * can only be called once in the contract's lifetime\\n   * @param ein The U.S. Tax Identification Number for the Organization\\n   * @param orgFactory Address of the Factory contract.\\n   */\\n  function initializeOrg(uint256 ein, address orgFactory) public initializer {\\n    require(orgFactory != address(0), \\\"Org: Factory cannot be null address.\\\");\\n    taxId = ein;\\n    orgFactoryContract = IFactory(orgFactory);\\n  }\\n\\n  // ========== Org Management & Info ==========\\n\\n  /**\\n   * @notice Creates Organization Claim and emits a `ClaimCreated` event\\n   * @param  claimId UUID representing this claim\\n   * @param  fName First name of Administrator\\n   * @param  lName Last name of Administrator\\n   * @param  eMail Email contact for Organization Administrator.\\n   * @param  orgAdminWalletAddress Wallet address of Organization's Administrator.\\n   */\\n  function claimRequest(\\n    string calldata claimId,\\n    string calldata fName,\\n    string calldata lName,\\n    string calldata eMail,\\n    address orgAdminWalletAddress\\n  ) public {\\n    require(!isEqual(claimId, \\\"\\\"), \\\"Org: Must provide claimId\\\");\\n    require(!isEqual(fName, \\\"\\\"), \\\"Org: Must provide the first name of the administrator\\\");\\n    require(!isEqual(lName, \\\"\\\"), \\\"Org: Must provide the last name of the administrator\\\");\\n    require(!isEqual(eMail, \\\"\\\"), \\\"Org: Must provide the email address of the administrator\\\");\\n    require(orgAdminWalletAddress != address(0), \\\"Org: Wallet address cannot be the zero address\\\");\\n    require(\\n      pendingClaims[claimId].desiredWallet == address(0),\\n      \\\"Org: Pending Claim with Id already exists\\\"\\n    );\\n\\n    Claim memory newClaim = Claim({\\n      firstName: fName,\\n      lastName: lName,\\n      eMail: eMail,\\n      desiredWallet: orgAdminWalletAddress\\n    });\\n\\n    emit ClaimCreated(claimId, newClaim);\\n    pendingClaims[claimId] = newClaim;\\n  }\\n\\n  /**\\n   * @notice Approves an Organization Claim and emits a `ClaimApproved` event\\n   * @param claimId UUID of the claim being approved\\n   */\\n  function approveClaim(string calldata claimId)\\n    public\\n    onlyAdminOrRole(orgFactoryContract.endaomentAdmin(), IEndaomentAdmin.Role.REVIEWER)\\n  {\\n    require(!isEqual(claimId, \\\"\\\"), \\\"Fund: Must provide a claimId\\\");\\n    Claim storage claim = pendingClaims[claimId];\\n    require(claim.desiredWallet != address(0), \\\"Org: claim does not exist\\\");\\n    emit ClaimApproved(claimId, claim);\\n    activeClaim = claim;\\n    delete pendingClaims[claimId];\\n  }\\n\\n  /**\\n   * @notice Rejects an Organization Claim and emits a 'ClaimRejected` event\\n   * @param claimId UUID of the claim being rejected\\n   */\\n  function rejectClaim(string calldata claimId)\\n    public\\n    onlyAdminOrRole(orgFactoryContract.endaomentAdmin(), IEndaomentAdmin.Role.REVIEWER)\\n  {\\n    require(!isEqual(claimId, \\\"\\\"), \\\"Fund: Must provide a claimId\\\");\\n    Claim storage claim = pendingClaims[claimId];\\n    require(claim.desiredWallet != address(0), \\\"Org: claim does not exist\\\");\\n\\n    emit ClaimRejected(claimId, claim);\\n\\n    delete pendingClaims[claimId];\\n  }\\n\\n  /**\\n   * @notice Cashes out Organization Contract and emits a `CashOutComplete` event\\n   * @param tokenAddress ERC20 address of desired token withdrawal\\n   */\\n  function cashOutOrg(address tokenAddress)\\n    public\\n    onlyAdminOrRole(orgFactoryContract.endaomentAdmin(), IEndaomentAdmin.Role.ACCOUNTANT)\\n  {\\n    require(tokenAddress != address(0), \\\"Org: Token address cannot be the zero address\\\");\\n    address payoutAddr = orgWallet();\\n    require(payoutAddr != address(0), \\\"Org: Cannot cashout unclaimed Org\\\");\\n\\n    IERC20 tokenContract = IERC20(tokenAddress);\\n    uint256 cashOutAmount = tokenContract.balanceOf(address(this));\\n\\n    tokenContract.safeTransfer(orgWallet(), cashOutAmount);\\n    emit CashOutComplete(cashOutAmount);\\n  }\\n\\n  /**\\n   * @notice Retrieves Token Balance of Org Contract\\n   * @param tokenAddress Address of desired token to query for balance\\n   * @return Balance of conract in token base unit of provided tokenAddress\\n   */\\n  function getTokenBalance(address tokenAddress) external view returns (uint256) {\\n    IERC20 tokenContract = IERC20(tokenAddress);\\n    uint256 balance = tokenContract.balanceOf(address(this));\\n\\n    return balance;\\n  }\\n\\n  /**\\n   * @notice Org Wallet convenience accessor\\n   * @return The wallet specified in the active, approved claim\\n   */\\n  function orgWallet() public view returns (address) {\\n    return activeClaim.desiredWallet;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"EndaomentAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"FundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"logicAddress\",\"type\":\"address\"}],\"name\":\"FundLogicDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"managerAddress\",\"type\":\"address\"}],\"name\":\"createFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"deployMinimal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endaomentAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundLogic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"updateEndaomentAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FundFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"999999","ConstructorArguments":"0000000000000000000000002a108b1810890482fdb3be188616c56dd0170a8e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}