{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y, uint base) internal pure returns (uint z) {\r\n        z = add(mul(x, y), base / 2) / base;\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    /*function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }*/\r\n}\r\n\r\ninterface IDfTokenizedStrategy {\r\n\r\n    function initialize(\r\n        string calldata _tokenName,\r\n        string calldata _tokenSymbol,\r\n        address payable _owner,\r\n        address _issuer,\r\n        bool _onlyWithProfit,\r\n        bool _transferDepositToOwner,\r\n        uint[5] calldata _params,     // extraCoef [0], profitPercent [1], usdcToBuyEth [2], ethType [3], closingType [4]\r\n        bytes calldata _exchangeData\r\n    ) external payable;\r\n\r\n    function strategyToken() external view returns(address);\r\n\r\n    function dfFinanceClose() external view returns(address);\r\n\r\n    function strategy() external view returns (\r\n        uint initialEth,                    // in eth – max more 1.2 mln eth\r\n        uint entryEthPrice,                 // in usd – max more 1.2 mln USD for 1 eth\r\n        uint profitPercent,                 // min profit percent\r\n        bool onlyWithProfit,                // strategy can be closed only with profitPercent profit\r\n        bool transferDepositToOwner,        // deposit will be transferred to the owner after closing the strategy\r\n        uint closingType,                   // strategy closing type\r\n        bool isStrategyClosed               // strategy is closed\r\n    );\r\n\r\n    function migrateStrategies(address[] calldata _dfWallets) external;\r\n\r\n    function collectAndCloseByUser(\r\n        address _dfWallet,\r\n        uint256 _ethForRedeem,\r\n        uint256 _minAmountUsd,\r\n        bool _onlyProfitInUsd,\r\n        bytes calldata _exData\r\n    ) external payable;\r\n\r\n    function exitAfterLiquidation(\r\n        address _dfWallet,\r\n        uint256 _ethForRedeem,\r\n        uint256 _minAmountUsd,\r\n        bytes calldata _exData\r\n    ) external payable;\r\n\r\n    function depositEth(address _dfWallet) external payable;\r\n\r\n}\r\n\r\ninterface IERC20Snapshot {\r\n\r\n    function balanceOfAt(address account, uint256 snapshotId) external view returns (uint256);\r\n\r\n    function totalSupplyAt(uint256 snapshotId) external view returns(uint256);\r\n\r\n    function snapshot() external returns (\r\n        uint256 currentId\r\n    );\r\n\r\n}\r\n\r\ncontract DfTokenizedAdmin is Initializable, DSMath {\r\n\r\n    struct Vote {\r\n        uint32 expireTime;\r\n        MethodType methodType;\r\n        uint64 snapshotId;\r\n\r\n        // params for CLOSE type\r\n        uint80 maxEthForRedeem;\r\n        uint64 minAmountUsd;\r\n        bool onlyProfitInUsd;\r\n\r\n        uint256 tokensVotedFor;\r\n    }\r\n\r\n    enum MethodType {\r\n        CLOSE,\r\n        MIGRATE\r\n    }\r\n\r\n    uint public constant MAX_VOTE_DURATION = 7 days;\r\n\r\n    address public dfTokenizedStrategy;\r\n    address public dfStrategyToken;\r\n\r\n    mapping(uint => Vote) public votes;\r\n    uint public voteCount;\r\n\r\n    // is user voted for voteId (user => voteId)\r\n    mapping(address => mapping(uint => bool)) public isUserVoted;\r\n\r\n    // ** EVENTS **\r\n\r\n    event VoteCreated(\r\n        uint voteId, MethodType methodType, uint expireTime, uint snapshotId\r\n    );\r\n\r\n    // ** MODIFIERS **\r\n\r\n    modifier isActive(uint _voteId) {\r\n        uint expireTime = votes[_voteId].expireTime;\r\n        require(expireTime > 0 && expireTime <= now, \"Voting is not active\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySuccess(uint _voteId) {\r\n        require(isVoteSuccess(_voteId), \"Vote is not success\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCloseCorrect(uint _voteId, uint _ethForRedeem, uint _minAmountUsd, bool _onlyProfitInUsd) {\r\n        Vote memory vote = votes[_voteId];\r\n        require(vote.methodType == MethodType.CLOSE, \"Method Type error\");\r\n        require(vote.maxEthForRedeem >= _ethForRedeem &&\r\n                vote.minAmountUsd <= _minAmountUsd &&\r\n                vote.onlyProfitInUsd == _onlyProfitInUsd, \"Invalid params\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMigrateCorrect(uint _voteId) {\r\n        require(votes[_voteId].methodType == MethodType.MIGRATE, \"Method Type error\");\r\n        _;\r\n    }\r\n\r\n    // ** INITIALIZER **\r\n\r\n    function initialize(address _dfTokenizedStrategy) public initializer {\r\n        dfTokenizedStrategy = _dfTokenizedStrategy;\r\n        dfStrategyToken = IDfTokenizedStrategy(_dfTokenizedStrategy).strategyToken();\r\n    }\r\n\r\n    // ** PUBLIC VIEW functions **\r\n\r\n    function isVoteSuccess(uint _voteId) public view returns (bool) {\r\n        return (getVoteRatio(_voteId) * 100 > 50 * WAD);  // success if more than 50% tokens for method call\r\n    }\r\n\r\n    // get vote for ratio (decimals == 1e18)\r\n    function getVoteRatio(uint _voteId) public view returns (uint ratio) {\r\n        Vote memory vote = votes[_voteId];\r\n\r\n        uint tokensVotedFor = vote.tokensVotedFor;\r\n        uint tokenTotalSupply = IERC20Snapshot(dfStrategyToken).totalSupplyAt(vote.snapshotId);\r\n\r\n        ratio = wdiv(tokensVotedFor, tokenTotalSupply);  // ex. 0.5e18 = 50%\r\n    }\r\n\r\n    // ** PUBLIC VOTE logic functions **\r\n\r\n    function voteFor(uint _voteId) public\r\n        isActive(_voteId)\r\n    {\r\n        address user = msg.sender;\r\n        require(!isUserVoted[user][_voteId], \"User has voted\");\r\n\r\n        Vote memory vote = votes[_voteId];\r\n\r\n        uint userTokenBalance = IERC20Snapshot(dfStrategyToken).balanceOfAt(user, vote.snapshotId);\r\n        require(userTokenBalance > 0, \"User's token balance cannot be zero\");\r\n\r\n        // UPD states\r\n        votes[_voteId].tokensVotedFor = add(vote.tokensVotedFor, userTokenBalance);\r\n        isUserVoted[user][_voteId] = true;\r\n    }\r\n\r\n    function cancelVote(uint _voteId) public\r\n        isActive(_voteId)\r\n    {\r\n        address user = msg.sender;\r\n        require(isUserVoted[user][_voteId], \"User has not voted\");\r\n\r\n        Vote memory vote = votes[_voteId];\r\n\r\n        uint userTokenBalance = IERC20Snapshot(dfStrategyToken).balanceOfAt(user, vote.snapshotId);\r\n        require(userTokenBalance > 0, \"User's token balance cannot be zero\");\r\n\r\n        // UPD states\r\n        votes[_voteId].tokensVotedFor = sub(vote.tokensVotedFor, userTokenBalance);\r\n        isUserVoted[user][_voteId] = false;\r\n    }\r\n\r\n    // ** PUBLIC CREATE VOTE logic functions **\r\n\r\n    function createVoteForClose(\r\n        uint _maxEthForRedeem,\r\n        uint _minAmountUsd,\r\n        bool _onlyProfitInUsd\r\n    ) public returns (\r\n        uint voteId\r\n    ) {\r\n        voteId = _createVote(MethodType.CLOSE, _maxEthForRedeem, _minAmountUsd, _onlyProfitInUsd);\r\n    }\r\n\r\n    function createVoteForMigrate() public returns (\r\n        uint voteId\r\n    ) {\r\n        voteId = _createVote(MethodType.MIGRATE, 0, 0, false);\r\n    }\r\n\r\n    // ** PUBLIC ONLY_CONFIRMED functions **\r\n\r\n    function collectAndCloseByUser(\r\n        uint _voteId,\r\n        address _dfWallet,\r\n        uint256 _ethForRedeem,\r\n        uint256 _minAmountUsd,\r\n        bool _onlyProfitInUsd,\r\n        bytes memory _exData\r\n    ) public payable\r\n        isActive(_voteId)\r\n        onlySuccess(_voteId)\r\n        onlyCloseCorrect(_voteId, _ethForRedeem, _minAmountUsd, _onlyProfitInUsd)\r\n    {\r\n\r\n        IDfTokenizedStrategy(dfTokenizedStrategy)\r\n            .collectAndCloseByUser\r\n            .value(msg.value)\r\n            (\r\n                _dfWallet,\r\n                _ethForRedeem,\r\n                _minAmountUsd,\r\n                _onlyProfitInUsd,\r\n                _exData\r\n            );\r\n\r\n    }\r\n\r\n    function migrateStrategies(\r\n        uint _voteId,\r\n        address[] memory _dfWallets\r\n    ) public\r\n        isActive(_voteId)\r\n        onlySuccess(_voteId)\r\n        onlyMigrateCorrect(_voteId)\r\n    {\r\n        IDfTokenizedStrategy(dfTokenizedStrategy).migrateStrategies(_dfWallets);\r\n    }\r\n\r\n    // ** PUBLIC functions **\r\n\r\n    function exitAfterLiquidation(\r\n        address _dfWallet,\r\n        uint256 _ethForRedeem,\r\n        uint256 _minAmountUsd,\r\n        bytes memory _exData\r\n    ) public payable {\r\n\r\n        IDfTokenizedStrategy(dfTokenizedStrategy)\r\n            .exitAfterLiquidation\r\n            .value(msg.value)\r\n            (\r\n                _dfWallet,\r\n                _ethForRedeem,\r\n                _minAmountUsd,\r\n                _exData\r\n            );\r\n\r\n    }\r\n\r\n    // TODO: add additional token mint logic\r\n    function depositEth(address _dfWallet) public payable {\r\n\r\n        IDfTokenizedStrategy(dfTokenizedStrategy)\r\n            .depositEth\r\n            .value(msg.value)\r\n            (\r\n                _dfWallet\r\n            );\r\n\r\n    }\r\n\r\n    // ** INTERNAL functions **\r\n\r\n    function _createVote(\r\n        MethodType _methodType,\r\n        uint _maxEthForRedeem,\r\n        uint _minAmountUsd,\r\n        bool _onlyProfitInUsd\r\n    ) internal returns (\r\n        uint voteId\r\n    ) {\r\n        voteId = voteCount;\r\n        uint expireTime = now + MAX_VOTE_DURATION;\r\n        uint snapshotId = IERC20Snapshot(dfStrategyToken).snapshot();\r\n\r\n        // UPD states\r\n        votes[voteId] = Vote({\r\n            expireTime: uint32(expireTime),\r\n            methodType: _methodType,\r\n            snapshotId: uint64(snapshotId),\r\n            // params for CLOSE type\r\n            maxEthForRedeem: uint80(_maxEthForRedeem),\r\n            minAmountUsd: uint64(_minAmountUsd),\r\n            onlyProfitInUsd: _onlyProfitInUsd,\r\n            // vote for counter\r\n            tokensVotedFor: 0\r\n        });\r\n        voteCount += 1;     // increment vote counter\r\n\r\n        emit VoteCreated(voteId, _methodType, expireTime, snapshotId);\r\n    }\r\n\r\n    // **FALLBACK function**\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum DfTokenizedAdmin.MethodType\",\"name\":\"methodType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"VoteCreated\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_VOTE_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteId\",\"type\":\"uint256\"}],\"name\":\"cancelVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_dfWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ethForRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountUsd\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_onlyProfitInUsd\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_exData\",\"type\":\"bytes\"}],\"name\":\"collectAndCloseByUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxEthForRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountUsd\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_onlyProfitInUsd\",\"type\":\"bool\"}],\"name\":\"createVoteForClose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createVoteForMigrate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dfWallet\",\"type\":\"address\"}],\"name\":\"depositEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dfStrategyToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dfTokenizedStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dfWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ethForRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountUsd\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_exData\",\"type\":\"bytes\"}],\"name\":\"exitAfterLiquidation\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteId\",\"type\":\"uint256\"}],\"name\":\"getVoteRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dfTokenizedStrategy\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isUserVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteId\",\"type\":\"uint256\"}],\"name\":\"isVoteSuccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_dfWallets\",\"type\":\"address[]\"}],\"name\":\"migrateStrategies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"voteCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteId\",\"type\":\"uint256\"}],\"name\":\"voteFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"votes\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"expireTime\",\"type\":\"uint32\"},{\"internalType\":\"enum DfTokenizedAdmin.MethodType\",\"name\":\"methodType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"snapshotId\",\"type\":\"uint64\"},{\"internalType\":\"uint80\",\"name\":\"maxEthForRedeem\",\"type\":\"uint80\"},{\"internalType\":\"uint64\",\"name\":\"minAmountUsd\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"onlyProfitInUsd\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokensVotedFor\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DfTokenizedAdmin","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://86c86467b72b7d607a3733b20246c2cec8bd9d6876c63e8ce478d40054307130"}]}