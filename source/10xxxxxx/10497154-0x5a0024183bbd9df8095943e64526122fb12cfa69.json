{"status":"1","message":"OK","result":[{"SourceCode":"{\"ApproveAndCallFallback.sol\":{\"content\":\"pragma solidity 0.4.26;\\n\\n\\ninterface ApproveAndCallFallBack {\\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) external;\\n}\\n\"},\"Context.sol\":{\"content\":\"pragma solidity 0.4.26;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"deploy.sol\":{\"content\":\"pragma solidity 0.4.26;\\n\\n\\n// Meridian Network token\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./meridianToken.sol\\\";\\nimport \\\"./staking.sol\\\";\\nimport \\\"./upgrade.sol\\\";\\n\\ncontract DeployMeridian{\\n  Meridian public m;\\n  MeridianStaking public s;\\n  MeridianUpgrade public u;\\n  address public previousToken= 0x896a07e3788983ec52eaf0F9C6F6E031464Ee2CC;\\n\\n  constructor() public{\\n    m = new Meridian();\\n    s = new MeridianStaking(address(m));\\n    u = new MeridianUpgrade(previousToken,address(m));\\n    m.addBurnExempt(address(s));\\n    m.addBurnExempt(address(u));\\n    m.addBurnExempt(msg.sender);\\n    m.addBurnExempt(address(m));\\n    m.addBurnExempt(address(this));\\n    m.addBurnExempt(0x6e347f4D50f0E2F9AD86179e81097eB573920357);\\n    m.addBurnExempt(0xE7D6989D02dB48c4ffC663b0F770125088C2E6e5);\\n    m.addBurnExempt(0xB976bdA4F44Fb9d985b9c5C8c4c5362837dE6949);\\n    m.addBurnExempt(0xDf824317AA0B1CE4c9892b2a70F351b92d5A7236);\\n    m.addBurnExempt(0x6758744932533CF81523B26ef9074121102116D8);\\n    m.addBurnExempt(0xd4dEFDb0F2793a2eb84449a22Bf755eF622C1160);\\n    m.addBurnExempt(0xA1957D7413256464c8a403F2122E8F2b38F6d960);\\n    m.addBurnExempt(0x7C54B3eb8399f4adff273027f3aBdD200fF82F99);\\n    m.addBurnExempt(0x5Beaa2C98C42422C37A3B84D2C49c693351A2042);\\n    m.addBurnExempt(0xEf418EB1Ce666d27cCDd439ef99c62c56CE04971);\\n    m.addBurnExempt(0xf8E1698cDE2A80B1338d076B1cCEb6Af867Fe5f9);\\n    m.addBurnExempt(0xb9dd2dFd981778D3274c0b95d42f3931Ea0b8E51);\\n    m.addBurnExempt(0xBD13322500f95b4D9e046EC0bcc277db46779957);\\n    m.addBurnExempt(0x44F3899e5256B415B2d0525DB7889a655D966d63);\\n    m.addBurnExempt(0x0cE8A35B510FF2dCa82177a2a087aa0b579Daf6a);\\n    m.addBurnExempt(0x82D57DE9380dde5d097672471822CFb5CA4B1126);\\n    m.addBurnExempt(0x6ea1115b94CDf9B27B66Ae7935341BcD355b72d1);\\n    m.addBurnExempt(0xfC9F9e1BD38d49C4372eE303794C4b99Dcf15E6b);\\n    m.addBurnExempt(0xD73E95EDE4251b4B298A2154aA9b55de1A137317);\\n    m.addBurnExempt(0x4297e9755e4Cc10BaE4cEAaec33d4A11b80D0b19);\\n    m.addBurnExempt(0xDF862903b3f126D250019cb4524Ca5d0B593Af9A);\\n    m.addBurnExempt(0x824aDDB051Bb51a958875cf945831a03BC19963C);\\n    m.addBurnExempt(0x44f2D115219596D2F9d122056d609b81a7Fa4Dd6);\\n    m.addBurnExempt(0x53e14efD0c49424CC9F0A10c15Be127BE7d5C601);\\n    m.addBurnExempt(0x677fE73709C75E1a1d8ddD8364E9A1208Ef130F1);\\n    m.addBurnExempt(0xDf824317AA0B1CE4c9892b2a70F351b92d5A7236);\\n    m.addBurnExempt(0x6758744932533CF81523B26ef9074121102116D8);\\n    m.addBurnExempt(0x233dB06cc7aC69333eED55E4b6A6C17A7D589c76);\\n    m.transfer(address(u),10000000 ether);\\n    m.transfer(address(s),5000000 ether);\\n    m.transfer(msg.sender,m.balanceOf(address(this)));\\n    m.transferOwnership(msg.sender);\\n  }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"interface ERC20 {\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address who) external view returns (uint256);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function transfer(address to, uint256 value) external returns (bool);\\n  function approve(address spender, uint256 value) external returns (bool);\\n  function approveAndCall(address spender, uint tokens, bytes data) external returns (bool success);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\\n  function burn(uint256 amount) external;\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"meridianToken.sol\":{\"content\":\"pragma solidity 0.4.26;\\n\\n\\n// Meridian Network token\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ApproveAndCallFallback.sol\\\";\\n\\n\\ncontract Meridian is ERC20, Ownable {\\n  using SafeMath for uint256;\\n\\n  mapping (address =\\u003e uint256) public balances;\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowed;\\n  string public constant name  = \\\"Meridian Network\\\";\\n  string public constant symbol = \\\"LOCK\\\";\\n  uint8 public constant decimals = 18;\\n\\n  uint256 _totalSupply = 15500000 * (10 ** 18);\\n  uint256 public totalBurned = 0;\\n\\n  //nonstandard variables\\n  mapping(address=\\u003ebool) public burnExempt;\\n  uint256 public TOKEN_BURN_RATE = 100; //represents 10%, shows 100 so that it may be adjusted to decimal precision\\n  bool public burnActive=true; //once turned off burn on transfer is permanently disabled\\n  uint256 LOCKED_AMOUNT=500000 * (10 ** 18);\\n  uint256 unlockTime=now + 40 days;\\n\\n  constructor() public Ownable(){\\n    balances[address(this)] = LOCKED_AMOUNT;\\n    uint amountRemaining = _totalSupply.sub(LOCKED_AMOUNT);\\n    balances[msg.sender] = amountRemaining;\\n    emit Transfer(address(0), address(this), LOCKED_AMOUNT);\\n    emit Transfer(address(0), msg.sender, amountRemaining);\\n  }\\n  function addBurnExempt(address addr) public onlyOwner{\\n    burnExempt[addr]=true;\\n  }\\n  function removeBurnExempt(address addr) public onlyOwner{\\n    burnExempt[addr]=false;\\n  }\\n  function permanentlyDisableBurnOnTransfer() public onlyOwner{\\n    burnActive=false;\\n  }\\n  /*\\n    After 2 months team can retrieve locked tokens\\n  */\\n  function retrieveLockedAmount(address to) public onlyOwner{\\n    require(now\\u003eunlockTime);\\n    uint256 toRetrieve = balances[address(this)];\\n    balances[to] = balances[to].add(toRetrieve);\\n    balances[address(this)] = 0;\\n    emit Transfer(address(this), to, toRetrieve);\\n  }\\n\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address user) public view returns (uint256) {\\n    return balances[user];\\n  }\\n\\n  function allowance(address user, address spender) public view returns (uint256) {\\n    return allowed[user][spender];\\n  }\\n\\n  function transfer(address recipient, uint256 value) public returns (bool) {\\n    require(value \\u003c= balances[msg.sender]);\\n    require(recipient != address(0));\\n\\n    uint burnFee;\\n    if((!burnActive)||burnExempt[msg.sender]){\\n      burnFee=0;\\n    }\\n    else{\\n      burnFee=value.mul(TOKEN_BURN_RATE).div(1000);\\n    }\\n    uint256 tokensToTransfer = value.sub(burnFee);\\n\\n    balances[msg.sender] = balances[msg.sender].sub(value);\\n    balances[recipient] = balances[recipient].add(tokensToTransfer);\\n\\n    _totalSupply = _totalSupply.sub(burnFee);\\n    totalBurned = totalBurned.add(burnFee);\\n\\n    emit Transfer(msg.sender, recipient, tokensToTransfer);\\n    if(burnFee\\u003e0){\\n      emit Transfer(msg.sender, address(0), burnFee);\\n    }\\n    return true;\\n  }\\n\\n  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\\n    for (uint256 i = 0; i \\u003c receivers.length; i++) {\\n      transfer(receivers[i], amounts[i]);\\n    }\\n  }\\n\\n  function approve(address spender, uint256 value) public returns (bool) {\\n    require(spender != address(0));\\n    allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  function approveAndCall(address spender, uint256 tokens, bytes data) external returns (bool) {\\n    allowed[msg.sender][spender] = tokens;\\n    emit Approval(msg.sender, spender, tokens);\\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\\n    return true;\\n  }\\n\\n  function transferFrom(address from, address recipient, uint256 value) public returns (bool) {\\n    require(value \\u003c= balances[from]);\\n    require(value \\u003c= allowed[from][msg.sender]);\\n    require(recipient != address(0));\\n\\n    uint burnFee;\\n    if((!burnActive)||burnExempt[from]||burnExempt[msg.sender]){\\n      burnFee=0;\\n    }\\n    else{\\n      burnFee=value.mul(TOKEN_BURN_RATE).div(1000);\\n    }\\n    uint256 tokensToTransfer = value.sub(burnFee);\\n\\n    balances[from] = balances[from].sub(value);\\n    balances[recipient] = balances[recipient].add(tokensToTransfer);\\n\\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\\n\\n    _totalSupply = _totalSupply.sub(burnFee);\\n    totalBurned = totalBurned.add(burnFee);\\n\\n    emit Transfer(from, recipient, tokensToTransfer);\\n    if(burnFee\\u003e0){\\n      emit Transfer(msg.sender, address(0), burnFee);\\n    }\\n\\n    return true;\\n  }\\n\\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n    require(spender != address(0));\\n    allowed[msg.sender][spender] = allowed[msg.sender][spender].add(addedValue);\\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n    require(spender != address(0));\\n    allowed[msg.sender][spender] = allowed[msg.sender][spender].sub(subtractedValue);\\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  function burn(uint256 amount) public {\\n    require(amount != 0);\\n    require(amount \\u003c= balances[msg.sender]);\\n    totalBurned = totalBurned.add(amount);\\n    _totalSupply = _totalSupply.sub(amount);\\n    balances[msg.sender] = balances[msg.sender].sub(amount);\\n    emit Transfer(msg.sender, address(0), amount);\\n  }\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.4.26;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"library SafeMath {\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    require(c / a == b);\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a / b;\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a);\\n    return c;\\n  }\\n\\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\\n    uint256 c = add(a,m);\\n    uint256 d = sub(c,1);\\n    return mul(div(d,m),m);\\n  }\\n}\\n\"},\"SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.4.26;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n        /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 \\u0026\\u0026 b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 \\u0026\\u0026 a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"},\"staking.sol\":{\"content\":\"pragma solidity 0.4.26;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SignedSafeMath.sol\\\";\\nimport \\\"./ApproveAndCallFallback.sol\\\";\\n\\ncontract MeridianInterface is ERC20{\\n  function owner() external returns(address);\\n}\\n\\ncontract MeridianStaking is ApproveAndCallFallBack{\\n  using SafeMath for uint;\\n  using SignedSafeMath for int;\\n  MeridianInterface public meridianToken;\\n  mapping(address =\\u003e uint256) public amountStaked;\\n  mapping(address =\\u003e int256) public payoutsTo;//only represents the portion of payouts from collective dividends\\n  mapping(address =\\u003e uint256) public payoutsToTime;//over time related payouts\\n  mapping(address =\\u003e uint256) public unclaimedDividends;//dividends over time before the last user checkpoint\\n  mapping(address =\\u003e uint256) public dividendCheckpoints;//the time from which to calculate new dividends\\n  mapping(address =\\u003e uint256) public dividendRateUsed;\\n  uint256 public stakedTotalSum;\\n  uint256 public divsPerShare;\\n  uint256 constant internal magnitude = 2 ** 64;\\n  uint256 constant internal STAKING_MINIMUM = 100 * (10 ** 18); //token is 18 decimals\\n  uint256 public STAKING_PERIOD = 1 days; //time period to which the dividend rate refers to\\n  uint256 public BURN_RATE = 100; //10% transaction burns, unstaking burns, div withdraw burns\\n  uint public STAKE_DIV_FEE = 50; //5% stake div fee\\n  uint256 public DIVIDEND_RATE = 10;//1.0%\\n  bool public activated = false;\\n  uint256 public contractEndTime=0;\\n\\n  uint256 public nowTest=now;\\n\\n  event Stake(address indexed user, uint256 amount);\\n\\tevent UnStake(address indexed user, uint256 amount);\\n  event WithdrawDivs(address indexed user, uint256 amount);\\n  event ReStakeDivs(address indexed user, uint256 amount);\\n\\n  modifier isAdmin() {\\n      require(msg.sender==meridianToken.owner(),\\\"user is not admin\\\");\\n      _;\\n  }\\n  modifier isActive() {\\n      require(activated,\\\"staking is not yet active\\\");\\n      _;\\n  }\\n\\n  constructor(address token) public{\\n    meridianToken=MeridianInterface(token);\\n  }\\n  function setRates(uint burn,uint div,uint unstake) public isAdmin{\\n    BURN_RATE=burn;\\n    DIVIDEND_RATE=div;\\n    STAKE_DIV_FEE=unstake;\\n  }\\n  function activateContract() public isAdmin{\\n    activated=true;\\n  }\\n  function burnAfterContractEnd() public isAdmin{\\n    meridianToken.burn(meridianToken.balanceOf(address(this)));\\n  }\\n  function disableDividendAccumulation() public isAdmin{\\n    contractEndTime=now;\\n  }\\n\\n  /*\\n    Used for staking, must send an approveAndCall to the token which will then call this function\\n  */\\n  function receiveApproval(address fromAddr, uint256 tokens, address token, bytes data) external{\\n    require(msg.sender==address(meridianToken));\\n    require(meridianToken.transferFrom(fromAddr,address(this),tokens),\\\"transfer failed\\\");\\n    _stake(tokens,fromAddr);\\n  }\\n  function _stake(uint256 amount,address fromAddr) private isActive{\\n    require(amountStaked[fromAddr].add(amount) \\u003e= STAKING_MINIMUM,\\\"amount below staking minimum\\\");\\n    updateCheckpoint(fromAddr,true);\\n    stakedTotalSum = stakedTotalSum.add(amount);\\n    amountStaked[fromAddr] = amountStaked[fromAddr].add(amount);\\n    payoutsTo[fromAddr] = payoutsTo[fromAddr].add(int256(amount.mul(divsPerShare)));\\n    emit Stake(fromAddr, amount);\\n  }\\n  function unstake(uint256 amount) public isActive{\\n    require(amountStaked[msg.sender] \\u003e= amount);\\n    updateCheckpoint(msg.sender,true);\\n\\n    uint256 divPortion=amount.mul(STAKE_DIV_FEE).div(1000);// dividends to be redistributed to users\\n    uint256 burnPortion=amount.mul(BURN_RATE).div(1000);// tokens to be burned\\n    uint256 unstakeFee = divPortion.add(burnPortion);\\n    divsPerShare = divsPerShare.add(divPortion.mul(magnitude).div(stakedTotalSum)); //portion of fee redistributed as divs, the rest to be burned\\n    stakedTotalSum = stakedTotalSum.sub(amount);\\n    uint256 taxedAmount = amount.sub(unstakeFee);\\n    amountStaked[msg.sender] = amountStaked[msg.sender].sub(amount);\\n    payoutsTo[msg.sender] = payoutsTo[msg.sender].sub(int256(amount.mul(divsPerShare)));\\n    meridianToken.burn(burnPortion);//burn a portion of the fee\\n    meridianToken.transfer(msg.sender,taxedAmount);\\n    emit UnStake(msg.sender, amount);\\n  }\\n  function withdrawDivs() public isActive{\\n    updateCheckpoint(msg.sender,false);\\n    uint256 burnedDivs = getBurnedDivs(msg.sender);\\n    payoutsTo[msg.sender] = payoutsTo[msg.sender].add(int256(burnedDivs.mul(magnitude)));\\n    uint256 timeDivs=getTotalDivsOverTime(msg.sender);\\n    payoutsToTime[msg.sender] = payoutsToTime[msg.sender].add(timeDivs);\\n    uint256 baseDivs=burnedDivs.add(timeDivs);\\n\\n    uint256 burnFee=baseDivs.mul(BURN_RATE).div(1000);\\n    uint256 divs=baseDivs.sub(burnFee);\\n\\n    meridianToken.burn(burnFee);\\n    meridianToken.transfer(msg.sender,divs);\\n    emit WithdrawDivs(msg.sender, divs);\\n  }\\n  function reinvestDivs() public isActive{\\n    updateCheckpoint(msg.sender,false);\\n    uint256 burnedDivs = getBurnedDivs(msg.sender);\\n    payoutsTo[msg.sender] = payoutsTo[msg.sender].add(int256(burnedDivs.mul(magnitude)));\\n    uint256 timeDivs=getTotalDivsOverTime(msg.sender);\\n    payoutsToTime[msg.sender] = payoutsToTime[msg.sender].add(timeDivs);\\n    uint256 divs=burnedDivs.add(timeDivs);\\n    _stake(divs,msg.sender);\\n    emit ReStakeDivs(msg.sender, divs);\\n  }\\n\\n  function getDividends(address user) public view returns(uint256){\\n    return getBurnedDivs(user).add(getTotalDivsOverTime(user));\\n  }\\n  function getBurnedDivs(address user) public view returns(uint256){\\n    if(int256(divsPerShare.mul(amountStaked[user])) \\u003c payoutsTo[user]){\\n      return 0;\\n    }\\n    else{\\n      return uint256(int256(divsPerShare.mul(amountStaked[user])).sub(payoutsTo[user])).div(magnitude);\\n    }\\n  }\\n  function updateCheckpoint(address user,bool updateRate) private{\\n    unclaimedDividends[user]=unclaimedDividends[user].add(getNewDivsOverTime(user));\\n    dividendCheckpoints[user]=getNow();\\n    if(updateRate){\\n      dividendRateUsed[user]=DIVIDEND_RATE;//locks in latest div rate. Done after unclaimedDividends updated, so divs from before this operation will be at the old rate.\\n    }\\n  }\\n  function getTotalDivsSubWithdrawFee(address user) external view returns(uint256){\\n    uint256 baseDivs=getDividends(user);\\n    uint256 fee=baseDivs.mul(BURN_RATE).div(1000).add(baseDivs.mul(STAKE_DIV_FEE).div(1000));\\n    return baseDivs.sub(fee);\\n  }\\n  //recent divs over time plus previously recorded divs over time\\n  function getTotalDivsOverTime(address user) public view returns(uint256){\\n    return unclaimedDividends[user].add(getNewDivsOverTime(user)).sub(payoutsToTime[user]);\\n  }\\n  //Formula for dividends over time is (time_passed/staking_period)*staked_tokens*dividend_rate\\n  //All divided by 1000 to convert dividend rate to the appropriate units\\n  function getNewDivsOverTime(address user) public view returns(uint256){\\n    return getNow().sub(dividendCheckpoints[user]).mul(amountStaked[user]).mul(dividendRateUsed[user]).div(STAKING_PERIOD.mul(1000));\\n  }\\n  function getNow() public view returns(uint256){\\n      //have \\u0027now\\u0027 be assumed to be the contract end time, if the current time is later than that. This is to prevent accumulation of dividends after this point.\\n      if(contractEndTime\\u003e0 \\u0026\\u0026 now\\u003econtractEndTime){\\n        return contractEndTime;\\n      }\\n      else{\\n        return now;\\n      }\\n\\n  }\\n}\\n\"},\"upgrade.sol\":{\"content\":\"pragma solidity 0.4.26;\\n\\n//Contract for upgrading Meridian Network tokens from MRDN to LOCK\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract MeridianUpgrade{\\n  using SafeMath for uint;\\n\\n  ERC20 public oldToken;\\n  ERC20 public newToken;\\n  constructor(address tokenAddr1,address tokenAddr2) public{\\n    oldToken=ERC20(tokenAddr1);\\n    newToken=ERC20(tokenAddr2);\\n  }\\n  function upgrade(uint amount) public{\\n    //transfer old tokens\\n    oldToken.transferFrom(msg.sender,address(this),amount);\\n    //user recieves tokens at given ratio\\n    newToken.transfer(msg.sender,amount);\\n  }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"m\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"s\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"u\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DeployMeridian","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b5526051faf5795b554c75d7da0871af7e237bf3fe45c7add33dd25045109238"}]}