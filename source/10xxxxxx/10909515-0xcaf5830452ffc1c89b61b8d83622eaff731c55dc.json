{"status":"1","message":"OK","result":[{"SourceCode":"{\"Container.sol\":{\"content\":\"pragma solidity ^0.5.11;\\n\\ncontract Container{\\n    struct Item{\\n        uint256 itemType;\\n        uint256 status;\\n        address[] addresses;\\n    }\\n    uint256 MaxItemAdressNum = 255;\\n\\n    mapping (bytes32 =\\u003e Item) private container;\\n\\n    function itemAddressExists(bytes32 id, address oneAddress) internal view returns(bool){\\n        for(uint256 i = 0; i \\u003c container[id].addresses.length; i++){\\n            if(container[id].addresses[i] == oneAddress)\\n                return true;\\n        }\\n        return false;\\n    }\\n    function getItemAddresses(bytes32 id) internal view returns(address[] memory){\\n        return container[id].addresses;\\n    }\\n\\n    function getItemInfo(bytes32 id) internal view returns(uint256, uint256, uint256){\\n        return (container[id].itemType, container[id].status, container[id].addresses.length);\\n    }\\n\\n    function getItemAddressCount(bytes32 id) internal view returns(uint256){\\n        return container[id].addresses.length;\\n    }\\n\\n    function setItemInfo(bytes32 id, uint256 itemType, uint256 status) internal{\\n        container[id].itemType = itemType;\\n        container[id].status = status;\\n    }\\n\\n    function addItemAddress(bytes32 id, address oneAddress) internal{\\n        require(!itemAddressExists(id, oneAddress), \\\"dup address added\\\");\\n        require(container[id].addresses.length \\u003c MaxItemAdressNum, \\\"too many addresses\\\");\\n        container[id].addresses.push(oneAddress);\\n    }\\n    function removeItemAddresses(bytes32 id) internal{\\n        container[id].addresses.length = 0;\\n    }\\n\\n    function removeOneItemAddress(bytes32 id, address oneAddress) internal{\\n        for(uint256 i = 0; i \\u003c container[id].addresses.length; i++){\\n            if(container[id].addresses[i] == oneAddress){\\n                container[id].addresses[i] = container[id].addresses[container[id].addresses.length - 1];\\n                container[id].addresses.length--;\\n                return;\\n            }\\n        }\\n        revert(\\\"not exist address\\\");\\n    }\\n\\n    function removeItem(bytes32 id) internal{\\n        delete container[id];\\n    }\\n\\n    function replaceItemAddress(bytes32 id, address oneAddress, address anotherAddress) internal{\\n        require(!itemAddressExists(id,anotherAddress),\\\"dup address added\\\");\\n        for(uint256 i = 0; i \\u003c container[id].addresses.length; i++){\\n            if(container[id].addresses[i] == oneAddress){\\n                container[id].addresses[i] = anotherAddress;\\n                return;\\n            }\\n        }\\n        revert(\\\"not exist address\\\");\\n    }\\n}\"},\"HBCHStorage.sol\":{\"content\":\"pragma solidity ^0.5.11;\\n\\nimport \\\"./Container.sol\\\";\\n\\ncontract HBCHStorage is Container{\\n\\n    string public constant name = \\\"HBCHStorage\\\";\\n\\n    address private caller;\\n\\n    constructor(address aCaller) public{\\n        totalSupply = 0;\\n        caller = aCaller;\\n    }\\n    uint256 public totalSupply;\\n\\n    mapping (address =\\u003e uint256) private balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private allowed;\\n\\n    function supporterExists(bytes32 taskHash, address user) public view returns(bool){\\n        return itemAddressExists(taskHash, user);\\n    }\\n\\n    function setTaskInfo(bytes32 taskHash, uint256 taskType, uint256 status) external onlyCaller{\\n        setItemInfo(taskHash, taskType, status);\\n    }\\n\\n    function getTaskInfo(bytes32 taskHash) public view returns(uint256, uint256, uint256){\\n        return getItemInfo(taskHash);\\n    }\\n\\n    function addSupporter(bytes32 taskHash, address oneAddress) external onlyCaller{\\n        addItemAddress(taskHash, oneAddress);\\n    }\\n\\n    function removeAllSupporter(bytes32 taskHash) external onlyCaller{\\n        removeItemAddresses(taskHash);\\n    }\\n\\n    modifier onlyCaller() {\\n        require(msg.sender == caller, \\\"only use main main contract to call\\\");\\n        _;\\n    }\\n\\n    function getTotalSupply() external view returns(uint256) {\\n        return totalSupply;\\n    }\\n\\n    function setTotalSupply(uint256 amount) external onlyCaller {\\n        totalSupply = amount;\\n    }\\n\\n    function balanceOf(address account) external view returns(uint256) {\\n        return balances[account];\\n    }\\n\\n    function setBalance(address account,uint256 amount) external onlyCaller {\\n        require(account != address(0),\\\"account address error\\\");\\n        balances[account] = amount;\\n    }\\n\\n    function getAllowed(address owner,address spender) external view returns(uint256) {\\n        return allowed[owner][spender];\\n    }\\n\\n    function setAllowed(address owner,address spender,uint256 amount) external onlyCaller {\\n        require(owner != address(0),\\\"owner address error\\\");\\n        require(spender != address(0),\\\"spender address error\\\");\\n        require(amount \\u003c= balances[owner], \\\"owner balance need \\u003e= amount\\\");\\n        allowed[owner][spender] = amount;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aCaller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"oneAddress\",\"type\":\"address\"}],\"name\":\"addSupporter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"getAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"}],\"name\":\"getTaskInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"}],\"name\":\"removeAllSupporter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"taskType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"setTaskInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTotalSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"supporterExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"HBCHStorage","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003bb8819b18d54f499aa6815c724b6b33a7a01403","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8caa285c0527cf84b0966f50b66703f4c939f904a2ea20254be5f53f50d9f976"}]}