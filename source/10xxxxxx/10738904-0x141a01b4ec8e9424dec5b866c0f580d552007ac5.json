{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-08-26\r\n*/\r\n\r\n// File: contracts/LiteSig.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * LiteSig is a lighter weight multisig based on https://github.com/christianlundkvist/simple-multisig\r\n * Owners aggregate signatures offline and then broadcast a transaction with the required number of signatures.\r\n * Unlike other multisigs, this is meant to have minimal administration functions and other features in order\r\n * to reduce the footprint and attack surface.\r\n */\r\ncontract LiteSig {\r\n\r\n    //  Events triggered for incoming and outgoing transactions\r\n    event Deposit(address indexed source, uint value);\r\n    event Execution(uint indexed transactionId, address indexed destination, uint value, bytes data);\r\n    event ExecutionFailure(uint indexed transactionId, address indexed destination, uint value, bytes data);\r\n\r\n    // List of owner addresses - for external readers convenience only\r\n    address[] public owners;\r\n\r\n    // Mapping of owner address to keep track for lookups\r\n    mapping(address => bool) ownersMap;\r\n\r\n    // Nonce increments by one on each broadcast transaction to prevent replays\r\n    uint public nonce = 0;\r\n\r\n    // Number of required signatures from the list of owners\r\n    uint public requiredSignatures = 0;\r\n\r\n    // EIP712 Precomputed hashes:\r\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\")\r\n    bytes32 constant EIP712DOMAINTYPE_HASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\r\n\r\n    // keccak256(\"LiteSig\")\r\n    bytes32 constant NAME_HASH = 0x3308695f49e3f28122810c848e1569a04488ca4f6a11835568450d7a38a86120;\r\n\r\n    // keccak256(\"1\")\r\n    bytes32 constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\r\n\r\n    // keccak256(\"MultiSigTransaction(address destination,uint256 value,bytes data,uint256 nonce,address txOrigin)\")\r\n    bytes32 constant TXTYPE_HASH = 0x81336c6b66e18c614f29c0c96edcbcbc5f8e9221f35377412f0ea5d6f428918e;\r\n\r\n    // keccak256(\"TOKENSOFT\")\r\n    bytes32 constant SALT = 0x9c360831104e550f13ec032699c5f1d7f17190a31cdaf5c83945a04dfd319eea;\r\n\r\n    // Hash for EIP712, computed from data and contract address - ensures it can't be replayed against\r\n    // other contracts or chains\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n\r\n    // Track init state\r\n    bool initialized = false;\r\n\r\n    // The init function inputs a list of owners and the number of signatures that\r\n    //   are required before a transaction is executed.\r\n    // Owners list must be in ascending address order.\r\n    // Required sigs must be greater than 0 and less than or equal to number of owners.\r\n    // Chain ID prevents replay across chains\r\n    // This function can only be run one time\r\n    function init(address[] memory _owners, uint _requiredSignatures, uint chainId) public {\r\n        // Verify it can't be initialized again\r\n        require(!initialized, \"Init function can only be run once\");\r\n        initialized = true;\r\n\r\n        // Verify the lengths of values being passed in\r\n        require(_owners.length > 0 && _owners.length <= 10, \"Owners List min is 1 and max is 10\");\r\n        require(\r\n            _requiredSignatures > 0 && _requiredSignatures <= _owners.length,\r\n            \"Required signatures must be in the proper range\"\r\n        );\r\n\r\n        // Verify the owners list is valid and in order\r\n        // No 0 addresses or duplicates\r\n        address lastAdd = address(0);\r\n        for (uint i = 0; i < _owners.length; i++) {\r\n            require(_owners[i] > lastAdd, \"Owner addresses must be unique and in order\");\r\n            ownersMap[_owners[i]] = true;\r\n            lastAdd = _owners[i];\r\n        }\r\n\r\n        // Save off owner list and required sig.\r\n        owners = _owners;\r\n        requiredSignatures = _requiredSignatures;\r\n\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(EIP712DOMAINTYPE_HASH,\r\n            NAME_HASH,\r\n            VERSION_HASH,\r\n            chainId,\r\n            address(this),\r\n            SALT)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * This function is adapted from the OpenZeppelin libarary but instead of passing in bytes\r\n     * array, it already has the sig fields broken down.\r\n     *\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * (.note) This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * (.warning) `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise)\r\n     * be too long), and then calling `toEthSignedMessageHash` on it.\r\n     */\r\n    function safeRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * Once the owners of the multisig have signed across the payload, they can submit it to this function.\r\n     * This will verify enough signatures were aggregated and then broadcast the transaction.\r\n     * It can be used to send ETH or trigger a function call against another address (or both).\r\n     *\r\n     * Signatures must be in the correct ascending order (according to associated addresses)\r\n     */\r\n    function submit(\r\n        uint8[] memory sigV,\r\n        bytes32[] memory sigR,\r\n        bytes32[] memory sigS,\r\n        address destination,\r\n        uint value,\r\n        bytes memory data\r\n    ) public returns (bool)\r\n    {\r\n        // Verify initialized\r\n        require(initialized, \"Initialization must be complete\");\r\n\r\n        // Verify signature lengths\r\n        require(sigR.length == sigS.length && sigR.length == sigV.length, \"Sig arrays not the same lengths\");\r\n        require(sigR.length == requiredSignatures, \"Signatures list is not the expected length\");\r\n\r\n        // EIP712 scheme: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\r\n        // Note that the nonce is always included from the contract state to prevent replay attacks\r\n        // Note that tx.origin is included to ensure only a predetermined account can broadcast\r\n        bytes32 txInputHash = keccak256(abi.encode(TXTYPE_HASH, destination, value, keccak256(data), nonce, tx.origin));\r\n        bytes32 totalHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, txInputHash));\r\n\r\n        // Add in the ETH specific prefix\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, totalHash));\r\n\r\n        // Iterate and verify signatures are from owners\r\n        address lastAdd = address(0); // cannot have address(0) as an owner\r\n        for (uint i = 0; i < requiredSignatures; i++) {\r\n\r\n            // Recover the address from the signature - if anything is wrong, this will return 0\r\n            address recovered = safeRecover(prefixedHash, sigV[i], sigR[i], sigS[i]);\r\n\r\n            // Ensure the signature is from an owner address and there are no duplicates\r\n            // Also verifies error of 0 returned\r\n            require(ownersMap[recovered], \"Signature must be from an owner\");\r\n            require(recovered > lastAdd, \"Signature must be unique\");\r\n            lastAdd = recovered;\r\n        }\r\n\r\n        // Increment the nonce before making external call\r\n        nonce = nonce + 1;\r\n        (bool success, ) = address(destination).call{value: value}(data);\r\n        if(success) {\r\n            emit Execution(nonce, destination, value, data);\r\n        } else {\r\n            emit ExecutionFailure(nonce, destination, value, data);\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    // Allow ETH to be sent to this contract\r\n    receive () external payable {\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/Administratable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/**\r\nThis contract allows a list of administrators to be tracked.  This list can then be enforced\r\non functions with administrative permissions.  Only the owner of the contract should be allowed\r\nto modify the administrator list.\r\n */\r\ncontract Administratable is Ownable {\r\n\r\n    // The mapping to track administrator accounts - true is reserved for admin addresses.\r\n    mapping (address => bool) public administrators;\r\n\r\n    // Events to allow tracking add/remove.\r\n    event AdminAdded(address indexed addedAdmin, address indexed addedBy);\r\n    event AdminRemoved(address indexed removedAdmin, address indexed removedBy);\r\n\r\n    /**\r\n    Function modifier to enforce administrative permissions.\r\n     */\r\n    modifier onlyAdministrator() {\r\n        require(isAdministrator(msg.sender), \"Calling account is not an administrator.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    Determine if the message sender is in the administrators list.\r\n     */\r\n    function isAdministrator(address addressToTest) public view returns (bool) {\r\n        return administrators[addressToTest];\r\n    }\r\n\r\n    /**\r\n    Add an admin to the list.  This should only be callable by the owner of the contract.\r\n     */\r\n    function addAdmin(address adminToAdd) public onlyOwner {\r\n        // Verify the account is not already an admin\r\n        require(administrators[adminToAdd] == false, \"Account to be added to admin list is already an admin\");\r\n\r\n        // Set the address mapping to true to indicate it is an administrator account.\r\n        administrators[adminToAdd] = true;\r\n\r\n        // Emit the event for any watchers.\r\n        emit AdminAdded(adminToAdd, msg.sender);\r\n    }\r\n\r\n    /**\r\n    Remove an admin from the list.  This should only be callable by the owner of the contract.\r\n     */\r\n    function removeAdmin(address adminToRemove) public onlyOwner {\r\n        // Verify the account is an admin\r\n        require(administrators[adminToRemove] == true, \"Account to be removed from admin list is not already an admin\");\r\n\r\n        // Set the address mapping to false to indicate it is NOT an administrator account.\r\n        administrators[adminToRemove] = false;\r\n\r\n        // Emit the event for any watchers.\r\n        emit AdminRemoved(adminToRemove, msg.sender);\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ncontract Proxy {\r\n    \r\n    // Code position in storage is:\r\n    // keccak256(\"PROXIABLE\") = \"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\"\r\n    uint256 constant PROXIABLE_SLOT = 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\r\n\r\n    constructor(address contractLogic) public {\r\n        // Verify a valid address was passed in\r\n        require(contractLogic != address(0), \"Contract Logic cannot be 0x0\");\r\n\r\n        // save the code address\r\n        assembly { // solium-disable-line\r\n            sstore(PROXIABLE_SLOT, contractLogic)\r\n        }\r\n    }\r\n\r\n    fallback() external payable {\r\n        assembly { // solium-disable-line\r\n            let contractLogic := sload(PROXIABLE_SLOT)\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0x0, calldatasize())\r\n            let success := delegatecall(gas(), contractLogic, ptr, calldatasize(), 0, 0)\r\n            let retSz := returndatasize()\r\n            returndatacopy(ptr, 0, retSz)\r\n            switch success\r\n            case 0 {\r\n                revert(ptr, retSz)\r\n            }\r\n            default {\r\n                return(ptr, retSz)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/LiteSigFactory.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n/**\r\n * LiteSig Factory creates new instances of the proxy class pointing to the multisig \r\n * contract and triggers an event for listeners to see the new contract.\r\n */\r\ncontract LiteSigFactory is Administratable {\r\n\r\n  // Event to track deployments\r\n  event Deployed(address indexed deployedAddress);\r\n\r\n  // Address where LiteSig logic contract lives\r\n  address public liteSigLogicAddress;\r\n\r\n  // Constructor for the factory\r\n  constructor(address _liteSigLogicAddress) public {\r\n    // Add the deployer as an admin by default\r\n    Administratable.addAdmin(msg.sender);\r\n\r\n    // Save the logic address\r\n    liteSigLogicAddress = _liteSigLogicAddress;\r\n  }\r\n\r\n  /**\r\n   * Function called by external addresses to create a new multisig contract\r\n   * Caller must be whitelisted as an admin - this is to prevent someone from sniping the address\r\n   * (the standard approach to locking in the sender addr into the salt was not chosen in case a long time\r\n   * passes before the contract is created and a new deployment account is required for some unknown reason)\r\n   */\r\n  function createLiteSig(bytes32 salt, address[] memory _owners, uint _requiredSignatures, uint chainId)\r\n    public onlyAdministrator returns (address) {\r\n    // Track the address for the new contract\r\n    address payable deployedAddress;\r\n\r\n    // Get the creation code from the Proxy class\r\n    bytes memory code = type(Proxy).creationCode;\r\n\r\n    // Pack the constructor arg for the proxy initialization\r\n    bytes memory deployCode = abi.encodePacked(code, abi.encode(liteSigLogicAddress));\r\n\r\n    // Drop into assembly to deploy with create2\r\n    assembly {\r\n      deployedAddress := create2(0, add(deployCode, 0x20), mload(deployCode), salt)\r\n      if iszero(extcodesize(deployedAddress)) { revert(0, 0) }\r\n    }\r\n\r\n    // Initialize the contract with this master's address\r\n    LiteSig(deployedAddress).init(_owners, _requiredSignatures, chainId);\r\n\r\n    // Trigger the event for any listeners\r\n    emit Deployed(deployedAddress);\r\n\r\n    // Return address back to caller if applicable\r\n    return deployedAddress;\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_requiredSignatures\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requiredSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"sigV\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"sigR\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"sigS\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LiteSig","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2a3a38d5b60c168bfe42480fa02ffdf96223d9c7382cfad2d17985f0f498c0b3"}]}