{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-08-07\r\n*/\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"sa\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"se\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"me\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/ERC20.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\n\r\ncontract ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    event  Approval(address indexed src, address indexed guy, uint wad);\r\n    event  Transfer(address indexed src, address indexed dst, uint wad);\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    function mint(address guy, uint256 wad) internal {\r\n        balanceOf[guy] = balanceOf[guy].add(wad);\r\n        totalSupply = totalSupply.add(wad);\r\n        emit Transfer(address(0), guy, wad);\r\n    }\r\n\r\n    function approve(address guy, uint wad) external returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        emit Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n        }\r\n\r\n        balanceOf[src] = balanceOf[src].sub(wad);\r\n        balanceOf[dst] = balanceOf[dst].add(wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/WETH.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\ncontract WETH {\r\n    string public name     = \"Wrapped Ether\";\r\n    string public symbol   = \"WETH\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed src, address indexed guy, uint wad);\r\n    event  Transfer(address indexed src, address indexed dst, uint wad);\r\n    event  Deposit(address indexed dst, uint wad);\r\n    event  Withdrawal(address indexed src, uint wad);\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    receive() external payable {\r\n        deposit();\r\n    }\r\n\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf[msg.sender] >= wad, \"not enough\");\r\n        balanceOf[msg.sender] -= wad;\r\n        msg.sender.transfer(wad);\r\n        emit Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        emit Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad, \"little balance\");\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad, \"not allowed\");\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/Auction.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\n\r\n\r\n\r\ncontract Auction {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public immutable FROM_PRICE;\r\n    uint256 public immutable DURATION;\r\n    uint256 public immutable MIN_START;\r\n\r\n    WETH public immutable WRAPPED_ETH;\r\n    ERC20 public immutable HOARD;\r\n\r\n    uint256 public started;\r\n\r\n    uint256 private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1);\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    constructor(\r\n        address _weth,\r\n        uint256 _minWait,\r\n        uint256 _fromPrice,\r\n        uint256 _duration,\r\n        address _hoard\r\n    ) public {\r\n        WRAPPED_ETH = WETH(address(uint160(_weth)));\r\n        MIN_START = block.timestamp + _minWait;\r\n        FROM_PRICE = _fromPrice;\r\n        DURATION = _duration;\r\n        HOARD = ERC20(_hoard);\r\n    }\r\n\r\n    function start() external lock {\r\n        require(block.timestamp > MIN_START, \"wait\");\r\n\r\n        uint256 balance = address(this).balance;\r\n\r\n        require(balance != 0, \"empty\");\r\n        require(started == 0, \"on\");\r\n\r\n        WRAPPED_ETH.deposit.value(balance)();\r\n        started = block.timestamp;\r\n    }\r\n\r\n    function stop() external lock {\r\n        require(started != 0, \"off\");\r\n\r\n        uint256 delta = block.timestamp - started;\r\n        require(delta >= DURATION || WRAPPED_ETH.balanceOf(address(this)) == 0, \"on\");\r\n\r\n        delete started;\r\n    }\r\n\r\n    function price(uint256 offer, uint256 delta) public view returns (uint256) {\r\n        return offer.mul(DURATION.sub(delta)).mul(FROM_PRICE) / (DURATION * 1 ether);\r\n    }\r\n\r\n    function take(uint256 _val) external lock {\r\n        uint256 _started = started;\r\n        require(_started != 0, \"not\");\r\n\r\n        uint256 delta = block.timestamp - _started;\r\n        require(delta < DURATION, \"old\");\r\n\r\n        uint256 balance = WRAPPED_ETH.balanceOf(address(this));\r\n        uint256 offer = balance < _val ? balance : _val;\r\n\r\n        uint256 cost = price(offer, delta);\r\n        require(HOARD.transferFrom(msg.sender, address(1), cost), \"s1e\");\r\n        require(WRAPPED_ETH.transfer(msg.sender, offer), \"s2e\");\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n\r\n// File: contracts/Poof.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\n\r\n\r\n\r\ncontract Poof is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name     = \"Poof.eth\";\r\n    string public constant symbol   = \"POOF\";\r\n    uint8  public constant decimals = 18;\r\n\r\n    event Poof();\r\n    event NotPoof(address _win, uint256 _total);\r\n\r\n    WETH public immutable WRAPPED_ETH;\r\n\r\n    uint256 private constant PERIOD = 1 hours;\r\n    uint256 private constant SLOPE = 256;\r\n\r\n    uint256 private constant BASE = 100;\r\n    uint256 private constant FEE = 10;\r\n\r\n    address public immutable FEE_RECIPIENT_1;\r\n    address public immutable FEE_RECIPIENT_2;\r\n\r\n    uint256 private constant INIT_MIN = 0.1 ether;\r\n    uint256 private constant DUST = 0.00001 ether;\r\n\r\n    uint256 private constant SHIFT_LOOPS = 232;\r\n    uint256 private constant SHIFT_PLAYS = 208;\r\n    uint256 private constant SHIFT_LAST = 160;\r\n\r\n    bytes32 private constant MASK_PLAYS = bytes32((2 ** uint256(24)) - 1);\r\n    bytes32 private constant MASK_LAST = bytes32((2 ** uint256(48)) - 1);\r\n    bytes32 private constant MASK_HEAD = bytes32((2 ** uint256(160)) - 1);\r\n\r\n    bytes32 internal p_data;\r\n\r\n    function sortTokens(address _tokenA, address _tokenB) private pure returns (address token0, address token1) {\r\n        (token0, token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\r\n    }\r\n\r\n    function pairFor(\r\n        address _factory,\r\n        address _tokenA,\r\n        address _tokenB\r\n    ) private pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(_tokenA, _tokenB);\r\n        pair = address(uint256(keccak256(abi.encodePacked(\r\n            hex'ff',\r\n            _factory,\r\n            keccak256(abi.encodePacked(token0, token1)),\r\n            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\r\n        ))));\r\n    }\r\n\r\n    constructor(\r\n        address _factory,\r\n        address _shuf,\r\n        address _weth,\r\n        uint256 _minWait,\r\n        uint256 _fromPrice,\r\n        uint256 _duration\r\n    ) public payable {\r\n        address hoard_1 = pairFor(_factory, _weth, _shuf);\r\n        address hoard_2 = pairFor(_factory, _weth, address(this));\r\n\r\n        FEE_RECIPIENT_1 = address(new Auction(_weth, _minWait, _fromPrice, _duration, hoard_1));\r\n        FEE_RECIPIENT_2 = address(new Auction(_weth, _minWait, _fromPrice, _duration, hoard_2));\r\n\r\n        WRAPPED_ETH = WETH(address(uint160(_weth)));\r\n        setData(address(this), block.timestamp, 0, 1);\r\n    }\r\n\r\n    function getData() public view returns (\r\n        address head,\r\n        uint256 last,\r\n        uint256 plays,\r\n        uint256 loops\r\n    ) {\r\n        bytes32 data = p_data;\r\n\r\n        head = address(uint160(uint256(data & MASK_HEAD)));\r\n        last = uint256((data >> SHIFT_LAST) & MASK_LAST);\r\n        plays = uint256((data >> SHIFT_PLAYS) & MASK_PLAYS);\r\n        loops = uint256(data >> SHIFT_LOOPS);\r\n    }\r\n\r\n    function setData(address _head, uint256 _last, uint256 _plays, uint256 _loops) private {\r\n        p_data = (\r\n            (bytes32(uint256(_head)) & MASK_HEAD) |\r\n            ((bytes32(_last) & MASK_LAST) << SHIFT_LAST) |\r\n            ((bytes32(_plays) & MASK_PLAYS) << SHIFT_PLAYS) |\r\n            (bytes32(_loops) << SHIFT_LOOPS)\r\n        );\r\n    }\r\n\r\n    function costFor(uint256 _plays, uint256 _delta) public pure returns (uint256) {\r\n        uint256 start = INIT_MIN + ((INIT_MIN * _plays) / SLOPE);\r\n        return DUST + ((start * (PERIOD - _delta)) / PERIOD);\r\n    }\r\n\r\n    receive() external payable {\r\n        (\r\n            address head,\r\n            uint256 last,\r\n            uint256 plays,\r\n            uint256 loops\r\n        ) = getData();\r\n\r\n        uint256 delta = block.timestamp.sub(last);\r\n\r\n        if (delta <= PERIOD) {\r\n            uint256 cost = costFor(plays, delta);\r\n            require(msg.value >= cost, \"more (￣﹃￣)\");\r\n\r\n            setData(msg.sender, block.timestamp, plays + 1, loops);\r\n            mint(head, 1 ether / loops);\r\n\r\n            emit Poof();\r\n\r\n            msg.sender.call{ value: msg.value - cost }(\"\");\r\n            return;\r\n        }\r\n\r\n        require(msg.value == 0, \"wait\");\r\n\r\n        uint256 total = address(this).balance;\r\n        uint256 fee = total.mul(FEE) / BASE;\r\n\r\n        (bool success1,) = FEE_RECIPIENT_1.call{ value: fee}(\"\");\r\n        (bool success2,) = FEE_RECIPIENT_2.call{ value: fee}(\"\");\r\n        require(success1 && success2, \"Error sending fees\");\r\n\r\n        emit NotPoof(head, total);\r\n\r\n        setData(address(this), block.timestamp, 0, loops + 1);\r\n\r\n        if (head != address(this)) {\r\n            uint256 send = address(this).balance.sub(fee);\r\n            WRAPPED_ETH.deposit.value(send)();\r\n            WRAPPED_ETH.transfer(head, send);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_shuf\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minWait\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fromPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_win\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"NotPoof\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Poof\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_RECIPIENT_1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_RECIPIENT_2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WRAPPED_ETH\",\"outputs\":[{\"internalType\":\"contract WETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"costFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"head\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"last\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loops\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Poof","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f0000000000000000000000003a9fff453d50d4ac52a6890647b823379ba36b9e000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000004f1a0000000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000000000000000009e3400","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5ed4571544eff9090e3c3d6a3a67eefacfa44ad06e042c18b0b1ffece07337b1"}]}