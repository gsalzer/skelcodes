{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath8 {\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n    uint8 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n    }\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a / b;\r\n        return c;\r\n    }\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        uint8 c = a - b;\r\n        return c;\r\n    }\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mod(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract gameContract {\r\n    function game(uint betMask, uint8 modulo, bytes32 entropy, uint betAmount) public pure returns(uint winAmount, uint256[10] result);\r\n    function getMaxWin(uint betMask, uint8 modulo, uint betAmount) public pure returns(uint maxWin);\r\n}\r\n\r\ncontract DoubleChanceDice is gameContract {\r\n    uint constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\r\n    uint constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\r\n    uint constant POPCNT_MODULO = 0x3F;\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath8 for uint8;\r\n\r\n    function getMaxWin(uint betMask, uint8 modulo, uint betAmount) public pure returns(uint maxWin) {\r\n        require(getBitCount(betMask) == 1);\r\n\r\n        maxWin = betAmount * 18;\r\n    }\r\n\r\n    function game(uint betMask, uint8 modulo, bytes32 entropy, uint betAmount) public pure returns (uint winAmount, uint256[10] result) {\r\n\r\n        require(getBitCount(betMask) == 1);\r\n\r\n        uint256[2] memory dice;\r\n        dice[0] = uint256(entropy).mod(6);\r\n        dice[1] = uint256(keccak256(abi.encodePacked(entropy))).mod(6);\r\n\r\n\r\n        uint8 hit = 0;\r\n        for (uint8 i = 0; i < 2; i++){\r\n            if((2 ** dice[i]) & betMask !=0) {\r\n                hit++;\r\n            }\r\n        }\r\n\r\n        if (hit == 2) {\r\n            winAmount = betAmount.mul(18);\r\n        } else if(hit == 1) {\r\n            winAmount = betAmount.div(10).mul(18);\r\n        } else {\r\n            winAmount = 0;\r\n        }\r\n\r\n        result[0] = dice[0];\r\n        result[1] = dice[1];\r\n    }\r\n    function getBitCount(uint betMask) public pure returns(uint bitCount) {\r\n        bitCount = (betMask.mul(POPCNT_MULT) & POPCNT_MASK).mod(POPCNT_MODULO);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"}],\"name\":\"getBitCount\",\"outputs\":[{\"name\":\"bitCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"getMaxWin\",\"outputs\":[{\"name\":\"maxWin\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"entropy\",\"type\":\"bytes32\"},{\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"game\",\"outputs\":[{\"name\":\"winAmount\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"DoubleChanceDice","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2debf6e6b9d938e09e2f1b7740aeb46b417702a8f1ee1116f44c87a66384e051"}]}