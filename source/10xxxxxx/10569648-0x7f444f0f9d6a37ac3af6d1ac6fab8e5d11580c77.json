{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n██╗     ███████╗██╗  ██╗                         \r\n██║     ██╔════╝╚██╗██╔╝                         \r\n██║     █████╗   ╚███╔╝                          \r\n██║     ██╔══╝   ██╔██╗                          \r\n███████╗███████╗██╔╝ ██╗                         \r\n╚══════╝╚══════╝╚═╝  ╚═╝                         \r\n ██████╗ ██╗   ██╗██╗██╗     ██████╗             \r\n██╔════╝ ██║   ██║██║██║     ██╔══██╗            \r\n██║  ███╗██║   ██║██║██║     ██║  ██║            \r\n██║   ██║██║   ██║██║██║     ██║  ██║            \r\n╚██████╔╝╚██████╔╝██║███████╗██████╔╝            \r\n ╚═════╝  ╚═════╝ ╚═╝╚══════╝╚═════╝             \r\n██╗      ██████╗  ██████╗██╗  ██╗███████╗██████╗ \r\n██║     ██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗\r\n██║     ██║   ██║██║     █████╔╝ █████╗  ██████╔╝\r\n██║     ██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗\r\n███████╗╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║\r\n╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\r\nDEAR MSG.SENDER(S):\r\n\r\n/ LXGL is a project in beta.\r\n// Please audit and use at your own risk.\r\n/// Entry into LXGL shall not create an attorney/client relationship.\r\n//// Likewise, LXGL should not be construed as legal advice or replacement for professional counsel.\r\n///// STEAL THIS C0D3SL4W \r\n\r\n~presented by Open, ESQ || LexDAO LLC\r\n*/\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract Context { // describes current contract execution context (metaTX support) / openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary SafeMath { // wrappers over solidity arithmetic operations with added overflow checks\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Address { // helper for address type / openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\ninterface IERC20 { // brief interface for erc20 token txs\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\nlibrary SafeERC20 { // wrappers around erc20 token txs that throw on failure (when the token contract returns false) / openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n   function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: erc20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IWETH { // brief interface for canonical ether token wrapper contract \r\n    function deposit() payable external;\r\n    \r\n    function transfer(address dst, uint wad) external returns (bool);\r\n}\r\n\r\ncontract LexGuildLocker is Context { // splittable digital deal lockers w/ embedded arbitration tailored for guild raids\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /** <$> LXGL <$> **/\r\n    address public wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // canonical ether token wrapper contract reference\r\n    uint256 public lockerCount;\r\n    mapping(uint256 => Locker) public lockers; \r\n\r\n    struct Locker {  \r\n        address client; \r\n        address[] provider;\r\n        address resolver;\r\n        address token;\r\n        uint8 confirmed;\r\n        uint8 locked;\r\n        uint256[] amount;\r\n        uint256 cap;\r\n        uint256 released;\r\n        uint256 termination;\r\n        bytes32 details; \r\n    }\r\n    \r\n    event RegisterLocker(address indexed client, address[] indexed provider, address indexed resolver, address token, uint256[] amount, uint256 cap, uint256 index, uint256 termination, bytes32 details);\t\r\n    event DepositLocker(uint256 indexed index, uint256 indexed sum);  \r\n    event Release(uint256 indexed index, uint256[] indexed milestone); \r\n    event Withdraw(uint256 indexed index, uint256 indexed remainder);\r\n    event Lock(address indexed sender, uint256 indexed index, bytes32 indexed details);\r\n    event Resolve(address indexed resolver, uint256 indexed clientAward, uint256[] indexed providerAward, uint256 index, uint256 resolutionFee, bytes32 details); \r\n\r\n    /***************\r\n    LOCKER FUNCTIONS\r\n    ***************/\r\n    function registerLocker( // register locker for token deposit and client deal confirmation\r\n        address client,\r\n        address[] calldata provider,\r\n        address resolver,\r\n        address token,\r\n        uint256[] calldata amount, \r\n        uint256 cap,\r\n        uint256 milestones,\r\n        uint256 termination,\r\n        bytes32 details) external returns (uint256) {\r\n        require(provider.length == amount.length, \"provider amount mismatch\");\r\n        \r\n\t    uint256 sum;\r\n        \r\n        for (uint256 i = 0; i < provider.length; i++) {\r\n            sum = sum.add(amount[i]);\r\n        }\r\n        \r\n        require(sum.mul(milestones) == cap, \"deposit milestones mismatch\");\r\n        \r\n        lockerCount = lockerCount + 1;\r\n        uint256 index = lockerCount;\r\n        \r\n        lockers[index] = Locker( \r\n            client, \r\n            provider,\r\n            resolver,\r\n            token,\r\n            0,\r\n            0,\r\n            amount,\r\n            cap,\r\n            0,\r\n            termination,\r\n            details);\r\n        \r\n        emit RegisterLocker(client, provider, resolver, token, amount, cap, index, termination, details); \r\n        return index;\r\n    }\r\n    \r\n    function depositLocker(uint256 index) payable external { // client confirms deposit of cap and locks in deal\r\n        Locker storage locker = lockers[index];\r\n        \r\n        require(locker.confirmed == 0, \"already confirmed\");\r\n        require(_msgSender() == locker.client, \"not locker client\");\r\n        \r\n        uint256 sum = locker.cap;\r\n        \r\n        if (locker.token == wETH && msg.value > 0) {\r\n            require(msg.value == sum, \"insufficient ETH\");\r\n            IWETH(wETH).deposit();\r\n            (bool success, ) = wETH.call.value(msg.value)(\"\");\r\n            require(success, \"transfer failed\");\r\n            IWETH(wETH).transfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(locker.token).safeTransferFrom(msg.sender, address(this), sum);\r\n        }\r\n        \r\n        locker.confirmed = 1;\r\n        \r\n        emit DepositLocker(index, sum); \r\n    }\r\n\r\n    function release(uint256 index) external { // client transfers locker amount(s) (milestone) to provider(s) \r\n    \tLocker storage locker = lockers[index];\r\n\t    \r\n\t    require(locker.locked == 0, \"locker locked\");\r\n\t    require(locker.confirmed == 1, \"locker unconfirmed\");\r\n\t    require(locker.cap > locker.released, \"locker released\");\r\n    \trequire(_msgSender() == locker.client, \"not locker client\"); \r\n        \r\n        uint256[] memory milestone = locker.amount;\r\n        \r\n        for (uint256 i = 0; i < locker.provider.length; i++) {\r\n            IERC20(locker.token).safeTransfer(locker.provider[i], milestone[i]);\r\n            locker.released = locker.released.add(milestone[i]);\r\n        }\r\n\r\n\t    emit Release(index, milestone); \r\n    }\r\n    \r\n    function withdraw(uint256 index) external { // withdraw locker remainder to client if termination time passes and no lock\r\n    \tLocker storage locker = lockers[index];\r\n        \r\n        require(locker.locked == 0, \"locker locked\");\r\n        require(locker.confirmed == 1, \"locker unconfirmed\");\r\n        require(locker.cap > locker.released, \"locker released\");\r\n        require(now > locker.termination, \"termination time pending\");\r\n        \r\n        uint256 remainder = locker.cap.sub(locker.released); \r\n        \r\n        IERC20(locker.token).safeTransfer(locker.client, remainder);\r\n        \r\n        locker.released = locker.released.add(remainder); \r\n        \r\n\t    emit Withdraw(index, remainder); \r\n    }\r\n    \r\n    /************\r\n    ADR FUNCTIONS\r\n    ************/\r\n    function lock(uint256 index, bytes32 details) external { // client or (main) provider can lock remainder for resolution during locker period / update request details\r\n        Locker storage locker = lockers[index]; \r\n        \r\n        require(locker.confirmed == 1, \"locker unconfirmed\");\r\n        require(locker.cap > locker.released, \"locker released\");\r\n        require(now < locker.termination, \"termination time passed\"); \r\n        \r\n        for (uint256 i = 0; i < locker.provider.length; i++) {\r\n            require(_msgSender() == locker.client || _msgSender() == locker.provider[i], \"not locker party\"); \r\n        }\r\n\r\n\t    locker.locked = 1; \r\n\t    \r\n\t    emit Lock(_msgSender(), index, details);\r\n    }\r\n    \r\n    function resolve(uint256 index, uint256 clientAward, uint256[] calldata providerAward, bytes32 details) external { // resolver splits locked deposit remainder between client and (main) provider\r\n        Locker storage locker = lockers[index];\r\n        \r\n        uint256 remainder = locker.cap.sub(locker.released); \r\n\t    uint256 resolutionFee = remainder.div(20); // calculates dispute resolution fee (5% of remainder)\r\n\t    \r\n\t    require(locker.locked == 1, \"locker not locked\"); \r\n\t    require(locker.cap > locker.released, \"cap released\");\r\n\t    require(_msgSender() == locker.resolver, \"not locker resolver\");\r\n\t    require(_msgSender() != locker.client, \"cannot be locker client\");\r\n\t    \r\n\t    for (uint256 i = 0; i < locker.provider.length; i++) {\r\n            require(msg.sender != locker.provider[i], \"cannot be locker provider\");\r\n            require(clientAward.add(providerAward[i]) == remainder.sub(resolutionFee), \"resolution must match remainder\");\r\n            IERC20(locker.token).safeTransfer(locker.provider[i], providerAward[i]);\r\n        }\r\n  \r\n        IERC20(locker.token).safeTransfer(locker.client, clientAward);\r\n        IERC20(locker.token).safeTransfer(locker.resolver, resolutionFee);\r\n\t    \r\n\t    locker.released = locker.released.add(remainder); \r\n\t    \r\n\t    emit Resolve(_msgSender(), clientAward, providerAward, index, resolutionFee, details);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"}],\"name\":\"DepositLocker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"provider\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"RegisterLocker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"milestone\",\"type\":\"uint256[]\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"clientAward\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"providerAward\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolutionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"Resolve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"remainder\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"depositLocker\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"confirmed\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"locked\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"provider\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"milestones\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"registerLocker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"clientAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"providerAward\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"resolve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LexGuildLocker","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9a7702fc9154fc2b9a93124b1d1d467bed489b16738011e5dc80300b560035a6"}]}