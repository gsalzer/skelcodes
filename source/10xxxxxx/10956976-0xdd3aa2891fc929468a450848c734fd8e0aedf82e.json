{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract LockIdGen {\r\n\r\n    uint256 public requestCount;\r\n\r\n    constructor() public {\r\n        requestCount = 0;\r\n    }\r\n\r\n    function generateLockId() internal returns (bytes32 lockId) {\r\n        return keccak256(abi.encodePacked(blockhash(block.number-1), address(this), ++requestCount));\r\n    }\r\n}\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(StandardToken token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(StandardToken token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(StandardToken token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(StandardToken token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(StandardToken token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ManagerUpgradeable is LockIdGen {\r\n\r\n    struct ChangeRequest {\r\n        address proposedNew;\r\n        address proposedClear;\r\n    }\r\n\r\n    // address public custodian;\r\n    mapping (address => address) public managers;\r\n\r\n    mapping (bytes32 => ChangeRequest) public changeReqs;\r\n\r\n    uint256     public    mancount  ;\r\n\r\n    // CONSTRUCTOR\r\n    constructor(\r\n         address  [] memory _mans\r\n    )\r\n      LockIdGen()\r\n      public\r\n    {\r\n        uint256 numMans = _mans.length;\r\n        for (uint256 i = 0; i < numMans; i++) {\r\n          address pto = _mans[i];\r\n          require(pto != address(0));\r\n          managers[pto] = pto;\r\n        }\r\n        mancount = 0;\r\n    }\r\n\r\n\r\n\r\n    modifier onlyManager {\r\n        require(msg.sender == managers[msg.sender],\"onlyManger must use\");\r\n        _;\r\n    }\r\n\r\n    //replace managers\r\n    function replaceManager(address _new,address _clear) public onlyManager {\r\n        require( _clear != address(0) || _new != address(0) );\r\n\r\n        require( _clear == address(0) || managers[_clear] == _clear);\r\n        \r\n        if(_new != address(0))\r\n        {\r\n            managers[_new] = _new;\r\n            mancount = mancount + 1;\r\n        }\r\n\r\n        if(_clear != address(0))\r\n        {\r\n            delete managers[_clear];\r\n            mancount = mancount - 1;\r\n        }\r\n\r\n    }\r\n    \r\n    // for manager change\r\n    function requestChange(address _new,address _clear) public onlyManager returns (bytes32 lockId) {\r\n        require( _clear != address(0) || _new != address(0) );\r\n\r\n        require( _clear == address(0) || managers[_clear] == _clear);\r\n\r\n        lockId = generateLockId();\r\n\r\n        changeReqs[lockId] = ChangeRequest({\r\n            proposedNew: _new,\r\n            proposedClear: _clear\r\n        });\r\n\r\n        emit ChangeRequested(lockId, msg.sender, _new,_clear);\r\n    }\r\n\r\n    event ChangeRequested(\r\n        bytes32 _lockId,\r\n        address _msgSender,\r\n        address _new,\r\n        address _clear\r\n    );\r\n\r\n   function confirmChange(bytes32 _lockId) public onlyManager {\r\n        ChangeRequest storage changeRequest = changeReqs[_lockId];\r\n        require( changeRequest.proposedNew != address(0) || changeRequest.proposedClear != address(0));\r\n\r\n        if(changeRequest.proposedNew != address(0))\r\n        {\r\n            managers[changeRequest.proposedNew] = changeRequest.proposedNew;\r\n            mancount = mancount + 1;\r\n        }\r\n\r\n        if(changeRequest.proposedClear != address(0))\r\n        {\r\n            delete managers[changeRequest.proposedClear];\r\n            mancount = mancount - 1;\r\n        }\r\n\r\n        delete changeReqs[_lockId];\r\n\r\n        emit ChangeConfirmed(_lockId, changeRequest.proposedNew,changeRequest.proposedClear);\r\n    }\r\n    event ChangeConfirmed(bytes32 _lockId, address _newCustodian, address _clearCustodian);\r\n\r\n    function sweepChange(bytes32 _lockId) public onlyManager {\r\n        ChangeRequest storage changeRequest=changeReqs[_lockId];\r\n        require((changeRequest.proposedNew != address(0) || changeRequest.proposedClear != address(0) ));\r\n        delete changeReqs[_lockId];\r\n        emit ChangeSweep(_lockId, msg.sender);\r\n    }\r\n    event ChangeSweep(bytes32 _lockId, address _sender);\r\n    \r\n    function sweeptoken(address tokenaddr,uint256 amount) public onlyManager{\r\n        TransferHelper.safeTransfer(tokenaddr,msg.sender,amount);\r\n    }\r\n    function sweepeth(uint256 amount) public onlyManager{\r\n        msg.sender.transfer(amount);\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n    // events\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // public functions\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address addr) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    // events\r\n    event Approval(address indexed owner, address indexed agent, uint256 value);\r\n\r\n    // public functions\r\n    function allowance(address owner, address agent) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address agent, uint256 value) public returns (bool);\r\n\r\n}\r\n\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  // public variables\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals = 18;\r\n\r\n  // internal variables\r\n  uint256 _totalSupply;\r\n  mapping(address => uint256) _balances;\r\n\r\n  // events\r\n\r\n  // public functions\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address addr) public view returns (uint256 balance) {\r\n    return _balances[addr];\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    require(to != address(0));\r\n    require(value <= _balances[msg.sender]);\r\n\r\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  // internal functions\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n  // public variables\r\n\r\n  // internal variables\r\n  mapping (address => mapping (address => uint256)) _allowances;\r\n\r\n  // events\r\n\r\n  // public functions\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n    require(to != address(0));\r\n    require(value <= _balances[from],\"value lt from\");\r\n    require(value <= _allowances[from][msg.sender],\"value lt _allowances from \");\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\r\n    emit Transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address agent, uint256 value) public returns (bool) {\r\n    _allowances[msg.sender][agent] = value;\r\n    emit Approval(msg.sender, agent, value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address owner, address agent) public view returns (uint256) {\r\n    return _allowances[owner][agent];\r\n  }\r\n\r\n  function increaseApproval(address agent, uint value) public returns (bool) {\r\n    _allowances[msg.sender][agent] = _allowances[msg.sender][agent].add(value);\r\n    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address agent, uint value) public returns (bool) {\r\n    uint allowanceValue = _allowances[msg.sender][agent];\r\n    if (value > allowanceValue) {\r\n      _allowances[msg.sender][agent] = 0;\r\n    } else {\r\n      _allowances[msg.sender][agent] = allowanceValue.sub(value);\r\n    }\r\n    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);\r\n    return true;\r\n  }\r\n  // internal functions\r\n}\r\n\r\n\r\n\r\ncontract MinableToken is StandardToken,ManagerUpgradeable{\r\n    \r\n    \r\n    uint256 maxMined =0;\r\n    constructor(uint256 _maxMined,address [] memory _mans) public ManagerUpgradeable(_mans){\r\n        maxMined = _maxMined;\r\n    }\r\n    \r\n    function _mint(address to, uint256 value) public onlyManager  {\r\n        require(maxMined==0||_totalSupply.add(value)<=maxMined,\"_mint value invalid\");\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) public {\r\n        _balances[from] = _balances[from].sub(value);\r\n        _totalSupply = _totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract DFKII is MinableToken {\r\n  // public variables\r\n  string public name = \"Defiking.finance Version 2.0\";\r\n  string public symbol = \"DFKII\";\r\n  uint8 public decimals = 18;\r\n\r\n  // internal variables\r\n \r\n  // events\r\n\r\n  // public functions\r\n  constructor(address [] memory _mans,uint256 _maxMined) public MinableToken(_maxMined,_mans) {\r\n    //init _totalSupply\r\n    // _totalSupply = 1000*10000 * (10 ** uint256(decimals));\r\n    \r\n    // _balances[msg.sender] = _totalSupply;\r\n    // emit Transfer(address(0x0), msg.sender, _totalSupply);\r\n  }\r\n\r\n  // internal functions\r\n}\r\n\r\ncontract USDT is MinableToken {\r\n  // public variables\r\n  string public name = \"Defiking.finance Version 2.0\";\r\n  string public symbol = \"USDT\";\r\n  uint8 public decimals = 6;\r\n\r\n  // internal variables\r\n \r\n  // events\r\n\r\n  // public functions\r\n  constructor(address [] memory _mans,uint256 _maxMined) public MinableToken(_maxMined,_mans) {\r\n    //init _totalSupply\r\n    // _totalSupply = 1000*10000 * (10 ** uint256(decimals));\r\n    \r\n    // _balances[msg.sender] = _totalSupply;\r\n    // emit Transfer(address(0x0), msg.sender, _totalSupply);\r\n  }\r\n\r\n  // internal functions\r\n}\r\n\r\n\r\ncontract DFK is ManagerUpgradeable {\r\n            \r\n    //liquidity +\r\n    function stakingDeposit(uint256 value) public payable returns (bool);\r\n\r\n    //profit +\r\n    function profit2Staking(uint256 value)public  returns (bool success);\r\n    \r\n    \r\n    function withdrawProfit(address to)public  returns (bool success);\r\n    \r\n    \r\n    function withdrawStaking(address to,uint256 value)public  returns (bool success);\r\n    \r\n    \r\n    function withdrawAll(address to)public  returns (bool success);\r\n\r\n    \r\n    \r\n    function totalMiners() public view returns (uint256);\r\n\r\n    function totalStaking() public view returns (uint256);\r\n\r\n    \r\n    function poolBalance() public view returns (uint256);\r\n\r\n    \r\n    function minedBalance() public view returns (uint256);\r\n\r\n    \r\n    function stakingBalance(address miner) public view returns (uint256);\r\n\r\n\r\n    function profitBalance(address miner) public view returns (uint256);\r\n\r\n    \r\n    \r\n    function pauseStaking()public  returns (bool success);\r\n    \r\n    \r\n    function resumeStaking()public  returns (bool success);\r\n\r\n}\r\n\r\ncontract DFKImplement is DFK {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for StandardToken;\r\n\r\n    int public status; \r\n\r\n    struct StakingLog{\r\n        uint256   staking_time;\r\n        uint256   profit_time;\r\n        uint256   staking_value;\r\n        uint256   unstaking_value; \r\n    }\r\n    mapping(address => StakingLog) public stakings;\r\n\r\n    uint256  public cleanup_time;\r\n\r\n    uint256  public profit_period;\r\n\r\n    uint256  public period_bonus; \r\n\r\n    mapping(address => uint256) public balanceProfit;\r\n    mapping(address => uint256) public balanceStaking;\r\n\r\n    StandardToken    public     dfkToken;\r\n\r\n    uint256 public  _totalMiners;\r\n    uint256 public  _totalStaking; \r\n    uint256 public  totalProfit;\r\n\r\n    uint256 public  minePoolBalance; \r\n\r\n    modifier onStaking {\r\n        require(status == 1,\"please start minner\");\r\n        _;\r\n    }\r\n    event ProfitLog(\r\n        address indexed from,\r\n        uint256 profit_time, \r\n        uint256 staking_value,\r\n        uint256 unstaking_value,\r\n        uint256 profit_times, \r\n        uint256 profit\r\n    );\r\n\r\n    constructor(address _dfkToken,int decimals,address  [] memory _mans) public ManagerUpgradeable(_mans){\r\n        status = 0;\r\n        cleanup_time = now;\r\n        profit_period = 24*3600; \r\n        period_bonus = 100000*(10 ** uint256(decimals));\r\n        cleanup_time = now;\r\n        dfkToken = StandardToken(_dfkToken);\r\n    }\r\n\r\n     \r\n    function addMinePool(uint256 stakevalue) public onStaking payable returns (uint256){\r\n        require(stakevalue>0);\r\n\r\n        // user must call prove first.\r\n        dfkToken.safeTransferFrom(msg.sender,address(this),stakevalue);\r\n\r\n        minePoolBalance = minePoolBalance.add(stakevalue);\r\n\r\n        return minePoolBalance;\r\n    }\r\n\r\n\r\n      \r\n    function stakingDeposit(uint256 stakevalue) public onStaking payable returns (bool){\r\n        require(stakevalue>0,\"stakevalue is gt zero\");\r\n\r\n        // user must call prove first.\r\n        dfkToken.transferFrom(msg.sender,address(this),stakevalue);\r\n\r\n        _totalStaking = _totalStaking.add(stakevalue);\r\n         \r\n        return addMinerStaking(msg.sender,stakevalue);\r\n    }\r\n\r\n\r\n    function addMinerStaking(address miner,uint256 stakevalue) internal  returns (bool){\r\n        balanceStaking[miner] = balanceStaking[miner].add(stakevalue);\r\n        \r\n        StakingLog memory slog=stakings[miner];\r\n\r\n        if(slog.profit_time < cleanup_time){ \r\n            stakings[miner] = StakingLog({\r\n                staking_time:now,\r\n                profit_time:now,\r\n                staking_value:0,\r\n                unstaking_value:stakevalue\r\n            });\r\n            _totalMiners = _totalMiners.add(1);\r\n        }else if(now.sub(slog.profit_time) >= profit_period){ \r\n            uint256   profit_times = now.sub(slog.profit_time).div(profit_period); \r\n            \r\n            stakings[miner] = StakingLog({\r\n                staking_time:now,\r\n                profit_time:now,\r\n                staking_value:slog.staking_value.add(slog.unstaking_value),\r\n                unstaking_value:stakevalue\r\n            });\r\n            \r\n            \r\n            uint256   profit =  period_bonus.mul(stakings[miner].staking_value).mul(profit_times).div(_totalStaking);\r\n            emit ProfitLog(miner,stakings[miner].profit_time,stakings[miner].staking_value,stakings[miner].unstaking_value,profit_times,profit);\r\n            require(minePoolBalance>=profit,\"minePoolBalance lt profit\");\r\n            minePoolBalance = minePoolBalance.sub(profit);\r\n\r\n             \r\n            balanceProfit[miner]=balanceProfit[miner].add(profit);\r\n            totalProfit = totalProfit.add(profit);\r\n\r\n        }else { \r\n            stakings[miner] = StakingLog({\r\n                staking_time:now,\r\n                profit_time:slog.profit_time,\r\n                staking_value:slog.staking_value,\r\n                unstaking_value:slog.unstaking_value.add(stakevalue)\r\n            });\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n     \r\n    function profit2Staking(uint256 value)public onStaking returns (bool success){\r\n        \r\n        require(balanceProfit[msg.sender]>=value);\r\n        balanceProfit[msg.sender] = balanceProfit[msg.sender].sub(value);\r\n        return addMinerStaking(msg.sender,value);\r\n\r\n    }\r\n\r\n     \r\n    function withdrawProfit(address to)public  returns (bool success){\r\n        \r\n        require(to != address(0));\r\n\r\n        addMinerStaking(msg.sender,0);\r\n\r\n        uint256 profit = balanceProfit[msg.sender];\r\n        balanceProfit[msg.sender] = 0;\r\n\r\n        require(dfkToken.transfer(to,profit));\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n     \r\n    function withdrawStaking(address to,uint256 value)public  returns (bool success){\r\n        require(value>0);\r\n        require(to != address(0));\r\n        require(balanceStaking[msg.sender]>=value);\r\n        require(_totalStaking>=value);\r\n        \r\n        _totalStaking=_totalStaking.sub(value);\r\n        \r\n        balanceStaking[msg.sender] = balanceStaking[msg.sender].sub(value);\r\n        StakingLog memory slog=stakings[msg.sender];\r\n        \r\n         \r\n        stakings[msg.sender] = StakingLog({\r\n            staking_time:now,\r\n            profit_time:slog.profit_time,\r\n            staking_value:0,\r\n            unstaking_value:balanceStaking[msg.sender]\r\n        });\r\n        \r\n        require(dfkToken.transfer(to,value));\r\n        \r\n        return true;\r\n    }\r\n\r\n      \r\n    function withdrawAll(address to)public  returns (bool success){\r\n        require(to != address(0));\r\n        \r\n        addMinerStaking(msg.sender,0);\r\n        \r\n        _totalStaking=_totalStaking.sub(balanceStaking[msg.sender]);\r\n        \r\n        uint256 total=balanceStaking[msg.sender].add(balanceProfit[msg.sender]);\r\n\r\n        balanceProfit[msg.sender]=0;\r\n        balanceStaking[msg.sender] = 0;\r\n         \r\n        stakings[msg.sender] = StakingLog({\r\n            staking_time:0,\r\n            profit_time:0,\r\n            staking_value:0,\r\n            unstaking_value:0\r\n        });\r\n        // _totalMiners=_totalMiners.sub(1);\r\n        require(dfkToken.transfer(to,total));\r\n        \r\n        return true;\r\n    }\r\n    \r\n    \r\n    function totalMiners() public view returns (uint256){\r\n        return _totalMiners;\r\n    }\r\n\r\n     \r\n    function totalStaking() public view returns (uint256){\r\n        return _totalStaking;\r\n\r\n    }\r\n     \r\n    function poolBalance() public view returns (uint256){\r\n        return minePoolBalance;\r\n    }\r\n\r\n     \r\n    function minedBalance() public view returns (uint256){\r\n        return totalProfit;\r\n    }\r\n\r\n     \r\n    function stakingBalance(address miner) public view returns (uint256){\r\n        return balanceStaking[miner];\r\n    }\r\n\r\n\r\n     \r\n    function profitBalance(address miner) public view returns (uint256){\r\n        return balanceProfit[miner];\r\n    }\r\n\r\n     \r\n    function pauseStaking()public onlyManager  returns (bool ){\r\n        status = 0;\r\n    }\r\n    \r\n     \r\n    function resumeStaking()public onlyManager returns (bool ){\r\n       status = 1;\r\n    }\r\n}\r\n\r\n\r\ncontract DFKImplHelper{\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    DFKImplement public dfkImpl;\r\n    \r\n    constructor(address _dfkImpl) public{\r\n        dfkImpl = DFKImplement(_dfkImpl);\r\n    }\r\n    \r\n    function calcProfit(address miner) public view returns (uint256)\r\n    {\r\n        (,uint256   profit_time,uint256   staking_value,) = dfkImpl.stakings(miner);\r\n        if(profit_time < dfkImpl.cleanup_time()){ \r\n            return 0;\r\n        }else if(now.sub(profit_time) >= dfkImpl.profit_period()){ \r\n            uint256   profit_times = now.sub(profit_time).div(dfkImpl.profit_period()); \r\n            uint256   profit =  dfkImpl.period_bonus().mul(staking_value).mul(profit_times).div(dfkImpl._totalStaking());\r\n            return profit;\r\n        }else { \r\n            return 0;\r\n        }\r\n        \r\n    }\r\n    \r\n    function calcProfitForFee(address miner,uint256 totalFee,uint256 lastFetchFee) public view returns (uint256)\r\n    {\r\n        (,uint256   profit_time,uint256   staking_value,) = dfkImpl.stakings(miner);\r\n        \r\n        if(staking_value == 0) {\r\n            return 0;\r\n        }\r\n        if(profit_time < dfkImpl.cleanup_time()){ \r\n            return 0;\r\n        }else { \r\n            // uint256   profit_times = now.sub(profit_time).div(dfkImpl.profit_period()); \r\n            uint256   profit =  totalFee.mul(staking_value).div(dfkImpl._totalStaking());\r\n            if(profit>lastFetchFee){\r\n                return profit.sub(lastFetchFee);\r\n            }else{\r\n                return 0;\r\n            }\r\n            \r\n        \r\n        }\r\n        \r\n    }\r\n    \r\n    \r\n}\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\ncontract DTradeLiquids is StandardToken {\r\n  // public variables\r\n  string public name = \"Defiking.finance swap\";\r\n  string public symbol = \"DTrade-V1 LP\";\r\n  uint8 public decimals = 18;\r\n\r\n  // internal variables\r\n \r\n  // events\r\n  address owner;\r\n  // public functions\r\n  constructor() public {\r\n    //init _totalSupply\r\n     owner = msg.sender;\r\n  }\r\n  \r\n  modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n   }\r\n    \r\n  function _mint(address to, uint value) public onlyOwner  {\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) public onlyOwner{\r\n        _balances[from] = _balances[from].sub(value);\r\n        _totalSupply = _totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n  //function initialize(string _symbol) public{\r\n//    symbol = _symbol;\r\n // }\r\n\r\n  // internal functions\r\n}\r\n\r\n\r\ninterface Refers {\r\n    \r\n    function rewards2Super(address user,uint256 totalReward) external returns (bool);\r\n    \r\n}\r\n\r\n\r\ncontract DFKExPair is ManagerUpgradeable{\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n    \r\n    \r\n    address public token0;//usdt,basic token\r\n    address public token1;//dfkii\r\n    \r\n    uint8   public price_decimal = 8;\r\n    uint256 public cur_price  = 0;\r\n    uint    public fee2Liquid = 22;\r\n    uint    public fee2Refs = 3;\r\n    uint    public fee2Burn = 5;\r\n    uint256 public feeTotal=30;\r\n    uint256 public PRICE_MOD=10000;//基数10000\r\n    uint256 public FEE_MOD=10000;//基数10000\r\n    uint256 public TOKEN_DECIMAL_DIF;//基数10000\r\n    uint256 public reserve0 =0;//liquid.token0\r\n    uint256 public reserve1 =0;//liquid.token1\r\n    uint256 public decimal0;//liquid.token0\r\n    uint256 public decimal1;//liquid.token1\r\n    uint256 public fee = 0;\r\n    uint256 public priceFlips = 1;//flips for each 10000 token1\r\n    uint256 public totalProfitForLiquids =0; //fee.for liquid\r\n    uint256 public totalProfitRefs =0; //fee.for dfk1 staking\r\n    uint256 public totalProfitBurn =0; //fee.for burn\r\n    uint256 public totalLiquids = 0;\r\n    // mapping(address => uint256) public profits4DFK1;\r\n    mapping(address => uint256[]) public liquidBonusLog;\r\n    \r\n    address public liquidToken;//\r\n    \r\n    Refers public  refers;\r\n    address public isDfkiiRefs;\r\n    \r\n    uint256 public unlocked = 0;\r\n    uint256 public miniLiquid = 100000*(10 **18);\r\n    modifier onLiquity {\r\n        require(unlocked == 1,\"please wait liquity\");\r\n        _;\r\n    }\r\n    \r\n    function pauseLiquity() public onlyManager  returns (bool ){\r\n        unlocked = 0;\r\n    }\r\n    \r\n     \r\n    function resumeLiquity() public onlyManager returns (bool ){\r\n       unlocked = 1;\r\n    }\r\n    \r\n    constructor(address _token0,address _token1,address refs,uint256 initprice,address []memory _mans,uint256 _miniLiquid) public ManagerUpgradeable(_mans){\r\n    //init _totalSupply\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n        if(_token0 == address(0x0)){\r\n            decimal0 = 10 **18;\r\n        } else {\r\n            decimal0 = 10 **uint256(StandardToken(_token0).decimals());\r\n        }\r\n\r\n        if(_token1 == address(0x0)){\r\n            decimal1 = 10 **18;\r\n        } else {\r\n            decimal1 = 10 **uint256(StandardToken(_token1).decimals());\r\n        }        \r\n        \r\n        cur_price = initprice;\r\n        TOKEN_DECIMAL_DIF = decimal1.div(decimal0);\r\n\r\n        refers = Refers(refs);        \r\n        bytes memory bytecode = type(DTradeLiquids).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n        address _swapV2;\r\n        assembly {\r\n            _swapV2 := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n\r\n        liquidToken = _swapV2;\r\n\t\t\r\n\t\tminiLiquid=_miniLiquid;\r\n        \r\n    } \r\n    \r\n    function setPriceMod(uint256 price_mod) onlyManager public {\r\n        require(price_mod>0);\r\n        PRICE_MOD=price_mod;\r\n    }\r\n    \r\n\r\n    //修正价格，手续费分配比例\r\n    function fixPrice (uint256 price,uint _fee2Liquid,uint _fee2Refs,uint _fee2Burn,uint256 _priceFlips,uint256 _miniLiquid) onlyManager public {\r\n        cur_price = price;\r\n        fee2Liquid = _fee2Liquid;\r\n        fee2Refs = _fee2Refs;\r\n        fee2Burn = _fee2Burn;\r\n        feeTotal = fee2Liquid+fee2Refs+fee2Burn;\r\n        priceFlips = _priceFlips;\r\n        miniLiquid=_miniLiquid;\r\n    }\r\n    \r\n    \r\n    //增加池子流动性\r\n    function poolTokens(uint256 amount0,uint256 amount1) payable onlyManager public {\r\n        if(token0 == address(0x0)){\r\n            require(msg.value>=amount0);\r\n        } else{\r\n            TransferHelper.safeTransferFrom(token0,msg.sender,address(this),amount0);\r\n        }        \r\n\r\n        if(token1 == address(0x0)){\r\n            require(msg.value>=amount1,\"eth not enough\");\r\n        }else{\r\n            TransferHelper.safeTransferFrom(token1,msg.sender,address(this),amount1);\r\n        }   \r\n         \r\n        reserve0 = reserve0.add(amount0);\r\n        reserve1 = reserve1.add(amount1);\r\n    }\r\n    event TotalEvent(\r\n        uint256 totalProfitBurn,\r\n        uint256 totalProfitRefs,\r\n        uint256 totalProfitForLiquids,\r\n        uint256 cur_price,\r\n        uint256 liquidfee,\r\n        uint256 liquidRefs,\r\n        uint256 liquidburn\r\n        );\r\n    event TotalAmount(\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        uint256 avg_price,\r\n        uint256 fee\r\n        );\r\n\r\n    //swap token0 or token1\r\n    function swap(uint256 amount0,uint256 amount1 ,bool toLiquids) payable public returns(uint256,uint256){\r\n        \r\n        require(cur_price>0);\r\n        \r\n        if(amount1>0 && amount0 == 0){//sell token get basic token\r\n            //uint256 price_float = amount1.mul(priceFlips).div(decimal1).div(PRICE_MOD);\r\n            \r\n            // require (ERC20(token1).balanceOf(msg.sender) >= amount1 );\r\n\r\n            uint256 price_float = amount1.mul(priceFlips).div(decimal1);\r\n            require(price_float<cur_price,\"too large amount\");\r\n            uint256 next_price = cur_price.sub(price_float);\r\n            uint256 avg_price = cur_price.add(next_price).div(2);\r\n\r\n            if(token1 == address(0x0)){\r\n                require(msg.value>=amount1);\r\n            }else{\r\n                require (ERC20(token1).balanceOf(msg.sender) >= amount1 );\r\n                TransferHelper.safeTransferFrom(token1,msg.sender,address(this),amount1);\r\n            }  \r\n\r\n            uint256 liquidfee = amount1.mul(fee2Liquid).div(FEE_MOD);\r\n            uint256 liquidRefs = amount1.mul(fee2Refs).div(FEE_MOD);\r\n            uint256 liquidburn = amount1.mul(fee2Burn).div(FEE_MOD);\r\n\r\n            amount1 = amount1.sub(liquidfee).sub(liquidRefs).sub(liquidburn);\r\n            \r\n            if(address(refers)!=address(0x0)){\r\n                TransferHelper.safeTransfer(token1,address(refers),liquidRefs);\r\n                refers.rewards2Super(msg.sender,liquidRefs);\r\n            }\r\n\r\n            totalProfitBurn = totalProfitBurn.add(liquidburn);\r\n            totalProfitRefs = totalProfitRefs.add(liquidRefs);\r\n            totalProfitForLiquids = totalProfitForLiquids.add(liquidfee);\r\n            \r\n            amount0 = amount1.mul(avg_price).div(TOKEN_DECIMAL_DIF).div(PRICE_MOD);\r\n            cur_price = next_price;\r\n            if(toLiquids){\r\n                reserve0 = reserve0.add(amount0);\r\n                reserve1 = reserve1.add(amount1);\r\n            }else{\r\n                if(token0==address(0x0))\r\n                {//eth\r\n                   msg.sender.transfer(amount0);\r\n                }else{\r\n                    TransferHelper.safeTransfer(token0,msg.sender,amount0);\r\n                }\r\n                \r\n            }\r\n        }\r\n        else if(amount0 > 0  && amount1 == 0){//using eth/usdt to buy token1\r\n            if(token0 == address(0x0)) {\r\n                require(msg.value >= amount0 );\r\n            } else {\r\n                require (ERC20(token0).balanceOf(msg.sender) >= amount0  );\r\n                TransferHelper.safeTransferFrom(token0,msg.sender,address(this),amount0);\r\n            }\r\n                        \r\n            amount1 = amount0.mul(PRICE_MOD).div(cur_price);\r\n\r\n            uint256 price_float = amount1.mul(priceFlips).div(decimal0);\r\n            uint256 next_price = cur_price.add(price_float);\r\n\r\n            uint256 avg_price = cur_price.add(next_price).div(2);\r\n            amount1 = amount0.mul(TOKEN_DECIMAL_DIF).mul(PRICE_MOD).div(avg_price);\r\n\r\n            \r\n            uint256 liquidfee = amount1.mul(fee2Liquid).div(FEE_MOD);\r\n            uint256 liquidRefs = amount1.mul(fee2Refs).div(FEE_MOD);\r\n            uint256 liquidburn = amount1.mul(fee2Burn).div(FEE_MOD);\r\n            \r\n            amount1 = amount1.sub(liquidfee).sub(liquidRefs).sub(liquidburn);\r\n            \r\n            if(address(refers)!=address(0x0)){\r\n                TransferHelper.safeTransfer(token1,address(refers),liquidRefs);\r\n                refers.rewards2Super(msg.sender,liquidRefs);\r\n            }\r\n            \r\n            totalProfitBurn = totalProfitBurn.add(liquidburn);\r\n            totalProfitRefs = totalProfitRefs.add(liquidRefs);\r\n            totalProfitForLiquids = totalProfitForLiquids.add(liquidfee);\r\n            cur_price = next_price;\r\n            if(toLiquids){\r\n                reserve0 = reserve0.add(amount0);\r\n                reserve1 = reserve1.add(amount1);\r\n            }else{\r\n                if(token1 == address(0x0)){\r\n                    msg.sender.transfer(amount1);\r\n                }else{\r\n                    TransferHelper.safeTransfer(token1,msg.sender,amount1);\r\n                }       \r\n\r\n            }\r\n\r\n        }\r\n        \r\n        return (amount0,amount1);\r\n    }\r\n    \r\n    \r\n    function addLiquid(uint256 amount0) public onLiquity  payable  returns(uint256) {\r\n\r\n        if(token0 == address(0x0)){\r\n            require (msg.value >= amount0);\r\n        }else{\r\n            require (ERC20(token0).balanceOf(msg.sender) >= amount0  );\r\n            TransferHelper.safeTransferFrom(token0,msg.sender,address(this),amount0.div(2));\r\n        }\r\n\r\n        (,uint256 buyamount1) = swap(amount0.div(2),0,true);\r\n        \r\n        uint256 totalLiquid = reserve1.add(reserve1);\r\n        uint256 poolLiquid = ERC20(address(token1)).balanceOf(address(this));\r\n        if(poolLiquid<miniLiquid){\r\n            poolLiquid=miniLiquid;\r\n        }\r\n\r\n        uint256 mineCoin = buyamount1.add(buyamount1).mul(totalLiquid).div(poolLiquid);\r\n        DTradeLiquids(liquidToken)._mint(msg.sender,mineCoin);\r\n        uint256 leftCoin = amount0.sub(amount0.div(2).mul(2));\r\n        if(leftCoin>0&&token0!=address(0x0)){\r\n            TransferHelper.safeTransferFrom(token0,msg.sender,address(this),leftCoin);\r\n        }\r\n        return mineCoin;\r\n    }\r\n    \r\n    function removeLiquid(uint256 amountL) payable public returns(uint256,uint256) {\r\n        require(DTradeLiquids(liquidToken).balanceOf(msg.sender)>=amountL);\r\n        \r\n        uint256 totalLiquid = reserve1.add(reserve1);\r\n        uint256 amount1 = amountL.mul((ERC20(address(token1)).balanceOf(address(this)))).div(totalLiquid).div(2);\r\n        uint256 amount0 = amount1.mul(cur_price).div(TOKEN_DECIMAL_DIF).div(PRICE_MOD);\r\n        \r\n        require(ERC20(token1).balanceOf(address(this))>=amount1);\r\n        \r\n        reserve1 = reserve1.sub(amount1);\r\n        reserve0 = reserve0.sub(amount0);\r\n        \r\n        DTradeLiquids(liquidToken)._burn(msg.sender,amountL);\r\n        \r\n        if(token0==address(0x0))\r\n        {//eth\r\n            require(address(this).balance>=amount0);\r\n            msg.sender.transfer(amount0);\r\n        }else{\r\n            require(ERC20(token0).balanceOf(address(this))>=amount0);\r\n            TransferHelper.safeTransfer(token0,msg.sender,amount0);\r\n        }\r\n        \r\n        if(token1==address(0x0))\r\n        {//eth\r\n            require(address(this).balance>=amount1);\r\n            msg.sender.transfer(amount1);\r\n        }else{\r\n            require(ERC20(token1).balanceOf(address(this))>=amount1);\r\n            TransferHelper.safeTransfer(token1,msg.sender,amount1);\r\n        }\r\n        \r\n        return (amount0,amount1);\r\n    }  \r\n    \r\n   \r\n}\r\n\r\n\r\ncontract UserRefers is ManagerUpgradeable,Refers{\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n    \r\n    mapping(address => address) public relations;\r\n    mapping(address => address[]) public superiors;\r\n    mapping(address => address) public callers;\r\n    mapping(address => uint256) public rewards;\r\n    \r\n    address public topAddr;\r\n    address public token;\r\n    \r\n    constructor(address _token,address []memory _mans) public ManagerUpgradeable(_mans){\r\n        relations[address(0x0)] = address(0x0);\r\n        topAddr = msg.sender;\r\n        token = _token;\r\n    }\r\n    \r\n    function addCaller(address _newCaller) onlyManager public {\r\n        callers[_newCaller] = _newCaller;\r\n    }\r\n    \r\n    function removeCaller(address rmCaller) onlyManager public {\r\n        callers[rmCaller] = address(0x0);\r\n    }\r\n    \r\n\r\n    function buildSuperoir(address ref,uint256 maxLayer) public {\r\n        if(relations[msg.sender]==address(0x0)) {\r\n            relations[msg.sender] = ref;\r\n            superiors[msg.sender].push(ref);\r\n            address[] memory supers = superiors[ref];\r\n            if(supers.length>0){\r\n                superiors[msg.sender].push(supers[0]);\r\n            }\r\n            uint256 cc = 2;\r\n            for(uint256 i=1;i<supers.length && cc < maxLayer;i++){\r\n                superiors[msg.sender].push(supers[i]);\r\n                cc++;\r\n            }\r\n        }\r\n    }\r\n    function withdrawRewards() public{\r\n        require(rewards[msg.sender]>0);\r\n        TransferHelper.safeTransfer(token,msg.sender,rewards[msg.sender]);\r\n        rewards[msg.sender] = 0;\r\n    }\r\n    // 0.03%分配给邀请人（其中0.01%分配给直接推荐人30%，0.005%分配给间接推荐人,15%,0.015%均分给第3代至第12代）\r\n    function rewards2Super(address user,uint256 totalReward) external returns (bool)\r\n    {\r\n        require(callers[msg.sender]==msg.sender,\"caller is empty\") ;\r\n        // rewards[user] = rewards[user].add(totalReward);\r\n        address[] memory supers = superiors[user];\r\n        uint256 leftReward = totalReward;\r\n        uint256 bonus0;\r\n        uint256 bonus1;\r\n        uint256 bonus2;\r\n        if(supers.length>0){\r\n            uint256 bonus = totalReward.mul(30).div(100);\r\n            rewards[supers[0]] = bonus;\r\n            // TransferHelper.safeTransfer(token,supers[0],bonus);\r\n            leftReward = leftReward.sub(bonus);\r\n            bonus0=bonus;\r\n        }\r\n        if(supers.length>1){\r\n            uint256 bonus = totalReward.mul(15).div(100);\r\n            rewards[supers[1]] = bonus;\r\n            // TransferHelper.safeTransfer(token,supers[1],bonus);\r\n            leftReward = leftReward.sub(bonus);\r\n            bonus1=bonus;\r\n        }\r\n        if(supers.length>2){\r\n            uint256 preReward = leftReward.div(supers.length.sub(2));\r\n        \r\n            for(uint256 i=2;i<supers.length ;i++){\r\n                // TransferHelper.safeTransfer(token,supers[i],preReward);\r\n                rewards[supers[i]] = preReward;\r\n                leftReward = leftReward.sub(preReward);\r\n            }\r\n\r\n            bonus2=preReward;\r\n        }\r\n        if(leftReward>0){\r\n            // TransferHelper.safeTransfer(token,topAddr,leftReward);\r\n            rewards[topAddr] = leftReward;\r\n        }\r\n        return true;\r\n        \r\n    }\r\n    \r\n\r\n}\r\ncontract TestRefs {\r\n    \r\n    \r\n    Refers public refs;\r\n    constructor(address _ref) public {\r\n        refs =  Refers(_ref);\r\n    }\r\n    \r\n    function testReward(uint256 amount) public {\r\n        refs.rewards2Super(msg.sender,amount);\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract DTrade is ManagerUpgradeable{\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n    mapping(address => mapping(address =>uint256 )) public uniswapLiquids;//(liquid.addr=>(user.address=>amount)\r\n\r\n    mapping(address => address) public liquidsMap;\r\n    mapping(address => uint256)public  liquidPools;\r\n\r\n    mapping(address => uint256) public profits4DFK1;\r\n    mapping(address => uint256) public bonusWithdraw;\r\n    mapping(address => uint256) public checkpointHistory;\r\n    \r\n    mapping(address => uint256) public joinTime;\r\n    address [] public liquidPairs;\r\n\r\n    uint256  public  peroid_total_bonus = 90000*(10 **18);\r\n    uint256   public peroid_left_bonus = 0;\r\n    uint256  public bonus_per_block = 9*(10 **18);\r\n    uint256   public bonus_percent_LP = 10;\r\n    \r\n    uint256   public checkpoint_number = 0;    \r\n    // uint256   totalProfitDFK1 = 0;\r\n    \r\n    uint256   public totalLiquids;\r\n\r\n    uint256   public  totalMint;\r\n    DFKImplHelper public dfk1Helper;\r\n    \r\n    uint256   public peroid_mined_coin = 0;\r\n    \r\n    address public token1;\r\n\r\n    uint256 public totalFactor = 0;\r\n\r\n    address public liquidToken;\r\n    \r\n    DFKII   public dfkii;\r\n    \r\n    constructor(address _token1,address []memory _mans) public ManagerUpgradeable(_mans){\r\n        token1 = _token1;\r\n        checkpoint_number = block.number+5*60;\r\n        \r\n        bytes memory bytecode = type(DTradeLiquids).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, token1));\r\n        address _swapV2;\r\n        assembly {\r\n            _swapV2 := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n\r\n        liquidToken = _swapV2;\r\n        \r\n    }\r\n    \r\n    function setDFKII(address _dfkii) public onlyManager {\r\n        dfkii = DFKII(_dfkii);\r\n    }\r\n    \r\n    function setDfk1Helper(address _dfk1Helper) public onlyManager {\r\n        dfk1Helper = DFKImplHelper(_dfk1Helper);\r\n    }\r\n    \r\n    \r\n    function nextPeroid(uint256 total,uint256 perblock,uint256 percentLP) public onlyManager {\r\n               \r\n        totalMint = totalMint.add(peroid_total_bonus);\r\n        peroid_total_bonus = total;\r\n        bonus_per_block = perblock;\r\n        bonus_percent_LP = percentLP;\r\n        peroid_left_bonus = total;\r\n        peroid_mined_coin = 0;\r\n        checkpoint_number = block.number;\r\n        joinTime[address(0x0)] = block.number;\r\n        \r\n    }\r\n    \r\n    function addUniswapPair(address uniAddr,uint256 factor) public onlyManager  {\r\n        if(liquidsMap[uniAddr]==address(0x0)){\r\n            uniswapLiquids[uniAddr][address(0x0)]=factor;\r\n            totalFactor = totalFactor.add(factor);\r\n            // uniswapLiquids[address(0x0)][address(0x0)] = uniswapLiquids[address(0x0)][address(0x0)].add(factor);\r\n            liquidsMap[uniAddr] = uniAddr;\r\n            liquidPairs.push(uniAddr);\r\n\r\n        }\r\n    }\r\n    \r\n    function removeUniswapPair(address uniAddr) public onlyManager  {\r\n        totalFactor = totalFactor.sub(uniswapLiquids[uniAddr][address(0x0)]);\r\n        uniswapLiquids[uniAddr][address(0x0)]=0;\r\n    }\r\n\r\n    function addDfkPair(address uniAddr,uint256 factor) public onlyManager  {\r\n        if(liquidsMap[uniAddr]==address(0x0)){\r\n            uniswapLiquids[uniAddr][address(0x0)]=factor;\r\n            totalFactor = totalFactor.add(factor);\r\n            liquidsMap[uniAddr] = uniAddr;\r\n            liquidPairs.push(uniAddr);\r\n        }\r\n    }\r\n    \r\n    function removeDfkPair(address uniAddr) public onlyManager  {\r\n        totalFactor = totalFactor.sub(uniswapLiquids[uniAddr][address(0x0)]);\r\n        uniswapLiquids[uniAddr][address(0x0)]=0;\r\n    }\r\n\r\n    \r\n    function addLiquid(address uniAddr,uint256 amountUL) public  {\r\n        require(uniswapLiquids[uniAddr][address(0x0)]>0);//factor must large than zero\r\n        uint256  realBonus=calcBonus(msg.sender);\r\n        if(realBonus>0)\r\n        {\r\n            dfkii._mint(msg.sender,realBonus);\r\n        }\r\n        \r\n        TransferHelper.safeTransferFrom(uniAddr,msg.sender,address(this),amountUL);\r\n        liquidPools[uniAddr] = liquidPools[uniAddr].add(amountUL);\r\n        uniswapLiquids[uniAddr][msg.sender]=uniswapLiquids[uniAddr][msg.sender].add(amountUL);\r\n\r\n        uint256 mine_liquid=amountUL.mul(uniswapLiquids[uniAddr][address(0x0)]);\r\n        // totalLiquids = totalLiquids.add(mine_liquid);\r\n        DTradeLiquids(liquidToken)._mint(msg.sender,mine_liquid);\r\n        \r\n        joinTime[msg.sender] = block.number;\r\n        bonusWithdraw[msg.sender] = 0;\r\n    }\r\n    \r\n    function removeLiquid(address uniAddr,uint256 amountUL) public  {\r\n        require(uniswapLiquids[uniAddr][msg.sender]>=amountUL,'amountUL is not enough');  \r\n\r\n        uint256  realBonus=calcBonus(msg.sender);\r\n        if(realBonus>0)\r\n        {\r\n            dfkii._mint(msg.sender,realBonus);\r\n        }          \r\n              \r\n        TransferHelper.safeTransfer(address(uniAddr),msg.sender,amountUL); \r\n        uint256 mine_liquid=amountUL.mul(uniswapLiquids[uniAddr][address(0x0)]);\r\n        DTradeLiquids(liquidToken)._burn(msg.sender,mine_liquid);        \r\n        uniswapLiquids[uniAddr][msg.sender]=uniswapLiquids[uniAddr][msg.sender].sub(amountUL);\r\n        \r\n        if(DTradeLiquids(liquidToken).balanceOf(msg.sender)==0){\r\n            joinTime[msg.sender] = 0;\r\n        }\r\n        else\r\n        {\r\n            joinTime[msg.sender] = block.number;\r\n        }\r\n        bonusWithdraw[msg.sender] = 0;\r\n    }\r\n    \r\n    function mintCoin(address user) public view returns (uint256){\r\n        if(joinTime[user]==0){\r\n            return 0;\r\n        }\r\n        uint256 checkTime = checkpoint_number;\r\n        if(joinTime[user]>checkpoint_number){\r\n            checkTime = joinTime[user];\r\n        }\r\n        uint256 currentBonus = bonus_per_block.mul(block.number.sub(checkTime));\r\n        if(currentBonus>peroid_left_bonus){\r\n            currentBonus = peroid_left_bonus;\r\n        }\r\n        \r\n        //\r\n        return currentBonus;\r\n         \r\n        \r\n    }\r\n\r\n   \r\n    modifier onlyJoin {\r\n        require(joinTime[msg.sender] > 0,\"onlyJoin time gt 0\");\r\n        _;\r\n    }\r\n\r\n    function calcDFK1Bonus(address addr) public view returns(uint256){\r\n        if(joinTime[msg.sender] == 0){\r\n            return 0;\r\n        }\r\n        return dfk1Helper.calcProfitForFee(addr,mintCoin(address(0x0)).mul(bonus_percent_LP).div(100),profits4DFK1[addr]);\r\n    }\r\n    \r\n    function withdrawDFK1Bonus() public onlyJoin returns(uint256){\r\n        \r\n        uint256 bonus=calcDFK1Bonus(msg.sender);\r\n        if(bonus>0){\r\n            profits4DFK1[msg.sender] = profits4DFK1[msg.sender].add(bonus);\r\n            // totalProfitDFK1 = totalProfitDFK1.sub(bonus);\r\n            // TransferHelper.safeTransfer(token1,msg.sender,bonus);\r\n            dfkii._mint(msg.sender,bonus);\r\n            return bonus;\r\n        }else{\r\n            return 0;\r\n        }\r\n            \r\n    }\r\n    \r\n\r\n    function withdrawBonus() public onlyJoin returns(uint256){\r\n        uint256  realBonus=calcBonus(msg.sender);\r\n        if(realBonus>0)\r\n        {\r\n            bonusWithdraw[msg.sender] = bonusWithdraw[msg.sender].add(realBonus);\r\n            dfkii._mint(msg.sender,realBonus);\r\n            \r\n            joinTime[msg.sender] = block.number;\r\n            bonusWithdraw[msg.sender] = 0;\r\n        }\r\n        return realBonus;\r\n    }\r\n\r\n    function calcBonus(address addr) public view returns (uint256){\r\n        if(joinTime[addr] == 0){\r\n            return 0;\r\n        }\r\n        if(joinTime[addr]<block.number){\r\n            return (ERC20(liquidToken).balanceOf(addr)).div(ERC20(liquidToken).totalSupply()).mul(mintCoin(addr));\r\n        }else{\r\n            return 0;\r\n        }\r\n        \r\n    }\r\n}\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    // function safeTransferETH(address to, uint value) internal {\r\n    //     (bool success,bt) = to.call{value:value}(new bytes(0));\r\n    //     require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    // }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_mans\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_maxMined\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newCustodian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_clearCustodian\",\"type\":\"address\"}],\"name\":\"ChangeConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_clear\",\"type\":\"address\"}],\"name\":\"ChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"ChangeSweep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"_burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"_mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"changeReqs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proposedNew\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposedClear\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"}],\"name\":\"confirmChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mancount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_clear\",\"type\":\"address\"}],\"name\":\"replaceManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_clear\",\"type\":\"address\"}],\"name\":\"requestChange\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"lockId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_lockId\",\"type\":\"bytes32\"}],\"name\":\"sweepChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweepeth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweeptoken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DFKII","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000dea9d2e81c9bb73c890a822f65118a3651c258d5","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://64f167854a9b72b24f41ab2e11cab7632f451eac0ca30977511dbfb1bb4822ab"}]}