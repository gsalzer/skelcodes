{"status":"1","message":"OK","result":[{"SourceCode":"{\"OwnersMap.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\ncontract OwnersMap {\\n\\tmapping(address =\\u003e bool) public owners;\\n}\\n\"},\"Proxy.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\nimport \\\"./OwnersMap.sol\\\";\\n\\n/// @dev Proxy implementation based on https://blog.openzeppelin.com/proxy-patterns/\\ncontract Proxy is OwnersMap {\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"org.rockside.proxy.implementation\\\", and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant IMPLEMENTATION_SLOT = 0xeb8e929d60cd64fa98ec5363fe06b59a1224241a3c075680e7fd7afe9ed1f2a4;\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"org.rockside.proxy.version\\\", and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant VERSION_SLOT = 0xebd5e45a3940557f33764246c4a8f7298050f720cd774a5014dd490b68013e2d;\\n\\n    event Upgraded(bytes32 version, address implementation);\\n\\n    constructor(address owner, bytes32 version, address implementation) payable public {\\n        owners[owner] = true;\\n        owners[address(this)] = true;\\n        _setVersion(version);\\n        _setImplementation(implementation);\\n    }\\n\\n    function upgradeTo(bytes32 newVersion, address newImplementation) public {\\n        require(owners[msg.sender], \\\"Sender is not an owner\\\");\\n        require(_implementation() != newImplementation, \\\"Implementation already used\\\");\\n        _setVersion(newVersion);\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newVersion, newImplementation);\\n    }\\n\\n    function upgradeToAndCall(bytes32 newVersion, address newImplementation, bytes memory data) payable public {\\n        upgradeTo(newVersion, newImplementation);\\n        (bool success,) = address(this).call{value:msg.value}(data);\\n        require(success, \\\"Failing call after upgrade\\\");\\n    }\\n\\n    function version() public view returns (bytes32) {\\n        return _version();\\n    }\\n\\n    function implementation() public view returns (address) {\\n        return _implementation();\\n    }\\n\\n    fallback() external payable {\\n        address _impl = _implementation();\\n        require(_impl != address(0), \\\"No implementation provided\\\");\\n\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n            case 0 { revert(ptr, size) }\\n            default { return(ptr, size) }\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n                impl := sload(slot)\\n        }\\n    }\\n\\n    function _setImplementation(address newImplementation) internal {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n\\n    function _version() internal view returns (bytes32 vrsn) {\\n        bytes32 slot = VERSION_SLOT;\\n        assembly {\\n            vrsn := sload(slot)\\n        }\\n    }\\n\\n    function _setVersion(bytes32 newVersion) internal {\\n        bytes32 slot = VERSION_SLOT;\\n\\n        assembly {\\n            sstore(slot, newVersion)\\n        }\\n    }\\n}\\n\"},\"ProxyFactory.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\nimport \\\"./Proxy.sol\\\";\\n\\ncontract ProxyFactory {\\n\\n    event ProxyCreation(Proxy proxy);\\n\\n    function createProxy(address owner, bytes32 version, address implementation, bytes memory data)\\n        public\\n        payable\\n        returns (Proxy proxy)\\n    {\\n        proxy = new Proxy{value:msg.value}(owner, version, implementation);\\n        if (data.length \\u003e 0) {\\n            (bool success,) = address(proxy).call(data);\\n            require(success, \\\"Failing call after deployment\\\");\\n        }\\n\\n        emit ProxyCreation(proxy);\\n    }\\n\\n    function createProxyWithNonce(address owner, bytes32 version, address implementation, bytes memory data, bytes32 saltNonce)\\n        public\\n        payable\\n        returns (Proxy proxy)\\n    {\\n        bytes32 salt = keccak256(abi.encode(keccak256(data), saltNonce));\\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, abi.encode(owner, version, implementation));\\n        uint256 amount = msg.value;\\n\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            proxy := create2(amount, add(0x20, deploymentData), mload(deploymentData), salt)\\n        }\\n        require(address(proxy) != address(0), \\\"Create2 call failed\\\");\\n\\n        if (data.length \\u003e 0) {\\n            (bool success,) = address(proxy).call(data);\\n            require(success, \\\"Failing call after deployment\\\");\\n        }\\n\\n        emit ProxyCreation(proxy);\\n    }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Proxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyCreation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"version\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createProxy\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"version\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"saltNonce\",\"type\":\"bytes32\"}],\"name\":\"createProxyWithNonce\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ProxyFactory","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7fc2cf0448e8e3476e967c3540a91815ee1e599e7308e18e772ed1fd3b3ea64f"}]}