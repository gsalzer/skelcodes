{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract TotlePrimary {\r\n  function performSwapCollection(\r\n    TotlePrimaryUtils.SwapCollection calldata swaps\r\n  ) external payable {\r\n\r\n  }\r\n}\r\n\r\nlibrary TotlePrimaryUtils {\r\n  struct Order {\r\n    address payable exchangeHandler;\r\n    bytes encodedPayload;\r\n    uint256 minSourceAmount;\r\n    uint256 maxSourceAmount;\r\n  }\r\n\r\n  struct Trade {\r\n    address sourceToken;\r\n    address destinationToken;\r\n    uint256 amount;\r\n    bool isSourceAmount; //true if amount is sourceToken, false if it's destinationToken\r\n    Order[] orders;\r\n  }\r\n\r\n  struct Swap {\r\n    Trade[] trades;\r\n    uint256 minimumExchangeRate;\r\n    uint256 minimumDestinationAmount;\r\n    uint256 sourceAmount;\r\n    uint256 tradeToTakeFeeFrom;\r\n    bool takeFeeFromSource; //Takes the fee before the trade if true, takes it after if false\r\n    address payable redirectAddress;\r\n    bool required;\r\n  }\r\n\r\n  struct SwapCollection {\r\n    Swap[] swaps;\r\n    address payable partnerContract;\r\n    uint256 expirationBlock;\r\n    bytes32 id;\r\n    uint256 maxGasPrice;\r\n    uint8 v;\r\n    bytes32 r;\r\n    bytes32 s;\r\n  }\r\n}\r\n\r\ncontract DSMath {\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender) public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n\r\n  function decimals() public view returns (uint256);\r\n\r\n  //For WETH\r\n  function deposit() external payable;\r\n  function withdraw(uint) external;\r\n}\r\n\r\ninterface DepositManagerInterface {\r\n  function depositERC20ForUser(address _token, address _user, uint256 _amount) external;\r\n  function depositEtherForUser(address _user) external payable;\r\n}\r\n\r\ninterface RegistryInterface {\r\n  function rootToChildToken(address rootToken) external returns (address childToken);\r\n  function getWethTokenAddress() external view returns (address);\r\n  function getDepositManagerAddress() external view returns (address);\r\n}\r\n\r\ncontract Swapper {\r\n  address public constant maticRegistry = 0x56B082d0a590A7ce5d170402D6f7f88B58F71988;\r\n\r\n  function swap(\r\n    TotlePrimary primary,\r\n    TotlePrimaryUtils.SwapCollection calldata swapCollection\r\n  ) external {\r\n    primary.performSwapCollection.value(address(this).balance)(swapCollection);\r\n  }\r\n\r\n  function fetchReturnData() internal pure returns (bool success) {\r\n    assembly {\r\n      switch returndatasize()\r\n      case 0 {\r\n        success := 1\r\n      }\r\n      case 32 {\r\n        returndatacopy(0, 0, 32)\r\n        success := mload(0)\r\n      }\r\n      default {\r\n        revert(0, 0)\r\n      }\r\n    }\r\n  }\r\n\r\n  function getBalance(address token) public view returns (uint256) {\r\n    return token == address(0)\r\n      ? address(this).balance\r\n      : ERC20(token).balanceOf(address(this));\r\n  }\r\n\r\n  function claim(address payable user, address token) public {\r\n    claim(user, token, getBalance(token));\r\n  }\r\n\r\n  function claim(address payable user, address token, uint amount) public {\r\n    require(amount > 0, 'Claim amount must be positive');\r\n\r\n    uint balance = getBalance(token);\r\n    if (balance < amount) {\r\n      amount = balance;\r\n    }\r\n\r\n    if (token == address(0)) {\r\n      user.transfer(amount);\r\n    } else {\r\n      safeTransfer(token, user, amount);\r\n    }\r\n  }\r\n\r\n  function depositMaticMax(address payable user, address token) public {\r\n    depositMatic(user, token, getBalance(token));\r\n  }\r\n\r\n  function depositMatic(address payable user, address token, uint amount) public {\r\n    require(amount > 0, 'Deposit amount must be positive');\r\n    RegistryInterface maticRegistryContract = RegistryInterface(maticRegistry);\r\n\r\n    uint balance = getBalance(token);\r\n    uint _amount = balance < amount ? balance : amount;\r\n    address _token = token == address(0) ? maticRegistryContract.getWethTokenAddress() : token;\r\n    address childToken = maticRegistryContract.rootToChildToken(_token);\r\n    require(childToken != address(0), \"Child token not registered\");\r\n\r\n    address maticDepositManager = maticRegistryContract.getDepositManagerAddress();\r\n    if (token == address(0)) {\r\n      ERC20(_token).deposit.value(_amount)();\r\n      approve(_token, maticDepositManager);\r\n      DepositManagerInterface(maticDepositManager).depositERC20ForUser(_token, user, _amount);\r\n    } else {\r\n      approve(_token, maticDepositManager);\r\n      DepositManagerInterface(maticDepositManager).depositERC20ForUser(_token, user, _amount);\r\n    }\r\n  }\r\n\r\n  function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\r\n    (success,) = _tokenAddress.call(abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _value));\r\n    require(success, \"Transfer failed\");\r\n\r\n    return fetchReturnData();\r\n  }\r\n\r\n  function approve(address token, address spender) public {\r\n    safeApprove(token, spender, getBalance(token));\r\n  }\r\n\r\n  function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\r\n    (success,) = _tokenAddress.call(abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _value));\r\n    require(success, \"Approve failed\");\r\n\r\n    return fetchReturnData();\r\n  }\r\n\r\n  function destroy(address payable user) external {\r\n    selfdestruct(user);\r\n  }\r\n\r\n  function() external payable {\r\n\r\n  }\r\n}\r\n\r\ncontract SwapperFactory is DSMath {\r\n  address public admin;\r\n  address public swapperLibrary;\r\n  uint public maxCommission;\r\n\r\n  event SwapPerformed(\r\n    address indexed user,\r\n    address srcToken,\r\n    address dstToken,\r\n    string uniqueId\r\n  );\r\n\r\n  event MaticSwapPerformed(\r\n    address indexed user,\r\n    address srcToken,\r\n    address dstToken,\r\n    string uniqueId\r\n  );\r\n\r\n  event TransferPerformed(\r\n    address indexed user,\r\n    address token,\r\n    string uniqueId\r\n  );\r\n\r\n  event MaticTransferPerformed(\r\n    address indexed user,\r\n    address token,\r\n    string uniqueId\r\n  );\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, 'Only the admin address can call this function.');\r\n    _;\r\n  }\r\n\r\n  struct Commission {\r\n    uint amount;\r\n    address payable destination;\r\n  }\r\n\r\n  constructor(address _swapperLibrary) public {\r\n    admin = msg.sender;\r\n    swapperLibrary = _swapperLibrary;\r\n    maxCommission = 5*10**16;\r\n  }\r\n\r\n  function performSwap(\r\n    address payable user,\r\n    address srcToken,\r\n    address dstToken,\r\n    string memory uniqueId,\r\n    Commission[] memory commission,\r\n    TotlePrimary primary,\r\n    TotlePrimaryUtils.SwapCollection memory swapCollection\r\n  ) public onlyAdmin() {\r\n    require(swapCollection.swaps.length == 1, 'Must only be 1 swap');\r\n    require(swapCollection.swaps[0].trades[0].sourceToken == srcToken, 'Incorrect source token for swap');\r\n    require(swapCollection.swaps[0].redirectAddress == user, 'User address does not match swap redirect address');\r\n\r\n    Swapper swapper = createClone(user, srcToken, dstToken, uniqueId);\r\n    takeCommission(swapper, srcToken, commission);\r\n\r\n    require(swapCollection.swaps[0].sourceAmount == swapper.getBalance(srcToken), 'Token balance does not match swap amount');\r\n\r\n    if (srcToken != address(0)) {\r\n      address tokenTransferProxy = 0x74758AcFcE059f503a7E6B0fC2c8737600f9F2c4;\r\n      swapper.approve(srcToken, tokenTransferProxy);\r\n    }\r\n\r\n    swapper.swap(primary, swapCollection);\r\n    swapper.destroy(user);\r\n\r\n    emit SwapPerformed(user, srcToken, dstToken, uniqueId);\r\n  }\r\n\r\n  function maticSwap(\r\n    address payable user,\r\n    address srcToken,\r\n    address dstToken,\r\n    string memory uniqueId,\r\n    Commission[] memory commission,\r\n    TotlePrimary primary,\r\n    TotlePrimaryUtils.SwapCollection memory swapCollection\r\n  ) public onlyAdmin() {\r\n    require(swapCollection.swaps.length == 1, 'Must only be 1 swap');\r\n    require(swapCollection.swaps[0].trades[0].sourceToken == srcToken, 'Incorrect source token for swap');\r\n\r\n    Swapper swapper = createClone(user, srcToken, dstToken, uniqueId);\r\n    require(\r\n      swapCollection.swaps[0].redirectAddress == user ||\r\n      swapCollection.swaps[0].redirectAddress == address(swapper),\r\n      'User address does not match swap redirect address');\r\n    takeCommission(swapper, srcToken, commission);\r\n\r\n    require(swapCollection.swaps[0].sourceAmount == swapper.getBalance(srcToken), 'Token balance does not match swap amount');\r\n\r\n    if (srcToken != address(0)) {\r\n      address tokenTransferProxy = 0x74758AcFcE059f503a7E6B0fC2c8737600f9F2c4;\r\n      swapper.approve(srcToken, tokenTransferProxy);\r\n    }\r\n\r\n    swapper.swap(primary, swapCollection);\r\n    swapper.depositMaticMax(user, dstToken);\r\n    swapper.destroy(user);\r\n\r\n    emit MaticSwapPerformed(user, srcToken, dstToken, uniqueId);\r\n  }\r\n\r\n  function performTransfer(\r\n    address payable user,\r\n    address token,\r\n    string memory uniqueId,\r\n    Commission[] memory commission\r\n  ) public onlyAdmin() {\r\n    Swapper swapper = createClone(user, token, token, uniqueId);\r\n    takeCommission(swapper, token, commission);\r\n    swapper.claim(user, token);\r\n    swapper.destroy(user);\r\n\r\n    emit TransferPerformed(user, token, uniqueId);\r\n  }\r\n\r\n  function maticTransfer(\r\n    address payable user,\r\n    address token,\r\n    string memory uniqueId,\r\n    Commission[] memory commission\r\n  ) public onlyAdmin() {\r\n    Swapper swapper = createClone(user, token, token, uniqueId);\r\n    takeCommission(swapper, token, commission);\r\n    swapper.depositMaticMax(user, token);\r\n    swapper.destroy(user);\r\n\r\n    emit MaticTransferPerformed(user, token, uniqueId);\r\n  }\r\n\r\n  function takeCommission(\r\n    Swapper swapper,\r\n    address token,\r\n    Commission[] memory commission\r\n  ) internal onlyAdmin() {\r\n    checkCommission(swapper, token, commission);\r\n    for (uint i = 0; i < commission.length; i++) {\r\n      require(swapper.getBalance(token) > commission[i].amount, 'Swapper balance not enough for commission');\r\n      swapper.claim(commission[i].destination, token, commission[i].amount);\r\n    }\r\n  }\r\n\r\n  function checkCommission(\r\n    Swapper swapper,\r\n    address token,\r\n    Commission[] memory commission\r\n  ) internal view onlyAdmin() {\r\n    uint _totalBal = swapper.getBalance(token);\r\n    uint _commissionAmt;\r\n    if(_totalBal == 0) return;\r\n    for (uint i = 0; i < commission.length; i++) {\r\n      _commissionAmt += commission[i].amount;\r\n    }\r\n    uint _maxCommissionAmt = wmul(_totalBal, maxCommission);\r\n    require(_maxCommissionAmt >= _commissionAmt, \"Over commission\");\r\n  }\r\n\r\n  function claimBalance(\r\n    address payable user,\r\n    address srcToken,\r\n    address dstToken,\r\n    string memory uniqueId,\r\n    address token\r\n  ) public onlyAdmin() {\r\n    Swapper swapper = createClone(user, srcToken, dstToken, uniqueId);\r\n    swapper.claim(user, token);\r\n    swapper.destroy(user);\r\n  }\r\n\r\n  function createClone(\r\n    address user,\r\n    address srcToken,\r\n    address dstToken,\r\n    string memory uniqueId\r\n  ) private onlyAdmin() returns (Swapper) {\r\n    bytes32 salt = computeCloneSalt(user, srcToken, dstToken, uniqueId);\r\n    bytes memory bytecode = getCloneBytecode();\r\n\r\n    address payable cloneAddress = computeAddress(salt);\r\n    if (!isContract(cloneAddress)) {\r\n      assembly {\r\n        cloneAddress := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\r\n      }\r\n    }\r\n\r\n    return Swapper(cloneAddress);\r\n  }\r\n\r\n  function getCloneBytecode() public view returns (bytes memory) {\r\n    bytes20 targetBytes = bytes20(swapperLibrary);\r\n\r\n    bytes memory bytecode = new bytes(0x37);\r\n    assembly {\r\n      mstore(add(bytecode, 0x20), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n      mstore(add(bytecode, 0x34), targetBytes)\r\n      mstore(add(bytecode, 0x48), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n    }\r\n\r\n    return bytecode;\r\n  }\r\n\r\n  function isContract(address _address) public view returns (bool) {\r\n    uint32 size;\r\n    assembly {\r\n      size := extcodesize(_address)\r\n    }\r\n    return (size > 0);\r\n  }\r\n\r\n  function computeCloneSalt(address user, address srcToken, address dstToken, string memory uniqueId) public pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(user, srcToken, dstToken, uniqueId));\r\n  }\r\n\r\n  function computeAddress(bytes32 salt) public view returns (address payable) {\r\n    bytes32 data = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(getCloneBytecode())));\r\n    return address(bytes20(data << 96));\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapperLibrary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"}],\"name\":\"MaticSwapPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"}],\"name\":\"MaticTransferPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"}],\"name\":\"SwapPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"}],\"name\":\"TransferPerformed\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"computeAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"}],\"name\":\"computeCloneSalt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCloneBytecode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"}],\"internalType\":\"struct SwapperFactory.Commission[]\",\"name\":\"commission\",\"type\":\"tuple[]\"},{\"internalType\":\"contract TotlePrimary\",\"name\":\"primary\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destinationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSourceAmount\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"exchangeHandler\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"encodedPayload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"minSourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSourceAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TotlePrimaryUtils.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"internalType\":\"struct TotlePrimaryUtils.Trade[]\",\"name\":\"trades\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minimumExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDestinationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradeToTakeFeeFrom\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"takeFeeFromSource\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"redirectAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"required\",\"type\":\"bool\"}],\"internalType\":\"struct TotlePrimaryUtils.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address payable\",\"name\":\"partnerContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct TotlePrimaryUtils.SwapCollection\",\"name\":\"swapCollection\",\"type\":\"tuple\"}],\"name\":\"maticSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"}],\"internalType\":\"struct SwapperFactory.Commission[]\",\"name\":\"commission\",\"type\":\"tuple[]\"}],\"name\":\"maticTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"}],\"internalType\":\"struct SwapperFactory.Commission[]\",\"name\":\"commission\",\"type\":\"tuple[]\"},{\"internalType\":\"contract TotlePrimary\",\"name\":\"primary\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destinationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSourceAmount\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"exchangeHandler\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"encodedPayload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"minSourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSourceAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TotlePrimaryUtils.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"internalType\":\"struct TotlePrimaryUtils.Trade[]\",\"name\":\"trades\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minimumExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDestinationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradeToTakeFeeFrom\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"takeFeeFromSource\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"redirectAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"required\",\"type\":\"bool\"}],\"internalType\":\"struct TotlePrimaryUtils.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address payable\",\"name\":\"partnerContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct TotlePrimaryUtils.SwapCollection\",\"name\":\"swapCollection\",\"type\":\"tuple\"}],\"name\":\"performSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uniqueId\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"}],\"internalType\":\"struct SwapperFactory.Commission[]\",\"name\":\"commission\",\"type\":\"tuple[]\"}],\"name\":\"performTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapperLibrary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SwapperFactory","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ea483a51abbb216bf7f35b7a8d7eb7f040fa2e4e","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5bc4220450c26225fc4956c3e45f58f5e6b74407b455514c681323acd2c4a93a"}]}