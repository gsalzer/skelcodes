{"status":"1","message":"OK","result":[{"SourceCode":"/* Discussion:\r\n * //github.com/b-u-i-d-l/dfo-hub\r\n */\r\n/* Description:\r\n * QuickScope - A simple DFO Microservice to easily swap Programmable Equities through Uniswap V2\r\n */\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\n\r\n/**\r\n * @title QuickScope - A simple DFO Microservice to easily swap Programmable Equities through Uniswap V2\r\n * @dev This general-purpose microservice can be called only by authorized sender, which can be easily set\r\n * using the DFOhub StateHolder.\r\n */\r\ncontract QuickScopeMicroservice {\r\n\r\n    string private _metadataLink;\r\n\r\n    /**\r\n     * @dev Microservice Constructor\r\n     * @param metadataLink The IPFS location of the Metadata, saved in JSON Format\r\n     */\r\n    constructor(string memory metadataLink) {\r\n        _metadataLink = metadataLink;\r\n    }\r\n\r\n    /**\r\n     * @dev GET the metadataLink\r\n     */\r\n    function getMetadataLink() public view returns(string memory) {\r\n        return _metadataLink;\r\n    }\r\n\r\n    /**\r\n     * @dev The Microservice method start\r\n     * It sets up the operator able to call the microservice\r\n     */\r\n    function onStart(address, address) public {\r\n        IMVDProxy proxy = IMVDProxy(msg.sender);\r\n        IStateHolder stateHolder = IStateHolder(proxy.getStateHolderAddress());\r\n        address quickScopeOperator = 0xd6b6B5c0F41D77E41C33a8e2B8BACe8fdBf4eDef;\r\n        stateHolder.setBool(string(abi.encode(\"quickScope.operator.\", _toLowerCase(_toString(quickScopeOperator)))), true);\r\n    }\r\n\r\n    /**\r\n     * @dev The Microservice method end\r\n     * It avoids the operator able to call the microservice\r\n     */\r\n    function onStop(address) public {\r\n        IMVDProxy proxy = IMVDProxy(msg.sender);\r\n        IStateHolder stateHolder = IStateHolder(proxy.getStateHolderAddress());\r\n        address quickScopeOperator = 0xd6b6B5c0F41D77E41C33a8e2B8BACe8fdBf4eDef;\r\n        stateHolder.clear(string(abi.encode(\"quickScope.operator.\", _toLowerCase(_toString(quickScopeOperator)))));\r\n    }\r\n\r\n    /**\r\n     * @dev The microservice main method.\r\n     * It transfers the desiderd tokens then swap it on UniswapV2, sending back again the gained tokens to the DFO.\r\n     * @param sender The original msg.sender who called the DFO Proxy. It should be the operator authorized to perform the action.\r\n     * @param uniswapV2RouterAddress The Uniswap V2 Router address useful to perform the operation\r\n     * @param path The token path to be used to swap the token\r\n     * @param amountIn The amount of passed token to be swapped\r\n     * @param amountOutMin The output amount to be received, it can contain the slippage\r\n     * @param deadline The swap deadline before to declare void this swap\r\n     */\r\n    function quickScope(address sender, uint256, address uniswapV2RouterAddress, address[] memory path, uint256 amountIn, uint256 amountOutMin, uint256 deadline) public {\r\n        IMVDProxy proxy = IMVDProxy(msg.sender);\r\n        IStateHolder stateHolder = IStateHolder(proxy.getStateHolderAddress());\r\n        require(stateHolder.getBool(string(abi.encode(\"quickScope.operator.\", _toLowerCase(_toString(sender))))), \"Unauthorized Action!\");\r\n        address walletAddress = proxy.getMVDWalletAddress();\r\n        proxy.transfer(address(this), amountIn, path[0]);\r\n        _checkAllowance(path[0], amountIn, uniswapV2RouterAddress);\r\n        IUniswapV2Router(uniswapV2RouterAddress).swapExactTokensForTokens(amountIn, amountOutMin, path, walletAddress, deadline);\r\n        _flush(path, walletAddress);\r\n    }\r\n\r\n    function _checkAllowance(\r\n        address tokenAddress,\r\n        uint256 value,\r\n        address spender\r\n    ) private {\r\n        IERC20 token = IERC20(tokenAddress);\r\n        if (token.allowance(address(this), spender) <= value) {\r\n            token.approve(spender, value);\r\n        }\r\n    }\r\n\r\n    function _flush(address[] memory tokenAddresses, address receiver) private {\r\n        for(uint256 i = 0; i < tokenAddresses.length; i++) {\r\n            IERC20 token = IERC20(tokenAddresses[i]);\r\n            uint256 balance = token.balanceOf(address(this));\r\n            if(balance > 0) {\r\n                token.transfer(receiver, balance);\r\n            }\r\n        }\r\n        uint256 balance = address(this).balance;\r\n        if(balance > 0) {\r\n            payable(receiver).transfer(balance);\r\n        }\r\n    }\r\n\r\n    function _toString(address _addr) private pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\r\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    function _toLowerCase(string memory str) private pure returns(string memory) {\r\n        bytes memory bStr = bytes(str);\r\n        for (uint i = 0; i < bStr.length; i++) {\r\n            bStr[i] = bStr[i] >= 0x41 && bStr[i] <= 0x5A ? bytes1(uint8(bStr[i]) + 0x20) : bStr[i];\r\n        }\r\n        return string(bStr);\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IMVDProxy {\r\n    function getStateHolderAddress() external view returns(address);\r\n    function getMVDWalletAddress() external view returns (address);\r\n    function transfer(address receiver, uint256 value, address token) external;\r\n}\r\n\r\ninterface IMVDFunctionalitiesManager {\r\n    function isAuthorizedFunctionality(address functionality) external view returns(bool);\r\n}\r\n\r\ninterface IStateHolder {\r\n    function clear(string calldata varName) external returns(string memory oldDataType, bytes memory oldVal);\r\n    function setBool(string calldata varName, bool val) external returns(bool);\r\n    function getBool(string calldata varName) external view returns (bool);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"metadataLink\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getMetadataLink\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"onStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"onStop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapV2RouterAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"quickScope\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"QuickScopeMicroservice","CompilerVersion":"v0.7.2+commit.51b20bc0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003a697066733a2f2f697066732f516d51686d5675625963685176377847375668507347687a366a5a626f7439424e75337639424d326a6377485752000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4c4dec0385f57986e10ba2b0a570bb27f763831b46772116a6f06cc86150c84e"}]}