{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-02-25\r\n*/\r\n\r\npragma solidity ^0.5.12;\r\n\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf   (address)                external view returns (uint256);\r\n    function approve     (address, uint256)       external      returns (bool);\r\n    function transferFrom(address, address, uint) external      returns (bool);\r\n    function transfer    (address, uint256)       external      returns (bool);\r\n}\r\n\r\ninterface IGateway {\r\n    function mint(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) external returns (uint256);\r\n    function burn(bytes calldata _to, uint256 _amount) external returns (uint256);\r\n}\r\n\r\ninterface IGatewayRegistry {\r\n    function getGatewayBySymbol(string calldata _tokenSymbol) external view returns (IGateway);\r\n    function getGatewayByToken(address  _tokenAddress) external view returns (IGateway);\r\n    function getTokenBySymbol(string calldata _tokenSymbol) external view returns (IERC20);\r\n}\r\n\r\ninterface ICurveExchange {\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\r\n    function get_dy(int128, int128 j, uint256 dx) external view returns (uint256);\r\n}\r\n\r\ncontract DirectBTCProxy {\r\n\r\n    function borrow(\r\n        address _owner, // CDP owner (if they do not own a CDP, one will be created).\r\n        int     _dink,  // Amount of WBTC to collateralize (18 decimals).\r\n        int     _dart   // Amount of Dai to borrow (18 decimals).\r\n    ) external;\r\n\r\n    function repay(\r\n        address _owner, // CDP owner\r\n        int     _dink,  // Amount of WBTC to reclaim (with 18 decimal places).\r\n        int     _dart   // Amount of Dai to repay\r\n    ) external;\r\n}\r\n\r\ncontract WBTCCDPProxy {\r\n    using SafeMath for uint256;\r\n\r\n    IGatewayRegistry public registry;\r\n    IERC20           public dai;\r\n    IERC20           public wbtc;\r\n    IERC20           public renbtc;\r\n    DirectBTCProxy   public directProxy;\r\n    ICurveExchange   public exchange; \r\n\r\n    mapping (address => bytes) btcAddrs;\r\n\r\n    constructor(\r\n        address _registry,\r\n        address _dai,\r\n        address _wbtc,\r\n        address _directProxy,\r\n        ICurveExchange _exchange\r\n    ) public {\r\n        registry    = IGatewayRegistry(_registry);\r\n        dai         = IERC20(_dai);\r\n        wbtc        = IERC20(_wbtc);\r\n        renbtc      = registry.getTokenBySymbol('BTC');\r\n        directProxy = DirectBTCProxy(_directProxy);\r\n        exchange    = ICurveExchange(_exchange);\r\n        \r\n        // Approve exchange.\r\n        require(wbtc.approve(address(exchange), uint256(-1)));\r\n        require(renbtc.approve(address(exchange), uint256(-1)));\r\n    }\r\n\r\n    // TODO: test me\r\n    function mintDai(\r\n        // User params\r\n        uint256     _dart,\r\n        bytes calldata _btcAddr,\r\n        uint256 _minWbtcAmount,\r\n\r\n        // Darknode params\r\n        uint256        _amount, // Amount of renBTC.\r\n        bytes32        _nHash,  // Nonce hash.\r\n        bytes calldata _sig     // Minting signature. TODO: understand better\r\n    ) external {\r\n        // Finish the lock-and-mint cross-chain transaction using the minting\r\n        // signature produced by RenVM.\r\n        \r\n        // TODO: read the IGateway code\r\n        uint256 amount = registry.getGatewayBySymbol(\"BTC\").mint(\r\n            keccak256(abi.encode(msg.sender, _dart, _btcAddr, _minWbtcAmount)), \r\n            _amount, \r\n            _nHash, \r\n            _sig\r\n        );\r\n        \r\n        // Get price\r\n        uint256 proceeds = exchange.get_dy(0, 1, amount);\r\n        \r\n        // Price is OK\r\n        if (proceeds >= _minWbtcAmount) {\r\n            uint256 startWbtcBalance = wbtc.balanceOf(address(this));\r\n            exchange.exchange(0, 1, amount, _minWbtcAmount);\r\n            uint256 wbtcBought = wbtc.balanceOf(address(this)).sub(startWbtcBalance);\r\n\r\n            require(\r\n                wbtc.transfer(address(directProxy), wbtcBought),\r\n                \"err: transfer failed\"\r\n            );\r\n\r\n            directProxy.borrow(\r\n                msg.sender,\r\n                int(wbtcBought * (10 ** 10)),\r\n                int(_dart)\r\n            );\r\n\r\n            btcAddrs[msg.sender] = _btcAddr;\r\n        } else {\r\n            // Send renBTC to the User instead\r\n            renbtc.transfer(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    // TODO: test me\r\n    function burnDai(\r\n        // User params\r\n        uint256 _dink,  // Amount of WBTC (with  8 decimal places)\r\n        uint256 _dart,   // Amount of DAI  (with 18 decimal places)\r\n        uint256 _minRenbtcAmount\r\n    ) external {\r\n        // get DAI from the msg.sender (requires msg.sender to approve)\r\n        require(\r\n            dai.transferFrom(msg.sender, address(this), _dart),\r\n            \"err: transferFrom dai\"\r\n        );\r\n\r\n        // send DAI to the directProxy\r\n        require(\r\n            dai.transfer(address(directProxy), _dart),\r\n            \"err: transfer dai\"\r\n        );\r\n\r\n        // proxy through to the direct proxy.\r\n        directProxy.repay(\r\n            msg.sender,\r\n            int(_dink) * (10 ** 10),\r\n            int(_dart)\r\n        );\r\n        \r\n        // Get renBTC\r\n        uint256 startRenbtcBalance = renbtc.balanceOf(address(this));\r\n        exchange.exchange(1, 0, _dink, _minRenbtcAmount);\r\n        uint256 endRenbtcBalance = renbtc.balanceOf(address(this));\r\n        uint256 renbtcBought = endRenbtcBalance.sub(startRenbtcBalance);\r\n\r\n        // Initiate the burn-and-release cross-chain transaction,\r\n        // after which RenVM will finish the cross-chain\r\n        // transaction by releasing BTC to the specified to address.\r\n        // TODO: consider rewriting how we get the shifter (constructor)\r\n        registry.getGatewayBySymbol(\"BTC\").burn(btcAddrs[msg.sender], renbtcBought);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wbtc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_directProxy\",\"type\":\"address\"},{\"internalType\":\"contract ICurveExchange\",\"name\":\"_exchange\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dink\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minRenbtcAmount\",\"type\":\"uint256\"}],\"name\":\"burnDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"directProxy\",\"outputs\":[{\"internalType\":\"contract DirectBTCProxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"contract ICurveExchange\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dart\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_btcAddr\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_minWbtcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"mintDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IGatewayRegistry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"renbtc\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wbtc\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WBTCCDPProxy","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000e80d347df1209a76dd9d2319d62912ba98c54ddd0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000bc20e022955344fd9c8ff03c20d69a5ba21bec230000000000000000000000008474c1236f0bc23830a23a41abb81b2764ba9f4f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8ffe8f856ac30504cca58c0781806faa3b1dd25eef47994374304b142c8b563a"}]}