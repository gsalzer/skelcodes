{"status":"1","message":"OK","result":[{"SourceCode":"/* \r\n This contract is based on dice2.win.\r\n  https://github.com/dice2-win/contracts/blob/master/Dice2Win.sol\r\n See license below\r\n  https://github.com/dice2-win/contracts/blob/master/LICENSE\r\n*/\r\npragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath8 {\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        uint8 c = a- b;\r\n        return c;\r\n    }\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint8 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath40 {\r\n    function add(uint40 a, uint40 b) internal pure returns (uint40) {\r\n        uint40 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    function sub(uint40 a, uint40 b) internal pure returns (uint40) {\r\n        assert(b <= a);\r\n        uint40 c = a- b;\r\n        return c;\r\n    }\r\n    function mul(uint40 a, uint40 b) internal pure returns (uint40) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint40 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint40 a, uint40 b) internal pure returns (uint40) {\r\n        uint40 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint40 a, uint40 b) internal pure returns (uint40) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath128 {\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        uint128 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        assert(b <= a);\r\n        uint128 c = a- b;\r\n        return c;\r\n    }\r\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint128 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        uint128 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract BlockChainCasino {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath8 for uint8;\r\n    using SafeMath40 for uint40;\r\n    using SafeMath128 for uint128;\r\n\r\n    uint constant HOUSE_EDGE_PERCENT = 1;\r\n    uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether;\r\n\r\n    uint constant MIN_JACKPOT_BET = 0.1 ether;\r\n\r\n    uint constant JACKPOT_FEE = 0.001 ether;\r\n\r\n    uint constant MIN_BET = 0.01 ether;\r\n    uint constant MAX_AMOUNT = 300000 ether;\r\n\r\n    uint constant MAX_MODULO = 100;\r\n\r\n    uint constant MAX_MASK_MODULO = 40;\r\n\r\n    uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO;\r\n\r\n    uint40 constant BET_EXPIRATION_BLOCKS = 250;\r\n\r\n    address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    uint public jackpot_modulo = 1000;\r\n\r\n    address public owner;\r\n    address private nextOwner;\r\n\r\n    uint public maxProfit = 999999000000000000000000;\r\n\r\n    address public secretSigner;\r\n\r\n    uint128 public jackpotSize;\r\n\r\n    uint128 public lockedInBets;\r\n\r\n    struct Bet {\r\n        uint numberOfBets;\r\n        uint[] amount;\r\n        uint totalAmount;\r\n        uint8 modulo;\r\n        uint8 rollUnder;\r\n        uint40 placeBlockNumber;\r\n        uint40[] mask;\r\n        uint8 gameId;\r\n        address gambler;\r\n    }\r\n\r\n    mapping (uint => Bet) public bets;\r\n\r\n    mapping (uint => address) public gameAddress;\r\n\r\n    event FailedPayment(address indexed beneficiary, uint amount);\r\n    event Payment(address indexed beneficiary, uint amount);\r\n    event JackpotPayment(address indexed beneficiary, uint amount);\r\n\r\n    event Commit(uint commit);\r\n\r\n    event Game(uint reveal, uint[10] result, uint totalWin, uint totalJackpot);\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        secretSigner = DUMMY_ADDRESS;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    function approveNextOwner(address _nextOwner) external onlyOwner {\r\n        require (_nextOwner != owner, \"Cannot approve current owner.\");\r\n        nextOwner = _nextOwner;\r\n    }\r\n\r\n    function acceptNextOwner() external {\r\n        require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\r\n        owner = nextOwner;\r\n    }\r\n\r\n    function () public payable {\r\n    }\r\n\r\n    function setSecretSigner(address newSecretSigner) external onlyOwner {\r\n        secretSigner = newSecretSigner;\r\n    }\r\n\r\n    function setMaxProfit(uint _maxProfit) public onlyOwner {\r\n        require (_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number.\");\r\n        maxProfit = _maxProfit;\r\n    }\r\n\r\n    function setGameContract(uint _gameId, address _contract_addr) public onlyOwner {\r\n        gameAddress[_gameId] = _contract_addr;\r\n    }\r\n\r\n    function increaseJackpot(uint increaseAmount) external onlyOwner {\r\n        require (increaseAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (jackpotSize + lockedInBets + increaseAmount <= address(this).balance, \"Not enough funds.\");\r\n        jackpotSize += uint128(increaseAmount);\r\n    }\r\n\r\n    function withdrawFunds(address beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (jackpotSize + lockedInBets + withdrawAmount <= address(this).balance, \"Not enough funds.\");\r\n        sendFunds(beneficiary, withdrawAmount, withdrawAmount);\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function placeBet(uint8 gameId, uint[] betMask, uint[] amount, uint8 modulo, uint commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s) external payable {\r\n        Bet storage bet = bets[commit];\r\n\r\n        uint totalAmount;\r\n        totalAmount = checkBetBeforePlace(betMask, amount, modulo, commitLastBlock, commit, v, r, s);\r\n\r\n        for (uint8 i = 0; i < amount.length; i++){\r\n            checkBetAmounts(gameId, betMask[i], amount[i], modulo);\r\n        }\r\n\r\n        emit Commit(commit);\r\n\r\n        for (i = 0; i < amount.length; i++ ) {\r\n            bet.amount.push(amount[i]);\r\n            bet.mask.push(uint40(betMask[i]));\r\n        }\r\n\r\n        bet.numberOfBets = amount.length;\r\n        bet.totalAmount = totalAmount;\r\n        bet.modulo = uint8(modulo);\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.gambler = msg.sender;\r\n        bet.gameId = gameId;\r\n    }\r\n\r\n    function checkBetBeforePlace(uint[] betMask, uint[] amount, uint modulo, uint commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s) private view returns (uint totalAmount){\r\n        Bet storage bet = bets[commit];\r\n        require (bet.gambler == address(0), \"Bet should be in a 'clean' state.\");\r\n\r\n        require (amount.length == betMask.length, \"Incorrect multiple bet\");\r\n        for (uint8 i = 0; i < amount.length; i++) {\r\n            totalAmount = totalAmount.add(amount[i]);\r\n            require (amount[i] >= MIN_BET && amount[i] <= MAX_AMOUNT, \"Amount should be within range.\");\r\n            require (betMask[i] > 0 && betMask[i] < MAX_BET_MASK, \"Mask should be within range.\");\r\n        }\r\n        require (totalAmount == msg.value, \"Send value is different from the total amount.\");\r\n\r\n        require (modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\r\n\r\n        require (block.number <= commitLastBlock, \"Commit has expired.\");\r\n        bytes32 signatureHash = keccak256(abi.encodePacked(uint40(commitLastBlock), commit));\r\n\r\n        require (secretSigner == ecrecover(signatureHash, v, r, s), \"ECDSA signature is not valid.\");\r\n\r\n    }\r\n\r\n    function checkBetAmounts(uint8 gameId, uint betMask, uint amount, uint8 modulo) private {\r\n        uint possibleWinAmount;\r\n        uint jackpotFee;\r\n        uint houseEdge;\r\n\r\n        (houseEdge, jackpotFee) = getHouseEdge(amount);\r\n        possibleWinAmount = callGetMaxWin(gameId, betMask, modulo, amount.sub(houseEdge).sub(jackpotFee));\r\n\r\n        require (possibleWinAmount <= amount.add(maxProfit), \"maxProfit limit violation.\");\r\n\r\n        lockedInBets = lockedInBets.add(uint128(possibleWinAmount));\r\n        jackpotSize = jackpotSize.add(uint128(jackpotFee));\r\n\r\n        require (jackpotSize.add(lockedInBets) <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n\r\n    }\r\n\r\n    function settleBet(uint reveal, bytes32 blockHash) external {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Bet storage bet = bets[commit];\r\n        uint placeBlockNumber = bet.placeBlockNumber;\r\n\r\n        require (block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\r\n        require (block.number <= placeBlockNumber.add(BET_EXPIRATION_BLOCKS), \"Blockhash can't be queried by EVM.\");\r\n        require (blockhash(placeBlockNumber) == blockHash, \"Wrong blockHash\");\r\n\r\n        settleBetCommon(bet, reveal, blockHash);\r\n    }\r\n\r\n    function callGame(uint _gameId, uint betMask, uint8 modulo, bytes32 entropy, uint betAmount) internal view returns(uint winAmount, uint[10] result) {\r\n        address contAddr = gameAddress[_gameId];\r\n        gameContract contObj;\r\n        contObj = gameContract(contAddr);\r\n        (winAmount, result) = contObj.game(betMask, modulo, entropy, betAmount);\r\n\r\n    }\r\n\r\n    function callGetMaxWin(uint _gameId, uint betMask, uint8 modulo, uint betAmount) internal view returns(uint maxWin) {\r\n        address contAddr = gameAddress[_gameId];\r\n        gameContract contObj;\r\n        contObj = gameContract(contAddr);\r\n        maxWin = contObj.getMaxWin(betMask, modulo, betAmount);\r\n\r\n    }\r\n\r\n    function settleBetCommon(Bet storage bet, uint reveal, bytes32 entropyBlockHash) private {\r\n\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, entropyBlockHash));\r\n\r\n        uint totalWin = 0;\r\n        uint totalJackpot = 0;\r\n        uint256[10] memory result;\r\n\r\n\r\n        for (uint i = 0; i < bet.numberOfBets; i++ ) {\r\n\r\n            require (bet.amount[i] != 0, \"Bet should be in an 'active' state\");\r\n\r\n            uint amount = bet.amount[i];\r\n            bet.amount[i] = 0;\r\n\r\n            uint winAmount;\r\n            (winAmount, result) = getGameWin(entropy, bet.gameId, amount, bet.mask[i], bet.modulo);\r\n            totalWin = totalWin.add(winAmount);\r\n            totalJackpot = totalJackpot.add(getJackpotWin(bet.gambler, entropy, amount, bet.modulo));\r\n        }\r\n        bet.totalAmount = 0;\r\n\r\n        sendFunds(bet.gambler, totalWin + totalJackpot == 0 ? 1 wei : totalWin + totalJackpot, totalWin);\r\n\r\n        emit Game(reveal, result, totalWin, totalJackpot);\r\n    }\r\n\r\n    function getGameWin(bytes32 entropy, uint gameId, uint amount, uint mask, uint8 modulo) private returns (uint winAmount, uint256[10] memory result) {\r\n\r\n        uint _jackpotFee;\r\n        uint _houseEdge;\r\n        uint possibleWinAmount;\r\n\r\n        (_houseEdge, _jackpotFee) = getHouseEdge(amount);\r\n\r\n        (winAmount, result) = callGame(gameId, mask, modulo, entropy, amount - _houseEdge - _jackpotFee);\r\n\r\n        possibleWinAmount = callGetMaxWin(gameId, mask, modulo, amount.sub(_houseEdge).sub(_jackpotFee));\r\n        lockedInBets = lockedInBets.sub(uint128(possibleWinAmount));\r\n\r\n    }\r\n\r\n    function getJackpotWin(address gambler, bytes32 entropy, uint amount, uint8 modulo) private returns (uint jackpotWin) {\r\n        if (amount >= MIN_JACKPOT_BET) {\r\n            uint jackpotRng = uint(entropy).div(modulo).mod(jackpot_modulo);\r\n\r\n            if (jackpotRng == 0) {\r\n                jackpotWin = jackpotSize;\r\n                jackpotSize = 0;\r\n            }\r\n        }\r\n\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(gambler, jackpotWin);\r\n        }\r\n\r\n    }\r\n\r\n    function refundBet(uint commit) external {\r\n        Bet storage bet = bets[commit];\r\n        uint jackpotFee;\r\n        uint houseEdge;\r\n        uint possibleWinAmount;\r\n        uint returnAmount;\r\n\r\n        require (bet.totalAmount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        require (block.number > bet.placeBlockNumber.add(BET_EXPIRATION_BLOCKS), \"Blockhash can't be queried by EVM.\");\r\n\r\n        returnAmount = bet.totalAmount;\r\n        bet.totalAmount = 0;\r\n        for (uint i = 0; i < bet.numberOfBets; i++) {\r\n            (houseEdge, jackpotFee) = getHouseEdge(bet.amount[i]);\r\n            possibleWinAmount = callGetMaxWin(bet.gameId, bet.mask[i], bet.modulo, bet.amount[i].sub(houseEdge).sub(jackpotFee));\r\n            lockedInBets = lockedInBets.sub(uint128(possibleWinAmount));\r\n            jackpotSize = jackpotSize.sub(uint128(jackpotFee));\r\n            bet.amount[i] = 0;\r\n        }\r\n\r\n        sendFunds(bet.gambler, returnAmount, returnAmount);\r\n    }\r\n\r\n    function getHouseEdge(uint amount) private pure returns (uint houseEdge, uint jackpotFee) {\r\n        jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n\r\n        houseEdge = amount.mul(HOUSE_EDGE_PERCENT).div(100);\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        require (houseEdge.add(jackpotFee) <= amount, \"Bet doesn't even cover house edge.\");\r\n    }\r\n\r\n    function sendFunds(address beneficiary, uint amount, uint successLogAmount) private {\r\n        if (beneficiary.send(amount)) {\r\n            emit Payment(beneficiary, successLogAmount);\r\n        } else {\r\n            emit FailedPayment(beneficiary, amount);\r\n        }\r\n    }\r\n\r\n    function getBet(uint commit) external view returns (uint numberOfBets, uint[] amount, uint totalAmount, uint8 modulo, uint40 placeBlockNumber, uint40[] mask, uint8 gameId, address gambler) {\r\n        numberOfBets = bets[commit].numberOfBets;\r\n        amount = bets[commit].amount;\r\n        totalAmount = bets[commit].totalAmount;\r\n        modulo = bets[commit].modulo;\r\n        placeBlockNumber = bets[commit].placeBlockNumber;\r\n        mask = bets[commit].mask;\r\n        gameId = bets[commit].gameId;\r\n        gambler = bets[commit].gambler;\r\n    }\r\n\r\n    function setJackpotModulo(uint _modulo) external onlyOwner returns (bool) {\r\n        jackpot_modulo = _modulo;\r\n    }\r\n\r\n}\r\n\r\ncontract gameContract {\r\n    function game(uint betMask, uint8 modulo, bytes32 entropy, uint betAmount) public pure returns(uint winAmount, uint256[10] result);\r\n    function getMaxWin(uint betMask, uint8 modulo, uint betAmount) public pure returns(uint maxWin);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"getBet\",\"outputs\":[{\"name\":\"numberOfBets\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256[]\"},{\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"placeBlockNumber\",\"type\":\"uint40\"},{\"name\":\"mask\",\"type\":\"uint40[]\"},{\"name\":\"gameId\",\"type\":\"uint8\"},{\"name\":\"gambler\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"numberOfBets\",\"type\":\"uint256\"},{\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"rollUnder\",\"type\":\"uint8\"},{\"name\":\"placeBlockNumber\",\"type\":\"uint40\"},{\"name\":\"gameId\",\"type\":\"uint8\"},{\"name\":\"gambler\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint8\"},{\"name\":\"betMask\",\"type\":\"uint256[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_contract_addr\",\"type\":\"address\"}],\"name\":\"setGameContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_modulo\",\"type\":\"uint256\"}],\"name\":\"setJackpotModulo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot_modulo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"increaseAmount\",\"type\":\"uint256\"}],\"name\":\"increaseJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSecretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"Commit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"reveal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256[10]\"},{\"indexed\":false,\"name\":\"totalWin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalJackpot\",\"type\":\"uint256\"}],\"name\":\"Game\",\"type\":\"event\"}]","ContractName":"BlockChainCasino","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d7990775c40fa197d3ed07cd6e4c84350aadda9779ef4f864c9b115d87cbcdae"}]}