{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.0;\r\n\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract AbacusOracle is Initializable{\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    address payable owner;\r\n    \r\n    uint public callFee;\r\n    uint public jobFee;\r\n    uint public jobsActive;\r\n    uint64[] private jobIds;\r\n    uint callId;\r\n    \r\n    enum Status {ACTIVE,CLOSED}\r\n        \r\n    /*============Mappings=============\r\n    ----------------------------------*/\r\n    \r\n    mapping (uint64 => Job) public jobs;\r\n    mapping (uint64 => uint[]) private jobResponse;\r\n    mapping (uint64 => bool) public isJobActive;\r\n    mapping (address => bool) private isUpdater;\r\n    mapping (uint => bytes32) public calls;\r\n\r\n    /*============Events===============\r\n    ---------------------------------*/\r\n    \r\n    event jobCreated(\r\n        string api,\r\n        bytes32 [] parameters,\r\n        uint64 jobId\r\n        );\r\n        \r\n    event breach(\r\n        uint64 jobId,\r\n        address creator,\r\n        uint previousPrice,\r\n        uint newPrice\r\n        );\r\n        \r\n    event ScheduleFuncEvent(\r\n        address indexed to, \r\n        uint256 indexed callTime,    \r\n        bytes data,\r\n        uint256 fee,\r\n        uint256 gaslimit,\r\n        uint256 gasprice, \r\n        uint256 indexed callID\r\n        );\r\n        \r\n    event FunctionExec(\r\n        address to,\r\n        bool txStatus,\r\n        bool reimbursedStatus\r\n        );\r\n    \r\n    /*=========Structs================\r\n    --------------------------------*/\r\n    \r\n    struct Job{\r\n        string api;\r\n        bytes32 [] parameters;\r\n        string ipfsHash;\r\n        address creator;\r\n        uint NoOfParameters;\r\n        uint triggerValue;\r\n        uint dataFrequency;\r\n        uint prepaidValue;\r\n        uint leftValue;\r\n        bool hashRequired;\r\n        Status status;\r\n    }\r\n    \r\n    \r\n    /*===========Modifiers===========\r\n    -------------------------------*/\r\n    \r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyUpdater(){\r\n        require(isUpdater[msg.sender]);\r\n        _;\r\n    }  \r\n    uint public totalOwnerFee;    \r\n    function initialize(address payable _owner,uint _fee,uint _callFee , address[] memory _updaters) public initializer{\r\n        owner =_owner;\r\n        jobFee = _fee;\r\n        isUpdater[_owner] =true;\r\n        callFee = _callFee;\r\n        \r\n        for(uint i=0; i<_updaters.length;i++){\r\n            isUpdater[_updaters[i]] = true;\r\n        } \r\n    }\r\n    // constructor  (address payable _owner,uint _fee,uint _callFee , address[] memory _updaters) public {\r\n    //     owner =_owner;\r\n    //     jobFee = _fee;\r\n    //     isUpdater[_owner] =true;\r\n    //     callFee = _callFee;\r\n        \r\n    //     for(uint i=0; i<_updaters.length;i++){\r\n    //         isUpdater[_updaters[i]] = true;\r\n    //     }\r\n    // }\r\n    \r\n    \r\n    /*===========Job functions============\r\n    -------------------------------------*/\r\n\r\n    function createJob(string calldata _api,\r\n                       bytes32[] calldata _parameters, \r\n                       uint _triggerValue , \r\n                       uint _frequency , \r\n                       uint _prepaidValue, \r\n                       uint ipfsHashProof\r\n                       ) \r\n                       external payable returns(uint _Id) \r\n                       {\r\n        require(msg.value == _prepaidValue);\r\n        bool _hashRequired = ipfsHashProof == 0 ? false:true;\r\n        uint nop  = _parameters.length;\r\n        uint64 _jobId = uint64(uint(keccak256(abi.encodePacked(_api,_triggerValue,now))));\r\n        \r\n        jobs[_jobId] = Job({api : _api,\r\n                            parameters : _parameters,\r\n                            ipfsHash : \"\",\r\n                            creator : msg.sender,\r\n                            triggerValue : _triggerValue,\r\n                            dataFrequency : _frequency,\r\n                            prepaidValue: msg.value,\r\n                            leftValue: msg.value,\r\n                            NoOfParameters : nop,\r\n                            hashRequired : _hashRequired,\r\n                            status : Status.ACTIVE\r\n        });\r\n        jobIds.push(_jobId);\r\n        isJobActive[_jobId] = true;\r\n        jobResponse[_jobId] = [uint(0)];\r\n        jobsActive += 1 ;\r\n        \r\n        emit jobCreated(_api,_parameters,_jobId);\r\n        \r\n        return _jobId;\r\n        }\r\n    \r\n    function updateJob(uint64 _jobId,uint[] calldata _values) external onlyUpdater {\r\n        require(isJobActive[_jobId],\"job closed or not exist\");\r\n        uint g1 = gasleft();\r\n        \r\n        if(breachCheck(_jobId,_values[0])){\r\n            //breachUpdate()\r\n            emit breach(_jobId,\r\n                        jobs[_jobId].creator,\r\n                        jobResponse[_jobId][0],\r\n                        _values[0]\r\n                        );\r\n        }\r\n        \r\n        jobResponse[_jobId] = _values;\r\n        \r\n        uint gasUsed = g1 - gasleft();\r\n        \r\n        if(jobs[_jobId].leftValue < gasUsed + jobFee){\r\n            jobs[_jobId].status = Status.CLOSED;\r\n            isJobActive[_jobId] = false;\r\n            jobsActive -= 1;\r\n        }else{\r\n            totalOwnerFee += jobFee;\r\n            jobs[_jobId].leftValue -= gasUsed + jobFee;\r\n        }\r\n    }\r\n    \r\n    function setFee(uint _fee) public onlyOwner {\r\n        jobFee = _fee;\r\n    }\r\n    \r\n    function deactivateJob(uint64 _jobId) public onlyOwner{\r\n        require(isJobActive[_jobId],\"job closed or not exist\");\r\n        isJobActive[_jobId] = false;\r\n        jobs[_jobId].status = Status.CLOSED;\r\n        jobsActive -= 1;\r\n    }\r\n      function getJobParameters(uint64 _jobId) public onlyUpdater view returns(bytes32[] memory _parameters){\r\n        return jobs[_jobId].parameters;\r\n    }  \r\n   \r\n    \r\n    function addUpdater(address _updater) public onlyOwner{\r\n        isUpdater[_updater] =true;\r\n    }\r\n    \r\n    function getJobIds() public onlyUpdater view returns(uint64[] memory Ids) {\r\n        return jobIds;\r\n    }\r\n    \r\n    function updateJobTrigger(uint64 _jobId,uint _triggerValue) public {\r\n        require(jobs[_jobId].creator == msg.sender,\"unauthorised\");\r\n        jobs[_jobId].triggerValue = _triggerValue;\r\n    }\r\n    \r\n    function getJobResponse(uint64 _jobId) public view returns(uint[] memory _values){\r\n        require(isJobActive[_jobId],\"job closed\");\r\n        return jobResponse[_jobId];\r\n    }\r\n    \r\n    function increasePrepaidValue(uint64 _jobId,uint amount) external payable{\r\n        require(jobs[_jobId].creator == msg.sender,\"unauthorised\");\r\n        require(msg.value == amount);\r\n        jobs[_jobId].prepaidValue = jobs[_jobId].prepaidValue + amount;\r\n        jobs[_jobId].leftValue = jobs[_jobId].leftValue + amount;\r\n        jobs[_jobId].status = Status.ACTIVE;\r\n        isJobActive[_jobId] = true;\r\n        jobsActive += 1;        \r\n    }\r\n    /*==============Shcedule functions===============\r\n    -----------------------------------------------*/\r\n    \r\n    function scheduleFunc(address to ,uint callTime, bytes calldata data , uint fee , uint gaslimit ,uint gasprice)external payable{\r\n        require(msg.value == callFee.add(gaslimit.mul(gasprice)));\r\n        callId += 1;\r\n        totalOwnerFee += callFee; \r\n        calls[callId] = keccak256(abi.encodePacked(to,callTime,data,fee,gaslimit,gasprice));\r\n       \r\n        \r\n        \r\n        emit ScheduleFuncEvent(to ,callTime ,data ,fee , gaslimit ,gasprice,callId);\r\n    }\r\n    \r\n    function execfunct(address to ,uint callTime, bytes calldata data , uint fee , uint gaslimit ,uint gasprice,uint _callId) external onlyUpdater  {\r\n       \r\n       require(calls[_callId] == keccak256(abi.encodePacked(to,callTime,data,fee,gaslimit,gasprice)));\r\n\r\n       (bool txStatus,) = to.call(data);\r\n       \r\n       (bool success,) = to.call{value:gasleft() -200}(\"\");       \r\n       delete calls[_callId];\r\n       \r\n       emit FunctionExec(to,txStatus,success);\r\n\r\n    }\r\n    \r\n    function setCallFee(uint _callFee) public onlyOwner {\r\n         callFee = _callFee;\r\n    }\r\n\r\n    /*==============Helpers============\r\n    ---------------------------------*/\r\n    \r\n    function breachCheck(uint64 _jobId, uint newvalue) private view returns(bool) {\r\n        uint _value = jobResponse[_jobId][0];\r\n        \r\n        if(newvalue >= _value){return false;}\r\n        \r\n        uint change = ((_value - newvalue)*100)/_value ;\r\n        return (change > jobs[_jobId].triggerValue );\r\n    }\r\n    \r\n    \r\n    function bytes32ToString(bytes32 x) public pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n    \r\n    function stringToBytes32(string memory str) public pure returns(bytes32 result){\r\n       assembly {\r\n            result := mload(add(str, 32))\r\n        }\r\n    }\r\n   function withdraw(uint amount) public onlyOwner{\r\n        require(amount<= totalOwnerFee,\"insufficient balance\");\r\n        owner.transfer(amount);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"txStatus\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"reimbursedStatus\",\"type\":\"bool\"}],\"name\":\"FunctionExec\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"callTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gaslimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"callID\",\"type\":\"uint256\"}],\"name\":\"ScheduleFuncEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"jobId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"breach\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"api\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"parameters\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"jobId\",\"type\":\"uint64\"}],\"name\":\"jobCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_updater\",\"type\":\"address\"}],\"name\":\"addUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"callFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"calls\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_api\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"_parameters\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_triggerValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_frequency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_prepaidValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ipfsHashProof\",\"type\":\"uint256\"}],\"name\":\"createJob\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_Id\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_jobId\",\"type\":\"uint64\"}],\"name\":\"deactivateJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"callTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gaslimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_callId\",\"type\":\"uint256\"}],\"name\":\"execfunct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getJobIds\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"Ids\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_jobId\",\"type\":\"uint64\"}],\"name\":\"getJobParameters\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_parameters\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_jobId\",\"type\":\"uint64\"}],\"name\":\"getJobResponse\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_jobId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increasePrepaidValue\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_callFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_updaters\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"isJobActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jobFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"jobs\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"api\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"NoOfParameters\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"triggerValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dataFrequency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prepaidValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leftValue\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hashRequired\",\"type\":\"bool\"},{\"internalType\":\"enum AbacusOracle.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jobsActive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"callTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gaslimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"}],\"name\":\"scheduleFunc\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_callFee\",\"type\":\"uint256\"}],\"name\":\"setCallFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalOwnerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_jobId\",\"type\":\"uint64\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"updateJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_jobId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_triggerValue\",\"type\":\"uint256\"}],\"name\":\"updateJobTrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AbacusOracle","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://03e1c97de2a3e97015df5de17a28d262b516411218087c195896bd35f9eed1db"}]}