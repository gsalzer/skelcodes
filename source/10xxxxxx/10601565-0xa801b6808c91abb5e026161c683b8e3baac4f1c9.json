{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nstruct Account {\r\n    uint256 etherBalance;\r\n    TokenBalance[] tokenBalances;\r\n}\r\n\r\n\r\nstruct TokenBalance {\r\n    bool callSuccess;\r\n    uint256 balance;\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n    function balanceOf(address account) external view returns (uint256 balance);\r\n}\r\n\r\n\r\ninterface AccountWatcherInterface {\r\n    function balancesOf(\r\n        ERC20Interface[] calldata tokens, address[] calldata accounts\r\n    ) external view returns (Account[] memory accountBalances);\r\n}\r\n\r\n\r\n/// Quickly check the Ether balance, as well as the balance of each\r\n/// supplied ERC20 token, for a collection of accounts.\r\n/// @author 0age\r\ncontract AccountWatcher is AccountWatcherInterface {\r\n    function balancesOf(\r\n        ERC20Interface[] calldata tokens, address[] calldata accounts\r\n    ) external view override returns (Account[] memory) {\r\n        Account[] memory accountBalances = new Account[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            address account = accounts[i];\r\n\r\n            TokenBalance[] memory tokenBalances = new TokenBalance[](tokens.length);\r\n\r\n            for (uint256 j = 0; j < tokens.length; j++) {\r\n                ERC20Interface token = tokens[j];\r\n                (bool success, bytes memory returnData) = address(token).staticcall(\r\n                    abi.encodeWithSelector(token.balanceOf.selector, account)\r\n                );\r\n                \r\n                if (success && returnData.length == 32) {\r\n                    TokenBalance memory tokenBalance;\r\n                    \r\n                    tokenBalance.callSuccess = true;\r\n                    tokenBalance.balance = abi.decode(returnData, (uint256));\r\n                    \r\n                    tokenBalances[j] = tokenBalance;\r\n                }\r\n            }\r\n\r\n            accountBalances[i].etherBalance = account.balance;\r\n            accountBalances[i].tokenBalances = tokenBalances;\r\n        }\r\n\r\n        return accountBalances;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ERC20Interface[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"balancesOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"etherBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"callSuccess\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenBalance[]\",\"name\":\"tokenBalances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Account[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AccountWatcher","CompilerVersion":"v0.6.9+commit.3e3065ac","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://76eb940c7f42898718a81e33889bdd38e26a953bc97f6e2ce0b8a6b0ce51e5d7"}]}