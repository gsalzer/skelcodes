{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/InterFaces/IERC20Token.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IERC20Token {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n}\r\n\r\n// File: contracts/InterFaces/IAuctionRegistery.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract AuctionRegisteryContracts {\r\n    bytes32 internal constant MAIN_TOKEN = \"MAIN_TOKEN\";\r\n    bytes32 internal constant ETN_TOKEN = \"ETN_TOKEN\";\r\n    bytes32 internal constant STOCK_TOKEN = \"STOCK_TOKEN\";\r\n    bytes32 internal constant WHITE_LIST = \"WHITE_LIST\";\r\n    bytes32 internal constant AUCTION = \"AUCTION\";\r\n    bytes32 internal constant AUCTION_PROTECTION = \"AUCTION_PROTECTION\";\r\n    bytes32 internal constant LIQUIDITY = \"LIQUIDITY\";\r\n    bytes32 internal constant CURRENCY = \"CURRENCY\";\r\n    bytes32 internal constant VAULT = \"VAULT\";\r\n    bytes32 internal constant CONTRIBUTION_TRIGGER = \"CONTRIBUTION_TRIGGER\";\r\n    bytes32 internal constant COMPANY_FUND_WALLET = \"COMPANY_FUND_WALLET\";\r\n    bytes32 internal constant SMART_SWAP = \"SMART_SWAP\";\r\n    bytes32 internal constant SMART_SWAP_P2P = \"SMART_SWAP_P2P\";\r\n    bytes32 internal constant ESCROW = \"ESCROW\";\r\n}\r\n\r\ninterface IAuctionRegistery {\r\n    function getAddressOf(bytes32 _contractName)\r\n        external\r\n        view\r\n        returns (address payable);\r\n}\r\n\r\n// File: contracts/Liquidity/LiquidityStorage.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\ncontract LiquidityStorage {\r\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    uint256 public constant BIG_NOMINATOR = 10**24;\r\n    uint256 public constant DECIMAL_NOMINATOR = 10**18;\r\n    uint256 public constant PRICE_NOMINATOR = 10**9;\r\n\r\n    address public converter;\r\n\r\n    address public bancorNetwork;\r\n\r\n    address public baseToken; // basetoken\r\n\r\n    address public mainToken; // maintoken\r\n\r\n    address public relayToken; // relayToken\r\n\r\n    address public etherToken; // etherToken\r\n\r\n    address public ethRelayToken; // ether to baseToken RelayToken\r\n\r\n    // registery of all contacrt\r\n    IAuctionRegistery public contractsRegistry;\r\n\r\n    address payable public whiteListAddress;\r\n    address payable public vaultAddress;\r\n    address payable public auctionAddress;\r\n    address payable public triggerAddress;\r\n    address payable public currencyPricesAddress;\r\n    address payable public escrowAddress;\r\n\r\n    // _path = 0 ether to maint token conversion path\r\n    address[] public ethToMainToken;\r\n    // _path = 1 basetoken to mainToken conversion path\r\n    address[] public baseTokenToMainToken;\r\n    // _path = 2 mainToken to basetoken conversion path\r\n    address[] public mainTokenTobaseToken;\r\n    // _path = 3 ether to baseToken conversion path\r\n    address[] public ethToBaseToken;\r\n    // _path = 4  basetoken to ether conversion path\r\n    address[] public baseTokenToEth;\r\n\r\n    IERC20Token[] public relayPath;\r\n\r\n    uint256[] public returnAmountRelay;\r\n\r\n    // side reserve ratio split between bancor and side reserve\r\n    uint256 public sideReseverRatio;\r\n\r\n    // 1:1 investment ratio\r\n    uint256 public tagAlongRatio;\r\n\r\n    // token price increase from yesterday limit 120%\r\n    uint256 public appreciationLimit;\r\n\r\n    // token price increase in decimal place\r\n    uint256 public appreciationLimitWithDecimal;\r\n\r\n    // contribution reduction start day\r\n    uint256 public reductionStartDay;\r\n\r\n    // basetoken price change ratio\r\n    uint256 public baseTokenVolatiltyRatio;\r\n\r\n    // reduction limit\r\n    uint256 public virtualReserverDivisor;\r\n\r\n    // previous day contribution in bancor\r\n    uint256 public previousMainReserveContribution;\r\n\r\n    // current day contribution in bancor\r\n    uint256 public todayMainReserveContribution;\r\n\r\n    // auction end day price of token\r\n    uint256 public tokenAuctionEndPrice;\r\n\r\n    // last reserve balance in bancor\r\n    uint256 public lastReserveBalance;\r\n\r\n    // basetoken starting price\r\n    uint256 public baseLinePrice;\r\n\r\n    // maxIteration for finding root\r\n    uint256 public maxIteration;\r\n\r\n    // check if today token price reach certain level\r\n    bool public isAppreciationLimitReached;\r\n\r\n    uint256 public relayPercent;\r\n\r\n    // mapping for where user last reddeem\r\n    mapping(address => uint256) public lastReedeemDay;\r\n\r\n    event Contribution(address _token, uint256 _amount, uint256 returnAmount);\r\n    event RecoverPrice(uint256 _oldPrice, uint256 _newPrice);\r\n    event Redemption(address _token, uint256 _amount, uint256 returnAmount);\r\n    event FundDeposited(address _token, address indexed _from, uint256 _amount);\r\n}\r\n\r\n// File: contracts/common/SafeMath.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function safeExponent(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 result;\r\n        assembly {\r\n            result := exp(a, b)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // calculates a^(1/n) to dp decimal places\r\n    // maxIts bounds the number of iterations performed\r\n    function nthRoot(\r\n        uint256 _a,\r\n        uint256 _n,\r\n        uint256 _dp,\r\n        uint256 _maxIts\r\n    ) internal pure returns (uint256) {\r\n        assert(_n > 1);\r\n\r\n        // The scale factor is a crude way to turn everything into integer calcs.\r\n        // Actually do (a * (10 ^ ((dp + 1) * n))) ^ (1/n)\r\n        // We calculate to one extra dp and round at the end\r\n        uint256 one = 10**(1 + _dp);\r\n        uint256 a0 = one**_n * _a;\r\n\r\n        // Initial guess: 1.0\r\n        uint256 xNew = one;\r\n        uint256 x;\r\n\r\n        uint256 iter = 0;\r\n        while (xNew != x && iter < _maxIts) {\r\n            x = xNew;\r\n            uint256 t0 = x**(_n - 1);\r\n            if (x * t0 > a0) {\r\n                xNew = x - (x - a0 / t0) / _n;\r\n            } else {\r\n                xNew = x + (a0 / t0 - x) / _n;\r\n            }\r\n            ++iter;\r\n        }\r\n\r\n        // Round to nearest in the last dp.\r\n        return (xNew + 5) / 10;\r\n    }\r\n}\r\n\r\n// File: contracts/common/Constant.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract Constant {\r\n    string constant ERR_CONTRACT_SELF_ADDRESS = \"ERR_CONTRACT_SELF_ADDRESS\";\r\n\r\n    string constant ERR_ZERO_ADDRESS = \"ERR_ZERO_ADDRESS\";\r\n\r\n    string constant ERR_NOT_OWN_ADDRESS = \"ERR_NOT_OWN_ADDRESS\";\r\n\r\n    string constant ERR_VALUE_IS_ZERO = \"ERR_VALUE_IS_ZERO\";\r\n\r\n    string constant ERR_SAME_ADDRESS = \"ERR_SAME_ADDRESS\";\r\n\r\n    string constant ERR_AUTHORIZED_ADDRESS_ONLY = \"ERR_AUTHORIZED_ADDRESS_ONLY\";\r\n\r\n    modifier notOwnAddress(address _which) {\r\n        require(msg.sender != _which, ERR_NOT_OWN_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // validates an address is not zero\r\n    modifier notZeroAddress(address _which) {\r\n        require(_which != address(0), ERR_ZERO_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThisAddress(address _which) {\r\n        require(_which != address(this), ERR_CONTRACT_SELF_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    modifier notZeroValue(uint256 _value) {\r\n        require(_value > 0, ERR_VALUE_IS_ZERO);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/common/ProxyOwnable.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\ncontract ProxyOwnable is Constant {\r\n    \r\n    address public primaryOwner;\r\n\r\n    address public authorityAddress;\r\n\r\n    address public newAuthorityAddress;\r\n\r\n    address public systemAddress;\r\n    \r\n    bool public isOwnerInitialize = false;\r\n\r\n    event OwnershipTransferred(\r\n        string ownerType,\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    \r\n    event AuthorityAddressChnageCall(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the `primaryOwner` and `systemAddress` and '_multisigAddress'\r\n     * account.\r\n     */\r\n\r\n    function initializeOwner(\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress\r\n    ) internal notZeroAddress(_primaryOwner) notZeroAddress(_systemAddress) notZeroAddress(_authorityAddress) {\r\n        \r\n        require(!isOwnerInitialize,\"ERR_OWNER_INTIALIZED_ALREADY\");\r\n        \r\n        require(_primaryOwner != _systemAddress, ERR_SAME_ADDRESS);\r\n        \r\n        require(_systemAddress != _authorityAddress, ERR_SAME_ADDRESS);\r\n        \r\n        require(_primaryOwner != _authorityAddress, ERR_SAME_ADDRESS);\r\n        \r\n        primaryOwner = _primaryOwner;\r\n        systemAddress = _systemAddress;\r\n        authorityAddress = _authorityAddress;\r\n        isOwnerInitialize = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == primaryOwner, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    modifier onlySystem() {\r\n        require(msg.sender == systemAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOneOfOnwer() {\r\n        require(\r\n            msg.sender == primaryOwner || msg.sender == systemAddress,\r\n            ERR_AUTHORIZED_ADDRESS_ONLY\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == authorityAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev change primary ownership governance \r\n     */\r\n    function changePrimaryOwner()\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        emit OwnershipTransferred(\"PRIMARY_OWNER\", primaryOwner, authorityAddress);\r\n        primaryOwner = authorityAddress;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change system address\r\n     * @param _which The address to which is new system address\r\n     */\r\n    function changeSystemAddress(address _which)\r\n        public\r\n        onlyAuthorized()\r\n        notThisAddress(_which)\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _which != systemAddress &&\r\n                _which != authorityAddress &&\r\n                _which != primaryOwner,\r\n            ERR_SAME_ADDRESS\r\n        );\r\n        emit OwnershipTransferred(\"SYSTEM_ADDRESS\", systemAddress, _which);\r\n        systemAddress = _which;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change system address\r\n     * @param _which The address to which is new Authority address\r\n     */\r\n    function changeAuthorityAddress(address _which)\r\n        public\r\n        onlyAuthorized()\r\n        notZeroAddress(_which)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _which != systemAddress &&\r\n                _which != authorityAddress,\r\n            ERR_SAME_ADDRESS\r\n        );\r\n        newAuthorityAddress = _which;\r\n        return true;\r\n    }\r\n\r\n    function acceptAuthorityAddress() public returns (bool) {\r\n        require(msg.sender == newAuthorityAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        emit OwnershipTransferred(\r\n            \"AUTHORITY_ADDRESS\",\r\n            authorityAddress,\r\n            newAuthorityAddress\r\n        );\r\n        authorityAddress = newAuthorityAddress;\r\n        newAuthorityAddress = address(0);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/common/TokenTransfer.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ncontract TokenTransfer {\r\n    function ensureTransferFrom(\r\n        IERC20Token _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal {\r\n        if (_from == address(this))\r\n            require(_token.transfer(_to, _amount), \"ERR_TOKEN_TRANSFER_FAIL\");\r\n        else\r\n            require(\r\n                _token.transferFrom(_from, _to, _amount),\r\n                \"ERR_TOKEN_TRANSFER_FAIL\"\r\n            );\r\n    }\r\n\r\n    function approveTransferFrom(\r\n        IERC20Token _token,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal {\r\n        require(_token.approve(_spender, _amount), \"ERR_TOKEN_APPROVAL_FAIL\");\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy/IRegistry.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * @title IRegistry\r\n * @dev This contract represents the interface of a registry contract\r\n */\r\ninterface IRegistry {\r\n    /**\r\n     * @dev This event will be emitted every time a new proxy is created\r\n     * @param proxy representing the address of the proxy created\r\n     */\r\n    event ProxyCreated(address proxy);\r\n\r\n    /**\r\n     * @dev This event will be emitted every time a new implementation is registered\r\n     * @param version representing the version name of the registered implementation\r\n     * @param implementation representing the address of the registered implementation\r\n     */\r\n    event VersionAdded(uint256 version, address implementation);\r\n\r\n    /**\r\n     * @dev Registers a new version with its implementation address\r\n     * @param version representing the version name of the new implementation to be registered\r\n     * @param implementation representing the address of the new implementation to be registered\r\n     */\r\n    function addVersion(uint256  version, address implementation)\r\n        external;\r\n\r\n    /**\r\n     * @dev Tells the address of the implementation for a given version\r\n     * @param version to query the implementation of\r\n     * @return address of the implementation registered for the given version\r\n     */\r\n    function getVersion(uint256 version)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/Proxy/Proxy.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n     * @dev Tells the address of the implementation where every call will be delegated.\r\n     * @return address of the implementation to which it will be delegated\r\n     */\r\n    function implementation() public view returns (address);\r\n\r\n    /**\r\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n     * This function will return whatever the implementation call returns\r\n     */\r\n    \r\n    function() external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0),\"ERR_IMPLEMENTEION_ZERO\");\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }  \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n}\r\n\r\n// File: contracts/Proxy/UpgradeabilityStorage.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityStorage\r\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\r\n */\r\ncontract UpgradeabilityStorage is Proxy {\r\n    // Versions registry\r\n    IRegistry public registry;\r\n\r\n    // Address of the current implementation\r\n    address internal _implementation;\r\n\r\n    /**\r\n     * @dev Tells the address of the current implementation\r\n     * @return address of the current implementation\r\n     */\r\n    function implementation() public view returns (address) {\r\n        return _implementation;\r\n    }\r\n}\r\n\r\n// File: contracts/Proxy/Upgradeable.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title Upgradeable\r\n * @dev This contract holds all the minimum required functionality for a behavior to be upgradeable.\r\n * This means, required state variables for owned upgradeability purpose and simple initialization validation.\r\n */\r\ncontract Upgradeable is UpgradeabilityStorage {\r\n    /**\r\n     * @dev Validates the caller is the versions registry.\r\n     * THIS FUNCTION SHOULD BE OVERRIDDEN CALLING SUPER\r\n     */\r\n    function initialize() public view {\r\n        require(msg.sender == address(registry),\"ERR_ONLY_REGISTRERY_CAN_CALL\");\r\n    }\r\n}\r\n\r\n// File: contracts/InterFaces/IContributionTrigger.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface IContributionTrigger {\r\n    function depositeToken(\r\n        IERC20Token _token,\r\n        address _from,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    function contributeTowardLiquidity(uint256 _amount)\r\n        external\r\n        returns (uint256);\r\n\r\n    function transferTokenLiquidity(\r\n        IERC20Token _token,\r\n        address _reciver,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/InterFaces/ICurrencyPrices.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ninterface ICurrencyPrices {\r\n    function getCurrencyPrice(address _which) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/InterFaces/IAuction.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ninterface IAuction {\r\n    \r\n    function dayWiseMarketPrice(uint256 dayId) external view returns(uint256);\r\n    \r\n    function dayWiseContribution(uint256 dayId) external view returns(uint256);\r\n    \r\n    function auctionDay() external returns(uint256);\r\n        \r\n}\r\n\r\n// File: contracts/InterFaces/ITokenVault.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\ninterface ITokenVault {\r\n    function depositeToken(\r\n        IERC20Token _token,\r\n        address _from,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    function directTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transferEther(address payable _to, uint256 amount)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/InterFaces/IWhiteList.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ninterface IWhiteList {\r\n    function address_belongs(address _who) external view returns (address);\r\n\r\n    function isWhiteListed(address _who) external view returns (bool);\r\n\r\n    function isAllowedInAuction(address _which) external view returns (bool);\r\n\r\n    function isAddressByPassed(address _which) external view returns (bool);\r\n\r\n    function isExchangeAddress(address _which) external view returns (bool);\r\n\r\n    function main_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) external view returns (bool);\r\n\r\n    function etn_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) external view returns (bool);\r\n\r\n    function stock_isTransferAllowed(\r\n        address _msgSender,\r\n        address _from,\r\n        address _to\r\n    ) external view returns (bool);\r\n\r\n    function addWalletBehalfExchange(address _mainWallet, address _subWallet)\r\n        external\r\n        returns (bool);\r\n\r\n    function main_isReceiveAllowed(address user) external view returns (bool);\r\n\r\n    function etn_isReceiveAllowed(address user) external view returns (bool);\r\n\r\n    function stock_isReceiveAllowed(address user) external view returns (bool);\r\n}\r\n\r\n// File: contracts/Liquidity/AuctionLiquidity.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface LiquidityInitializeInterface {\r\n    function initialize(\r\n        address _converter,\r\n        address _baseToken,\r\n        address _mainToken,\r\n        address _relayToken,\r\n        address _etherToken,\r\n        address _ethRelayToken,\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress,\r\n        address _registryaddress,\r\n        uint256 _baseLinePrice\r\n    ) external;\r\n}\r\n\r\ninterface IBancorNetwork {\r\n    function etherTokens(address _address) external view returns (bool);\r\n\r\n    function rateByPath(address[] calldata _path, uint256 _amount)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function convertByPath(\r\n        address[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address payable _beneficiary,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) external payable returns (uint256);\r\n}\r\n\r\ninterface IContractRegistry {\r\n    function addressOf(bytes32 _contractName) external view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) external view returns (address);\r\n}\r\n\r\ninterface IEtherToken {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 _amount) external;\r\n\r\n    function withdrawTo(address _to, uint256 _amount) external;\r\n}\r\n\r\ninterface IBancorConverter {\r\n    function registry() external view returns (address);\r\n\r\n    function reserves(address _address)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint32,\r\n            bool,\r\n            bool,\r\n            bool\r\n        );\r\n\r\n    function removeLiquidity(\r\n        uint256 _amount,\r\n        IERC20Token[] calldata _reserveTokens,\r\n        uint256[] calldata _reserveMinReturnAmounts\r\n    ) external;\r\n}\r\n\r\ncontract BancorConverterLiquidity is ProxyOwnable, SafeMath, LiquidityStorage {\r\n    function updateConverter(address _converter)\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        converter = _converter;\r\n        return true;\r\n    }\r\n\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        address _registry = IBancorConverter(converter).registry();\r\n        IContractRegistry registry = IContractRegistry(_registry);\r\n        return registry.addressOf(_contractName);\r\n    }\r\n\r\n    function getTokensReserveRatio()\r\n        internal\r\n        view\r\n        returns (uint256 _baseTokenRatio, uint256 _mainTokenRatio)\r\n    {\r\n        uint256 a;\r\n        bool c;\r\n        bool d;\r\n        bool e;\r\n        (a, _baseTokenRatio, c, d, e) = IBancorConverter(converter).reserves(\r\n            address(baseToken)\r\n        );\r\n        (a, _mainTokenRatio, c, d, e) = IBancorConverter(converter).reserves(\r\n            address(mainToken)\r\n        );\r\n        return (_baseTokenRatio, _mainTokenRatio);\r\n    }\r\n\r\n    function etherTokens(address _address) internal view returns (bool) {\r\n        IBancorNetwork network = IBancorNetwork(bancorNetwork);\r\n        return network.etherTokens(_address);\r\n    }\r\n\r\n    function getReturnByPath(address[] memory _path, uint256 _amount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        IBancorNetwork network = IBancorNetwork(bancorNetwork);\r\n        return network.rateByPath(_path, _amount);\r\n    }\r\n}\r\n\r\ncontract RegisteryLiquidity is\r\n    BancorConverterLiquidity,\r\n    AuctionRegisteryContracts\r\n{\r\n    function updateRegistery(address _address)\r\n        external\r\n        onlyAuthorized()\r\n        notZeroAddress(_address)\r\n        returns (bool)\r\n    {\r\n        contractsRegistry = IAuctionRegistery(_address);\r\n        _updateAddresses();\r\n        return true;\r\n    }\r\n\r\n    function getAddressOf(bytes32 _contractName)\r\n        internal\r\n        view\r\n        returns (address payable)\r\n    {\r\n        return contractsRegistry.getAddressOf(_contractName);\r\n    }\r\n\r\n    /**@dev updates all the address from the registry contract\r\n    this decision was made to save gas that occurs from calling an external view function */\r\n\r\n    function _updateAddresses() internal {\r\n        whiteListAddress = getAddressOf(WHITE_LIST);\r\n        currencyPricesAddress = getAddressOf(CURRENCY);\r\n        vaultAddress = getAddressOf(VAULT);\r\n        triggerAddress = getAddressOf(CONTRIBUTION_TRIGGER);\r\n        auctionAddress = getAddressOf(AUCTION);\r\n        escrowAddress = getAddressOf(ESCROW);\r\n\r\n        // bancor network\r\n        bancorNetwork = addressOf(BANCOR_NETWORK);\r\n    }\r\n\r\n    function updateAddresses() external returns (bool) {\r\n        _updateAddresses();\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract LiquidityUtils is RegisteryLiquidity {\r\n    modifier allowedAddressOnly(address _which) {\r\n        require(_which == auctionAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    function _updateTokenPath() internal returns (bool) {\r\n        ethToMainToken = [\r\n            etherToken,\r\n            ethRelayToken,\r\n            baseToken,\r\n            relayToken,\r\n            mainToken\r\n        ];\r\n        baseTokenToMainToken = [baseToken, relayToken, mainToken];\r\n        mainTokenTobaseToken = [mainToken, relayToken, baseToken];\r\n        ethToBaseToken = [etherToken, ethRelayToken, baseToken];\r\n        baseTokenToEth = [baseToken, ethRelayToken, etherToken];\r\n        relayPath = [IERC20Token(mainToken), IERC20Token(baseToken)];\r\n        returnAmountRelay = [1, 1];\r\n        return true;\r\n    }\r\n\r\n    // this is for bnt an eth token only\r\n    function updateTokenPath() external returns (bool) {\r\n        return _updateTokenPath();\r\n    }\r\n\r\n    function setSideReseverRatio(uint256 _sideReseverRatio)\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        require(_sideReseverRatio < 100, \"ERR_RATIO_CANT_BE_GREATER_THAN_100\");\r\n        sideReseverRatio = _sideReseverRatio;\r\n        return true;\r\n    }\r\n\r\n    function setTagAlongRatio(uint256 _tagAlongRatio)\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        tagAlongRatio = _tagAlongRatio;\r\n        return true;\r\n    }\r\n\r\n    function setAppreciationLimit(uint256 _limit)\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        appreciationLimit = _limit;\r\n        appreciationLimitWithDecimal = safeMul(_limit, DECIMAL_NOMINATOR);\r\n        return true;\r\n    }\r\n\r\n    function setBaseTokenVolatiltyRatio(uint256 _baseTokenVolatiltyRatio)\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        baseTokenVolatiltyRatio = _baseTokenVolatiltyRatio;\r\n        return true;\r\n    }\r\n\r\n    function setReductionStartDay(uint256 _reductionStartDay)\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        reductionStartDay = _reductionStartDay;\r\n        return true;\r\n    }\r\n\r\n    function setRelayPercent(uint256 _relayPercent)\r\n        public\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        require(_relayPercent < 99);\r\n        relayPercent = _relayPercent;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract LiquidityFormula is LiquidityUtils {\r\n    // current market price calculate according to baseLinePrice\r\n    // if baseToken Price differ from\r\n    function _getCurrentMarketPrice() internal view returns (uint256) {\r\n        uint256 _mainTokenBalance = IERC20Token(mainToken).balanceOf(converter);\r\n\r\n        (\r\n            uint256 _baseTokenRatio,\r\n            uint256 _mainTokenRatio\r\n        ) = getTokensReserveRatio();\r\n\r\n        uint256 ratio = safeDiv(\r\n            safeMul(\r\n                safeMul(lastReserveBalance, _mainTokenRatio),\r\n                BIG_NOMINATOR\r\n            ),\r\n            safeMul(_mainTokenBalance, _baseTokenRatio)\r\n        );\r\n\r\n        return safeDiv(safeMul(ratio, baseLinePrice), BIG_NOMINATOR);\r\n    }\r\n\r\n    function calculateLiquidityMainReserve(\r\n        uint256 yesterdayPrice,\r\n        uint256 dayBeforyesterdayPrice,\r\n        uint256 yesterDaycontibution,\r\n        uint256 yesterdayMainReserv\r\n    ) internal pure returns (uint256) {\r\n        // multiply 10**9 so we cant get zero value if amount come in float\r\n\r\n        uint256 _tempContrbution = safeDiv(\r\n            safeMul(yesterDaycontibution, PRICE_NOMINATOR),\r\n            yesterdayMainReserv\r\n        );\r\n\r\n        uint256 _tempRatio = safeDiv(\r\n            safeMul(yesterdayPrice, PRICE_NOMINATOR),\r\n            dayBeforyesterdayPrice\r\n        );\r\n\r\n        _tempRatio = safeMul(_tempContrbution, _tempRatio);\r\n\r\n        if (_tempRatio > DECIMAL_NOMINATOR) {\r\n            return _tempRatio;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Liquidity is\r\n    Upgradeable,\r\n    LiquidityFormula,\r\n    TokenTransfer,\r\n    LiquidityInitializeInterface\r\n{\r\n    function initialize(\r\n        address _converter,\r\n        address _baseToken,\r\n        address _mainToken,\r\n        address _relayToken,\r\n        address _etherToken,\r\n        address _ethRelayToken,\r\n        address _primaryOwner,\r\n        address _systemAddress,\r\n        address _authorityAddress,\r\n        address _registryaddress,\r\n        uint256 _baseLinePrice\r\n    ) public {\r\n        super.initialize();\r\n        initializeOwner(_primaryOwner, _systemAddress, _authorityAddress);\r\n\r\n        converter = _converter;\r\n        baseLinePrice = _baseLinePrice;\r\n        sideReseverRatio = 70;\r\n        appreciationLimit = 120;\r\n        tagAlongRatio = 100;\r\n        reductionStartDay = 21;\r\n        maxIteration = 35;\r\n        relayPercent = 10;\r\n        appreciationLimitWithDecimal = safeMul(120, DECIMAL_NOMINATOR);\r\n        baseTokenVolatiltyRatio = 5 * PRICE_NOMINATOR;\r\n\r\n        baseToken = _baseToken;\r\n        mainToken = _mainToken;\r\n        relayToken = _relayToken;\r\n        etherToken = _etherToken;\r\n        ethRelayToken = _ethRelayToken;\r\n\r\n        contractsRegistry = IAuctionRegistery(_registryaddress);\r\n        lastReserveBalance = IERC20Token(baseToken).balanceOf(converter);\r\n        tokenAuctionEndPrice = _getCurrentMarketPrice();\r\n        _updateAddresses();\r\n        _updateTokenPath();\r\n    }\r\n\r\n    function _contributeWithEther(uint256 value) internal returns (uint256) {\r\n        uint256 lastBalance = IERC20Token(baseToken).balanceOf(converter);\r\n\r\n        if (lastBalance != lastReserveBalance) {\r\n            _recoverPriceDueToManipulation();\r\n        }\r\n\r\n        uint256 returnAmount = IBancorNetwork(bancorNetwork)\r\n            .convertByPath\r\n            .value(value)(\r\n            ethToMainToken,\r\n            value,\r\n            1,\r\n            vaultAddress,\r\n            address(0),\r\n            0\r\n        );\r\n\r\n        todayMainReserveContribution = safeAdd(\r\n            todayMainReserveContribution,\r\n            value\r\n        );\r\n\r\n        emit Contribution(address(0), value, returnAmount);\r\n        lastReserveBalance = IERC20Token(baseToken).balanceOf(converter);\r\n        checkAppeciationLimit();\r\n        return returnAmount;\r\n    }\r\n\r\n    //convert base token token into ether\r\n    function _convertBaseTokenToEth() internal {\r\n        uint256 _baseTokenBalance = IERC20Token(baseToken).balanceOf(\r\n            address(this)\r\n        );\r\n\r\n        if (_baseTokenBalance > 0) {\r\n            if (etherTokens(baseToken)) {\r\n                IEtherToken(baseToken).withdraw(_baseTokenBalance);\r\n            } else {\r\n                approveTransferFrom(\r\n                    IERC20Token(baseToken),\r\n                    bancorNetwork,\r\n                    _baseTokenBalance\r\n                );\r\n                IBancorNetwork(bancorNetwork).convertByPath.value(0)(\r\n                    baseTokenToEth,\r\n                    _baseTokenBalance,\r\n                    1,\r\n                    address(0),\r\n                    address(0),\r\n                    0\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    //This method return token base on wich is last address\r\n    //If last address is ethtoken it will return ether\r\n    function _convertWithToken(uint256 value, address[] memory _path)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        approveTransferFrom(IERC20Token(_path[0]), bancorNetwork, value);\r\n\r\n        address payable sentBackAddress;\r\n\r\n        if (_path[safeSub(_path.length, 1)] == mainToken) {\r\n            sentBackAddress = vaultAddress;\r\n        }\r\n        IBancorNetwork(bancorNetwork).convertByPath.value(0)(\r\n            _path,\r\n            value,\r\n            1,\r\n            sentBackAddress,\r\n            address(0),\r\n            0\r\n        );\r\n\r\n        _convertBaseTokenToEth();\r\n        lastReserveBalance = IERC20Token(baseToken).balanceOf(converter);\r\n        return true;\r\n    }\r\n\r\n    function checkAppeciationLimit() internal returns (bool) {\r\n        uint256 tokenCurrentPrice = _getCurrentMarketPrice();\r\n\r\n        uint256 _appreciationReached = safeDiv(\r\n            safeMul(tokenCurrentPrice, safeMul(100, DECIMAL_NOMINATOR)),\r\n            tokenAuctionEndPrice\r\n        );\r\n\r\n        if (_appreciationReached > appreciationLimitWithDecimal) {\r\n            isAppreciationLimitReached = true;\r\n            _priceRecoveryWithConvertMainToken(_appreciationReached);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // when we have zero contibution towards auction\r\n    // this method called from auction contarct\r\n    // this method sell 10% realy and convert into ether if there\r\n    // is no ether into tagAlong\r\n    function contributeTowardMainReserve()\r\n        external\r\n        allowedAddressOnly(msg.sender)\r\n        returns (uint256)\r\n    {\r\n        if (address(this).balance < previousMainReserveContribution) {\r\n            while (previousMainReserveContribution >= address(this).balance) {\r\n                _liquadate(safeMul(relayPercent, PRICE_NOMINATOR));\r\n                _convertBaseTokenToEth();\r\n                if (address(this).balance >= previousMainReserveContribution) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        _contributeWithEther(previousMainReserveContribution);\r\n        return previousMainReserveContribution;\r\n    }\r\n\r\n    function contributeWithEther()\r\n        public\r\n        payable\r\n        allowedAddressOnly(msg.sender)\r\n        returns (uint256)\r\n    {\r\n        uint256 _amount = msg.value;\r\n\r\n        uint256 sideReseverAmount = safeDiv(\r\n            safeMul(_amount, sideReseverRatio),\r\n            100\r\n        );\r\n\r\n        uint256 mainReserverAmount = safeSub(_amount, sideReseverAmount);\r\n        if (virtualReserverDivisor > 0)\r\n            mainReserverAmount = safeDiv(\r\n                safeMul(mainReserverAmount, DECIMAL_NOMINATOR),\r\n                virtualReserverDivisor\r\n            );\r\n\r\n        if (isAppreciationLimitReached) {\r\n            return _getCurrentMarketPrice();\r\n        }\r\n\r\n        uint256 tagAlongAmount = safeDiv(\r\n            safeMul(mainReserverAmount, tagAlongRatio),\r\n            100\r\n        );\r\n\r\n        if (tagAlongAmount > address(this).balance)\r\n            mainReserverAmount = safeAdd(\r\n                mainReserverAmount,\r\n                address(this).balance\r\n            );\r\n        else mainReserverAmount = safeAdd(mainReserverAmount, tagAlongAmount);\r\n\r\n        _contributeWithEther(mainReserverAmount);\r\n        return _getCurrentMarketPrice();\r\n    }\r\n\r\n    function _recoverReserve(bool isMainToken, uint256 _liquadateRatio)\r\n        internal\r\n    {\r\n        (uint256 returnBase, uint256 returnMain) = _liquadate(_liquadateRatio);\r\n\r\n        if (isMainToken) {\r\n            ITokenVault(vaultAddress).directTransfer(\r\n                mainToken,\r\n                converter,\r\n                returnMain\r\n            );\r\n        } else {\r\n            ensureTransferFrom(\r\n                IERC20Token(baseToken),\r\n                address(this),\r\n                converter,\r\n                returnBase\r\n            );\r\n        }\r\n\r\n        lastReserveBalance = IERC20Token(baseToken).balanceOf(converter);\r\n    }\r\n\r\n    function recoverPriceVolatility() external returns (bool) {\r\n        _recoverPriceDueToManipulation();\r\n\r\n        uint256 baseTokenPrice = ICurrencyPrices(currencyPricesAddress)\r\n            .getCurrencyPrice(address(baseToken));\r\n\r\n        uint256 volatilty;\r\n\r\n        bool isMainToken;\r\n\r\n        if (baseTokenPrice > baseLinePrice) {\r\n            volatilty = safeDiv(\r\n                safeMul(\r\n                    safeSub(baseTokenPrice, baseLinePrice),\r\n                    safeMul(100, PRICE_NOMINATOR)\r\n                ),\r\n                baseTokenPrice\r\n            );\r\n            isMainToken = true;\r\n        } else if (baseLinePrice > baseTokenPrice) {\r\n            volatilty = safeDiv(\r\n                safeMul(\r\n                    safeSub(baseLinePrice, baseTokenPrice),\r\n                    safeMul(100, PRICE_NOMINATOR)\r\n                ),\r\n                baseLinePrice\r\n            );\r\n            isMainToken = false;\r\n        }\r\n\r\n        if (volatilty >= baseTokenVolatiltyRatio) {\r\n            _recoverReserve(isMainToken, volatilty);\r\n        }\r\n        baseLinePrice = baseTokenPrice;\r\n        return true;\r\n    }\r\n\r\n    function _recoverPriceDueToManipulation() internal returns (bool) {\r\n        uint256 volatilty;\r\n\r\n        uint256 _baseTokenBalance = IERC20Token(baseToken).balanceOf(converter);\r\n        bool isMainToken;\r\n\r\n        if (_baseTokenBalance > lastReserveBalance) {\r\n            volatilty = safeDiv(\r\n                safeMul(\r\n                    safeSub(_baseTokenBalance, lastReserveBalance),\r\n                    safeMul(100, PRICE_NOMINATOR)\r\n                ),\r\n                _baseTokenBalance\r\n            );\r\n\r\n            isMainToken = true;\r\n            _recoverReserve(isMainToken, volatilty);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function recoverPriceDueToManipulation() external returns (bool) {\r\n        return _recoverPriceDueToManipulation();\r\n    }\r\n\r\n    // recover price from main token\r\n    // if there is not enough main token sell 10% relay\r\n    // this is very rare case where vault dont have balance\r\n    // At 35th round we get excat value in fraction\r\n    // we dont value in decimal we already provide _percent with decimal\r\n    function _priceRecoveryWithConvertMainToken(uint256 _percent)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint256 tempX = safeDiv(_percent, appreciationLimit);\r\n        uint256 root = nthRoot(tempX, 2, 0, maxIteration);\r\n        uint256 _tempValue = safeSub(root, PRICE_NOMINATOR);\r\n        uint256 _supply = IERC20Token(mainToken).balanceOf(converter);\r\n\r\n        uint256 _reverseBalance = safeDiv(\r\n            safeMul(_supply, _tempValue),\r\n            PRICE_NOMINATOR\r\n        );\r\n\r\n        uint256 vaultBalance = IERC20Token(mainToken).balanceOf(vaultAddress);\r\n\r\n        if (vaultBalance >= _reverseBalance) {\r\n            ITokenVault(vaultAddress).directTransfer(\r\n                address(mainToken),\r\n                address(this),\r\n                _reverseBalance\r\n            );\r\n            return _convertWithToken(_reverseBalance, mainTokenTobaseToken);\r\n        } else {\r\n            uint256 converterBalance = IERC20Token(mainToken).balanceOf(\r\n                converter\r\n            );\r\n\r\n            uint256 _tempRelayPercent = relayPercent;\r\n\r\n            if (converterBalance > _reverseBalance)\r\n                _tempRelayPercent = safeDiv(\r\n                    safeMul(\r\n                        safeSub(converterBalance, _reverseBalance),\r\n                        safeMul(100, PRICE_NOMINATOR)\r\n                    ),\r\n                    _reverseBalance\r\n                );\r\n            _liquadate(safeMul(_tempRelayPercent, PRICE_NOMINATOR));\r\n            return _priceRecoveryWithConvertMainToken(_percent);\r\n        }\r\n    }\r\n    \r\n\r\n    // if not have enough ether we sell relay \r\n    // exmple reserve have 100 token and we need 25 token to recover \r\n    // we need to sell 25% relay \r\n    // _amount*100/reserveBalance\r\n    // (25*100)/100 so we get 25%\r\n    // we multiply it with price PRICE_NOMINATOR so we can get excat amount \r\n    function _recoverAfterRedemption(uint256 _amount) internal returns (bool) {\r\n        uint256 totalEthAmount = getReturnByPath(ethToBaseToken, _amount);\r\n\r\n        if (address(this).balance >= totalEthAmount) {\r\n            IBancorNetwork(bancorNetwork).convertByPath.value(totalEthAmount)(\r\n                ethToBaseToken,\r\n                totalEthAmount,\r\n                1,\r\n                address(0),\r\n                address(0),\r\n                0\r\n            );\r\n\r\n            return _convertWithToken(_amount, baseTokenToMainToken);\r\n        } else {\r\n            uint256 converterBalance = IERC20Token(baseToken).balanceOf(\r\n                converter\r\n            );\r\n\r\n            uint256 _tempRelayPercent;\r\n            \r\n            if (converterBalance > _amount) {\r\n                _tempRelayPercent = safeDiv(\r\n                    safeMul(safeMul(_amount, PRICE_NOMINATOR), 100),\r\n                    converterBalance\r\n                );\r\n            } else {\r\n                 _tempRelayPercent = safeDiv(\r\n                    safeMul(safeMul(_amount, PRICE_NOMINATOR), 100),\r\n                    safeAdd(converterBalance,_amount)\r\n                );\r\n            }\r\n\r\n            _liquadate(_tempRelayPercent);\r\n\r\n            _amount = safeSub(\r\n                _amount,\r\n                safeDiv(safeMul(_amount, _tempRelayPercent),safeMul(100,PRICE_NOMINATOR))\r\n            );\r\n\r\n            return _convertWithToken(_amount, baseTokenToMainToken);\r\n        }\r\n    }\r\n\r\n    function redemptionFromEscrow(\r\n        address[] memory _path,\r\n        uint256 _amount,\r\n        address payable _reciver\r\n    ) public returns (bool) {\r\n        require(msg.sender == escrowAddress, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        return _redemption(_path, _amount, msg.sender, _reciver);\r\n    }\r\n\r\n    function redemption(address[] memory _path, uint256 _amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        return _redemption(_path, _amount, msg.sender, msg.sender);\r\n    }\r\n\r\n    function _redemption(\r\n        address[] memory _path,\r\n        uint256 _amount,\r\n        address payable _caller,\r\n        address payable _reciver\r\n    ) internal returns (bool) {\r\n        require(_path[0] == mainToken, \"ERR_MAIN_TOKEN\");\r\n\r\n        address primaryWallet = IWhiteList(whiteListAddress).address_belongs(\r\n            _reciver\r\n        );\r\n\r\n        uint256 auctionDay = IAuction(auctionAddress).auctionDay();\r\n\r\n        require(primaryWallet != address(0), \"ERR_WHITELIST\");\r\n\r\n        require(\r\n            auctionDay > lastReedeemDay[primaryWallet],\r\n            \"ERR_WALLET_ALREADY_REDEEM\"\r\n        );\r\n\r\n        uint256 _beforeBalance = IERC20Token(baseToken).balanceOf(converter);\r\n\r\n        if (_beforeBalance != lastReserveBalance) {\r\n            _recoverPriceDueToManipulation();\r\n        }\r\n\r\n        ensureTransferFrom(\r\n            IERC20Token(mainToken),\r\n            _caller,\r\n            address(this),\r\n            _amount\r\n        );\r\n\r\n        approveTransferFrom(IERC20Token(mainToken), bancorNetwork, _amount);\r\n\r\n        uint256 returnAmount = IBancorNetwork(bancorNetwork)\r\n            .convertByPath\r\n            .value(0)(_path, _amount, 1, _reciver, address(0), 0);\r\n\r\n        lastReedeemDay[primaryWallet] = auctionDay;\r\n\r\n        uint256 _afterBalance = IERC20Token(baseToken).balanceOf(converter);\r\n\r\n        emit Redemption(\r\n            address(_path[safeSub(_path.length, 1)]),\r\n            _amount,\r\n            returnAmount\r\n        );\r\n\r\n        if (_beforeBalance > _afterBalance) {\r\n            _recoverAfterRedemption(safeSub(_beforeBalance, _afterBalance));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function auctionEnded()\r\n        external\r\n        allowedAddressOnly(msg.sender)\r\n        returns (bool)\r\n    {\r\n        uint256 _baseTokenBalance = IERC20Token(baseToken).balanceOf(converter);\r\n\r\n        uint256 yesterdayMainReserv = safeDiv(\r\n            safeMul(_baseTokenBalance, baseLinePrice),\r\n            safeExponent(10, IERC20Token(baseToken).decimals())\r\n        );\r\n\r\n        IAuction auction = IAuction(auctionAddress);\r\n\r\n        uint256 auctionDay = auction.auctionDay();\r\n\r\n        if (auctionDay > reductionStartDay) {\r\n            uint256 _yesterdayPrice = auction.dayWiseMarketPrice(\r\n                safeSub(auctionDay, 1)\r\n            );\r\n\r\n            uint256 _dayBeforePrice = auction.dayWiseMarketPrice(\r\n                safeSub(auctionDay, 2)\r\n            );\r\n\r\n            uint256 _yesterdayContribution = auction.dayWiseContribution(\r\n                safeSub(auctionDay, 1)\r\n            );\r\n\r\n            virtualReserverDivisor = calculateLiquidityMainReserve(\r\n                _yesterdayPrice,\r\n                _dayBeforePrice,\r\n                _yesterdayContribution,\r\n                yesterdayMainReserv\r\n            );\r\n        }\r\n        previousMainReserveContribution = todayMainReserveContribution;\r\n        todayMainReserveContribution = 0;\r\n        tokenAuctionEndPrice = _getCurrentMarketPrice();\r\n        isAppreciationLimitReached = false;\r\n        return true;\r\n    }\r\n\r\n    function _liquadate(uint256 _relayPercent)\r\n        internal\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 _mainTokenBalance = IERC20Token(mainToken).balanceOf(\r\n            address(this)\r\n        );\r\n\r\n        uint256 _baseTokenBalance = IERC20Token(baseToken).balanceOf(\r\n            address(this)\r\n        );\r\n\r\n        uint256 sellRelay = safeDiv(\r\n            safeMul(\r\n                IERC20Token(relayToken).balanceOf(triggerAddress),\r\n                _relayPercent\r\n            ),\r\n            safeMul(100, PRICE_NOMINATOR)\r\n        );\r\n\r\n        require(sellRelay > 0, \"ERR_RELAY_ZERO\");\r\n\r\n        IContributionTrigger(triggerAddress).transferTokenLiquidity(\r\n            IERC20Token(relayToken),\r\n            address(this),\r\n            sellRelay\r\n        );\r\n\r\n        //take out both side of token from the reserve\r\n        IBancorConverter(converter).removeLiquidity(\r\n            sellRelay,\r\n            relayPath,\r\n            returnAmountRelay\r\n        );\r\n\r\n        _mainTokenBalance = safeSub(\r\n            IERC20Token(mainToken).balanceOf(address(this)),\r\n            _mainTokenBalance\r\n        );\r\n\r\n        _baseTokenBalance = safeSub(\r\n            IERC20Token(baseToken).balanceOf(address(this)),\r\n            _baseTokenBalance\r\n        );\r\n\r\n        ensureTransferFrom(\r\n            IERC20Token(mainToken),\r\n            address(this),\r\n            vaultAddress,\r\n            _mainTokenBalance\r\n        );\r\n\r\n        // etherToken converted into\r\n        if (etherTokens(baseToken)) {\r\n            IEtherToken(baseToken).withdraw(_baseTokenBalance);\r\n        }\r\n        return (_baseTokenBalance, _mainTokenBalance);\r\n    }\r\n\r\n    function returnFundToTagAlong(IERC20Token _token, uint256 _value)\r\n        external\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        if (address(_token) == address(0)) {\r\n            triggerAddress.transfer(_value);\r\n        } else {\r\n            ensureTransferFrom(_token, address(this), triggerAddress, _value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //return token and ether from tagalong to here  as we only need ether\r\n    function takeFundFromTagAlong(IERC20Token _token, uint256 _value)\r\n        external\r\n        onlyOwner()\r\n        returns (bool)\r\n    {\r\n        if (address(_token) == address(0))\r\n            IContributionTrigger(triggerAddress).contributeTowardLiquidity(\r\n                _value\r\n            );\r\n        else\r\n            IContributionTrigger(triggerAddress).transferTokenLiquidity(\r\n                _token,\r\n                address(this),\r\n                _value\r\n            );\r\n        return true;\r\n    }\r\n\r\n    function getCurrencyPrice() public view returns (uint256) {\r\n        return _getCurrentMarketPrice();\r\n    }\r\n\r\n    function sendMainTokenToVault() external returns (bool) {\r\n        uint256 mainTokenBalance = IERC20Token(mainToken).balanceOf(\r\n            address(this)\r\n        );\r\n        ensureTransferFrom(\r\n            IERC20Token(mainToken),\r\n            address(this),\r\n            vaultAddress,\r\n            mainTokenBalance\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function convertBaseTokenToEth() external returns (bool) {\r\n        _convertBaseTokenToEth();\r\n        return true;\r\n    }\r\n\r\n    function() external payable {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"triggerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"changeSystemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BIG_NOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recoverPriceVolatility\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reductionStartDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrowAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastReserveBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"baseTokenToMainToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contributeTowardMainReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redemption\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changePrimaryOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"virtualReserverDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMAL_NOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwnerInitialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastReedeemDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"takeFundFromTagAlong\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"todayMainReserveContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteListAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAppreciationLimitReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sideReseverRatio\",\"type\":\"uint256\"}],\"name\":\"setSideReseverRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRelayToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"},{\"name\":\"_baseToken\",\"type\":\"address\"},{\"name\":\"_mainToken\",\"type\":\"address\"},{\"name\":\"_relayToken\",\"type\":\"address\"},{\"name\":\"_etherToken\",\"type\":\"address\"},{\"name\":\"_ethRelayToken\",\"type\":\"address\"},{\"name\":\"_primaryOwner\",\"type\":\"address\"},{\"name\":\"_systemAddress\",\"type\":\"address\"},{\"name\":\"_authorityAddress\",\"type\":\"address\"},{\"name\":\"_registryaddress\",\"type\":\"address\"},{\"name\":\"_baseLinePrice\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"returnFundToTagAlong\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_NOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousMainReserveContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"appreciationLimitWithDecimal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reductionStartDay\",\"type\":\"uint256\"}],\"name\":\"setReductionStartDay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"relayPath\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"auctionEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethToBaseToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"primaryOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_which\",\"type\":\"address\"}],\"name\":\"changeAuthorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_reciver\",\"type\":\"address\"}],\"name\":\"redemptionFromEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAuctionEndPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_baseTokenVolatiltyRatio\",\"type\":\"uint256\"}],\"name\":\"setBaseTokenVolatiltyRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sideReseverRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recoverPriceDueToManipulation\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorNetwork\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendMainTokenToVault\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contributeWithEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"returnAmountRelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxIteration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tagAlongRatio\",\"type\":\"uint256\"}],\"name\":\"setTagAlongRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setAppreciationLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrencyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tagAlongRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"appreciationLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateTokenPath\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateRegistery\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"converter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mainTokenTobaseToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"baseTokenToEth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethToMainToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currencyPricesAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"updateConverter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"convertBaseTokenToEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_relayPercent\",\"type\":\"uint256\"}],\"name\":\"setRelayPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseTokenVolatiltyRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseLinePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"RecoverPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"name\":\"Redemption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FundDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ownerType\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AuthorityAddressChnageCall\",\"type\":\"event\"}]","ContractName":"Liquidity","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7ce47650138f79cac23a96a9a2191898f3f8b1acbeca0a962f221de999a6ea48"}]}