{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Factory.sol\": {\r\n      \"content\": \"pragma solidity 0.6.8;\\nimport \\\"./Wallet.sol\\\";\\n\\n\\ncontract Factory {\\n  /**\\n   * @notice Will deploy a new wallet instance\\n   * @param _mainModule Address of the main module to be used by the wallet\\n   * @param _salt Salt used to generate the wallet, which is the imageHash\\n   *       of the wallet's configuration.\\n   * @dev It is recommended to not have more than 200 signers as opcode repricing\\n   *      could make transactions impossible to execute as all the signers must be\\n   *      passed for each transaction.\\n   */\\n  function deploy(address _mainModule, bytes32 _salt) public payable returns (address _contract) {\\n    bytes memory code = abi.encodePacked(Wallet.creationCode, uint256(_mainModule));\\n    assembly { _contract := create2(callvalue(), add(code, 32), mload(code), _salt) }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Wallet.sol\": {\r\n      \"content\": \"pragma solidity 0.6.8;\\n\\n/**\\n    Minimal upgradeable proxy implementation, delegates all calls to the address\\n    defined by the storage slot matching the wallet address.\\n\\n    Inspired by EIP-1167 Implementation (https://eips.ethereum.org/EIPS/eip-1167)\\n\\n    deployed code:\\n\\n        0x00    0x36         0x36      CALLDATASIZE      cds\\n        0x01    0x3d         0x3d      RETURNDATASIZE    0 cds\\n        0x02    0x3d         0x3d      RETURNDATASIZE    0 0 cds\\n        0x03    0x37         0x37      CALLDATACOPY\\n        0x04    0x3d         0x3d      RETURNDATASIZE    0\\n        0x05    0x3d         0x3d      RETURNDATASIZE    0 0\\n        0x06    0x3d         0x3d      RETURNDATASIZE    0 0 0\\n        0x07    0x36         0x36      CALLDATASIZE      cds 0 0 0\\n        0x08    0x3d         0x3d      RETURNDATASIZE    0 cds 0 0 0\\n        0x09    0x30         0x30      ADDRESS           addr 0 cds 0 0 0\\n        0x0A    0x54         0x54      SLOAD             imp 0 cds 0 0 0\\n        0x0B    0x5a         0x5a      GAS               gas imp 0 cds 0 0 0\\n        0x0C    0xf4         0xf4      DELEGATECALL      suc 0\\n        0x0D    0x3d         0x3d      RETURNDATASIZE    rds suc 0\\n        0x0E    0x82         0x82      DUP3              0 rds suc 0\\n        0x0F    0x80         0x80      DUP1              0 0 rds suc 0\\n        0x10    0x3e         0x3e      RETURNDATACOPY    suc 0\\n        0x11    0x90         0x90      SWAP1             0 suc\\n        0x12    0x3d         0x3d      RETURNDATASIZE    rds 0 suc\\n        0x13    0x91         0x91      SWAP2             suc 0 rds\\n        0x14    0x60 0x18    0x6018    PUSH1             0x18 suc 0 rds\\n    /-- 0x16    0x57         0x57      JUMPI             0 rds\\n    |   0x17    0xfd         0xfd      REVERT\\n    \\\\-> 0x18    0x5b         0x5b      JUMPDEST          0 rds\\n        0x19    0xf3         0xf3      RETURN\\n\\n    flat deployed code: 0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\\n\\n    deploy function:\\n\\n        0x00    0x60 0x3a    0x603a    PUSH1             0x3a\\n        0x02    0x60 0x0e    0x600e    PUSH1             0x0e 0x3a\\n        0x04    0x3d         0x3d      RETURNDATASIZE    0 0x0e 0x3a\\n        0x05    0x39         0x39      CODECOPY\\n        0x06    0x60 0x1a    0x601a    PUSH1             0x1a\\n        0x08    0x80         0x80      DUP1              0x1a 0x1a\\n        0x09    0x51         0x51      MLOAD             imp 0x1a\\n        0x0A    0x30         0x30      ADDRESS           addr imp 0x1a\\n        0x0B    0x55         0x55      SSTORE            0x1a\\n        0x0C    0x3d         0x3d      RETURNDATASIZE    0 0x1a\\n        0x0D    0xf3         0xf3      RETURN\\n        [...deployed code]\\n\\n    flat deploy function: 0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\\n*/\\nlibrary Wallet {\\n  bytes internal constant creationCode = hex\\\"603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC1271Wallet.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ninterface IERC1271Wallet {\\n\\n  /**\\n   * @notice Verifies whether the provided signature is valid with respect to the provided data\\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided data\\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n   *   > This function MAY modify Ethereum's state\\n   * @param _data       Arbitrary length data signed on the behalf of address(this)\\n   * @param _signature  Signature byte array associated with _data\\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\\n   */\\n  function isValidSignature(\\n    bytes calldata _data,\\n    bytes calldata _signature)\\n    external\\n    view\\n    returns (bytes4 magicValue);\\n\\n  /**\\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n   *   > This function MAY modify Ethereum's state\\n   * @param _hash       keccak256 hash that was signed\\n   * @param _signature  Signature byte array associated with _data\\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\\n   */\\n  function isValidSignature(\\n    bytes32 _hash,\\n    bytes calldata _signature)\\n    external\\n    view\\n    returns (bytes4 magicValue);\\n}\"\r\n    },\r\n    \"contracts/interfaces/receivers/IERC1155Receiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ninterface IERC1155Receiver {\\n  function onERC1155Received(address, address, uint256, uint256, bytes calldata) external returns (bytes4);\\n  function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/receivers/IERC223Receiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ninterface IERC223Receiver {\\n  function tokenFallback(address, uint256, bytes calldata) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/receivers/IERC721Receiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ninterface IERC721Receiver {\\n  function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/migrations/Migrations.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  modifier restricted() {\\n    if (msg.sender == owner)\\n      _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/CallReceiverMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ncontract CallReceiverMock {\\n  uint256 public lastValA;\\n  bytes public lastValB;\\n\\n  bool revertFlag;\\n\\n  constructor() public payable { }\\n\\n  function setRevertFlag(bool _revertFlag) external {\\n    revertFlag = _revertFlag;\\n  }\\n\\n  function testCall(uint256 _valA, bytes calldata _valB) external payable {\\n    require(!revertFlag, \\\"CallReceiverMock#testCall: REVERT_FLAG\\\");\\n\\n    lastValA = _valA;\\n    lastValB = _valB;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/DelegateCallMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ncontract DelegateCallMock {\\n  event Readed(uint256 _val);\\n\\n  uint256 private constant REVERT_SLOT = uint256(keccak256(\\\"revert-flag\\\"));\\n\\n  mapping(uint256 => uint256) private store;\\n\\n  function setRevertFlag(bool _revertFlag) external {\\n    store[REVERT_SLOT] = _revertFlag ? 1 : 0;\\n  }\\n\\n  function write(uint256 _key, uint256 _val) external {\\n    require(store[REVERT_SLOT] == 0, \\\"DelegateCallMock#write: REVERT_FLAG\\\");\\n    store[_key] = _val;\\n  }\\n\\n  function read(uint256 _key) external {\\n    emit Readed(store[_key]);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/ERC165CheckerMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ncontract ERC165CheckerMock {\\n  bytes4 constant InvalidID = 0xffffffff;\\n  bytes4 constant ERC165ID = 0x01ffc9a7;\\n\\n  function doesContractImplementInterface(address _contract, bytes4 _interfaceId) external view returns (bool) {\\n    uint256 success;\\n    uint256 result;\\n\\n    (success, result) = noThrowCall(_contract, ERC165ID);\\n    if (success == 0 || result == 0) {\\n      return false;\\n    }\\n\\n    (success, result) = noThrowCall(_contract, InvalidID);\\n    if (success == 0 || result != 0) {\\n      return false;\\n    }\\n\\n    (success, result) = noThrowCall(_contract, _interfaceId);\\n    if (success == 1 && result == 1) {\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function noThrowCall(\\n    address _contract,\\n    bytes4 _interfaceId\\n  ) private view returns (\\n    uint256 success,\\n    uint256 result\\n  ) {\\n    bytes4 erc165ID = ERC165ID;\\n\\n    assembly {\\n      let x := mload(0x40)               // Find empty storage location using \\\"free memory pointer\\\"\\n      mstore(x, erc165ID)                // Place signature at beginning of empty storage\\n      mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature\\n\\n      success := staticcall(\\n        30000,     // 30k gas\\n        _contract, // To addr\\n        x,         // Inputs are stored at location x\\n        0x24,      // Inputs are 36 bytes long\\n        x,         // Store output over input (saves space)\\n        0x20       // Outputs are 32 bytes long\\n      )\\n\\n      result := mload(x)                 // Load the result\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/GasBurnerMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ncontract GasBurnerMock {\\n  event ProvidedGas(uint256 _val);\\n\\n  function burnGas(uint256 _burn) external {\\n    emit ProvidedGas(gasleft());\\n\\n    bytes32 stub;\\n    uint256 initial = gasleft();\\n\\n    while (initial - gasleft() < _burn) {\\n      stub = keccak256(abi.encode(stub));\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/HookCallerMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\nimport \\\"../interfaces/receivers/IERC1155Receiver.sol\\\";\\nimport \\\"../interfaces/receivers/IERC721Receiver.sol\\\";\\nimport \\\"../interfaces/receivers/IERC223Receiver.sol\\\";\\n\\nimport \\\"../interfaces/IERC1271Wallet.sol\\\";\\n\\n\\ncontract HookCallerMock {\\n  function callERC1155Received(address _addr) external {\\n    bytes4 result = IERC1155Receiver(_addr).onERC1155Received(\\n      address(this),\\n      msg.sender,\\n      1,\\n      2,\\n      msg.data\\n    );\\n\\n    require(result == 0xf23a6e61, \\\"HookCallerMock#callERC1155Received: INVALID_RETURN\\\");\\n  }\\n\\n  function callERC1155BatchReceived(address _addr) external {\\n    uint256[] memory ids = new uint256[](3);\\n    ids[0] = 1;\\n    ids[1] = 2;\\n    ids[2] = 3;\\n\\n    uint256[] memory values = new uint256[](3);\\n    values[0] = 200;\\n    values[1] = 300;\\n    values[2] = 400;\\n\\n    bytes4 result = IERC1155Receiver(_addr).onERC1155BatchReceived(\\n      address(this),\\n      msg.sender,\\n      ids,\\n      values,\\n      msg.data\\n    );\\n\\n    require(result == 0xbc197c81, \\\"HookCallerMock#callERC1155BatchReceived: INVALID_RETURN\\\");\\n  }\\n\\n  function callERC721Received(address _addr) external {\\n    bytes4 result = IERC721Receiver(_addr).onERC721Received(\\n      address(this),\\n      msg.sender,\\n      1,\\n      msg.data\\n    );\\n\\n    require(result == 0x150b7a02, \\\"HookCallerMock#callERC721Received: INVALID_RETURN\\\");\\n  }\\n\\n  function callERC223Received(address _addr) external {\\n    IERC223Receiver(_addr).tokenFallback(msg.sender, 1, msg.data);\\n  }\\n\\n  function callERC1271isValidSignatureData(\\n    address _addr,\\n    bytes calldata _data,\\n    bytes calldata _signature\\n  ) external view {\\n    bytes4 result = IERC1271Wallet(_addr).isValidSignature(_data, _signature);\\n    require(result == 0x20c13b0b, \\\"HookCallerMock#callERC1271isValidSignatureData: INVALID_RETURN\\\");\\n  }\\n\\n  function callERC1271isValidSignatureHash(\\n    address _addr,\\n    bytes32 _hash,\\n    bytes calldata _signature\\n  ) external view {\\n    bytes4 result = IERC1271Wallet(_addr).isValidSignature(_hash, _signature);\\n    require(result == 0x1626ba7e, \\\"HookCallerMock#callERC1271isValidSignatureHash: INVALID_RETURN\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/HookMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ncontract HookMock {\\n  function onHookMockCall(uint256 _num) external pure returns (uint256) {\\n    return _num * 2;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/LibBytesImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nimport \\\"../utils/LibBytes.sol\\\";\\n\\n\\ncontract LibBytesImpl {\\n  using LibBytes for bytes;\\n\\n  function readFirstUint16(bytes calldata _data) external pure returns (uint16, uint256) {\\n    return _data.readFirstUint16();\\n  }\\n\\n  function readUint8Uint8(bytes calldata _data, uint256 _index) external pure returns (uint8, uint8, uint256) {\\n    return _data.readUint8Uint8(_index);\\n  }\\n\\n  function readAddress(bytes calldata _data, uint256 _index) external pure returns (address, uint256) {\\n    return _data.readAddress(_index);\\n  }\\n\\n  function readBytes66(bytes calldata _data, uint256 _index) external pure returns (bytes memory, uint256) {\\n    return _data.readBytes66(_index);\\n  }\\n\\n  function readBytes32(bytes calldata _data, uint256 _index) external pure returns (bytes32) {\\n    return _data.readBytes32(_index);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibBytes.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2018 ZeroEx Intl.\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n  http://www.apache.org/licenses/LICENSE-2.0\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n  This is a truncated version of the original LibBytes.sol library from ZeroEx.\\n*/\\n\\npragma solidity ^0.6.8;\\n\\nlibrary LibBytes {\\n  using LibBytes for bytes;\\n\\n  /***********************************|\\n  |        Read Bytes Functions       |\\n  |__________________________________*/\\n\\n  /**\\n   * @dev Read firsts uint16 value.\\n   * @param data Byte array to be read.\\n   * @return a uint16 value of data at index zero.\\n   * @return newIndex Updated index after reading the values.\\n   */\\n  function readFirstUint16(\\n    bytes memory data\\n  ) internal pure returns (\\n    uint16 a,\\n    uint256 newIndex\\n  ) {\\n    assembly {\\n      let word := mload(add(32, data))\\n      a := shr(240, word)\\n      newIndex := 2\\n    }\\n    require(2 <= data.length, \\\"LibBytes#readFirstUint16: OUT_OF_BOUNDS\\\");\\n  }\\n\\n  /**\\n   * @dev Reads consecutive bool (8 bits) and uint8 values.\\n   * @param data Byte array to be read.\\n   * @param index Index in byte array of uint8 and uint8 values.\\n   * @return a uint8 value of data at given index.\\n   * @return b uint8 value of data at given index + 8.\\n   * @return newIndex Updated index after reading the values.\\n   */\\n  function readUint8Uint8(\\n    bytes memory data,\\n    uint256 index\\n  ) internal pure returns (\\n    uint8 a,\\n    uint8 b,\\n    uint256 newIndex\\n  ) {\\n    assembly {\\n      let word := mload(add(index, add(32, data)))\\n      a := shr(248, word)\\n      b := and(shr(240, word), 0xff)\\n      newIndex := add(index, 2)\\n    }\\n    require(newIndex <= data.length, \\\"LibBytes#readUint8Uint8: OUT_OF_BOUNDS\\\");\\n  }\\n\\n  /**\\n   * @dev Reads an address value from a position in a byte array.\\n   * @param data Byte array to be read.\\n   * @param index Index in byte array of address value.\\n   * @return a address value of data at given index.\\n   * @return newIndex Updated index after reading the value.\\n   */\\n  function readAddress(\\n    bytes memory data,\\n    uint256 index\\n  ) internal pure returns (\\n    address a,\\n    uint256 newIndex\\n  ) {\\n    assembly {\\n      let word := mload(add(index, add(32, data)))\\n      a := and(shr(96, word), 0xffffffffffffffffffffffffffffffffffffffff)\\n      newIndex := add(index, 20)\\n    }\\n    require(newIndex <= data.length, \\\"LibBytes#readAddress: OUT_OF_BOUNDS\\\");\\n  }\\n\\n  /**\\n   * @dev Reads 66 bytes from a position in a byte array.\\n   * @param data Byte array to be read.\\n   * @param index Index in byte array of 66 bytes value.\\n   * @return a 66 bytes bytes array value of data at given index.\\n   * @return newIndex Updated index after reading the value.\\n   */\\n  function readBytes66(\\n    bytes memory data,\\n    uint256 index\\n  ) internal pure returns (\\n    bytes memory a,\\n    uint256 newIndex\\n  ) {\\n    a = new bytes(66);\\n    assembly {\\n      let offset := add(32, add(data, index))\\n      mstore(add(a, 32), mload(offset))\\n      mstore(add(a, 64), mload(add(offset, 32)))\\n      mstore(add(a, 66), mload(add(offset, 34)))\\n      newIndex := add(index, 66)\\n    }\\n    require(newIndex <= data.length, \\\"LibBytes#readBytes66: OUT_OF_BOUNDS\\\");\\n  }\\n\\n  /**\\n   * @dev Reads a bytes32 value from a position in a byte array.\\n   * @param b Byte array containing a bytes32 value.\\n   * @param index Index in byte array of bytes32 value.\\n   * @return result bytes32 value from byte array.\\n   */\\n  function readBytes32(\\n    bytes memory b,\\n    uint256 index\\n  )\\n    internal\\n    pure\\n    returns (bytes32 result)\\n  {\\n    require(\\n      b.length >= index + 32,\\n      \\\"LibBytes#readBytes32: GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\\\"\\n    );\\n\\n    // Arrays are prefixed by a 256 bit length parameter\\n    uint256 pos = index + 32;\\n\\n    // Read the bytes32 from array memory\\n    assembly {\\n      result := mload(add(b, pos))\\n    }\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/ModuleMock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ncontract ModuleMock {\\n  event Pong();\\n\\n  function ping() external {\\n    emit Pong();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/Implementation.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n/**\\n * @dev Allows modules to access the implementation slot\\n */\\ncontract Implementation {\\n  /**\\n   * @notice Updates the Wallet implementation\\n   * @param _imp New implementation address\\n   * @dev The wallet implementation is stored on the storage slot\\n   *   defined by the address of the wallet itself\\n   *   WARNING updating this value may break the wallet and users\\n   *   must be confident that the new implementation is safe.\\n   */\\n  function _setImplementation(address _imp) internal {\\n    assembly {\\n      sstore(address(), _imp)\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the Wallet implementation\\n   * @return _imp The address of the current Wallet implementation\\n   */\\n  function _getImplementation() internal view returns (address _imp) {\\n    assembly {\\n      _imp := sload(address())\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/interfaces/IModuleAuth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\nabstract contract IModuleAuth {\\n  /**\\n   * @notice Hashed _data to be signed\\n   * @param _data Data to be hashed\\n   * @return hashed data for this wallet\\n   */\\n  function _hashData(\\n    bytes memory _data\\n  ) internal virtual view returns (bytes32);\\n\\n  /**\\n   * @notice Verify if signer is default wallet owner\\n   * @param _hash Hashed signed message\\n   * @param _signature Encoded signature\\n   * @return True is the signature is valid\\n   */\\n  function _signatureValidation(\\n    bytes32 _hash,\\n    bytes memory _signature\\n  ) internal virtual view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/interfaces/IModuleAuthUpgradable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ninterface IModuleAuthUpgradable {\\n  /**\\n   * @notice Updates the signers configuration of the wallet\\n   * @param _imageHash New required image hash of the signature\\n   */\\n  function updateImageHash(bytes32 _imageHash) external;\\n\\n  /**\\n   * @notice Returns the current image hash of the wallet\\n   */\\n  function imageHash() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/interfaces/IModuleCalls.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface IModuleCalls {\\n  // Events\\n  event NonceChange(uint256 _space, uint256 _newNonce);\\n  event TxFailed(bytes32 _tx, bytes _reason);\\n  event TxExecuted(bytes32 _tx) anonymous;\\n\\n  // Transaction structure\\n  struct Transaction {\\n    bool delegateCall;   // Performs delegatecall\\n    bool revertOnError;  // Reverts transaction bundle if tx fails\\n    uint256 gasLimit;    // Maximum gas to be forwarded\\n    address target;      // Address of the contract to call\\n    uint256 value;       // Amount of ETH to pass with the call\\n    bytes data;          // calldata to pass\\n  }\\n\\n  /**\\n   * @notice Returns the next nonce of the default nonce space\\n   * @dev The default nonce space is 0x00\\n   * @return The next nonce\\n   */\\n  function nonce() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the next nonce of the given nonce space\\n   * @param _space Nonce space, each space keeps an independent nonce count\\n   * @return The next nonce\\n   */\\n  function readNonce(uint256 _space) external view returns (uint256);\\n\\n  /**\\n   * @notice Allow wallet owner to execute an action\\n   * @param _txs        Transactions to process\\n   * @param _nonce      Signature nonce (may contain an encoded space)\\n   * @param _signature  Encoded signature\\n   */\\n  function execute(\\n    Transaction[] calldata _txs,\\n    uint256 _nonce,\\n    bytes calldata _signature\\n  ) external;\\n\\n  /**\\n   * @notice Allow wallet to execute an action\\n   *   without signing the message\\n   * @param _txs  Transactions to execute\\n   */\\n  function selfExecute(\\n    Transaction[] calldata _txs\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/interfaces/IModuleCreator.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ninterface IModuleCreator {\\n  /**\\n   * @notice Creates a contract forwarding eth value\\n   * @param _code Creation code of the contract\\n   * @return addr The address of the created contract\\n   */\\n  function createContract(bytes calldata _code) external payable returns (address addr);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/interfaces/IModuleHooks.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ninterface IModuleHooks {\\n  /**\\n   * @notice Reads the implementation hook of a signature\\n   * @param _signature Signature function\\n   * @return The address of the implementation hook, address(0) if none\\n  */\\n  function readHook(bytes4 _signature) external view returns (address);\\n\\n  /**\\n   * @notice Adds a new hook to handle a given function selector\\n   * @param _signature Signature function linked to the hook\\n   * @param _implementation Hook implementation contract\\n   */\\n  function addHook(bytes4 _signature, address _implementation) external;\\n\\n  /**\\n   * @notice Removes a registered hook\\n   * @param _signature Signature function linked to the hook\\n   */\\n  function removeHook(bytes4 _signature) external;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/interfaces/IModuleUpdate.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ninterface IModuleUpdate {\\n  /**\\n   * @notice Updates the implementation of the base wallet\\n   * @param _implementation New main module implementation\\n   * @dev WARNING Updating the implementation can brick the wallet\\n   */\\n  function updateImplementation(address _implementation) external;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/ModuleAuth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\nimport \\\"../../utils/LibBytes.sol\\\";\\nimport \\\"../../utils/SignatureValidator.sol\\\";\\nimport \\\"../../interfaces/IERC1271Wallet.sol\\\";\\n\\nimport \\\"./interfaces/IModuleAuth.sol\\\";\\n\\nimport \\\"./ModuleERC165.sol\\\";\\n\\n\\nabstract contract ModuleAuth is IModuleAuth, ModuleERC165, SignatureValidator, IERC1271Wallet {\\n  using LibBytes for bytes;\\n\\n  uint256 private constant FLAG_SIGNATURE = 0;\\n  uint256 private constant FLAG_ADDRESS = 1;\\n\\n  bytes4 private constant SELECTOR_ERC1271_BYTES_BYTES = 0x20c13b0b;\\n  bytes4 private constant SELECTOR_ERC1271_BYTES32_BYTES = 0x1626ba7e;\\n\\n  /**\\n   * @notice Verify if signer is default wallet owner\\n   * @param _hash       Hashed signed message\\n   * @param _signature  Array of signatures with signers ordered\\n   *                    like the the keys in the multisig configs\\n   *\\n   * @dev The signature must be solidity packed and contain the total number of owners,\\n   *      the threshold, the weight and either the address or a signature for each owner.\\n   *\\n   *      Each weight & (address or signature) pair is prefixed by a flag that signals if such pair\\n   *      contains an address or a signature. The aggregated weight of the signatures must surpass the threshold.\\n   *\\n   *      Flag types:\\n   *        0x00 - Signature\\n   *        0x01 - Address\\n   *\\n   *      E.g:\\n   *      abi.encodePacked(\\n   *        uint16 threshold,\\n   *        uint8 01,  uint8 weight_1, address signer_1,\\n   *        uint8 00, uint8 weight_2, bytes signature_2,\\n   *        ...\\n   *        uint8 01,  uint8 weight_5, address signer_5\\n   *      )\\n   */\\n  function _signatureValidation(\\n    bytes32 _hash,\\n    bytes memory _signature\\n  )\\n    internal override view returns (bool)\\n  {\\n    (\\n      uint16 threshold,  // required threshold signature\\n      uint256 rindex     // read index\\n    ) = _signature.readFirstUint16();\\n\\n    // Start image hash generation\\n    bytes32 imageHash = bytes32(uint256(threshold));\\n\\n    // Acumulated weight of signatures\\n    uint256 totalWeight;\\n\\n    // Iterate until the image is completed\\n    while (rindex < _signature.length) {\\n      // Read next item type and addrWeight\\n      uint256 flag; uint256 addrWeight; address addr;\\n      (flag, addrWeight, rindex) = _signature.readUint8Uint8(rindex);\\n\\n      if (flag == FLAG_ADDRESS) {\\n        // Read plain address\\n        (addr, rindex) = _signature.readAddress(rindex);\\n      } else if (flag == FLAG_SIGNATURE) {\\n        // Read single signature and recover signer\\n        bytes memory signature;\\n        (signature, rindex) = _signature.readBytes66(rindex);\\n        addr = recoverSigner(_hash, signature);\\n\\n        // Acumulate total weight of the signature\\n        totalWeight += addrWeight;\\n      } else {\\n        revert(\\\"ModuleAuth#_signatureValidation INVALID_FLAG\\\");\\n      }\\n\\n      // Write weight and address to image\\n      imageHash = keccak256(abi.encode(imageHash, addrWeight, addr));\\n    }\\n\\n    return totalWeight >= threshold && _isValidImage(imageHash);\\n  }\\n\\n  /**\\n   * @notice Validates the signature image\\n   * @param _imageHash Hashed image of signature\\n   * @return true if the signature image is valid\\n   */\\n  function _isValidImage(bytes32 _imageHash) internal virtual view returns (bool);\\n\\n  /**\\n   * @notice Will hash _data to be signed (similar to EIP-712)\\n   * @param _data Data to be hashed\\n   * @return hashed data for this wallet\\n   */\\n  function _hashData(bytes memory _data) internal override view returns (bytes32) {\\n    uint256 chainId; assembly { chainId := chainid() }\\n    return keccak256(\\n      abi.encodePacked(\\n        \\\"\\\\x19\\\\x01\\\",\\n        chainId,\\n        address(this),\\n        keccak256(_data)\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @notice Verifies whether the provided signature is valid with respect to the provided data\\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided data\\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\"))\\n   * @param _data       Arbitrary length data signed on the behalf of address(this)\\n   * @param _signatures Signature byte array associated with _data.\\n   *                    Encoded as abi.encode(Signature[], Configs)\\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\\n   */\\n  function isValidSignature(\\n    bytes calldata _data,\\n    bytes calldata _signatures\\n  ) external override view returns (bytes4) {\\n    // Validate signatures\\n    if (_signatureValidation(_hashData(_data), _signatures)) {\\n      return SELECTOR_ERC1271_BYTES_BYTES;\\n    }\\n  }\\n\\n  /**\\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\\n   *   > The bytes4 magic value to return when signature is valid is 0x1626ba7e : bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n   * @param _hash       keccak256 hash that was signed\\n   * @param _signatures Signature byte array associated with _data.\\n   *                    Encoded as abi.encode(Signature[], Configs)\\n   * @return magicValue Magic value 0x1626ba7e if the signature is valid and 0x0 otherwise\\n   */\\n  function isValidSignature(\\n    bytes32 _hash,\\n    bytes calldata _signatures\\n  ) external override view returns (bytes4) {\\n    // Validate signatures\\n    if (_signatureValidation(_hash, _signatures)) {\\n      return SELECTOR_ERC1271_BYTES32_BYTES;\\n    }\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\\n    if (\\n      _interfaceID == type(IModuleAuth).interfaceId ||\\n      _interfaceID == type(IERC1271Wallet).interfaceId\\n    ) {\\n      return true;\\n    }\\n\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SignatureValidator.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\nimport \\\"../interfaces/IERC1271Wallet.sol\\\";\\n\\nimport \\\"./LibBytes.sol\\\";\\n\\n/**\\n * @dev Contains logic for signature validation.\\n * Signatures from wallet contracts assume ERC-1271 support (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md)\\n * Notes: Methods are strongly inspired by contracts in https://github.com/0xProject/0x-monorepo/blob/development/\\n */\\ncontract SignatureValidator {\\n  using LibBytes for bytes;\\n\\n  /***********************************|\\n  |             Variables             |\\n  |__________________________________*/\\n\\n  // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\"))\\n  bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\\n\\n  // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n  bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\\n\\n  // Allowed signature types.\\n  uint256 private constant SIG_TYPE_EIP712 = 1;\\n  uint256 private constant SIG_TYPE_ETH_SIGN = 2;\\n\\n  /***********************************|\\n  |        Signature Functions        |\\n  |__________________________________*/\\n\\n /**\\n   * @notice Recover the signer of hash, assuming it's an EOA account\\n   * @dev Only for SignatureType.EIP712 and SignatureType.EthSign signatures\\n   * @param _hash      Hash that was signed\\n   *   encoded as (bytes32 r, bytes32 s, uint8 v, ... , SignatureType sigType)\\n   */\\n  function recoverSigner(\\n    bytes32 _hash,\\n    bytes memory _signature\\n  ) internal pure returns (address signer) {\\n    uint256 signatureType = uint8(_signature[_signature.length - 1]);\\n\\n    // Variables are not scoped in Solidity.\\n    uint8 v = uint8(_signature[64]);\\n    bytes32 r = _signature.readBytes32(0);\\n    bytes32 s = _signature.readBytes32(32);\\n\\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n    // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n    //\\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n    // these malleable signatures as well.\\n    //\\n    // Source OpenZeppelin\\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\\n\\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n      revert(\\\"SignatureValidator#recoverSigner: invalid signature 's' value\\\");\\n    }\\n\\n    if (v != 27 && v != 28) {\\n      revert(\\\"SignatureValidator#recoverSigner: invalid signature 'v' value\\\");\\n    }\\n\\n    // Signature using EIP712\\n    if (signatureType == SIG_TYPE_EIP712) {\\n      signer = ecrecover(_hash, v, r, s);\\n\\n    // Signed using web3.eth_sign() or Ethers wallet.signMessage()\\n    } else if (signatureType == SIG_TYPE_ETH_SIGN) {\\n      signer = ecrecover(\\n        keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash)),\\n        v,\\n        r,\\n        s\\n      );\\n\\n    } else {\\n      // Anything other signature types are illegal (We do not return false because\\n      // the signature may actually be valid, just not in a format\\n      // that we currently support. In this case returning false\\n      // may lead the caller to incorrectly believe that the\\n      // signature was invalid.)\\n      revert(\\\"SignatureValidator#recoverSigner: UNSUPPORTED_SIGNATURE_TYPE\\\");\\n    }\\n\\n    // Prevent signer from being 0x0\\n    require(\\n      signer != address(0x0),\\n      \\\"SignatureValidator#recoverSigner: INVALID_SIGNER\\\"\\n    );\\n\\n    return signer;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/ModuleERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\n\\nabstract contract ModuleERC165 {\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @dev Adding new hooks will not lead to them being reported by this function\\n   *      without upgrading the wallet. In addition, developpers must ensure that \\n   *      all inherited contracts by the mainmodule don't conflict and are accounted\\n   *      to be supported by the supportsInterface method.\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(bytes4 _interfaceID) virtual public pure returns (bool) {\\n    return _interfaceID == this.supportsInterface.selector;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/ModuleAuthFixed.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\nimport \\\"./ModuleAuth.sol\\\";\\nimport \\\"../../Wallet.sol\\\";\\n\\n/**\\n *  Implements ModuleAuth by validating the signature image against\\n *  the salt used to deploy the contract\\n *\\n *  This module allows wallets to be deployed with a default configuration\\n *  without using any aditional contract storage\\n */\\nabstract contract ModuleAuthFixed is ModuleAuth {\\n  bytes32 public immutable INIT_CODE_HASH;\\n  address public immutable FACTORY;\\n\\n  constructor(address _factory) public {\\n    // Build init code hash of the deployed wallets using that module\\n    bytes32 initCodeHash = keccak256(abi.encodePacked(Wallet.creationCode, uint256(address(this))));\\n\\n    INIT_CODE_HASH = initCodeHash;\\n    FACTORY = _factory;\\n  }\\n\\n  /**\\n   * @notice Validates the signature image with the salt used to deploy the contract\\n   * @param _imageHash Hash image of signature\\n   * @return true if the signature image is valid\\n   */\\n  function _isValidImage(bytes32 _imageHash) internal override view returns (bool) {\\n    return address(\\n      uint256(\\n        keccak256(\\n          abi.encodePacked(\\n            byte(0xff),\\n            FACTORY,\\n            _imageHash,\\n            INIT_CODE_HASH\\n          )\\n        )\\n      )\\n    ) == address(this);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/ModuleAuthUpgradable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\nimport \\\"./interfaces/IModuleAuthUpgradable.sol\\\";\\n\\nimport \\\"./ModuleSelfAuth.sol\\\";\\nimport \\\"./ModuleAuth.sol\\\";\\nimport \\\"./ModuleStorage.sol\\\";\\n\\n\\nabstract contract ModuleAuthUpgradable is IModuleAuthUpgradable, ModuleAuth, ModuleSelfAuth {\\n  //                       IMAGE_HASH_KEY = keccak256(\\\"org.arcadeum.module.auth.upgradable.image.hash\\\");\\n  bytes32 private constant IMAGE_HASH_KEY = bytes32(0xea7157fa25e3aa17d0ae2d5280fa4e24d421c61842aa85e45194e1145aa72bf8);\\n\\n  event ImageHashUpdated(bytes32 newImageHash);\\n\\n  /**\\n   * @notice Updates the signers configuration of the wallet\\n   * @param _imageHash New required image hash of the signature\\n   * @dev It is recommended to not have more than 200 signers as opcode repricing\\n   *      could make transactions impossible to execute as all the signers must be\\n   *      passed for each transaction.\\n   */\\n  function updateImageHash(bytes32 _imageHash) external override onlySelf {\\n    require(_imageHash != bytes32(0), \\\"ModuleAuthUpgradable#updateImageHash INVALID_IMAGE_HASH\\\");\\n    ModuleStorage.writeBytes32(IMAGE_HASH_KEY, _imageHash);\\n    emit ImageHashUpdated(_imageHash);\\n  }\\n\\n  /**\\n   * @notice Returns the current image hash of the wallet\\n   */\\n  function imageHash() external override view returns (bytes32) {\\n    return ModuleStorage.readBytes32(IMAGE_HASH_KEY);\\n  }\\n\\n  /**\\n   * @notice Validates the signature image with a valid image hash defined\\n   *   in the contract storage\\n   * @param _imageHash Hash image of signature\\n   * @return true if the signature image is valid\\n   */\\n  function _isValidImage(bytes32 _imageHash) internal override view returns (bool) {\\n    return _imageHash != bytes32(0) && _imageHash == ModuleStorage.readBytes32(IMAGE_HASH_KEY);\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\\n    if (_interfaceID == type(IModuleAuthUpgradable).interfaceId) {\\n      return true;\\n    }\\n\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/ModuleSelfAuth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\ncontract ModuleSelfAuth {\\n  modifier onlySelf() {\\n    require(msg.sender == address(this), \\\"ModuleSelfAuth#onlySelf: NOT_AUTHORIZED\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/ModuleStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\nlibrary ModuleStorage {\\n  function writeBytes32(bytes32 _key, bytes32 _val) internal {\\n    assembly { sstore(_key, _val) }\\n  }\\n\\n  function readBytes32(bytes32 _key) internal view returns (bytes32 val) {\\n    assembly { val := sload(_key) }\\n  }\\n\\n  function writeBytes32Map(bytes32 _key, bytes32 _subKey, bytes32 _val) internal {\\n    bytes32 key = keccak256(abi.encode(_key, _subKey));\\n    assembly { sstore(key, _val) }\\n  }\\n\\n  function readBytes32Map(bytes32 _key, bytes32 _subKey) internal view returns (bytes32 val) {\\n    bytes32 key = keccak256(abi.encode(_key, _subKey));\\n    assembly { val := sload(key) }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/ModuleCalls.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ModuleSelfAuth.sol\\\";\\nimport \\\"./ModuleStorage.sol\\\";\\nimport \\\"./ModuleERC165.sol\\\";\\n\\nimport \\\"./interfaces/IModuleCalls.sol\\\";\\nimport \\\"./interfaces/IModuleAuth.sol\\\";\\n\\n\\nabstract contract ModuleCalls is IModuleCalls, IModuleAuth, ModuleERC165, ModuleSelfAuth {\\n  //                       NONCE_KEY = keccak256(\\\"org.arcadeum.module.calls.nonce\\\");\\n  bytes32 private constant NONCE_KEY = bytes32(0x8d0bf1fd623d628c741362c1289948e57b3e2905218c676d3e69abee36d6ae2e);\\n\\n  uint256 private constant NONCE_BITS = 96;\\n  bytes32 private constant NONCE_MASK = bytes32((1 << NONCE_BITS) - 1);\\n\\n  /**\\n   * @notice Returns the next nonce of the default nonce space\\n   * @dev The default nonce space is 0x00\\n   * @return The next nonce\\n   */\\n  function nonce() external override virtual view returns (uint256) {\\n    return readNonce(0);\\n  }\\n\\n  /**\\n   * @notice Returns the next nonce of the given nonce space\\n   * @param _space Nonce space, each space keeps an independent nonce count\\n   * @return The next nonce\\n   */\\n  function readNonce(uint256 _space) public override virtual view returns (uint256) {\\n    return uint256(ModuleStorage.readBytes32Map(NONCE_KEY, bytes32(_space)));\\n  }\\n\\n  /**\\n   * @notice Changes the next nonce of the given nonce space\\n   * @param _space Nonce space, each space keeps an independent nonce count\\n   * @param _nonce Nonce to write on the space\\n   */\\n  function _writeNonce(uint256 _space, uint256 _nonce) private {\\n    ModuleStorage.writeBytes32Map(NONCE_KEY, bytes32(_space), bytes32(_nonce));\\n  }\\n\\n  /**\\n   * @notice Allow wallet owner to execute an action\\n   * @dev Relayers must ensure that the gasLimit specified for each transaction\\n   *      is acceptable to them. A user could specify large enough that it could\\n   *      consume all the gas available.\\n   * @param _txs        Transactions to process\\n   * @param _nonce      Signature nonce (may contain an encoded space)\\n   * @param _signature  Encoded signature\\n   */\\n  function execute(\\n    Transaction[] memory _txs,\\n    uint256 _nonce,\\n    bytes memory _signature\\n  ) public override virtual {\\n    // Validate and update nonce\\n    _validateNonce(_nonce);\\n\\n    // Hash transaction bundle\\n    bytes32 txHash = _hashData(abi.encode(_nonce, _txs));\\n\\n    // Verify that signatures are valid\\n    require(\\n      _signatureValidation(txHash, _signature),\\n      \\\"ModuleCalls#execute: INVALID_SIGNATURE\\\"\\n    );\\n\\n    // Execute the transactions\\n    _execute(txHash, _txs);\\n  }\\n\\n  /**\\n   * @notice Allow wallet to execute an action\\n   *   without signing the message\\n   * @param _txs  Transactions to execute\\n   */\\n  function selfExecute(\\n    Transaction[] memory _txs\\n  ) public override virtual onlySelf {\\n    // Hash transaction bundle\\n    bytes32 txHash = _hashData(abi.encode('self:', _txs));\\n\\n    // Execute the transactions\\n    _execute(txHash, _txs);\\n  }\\n\\n  /**\\n   * @notice Executes a list of transactions\\n   * @param _txHash  Hash of the batch of transactions\\n   * @param _txs  Transactions to execute\\n   */\\n  function _execute(\\n    bytes32 _txHash,\\n    Transaction[] memory _txs\\n  ) private {\\n    // Execute transaction\\n    for (uint256 i = 0; i < _txs.length; i++) {\\n      Transaction memory transaction = _txs[i];\\n\\n      bool success;\\n      bytes memory result;\\n\\n      require(gasleft() >= transaction.gasLimit, \\\"ModuleCalls#_execute: NOT_ENOUGH_GAS\\\");\\n\\n      if (transaction.delegateCall) {\\n        (success, result) = transaction.target.delegatecall{\\n          gas: transaction.gasLimit == 0 ? gasleft() : transaction.gasLimit\\n        }(transaction.data);\\n      } else {\\n        (success, result) = transaction.target.call{\\n          value: transaction.value,\\n          gas: transaction.gasLimit == 0 ? gasleft() : transaction.gasLimit\\n        }(transaction.data);\\n      }\\n\\n      if (success) {\\n        emit TxExecuted(_txHash);\\n      } else {\\n        _revertBytes(transaction, _txHash, result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Verify if a nonce is valid\\n   * @param _rawNonce Nonce to validate (may contain an encoded space)\\n   * @dev A valid nonce must be above the last one used\\n   *   with a maximum delta of 100\\n   */\\n  function _validateNonce(uint256 _rawNonce) private {\\n    // Retrieve current nonce for this wallet\\n    (uint256 space, uint256 providedNonce) = _decodeNonce(_rawNonce);\\n    uint256 currentNonce = readNonce(space);\\n\\n    // Verify if nonce is valid\\n    require(\\n      providedNonce == currentNonce,\\n      \\\"MainModule#_auth: INVALID_NONCE\\\"\\n    );\\n\\n    // Update signature nonce\\n    uint256 newNonce = providedNonce + 1;\\n    _writeNonce(space, newNonce);\\n    emit NonceChange(space, newNonce);\\n  }\\n\\n  /**\\n   * @notice Logs a failed transaction, reverts if the transaction is not optional\\n   * @param _tx      Transaction that is reverting\\n   * @param _txHash  Hash of the transaction\\n   * @param _reason  Encoded revert message\\n   */\\n  function _revertBytes(\\n    Transaction memory _tx,\\n    bytes32 _txHash,\\n    bytes memory _reason\\n  ) internal {\\n    if (_tx.revertOnError) {\\n      assembly { revert(add(_reason, 0x20), mload(_reason)) }\\n    } else {\\n      emit TxFailed(_txHash, _reason);\\n    }\\n  }\\n\\n  /**\\n   * @notice Decodes a raw nonce\\n   * @dev A raw nonce is encoded using the first 160 bits for the space\\n   *  and the last 96 bits for the nonce\\n   * @param _rawNonce Nonce to be decoded\\n   * @return _space The nonce space of the raw nonce\\n   * @return _nonce The nonce of the raw nonce\\n   */\\n  function _decodeNonce(uint256 _rawNonce) private pure returns (uint256 _space, uint256 _nonce) {\\n    _nonce = uint256(bytes32(_rawNonce) & NONCE_MASK);\\n    _space = _rawNonce >> NONCE_BITS;\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\\n    if (_interfaceID == type(IModuleCalls).interfaceId) {\\n      return true;\\n    }\\n\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/ModuleCreator.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\nimport \\\"./interfaces/IModuleCreator.sol\\\";\\n\\nimport \\\"./ModuleSelfAuth.sol\\\";\\nimport \\\"./ModuleERC165.sol\\\";\\n\\n\\ncontract ModuleCreator is IModuleCreator, ModuleERC165, ModuleSelfAuth {\\n  event CreatedContract(address _contract);\\n\\n  /**\\n   * @notice Creates a contract forwarding eth value\\n   * @param _code Creation code of the contract\\n   * @return addr The address of the created contract\\n   */\\n  function createContract(bytes memory _code) public override payable onlySelf returns (address addr) {\\n    assembly { addr := create(callvalue(), add(_code, 32), mload(_code)) }\\n    emit CreatedContract(addr);\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\\n    if (_interfaceID == type(IModuleCreator).interfaceId) {\\n      return true;\\n    }\\n\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/ModuleHooks.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\nimport \\\"./interfaces/IModuleHooks.sol\\\";\\n\\nimport \\\"./ModuleSelfAuth.sol\\\";\\nimport \\\"./ModuleStorage.sol\\\";\\nimport \\\"./ModuleERC165.sol\\\";\\n\\nimport \\\"../../interfaces/receivers/IERC1155Receiver.sol\\\";\\nimport \\\"../../interfaces/receivers/IERC721Receiver.sol\\\";\\nimport \\\"../../interfaces/receivers/IERC223Receiver.sol\\\";\\n\\n\\ncontract ModuleHooks is IERC1155Receiver, IERC721Receiver, IModuleHooks, ModuleERC165, ModuleSelfAuth {\\n  //                       HOOKS_KEY = keccak256(\\\"org.arcadeum.module.hooks.hooks\\\");\\n  bytes32 private constant HOOKS_KEY = bytes32(0xbe27a319efc8734e89e26ba4bc95f5c788584163b959f03fa04e2d7ab4b9a120);\\n\\n  /**\\n   * @notice Reads the implementation hook of a signature\\n   * @param _signature Signature function\\n   * @return The address of the implementation hook, address(0) if none\\n  */\\n  function readHook(bytes4 _signature) external override view returns (address) {\\n    return _readHook(_signature);\\n  }\\n\\n  /**\\n   * @notice Adds a new hook to handle a given function selector\\n   * @param _signature Signature function linked to the hook\\n   * @param _implementation Hook implementation contract\\n   * @dev Can't overwrite hooks that are part of the mainmodule (those defined below)\\n   */\\n  function addHook(bytes4 _signature, address _implementation) external override onlySelf {\\n    require(_readHook(_signature) == address(0), \\\"ModuleHooks#addHook: HOOK_ALREADY_REGISTERED\\\");\\n    _writeHook(_signature, _implementation);\\n  }\\n\\n  /**\\n   * @notice Removes a registered hook\\n   * @param _signature Signature function linked to the hook\\n   * @dev Can't remove hooks that are part of the mainmodule (those defined below) \\n   *      without upgrading the wallet\\n   */\\n  function removeHook(bytes4 _signature) external override onlySelf {\\n    require(_readHook(_signature) != address(0), \\\"ModuleHooks#removeHook: HOOK_NOT_REGISTERED\\\");\\n    _writeHook(_signature, address(0));\\n  }\\n\\n  /**\\n   * @notice Reads the implementation hook of a signature\\n   * @param _signature Signature function\\n   * @return The address of the implementation hook, address(0) if none\\n  */\\n  function _readHook(bytes4 _signature) private view returns (address) {\\n    return address(uint256(ModuleStorage.readBytes32Map(HOOKS_KEY, _signature)));\\n  }\\n\\n  /**\\n   * @notice Writes the implementation hook of a signature\\n   * @param _signature Signature function\\n   * @param _implementation Hook implementation contract\\n  */\\n  function _writeHook(bytes4 _signature, address _implementation) private {\\n    ModuleStorage.writeBytes32Map(HOOKS_KEY, _signature, bytes32(uint256(_implementation)));\\n  }\\n\\n  /**\\n   * @notice Handle the receipt of a single ERC1155 token type.\\n   * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   */\\n  function onERC1155Received(\\n    address,\\n    address,\\n    uint256,\\n    uint256,\\n    bytes calldata\\n  ) external override returns (bytes4) {\\n    return ModuleHooks.onERC1155Received.selector;\\n  }\\n\\n  /**\\n   * @notice Handle the receipt of multiple ERC1155 token types.\\n   * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   */\\n  function onERC1155BatchReceived(\\n    address,\\n    address,\\n    uint256[] calldata,\\n    uint256[] calldata,\\n    bytes calldata\\n  ) external override returns (bytes4) {\\n    return ModuleHooks.onERC1155BatchReceived.selector;\\n  }\\n\\n  /**\\n   * @notice Handle the receipt of a single ERC721 token.\\n   * @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n   */\\n  function onERC721Received(address, address, uint256, bytes calldata) external override returns (bytes4) {\\n    return ModuleHooks.onERC721Received.selector;\\n  }\\n\\n  /**\\n   * @notice Routes fallback calls through hooks\\n   */\\n  fallback() external payable {\\n    address target = _readHook(msg.sig);\\n    if (target != address(0)) {\\n      (bool success, bytes memory result) = target.delegatecall(msg.data);\\n      assembly {\\n        if iszero(success)  {\\n          revert(add(result, 0x20), mload(result))\\n        }\\n\\n        return(add(result, 0x20), mload(result))\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows the wallet to receive ETH\\n   */\\n  receive() external payable { }\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\\n    if (\\n      _interfaceID == type(IModuleHooks).interfaceId ||\\n      _interfaceID == type(IERC1155Receiver).interfaceId ||\\n      _interfaceID == type(IERC721Receiver).interfaceId ||\\n      _interfaceID == type(IERC223Receiver).interfaceId\\n    ) {\\n      return true;\\n    }\\n\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/commons/ModuleUpdate.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\nimport \\\"./interfaces/IModuleUpdate.sol\\\";\\n\\nimport \\\"./Implementation.sol\\\";\\nimport \\\"./ModuleSelfAuth.sol\\\";\\nimport \\\"./ModuleERC165.sol\\\";\\n\\nimport \\\"../../utils/LibAddress.sol\\\";\\n\\n\\ncontract ModuleUpdate is IModuleUpdate, ModuleERC165, ModuleSelfAuth, Implementation {\\n  using LibAddress for address;\\n\\n  event ImplementationUpdated(address newImplementation);\\n\\n  /**\\n   * @notice Updates the implementation of the base wallet\\n   * @param _implementation New main module implementation\\n   * @dev WARNING Updating the implementation can brick the wallet\\n   */\\n  function updateImplementation(address _implementation) external override onlySelf {\\n    require(_implementation.isContract(), \\\"ModuleUpdate#updateImplementation: INVALID_IMPLEMENTATION\\\");\\n    _setImplementation(_implementation);\\n    emit ImplementationUpdated(_implementation);\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\\n    if (_interfaceID == type(IModuleUpdate).interfaceId) {\\n      return true;\\n    }\\n\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibAddress.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\n\\n\\nlibrary LibAddress {\\n  /**\\n   * @notice Will return true if provided address is a contract\\n   * @param account Address to verify if contract or not\\n   * @dev This contract will return false if called within the constructor of\\n   *      a contract's deployment, as the code is not yet stored on-chain.\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 csize;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly { csize := extcodesize(account) }\\n    return csize != 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/GuestModule.sol\": {\r\n      \"content\": \"pragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../utils/SignatureValidator.sol\\\";\\n\\nimport \\\"./commons/Implementation.sol\\\";\\nimport \\\"./commons/ModuleAuth.sol\\\";\\nimport \\\"./commons/ModuleHooks.sol\\\";\\nimport \\\"./commons/ModuleCalls.sol\\\";\\nimport \\\"./commons/ModuleUpdate.sol\\\";\\nimport \\\"./commons/ModuleCreator.sol\\\";\\n\\nimport \\\"../interfaces/receivers/IERC1155Receiver.sol\\\";\\nimport \\\"../interfaces/receivers/IERC721Receiver.sol\\\";\\n\\nimport \\\"../interfaces/IERC1271Wallet.sol\\\";\\n\\n\\n/**\\n * GuestModule implements an Arcadeum wallet without signatures, nonce or replay protection.\\n * executing transactions using this wallet is not an authenticated process, and can be done by any address.\\n *\\n * @notice This contract is completely public with no security, designed to execute pre-signed transactions\\n *   and use Arcadeum tools without using the wallets.\\n */\\ncontract GuestModule is\\n  ModuleAuth,\\n  ModuleCalls,\\n  ModuleCreator\\n{\\n  /**\\n   * @notice Allow any caller to execute an action\\n   * @param _txs Transactions to process\\n   */\\n  function execute(\\n    Transaction[] memory _txs,\\n    uint256,\\n    bytes memory\\n  ) public override {\\n    // Hash transaction bundle\\n    bytes32 txHash = _hashData(abi.encode('guest:', _txs));\\n\\n    // Execute the transactions\\n    _executeGuest(txHash, _txs);\\n  }\\n\\n  /**\\n   * @notice Allow any caller to execute an action\\n   * @param _txs Transactions to process\\n   */\\n  function selfExecute(\\n    Transaction[] memory _txs\\n  ) public override {\\n    // Hash transaction bundle\\n    bytes32 txHash = _hashData(abi.encode('self:', _txs));\\n\\n    // Execute the transactions\\n    _executeGuest(txHash, _txs);\\n  }\\n\\n  /**\\n   * @notice Executes a list of transactions\\n   * @param _txHash  Hash of the batch of transactions\\n   * @param _txs  Transactions to execute\\n   */\\n  function _executeGuest(\\n    bytes32 _txHash,\\n    Transaction[] memory _txs\\n  ) private {\\n    // Execute transaction\\n    for (uint256 i = 0; i < _txs.length; i++) {\\n      Transaction memory transaction = _txs[i];\\n\\n      bool success;\\n      bytes memory result;\\n\\n      require(!transaction.delegateCall, 'GuestModule#_executeGuest: delegateCall not allowed');\\n      require(gasleft() >= transaction.gasLimit, \\\"GuestModule#_executeGuest: NOT_ENOUGH_GAS\\\");\\n\\n      // solhint-disable\\n      (success, result) = transaction.target.call{\\n        value: transaction.value,\\n        gas: transaction.gasLimit == 0 ? gasleft() : transaction.gasLimit\\n      }(transaction.data);\\n      // solhint-enable\\n\\n      if (success) {\\n        emit TxExecuted(_txHash);\\n      } else {\\n        _revertBytes(transaction, _txHash, result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Validates any signature image, because the wallet is public and has now owner.\\n   * @return true, all signatures are valid.\\n   */\\n  function _isValidImage(bytes32) internal override view returns (bool) {\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(\\n    bytes4 _interfaceID\\n  ) public override (\\n    ModuleAuth,\\n    ModuleCalls,\\n    ModuleCreator\\n  ) pure returns (bool) {\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/MainModule.sol\": {\r\n      \"content\": \"pragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../utils/SignatureValidator.sol\\\";\\n\\nimport \\\"./commons/Implementation.sol\\\";\\nimport \\\"./commons/ModuleAuthFixed.sol\\\";\\nimport \\\"./commons/ModuleHooks.sol\\\";\\nimport \\\"./commons/ModuleCalls.sol\\\";\\nimport \\\"./commons/ModuleUpdate.sol\\\";\\nimport \\\"./commons/ModuleCreator.sol\\\";\\n\\nimport \\\"../interfaces/receivers/IERC1155Receiver.sol\\\";\\nimport \\\"../interfaces/receivers/IERC721Receiver.sol\\\";\\n\\nimport \\\"../interfaces/IERC1271Wallet.sol\\\";\\n\\n\\n/**\\n * @notice Contains the core functionality arcadeum wallets will inherit.\\n * @dev If using a new main module, developpers must ensure that all inherited\\n *      contracts by the mainmodule don't conflict and are accounted for to be\\n *      supported by the supportsInterface method.\\n */\\ncontract MainModule is\\n  ModuleAuthFixed,\\n  ModuleCalls,\\n  ModuleUpdate,\\n  ModuleHooks,\\n  ModuleCreator\\n{\\n  constructor(\\n    address _factory\\n  ) public ModuleAuthFixed(\\n    _factory\\n  ) { }\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(\\n    bytes4 _interfaceID\\n  ) public override(\\n    ModuleAuth,\\n    ModuleCalls,\\n    ModuleUpdate,\\n    ModuleHooks,\\n    ModuleCreator\\n  ) pure returns (bool) {\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/MainModuleUpgradable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./commons/ModuleAuthUpgradable.sol\\\";\\nimport \\\"./commons/ModuleHooks.sol\\\";\\nimport \\\"./commons/ModuleCalls.sol\\\";\\nimport \\\"./commons/ModuleUpdate.sol\\\";\\nimport \\\"./commons/ModuleCreator.sol\\\";\\n\\n\\n/**\\n * @notice Contains the core functionality arcadeum wallets will inherit with\\n *         the added functionality that the main-module can be changed.\\n * @dev If using a new main module, developpers must ensure that all inherited\\n *      contracts by the mainmodule don't conflict and are accounted for to be\\n *      supported by the supportsInterface method.\\n */\\ncontract MainModuleUpgradable is\\n  ModuleAuthUpgradable,\\n  ModuleCalls,\\n  ModuleUpdate,\\n  ModuleHooks,\\n  ModuleCreator\\n{\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @dev If using a new main module, developpers must ensure that all inherited\\n   *      contracts by the mainmodule don't conflict and are accounted for to be\\n   *      supported by the supportsInterface method.\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(\\n    bytes4 _interfaceID\\n  ) public override(\\n    ModuleAuthUpgradable,\\n    ModuleCalls,\\n    ModuleUpdate,\\n    ModuleHooks,\\n    ModuleCreator\\n  ) pure returns (bool) {\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/utils/RequireUtils.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../commons/interfaces/IModuleCalls.sol\\\";\\nimport \\\"../commons/interfaces/IModuleAuthUpgradable.sol\\\";\\nimport \\\"../../Wallet.sol\\\";\\n\\n\\ncontract RequireUtils {\\n  uint256 private constant NONCE_BITS = 96;\\n  bytes32 private constant NONCE_MASK = bytes32((1 << NONCE_BITS) - 1);\\n\\n  bytes32 private immutable INIT_CODE_HASH;\\n  address private immutable FACTORY;\\n\\n  struct Member {\\n    uint256 weight;\\n    address signer;\\n  }\\n\\n  event RequiredConfig(\\n    address indexed _wallet,\\n    bytes32 indexed _imageHash,\\n    uint256 _threshold,\\n    bytes _signers\\n  );\\n\\n  constructor(address _factory, address _mainModule) public {\\n    FACTORY = _factory;\\n    INIT_CODE_HASH = keccak256(abi.encodePacked(Wallet.creationCode, uint256(_mainModule)));\\n  }\\n\\n  function requireConfig(\\n    address _wallet,\\n    uint256 _threshold,\\n    Member[] calldata _members\\n  ) external {\\n    // Compute expected imageHash\\n    bytes32 imageHash = bytes32(uint256(_threshold));\\n    for (uint256 i = 0; i < _members.length; i++) {\\n      imageHash = keccak256(abi.encode(imageHash, _members[i].weight, _members[i].signer));\\n    }\\n\\n    // Check against wallet imageHash\\n    (bool succeed, bytes memory data) = _wallet.call(abi.encodePacked(IModuleAuthUpgradable(_wallet).imageHash.selector));\\n    if (succeed && data.length == 32) {\\n      // Check contract defined\\n      bytes32 currentImageHash = abi.decode(data, (bytes32));\\n      require(currentImageHash == imageHash, \\\"RequireUtils#requireConfig: UNEXPECTED_IMAGE_HASH\\\");\\n    } else {\\n      // Check counter-factual\\n      require(address(\\n        uint256(\\n          keccak256(\\n            abi.encodePacked(\\n              byte(0xff),\\n              FACTORY,\\n              imageHash,\\n              INIT_CODE_HASH\\n            )\\n          )\\n        )\\n      ) == _wallet, \\\"RequireUtils#requireConfig: UNEXPECTED_COUNTERFACTUAL_IMAGE_HASH\\\");\\n    }\\n\\n    // Emit event for easy config retrieval\\n    emit RequiredConfig(_wallet, imageHash, _threshold, abi.encode(_members));\\n  }\\n\\n  function requireNonExpired(uint256 _expiration) external view {\\n    require(block.timestamp < _expiration, \\\"RequireUtils#requireNonExpired: EXPIRED\\\");\\n  }\\n\\n  function requireMinNonce(address _wallet, uint256 _nonce) external view {\\n    (uint256 space, uint256 nonce) = _decodeNonce(_nonce);\\n    uint256 currentNonce = IModuleCalls(_wallet).readNonce(space);\\n    require(currentNonce >= nonce, \\\"RequireUtils#requireMinNonce: NONCE_BELOW_REQUIRED\\\");\\n  }\\n\\n  /**\\n   * @notice Decodes a raw nonce\\n   * @dev A raw nonce is encoded using the first 160 bits for the space\\n   *  and the last 96 bits for the nonce\\n   * @param _rawNonce Nonce to be decoded\\n   * @return _space The nonce space of the raw nonce\\n   * @return _nonce The nonce of the raw nonce\\n   */\\n  function _decodeNonce(uint256 _rawNonce) private pure returns (uint256 _space, uint256 _nonce) {\\n    _nonce = uint256(bytes32(_rawNonce) & NONCE_MASK);\\n    _space = _rawNonce >> NONCE_BITS;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mainModule\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_imageHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_signers\",\"type\":\"bytes\"}],\"name\":\"RequiredConfig\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"internalType\":\"struct RequireUtils.Member[]\",\"name\":\"_members\",\"type\":\"tuple[]\"}],\"name\":\"requireConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"requireMinNonce\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expiration\",\"type\":\"uint256\"}],\"name\":\"requireNonExpired\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RequireUtils","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"00000000000000000000000029285b3b5bbccc83f0c116311abb93127d0f90da00000000000000000000000039bbffacb26c59810a522ae152c98aef16ae4430","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}