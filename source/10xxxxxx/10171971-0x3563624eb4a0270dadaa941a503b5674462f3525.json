{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.6.6;\n\n\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    \n    \n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        virtual\n        onlyOwner\n    {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function renounceOwnership()\n        public\n        onlyOwner\n    {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n}\n\ncontract Claimable is Ownable\n{\n    address public pendingOwner;\n\n    \n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        override\n        onlyOwner\n    {\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\n        pendingOwner = newOwner;\n    }\n\n    \n    function claimOwnership()\n        public\n        onlyPendingOwner\n    {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\ncontract AddressSet {\n    struct Set\n    {\n        address[] addresses;\n        mapping (address => uint) positions;\n        uint count;\n    }\n    mapping (bytes32 => Set) private sets;\n\n    function addAddressToSet(\n        bytes32 key,\n        address addr,\n        bool maintainList\n        ) internal\n    {\n        Set storage set = sets[key];\n        require(set.positions[addr] == 0, \"ALREADY_IN_SET\");\n        \n        if (maintainList) {\n            require(set.addresses.length == set.count, \"PREVIOUSLY_NOT_MAINTAILED\");\n            set.addresses.push(addr);\n        } else {\n            require(set.addresses.length == 0, \"MUST_MAINTAIN\");\n        }\n\n        set.count += 1;\n        set.positions[addr] = set.count;\n    }\n\n    function removeAddressFromSet(\n        bytes32 key,\n        address addr\n        )\n        internal\n    {\n        Set storage set = sets[key];\n        uint pos = set.positions[addr];\n        require(pos != 0, \"NOT_IN_SET\");\n\n        delete set.positions[addr];\n        set.count -= 1;\n\n        if (set.addresses.length > 0) {\n            address lastAddr = set.addresses[set.count];\n            if (lastAddr != addr) {\n                set.addresses[pos - 1] = lastAddr;\n                set.positions[lastAddr] = pos;\n            }\n            set.addresses.pop();\n        }\n    }\n\n    function removeSet(bytes32 key)\n        internal\n    {\n        delete sets[key];\n    }\n\n    function isAddressInSet(\n        bytes32 key,\n        address addr\n        )\n        internal\n        view\n        returns (bool)\n    {\n        return sets[key].positions[addr] != 0;\n    }\n\n    function numAddressesInSet(bytes32 key)\n        internal\n        view\n        returns (uint)\n    {\n        Set storage set = sets[key];\n        return set.count;\n    }\n\n    function addressesInSet(bytes32 key)\n        internal\n        view\n        returns (address[] memory)\n    {\n        Set storage set = sets[key];\n        require(set.count == set.addresses.length, \"NOT_MAINTAINED\");\n        return sets[key].addresses;\n    }\n}\n\ncontract OwnerManagable is Claimable, AddressSet\n{\n    bytes32 internal constant MANAGER = keccak256(\"__MANAGED__\");\n\n    event ManagerAdded  (address indexed manager);\n    event ManagerRemoved(address indexed manager);\n\n    modifier onlyManager\n    {\n        require(isManager(msg.sender), \"NOT_MANAGER\");\n        _;\n    }\n\n    modifier onlyOwnerOrManager\n    {\n        require(msg.sender == owner || isManager(msg.sender), \"NOT_OWNER_OR_MANAGER\");\n        _;\n    }\n\n    constructor() public Claimable() {}\n\n    \n    \n    function managers()\n        public\n        view\n        returns (address[] memory)\n    {\n        return addressesInSet(MANAGER);\n    }\n\n    \n    \n    function numManagers()\n        public\n        view\n        returns (uint)\n    {\n        return numAddressesInSet(MANAGER);\n    }\n\n    \n    \n    \n    function isManager(address addr)\n        public\n        view\n        returns (bool)\n    {\n        return isAddressInSet(MANAGER, addr);\n    }\n\n    \n    \n    function addManager(address manager)\n        public\n        onlyOwner\n    {\n        addManagerInternal(manager);\n    }\n\n    \n    \n    function removeManager(address manager)\n        public\n        onlyOwner\n    {\n        removeAddressFromSet(MANAGER, manager);\n        emit ManagerRemoved(manager);\n    }\n\n    function addManagerInternal(address manager)\n        internal\n    {\n        addAddressToSet(MANAGER, manager, true);\n        emit ManagerAdded(manager);\n    }\n}\n\ninterface Wallet {\n    function owner() external view returns (address);\n\n    \n    function setOwner(address newOwner) external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function setup(address _controller, address _owner, address _boostrapModule) external;\n\n    \n    \n    \n    \n    function addModule(address _module) external;\n\n    \n    \n    \n    function removeModule(address _module) external;\n\n    \n    \n    \n    function modules() external view returns (address[] memory _modules);\n\n    \n    \n    \n    function hasModule(address _module) external view returns (bool);\n\n    \n    \n    \n    \n    \n    \n    \n    function bindMethod(bytes4 _method, address _module) external;\n\n    \n    \n    \n    \n    function boundMethodModule(bytes4 _method) external view returns (address _module);\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function transact(\n        uint8    mode,\n        address  to,\n        uint     value,\n        bytes    calldata data\n        )\n        external\n        returns (bytes memory returnData);\n}\n\ncontract DataStore {\n  modifier onlyWalletModule(address wallet)\n    {\n        require(Wallet(wallet).hasModule(msg.sender), \"UNAUTHORIZED\");\n        _;\n    }\n}\n\ncontract DappAddressStore is DataStore, OwnerManagable\n{\n    bytes32 internal constant DAPPS = keccak256(\"__DAPPS__\");\n\n    event Whitelisted(\n        address indexed addr,\n        bool            whitelisted\n    );\n\n    constructor() public DataStore() {}\n\n    function addDapp(address addr)\n        public\n        onlyManager\n    {\n        addAddressToSet(DAPPS, addr, true);\n        emit Whitelisted(addr, true);\n    }\n\n    function removeDapp(address addr)\n        public\n        onlyManager\n    {\n        removeAddressFromSet(DAPPS, addr);\n        emit Whitelisted(addr, false);\n    }\n\n    function dapps()\n        public\n        view\n        returns (\n            address[] memory addresses\n        )\n    {\n        return addressesInSet(DAPPS);\n    }\n\n    function isDapp(\n        address addr\n        )\n        public\n        view\n        returns (bool)\n    {\n        return isAddressInSet(DAPPS, addr);\n    }\n\n    function numDapps()\n        public\n        view\n        returns (uint)\n    {\n        return numAddressesInSet(DAPPS);\n    }\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addDapp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dapps\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isDapp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numDapps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numManagers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeDapp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DappAddressStore","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}