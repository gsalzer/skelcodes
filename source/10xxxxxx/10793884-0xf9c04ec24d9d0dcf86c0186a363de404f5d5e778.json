{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.0;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract BullStaking is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _stakes;\r\n\r\n    address public owner = msg.sender;\r\n    address  public tokenAddress;\r\n    uint public stakingStarts;\r\n    uint public stakingEnds;\r\n    uint public withdrawStarts;\r\n    uint public withdrawEnds;\r\n    uint256 public stakedTotal;\r\n    uint256 public stakingCap;\r\n    uint256 public totalReward;\r\n    uint256 public earlyWithdrawReward;\r\n    uint256 public rewardBalance;\r\n    uint256 public stakedBalance;\r\n\r\n    address payable ethFund = 0xB205238e2eCb8462d5D826E28DCd2aCe0BF811a4;\r\n\r\n    ERC20 public ERC20Interface;\r\n    event Staked(address indexed token, address indexed staker_, uint256 requestedAmount_, uint256 stakedAmount_);\r\n    event PaidOut(address indexed token, address indexed staker_, uint256 amount_, uint256 reward_);\r\n    event Refunded(address indexed token, address indexed staker_, uint256 amount_);\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    uint256 public price;\r\n    uint256 public sold = 0;\r\n\r\n    bool public distributionFinished = false;\r\n\r\n    bool public distribution_ongoing = false;\r\n\r\n    uint256 public tokensPerEth = 60000e18;\r\n\r\n    constructor (string memory name, string memory symbol, address payable _ethFund, uint256 _tokensPerEth) public {\r\n        tokensPerEth = _tokensPerEth*1e18;\r\n        price = SafeMath.div(1e18, SafeMath.div(tokensPerEth, 1e18));\r\n        _name = name;\r\n        _symbol = symbol;\r\n        ethFund = _ethFund;\r\n        _decimals = 18;\r\n        _totalSupply = 100000000e18;\r\n        owner = msg.sender;\r\n        _balances[owner] = _balances[owner].add(_totalSupply);\r\n    }\r\n\r\n    modifier saleHappening {\r\n      require(distribution_ongoing == true, \"distribution started\");\r\n      require(sold <= _totalSupply, \"tokens sold out\");\r\n      _;\r\n    }\r\n\r\n    function tokenSaleStarted() public view returns (bool) {\r\n        return distribution_ongoing;\r\n    }\r\n\r\n    function startSale() public\r\n    onlyOwner {\r\n      distribution_ongoing = true;\r\n    }\r\n\r\n    function endSale() public\r\n    onlyOwner {\r\n      distribution_ongoing = false;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n\r\n    function finishDistribution() onlyOwner canDistr public returns (bool) {\r\n        distributionFinished = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\r\n\r\n        _balances[owner] = _balances[owner].sub(_amount);\r\n        _balances[_to] = _balances[_to].add(_amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier canDistr() {\r\n        require(!distributionFinished);\r\n        _;\r\n    }\r\n\r\n\r\n    receive ()\r\n      external\r\n      payable\r\n      saleHappening\r\n    {\r\n      \r\n      uint excessAmount = msg.value % price;\r\n\r\n      uint purchaseAmount = SafeMath.sub(msg.value, excessAmount);\r\n\r\n      uint tokenPurchase = SafeMath.div(SafeMath.mul(purchaseAmount,1e18), price);\r\n\r\n      uint total_token = tokenPurchase;\r\n\r\n      sold= SafeMath.add(sold, total_token);\r\n\r\n      assert(sold <= _totalSupply);\r\n\r\n      ethFund.transfer(msg.value);\r\n      assert(distr(msg.sender, total_token));\r\n\r\n    }\r\n\r\n\r\n    function init_staking(\r\n        address tokenAddress_,\r\n        uint stakingEnds_,\r\n        uint withdrawStarts_,\r\n        uint256 stakingCap_\r\n    )\r\n\r\n    public onlyOwner {\r\n\r\n        require(tokenAddress_ != address(0), \"BullStaking: 0 address\");\r\n        tokenAddress = tokenAddress_;\r\n\r\n        stakingStarts = now;\r\n\r\n        require(stakingEnds_ > 0, \"BullStaking: staking end must be positive\");\r\n        stakingEnds = now + stakingEnds_;\r\n\r\n        require(withdrawStarts_ >= stakingEnds_, \"Bulltaking: withdrawStarts must be after staking ends\");\r\n        withdrawStarts = withdrawStarts_;\r\n\r\n        withdrawEnds = withdrawStarts + 180 days; // 6 months to withdraw reward\r\n\r\n        require(stakingCap_ > 0, \"BullStaking: stakingCap must be positive\");\r\n        stakingCap = stakingCap_;\r\n    }\r\n\r\n    function addReward(uint256 rewardAmount, uint256 withdrawableAmount)\r\n    public\r\n\r\n    returns (bool) {\r\n        require(rewardAmount > 0, \"BullStaking: reward must be positive\");\r\n        require(withdrawableAmount >= 0, \"BullStaking: withdrawable amount cannot be negative\");\r\n        require(withdrawableAmount <= rewardAmount, \"BullStaking: withdrawable amount must be less than or equal to the reward amount\");\r\n        address from = msg.sender;\r\n        if (!_payMe(from, rewardAmount)) {\r\n            return false;\r\n        }\r\n\r\n        totalReward = totalReward.add(rewardAmount);\r\n        rewardBalance = totalReward;\r\n        earlyWithdrawReward = earlyWithdrawReward.add(withdrawableAmount);\r\n        return true;\r\n    }\r\n\r\n    function stakeOf(address account) public view returns (uint256) {\r\n        return _stakes[account];\r\n    }\r\n\r\n    function stake(uint256 amount)\r\n    public\r\n    _positive(amount)\r\n    _realAddress(msg.sender)\r\n    returns (bool) {\r\n        address from = msg.sender;\r\n        return _stake(from, amount);\r\n    }\r\n\r\n    function withdraw(uint256 amount)\r\n    public\r\n    _after(withdrawStarts)\r\n    _positive(amount)\r\n    _realAddress(msg.sender)\r\n    returns (bool) {\r\n        address from = msg.sender;\r\n        require(amount <= _stakes[from], \"BullStaking: not enough balance\");\r\n        if (now < withdrawEnds) {\r\n            return _withdrawEarly(from, amount);\r\n        } else {\r\n            return _withdrawAfterClose(from, amount);\r\n        }\r\n    }\r\n\r\n    function _withdrawEarly(address from, uint256 amount)\r\n    private\r\n    _realAddress(from)\r\n    returns (bool) {\r\n        // The formula to calculate reward:\r\n        // r = (earlyWithdrawReward / stakedTotal) * (now - stakingEnds) / (withdrawEnds - stakingEnds)\r\n        // w = (1+r) * a\r\n        uint256 denom = (withdrawEnds.sub(stakingEnds)).mul(stakedTotal);\r\n        uint256 reward = (\r\n        ( (now.sub(stakingEnds)).mul(earlyWithdrawReward) ).mul(amount)\r\n        ).div(denom);\r\n        uint256 payOut = amount.add(reward);\r\n        rewardBalance = rewardBalance.sub(reward);\r\n        stakedBalance = stakedBalance.sub(amount);\r\n        _stakes[from] = _stakes[from].sub(amount);\r\n        if (_payDirect(from, payOut)) {\r\n            emit PaidOut(tokenAddress, from, amount, reward);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _withdrawAfterClose(address from, uint256 amount)\r\n    private\r\n    _realAddress(from)\r\n    returns (bool) {\r\n        uint256 reward = (rewardBalance.mul(amount)).div(stakedBalance);\r\n        uint256 payOut = amount.add(reward);\r\n        _stakes[from] = _stakes[from].sub(amount);\r\n        if (_payDirect(from, payOut)) {\r\n            emit PaidOut(tokenAddress, from, amount, reward);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _stake(address staker, uint256 amount)\r\n    private\r\n    _after(stakingStarts)\r\n    _before(stakingEnds)\r\n    _positive(amount)\r\n    returns (bool) {\r\n        amount = amount*1e18;\r\n        uint256 remaining = amount;\r\n        if (remaining > (stakingCap.sub(stakedBalance))) {\r\n            remaining = stakingCap.sub(stakedBalance);\r\n        }\r\n\r\n        require(remaining > 0, \"BullStaking: Staking cap is filled\");\r\n        require((remaining + stakedTotal) <= stakingCap, \"BullStaking: this will increase staking amount pass the cap\");\r\n        if (!_payMe(staker, remaining)) {\r\n            return false;\r\n        }\r\n        emit Staked(tokenAddress, staker, amount, remaining);\r\n\r\n        if (remaining < amount) {\r\n\r\n            uint256 refund = amount.sub(remaining);\r\n            if (_payTo(staker, staker, refund)) {\r\n                emit Refunded(tokenAddress, staker, refund);\r\n            }\r\n        }\r\n\r\n        stakedBalance = stakedBalance.add(remaining);\r\n        stakedTotal = stakedTotal.add(remaining);\r\n        _stakes[staker] = _stakes[staker].add(remaining);\r\n        return true;\r\n    }\r\n\r\n    function _payMe(address payer, uint256 amount)\r\n    private\r\n    returns (bool) {\r\n        return _payTo(payer, address(this), amount);\r\n    }\r\n\r\n    function _payTo(address allower, address receiver, uint256 amount)\r\n    private\r\n    returns (bool) {\r\n\r\n        ERC20Interface = ERC20(tokenAddress);\r\n        return ERC20Interface.transferFrom(allower, receiver, amount);\r\n    }\r\n\r\n    function _payDirect(address to, uint256 amount)\r\n    private\r\n    _positive(amount)\r\n    returns (bool) {\r\n        ERC20Interface = ERC20(tokenAddress);\r\n        return ERC20Interface.transfer(to, amount);\r\n    }\r\n\r\n    modifier _realAddress(address addr) {\r\n        require(addr != address(0), \"BullStaking: zero address\");\r\n        _;\r\n    }\r\n\r\n    modifier _positive(uint256 amount) {\r\n        require(amount >= 0, \"BullStaking: negative amount\");\r\n        _;\r\n    }\r\n\r\n    modifier _after(uint eventTime) {\r\n        require(now >= eventTime, \"BullStaking: bad timing for the request\");\r\n        _;\r\n    }\r\n\r\n    modifier _before(uint eventTime) {\r\n        require(now < eventTime, \"BullStaking: bad timing for the request\");\r\n        _;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"_ethFund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokensPerEth\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_\",\"type\":\"uint256\"}],\"name\":\"PaidOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedAmount_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount_\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ERC20Interface\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableAmount\",\"type\":\"uint256\"}],\"name\":\"addReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribution_ongoing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlyWithdrawReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishDistribution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingEnds_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawStarts_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingCap_\",\"type\":\"uint256\"}],\"name\":\"init_staking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"stakeOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingEnds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingStarts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSaleStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEnds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStarts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BullStaking","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000069744a0c3679470212d08d269ec051dbeb8d6b0400000000000000000000000000000000000000000000000000000000000099f600000000000000000000000000000000000000000000000000000000000000135061796d656e7462756c6c2e66696e616e636500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000442554c4c00000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0f0066cd20c9c76f8d2d367b865807a9b0254a1512b6ce0e1152bc5c644229c4"}]}