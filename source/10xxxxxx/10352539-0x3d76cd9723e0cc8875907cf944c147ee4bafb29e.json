{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n    SPDX-License-Identifier: MIT\r\n    A Bankteller Production\r\n    Bankroll Network\r\n    Copyright 2020\r\n*/\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\ncontract Token {\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function balanceOf(address who) public view returns (uint256);\r\n}\r\n\r\ncontract UniSwapV2LiteRouter {\r\n\r\n    //function ethToTokenSwapInput(uint256 min_tokens) public payable returns (uint256);\r\n    function WETH() external pure returns (address);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] path, address to, uint deadline) external payable returns (uint[] amounts);\r\n}\r\n\r\n/*\r\n * @dev Life is a perpetual rewards contract the collects 9% fee for a dividend pool that drips 2% daily.\r\n * A 1% fee is used to buy back a specified ERC20/TRC20 token and distribute to LYF holders via a 2% drip\r\n*/\r\n\r\n\r\ncontract BankrollNetworkLife {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n\r\n    /// @dev Only people with tokens\r\n    modifier onlyBagholders {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Only people with profits\r\n    modifier onlyStronghands {\r\n        require(myDividends() > 0);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n\r\n\r\n    event onLeaderBoard(\r\n        address indexed customerAddress,\r\n        uint256 invested,\r\n        uint256 tokens,\r\n        uint256 soldTokens,\r\n        uint256 claims,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingeth,\r\n        uint256 tokensMinted,\r\n        uint timestamp\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethEarned,\r\n        uint timestamp\r\n    );\r\n\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethReinvested,\r\n        uint256 tokensMinted,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethWithdrawn,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onClaim(\r\n        address indexed customerAddress,\r\n        uint256 tokens,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onBuyBack(\r\n        uint ethAmount,\r\n        uint tokenAmount,\r\n        uint256 timestamp\r\n    );\r\n\r\n\r\n    event onBalance(\r\n        uint256 balance,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onDonation(\r\n        address indexed from,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    // Onchain Stats!!!\r\n    struct Stats {\r\n        uint invested;\r\n        uint reinvested;\r\n        uint withdrawn;\r\n        uint claims;\r\n        uint rewarded;\r\n        uint contributed;\r\n        uint transferredTokens;\r\n        uint receivedTokens;\r\n        int256 tokenPayoutsTo;\r\n        uint xInvested;\r\n        uint xReinvested;\r\n        uint xRewarded;\r\n        uint xContributed;\r\n        uint xWithdrawn;\r\n        uint xTransferredTokens;\r\n        uint xReceivedTokens;\r\n        uint xClaimed;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n\r\n    /// @dev 15% dividends for token purchase\r\n    uint8 constant internal entryFee_ = 10;\r\n\r\n\r\n    /// @dev 5% dividends for token selling\r\n    uint8 constant internal exitFee_ = 10;\r\n\r\n    uint8 constant internal dripFee = 80;  //80% of fees go to drip, the rest to the Swap buyback\r\n\r\n    uint8 constant payoutRate_ = 2;\r\n\r\n    uint256 constant internal magnitude = 2 ** 64;\r\n\r\n    /*=================================\r\n     =            DATASETS            =\r\n     ================================*/\r\n\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) private tokenBalanceLedger_;\r\n    mapping(address => int256) private payoutsTo_;\r\n    mapping(address => Stats) private stats;\r\n    //on chain referral tracking\r\n    uint256 private tokenSupply_;\r\n    uint256 private profitPerShare_;\r\n    uint256 private rewardsProfitPerShare_;\r\n    uint256 public totalDeposits;\r\n    uint256 internal lastBalance_;\r\n\r\n    uint public players;\r\n    uint public totalTxs;\r\n    uint public dividendBalance_;\r\n    uint public swapCollector_;\r\n    uint public swapBalance_;\r\n    uint public lastPayout;\r\n    uint public totalClaims;\r\n\r\n    uint256 public balanceInterval = 6 hours;\r\n    uint256 public distributionInterval = 2 seconds;\r\n    uint256 public depotFlushSize = 0.5 ether;\r\n\r\n\r\n    address public swapAddress;\r\n    address public tokenAddress;\r\n\r\n    Token private token;\r\n    UniSwapV2LiteRouter private swap;\r\n\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS           =\r\n    =======================================*/\r\n\r\n    constructor(address _tokenAddress, address _swapAddress) public {\r\n\r\n        tokenAddress = _tokenAddress;\r\n        token = Token(_tokenAddress);\r\n\r\n        swapAddress = _swapAddress;\r\n        swap = UniSwapV2LiteRouter(_swapAddress);\r\n\r\n        lastPayout = now;\r\n\r\n    }\r\n\r\n\r\n    /// @dev This is how you pump pure \"drip\" dividends into the system\r\n    function donatePool() public payable returns (uint256) {\r\n        require(msg.value > 0);\r\n\r\n        dividendBalance_ += msg.value;\r\n\r\n        emit onDonation(msg.sender, msg.value,now);\r\n    }\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buy() public payable returns (uint256)  {\r\n        return buyFor(msg.sender);\r\n    }\r\n\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buyFor(address _customerAddress) public payable returns (uint256)  {\r\n        require(msg.value > 0);\r\n        totalDeposits += msg.value;\r\n        uint amount = purchaseTokens(_customerAddress, msg.value);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            stats[_customerAddress].claims,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n\r\n        return amount;\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * @dev Fallback function to handle eth that was send straight to the contract\r\n     *  Unfortunately we cannot use a referral address this way.\r\n     */\r\n    function() payable public {\r\n        donatePool();\r\n    }\r\n\r\n    /// @dev Converts all of caller's dividends to tokens.\r\n    function reinvest() onlyStronghands public {\r\n        // fetch dividends\r\n        uint256 _dividends = myDividends();\r\n        // retrieve ref. bonus later in the code\r\n\r\n        // pay out the dividends virtually\r\n        address _customerAddress = msg.sender;\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens = purchaseTokens(msg.sender, _dividends);\r\n\r\n        // fire event\r\n        emit onReinvestment(_customerAddress, _dividends, _tokens, now);\r\n\r\n        //Stats\r\n        stats[_customerAddress].reinvested = SafeMath.add(stats[_customerAddress].reinvested, _dividends);\r\n        stats[_customerAddress].xReinvested += 1;\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            stats[_customerAddress].claims,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /// @dev Withdraws all of the callers earnings.\r\n    function withdraw() onlyStronghands public {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myDividends();\r\n\r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n\r\n        // lambo delivery service\r\n        _customerAddress.transfer(_dividends);\r\n\r\n        //stats\r\n        stats[_customerAddress].withdrawn = SafeMath.add(stats[_customerAddress].withdrawn, _dividends);\r\n        stats[_customerAddress].xWithdrawn += 1;\r\n        totalTxs += 1;\r\n\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends,now);\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /// @dev Withdraws all of the callers rewards.\r\n    function claim() public {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myClaims();\r\n\r\n        //only  to claim\r\n        require(_dividends > 0);\r\n\r\n        // update dividend tracker\r\n        stats[_customerAddress].tokenPayoutsTo += (int256) (_dividends * magnitude);\r\n\r\n\r\n        // lambo delivery service\r\n        token.transfer(_customerAddress, _dividends);\r\n\r\n        //stats\r\n        stats[_customerAddress].claims = SafeMath.add(stats[_customerAddress].claims, _dividends);\r\n        stats[_customerAddress].xClaimed += 1;\r\n        totalTxs += 1;\r\n\r\n        // fire event\r\n        emit onClaim(_customerAddress, _dividends,now);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            stats[_customerAddress].claims,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /// @dev Liquifies tokens to eth.\r\n    function sell(uint256 _amountOfTokens) onlyBagholders public {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.mul(_amountOfTokens, exitFee_) / 100;\r\n        uint256 _taxedeth = SafeMath.sub(_amountOfTokens, _undividedDividends);\r\n\r\n        //drip and buybacks\r\n        allocateFees(_undividedDividends);\r\n\r\n        // burn the sold tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfTokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens + (_taxedeth * magnitude));\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n\r\n        //update claims tracker; don't need to redeem extra claims\r\n        stats[_customerAddress].tokenPayoutsTo -= (int256) (rewardsProfitPerShare_ * _amountOfTokens);\r\n\r\n\r\n        // fire event\r\n        emit onTokenSell(_customerAddress, _amountOfTokens, _taxedeth, now);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            stats[_customerAddress].claims,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from the caller to a new holder.\r\n    *  Zero fees\r\n    */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders external returns (bool) {\r\n        // setup\r\n        address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested tokens\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n        // withdraw all outstanding dividends first\r\n        if (myDividends() > 0) {\r\n            withdraw();\r\n        }\r\n\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\r\n\r\n        // update dividend trackers\r\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);\r\n\r\n        //update claims tracker\r\n        stats[_customerAddress].tokenPayoutsTo -= (int256) (rewardsProfitPerShare_ * _amountOfTokens);\r\n        stats[_toAddress].tokenPayoutsTo += (int256) (rewardsProfitPerShare_ * _amountOfTokens);\r\n\r\n\r\n\r\n\r\n        /* Members\r\n            A player can be initialized by buying or receiving and we want to add the user ASAP\r\n         */\r\n        if (stats[_toAddress].invested == 0 && stats[_toAddress].receivedTokens == 0) {\r\n            players += 1;\r\n        }\r\n\r\n        //Stats\r\n        stats[_customerAddress].xTransferredTokens += 1;\r\n        stats[_customerAddress].transferredTokens += _amountOfTokens;\r\n        stats[_toAddress].receivedTokens += _amountOfTokens;\r\n        stats[_toAddress].xReceivedTokens += 1;\r\n        totalTxs += 1;\r\n\r\n        // fire event\r\n        emit onTransfer(_customerAddress, _toAddress, _amountOfTokens,now);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            stats[_customerAddress].claims,\r\n            now\r\n        );\r\n\r\n        emit onLeaderBoard(_toAddress,\r\n            stats[_toAddress].invested,\r\n            tokenBalanceLedger_[_toAddress],\r\n            stats[_toAddress].withdrawn,\r\n            stats[_toAddress].claims,\r\n            now\r\n        );\r\n\r\n        // ERC20\r\n        return true;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =      HELPERS AND CALCULATORS        =\r\n    =====================================*/\r\n\r\n    /**\r\n     * @dev Method to view the current eth stored in the contract\r\n     */\r\n    function totalEthBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    /// @dev Retrieve the total token supply.\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    /// @dev Retrieve the tokens owned by the caller.\r\n    function myTokens() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the dividends owned by the caller.\r\n     */\r\n    function myDividends() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return dividendsOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve token claims owned by the caller.\r\n     */\r\n    function myClaims() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return claimsOf(_customerAddress);\r\n    }\r\n\r\n\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function balanceOf(address _customerAddress) public view returns (uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function tokenBalance(address _customerAddress) public view returns (uint256) {\r\n        return _customerAddress.balance;\r\n    }\r\n\r\n    /// @dev Retrieve the dividend balance of any single address.\r\n    function dividendsOf(address _customerAddress) public view returns (uint256) {\r\n        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n    }\r\n\r\n    /// @dev Retrieve the claims balance of any single address.\r\n    function claimsOf(address _customerAddress) public view returns (uint256) {\r\n        return (uint256) ((int256) (rewardsProfitPerShare_ * tokenBalanceLedger_[_customerAddress]) - stats[_customerAddress].tokenPayoutsTo) / magnitude;\r\n    }\r\n\r\n    /// @dev Return the sell price of 1 individual token.\r\n    function sellPrice() public pure returns (uint256) {\r\n        uint256 _eth = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, exitFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_eth, _dividends);\r\n\r\n        return _taxedeth;\r\n\r\n    }\r\n\r\n    /// @dev Return the buy price of 1 individual token.\r\n    function buyPrice() public pure returns (uint256) {\r\n        uint256 _eth = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, entryFee_), 100);\r\n        uint256 _taxedeth = SafeMath.add(_eth, _dividends);\r\n\r\n        return _taxedeth;\r\n\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n    function calculateTokensReceived(uint256 _ethToSpend) public pure returns (uint256) {\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethToSpend, entryFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_ethToSpend, _dividends);\r\n        uint256 _amountOfTokens = _taxedeth;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n    function calculateethReceived(uint256 _tokensToSell) public view returns (uint256) {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _eth = _tokensToSell;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, exitFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_eth, _dividends);\r\n        return _taxedeth;\r\n    }\r\n\r\n\r\n    /// @dev Stats of any single address\r\n    function statsOf(address _customerAddress) public view returns (uint256[16] memory){\r\n        Stats memory s = stats[_customerAddress];\r\n        uint256[16] memory statArray = [s.invested, s.withdrawn, s.rewarded, s.contributed, s.transferredTokens, s.receivedTokens, s.xInvested, s.xRewarded, s.xContributed, s.xWithdrawn, s.xTransferredTokens, s.xReceivedTokens, s.reinvested, s.xReinvested, s.claims, s.xClaimed];\r\n        return statArray;\r\n    }\r\n\r\n\r\n    function dailyEstimate(address _customerAddress) public view returns (uint256){\r\n        uint256 share = dividendBalance_.mul(payoutRate_).div(100);\r\n\r\n        return (tokenSupply_ > 0) ? share.mul(tokenBalanceLedger_[_customerAddress]).div(tokenSupply_) : 0;\r\n    }\r\n\r\n    function dailyClaimEstimate(address _customerAddress) public view returns (uint256){\r\n        uint256 share = swapBalance_.mul(payoutRate_).div(100);\r\n\r\n        return (tokenSupply_ > 0) ? share.mul(tokenBalanceLedger_[_customerAddress]).div(tokenSupply_) : 0;\r\n    }\r\n\r\n    function allocateFees(uint fee) private {\r\n        uint _drip = SafeMath.mul(fee, dripFee) / 100;\r\n        uint _swap = SafeMath.safeSub(fee, _drip);\r\n\r\n        //Add to dividend drip pools\r\n        dividendBalance_ += _drip;\r\n        swapCollector_ += _swap;\r\n    }\r\n\r\n    function distribute() private {\r\n\r\n        if (now.safeSub(lastBalance_) > balanceInterval) {\r\n            emit onBalance(totalEthBalance(), now);\r\n            lastBalance_ = now;\r\n        }\r\n\r\n\r\n        if (SafeMath.safeSub(now, lastPayout) > distributionInterval && tokenSupply_ > 0) {\r\n\r\n            //A portion of the dividend is paid out according to the rate\r\n            uint256 share = dividendBalance_.mul(payoutRate_).div(100).div(24 hours);\r\n            //divide the profit by seconds in the day\r\n            uint256 profit = share * now.safeSub(lastPayout);\r\n            //share times the amount of time elapsed\r\n            dividendBalance_ = dividendBalance_.safeSub(profit);\r\n\r\n            //Apply divs\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (profit * magnitude) / tokenSupply_);\r\n\r\n\r\n            //Don't distribute if we don't have  sufficient profit\r\n            //A portion of the dividend is paid out according to the rate\r\n            share = swapBalance_.mul(payoutRate_).div(100).div(24 hours);\r\n            //divide the profit by seconds in the day\r\n            profit = share * now.safeSub(lastPayout);\r\n\r\n            //share times the amount of time elapsed\r\n            swapBalance_ = swapBalance_.safeSub(profit);\r\n\r\n            //Apply claimed token divs\r\n            rewardsProfitPerShare_ = SafeMath.add(rewardsProfitPerShare_, (profit * magnitude) / tokenSupply_);\r\n\r\n            lastPayout = now;\r\n\r\n\r\n            processBuyBacks();\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    function processBuyBacks() private {\r\n\r\n\r\n        if (swapCollector_ >= depotFlushSize) {\r\n\r\n            uint amount = swapCollector_;\r\n\r\n            //reset Collector\r\n            swapCollector_ = 0;\r\n\r\n            //VLT for ALL\r\n            uint _tokens = buyback(amount);\r\n\r\n            totalClaims += _tokens;\r\n\r\n            //Add to the pool\r\n            swapBalance_ += _tokens;\r\n\r\n        }\r\n    }\r\n\r\n    function buyback(uint amount) private returns (uint) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = swap.WETH();\r\n        path[1] = tokenAddress;\r\n\r\n\r\n        uint[] memory amounts = swap.swapExactETHForTokens.value(amount)(1,path, address(this), now + 24 hours);\r\n\r\n        //2nd index is token amount\r\n        emit onBuyBack(amount, amounts[1], now);\r\n\r\n        return amounts[1];\r\n\r\n    }\r\n\r\n\r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n\r\n    /// @dev Internal function to actually purchase the tokens.\r\n    function purchaseTokens(address _customerAddress, uint256 _incomingeth) internal returns (uint256) {\r\n\r\n        /* Members */\r\n        if (stats[_customerAddress].invested == 0 && stats[_customerAddress].receivedTokens == 0) {\r\n            players += 1;\r\n        }\r\n\r\n        totalTxs += 1;\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.mul(_incomingeth, entryFee_) / 100;\r\n        uint256 _amountOfTokens = SafeMath.sub(_incomingeth, _undividedDividends);\r\n\r\n        //drip and buybacks\r\n        allocateFees(_undividedDividends);\r\n\r\n        // fire event\r\n        emit onTokenPurchase(_customerAddress, _incomingeth, _amountOfTokens, now);\r\n\r\n        // yes we know that the safemath function automatically rules out the \"greater then\" equation.\r\n        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\r\n\r\n\r\n        // we can't give people infinite eth\r\n        if (tokenSupply_ > 0) {\r\n            // add tokens to the pool\r\n            tokenSupply_ += _amountOfTokens;\r\n\r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\r\n        // really i know you think you do but you don't\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_customerAddress] += _updatedPayouts;\r\n\r\n        _updatedPayouts = (int256) (rewardsProfitPerShare_ * _amountOfTokens);\r\n        stats[_customerAddress].tokenPayoutsTo += _updatedPayouts;\r\n\r\n\r\n        //Stats\r\n        stats[_customerAddress].invested += _incomingeth;\r\n        stats[_customerAddress].xInvested += 1;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /* @dev Subtracts two numbers, else returns zero */\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        if (b > a) {\r\n            return 0;\r\n        } else {\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"claimsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapCollector_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"statsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[16]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalClaims\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTxs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"buyFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myClaims\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateethReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapBalance_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dailyClaimEstimate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depotFlushSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendBalance_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donatePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dailyEstimate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_swapAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"invested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"soldTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onLeaderBoard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingeth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onBuyBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onDonation\",\"type\":\"event\"}]","ContractName":"BankrollNetworkLife","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b785a0322126826d8226d77e173d75dafb84d11000000000000000000000000f164fc0ec4e93095b804a4795bbe1e041497b92a","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://88a1045427ee5483c7f951240b656c38c776b1d200f388370d78719c0fb61205"}]}