{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\n/*\r\n  _______                   ____  _____  \r\n |__   __|                 |___ \\|  __ \\ \r\n    | | ___  __ _ _ __ ___   __) | |  | |\r\n    | |/ _ \\/ _` | '_ ` _ \\ |__ <| |  | |\r\n    | |  __/ (_| | | | | | |___) | |__| |\r\n    |_|\\___|\\__,_|_| |_| |_|____/|_____/ \r\n\r\n    https://team3d.io\r\n    https://discord.gg/team3d\r\n    \r\n    NFT Inventory contract\r\n\r\n*/\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ncontract IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\r\n    /**\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A contract implementing SupportsInterfaceWithLookup\r\n     * implement ERC165 itself\r\n     */\r\n    constructor () internal {\r\n        _registerInterface(_InterfaceId_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721Metadata {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721Enumerable {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n\r\n\r\ncontract ERC20Token {\r\n    function balanceOf(address owner) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\ncontract Inventory is ERC165, IERC721, IERC721Metadata, IERC721Enumerable, Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    \r\n    string private _name;\r\n    string private _symbol;\r\n    string private _pathStart;\r\n    string private _pathEnd;\r\n    bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n    bytes4 private constant _InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n    bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Treasure chest reward token (VIDYA)\r\n    ERC20Token public constant treasureChestRewardToken = ERC20Token(0x3D3D35bb9bEC23b06Ca00fe472b50E7A4c692C30);\r\n    \r\n    // Uniswap token \r\n    ERC20Token public constant UNI_ADDRESS = ERC20Token(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984);\r\n    \r\n    // Unicorn's Head\r\n    uint256 private constant UNICORN_TEMPLATE_ID = 11;\r\n\tuint256 public UNICORN_TOTAL_SUPPLY = 0;\r\n\tmapping (address => bool) public unicornClaimed;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned tokens\r\n    mapping (address => uint256) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n    \r\n    // Mapping of contract addresses that are allowed to edit item features \r\n    mapping (address => bool) private _approvedGameContract;\r\n\r\n    // Mapping from token ID to respective treasure chest rewards in VIDYA tokens\r\n    mapping (uint256 => uint256) public treasureChestRewards;\r\n\r\n    // Mapping to calculate how many treasure hunts an address has participated in\r\n    mapping (address => uint256) public treasureHuntPoints;\r\n    \r\n    // Mapping for the different equipment items of each address/character\r\n    // 0 - head, 1 - left hand, 2 - neck, 3 - right hand, 4 - chest, 5 - legs\r\n    mapping (address => uint256[6]) public characterEquipment;\r\n    \r\n    // To check if a template exists\r\n    mapping (uint256 => bool) _templateExists; \r\n\r\n    /* Item struct holds the templateId, a total of 4 additional features\r\n    and the burned status */\r\n    struct Item {\r\n        uint256 templateId; // id of Template in the itemTemplates array\r\n        uint8 feature1;\r\n        uint8 feature2;\r\n        uint8 feature3;\r\n        uint8 feature4;\r\n        uint8 equipmentPosition;\r\n        bool burned;\r\n    }\r\n    \r\n    /* Template struct holds the uri for each Item- \r\n    a reference to the json file which describes them */\r\n    struct Template {\r\n        string uri;\r\n    }\r\n    \r\n    // All items created, ever, both burned and not burned \r\n    Item[] public allItems;\r\n    \r\n    // Admin editable templates for each item \r\n    Template[] public itemTemplates;\r\n    \r\n    modifier onlyApprovedGame() {\r\n        require(_approvedGameContract[msg.sender], \"msg.sender is not an approved game contract\");\r\n        _;\r\n    }\r\n    \r\n    modifier tokenExists(uint256 _tokenId) {\r\n        require(_exists(_tokenId), \"Token does not exist\");\r\n        _;\r\n    }\r\n    \r\n    modifier isOwnedByOrigin(uint256 _tokenId) {\r\n        require(ownerOf(_tokenId) == tx.origin, \"tx.origin is not the token owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier isOwnerOrApprovedGame(uint256 _tokenId) {\r\n        require(ownerOf(_tokenId) == msg.sender || _approvedGameContract[msg.sender], \"Not owner or approved game\");\r\n        _;\r\n    }\r\n    \r\n    modifier templateExists(uint256 _templateId) {\r\n        require(_templateExists[_templateId], \"Template does not exist\");\r\n        _;\r\n    }\r\n\r\n    constructor() \r\n        public  \r\n    {\r\n        _name = \"Inventory\";\r\n        _symbol = \"ITEM\";\r\n        _pathStart = \"https://team3d.io/inventory/json/\";\r\n        _pathEnd = \".json\";\r\n        _registerInterface(InterfaceId_ERC721Metadata);\r\n        _registerInterface(_InterfaceId_ERC721Enumerable);\r\n        _registerInterface(_InterfaceId_ERC721);\r\n        \r\n        // Add the \"nothing\" item to msg.sender\r\n        // This is a dummy item so that valid items in allItems start with 1\r\n        addNewItem(0,0);\r\n    }\r\n    \r\n    // Get the Unicorn's head item\r\n    function mintUnicorn()\r\n        external\r\n    {\r\n        uint256 id;\r\n        \r\n        require(UNICORN_TOTAL_SUPPLY < 100, \"Unicorns are now extinct\");\r\n\t\trequire(!unicornClaimed[msg.sender], \"You have already claimed a unicorn\");\r\n        require(UNI_ADDRESS.balanceOf(msg.sender) >= 1000 * 10**18, \"Min balance 1000 UNI\");\r\n        require(_templateExists[UNICORN_TEMPLATE_ID], \"Unicorn template has not been added yet\");\r\n        checkAndTransferVIDYA(1000 * 10**18); // Unicorn's head costs 1000 VIDYA \r\n        \r\n        id = allItems.push(Item(UNICORN_TEMPLATE_ID,0,0,0,0,0,false)) -1;\r\n\t\t\r\n\t\tUNICORN_TOTAL_SUPPLY = UNICORN_TOTAL_SUPPLY.add(1);\r\n\t\tunicornClaimed[msg.sender] = true;\r\n        \r\n        // Materialize \r\n        _mint(msg.sender, id);\r\n    }\r\n    \r\n    function checkAndTransferVIDYA(uint256 _amount) private {\r\n        require(treasureChestRewardToken.transferFrom(msg.sender, address(this), _amount) == true, \"transfer must succeed\");\r\n    }\r\n    \r\n    function equip(\r\n        uint256 _tokenId, \r\n        uint8 _equipmentPosition\r\n    ) \r\n        external\r\n        tokenExists(_tokenId)\r\n    {\r\n        require(_equipmentPosition < 6);\r\n        require(allItems[_tokenId].equipmentPosition == _equipmentPosition, \r\n            \"Item cannot be equipped in this slot\");\r\n            \r\n        characterEquipment[msg.sender][_equipmentPosition] = _tokenId;\r\n    }\r\n\r\n    function unequip(\r\n        uint8 _equipmentPosition\r\n    ) \r\n        external\r\n    {\r\n        require(_equipmentPosition < 6);\r\n        characterEquipment[msg.sender][_equipmentPosition] = 0;\r\n    }\r\n\r\n    function getEquipment(\r\n        address player\r\n    ) \r\n        public \r\n        view \r\n        returns(uint256[6] memory)\r\n    {\r\n        return characterEquipment[player];\r\n    }\r\n\r\n    // The total supply of any one item\r\n    // Ask for example how many of \"Torch\" item exist\r\n    function getIndividualCount(\r\n        uint256 _templateId\r\n    ) \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        uint counter = 0;\r\n        \r\n        for (uint i = 0; i < allItems.length; i++) {\r\n            // If match found & is not burned \r\n            if (allItems[i].templateId == _templateId && !allItems[i].burned) {\r\n                counter++;\r\n            }\r\n        }\r\n        \r\n        // Total supply of item using the _templateId\r\n        return counter;\r\n    }\r\n    \r\n    // Total supply of any one item owned by _owner\r\n    // Ask for example how many of \"Torch\" item does the _owner have \r\n    function getIndividualOwnedCount(\r\n        uint256 _templateId,\r\n        address _owner\r\n    )\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        uint counter = 0;\r\n        uint[] memory ownedItems = getItemsByOwner(_owner);\r\n        \r\n        for(uint i = 0; i < ownedItems.length; i++) {\r\n            \r\n            /* If ownedItems[i]'s templateId matches the one in allItems[] */\r\n            if(allItems[ownedItems[i]].templateId == _templateId) {\r\n                counter++;\r\n            }\r\n        }\r\n        \r\n        // Total supply of _templateId that _owner owns \r\n        return counter;\r\n    }\r\n    \r\n    // Given a _tokenId returns how many other tokens exist with \r\n    // the same _templateId\r\n    function getIndividualCountByID(\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        view\r\n        tokenExists(_tokenId)\r\n        returns(uint256)\r\n    {\r\n        uint256 counter = 0;\r\n        uint256 templateId = allItems[_tokenId].templateId; // templateId we are looking for \r\n        \r\n        for(uint i = 0; i < allItems.length; i++) {\r\n            if(templateId == allItems[i].templateId && !allItems[i].burned) {\r\n                counter++;\r\n            }\r\n        }\r\n        \r\n        return counter;\r\n    }\r\n    \r\n    // Given a _tokenId returns how many other tokens the _owner has \r\n    // with the same _templateId\r\n    function getIndividualOwnedCountByID(\r\n        uint256 _tokenId,\r\n        address _owner \r\n    )\r\n        public\r\n        view\r\n        tokenExists(_tokenId)\r\n        returns(uint256)\r\n    {\r\n        uint256 counter = 0;\r\n        uint256 templateId = allItems[_tokenId].templateId; // templateId we are looking for \r\n        uint[] memory ownedItems = getItemsByOwner(_owner);\r\n        \r\n        for(uint i = 0; i < ownedItems.length; i++) {\r\n            // The item cannot be burned because of getItemsByOwner(_owner), no need to check \r\n            if(templateId == allItems[ownedItems[i]].templateId) {\r\n                counter++;\r\n            }\r\n        }\r\n        \r\n        return counter;\r\n    }\r\n    \r\n    /*  Given an array of _tokenIds return the corresponding _templateId count \r\n        for each of those _tokenIds */\r\n    function getTemplateCountsByTokenIDs(\r\n        uint[] memory _tokenIds\r\n    )\r\n        public\r\n        view\r\n        returns(uint[] memory)\r\n    {\r\n        uint[] memory counts = new uint[](_tokenIds.length);\r\n        \r\n        for(uint i = 0; i < _tokenIds.length; i++) {\r\n            counts[i] = getIndividualCountByID(_tokenIds[i]);\r\n        }\r\n        \r\n        return counts;\r\n    }\r\n    \r\n    /*  Given an array of _tokenIds return the corresponding _templateId count \r\n        for each of those _tokenIds that the _owner owns */\r\n    function getTemplateCountsByTokenIDsOfOwner(\r\n        uint[] memory _tokenIds,\r\n        address _owner \r\n    )\r\n        public\r\n        view\r\n        returns(uint[] memory)\r\n    {\r\n        uint[] memory counts = new uint[](_tokenIds.length);\r\n        \r\n        for(uint i = 0; i < _tokenIds.length; i++) {\r\n            counts[i] = getIndividualOwnedCountByID(_tokenIds[i], _owner);\r\n        }\r\n        \r\n        return counts;\r\n    }\r\n    \r\n    /*  Given an array of _tokenIds return the corresponding _templateIds \r\n        for each of those _tokenIds \r\n        \r\n        Useful for cross referencing / weeding out duplicates to populate the UI */\r\n    function getTemplateIDsByTokenIDs(\r\n        uint[] memory _tokenIds\r\n    )\r\n        public\r\n        view\r\n        returns(uint[] memory)\r\n    {\r\n        uint[] memory templateIds = new uint[](_tokenIds.length);\r\n        \r\n        for(uint i = 0; i < _tokenIds.length; i++) {\r\n            templateIds[i] = allItems[_tokenIds[i]].templateId;\r\n        }\r\n        \r\n        return templateIds;\r\n    }\r\n\r\n    // Get all the item id's by owner \r\n    function getItemsByOwner(\r\n        address _owner\r\n    ) \r\n        public \r\n        view \r\n        returns(uint[] memory) \r\n    {\r\n        uint[] memory result = new uint[](_ownedTokensCount[_owner]);\r\n        uint counter = 0;\r\n        \r\n        for (uint i = 0; i < allItems.length; i++) {\r\n            // If owner is _owner and token is not burned \r\n            if (_tokenOwner[i] == _owner && !allItems[i].burned) {\r\n                result[counter] = i;\r\n                counter++;\r\n            }\r\n        }\r\n        \r\n        // Array of ID's in allItems that _owner owns \r\n        return result;\r\n    }\r\n\r\n    // Function to withdraw any ERC20 tokens\r\n    function withdrawERC20Tokens(\r\n        address _tokenContract\r\n    ) \r\n        external \r\n        onlyOwner \r\n        returns(bool) \r\n    {\r\n        ERC20Token token = ERC20Token(_tokenContract);\r\n        uint256 amount = token.balanceOf(address(this));\r\n        return token.transfer(msg.sender, amount);\r\n    }\r\n    \r\n    // Admin can approve (or disapprove) game contracts \r\n    function approveGameContract(\r\n        address _game,\r\n        bool _status\r\n    )\r\n        external \r\n        onlyOwner\r\n    {\r\n        _approvedGameContract[_game] = _status;\r\n    }\r\n    \r\n    // Admin function to set _pathStart and _pathEnd\r\n    function setPaths(\r\n        string calldata newPathStart,\r\n        string calldata newPathEnd\r\n    )\r\n        external\r\n        onlyOwner\r\n        returns(bool)\r\n    {\r\n        bool success;\r\n        \r\n        if(keccak256(abi.encodePacked(_pathStart)) != keccak256(abi.encodePacked(newPathStart))) {\r\n            _pathStart = newPathStart;\r\n            success = true;\r\n        }\r\n        \r\n        if(keccak256(abi.encodePacked(_pathEnd)) != keccak256(abi.encodePacked(newPathEnd))) {\r\n            _pathEnd = newPathEnd;\r\n            success = true;\r\n        }\r\n        \r\n        return success;\r\n    }\r\n\r\n    /* Admin can add new item template\r\n    The _templateId is a reference to Template struct in itemTemplates[] */\r\n    function addNewItem(\r\n        uint256 _templateId,\r\n        uint8 _equipmentPosition\r\n    )\r\n        public \r\n        onlyOwner\r\n    {\r\n        uint256 id;\r\n        \r\n        // Does the _templateId exist or do we need to add it?\r\n        if(!_templateExists[_templateId]) {\r\n            // Add template id for this item as reference\r\n            itemTemplates.push(Template(uint2str(_templateId)));\r\n            _templateExists[_templateId] = true;\r\n        }\r\n        \r\n        id = allItems.push(Item(_templateId,0,0,0,0,_equipmentPosition,false)) -1;\r\n        \r\n        // Materialize \r\n        _mint(msg.sender, id);\r\n    }\r\n    \r\n    /* Admin can add new item template and send it to receiver in \r\n    one call */\r\n    function addNewItemAndTransfer(\r\n        uint256 _templateId,\r\n        uint8 _equipmentPosition,\r\n        address receiver \r\n    )\r\n        public \r\n        onlyOwner\r\n    {\r\n        uint256 id;\r\n        \r\n        // Does the _templateId exist or do we need to add it?\r\n        if(!_templateExists[_templateId]) {\r\n            // Add template id for this item as reference \r\n            itemTemplates.push(Template(uint2str(_templateId)));\r\n            _templateExists[_templateId] = true;\r\n        }\r\n        \r\n        id = allItems.push(Item(_templateId,0,0,0,0,_equipmentPosition,false)) -1;\r\n        \r\n        // Materialize \r\n        _mint(receiver, id);\r\n    }\r\n    \r\n    /*  Allows approved game contracts to create new items from \r\n        already existing templates (added by admin)\r\n        \r\n        In other words this function allows a game to spawn more \r\n        of ie. \"Torch\" and set its default features etc */\r\n    function createFromTemplate(\r\n        uint256 _templateId,\r\n        uint8 _feature1,\r\n        uint8 _feature2,\r\n        uint8 _feature3,\r\n        uint8 _feature4,\r\n        uint8 _equipmentPosition\r\n    )\r\n        public\r\n        templateExists(_templateId)\r\n        onlyApprovedGame\r\n        returns(uint256)\r\n    {\r\n        uint256 id; \r\n        address player = tx.origin;\r\n        \r\n        id = allItems.push(\r\n            Item(\r\n                _templateId,\r\n                _feature1,\r\n                _feature2,\r\n                _feature3,\r\n                _feature4,\r\n                _equipmentPosition,\r\n                false\r\n            )\r\n        ) -1;\r\n        \r\n        // Materialize to tx.origin (and not msg.sender aka. the game contract)\r\n        _mint(player, id);\r\n        \r\n        // id of the new item \r\n        return id;\r\n    }\r\n\r\n    /*\r\n    Change feature values of _tokenId\r\n    \r\n    Only succeeds when:\r\n        the tx.origin (a player) owns the item \r\n        the msg.sender (game contract) is a manually approved game address \r\n    */\r\n    function changeFeaturesForItem(\r\n        uint256 _tokenId,\r\n        uint8 _feature1,\r\n        uint8 _feature2,\r\n        uint8 _feature3,\r\n        uint8 _feature4,\r\n        uint8 _equipmentPosition\r\n    )\r\n        public \r\n        onlyApprovedGame // msg.sender has to be a manually approved game address \r\n        tokenExists(_tokenId) // check if _tokenId exists in the first place \r\n        isOwnedByOrigin(_tokenId) // does the tx.origin (player in a game) own the token?\r\n        returns(bool)\r\n    {\r\n        return (\r\n            _changeFeaturesForItem(\r\n                _tokenId,\r\n                _feature1,\r\n                _feature2,\r\n                _feature3,\r\n                _feature4,\r\n                _equipmentPosition\r\n            )\r\n        );\r\n    }\r\n\r\n    function _changeFeaturesForItem(\r\n        uint256 _tokenId,\r\n        uint8 _feature1,\r\n        uint8 _feature2,\r\n        uint8 _feature3,\r\n        uint8 _feature4,\r\n        uint8 _equipmentPosition\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        Item storage item = allItems[_tokenId];\r\n\r\n        if(item.feature1 != _feature1) {\r\n            item.feature1 = _feature1;\r\n        }\r\n        \r\n        if(item.feature2 != _feature2) {\r\n            item.feature2 = _feature2;\r\n        }\r\n        \r\n        if(item.feature3 != _feature3) {\r\n            item.feature3 = _feature3;\r\n        }\r\n        \r\n        if(item.feature4 != _feature4) {\r\n            item.feature4 = _feature4;\r\n        }\r\n        \r\n        if(item.equipmentPosition != _equipmentPosition) {\r\n            item.equipmentPosition = _equipmentPosition;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /*\r\n    Features of _tokenId \r\n    Useful in various games where the _tokenId should \r\n    have traits etc.\r\n    \r\n    Example: a \"Torch\" could start with 255 and degrade \r\n    during gameplay over time \r\n    \r\n    Note: maximum value for uint8 type is 255 \r\n    */\r\n    function getFeaturesOfItem(\r\n        uint256 _tokenId \r\n    )\r\n        public \r\n        view \r\n        returns(uint8[] memory)\r\n    {\r\n        Item storage item = allItems[_tokenId];\r\n        uint8[] memory features = new uint8[](4);\r\n        \r\n        features[0] = item.feature1;\r\n        features[1] = item.feature2;\r\n        features[2] = item.feature3;\r\n        features[3] = item.feature4;\r\n        \r\n        return features;\r\n    }\r\n\r\n    /*\r\n    Turn uint256 into a string\r\n    \r\n    Reason: ERC721 standard needs token uri to return as string,\r\n    but we don't want to store long urls to the json files on-chain.\r\n    Instead we use this returned string (which is actually just an ID)\r\n    and say to front ends that the token uri can be found at \r\n    somethingsomething.io/tokens/<id>.json \r\n    */\r\n    function uint2str(\r\n        uint256 i\r\n    ) \r\n        internal \r\n        pure \r\n        returns(string memory) \r\n    {\r\n        if (i == 0) return \"0\";\r\n        \r\n        uint256 j = i;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint256 k = length - 1;\r\n        while (i != 0) {\r\n            bstr[k--] = byte(uint8(48 + i % 10)); \r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    function append(\r\n        string memory a, \r\n        string memory b, \r\n        string memory c\r\n    ) \r\n        internal \r\n        pure \r\n        returns(string memory) \r\n    {\r\n        return string(\r\n            abi.encodePacked(a, b, c)\r\n        );\r\n    }\r\n    \r\n    /*\r\n     * Adds an NFT and the corresponding reward for whoever finds it and burns it.\r\n     */\r\n    function addTreasureChest(uint256 _tokenId, uint256 _rewardsAmount) \r\n    external\r\n    tokenExists(_tokenId)\r\n    onlyApprovedGame \r\n    {\r\n        treasureChestRewards[_tokenId] = _rewardsAmount;\r\n    }\r\n\r\n    /*  Burn the _tokenId\r\n        Succeeds when:\r\n            token exists \r\n            msg.sender is either direct owner of the token OR \r\n            msg.sender is a manually approved game contract \r\n        \r\n        If tx.origin and msg.sender are different, burn the \r\n        _tokenId of the tx.origin (the player, not the game contract)\r\n    */\r\n    function burn(\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        tokenExists(_tokenId)\r\n        isOwnerOrApprovedGame(_tokenId)\r\n        returns(bool)\r\n    {\r\n        if (tx.origin == msg.sender) {\r\n            return _burn(_tokenId, msg.sender);\r\n        } else {\r\n            return _burn(_tokenId, tx.origin);\r\n        }\r\n    }\r\n    \r\n    // Burn owner's tokenId \r\n    function _burn(\r\n        uint256 _tokenId,\r\n        address owner\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        // Set burned status on token\r\n        allItems[_tokenId].burned = true;\r\n        \r\n        // Set new owner to 0x0 \r\n        _tokenOwner[_tokenId] = address(0);\r\n        \r\n        // Remove from old owner \r\n        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\r\n\r\n        // Check if it's a treasure hunt token\r\n        uint256 treasureChestRewardsForToken = treasureChestRewards[_tokenId];\r\n        if (treasureChestRewardsForToken > 0) {\r\n            treasureChestRewardToken.transfer(msg.sender, treasureChestRewardsForToken);\r\n            treasureHuntPoints[owner]++;\r\n        }\r\n\r\n        // Fire event \r\n        emit Transfer(owner, address(0), _tokenId);\r\n        \r\n        return true;\r\n    }\r\n\r\n    function getLevel(address player) public view returns(uint256) {\r\n        return treasureHuntPoints[player];\r\n    }\r\n\r\n    // Return the total supply\r\n    function totalSupply() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        uint256 counter;\r\n        for(uint i = 0; i < allItems.length; i++) {\r\n            if(!allItems[i].burned) {\r\n                counter++;\r\n            }\r\n        }\r\n        \r\n        // All tokens which are not burned \r\n        return counter;\r\n    }\r\n    \r\n    // Return the templateId of _index token\r\n    function tokenByIndex(\r\n        uint256 _index\r\n    ) \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        require(_index < totalSupply());\r\n        return allItems[_index].templateId;\r\n    }\r\n    \r\n    // Return The token templateId for the index'th token assigned to owner\r\n    function tokenOfOwnerByIndex(\r\n        address owner,\r\n        uint256 index\r\n    ) \r\n        public \r\n        view \r\n        returns \r\n        (uint256 tokenId) \r\n    {\r\n        require(index < balanceOf(owner));\r\n        return getItemsByOwner(owner)[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name\r\n     * @return string representing the token name\r\n     */\r\n    function name() \r\n        external \r\n        view \r\n        returns(string memory) \r\n    {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() \r\n        external \r\n        view \r\n        returns(string memory) \r\n    {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given token ID\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) \r\n        external \r\n        view \r\n        returns(string memory) \r\n    {\r\n        require(_exists(tokenId));\r\n        uint256 tokenTemplateId = allItems[tokenId].templateId;\r\n        \r\n        string memory id = uint2str(tokenTemplateId);\r\n        return append(_pathStart, id, _pathEnd);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(\r\n        address owner\r\n    ) \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        require(owner != address(0));\r\n        return _ownedTokensCount[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return owner address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(\r\n        uint256 tokenId\r\n    ) \r\n        public \r\n        view \r\n        returns(address) \r\n    {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0));\r\n        require(!allItems[tokenId].burned, \"This token is burned\"); // Probably useless require at this point \r\n        \r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(\r\n        address to, \r\n        uint256 tokenId\r\n    ) \r\n        public \r\n    {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(\r\n        uint256 tokenId\r\n    ) \r\n        public \r\n        view \r\n        returns(address)\r\n    {\r\n        require(_exists(tokenId));\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(\r\n        address to, \r\n        bool approved\r\n    ) \r\n        public \r\n    {\r\n        require(to != msg.sender);\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        \r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(\r\n        address owner, \r\n        address operator\r\n    ) \r\n        public \r\n        view \r\n        returns(bool) \r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(\r\n        address from, \r\n        address to, \r\n        uint256 tokenId\r\n    ) \r\n        public \r\n    {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     *\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(\r\n        address from, \r\n        address to, \r\n        uint256 tokenId\r\n    )\r\n        public \r\n    {\r\n        // solium-disable-next-line arg-overflow\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(\r\n        address from, \r\n        address to, \r\n        uint256 tokenId, \r\n        bytes memory _data\r\n    ) \r\n        public \r\n    {\r\n        transferFrom(from, to, tokenId);\r\n        // solium-disable-next-line arg-overflow\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return whether the token exists\r\n     */\r\n    function _exists(\r\n        uint256 tokenId\r\n    ) \r\n        internal \r\n        view \r\n        returns(bool) \r\n    {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     *    is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(\r\n        address spender, \r\n        uint256 tokenId\r\n    ) \r\n        internal \r\n        view \r\n        returns(bool) \r\n    {\r\n        address owner = ownerOf(tokenId);\r\n        // Disable solium check because of\r\n        // https://github.com/duaraghav8/Solium/issues/175\r\n        // solium-disable-next-line operator-whitespace\r\n        return (\r\n            spender == owner || \r\n            getApproved(tokenId) == spender || \r\n            isApprovedForAll(owner, spender)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(\r\n        address to, \r\n        uint256 tokenId\r\n    ) internal {\r\n        require(to != address(0));\r\n        require(!_exists(tokenId));\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function _transferFrom(\r\n        address from, \r\n        address to, \r\n        uint256 tokenId\r\n    ) \r\n        internal \r\n    {\r\n        require(ownerOf(tokenId) == from);\r\n        require(to != address(0));\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\r\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from, \r\n        address to, \r\n        uint256 tokenId, \r\n        bytes memory _data\r\n    ) \r\n        internal \r\n        returns(bool) \r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(\r\n            msg.sender, \r\n            from, \r\n            tokenId, \r\n            _data\r\n        );\r\n        \r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(\r\n        uint256 tokenId\r\n    ) \r\n        private \r\n    {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNICORN_TOTAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNI_ADDRESS\",\"outputs\":[{\"internalType\":\"contract ERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_templateId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_equipmentPosition\",\"type\":\"uint8\"}],\"name\":\"addNewItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_templateId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_equipmentPosition\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"addNewItemAndTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsAmount\",\"type\":\"uint256\"}],\"name\":\"addTreasureChest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allItems\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"templateId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"feature1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"feature2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"feature3\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"feature4\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"equipmentPosition\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_game\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"approveGameContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_feature1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_feature2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_feature3\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_feature4\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_equipmentPosition\",\"type\":\"uint8\"}],\"name\":\"changeFeaturesForItem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"characterEquipment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_templateId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_feature1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_feature2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_feature3\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_feature4\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_equipmentPosition\",\"type\":\"uint8\"}],\"name\":\"createFromTemplate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_equipmentPosition\",\"type\":\"uint8\"}],\"name\":\"equip\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getEquipment\",\"outputs\":[{\"internalType\":\"uint256[6]\",\"name\":\"\",\"type\":\"uint256[6]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getFeaturesOfItem\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_templateId\",\"type\":\"uint256\"}],\"name\":\"getIndividualCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getIndividualCountByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_templateId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getIndividualOwnedCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getIndividualOwnedCountByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getItemsByOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getTemplateCountsByTokenIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTemplateCountsByTokenIDsOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getTemplateIDsByTokenIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemTemplates\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintUnicorn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"newPathStart\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newPathEnd\",\"type\":\"string\"}],\"name\":\"setPaths\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasureChestRewardToken\",\"outputs\":[{\"internalType\":\"contract ERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"treasureChestRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"treasureHuntPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_equipmentPosition\",\"type\":\"uint8\"}],\"name\":\"unequip\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"unicornClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawERC20Tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Inventory","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3d6f0cf075dd3e4b74e4524d3514f301990ef7f34c54193bd247324d93b04317"}]}