{"status":"1","message":"OK","result":[{"SourceCode":"{\"contract.sol\":{\"content\":\"pragma solidity 0.5.14;\\nimport \\\"./DappToken.sol\\\";\\ncontract XProtocal {\\n    using SafeMath for uint256;\\n    struct UserStruct {\\n        uint id;\\n        uint orignalRefID;\\n        uint referrerID;\\n        uint currentLevel;\\n        uint totalEarningEth;\\n        address[] referral;\\n    }\\n    struct LevelStruct {\\n        uint ethValue;\\n        uint tokenValue;\\n        uint tokenOrignalValue;\\n    }\\n    address public ownerAddress;\\n    uint public adminFee = 15 ether;\\n    uint public currentId = 0;\\n    uint referrer1Limit = 2;\\n    bool public lockStatus;\\n    bytes32 private secretPhase;\\n    XProtocalToken Token;\\n    mapping (uint =\\u003e LevelStruct) public LEVEL_PRICE;\\n    mapping (address =\\u003e UserStruct) public users;\\n    mapping (uint =\\u003e address) public userList;\\n    mapping (address =\\u003e mapping (uint =\\u003e uint)) public EarnedEth;\\n    mapping (address =\\u003e uint) public loopCheck;\\n    mapping (address =\\u003e uint) public createdDate;\\n    event regLevelEvent(address indexed UserAddress, uint indexed UserId, uint Time);\\n    event buyLevelEvent(address indexed UserAddress, uint Levelno, uint Time);\\n    event getMoneyForLevelEvent(address indexed UserAddress, uint UserId, address indexed ReferrerAddress, uint ReferrerId, uint Levelno, uint orignalRefID, uint Time);\\n    event lostMoneyForLevelEvent(address indexed UserAddress, uint UserId, address indexed ReferrerAddress, uint ReferrerId, uint Levelno, uint LevelPrice, uint Time);    \\n    constructor(XProtocalToken _tokkenAddress, bytes32 _secretPhase) public {\\n        ownerAddress = msg.sender;\\n        secretPhase = _secretPhase;\\n        Token = _tokkenAddress;\\n        LEVEL_PRICE[1] = LevelStruct({\\n            ethValue: 0.1 ether,\\n            tokenOrignalValue: 2,\\n            tokenValue: 10\\n        });\\n        LEVEL_PRICE[2] = LevelStruct({\\n            ethValue: 0.15 ether,\\n            tokenOrignalValue: 3,\\n            tokenValue: 15\\n        });\\n        LEVEL_PRICE[3] = LevelStruct({\\n            ethValue: 0.5 ether,\\n            tokenOrignalValue: 10,\\n            tokenValue: 50\\n        });\\n        LEVEL_PRICE[4] = LevelStruct({\\n            ethValue: 3 ether,\\n            tokenOrignalValue: 120,\\n            tokenValue: 600\\n        });\\n        LEVEL_PRICE[5] = LevelStruct({\\n            ethValue: 5 ether,\\n            tokenOrignalValue: 200,\\n            tokenValue: 1000\\n        });\\n        LEVEL_PRICE[6] = LevelStruct({\\n            ethValue: 10 ether,\\n            tokenOrignalValue: 400,\\n            tokenValue: 2000\\n        });\\n        LEVEL_PRICE[7] = LevelStruct({\\n            ethValue: 22 ether,\\n            tokenOrignalValue: 1320,\\n            tokenValue: 6600\\n        });\\n        LEVEL_PRICE[8] = LevelStruct({\\n            ethValue: 28 ether,\\n            tokenOrignalValue: 1680,\\n            tokenValue: 8400\\n        });\\n        LEVEL_PRICE[9] = LevelStruct({\\n            ethValue: 36 ether,\\n            tokenOrignalValue: 2160,\\n            tokenValue: 10800\\n        });\\n        UserStruct memory userStruct;\\n        currentId = currentId.add(1);\\n        userStruct = UserStruct({\\n            id: currentId,\\n            orignalRefID: 1,\\n            referrerID: 0,\\n            currentLevel:1,\\n            totalEarningEth:0,\\n            referral: new address[](0)\\n        });\\n        users[ownerAddress] = userStruct;\\n        userList[currentId] = ownerAddress;\\n        users[ownerAddress].currentLevel = 9;\\n    } \\n    modifier onlyOwner() {\\n        require(msg.sender == ownerAddress, \\\"Only owner\\\");\\n        _;\\n    }\\n    function regUser(uint _referrerID, uint _orignalRef) external payable {\\n        require(lockStatus == false, \\\"Contract Locked\\\");\\n        require(users[msg.sender].id == 0, \\\"User exist\\\");\\n        require(_referrerID \\u003c= currentId, \\\"Incorrect parentID Id\\\");\\n        require(_orignalRef \\u003c= currentId, \\\"Incorrect referrer Id\\\");\\n        require(msg.value == LEVEL_PRICE[1].ethValue, \\\"Incorrect Value\\\");\\n        require(users[userList[_referrerID]].referral.length  \\u003c referrer1Limit, \\\"User already have 2 childs\\\");\\n        UserStruct memory userStruct;\\n        currentId = currentId.add(1);\\n        userStruct = UserStruct({\\n            id: currentId,\\n            referrerID: _referrerID,\\n            currentLevel: 1,\\n            orignalRefID: _orignalRef,\\n            totalEarningEth:0,\\n            referral: new address[](0)\\n        });\\n        users[msg.sender] = userStruct;\\n        userList[currentId] = msg.sender;\\n        users[userList[_referrerID]].referral.push(msg.sender);\\n        loopCheck[msg.sender] = 0;\\n        createdDate[msg.sender] = now;\\n        loopCheck[msg.sender] = 0;\\n        payForLevel(true, 1, msg.sender, ((LEVEL_PRICE[1].ethValue.mul(adminFee)).div(10**20)));\\n        emit regLevelEvent(msg.sender, currentId, now);\\n        Token.mint(msg.sender, LEVEL_PRICE[1].tokenValue, secretPhase);\\n        Token.mint(userList[_orignalRef], LEVEL_PRICE[1].tokenOrignalValue, secretPhase);\\n    }\\n    function buyLevel(uint256 _level) external payable {\\n        require(lockStatus == false, \\\"Contract Locked\\\");\\n        require(users[msg.sender].id != 0, \\\"User not exist\\\"); \\n        require(_level \\u003e 0 \\u0026\\u0026 _level \\u003c= 9, \\\"Incorrect level\\\");\\n        require(msg.value == LEVEL_PRICE[_level].ethValue, \\\"Incorrect Value\\\");\\n        if (_level == 1) {\\n            users[msg.sender].currentLevel = 1;\\n        } else {\\n            if(users[msg.sender].currentLevel + 1 != _level) {\\n                require(users[msg.sender].currentLevel + 1 == _level, \\\"Buy the previous level\\\");\\n            }\\n            users[msg.sender].currentLevel = _level;\\n        }\\n        loopCheck[msg.sender] = 0;\\n        payForLevel(true, _level, msg.sender, ((LEVEL_PRICE[_level].ethValue.mul(adminFee)).div(10**20)));\\n        emit buyLevelEvent(msg.sender, _level, now);\\n        Token.mint(msg.sender, LEVEL_PRICE[_level].tokenValue, secretPhase);\\n        Token.mint(userList[users[msg.sender].orignalRefID], LEVEL_PRICE[_level].tokenOrignalValue, secretPhase);\\n    }\\n    function payForLevel(bool _isNew, uint _level, address _userAddress, uint _adminPrice) internal {\\n            address referer;\\n            if(_isNew) {\\n                if (_level == 1 || _level == 4 || _level == 7) {\\n                    referer = userList[users[_userAddress].referrerID];\\n                } else if (_level == 2 || _level == 5 || _level == 8) {\\n                    referer = userList[users[_userAddress].referrerID];\\n                    referer = userList[users[referer].referrerID];\\n                } else if (_level == 3 || _level == 6 || _level == 9) {\\n                    referer = userList[users[_userAddress].referrerID];\\n                    referer = userList[users[referer].referrerID];\\n                    referer = userList[users[referer].referrerID];\\n                }\\n            } else {\\n                referer = userList[users[_userAddress].referrerID];\\n            }\\n            if (loopCheck[msg.sender] \\u003e= 9) {\\n                referer = userList[1];\\n            }\\n            if (users[referer].currentLevel \\u003e= _level) {\\n                require((address(uint160(referer)).send(LEVEL_PRICE[_level].ethValue.sub(_adminPrice))) \\u0026\\u0026 \\n                    (address(uint160(ownerAddress)).send(_adminPrice)));\\n                users[referer].totalEarningEth = users[referer].totalEarningEth.add(LEVEL_PRICE[_level].ethValue);\\n                EarnedEth[referer][_level] = EarnedEth[referer][_level].add(LEVEL_PRICE[_level].ethValue);\\n                emit getMoneyForLevelEvent(msg.sender, users[msg.sender].id, referer, users[referer].id, _level, users[msg.sender].orignalRefID, now);\\n        } else {\\n            if (loopCheck[msg.sender] \\u003c 9) {\\n                loopCheck[msg.sender] = loopCheck[msg.sender].add(1);\\n                emit lostMoneyForLevelEvent(msg.sender, users[msg.sender].id, referer, users[referer].id, _level, LEVEL_PRICE[_level].ethValue ,now);\\n                payForLevel(false, _level, referer, _adminPrice);\\n            }\\n        }\\n    }\\n    function viewUserReferral(address _userAddress) external view returns (address[] memory) {\\n        return users[_userAddress].referral;\\n    }\\n    function contractLock(bool _lockStatus) public onlyOwner returns (bool) {\\n        lockStatus = _lockStatus;\\n        return true;\\n    }\\n    function updateFeePercentage(uint256 _adminFee) public onlyOwner returns (bool) {\\n        adminFee = _adminFee.mul(10**18);\\n        return true;  \\n    }\\n    function failSafe(address payable _toUser, uint _amount) public onlyOwner returns (bool) {\\n        require(_toUser != address(0), \\\"Invalid Address\\\");\\n        require(address(this).balance \\u003e= _amount, \\\"Insufficient balance\\\");\\n        (_toUser).transfer(_amount);\\n        return true;\\n    }\\n    function () external payable {\\n        revert(\\\"Invalid Transaction\\\");\\n    }\\n}\"},\"DappToken.sol\":{\"content\":\"pragma solidity ^0.5.14;\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n        return c;\\n    }\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        return c;\\n    }\\n}\\ncontract ERC20 {\\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\\n    function approve(address spender, uint256 value) public returns (bool);\\n    function transfer(address to, uint256 value) public returns(bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\ncontract XProtocalToken is ERC20 {\\n    using SafeMath for uint256;\\n    string  public constant name = \\\"X Protocal\\\";\\n    string  public constant symbol = \\\"XPT\\\";\\n    uint256 public totalSupply;\\n    address public owner;\\n    address private contractAddress;\\n    bytes32 private secretPhase;\\n    bool public isEnabled = false;\\n    uint public sellEndTime = now + 426 days;\\n    mapping(address =\\u003e uint256) public balanceOf;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n    mapping (address =\\u003e bool) public frozenAccount;\\n    event FrozenFunds(address target, bool frozen);\\n    constructor (bytes32 _secretPhase) public {\\n        owner = msg.sender;\\n        secretPhase = _secretPhase;\\n    }\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        _;\\n    }\\n    modifier onlyContract() {\\n        require(msg.sender == contractAddress, \\\"Only contract\\\");\\n        _;\\n    }\\n    function transfer(address _to, uint256 _value) public returns (bool success) {\\n        require(balanceOf[msg.sender] \\u003e= _value, \\\"not enough balance\\\");\\n        require (isEnabled, \\\"cannot send token at this point\\\");                   // Check if sender is frozen\\n        require(!frozenAccount[_to]); \\n        balanceOf[msg.sender] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n    function mint(address _to, uint256 _value, bytes32 _secretPhase) public onlyContract returns (bool success) {\\n        require(secretPhase == _secretPhase, \\\"sorry wrong secrat\\\");\\n        if (sellEndTime \\u003c= now) {\\n            return false;\\n        }\\n        totalSupply += _value;\\n        balanceOf[_to] += _value;\\n        return true;\\n    }\\n    function setContractAddress(address _contractAddress) public onlyOwner {\\n        contractAddress = _contractAddress;\\n    }\\n    function approve(address _spender, uint256 _value) public returns (bool success) {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\n        require(_value \\u003c= balanceOf[_from], \\\"from error\\\");\\n        require(_value \\u003c= allowance[_from][msg.sender], \\\"allowance\\\");\\n        require (isEnabled, \\\"cannot send token at this point\\\");\\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\\n        require(!frozenAccount[_to]); \\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        allowance[_from][msg.sender] -= _value;\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n    function changeowner(address _newOwner) public onlyOwner returns(bool) {\\n        require(_newOwner != address(0), \\\"Invalid Address\\\");\\n        owner = _newOwner;\\n        return true;\\n    }\\n    function setTokenStatus() onlyOwner public {\\n        require(!isEnabled, \\\"can not unlock\\\");\\n        isEnabled = true;\\n        if(isEnabled) {\\n            balanceOf[owner] += (totalSupply.mul(20)).div(100);\\n            totalSupply += (totalSupply.mul(20)).div(100);   \\n        }\\n    }\\n    function freezeAccount(address target, bool freeze) onlyOwner public {\\n        frozenAccount[target] = freeze;\\n        emit FrozenFunds(target, freeze);\\n    }\\n    function () external payable {\\n        revert();\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract XProtocalToken\",\"name\":\"_tokkenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_secretPhase\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"UserAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Levelno\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Time\",\"type\":\"uint256\"}],\"name\":\"buyLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"UserAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"UserId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ReferrerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ReferrerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Levelno\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orignalRefID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Time\",\"type\":\"uint256\"}],\"name\":\"getMoneyForLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"UserAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"UserId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ReferrerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ReferrerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Levelno\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LevelPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Time\",\"type\":\"uint256\"}],\"name\":\"lostMoneyForLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"UserAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"UserId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Time\",\"type\":\"uint256\"}],\"name\":\"regLevelEvent\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"EarnedEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEVEL_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOrignalValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lockStatus\",\"type\":\"bool\"}],\"name\":\"contractLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"createdDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_toUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"failSafe\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"loopCheck\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_orignalRef\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_adminFee\",\"type\":\"uint256\"}],\"name\":\"updateFeePercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orignalRefID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarningEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"XProtocal","CompilerVersion":"v0.5.14+commit.01f1aaa4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000aa2c561bd89eef997053e616be2dda4cf3c0e06f7465737400000000000007465737400000000007465737400000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://eac3e018b5b9481d877da24684b662ac6134cc5eb9f344a4d6f302b485c10cdc"}]}