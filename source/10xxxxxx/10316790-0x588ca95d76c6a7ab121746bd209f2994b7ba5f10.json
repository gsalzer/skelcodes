{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Crypto stamp 2 On-Chain Shop\r\n * Ability to purchase pseudo-random digital-physical collectible postage stamps\r\n * and to redeem Crypto stamp 2 pre-sale vouchers in a similar manner\r\n *\r\n * Developed by Capacity Blockchain Solutions GmbH <capacity.at>\r\n * for Ã–sterreichische Post AG <post.at>\r\n */\r\n\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transfered from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n      * - `from`, `to` cannot be zero.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/ENSReverseRegistrarI.sol\r\n\r\n/*\r\n * Interfaces for ENS Reverse Registrar\r\n * See https://github.com/ensdomains/ens/blob/master/contracts/ReverseRegistrar.sol for full impl\r\n * Also see https://github.com/wealdtech/wealdtech-solidity/blob/master/contracts/ens/ENSReverseRegister.sol\r\n *\r\n * Use this as follows (registryAddress is the address of the ENS registry to use):\r\n * -----\r\n * // This hex value is caclulated by namehash('addr.reverse')\r\n * bytes32 public constant ENS_ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n * function registerReverseENS(address registryAddress, string memory calldata) external {\r\n *     require(registryAddress != address(0), \"need a valid registry\");\r\n *     address reverseRegistrarAddress = ENSRegistryOwnerI(registryAddress).owner(ENS_ADDR_REVERSE_NODE)\r\n *     require(reverseRegistrarAddress != address(0), \"need a valid reverse registrar\");\r\n *     ENSReverseRegistrarI(reverseRegistrarAddress).setName(name);\r\n * }\r\n * -----\r\n * or\r\n * -----\r\n * function registerReverseENS(address reverseRegistrarAddress, string memory calldata) external {\r\n *    require(reverseRegistrarAddress != address(0), \"need a valid reverse registrar\");\r\n *     ENSReverseRegistrarI(reverseRegistrarAddress).setName(name);\r\n * }\r\n * -----\r\n * ENS deployments can be found at https://docs.ens.domains/ens-deployments\r\n * E.g. Etherscan can be used to look up that owner on those contracts.\r\n * namehash.hash(\"addr.reverse\") == \"0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2\"\r\n * Ropsten: ens.owner(namehash.hash(\"addr.reverse\")) == \"0x6F628b68b30Dc3c17f345c9dbBb1E483c2b7aE5c\"\r\n * Mainnet: ens.owner(namehash.hash(\"addr.reverse\")) == \"0x084b1c3C81545d370f3634392De611CaaBFf8148\"\r\n */\r\npragma solidity ^0.6.0;\r\n\r\ninterface ENSRegistryOwnerI {\r\n    function owner(bytes32 node) external view returns (address);\r\n}\r\n\r\ninterface ENSReverseRegistrarI {\r\n    function setName(string calldata name) external returns (bytes32 node);\r\n}\r\n\r\n// File: contracts/OracleRequest.sol\r\n\r\n/*\r\nInterface for requests to the rate oracle (for EUR/ETH)\r\nCopy this to projects that need to access the oracle.\r\nSee rate-oracle project for implementation.\r\n*/\r\npragma solidity ^0.6.0;\r\n\r\n\r\nabstract contract OracleRequest {\r\n\r\n    uint256 public EUR_WEI; //number of wei per EUR\r\n\r\n    uint256 public lastUpdate; //timestamp of when the last update occurred\r\n\r\n    function ETH_EUR() public view virtual returns (uint256); //number of EUR per ETH (rounded down!)\r\n\r\n    function ETH_EURCENT() public view virtual returns (uint256); //number of EUR cent per ETH (rounded down!)\r\n\r\n}\r\n\r\n// File: contracts/CS2PropertiesI.sol\r\n\r\n/*\r\nInterface for CS2 properties.\r\n*/\r\npragma solidity ^0.6.0;\r\n\r\ninterface CS2PropertiesI {\r\n\r\n    enum AssetType {\r\n        Honeybadger,\r\n        Llama,\r\n        Panda,\r\n        Doge\r\n    }\r\n\r\n    enum Colors {\r\n        Black,\r\n        Green,\r\n        Blue,\r\n        Yellow,\r\n        Red\r\n    }\r\n\r\n    function getType(uint256 tokenId) external view returns (AssetType);\r\n    function getColor(uint256 tokenId) external view returns (Colors);\r\n\r\n}\r\n\r\n// File: contracts/OZ_ERC1155/IERC1155.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n    @title ERC-1155 Multi Token Standard basic interface\r\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\r\n */\r\nabstract contract IERC1155 is IERC165 {\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256);\r\n\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids) public view virtual returns (uint256[] memory);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external virtual;\r\n\r\n    function isApprovedForAll(address account, address operator) external view virtual returns (bool);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external virtual;\r\n\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata values, bytes calldata data) external virtual;\r\n}\r\n\r\n// File: contracts/CS2PresaleRedeemI.sol\r\n\r\n/*\r\nInterface for CS2 on-chain presale for usage with redeemer (OCS) contract.\r\n*/\r\npragma solidity ^0.6.0;\r\n\r\n\r\nabstract contract CS2PresaleRedeemI is IERC1155 {\r\n    enum AssetType {\r\n        Honeybadger,\r\n        Llama,\r\n        Panda,\r\n        Doge\r\n    }\r\n\r\n    // Redeem assets of a multiple types/animals at once.\r\n    // This burns them in this contract, but should be called by a contract that assigns/creates the final assets in turn.\r\n    function redeemBatch(address owner, AssetType[] calldata _type, uint256[] calldata _count) external virtual;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/ERC721ExistsI.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev ERC721 compliant contract with an exists() function.\r\n */\r\nabstract contract ERC721ExistsI is IERC721 {\r\n\r\n    // Returns whether the specified token exists\r\n    function exists(uint256 tokenId) public view virtual returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/CS2OCSBaseI.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @dev ERC721 compliant contract with an exists() function.\r\n */\r\nabstract contract CS2OCSBaseI is ERC721ExistsI, IERC721Enumerable {\r\n\r\n    // Issue a crypto stamp with a merkle proof.\r\n    function createWithProof(bytes32 tokenData, bytes32[] memory merkleProof) public virtual returns (uint256);\r\n\r\n}\r\n\r\n// File: contracts/CS2OnChainShop.sol\r\n\r\n/*\r\nImplements an on-chain shop for Crypto stamp Edition 2\r\n*/\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CS2OnChainShop {\r\n    using SafeMath for uint256;\r\n\r\n    CS2OCSBaseI internal CS2;\r\n    CS2PresaleRedeemI internal CS2Presale;\r\n    OracleRequest internal oracle;\r\n\r\n    address payable public beneficiary;\r\n    address public shippingControl;\r\n    address public tokenAssignmentControl;\r\n\r\n    uint256 public basePriceEurCent;\r\n    uint256 public priceTargetTimestamp;\r\n    uint256[4] public lastSaleTimestamp; // Every AssetType has their own sale/price tracking.\r\n    uint256[4] public lastSalePriceEurCent;\r\n    uint256[4] public lastSlotPriceEurCent;\r\n    uint256 public slotSeconds = 600;\r\n    uint256 public increaseFactorMicro; // 2500 for 0.25% (0.0025 * 1M)\r\n\r\n    struct SoldInfo {\r\n        address recipient;\r\n        uint256 blocknumber;\r\n        uint256 tokenId;\r\n        bool presale;\r\n        CS2PropertiesI.AssetType aType;\r\n    }\r\n\r\n    SoldInfo[] public soldSequence;\r\n    uint256 public lastAssignedSequence;\r\n    uint256 public lastRetrievedSequence;\r\n\r\n    address[8] public tokenPools; // Pools for every AssetType as well as \"normal\" OCS and presale.\r\n    uint256[8] public startIds;\r\n    uint256[8] public tokenPoolSize;\r\n    uint256[8] public unassignedInPool;\r\n    uint256[2500][8] public tokenIdPools; // Max 2500 IDs per pool.\r\n\r\n    bool internal _isOpen = true;\r\n\r\n    enum ShippingStatus{\r\n        Initial,\r\n        Sold,\r\n        ShippingSubmitted,\r\n        ShippingConfirmed\r\n    }\r\n\r\n    mapping(uint256 => ShippingStatus) public deliveryStatus;\r\n\r\n    event BasePriceChanged(uint256 previousBasePriceEurCent, uint256 newBasePriceEurCent);\r\n    event PriceTargetTimeChanged(uint256 previousPriceTargetTimestamp, uint256 newPriceTargetTimestamp);\r\n    event IncreaseFactorChanged(uint256 previousIncreaseFactorMicro, uint256 newIncreaseFactorMicro);\r\n    event OracleChanged(address indexed previousOracle, address indexed newOracle);\r\n    event BeneficiaryTransferred(address indexed previousBeneficiary, address indexed newBeneficiary);\r\n    event TokenAssignmentControlTransferred(address indexed previousTokenAssignmentControl, address indexed newTokenAssignmentControl);\r\n    event ShippingControlTransferred(address indexed previousShippingControl, address indexed newShippingControl);\r\n    event ShopOpened();\r\n    event ShopClosed();\r\n    event AssetSold(address indexed buyer, address recipient, bool indexed presale, CS2PropertiesI.AssetType indexed aType, uint256 sequenceNumber, uint256 priceWei);\r\n    event AssetAssigned(address indexed recipient, uint256 indexed tokenId, uint256 sequenceNumber);\r\n    event AssignedAssetRetrieved(uint256 indexed tokenId, address indexed recipient);\r\n    event ShippingSubmitted(address indexed owner, uint256[] tokenIds, string deliveryInfo);\r\n    event ShippingFailed(address indexed owner, uint256 indexed tokenId, string reason);\r\n    event ShippingConfirmed(address indexed owner, uint256 indexed tokenId);\r\n    // ERC721 event - never emitted in this contract but helpful for running our tests.\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    // ERC1155 event - never emitted in this contract but helpful for running our tests.\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    constructor(OracleRequest _oracle,\r\n        address _CS2Address,\r\n        address _CS2PresaleAddress,\r\n        uint256 _basePriceEurCent,\r\n        uint256 _priceTargetTimestamp,\r\n        uint256 _increaseFactorMicro,\r\n        address payable _beneficiary,\r\n        address _shippingControl,\r\n        address _tokenAssignmentControl,\r\n        uint256 _tokenPoolSize,\r\n        address[] memory _tokenPools,\r\n        uint256[] memory _startIds)\r\n    public\r\n    {\r\n        oracle = _oracle;\r\n        require(address(oracle) != address(0x0), \"You need to provide an actual Oracle contract.\");\r\n        CS2 = CS2OCSBaseI(_CS2Address);\r\n        require(address(CS2) != address(0x0), \"You need to provide an actual Cryptostamp 2 contract.\");\r\n        CS2Presale = CS2PresaleRedeemI(_CS2PresaleAddress);\r\n        require(address(CS2Presale) != address(0x0), \"You need to provide an actual Cryptostamp 2 Presale contract.\");\r\n        beneficiary = _beneficiary;\r\n        require(address(beneficiary) != address(0x0), \"You need to provide an actual beneficiary address.\");\r\n        shippingControl = _shippingControl;\r\n        require(address(shippingControl) != address(0x0), \"You need to provide an actual shippingControl address.\");\r\n        tokenAssignmentControl = _tokenAssignmentControl;\r\n        require(address(tokenAssignmentControl) != address(0x0), \"You need to provide an actual tokenAssignmentControl address.\");\r\n        basePriceEurCent = _basePriceEurCent;\r\n        require(basePriceEurCent > 0, \"You need to provide a non-zero base price.\");\r\n        priceTargetTimestamp = _priceTargetTimestamp;\r\n        require(priceTargetTimestamp > now, \"You need to provide a price target time in the future.\");\r\n        increaseFactorMicro = _increaseFactorMicro;\r\n        uint256 poolnum = tokenPools.length;\r\n        require(_tokenPools.length == poolnum, \"Need correct amount of token pool addresses.\");\r\n        require(_startIds.length == poolnum, \"Need correct amount of token pool start IDs.\");\r\n        for (uint256 i = 0; i < poolnum; i++) {\r\n            tokenPools[i] = _tokenPools[i];\r\n            startIds[i] = _startIds[i];\r\n            tokenPoolSize[i] = _tokenPoolSize;\r\n        }\r\n    }\r\n\r\n    modifier onlyBeneficiary() {\r\n        require(msg.sender == beneficiary, \"Only the current benefinicary can call this function.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyShippingControl() {\r\n        require(msg.sender == shippingControl, \"shippingControl key required for this function.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenAssignmentControl() {\r\n        require(msg.sender == tokenAssignmentControl, \"tokenAssignmentControl key required for this function.\");\r\n        _;\r\n    }\r\n\r\n    modifier requireOpen() {\r\n        require(isOpen() == true, \"This call only works when the shop is open.\");\r\n        _;\r\n    }\r\n\r\n    /*** Enable adjusting variables after deployment ***/\r\n\r\n    function setBasePrice(uint256 _newBasePriceEurCent)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        require(_newBasePriceEurCent > 0, \"You need to provide a non-zero price.\");\r\n        emit BasePriceChanged(basePriceEurCent, _newBasePriceEurCent);\r\n        basePriceEurCent = _newBasePriceEurCent;\r\n    }\r\n\r\n    function setPriceTargetTime(uint256 _newPriceTargetTimestamp)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        require(_newPriceTargetTimestamp > now, \"You need to provide a price target time in the future.\");\r\n        emit PriceTargetTimeChanged(priceTargetTimestamp, _newPriceTargetTimestamp);\r\n        priceTargetTimestamp = _newPriceTargetTimestamp;\r\n    }\r\n\r\n    function setIncreaseFactor(uint256 _newIncreaseFactorMicro)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        emit IncreaseFactorChanged(increaseFactorMicro, _newIncreaseFactorMicro);\r\n        increaseFactorMicro = _newIncreaseFactorMicro;\r\n    }\r\n\r\n    function setOracle(OracleRequest _newOracle)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        require(address(_newOracle) != address(0x0), \"You need to provide an actual Oracle contract.\");\r\n        emit OracleChanged(address(oracle), address(_newOracle));\r\n        oracle = _newOracle;\r\n    }\r\n\r\n    function transferBeneficiary(address payable _newBeneficiary)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        require(_newBeneficiary != address(0), \"beneficiary cannot be the zero address.\");\r\n        emit BeneficiaryTransferred(beneficiary, _newBeneficiary);\r\n        beneficiary = _newBeneficiary;\r\n    }\r\n\r\n    function transferTokenAssignmentControl(address _newTokenAssignmentControl)\r\n    public\r\n    onlyTokenAssignmentControl\r\n    {\r\n        require(_newTokenAssignmentControl != address(0), \"tokenAssignmentControl cannot be the zero address.\");\r\n        emit TokenAssignmentControlTransferred(tokenAssignmentControl, _newTokenAssignmentControl);\r\n        tokenAssignmentControl = _newTokenAssignmentControl;\r\n    }\r\n\r\n    function transferShippingControl(address _newShippingControl)\r\n    public\r\n    onlyShippingControl\r\n    {\r\n        require(_newShippingControl != address(0), \"shippingControl cannot be the zero address.\");\r\n        emit ShippingControlTransferred(shippingControl, _newShippingControl);\r\n        shippingControl = _newShippingControl;\r\n    }\r\n\r\n    function openShop()\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        _isOpen = true;\r\n        emit ShopOpened();\r\n    }\r\n\r\n    function closeShop()\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        _isOpen = false;\r\n        emit ShopClosed();\r\n    }\r\n\r\n    /*** Actual on-chain shop functionality ***/\r\n\r\n    // Return true if OCS is currently open for purchases.\r\n    // This can have additional conditions to just the variable, e.g. actually having items to sell.\r\n    function isOpen()\r\n    public view\r\n    returns (bool)\r\n    {\r\n        return _isOpen;\r\n    }\r\n\r\n    // Calculate dynamic asset price in EUR cent.\r\n    function priceEurCent(CS2PropertiesI.AssetType _type)\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        return priceEurCentDynamic(true, _type);\r\n    }\r\n\r\n    // Calculate fully dynamic asset price in EUR cent, without any capping for a time period.\r\n    // If freezeSaleSlot is true, the price from the last sale stays frozen during its slot.\r\n    // If that parameter if false, any sale will increase the price, even within the slot (used internally).\r\n    function priceEurCentDynamic(bool freezeSaleSlot, CS2PropertiesI.AssetType _type)\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        uint256 nowSlot = getTimeSlot(now);\r\n        uint256 typeNum = uint256(_type);\r\n        if (lastSaleTimestamp[typeNum] == 0 || nowSlot == 0) {\r\n            // The first stamp as well as any after the target time are sold for the base price.\r\n            return basePriceEurCent;\r\n        }\r\n        uint256 lastSaleSlot = getTimeSlot(lastSaleTimestamp[typeNum]);\r\n        if (freezeSaleSlot) {\r\n            // Keep price static within a time slot of slotSeconds (default 10 minutes).\r\n            if (nowSlot == lastSaleSlot) {\r\n                return lastSlotPriceEurCent[typeNum];\r\n            }\r\n        }\r\n        // The price is increased by a fixed percentage compared to the last sale,\r\n        // and decreased linearly towards the target timestamp and the base price.\r\n        // NOTE that due to the precision in EUR cent, we never end up with fractal EUR cent values.\r\n        uint256 priceIncrease = lastSalePriceEurCent[typeNum] * increaseFactorMicro / 1_000_000;\r\n        // Decrease: current overpricing multiplied by how much of the time between last sale and target has already passed.\r\n        // NOTE: *current* overpricing needs to take the increase into account first (otherwise it's overpricing of last sale)\r\n        // NOTE: getTimeSlot already reports the number of slots remaining to the target.\r\n        uint256 priceDecrease = (lastSalePriceEurCent[typeNum] + priceIncrease - basePriceEurCent) * (lastSaleSlot - nowSlot) / lastSaleSlot;\r\n        return lastSalePriceEurCent[typeNum] + priceIncrease - priceDecrease;\r\n    }\r\n\r\n    // Get number of time slot. Slot numbers decrease towards the target timestamp, 0 is anything after that target.\r\n    function getTimeSlot(uint256 _timestamp)\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        if (_timestamp >= priceTargetTimestamp) {\r\n            return 0;\r\n        }\r\n        return (priceTargetTimestamp - _timestamp) / slotSeconds + 1;\r\n    }\r\n\r\n    // Calculate current asset price in wei.\r\n    // Note: Price in EUR cent is available from basePriceEurCent().\r\n    function priceWei(CS2PropertiesI.AssetType _type)\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        return priceEurCent(_type).mul(oracle.EUR_WEI()).div(100);\r\n    }\r\n\r\n    // Get the index of the pool for presale or normal OCS assets of the given type.\r\n    function getPoolIndex(bool _isPresale, CS2PropertiesI.AssetType _type)\r\n    public pure\r\n    returns (uint256)\r\n    {\r\n        return (_isPresale ? 4 : 0) + uint256(_type);\r\n    }\r\n\r\n    // Returns the amount of assets of that type still available for sale.\r\n    function availableForSale(bool _presale, CS2PropertiesI.AssetType _type)\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        uint256 poolIndex = getPoolIndex(_presale, _type);\r\n        return tokenPoolSize[poolIndex].sub(unassignedInPool[poolIndex]);\r\n    }\r\n\r\n    // Returns true if the asset of the given type is sold out.\r\n    function isSoldOut(bool _presale, CS2PropertiesI.AssetType _type)\r\n    public view\r\n    returns (bool)\r\n    {\r\n        return availableForSale(_presale, _type) == 0;\r\n    }\r\n\r\n    // Buy assets of a single type/animal.\r\n    // The number of assets as well as the recipient are explicitly given.\r\n    // This will fail when the full amount cannot be provided or the payment is too little for that amount.\r\n    // The recipient does not need to match the buyer, so the assets can be sent elsewhere (e.g. into a collection).\r\n    // tokenData and merkleProofs are are collection of mint proofs to optimistically try for retrieving assigned assets.\r\n    function buy(CS2PropertiesI.AssetType _type, uint256 _amount, address payable _recipient, bytes32[] memory tokenData, bytes32[] memory merkleProofsAggregated)\r\n    public payable\r\n    requireOpen\r\n    {\r\n        if (tokenData.length > 0) {\r\n            mintAssetsWithAggregatedProofs(tokenData, merkleProofsAggregated);\r\n        }\r\n        bool isPresale = false;\r\n        require(_amount <= availableForSale(isPresale, _type), \"Not enough assets available to buy that amount.\");\r\n        uint256 curPriceWei = priceWei(_type);\r\n        uint256 payAmount = _amount.mul(curPriceWei);\r\n        require(msg.value >= payAmount, \"You need to send enough currency to buy the specified amount.\");\r\n        uint256 typeNum = uint256(_type);\r\n        if (lastSaleTimestamp[typeNum] == 0 || getTimeSlot(now) != getTimeSlot(lastSaleTimestamp[typeNum])) {\r\n            // This is only called when priceEurCent() actually returns something different than the last slot price.\r\n            lastSlotPriceEurCent[typeNum] = priceEurCent(_type);\r\n        }\r\n        // Transfer the actual payment amount to the beneficiary.\r\n        // NOTE: We know this is no contract that causes re-entrancy as we own it.\r\n        (bool sendSuccess, /*bytes memory data*/) = beneficiary.call{value: payAmount}(\"\");\r\n        if (!sendSuccess) { revert(\"Error in sending payment!\"); }\r\n        for (uint256 i = 0; i < _amount; i++) {\r\n            // Assign a sequence number and store block and owner for it.\r\n            soldSequence.push(SoldInfo(_recipient, block.number, 0, isPresale, _type));\r\n            emit AssetSold(msg.sender, _recipient, isPresale, _type, soldSequence.length, curPriceWei);\r\n            // Adjust lastSale parameters for every sale so per-sale increase is calculated correctly.\r\n            lastSalePriceEurCent[typeNum] = priceEurCentDynamic(false, _type);\r\n            lastSaleTimestamp[typeNum] = now;\r\n        }\r\n        uint256 poolIndex = getPoolIndex(isPresale, _type);\r\n        unassignedInPool[poolIndex] = unassignedInPool[poolIndex].add(_amount);\r\n        // Assign a max of one asset/token more than we purchased.\r\n        assignPurchasedAssets(_amount + 1);\r\n        // Try retrieving a max of one asset/token more than we purchased.\r\n        retrieveAssignedAssets(_amount + 1);\r\n        // Send back change money. Do this last as msg.sender could cause re-entrancy.\r\n        if (msg.value > payAmount) {\r\n            (bool returnSuccess, /*bytes memory data*/) = msg.sender.call{value: msg.value.sub(payAmount)}(\"\");\r\n            if (!returnSuccess) { revert(\"Error in returning change!\"); }\r\n        }\r\n    }\r\n\r\n    // Redeem presale vouchers for assets of a single type/animal.\r\n    // The number of assets as well as the recipient are explicitly given.\r\n    // This will fail when the full amount cannot be provided or the buyer has too few vouchers.\r\n    // The recipient does not need to match the buyer, so the assets can be sent elsewhere (e.g. into a collection).\r\n    // tokenData and merkleProofs are are collection of mint proofs to optimistically try for retrieving assigned assets.\r\n    function redeemVoucher(CS2PropertiesI.AssetType _type, uint256 _amount, address payable _recipient, bytes32[] memory tokenData, bytes32[] memory merkleProofsAggregated)\r\n    public\r\n    requireOpen\r\n    {\r\n        if (tokenData.length > 0) {\r\n            mintAssetsWithAggregatedProofs(tokenData, merkleProofsAggregated);\r\n        }\r\n        bool isPresale = true;\r\n        require(_amount <= availableForSale(isPresale, _type), \"Not enough assets available to buy that amount.\");\r\n        uint256 typeNum = uint256(_type);\r\n        require(CS2Presale.balanceOf(msg.sender, typeNum) >= _amount, \"You need to own enough presale vouchers to redeem the specified amount.\");\r\n        // Redeem the vouchers.\r\n        CS2PresaleRedeemI.AssetType[] memory redeemTypes = new CS2PresaleRedeemI.AssetType[](1);\r\n        uint256[] memory redeemAmounts = new uint256[](1);\r\n        redeemTypes[0] = CS2PresaleRedeemI.AssetType(typeNum);\r\n        redeemAmounts[0] = _amount;\r\n        CS2Presale.redeemBatch(msg.sender, redeemTypes, redeemAmounts);\r\n        //CS2Presale.redeemBatch(msg.sender, [_type], [_amount]);\r\n        for (uint256 i = 0; i < _amount; i++) {\r\n            // Assign a sequence number and store block and owner for it.\r\n            soldSequence.push(SoldInfo(_recipient, block.number, 0, isPresale, _type));\r\n            emit AssetSold(msg.sender, _recipient, isPresale, _type, soldSequence.length, 0);\r\n        }\r\n        uint256 poolIndex = getPoolIndex(isPresale, _type);\r\n        unassignedInPool[poolIndex] = unassignedInPool[poolIndex].add(_amount);\r\n        // Assign a max of one asset/token more than we purchased.\r\n        assignPurchasedAssets(_amount + 1);\r\n        // Try retrieving a max of one asset/token more than we purchased.\r\n        retrieveAssignedAssets(_amount + 1);\r\n    }\r\n\r\n    // Get total amount of not-yet-assigned assets\r\n    function getUnassignedAssetCount()\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        return soldSequence.length - lastAssignedSequence;\r\n    }\r\n\r\n    // Get total amount of not-yet-retrieved assets\r\n    function getUnretrievedAssetCount()\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        return soldSequence.length - lastRetrievedSequence;\r\n    }\r\n\r\n    // Get total amount of sold assets\r\n    function getSoldCount()\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        return soldSequence.length;\r\n    }\r\n\r\n    // Get the token ID for any sold asset with the given sequence number.\r\n    // As we do not know the block hash of the current block in Solidity, this can be given from the outside.\r\n    // NOTE that when you hand in a wrong block hash, you will get wrong results!\r\n    function getSoldTokenId(uint256 _sequenceNumber, bytes32 _currentBlockHash)\r\n    public view\r\n    returns (uint256)\r\n    {\r\n        if (_sequenceNumber <= lastAssignedSequence) {\r\n            // We can return the ID directly from the soldSequence.\r\n            uint256 seqIdx = _sequenceNumber.sub(1);\r\n            return soldSequence[seqIdx].tokenId;\r\n        }\r\n        // For unassigned assets, get pool and slot and then a token ID from that.\r\n        uint256 poolIndex;\r\n        uint256 slotIndex;\r\n        if (_sequenceNumber == lastAssignedSequence.add(1)) {\r\n            (poolIndex, slotIndex) = _getNextUnassignedPoolSlot(_currentBlockHash);\r\n        }\r\n        else {\r\n            (poolIndex, slotIndex) = _getUnassignedPoolSlotDeep(_sequenceNumber, _currentBlockHash);\r\n        }\r\n        return _getTokenIdForPoolSlot(poolIndex, slotIndex);\r\n    }\r\n\r\n    // Get the actual token ID for a pool slot, including the dance of resolving \"0\" IDs.\r\n    function _getTokenIdForPoolSlot(uint256 _poolIndex, uint256 _slotIndex)\r\n    internal view\r\n    returns (uint256)\r\n    {\r\n        uint256 tokenId = tokenIdPools[_poolIndex][_slotIndex];\r\n        if (tokenId == 0) {\r\n            // We know we don't have token ID 0 in the pool, so we'll calculate the actual ID.\r\n            tokenId = startIds[_poolIndex].add(_slotIndex);\r\n        }\r\n        return tokenId;\r\n    }\r\n\r\n    // Get a slot index for the given sequence index (not sequence number!) and pool size.\r\n    function _getSemiRandomSlotIndex(uint256 seqIdx, uint256 poolSize, bytes32 _currentBlockHash)\r\n    internal view\r\n    returns (uint256)\r\n    {\r\n        // Get block hash. As this only works for the last 256 blocks, fall back to the empty keccak256 hash to keep getting stable results.\r\n        bytes32 bhash;\r\n        if (soldSequence[seqIdx].blocknumber == block.number) {\r\n          require(_currentBlockHash != bytes32(\"\"), \"For assets sold in the current block, provide a valid block hash.\");\r\n          bhash = _currentBlockHash;\r\n        }\r\n        else if (block.number < 256 || soldSequence[seqIdx].blocknumber >= block.number.sub(256)) {\r\n          bhash = blockhash(soldSequence[seqIdx].blocknumber);\r\n        }\r\n        else {\r\n          bhash = keccak256(\"\");\r\n        }\r\n        return uint256(keccak256(abi.encodePacked(seqIdx, bhash))) % poolSize;\r\n    }\r\n\r\n    // Get the pool and slot indexes for the next asset to assign, which is a pretty straight-forward case.\r\n    function _getNextUnassignedPoolSlot(bytes32 _currentBlockHash)\r\n    internal view\r\n    returns (uint256, uint256)\r\n    {\r\n        uint256 seqIdx = lastAssignedSequence; // last + 1 is next seqNo, seqIdx is seqNo - 1\r\n        uint256 poolIndex = getPoolIndex(soldSequence[seqIdx].presale, soldSequence[seqIdx].aType);\r\n        uint256 slotIndex = _getSemiRandomSlotIndex(seqIdx, tokenPoolSize[poolIndex], _currentBlockHash);\r\n        return (poolIndex, slotIndex);\r\n    }\r\n\r\n    // Get the pool and slot indexes for any asset that is still to be assigned.\r\n    // This case is rather complicated as it needs to calculate which assets would be removed in sequence before this one.\r\n    function _getUnassignedPoolSlotDeep(uint256 _sequenceNumber, bytes32 _currentBlockHash)\r\n    internal view\r\n    returns (uint256, uint256)\r\n    {\r\n        require(_sequenceNumber > lastAssignedSequence, \"The asset was assigned already.\");\r\n        require(_sequenceNumber <= soldSequence.length, \"Exceeds maximum sequence number.\");\r\n        uint256 depth = _sequenceNumber.sub(lastAssignedSequence);\r\n        uint256[] memory poolIndex = new uint256[](depth);\r\n        uint256[] memory slotIndex = new uint256[](depth);\r\n        uint256[] memory slotRedirect = new uint256[](depth);\r\n        uint256[] memory poolSizeReduction = new uint256[](tokenPoolSize.length);\r\n        for (uint256 i = 0; i < depth; i++) {\r\n            uint256 seqIdx = lastAssignedSequence.add(i); // last + 1 is next seqNo, seqIdx is seqNo - 1, then we add i\r\n            poolIndex[i] = getPoolIndex(soldSequence[seqIdx].presale, soldSequence[seqIdx].aType);\r\n            uint256 calcPoolSize = tokenPoolSize[poolIndex[i]].sub(poolSizeReduction[poolIndex[i]]);\r\n            slotIndex[i] = _getSemiRandomSlotIndex(seqIdx, calcPoolSize, _currentBlockHash);\r\n            // Resolve all fitting redirects - this is an O(2) loop!\r\n            for (uint256 fitloop = 0; fitloop < i; fitloop++) {\r\n                for (uint256 j = 0; j < i; j++) {\r\n                    if (poolIndex[i] == poolIndex[j] && slotIndex[i] == slotIndex[j]) {\r\n                        slotIndex[i] = slotRedirect[j];\r\n                    }\r\n                }\r\n            }\r\n            // Instead of actually shuffling the array, do a redirect dance.\r\n            slotRedirect[i] = calcPoolSize.sub(1);\r\n            poolSizeReduction[poolIndex[i]] = poolSizeReduction[poolIndex[i]].add(1);\r\n        }\r\n        return (poolIndex[depth.sub(1)], slotIndex[depth.sub(1)]);\r\n    }\r\n\r\n    // Assign _maxCount asset (or less if less are unassigned)\r\n    function assignPurchasedAssets(uint256 _maxCount)\r\n    public\r\n    {\r\n        for (uint256 i = 0; i < _maxCount; i++) {\r\n            if (lastAssignedSequence < soldSequence.length) {\r\n                _assignNextPurchasedAsset(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    function assignNextPurchasedAssset()\r\n    public\r\n    {\r\n        _assignNextPurchasedAsset(true);\r\n    }\r\n\r\n    function _assignNextPurchasedAsset(bool revertForSameBlock)\r\n    internal\r\n    {\r\n        uint256 nextSequenceNumber = lastAssignedSequence.add(1);\r\n        // Find the stamp to assign and transfer it.\r\n        uint256 seqIdx = nextSequenceNumber.sub(1);\r\n        if (soldSequence[seqIdx].blocknumber < block.number) {\r\n            // Get tokenId in two steps as we need the slot index later.\r\n            (uint256 poolIndex, uint256 slotIndex) = _getNextUnassignedPoolSlot(bytes32(\"\"));\r\n            uint256 tokenId = _getTokenIdForPoolSlot(poolIndex, slotIndex);\r\n            soldSequence[seqIdx].tokenId = tokenId;\r\n            emit AssetAssigned(soldSequence[seqIdx].recipient, tokenId, nextSequenceNumber);\r\n            if (lastRetrievedSequence == lastAssignedSequence && CS2.exists(tokenId)) {\r\n                // If the asset exists and retrieval is caught up, do retrieval right away.\r\n                _retrieveAssignedAsset(seqIdx);\r\n            }\r\n            // Adjust the pool for the transferred asset.\r\n            uint256 lastSlotIndex = tokenPoolSize[poolIndex].sub(1);\r\n            if (slotIndex != lastSlotIndex) {\r\n                // If the removed index is not the last, move the last one to the removed slot.\r\n                uint256 lastValue = tokenIdPools[poolIndex][lastSlotIndex];\r\n                if (lastValue == 0) {\r\n                    // In case we still have a 0 here, set the correct tokenId instead.\r\n                    lastValue = startIds[poolIndex] + lastSlotIndex;\r\n                }\r\n                tokenIdPools[poolIndex][slotIndex] = lastValue;\r\n            }\r\n            tokenPoolSize[poolIndex] = tokenPoolSize[poolIndex].sub(1);\r\n            unassignedInPool[poolIndex] = unassignedInPool[poolIndex].sub(1);\r\n            // Set delivery status for newly sold asset, and update lastAssigned.\r\n            deliveryStatus[tokenId] = ShippingStatus.Sold;\r\n            lastAssignedSequence = nextSequenceNumber;\r\n        }\r\n        else {\r\n            if (revertForSameBlock) {\r\n                revert(\"Cannot assign assets in the same block.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    // Retrieve multiple assets with mint proofs, if they match the next ones to retrieve.\r\n    function mintAssetsWithAggregatedProofs(bytes32[] memory tokenData, bytes32[] memory merkleProofsAggregated)\r\n    public\r\n    {\r\n        uint256 count = tokenData.length;\r\n        require(count > 0, \"Need actual data and proofs\");\r\n        require(merkleProofsAggregated.length % count == 0, \"Count of data and proofs need to match\");\r\n        uint256 singleProofLength = merkleProofsAggregated.length / count;\r\n        // Try to mint all given proofs.\r\n        for (uint256 i = 0; i < count; i++) {\r\n            uint256 tokenId = uint256(tokenData[i] >> 168); // shift by 20 bytes for address and 1 byte for properties\r\n            if (!CS2.exists(tokenId)) {\r\n                bytes32[] memory merkleProof = new bytes32[](singleProofLength);\r\n                for (uint256 j = 0; j < singleProofLength; j++) {\r\n                    merkleProof[j] = merkleProofsAggregated[singleProofLength.mul(i).add(j)];\r\n                }\r\n                CS2.createWithProof(tokenData[i], merkleProof);\r\n            }\r\n        }\r\n    }\r\n\r\n    function retrieveAssignedAssets(uint256 _maxCount)\r\n    public\r\n    {\r\n        for (uint256 i = 0; i < _maxCount; i++) {\r\n            if (lastRetrievedSequence < lastAssignedSequence) {\r\n                uint256 seqIdx = lastRetrievedSequence; // last + 1 is next seqNo, seqIdx is seqNo - 1\r\n                // Only retrieve an asset if the token actually exists.\r\n                if (CS2.exists(soldSequence[seqIdx].tokenId)) {\r\n                    _retrieveAssignedAsset(seqIdx);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _retrieveAssignedAsset(uint256 seqIdx)\r\n    internal\r\n    {\r\n        uint256 poolIndex = getPoolIndex(soldSequence[seqIdx].presale, soldSequence[seqIdx].aType);\r\n        require(CS2.ownerOf(soldSequence[seqIdx].tokenId) == tokenPools[poolIndex], \"Already transferred out of the pool\");\r\n        // NOTE: We know CS2 is no contract that causes re-entrancy as it's our code.\r\n        CS2.safeTransferFrom(tokenPools[poolIndex], soldSequence[seqIdx].recipient, soldSequence[seqIdx].tokenId);\r\n        emit AssignedAssetRetrieved(soldSequence[seqIdx].tokenId, soldSequence[seqIdx].recipient);\r\n        lastRetrievedSequence = seqIdx.add(1); // current SeqNo is SeqIdx + 1\r\n    }\r\n\r\n    /*** Handle physical shipping ***/\r\n\r\n    // For token owner (after successful purchase): Request shipping.\r\n    // _deliveryInfo is a postal address encrypted with a public key on the client side.\r\n    function shipToMe(string memory _deliveryInfo, uint256[] memory _tokenIds)\r\n    public\r\n    requireOpen\r\n    {\r\n        uint256 count = _tokenIds.length;\r\n        for (uint256 i = 0; i < count; i++) {\r\n            require(CS2.ownerOf(_tokenIds[i]) == msg.sender, \"You can only request shipping for your own tokens.\");\r\n            require(deliveryStatus[_tokenIds[i]] == ShippingStatus.Sold, \"Shipping was already requested for one of these tokens or it was not sold by this shop.\");\r\n            deliveryStatus[_tokenIds[i]] = ShippingStatus.ShippingSubmitted;\r\n        }\r\n        emit ShippingSubmitted(msg.sender, _tokenIds, _deliveryInfo);\r\n    }\r\n\r\n    // For shipping service: Mark shipping as completed/confirmed.\r\n    function confirmShipping(uint256[] memory _tokenIds)\r\n    public\r\n    onlyShippingControl\r\n    {\r\n        uint256 count = _tokenIds.length;\r\n        for (uint256 i = 0; i < count; i++) {\r\n            deliveryStatus[_tokenIds[i]] = ShippingStatus.ShippingConfirmed;\r\n            emit ShippingConfirmed(CS2.ownerOf(_tokenIds[i]), _tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    // For shipping service: Mark shipping as failed/rejected (due to invalid address).\r\n    function rejectShipping(uint256[] memory _tokenIds, string memory _reason)\r\n    public\r\n    onlyShippingControl\r\n    {\r\n        uint256 count = _tokenIds.length;\r\n        for (uint256 i = 0; i < count; i++) {\r\n            deliveryStatus[_tokenIds[i]] = ShippingStatus.Sold;\r\n            emit ShippingFailed(CS2.ownerOf(_tokenIds[i]), _tokenIds[i], _reason);\r\n        }\r\n    }\r\n\r\n    /*** Enable reverse ENS registration ***/\r\n\r\n    // Call this with the address of the reverse registrar for the respecitve network and the ENS name to register.\r\n    // The reverse registrar can be found as the owner of 'addr.reverse' in the ENS system.\r\n    // For Mainnet, the address needed is 0x9062c0a6dbd6108336bcbe4593a3d1ce05512069\r\n    function registerReverseENS(address _reverseRegistrarAddress, string calldata _name)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        require(_reverseRegistrarAddress != address(0), \"need a valid reverse registrar\");\r\n        ENSReverseRegistrarI(_reverseRegistrarAddress).setName(_name);\r\n    }\r\n\r\n    /*** Make sure currency or NFT doesn't get stranded in this contract ***/\r\n\r\n    // If this contract gets a balance in some ERC20 contract after it's finished, then we can rescue it.\r\n    function rescueToken(IERC20 _foreignToken, address _to)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        _foreignToken.transfer(_to, _foreignToken.balanceOf(address(this)));\r\n    }\r\n\r\n    // If this contract gets a balance in some ERC721 contract after it's finished, then we can rescue it.\r\n    function approveNFTrescue(IERC721 _foreignNFT, address _to)\r\n    external\r\n    onlyTokenAssignmentControl\r\n    {\r\n        _foreignNFT.setApprovalForAll(_to, true);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract OracleRequest\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_CS2Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_CS2PresaleAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_basePriceEurCent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceTargetTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_increaseFactorMicro\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_shippingControl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAssignmentControl\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPoolSize\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_tokenPools\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_startIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"}],\"name\":\"AssetAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"presale\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"enum CS2PropertiesI.AssetType\",\"name\":\"aType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceWei\",\"type\":\"uint256\"}],\"name\":\"AssetSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"AssignedAssetRetrieved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBasePriceEurCent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBasePriceEurCent\",\"type\":\"uint256\"}],\"name\":\"BasePriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousBeneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousIncreaseFactorMicro\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newIncreaseFactorMicro\",\"type\":\"uint256\"}],\"name\":\"IncreaseFactorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"OracleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPriceTargetTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriceTargetTimestamp\",\"type\":\"uint256\"}],\"name\":\"PriceTargetTimeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ShippingConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousShippingControl\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newShippingControl\",\"type\":\"address\"}],\"name\":\"ShippingControlTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"ShippingFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"deliveryInfo\",\"type\":\"string\"}],\"name\":\"ShippingSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ShopClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ShopOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTokenAssignmentControl\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTokenAssignmentControl\",\"type\":\"address\"}],\"name\":\"TokenAssignmentControlTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_foreignNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"approveNFTrescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assignNextPurchasedAssset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxCount\",\"type\":\"uint256\"}],\"name\":\"assignPurchasedAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_presale\",\"type\":\"bool\"},{\"internalType\":\"enum CS2PropertiesI.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"availableForSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePriceEurCent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CS2PropertiesI.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"tokenData\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProofsAggregated\",\"type\":\"bytes32[]\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeShop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"confirmShipping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deliveryStatus\",\"outputs\":[{\"internalType\":\"enum CS2OnChainShop.ShippingStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPresale\",\"type\":\"bool\"},{\"internalType\":\"enum CS2PropertiesI.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"getPoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSoldCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_currentBlockHash\",\"type\":\"bytes32\"}],\"name\":\"getSoldTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getTimeSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnassignedAssetCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnretrievedAssetCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"increaseFactorMicro\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_presale\",\"type\":\"bool\"},{\"internalType\":\"enum CS2PropertiesI.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"isSoldOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAssignedSequence\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRetrievedSequence\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastSalePriceEurCent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastSaleTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastSlotPriceEurCent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"tokenData\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProofsAggregated\",\"type\":\"bytes32[]\"}],\"name\":\"mintAssetsWithAggregatedProofs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openShop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CS2PropertiesI.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"priceEurCent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"freezeSaleSlot\",\"type\":\"bool\"},{\"internalType\":\"enum CS2PropertiesI.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"priceEurCentDynamic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceTargetTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CS2PropertiesI.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"priceWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CS2PropertiesI.AssetType\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"tokenData\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProofsAggregated\",\"type\":\"bytes32[]\"}],\"name\":\"redeemVoucher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reverseRegistrarAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"registerReverseENS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"rejectShipping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_foreignToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxCount\",\"type\":\"uint256\"}],\"name\":\"retrieveAssignedAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newBasePriceEurCent\",\"type\":\"uint256\"}],\"name\":\"setBasePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newIncreaseFactorMicro\",\"type\":\"uint256\"}],\"name\":\"setIncreaseFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract OracleRequest\",\"name\":\"_newOracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPriceTargetTimestamp\",\"type\":\"uint256\"}],\"name\":\"setPriceTargetTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_deliveryInfo\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"shipToMe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shippingControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slotSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"soldSequence\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blocknumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"presale\",\"type\":\"bool\"},{\"internalType\":\"enum CS2PropertiesI.AssetType\",\"name\":\"aType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"startIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAssignmentControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenPoolSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newBeneficiary\",\"type\":\"address\"}],\"name\":\"transferBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newShippingControl\",\"type\":\"address\"}],\"name\":\"transferShippingControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTokenAssignmentControl\",\"type\":\"address\"}],\"name\":\"transferTokenAssignmentControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unassignedInPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CS2OnChainShop","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001863d1351fc3003f1ad361939248e3a3a114958e000000000000000000000000a7f87e8d193e29bf1ed050fdd511b79fe0264d8b000000000000000000000000818737eec8a5350756da40d5ddafda8a84ade10700000000000000000000000000000000000000000000000000000000000002bc000000000000000000000000000000000000000000000000000000005f7a620000000000000000000000000000000000000000000000000000000000000007d0000000000000000000000000cebb9ae52a3d61c4ed1528fba93e5beaaa40e9e20000000000000000000000009a5be4f89d483e445716dc1abb7668e56deaa909000000000000000000000000596e620e175c2c37a5f35a41d9f2305a991ffc8900000000000000000000000000000000000000000000000000000000000009c4000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000000000000000000000000000000000000000000800000000000000000000000075b09e4ac76b2a9fc104014b1f73ce2dc134472600000000000000000000000023ba98addef64e1fdbdacee2293cbfd5f3d5e7ab000000000000000000000000d8a2264ba34fecb10e0001b5ffed50bfa7f2c0a90000000000000000000000002b15bdea3e1f4373607c1e468194e52d7d7c5b3500000000000000000000000094d20a5c9dff08a430e87e60c7ba5918833b72a3000000000000000000000000a9d27dc56c45fb9388ebb27cb0dcce6e4c97eadc0000000000000000000000002c6176e791a07930d86634a9dc191af9fa6251be00000000000000000000000069148554c14e061600109771102d7e329d796df20000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000d6d8000000000000000000000000000000000000000000000000000000000001c138000000000000000000000000000000000000000000000000000000000002ab9800000000000000000000000000000000000000000000000000000000000395f8000000000000000000000000000000000000000000000000000000000000e09c000000000000000000000000000000000000000000000000000000000001cafc000000000000000000000000000000000000000000000000000000000002b55c0000000000000000000000000000000000000000000000000000000000039fbc","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://675293a428cc64fcef06eb856578527f12f5baf480f751a59c24ff72a712cac0"}]}