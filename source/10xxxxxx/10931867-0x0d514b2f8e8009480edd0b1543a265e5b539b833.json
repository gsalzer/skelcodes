{"status":"1","message":"OK","result":[{"SourceCode":"/* \r\n *  PeriodicStaker\r\n *  VERSION: 3\r\n *\r\n */\r\n\r\ncontract ERC20{\r\n    function allowance(address owner, address spender) external view returns (uint256){}\r\n    function transfer(address recipient, uint256 amount) external returns (bool){}\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool){}\r\n    function balanceOf(address account) external view returns (uint256){}\r\n}\r\n\r\ncontract PeriodicStaker {\r\n    \r\n\r\n    event Staked(address staker);\r\n\r\n\r\n    ERC20 public token;\r\n    uint public total_stake=0;\r\n    uint public total_stakers=0;\r\n    mapping(address => uint)public stake;\r\n    \r\n    uint public status=0; //0=open , 1=can't unstake , 2 can't stake\r\n    \r\n    uint safeWindow=20;//40320;\r\n    \r\n    uint public startLock;\r\n    uint public lockTime;\r\n    uint minLock=10;//17280;\r\n    uint maxLock=60;//17280s0;\r\n    \r\n    uint public freezeTime;\r\n    uint minFreeze=10;//17280;\r\n    uint maxFreeze=60;//40320;\r\n\r\n    address public master;\r\n\r\n    \r\n\r\n    constructor(address tokenToStake,address mastr) public {\r\n        token=ERC20(tokenToStake);\r\n        master=mastr;\r\n    }\r\n    \r\n\r\n    function stakeNow(uint256 amount) public {\r\n        require(amount > 0);\r\n        require(status!=2);\r\n        uint256 allowance = token.allowance(msg.sender, address(this));\r\n        require(allowance >= amount);\r\n        require(token.transferFrom(msg.sender, address(this), amount));\r\n        if(stake[msg.sender]==0)total_stakers++;\r\n        stake[msg.sender]+=amount;\r\n        total_stake+=amount;\r\n        \r\n        emit Staked(msg.sender);\r\n    }\r\n    \r\n    function unstake() public {\r\n        require(stake[msg.sender] > 0);\r\n        if(status==1)require((startLock+lockTime)<block.number);\r\n        require(token.transfer(msg.sender, stake[msg.sender]));\r\n        total_stake-=stake[msg.sender];\r\n        stake[msg.sender]=0;\r\n        total_stakers--;\r\n\r\n    }\r\n    \r\n    function openDropping(uint lock) public{\r\n        require(msg.sender==master);\r\n        require(block.number>startLock+safeWindow);\r\n        require(minLock<=lock);\r\n        require(lock<=maxLock);\r\n        require(status==0);\r\n        status=1;\r\n        lockTime=lock;\r\n        startLock=block.number;\r\n    }\r\n    \r\n    function freeze(uint freez) public{\r\n        require(msg.sender==master);\r\n        require(block.number>startLock+safeWindow);\r\n        require(minFreeze<=freez);\r\n        require(freez<=maxFreeze);\r\n        require(status==0);\r\n        status=2;\r\n        freezeTime=freez;\r\n        startLock=block.number;\r\n    }\r\n    \r\n    function open() public{\r\n        require(status>0);\r\n        if(status==1)require(block.number>startLock+lockTime);\r\n        if(status==2)require(block.number>startLock+freezeTime);\r\n        startLock=block.number;\r\n        status=0;\r\n        \r\n    }\r\n    \r\n    function setMaster(address new_master)public returns(bool){\r\n        require(msg.sender!=master);\r\n        master=new_master;\r\n        return true;\r\n    }\r\n    \r\n    function status()public view returns(uint){return status;}\r\n\r\n}\r\n\r\ncontract TokenDropper{\r\n    \r\n    PeriodicStaker public staker;\r\n    ERC20 public token;\r\n    mapping(address => bool)public rewarded;\r\n    uint public multiplier;\r\n    address master;\r\n    address public receiver;\r\n    \r\n    constructor(address staker_contract,uint multip,address token_address,address destination) public{\r\n        staker=PeriodicStaker(staker_contract);\r\n        multiplier=multip;\r\n        token=ERC20(token_address);\r\n        master=msg.sender;\r\n        receiver=destination;\r\n    }\r\n    \r\n    function Pull_Reward() public{\r\n        require(!rewarded[msg.sender]);\r\n        require(staker.status()>0);\r\n        require(token.transfer(msg.sender, staker.stake(msg.sender)*multiplier));\r\n        rewarded[msg.sender]=true;\r\n    }\r\n    \r\n    function burn()public returns(bool){\r\n        require(staker.status()==0);\r\n        token.transfer(receiver, token.balanceOf(address(this)));\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_master\",\"type\":\"address\"}],\"name\":\"setMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_stakers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lock\",\"type\":\"uint256\"}],\"name\":\"openDropping\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_stake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"freez\",\"type\":\"uint256\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeNow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freezeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenToStake\",\"type\":\"address\"},{\"name\":\"mastr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"Staked\",\"type\":\"event\"}]","ContractName":"PeriodicStaker","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000801f90f81786dc72b4b9d51ab613fbe99e5e4ccd000000000000000000000000da1ec8f2fb47e905079663bcea69f1a2b010f2d3","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3341969092f74f5e7973bedd041e7857ebed6f5434edcf46a7a307aa6669e86b"}]}