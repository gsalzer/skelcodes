{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: BSD-3-Clause\r\n\r\n/** \r\n*                                                                                                                                  \r\n*       ##### /                                                             #######      /                                         \r\n*    ######  /          #                                                 /       ###  #/                                          \r\n*   /#   /  /          ###                                               /         ##  ##                                          \r\n*  /    /  /            #                                                ##        #   ##                                          \r\n*      /  /                                                               ###          ##                                          \r\n*     ## ##           ###        /###    ###  /###         /###          ## ###        ##  /##      /###    ###  /###       /##    \r\n*     ## ##            ###      / ###  /  ###/ #### /     / #### /        ### ###      ## / ###    / ###  /  ###/ #### /   / ###   \r\n*     ## ##             ##     /   ###/    ##   ###/     ##  ###/           ### ###    ##/   ###  /   ###/    ##   ###/   /   ###  \r\n*     ## ##             ##    ##    ##     ##    ##   k ####                  ### /##  ##     ## ##    ##     ##         ##    ### \r\n*     ## ##             ##    ##    ##     ##    ##   a   ###                   #/ /## ##     ## ##    ##     ##         ########  \r\n*     #  ##             ##    ##    ##     ##    ##   i     ###                  #/ ## ##     ## ##    ##     ##         #######   \r\n*        /              ##    ##    ##     ##    ##   z       ###                 # /  ##     ## ##    ##     ##         ##        \r\n*    /##/           /   ##    ##    ##     ##    ##   e  /###  ##       /##        /   ##     ## ##    /#     ##         ####    / \r\n*   /  ############/    ### /  ######      ###   ###  n / #### /       /  ########/    ##     ##  ####/ ##    ###         ######/  \r\n*  /     #########       ##/    ####        ###   ### -    ###/       /     #####       ##    ##   ###   ##    ###         #####   \r\n*  #                                                  w               |                       /                                    \r\n*   ##                                                e                \\)                    /                                     \r\n*                                                     b                                     /                                      \r\n*                                                                                          /                                       \r\n*\r\n*\r\n* Lion's Share is the very first true follow-me matrix smart contract ever created. \r\n* https://www.lionsshare.io\r\n* Get your share, join today!\r\n*/\r\n\r\npragma solidity 0.6.8;\r\n\r\ncontract LionShare {\r\n\r\n  struct Account {\r\n    uint32 id;\r\n    uint32 directSales;\r\n    uint8[] activeLevel;\r\n    bool exists;\r\n    address sponsor;\r\n    mapping(uint8 => L1) x31Positions;\r\n    mapping(uint8 => L2) x22Positions;\r\n  }\r\n\r\n  struct L1 {\r\n    uint32 directSales;\r\n    uint16 cycles;\r\n    uint8 passup;\r\n    uint8 reEntryCheck;\r\n    uint8 placement;\r\n    address sponsor;\r\n  }\r\n\r\n  struct L2 {\r\n    uint32 directSales;\r\n    uint16 cycles;\r\n    uint8 passup;\r\n    uint8 cycle;\r\n    uint8 reEntryCheck;\r\n    uint8 placementLastLevel;\r\n    uint8 placementSide;\r\n    address sponsor;\r\n    address placedUnder;\r\n    address[] placementFirstLevel;\r\n  }\r\n\r\n  uint internal constant ENTRY_ENABLED = 1;\r\n  uint internal constant ENTRY_DISABLED = 2;\r\n  uint public constant REENTRY_REQ = 2;\r\n\r\n  mapping(address => Account) public members;\r\n  mapping(uint32 => address) public idToMember;\r\n  mapping(uint8 => uint) public levelCost;\r\n  \r\n  uint internal reentry_status;\r\n  uint32 public lastId;\r\n  uint8 public topLevel;\r\n  address internal owner;\r\n\r\n  event Registration(address member, uint memberId, address sponsor);\r\n  event Upgrade(address member, address sponsor, uint8 matrix, uint8 level);\r\n  event PlacementL1(address member, address sponsor, uint8 level, uint8 placement, bool passup);  \r\n  event PlacementL2(address member, address sponsor, uint8 level, uint8 placementSide, address placedUnder, bool passup);\r\n  event Cycle(address indexed member, address fromPosition, uint8 matrix, uint8 level);\r\n  event PlacementReEntry(address indexed member, address reEntryFrom, uint8 matrix, uint8 level);\r\n  event FundsPayout(address indexed member, address payoutFrom, uint8 matrix, uint8 level);\r\n  event FundsPassup(address indexed member, address passupFrom, uint8 matrix, uint8 level);\r\n\r\n  modifier isOwner(address _account) {\r\n    require(owner == _account, \"Restricted Access!\");\r\n    _;\r\n  }\r\n\r\n  modifier isMember(address _addr) {\r\n    require(members[_addr].exists, \"Register Account First!\");\r\n    _;\r\n  }\r\n  \r\n  modifier blockReEntry() {\r\n    require(reentry_status != ENTRY_DISABLED, \"Security Block\");\r\n    reentry_status = ENTRY_DISABLED;\r\n\r\n    _;\r\n\r\n    reentry_status = ENTRY_ENABLED;\r\n  }\r\n\r\n  constructor(address _addr) public {\r\n    owner = msg.sender;\r\n\r\n    reentry_status = ENTRY_ENABLED;\r\n\r\n    levelCost[1] = 0.02 ether;\r\n    topLevel = 1;\r\n\r\n    createAccount(_addr, _addr, true);\r\n    handlePositionL1(_addr, _addr, _addr, 1, true);\r\n    handlePositionL2(_addr, _addr, _addr, 1, true);\r\n  }\r\n\r\n  fallback() external payable blockReEntry() {\r\n    preRegistration(msg.sender, bytesToAddress(msg.data));\r\n  }\r\n\r\n  receive() external payable blockReEntry() {\r\n    preRegistration(msg.sender, idToMember[1]);\r\n  }\r\n\r\n  function registration(address _sponsor) external payable blockReEntry() {\r\n    preRegistration(msg.sender, _sponsor);\r\n  }\r\n\r\n  function preRegistration(address _addr, address _sponsor) internal {\r\n    require((levelCost[1] * 2) == msg.value, \"Require .04 eth to register!\");\r\n\r\n    createAccount(_addr, _sponsor, false);\r\n\r\n    members[_sponsor].directSales++;\r\n    \r\n    handlePositionL1(_addr, _sponsor, _sponsor, 1, false);\r\n    handlePositionL2(_addr, _sponsor, _sponsor, 1, false);\r\n    \r\n    handlePayout(_addr, 0, 1);\r\n    handlePayout(_addr, 1, 1);\r\n  }\r\n  \r\n  function createAccount(address _addr, address _sponsor, bool _initial) internal {\r\n    require(!members[_addr].exists, \"Already a member!\");\r\n\r\n    if (_initial == false) {\r\n      require(members[_sponsor].exists, \"Sponsor dont exist!\");\r\n    }\r\n\r\n    lastId++;    \r\n\r\n    members[_addr] = Account({id: lastId, sponsor: _sponsor, exists: true, directSales: 0, activeLevel: new uint8[](2)});\r\n    idToMember[lastId] = _addr;\r\n    \r\n    emit Registration(_addr, lastId, _sponsor);\r\n  }\r\n\r\n  function purchaseLevel(uint8 _matrix, uint8 _level) external payable isMember(msg.sender) blockReEntry() {\r\n    require((_matrix == 1 || _matrix == 2), \"Invalid matrix identifier.\");\r\n    require((_level > 0 && _level <= topLevel), \"Invalid matrix level.\");    \r\n\r\n    uint8 activeLevel = members[msg.sender].activeLevel[(_matrix - 1)];\r\n    uint8 otherLevel = 1;\r\n\r\n    if (_matrix == 2) {\r\n      otherLevel = 0;\r\n    }\r\n\r\n    require((activeLevel < _level), \"Already active at level!\");\r\n    require((activeLevel == (_level - 1)), \"Level upgrade req. in order!\");\r\n    require(((members[msg.sender].activeLevel[otherLevel] * 2) >= _level), \"Double upgrade exeeded.\");\r\n    require((msg.value == levelCost[_level]), \"Wrong amount transferred.\");\r\n  \r\n    address sponsor = members[msg.sender].sponsor;\r\n    \r\n    Upgrade(msg.sender, sponsor, _matrix, _level);\r\n\r\n    if (_matrix == 1) {\r\n      handlePositionL1(msg.sender, sponsor, findActiveSponsor(msg.sender, sponsor, 0, _level, true), _level, false);\r\n    } else {\r\n      handlePositionL2(msg.sender, sponsor, findActiveSponsor(msg.sender, sponsor, 1, _level, true), _level, false);\r\n    }\r\n\r\n    handlePayout(msg.sender, (_matrix - 1), _level);    \r\n  }\r\n\r\n  function handlePositionL1(address _addr, address _mainSponsor, address _sponsor, uint8 _level, bool _initial) internal {\r\n    Account storage member = members[_addr];\r\n\r\n    member.activeLevel[0] = _level;\r\n    member.x31Positions[_level] = L1({sponsor: _sponsor, placement: 0, directSales: 0, cycles: 0, passup: 0, reEntryCheck: 0});\r\n\r\n    if (_initial == true) {\r\n      return;\r\n    } else if (_mainSponsor == _sponsor) {\r\n      members[_mainSponsor].x31Positions[_level].directSales++;\r\n    } else {\r\n      member.x31Positions[_level].reEntryCheck = 1;\r\n    }\r\n    \r\n    sponsorPlaceL1(_addr, _sponsor, _level, false);\r\n  }\r\n\r\n  function sponsorPlaceL1(address _addr, address _sponsor, uint8 _level, bool passup) internal {\r\n    L1 storage position = members[_sponsor].x31Positions[_level];\r\n\r\n    emit PlacementL1(_addr, _sponsor, _level, (position.placement + 1), passup);\r\n\r\n    if (position.placement >= 2) {\r\n      emit Cycle(_sponsor, _addr, 1, _level);\r\n\r\n      position.placement = 0;\r\n      position.cycles++;\r\n\r\n      if (_sponsor != idToMember[1]) {\r\n        position.passup++;\r\n\r\n        sponsorPlaceL1(_sponsor, position.sponsor, _level, true);\r\n      }\r\n    } else {\r\n      position.placement++;\r\n    }\r\n  }\r\n\r\n  function handlePositionL2(address _addr, address _mainSponsor, address _sponsor, uint8 _level, bool _initial) internal {\r\n    Account storage member = members[_addr];\r\n    \r\n    member.activeLevel[1] = _level;\r\n    member.x22Positions[_level] = L2({sponsor: _sponsor, directSales: 0, cycles: 0, passup: 0, cycle: 0, reEntryCheck: 0, placementSide: 0, placedUnder: _sponsor, placementFirstLevel: new address[](0), placementLastLevel: 0});\r\n\r\n    if (_initial == true) {\r\n      return;\r\n    } else if (_mainSponsor == _sponsor) {\r\n      members[_mainSponsor].x22Positions[_level].directSales++;\r\n    } else {\r\n      member.x22Positions[_level].reEntryCheck = 1;\r\n    }\r\n\r\n    sponsorPlaceL2(_addr, _sponsor, _level, false);\r\n  }\r\n\r\n  function sponsorPlaceL2(address _addr, address _sponsor, uint8 _level, bool passup) internal {\r\n    L2 storage member = members[_addr].x22Positions[_level];\r\n    L2 storage position = members[_sponsor].x22Positions[_level];\r\n\r\n    if (position.placementFirstLevel.length < 2) {\r\n      if (position.placementFirstLevel.length == 0) {\r\n        member.placementSide = 1;\r\n      } else {\r\n        member.placementSide = 2;\r\n      }\r\n      \r\n      member.placedUnder = _sponsor;\r\n      position.placementFirstLevel.push(_addr);\r\n\r\n      if (_sponsor != idToMember[1]) {\r\n        position.passup++;\r\n      }\r\n      \r\n      positionPlaceLastLevelL2(_addr, _sponsor, position.placedUnder, position.placementSide, _level);\r\n    } else {\r\n\r\n      if (position.placementLastLevel == 0) {\r\n        member.placementSide = 1;\r\n        member.placedUnder = position.placementFirstLevel[0];\r\n        position.placementLastLevel += 1;      \r\n      } else if ((position.placementLastLevel & 2) == 0) {\r\n        member.placementSide = 2;\r\n        member.placedUnder = position.placementFirstLevel[0];\r\n        position.placementLastLevel += 2;\r\n      } else if ((position.placementLastLevel & 4) == 0) {\r\n        member.placementSide = 1;\r\n        member.placedUnder = position.placementFirstLevel[1];\r\n        position.placementLastLevel += 4;\r\n      } else {\r\n        member.placementSide = 2;\r\n        member.placedUnder = position.placementFirstLevel[1];\r\n        position.placementLastLevel += 8;\r\n      }\r\n\r\n      if (member.placedUnder != idToMember[1]) {\r\n        members[member.placedUnder].x22Positions[_level].placementFirstLevel.push(_addr);        \r\n      }\r\n    }\r\n\r\n    if ((position.placementLastLevel & 15) == 15) {\r\n      emit Cycle(_sponsor, _addr, 2, _level);\r\n\r\n      position.placementFirstLevel = new address[](0);\r\n      position.placementLastLevel = 0;\r\n      position.cycles++;\r\n\r\n      if (_sponsor != idToMember[1]) {\r\n        position.cycle++;\r\n\r\n        sponsorPlaceL2(_sponsor, position.sponsor, _level, true);\r\n      }\r\n    }\r\n\r\n    emit PlacementL2(_addr, _sponsor, _level, member.placementSide, member.placedUnder, passup);\r\n  }\r\n\r\n  function positionPlaceLastLevelL2(address _addr, address _sponsor, address _position, uint8 _placementSide, uint8 _level) internal {\r\n    L2 storage position = members[_position].x22Positions[_level];\r\n\r\n    if (position.placementSide == 0 && _sponsor == idToMember[1]) {\r\n      return;\r\n    }\r\n    \r\n    if (_placementSide == 1) {\r\n      if ((position.placementLastLevel & 1) == 0) {\r\n        position.placementLastLevel += 1;\r\n      } else {\r\n        position.placementLastLevel += 2;\r\n      }\r\n    } else {\r\n      if ((position.placementLastLevel & 4) == 0) {\r\n        position.placementLastLevel += 4;\r\n      } else {\r\n        position.placementLastLevel += 8;\r\n      }\r\n    }\r\n\r\n    if ((position.placementLastLevel & 15) == 15) {\r\n      emit Cycle(_position, _addr, 2, _level);\r\n\r\n      position.placementFirstLevel = new address[](0);\r\n      position.placementLastLevel = 0;\r\n      position.cycles++;\r\n\r\n      if (_position != idToMember[1]) {\r\n        position.cycle++;\r\n\r\n        sponsorPlaceL2(_position, position.sponsor, _level, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  function findActiveSponsor(address _addr, address _sponsor, uint8 _matrix, uint8 _level, bool _emit) internal returns (address) {\r\n    address sponsorAddress = _sponsor;\r\n\r\n    while (true) {\r\n      if (members[sponsorAddress].activeLevel[_matrix] >= _level) {\r\n        return sponsorAddress;\r\n      }\r\n\r\n      if (_emit == true) {\r\n        emit FundsPassup(sponsorAddress, _addr, (_matrix + 1), _level);\r\n      }\r\n\r\n      sponsorAddress = members[sponsorAddress].sponsor;\r\n    }\r\n  }\r\n\r\n  function handleReEntryL1(address _addr, uint8 _level) internal {\r\n    L1 storage member = members[_addr].x31Positions[_level];\r\n    bool reentry = false;\r\n\r\n    member.reEntryCheck++;\r\n\r\n    if (member.reEntryCheck >= REENTRY_REQ) {\r\n      address sponsor = members[_addr].sponsor;\r\n\r\n      if (members[sponsor].activeLevel[0] >= _level) {\r\n        member.reEntryCheck = 0;\r\n        reentry = true;\r\n      } else {\r\n        sponsor = findActiveSponsor(_addr, sponsor, 0, _level, false);\r\n\r\n        if (member.sponsor != sponsor && members[sponsor].activeLevel[0] >= _level) {        \r\n          reentry = true;\r\n        }\r\n      }\r\n\r\n      if (reentry == true) {\r\n        member.sponsor = sponsor;\r\n\r\n        emit PlacementReEntry(sponsor, _addr, 1, _level);\r\n      }\r\n    }\r\n  }\r\n\r\n  function handleReEntryL2(address _addr, uint8 _level) internal {\r\n    L2 storage member = members[_addr].x22Positions[_level];\r\n    bool reentry = false;\r\n\r\n    member.reEntryCheck++;\r\n\r\n    if (member.reEntryCheck >= REENTRY_REQ) {\r\n      address sponsor = members[_addr].sponsor;\r\n\r\n      if (members[sponsor].activeLevel[1] >= _level) {\r\n        member.reEntryCheck = 0;\r\n        member.sponsor = sponsor;\r\n        reentry = true;\r\n      } else {\r\n        address active_sponsor = findActiveSponsor(_addr, sponsor, 1, _level, false);\r\n\r\n        if (member.sponsor != active_sponsor && members[active_sponsor].activeLevel[1] >= _level) {\r\n          member.sponsor = active_sponsor;\r\n          reentry = true;\r\n        }\r\n      }\r\n\r\n      if (reentry == true) {\r\n        emit PlacementReEntry(member.sponsor, _addr, 2, _level);\r\n      }\r\n    }\r\n  }\r\n\r\n  function findPayoutReceiver(address _addr, uint8 _matrix, uint8 _level) internal returns (address) {    \r\n    address from;\r\n    address receiver;\r\n\r\n    if (_matrix == 0) {      \r\n      receiver = members[_addr].x31Positions[_level].sponsor;\r\n\r\n      while (true) {\r\n        L1 storage member = members[receiver].x31Positions[_level];\r\n\r\n        if (member.passup == 0) {\r\n          return receiver;\r\n        }\r\n\r\n        member.passup--;\r\n        from = receiver;\r\n        receiver = member.sponsor;\r\n\r\n        if (_level > 1 && member.reEntryCheck > 0) {          \r\n          handleReEntryL1(from, _level);\r\n        }\r\n      }\r\n    } else {\r\n      receiver = members[_addr].x22Positions[_level].sponsor;\r\n\r\n      while (true) {\r\n        L2 storage member = members[receiver].x22Positions[_level];\r\n\r\n        if (member.passup == 0 && member.cycle == 0) {\r\n          return receiver;\r\n        }\r\n\r\n        if (member.passup > 0) {\r\n          member.passup--;\r\n          receiver = member.placedUnder;\r\n        } else {\r\n          member.cycle--;\r\n          from = receiver;\r\n          receiver = member.sponsor;  \r\n\r\n          if (_level > 1 && member.reEntryCheck > 0) {\r\n            handleReEntryL2(from, _level);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function handlePayout(address _addr, uint8 _matrix, uint8 _level) internal {\r\n    address receiver = findPayoutReceiver(_addr, _matrix, _level);\r\n\r\n    emit FundsPayout(receiver, _addr, (_matrix + 1), _level);\r\n\r\n    (bool success, ) = address(uint160(receiver)).call{ value: levelCost[_level], gas: 40000 }(\"\");\r\n\r\n    if (success == false) { //Failsafe to prevent malicious contracts from blocking matrix\r\n      (success, ) = address(uint160(idToMember[1])).call{ value: levelCost[_level], gas: 40000 }(\"\");\r\n      require(success, 'Transfer Failed');\r\n    }\r\n  }\r\n\r\n  function getAffiliateId() external view returns (uint) {\r\n    return members[msg.sender].id;\r\n  }\r\n\r\n  function getAffiliateWallet(uint32 memberId) external view returns (address) {\r\n    return idToMember[memberId];\r\n  }\r\n\r\n  function setupAccount(address _addr, address _sponsor, uint8 _level) external isOwner(msg.sender) {\r\n    createAccount(_addr, _sponsor, false);\r\n    compLevel(_addr, 1, _level);\r\n    compLevel(_addr, 2, _level);\r\n  }\r\n\r\n  function compLevel(address _addr, uint8 _matrix, uint8 _level) public isOwner(msg.sender) isMember(_addr) {\r\n    require((_matrix == 1 || _matrix == 2), \"Invalid matrix identifier.\");\r\n    require((_level > 0 && _level <= topLevel), \"Invalid matrix level.\");\r\n\r\n    uint8 matrix = _matrix - 1;\r\n    uint8 activeLevel = members[_addr].activeLevel[matrix];\r\n    address sponsor = members[_addr].sponsor;\r\n\r\n    require((activeLevel < _level), \"Already active at level!\");\r\n\r\n    for (uint8 num = (activeLevel + 1);num <= _level;num++) {\r\n      Upgrade(_addr, sponsor, _matrix, num);\r\n\r\n      if (matrix == 0) {\r\n        handlePositionL1(_addr, sponsor, findActiveSponsor(_addr, sponsor, 0, num, true), num, false);\r\n      } else {\r\n        handlePositionL2(_addr, sponsor, findActiveSponsor(_addr, sponsor, 1, num, true), num, false);\r\n      }\r\n    }\r\n  }\r\n\r\n  function addLevel(uint _levelPrice) external isOwner(msg.sender) {\r\n    require((levelCost[topLevel] < _levelPrice), \"Check price point!\");\r\n\r\n    topLevel++;\r\n\r\n    levelCost[topLevel] = _levelPrice;\r\n\r\n    handlePositionL1(idToMember[1], idToMember[1], idToMember[1], topLevel, true);\r\n    handlePositionL2(idToMember[1], idToMember[1], idToMember[1], topLevel, true);\r\n  }\r\n\r\n  function updateLevelCost(uint8 _level, uint _levelPrice) external isOwner(msg.sender) {\r\n    require((_level > 0 && _level <= topLevel), \"Invalid matrix level.\");\r\n    require((_levelPrice > 0), \"Check price point!\");\r\n\r\n    if (_level > 1) {\r\n      require((levelCost[(_level - 1)] < _levelPrice), \"Check price point!\");\r\n    }\r\n\r\n    if (_level < topLevel) {\r\n      require((levelCost[(_level + 1)] > _levelPrice), \"Check price point!\");\r\n    }\r\n\r\n    levelCost[_level] = _levelPrice;\r\n  }\r\n\r\n  function bytesToAddress(bytes memory _source) private pure returns (address addr) {\r\n    assembly {\r\n      addr := mload(add(_source, 20))\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromPosition\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Cycle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"passupFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"FundsPassup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payoutFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"FundsPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"placement\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"passup\",\"type\":\"bool\"}],\"name\":\"PlacementL1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"placementSide\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"placedUnder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"passup\",\"type\":\"bool\"}],\"name\":\"PlacementL2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reEntryFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"PlacementReEntry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"memberId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"REENTRY_REQ\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_levelPrice\",\"type\":\"uint256\"}],\"name\":\"addLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_matrix\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"compLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAffiliateId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"memberId\",\"type\":\"uint32\"}],\"name\":\"getAffiliateWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"idToMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"members\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"directSales\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_matrix\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"purchaseLevel\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"}],\"name\":\"registration\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"setupAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topLevel\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_levelPrice\",\"type\":\"uint256\"}],\"name\":\"updateLevelCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LionShare","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000000ec97f7bac8d38a16da32bbbd84f74b0870a2002","EVMVersion":"byzantium","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2eeb65f1c5138a4ae5191d939dfa119c98fc14e39c4bc8ba660397ade9209ab6"}]}