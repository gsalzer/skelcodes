{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n*******\r\n*******\r\n\r\n\r\n██████╗ ██╗  ██╗ ██████╗ ███████╗███╗   ██╗██╗██╗  ██╗████████╗██╗ ██████╗ ███████╗██████╗ \r\n██╔══██╗██║  ██║██╔═══██╗██╔════╝████╗  ██║██║╚██╗██╔╝╚══██╔══╝██║██╔════╝ ██╔════╝██╔══██╗\r\n██████╔╝███████║██║   ██║█████╗  ██╔██╗ ██║██║ ╚███╔╝    ██║   ██║██║  ███╗█████╗  ██████╔╝\r\n██╔═══╝ ██╔══██║██║   ██║██╔══╝  ██║╚██╗██║██║ ██╔██╗    ██║   ██║██║   ██║██╔══╝  ██╔══██╗\r\n██║     ██║  ██║╚██████╔╝███████╗██║ ╚████║██║██╔╝ ██╗   ██║   ██║╚██████╔╝███████╗██║  ██║\r\n╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═══╝╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝\r\n                                                                                           \r\ncopyright@2020 PHOENIXTIGER.IO\r\n\r\n-Developed by Kryptual Team\r\n\r\n****                                                          \r\n*/\r\n\r\npragma solidity >=0.4.23 <0.6.0;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    /**\r\n      * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n      * account.\r\n      */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n      * @dev Throws if called by any account other than the owner.\r\n      */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n    uint public _totalSupply;\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address who) public constant returns (uint);\r\n    function transfer(address to, uint value) public;\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public constant returns (uint);\r\n    function transferFrom(address from, address to, uint value) public;\r\n    function approve(address spender, uint value) public;\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is Ownable, ERC20Basic {\r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint) public balances;\r\n\r\n    // additional variables for use if transaction fees ever became necessary\r\n    uint public basisPointsRate = 0;\r\n    uint public maximumFee = 0;\r\n\r\n    /**\r\n    * @dev Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(!(msg.data.length < size + 4));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\r\n        uint fee = (_value.mul(basisPointsRate)).div(10000);\r\n        if (fee > maximumFee) {\r\n            fee = maximumFee;\r\n        }\r\n        uint sendAmount = _value.sub(fee);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(sendAmount);\r\n        if (fee > 0) {\r\n            balances[owner] = balances[owner].add(fee);\r\n            Transfer(msg.sender, owner, fee);\r\n        }\r\n        Transfer(msg.sender, _to, sendAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is BasicToken, ERC20 {\r\n\r\n    mapping (address => mapping (address => uint)) public allowed;\r\n\r\n    uint public constant MAX_UINT = 2**256 - 1;\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // if (_value > _allowance) throw;\r\n\r\n        uint fee = (_value.mul(basisPointsRate)).div(10000);\r\n        if (fee > maximumFee) {\r\n            fee = maximumFee;\r\n        }\r\n        if (_allowance < MAX_UINT) {\r\n            allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        }\r\n        uint sendAmount = _value.sub(fee);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(sendAmount);\r\n        if (fee > 0) {\r\n            balances[owner] = balances[owner].add(fee);\r\n            Transfer(_from, owner, fee);\r\n        }\r\n        Transfer(_from, _to, sendAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\ncontract BlackList is Ownable, BasicToken {\r\n\r\n    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded Tether) ///////\r\n    function getBlackListStatus(address _maker) external constant returns (bool) {\r\n        return isBlackListed[_maker];\r\n    }\r\n\r\n    function getOwner() external constant returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    mapping (address => bool) public isBlackListed;\r\n\r\n    function addBlackList (address _evilUser) public onlyOwner {\r\n        isBlackListed[_evilUser] = true;\r\n        AddedBlackList(_evilUser);\r\n    }\r\n\r\n    function removeBlackList (address _clearedUser) public onlyOwner {\r\n        isBlackListed[_clearedUser] = false;\r\n        RemovedBlackList(_clearedUser);\r\n    }\r\n\r\n    function destroyBlackFunds (address _blackListedUser) public onlyOwner {\r\n        require(isBlackListed[_blackListedUser]);\r\n        uint dirtyFunds = balanceOf(_blackListedUser);\r\n        balances[_blackListedUser] = 0;\r\n        _totalSupply -= dirtyFunds;\r\n        DestroyedBlackFunds(_blackListedUser, dirtyFunds);\r\n    }\r\n\r\n    event DestroyedBlackFunds(address _blackListedUser, uint _balance);\r\n\r\n    event AddedBlackList(address _user);\r\n\r\n    event RemovedBlackList(address _user);\r\n\r\n}\r\n\r\ncontract UpgradedStandardToken is StandardToken{\r\n    // those methods are called by the legacy contract\r\n    // and they must ensure msg.sender to be the contract address\r\n    function transferByLegacy(address from, address to, uint value) public;\r\n    function transferFromByLegacy(address sender, address from, address spender, uint value) public;\r\n    function approveByLegacy(address from, address spender, uint value) public;\r\n}\r\n\r\ncontract TetherToken is Pausable, StandardToken, BlackList {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimals;\r\n    address public upgradedAddress;\r\n    bool public deprecated;\r\n\r\n    //  The contract can be initialized with a number of tokens\r\n    //  All the tokens are deposited to the owner address\r\n    //\r\n    // @param _balance Initial supply of the contract\r\n    // @param _name Token Name\r\n    // @param _symbol Token symbol\r\n    // @param _decimals Token decimals\r\n    function TetherToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\r\n        _totalSupply = _initialSupply;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        balances[owner] = _initialSupply;\r\n        deprecated = false;\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function transfer(address _to, uint _value) public whenNotPaused {\r\n        require(!isBlackListed[msg.sender]);\r\n        if (deprecated) {\r\n            return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);\r\n        } else {\r\n            return super.transfer(_to, _value);\r\n        }\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {\r\n        require(!isBlackListed[_from]);\r\n        if (deprecated) {\r\n            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);\r\n        } else {\r\n            return super.transferFrom(_from, _to, _value);\r\n        }\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function balanceOf(address who) public constant returns (uint) {\r\n        if (deprecated) {\r\n            return UpgradedStandardToken(upgradedAddress).balanceOf(who);\r\n        } else {\r\n            return super.balanceOf(who);\r\n        }\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\r\n        if (deprecated) {\r\n            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);\r\n        } else {\r\n            return super.approve(_spender, _value);\r\n        }\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        if (deprecated) {\r\n            return StandardToken(upgradedAddress).allowance(_owner, _spender);\r\n        } else {\r\n            return super.allowance(_owner, _spender);\r\n        }\r\n    }\r\n\r\n    // deprecate current contract in favour of a new one\r\n    function deprecate(address _upgradedAddress) public onlyOwner {\r\n        deprecated = true;\r\n        upgradedAddress = _upgradedAddress;\r\n        Deprecate(_upgradedAddress);\r\n    }\r\n\r\n    // deprecate current contract if favour of a new one\r\n    function totalSupply() public constant returns (uint) {\r\n        if (deprecated) {\r\n            return StandardToken(upgradedAddress).totalSupply();\r\n        } else {\r\n            return _totalSupply;\r\n        }\r\n    }\r\n\r\n    // Issue a new amount of tokens\r\n    // these tokens are deposited into the owner address\r\n    //\r\n    // @param _amount Number of tokens to be issued\r\n    function issue(uint amount) public onlyOwner {\r\n        require(_totalSupply + amount > _totalSupply);\r\n        require(balances[owner] + amount > balances[owner]);\r\n\r\n        balances[owner] += amount;\r\n        _totalSupply += amount;\r\n        Issue(amount);\r\n    }\r\n\r\n    // Redeem tokens.\r\n    // These tokens are withdrawn from the owner address\r\n    // if the balance must be enough to cover the redeem\r\n    // or the call will fail.\r\n    // @param _amount Number of tokens to be issued\r\n    function redeem(uint amount) public onlyOwner {\r\n        require(_totalSupply >= amount);\r\n        require(balances[owner] >= amount);\r\n\r\n        _totalSupply -= amount;\r\n        balances[owner] -= amount;\r\n        Redeem(amount);\r\n    }\r\n\r\n    function setParams(uint newBasisPoints, uint newMaxFee) public onlyOwner {\r\n        // Ensure transparency by hardcoding limit beyond which fees can never be added\r\n        require(newBasisPoints < 20);\r\n        require(newMaxFee < 50);\r\n\r\n        basisPointsRate = newBasisPoints;\r\n        maximumFee = newMaxFee.mul(10**decimals);\r\n\r\n        Params(basisPointsRate, maximumFee);\r\n    }\r\n\r\n    // Called when new token are issued\r\n    event Issue(uint amount);\r\n\r\n    // Called when tokens are redeemed\r\n    event Redeem(uint amount);\r\n\r\n    // Called when contract is deprecated\r\n    event Deprecate(address newAddress);\r\n\r\n    // Called if contract ever adds fees\r\n    event Params(uint feeBasisPoints, uint maxFee);\r\n}\r\n\r\n\r\n\r\ncontract PhoenixTiger {\r\n    TetherToken tether;\r\n    \r\n    /*-----------Public Variables---------------\r\n    -----------------------------------*/\r\n    address public owner;\r\n    uint public totalGpv;\r\n    uint public lastuid;\r\n    uint[6] private poolEli = [uint(100000000000), 1000000000000, 250000000000, 100000000000, 100000000000, 1000000000000];\r\n    //poolEli[6] : 0 - orgEli; 1 - millEli; 2- gloEli; 3- countEli; 4 - orgDownEli; 5 - millDownEli \r\n    \r\n    /*-----------Private Varibales---------------\r\n    -----------------------------------*/\r\n    uint private total_packs = 11;\r\n    uint private totalcountry = 200;\r\n    uint private countrycommissionprice = 2;\r\n    uint private gloComPrice = 1;\r\n    uint private milComPrice = 1;\r\n    uint private orgComPrice = 1;\r\n    address private expenseAddress;\r\n    address[] private orgPool;\r\n    address[] private milPool;\r\n    address[] private gloPool; \r\n    \r\n    /*-----------Mapping---------------\r\n    -----------------------------------*/\r\n    \r\n    mapping(address => User) public users;\r\n    mapping(address => bool) public userExist;\r\n    mapping(uint => uint) public totalCountryGpv;\r\n    mapping(address => uint[]) private userPackages;\r\n    mapping(uint=>address[]) private countrypool;\r\n    mapping(uint=>address[]) private countEliPool;\r\n    mapping(address => bool) public orgpool;\r\n    mapping(address=> bool) public millpool;\r\n    mapping(address => bool) public globalpool;\r\n    mapping(address=>address[]) public userDownlink;\r\n    mapping(address => bool) public isRegistrar;\r\n    mapping(address=> uint) public userLockTime;\r\n    mapping(address =>bool) public isCountryEli;    \r\n    mapping(uint => address) public useridmap;\r\n    \r\n    /*-----------Arrays--------------\r\n    -----------------------------------0x0000000000000000000000000000000000000000*/\r\n    \r\n    uint[12] public Packs;\r\n    \r\n    /*-----------enums---------------\r\n    -----------------------------------*/\r\n    enum Status {CREATED, ACTIVE}\r\n\r\n    /*----------Modifier-------------\r\n    -----------------------------------*/\r\n    modifier onlyOwner(){\r\n      require(msg.sender == owner,\"only owner\");\r\n      _;\r\n    }\r\n\r\n    /*-----------Structures---------------\r\n    -----------------------------------*/\r\n    struct User {\r\n    \tuint userid;\r\n        uint countrycode;\r\n        uint pbalance;\r\n        uint rbalance;\r\n        uint rank;\r\n        uint gHeight;\r\n        uint gpv;\r\n        uint[2] lastBuy;   //0- time ; 1- pack;\r\n        uint[7] earnings;  // 0 - team earnings; 1 - family earnings; 2 - match earnings; 3 - country earnings, 4- organisation, 5 - global, 6 - millionaire\r\n        bool isbonus;\r\n        bool isKyc;\r\n        address teamaddress;\r\n        address familyaddress;\r\n        Status status;\r\n        uint traininglevel;\r\n        mapping(uint=>TrainingLevel) trainingpackage;\r\n    }\r\n    \r\n    struct TrainingLevel {\r\n        uint package;\r\n        bool purchased;\r\n\r\n    }\r\n    /*-----------EVENTS---------------\r\n    -----------------------------------*/\r\n    event Registration(\r\n                \r\n                address useraddress,\r\n                uint countrycode,\r\n                uint gHeight,\r\n                address teamaddress\r\n    );\r\n\r\n    event newPackage (\r\n                address useraddress,\r\n                uint pack\r\n            );\r\n\r\n    event RaiseTrainingLevel(\r\n            \r\n                address useraddress,\r\n                uint tlevel,\r\n                uint rank\r\n            );\r\n\r\n    event RedeemEarning(\r\n            \r\n                address useraddress,\r\n                uint pbalance,\r\n                uint rbalance\r\n            );\r\n            \r\n    event LockTimeUpdate(\r\n                address useraddress,\r\n                uint locktime\r\n            );\r\n \r\n    event KycDone(\r\n                address useraddress\r\n            );\r\n            \r\n    /*-----------Constructor---------------\r\n    -----------------------------------*/\r\n\r\n    constructor(address ownerAddress,address _expenseAddress) public {\r\n\r\n        tether = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n        Packs = [0,500, 1000, 2000, 5000, 10000, 20000,50000,100000,250000, 500000, 1000000];\r\n\r\n        owner = ownerAddress;\r\n        expenseAddress = _expenseAddress;\r\n        isRegistrar[owner] = true;\r\n  \r\n        address master = 0x3417F6448eeDbf8737af2cef9Ca2d2dd2Ee3d543;\r\n        \r\n        userExist[master] = true;\r\n        User memory user;\r\n        user= User({\r\n            userid : 1000001,\r\n            teamaddress : address(0),\r\n            countrycode: 165,\r\n            isbonus : false,\r\n            familyaddress : address(0),\r\n            pbalance: 0,\r\n            rbalance : 0,\r\n            rank : 0,\r\n            gHeight: 1,\r\n            status : Status.ACTIVE,\r\n            traininglevel : 0,\r\n            gpv : 0,\r\n            isKyc:false,\r\n            lastBuy:[uint(0),0],\r\n            earnings:[uint(0),0,0,0,0,0,0]\r\n        });\r\n        users[master] = user; //Master\r\n        lastuid = 1000001;\r\n        useridmap[lastuid] = master;\r\n\r\n    }\r\n\r\n    /*-----------Main functions---------------\r\n    -------------------------------------------*/\r\n    \r\n    function superRegister(address useraddress,address referrerAddress,uint usercountry,uint pack, uint rbal, uint gbv, uint[7] userEarnings, uint[2] lastBuy, uint ltime) external onlyOwner {\r\n        require(!isUserExists(useraddress) && isUserExists(referrerAddress), \"user exists\");\r\n        require(checkCountry(usercountry), \"country must be from 0 to 200\");\r\n        require(isAddress(useraddress), \"cannot be a contract\");\r\n        totalCountryGpv[usercountry] += Packs[pack]*1000000;\r\n        totalGpv += Packs[pack]*1000000;\r\n       \r\n        userExist[useraddress] = true;\r\n        User memory user = User({\r\n\t        userid : ++lastuid,\r\n            teamaddress : referrerAddress,\r\n            countrycode: usercountry,\r\n            isbonus : true,\r\n            familyaddress : getFamilyFromReferral(referrerAddress),\r\n            pbalance: 0,\r\n            rbalance : rbal,\r\n            rank : pack,\r\n            gHeight: users[referrerAddress].gHeight+1,\r\n            status : Status.ACTIVE,\r\n            gpv : gbv,\r\n            isKyc : false,\r\n            lastBuy:[uint(lastBuy[0]),lastBuy[1]],\r\n            traininglevel :0,\r\n            earnings: [uint(userEarnings[0]),userEarnings[1],userEarnings[2],userEarnings[3],userEarnings[4],userEarnings[5],userEarnings[6]]\r\n        });\r\n    \tusers[useraddress] = user;\r\n    \tuseridmap[lastuid] = useraddress;\r\n        if(lastBuy[1]==0){\r\n            users[useraddress].status = Status.CREATED;\r\n            users[useraddress].isbonus = false;\r\n        }\r\n        \r\n        isCountryEli[useraddress] = false;\r\n        globalpool[useraddress] = false;\r\n        millpool[useraddress] = false;\r\n        orgpool[useraddress] = false;\r\n        \r\n        users[useraddress].trainingpackage[pack].package=pack;\r\n        users[useraddress].traininglevel=0;\r\n        users[useraddress].trainingpackage[pack].purchased=true;     \r\n      \r\n        userLockTime[useraddress] = ltime;\r\n        userPackages[useraddress].push(pack);\r\n        countrypool[usercountry].push(useraddress);\r\n        userDownlink[referrerAddress].push(useraddress);\r\n        \r\n        /*-------------------Emitter--------------*/\r\n        emit Registration(\r\n            useraddress,\r\n            users[useraddress].countrycode,\r\n            users[useraddress].gHeight,\r\n            users[useraddress].teamaddress\r\n        );        \r\n    }\r\n    \r\n    function registration(address useraddress, address referrerAddress, uint usercountry,uint locktime) external {\r\n        require(!isUserExists(useraddress) && isUserExists(referrerAddress), \"user exists\");\r\n        require(referrerAddress != address(0),\"referrerAddress cannot be zero address\");\r\n        require(checkCountry(usercountry), \"country must be from 0 to 200\");\r\n        require(isAddress(useraddress) && isAddress(referrerAddress), \"cannot be a contract\");\r\n        \r\n        address teamaddress = referrerAddress;\r\n    \r\n        userExist[useraddress] = true;\r\n        User memory user = User({\r\n            userid : ++lastuid,\r\n            teamaddress : teamaddress,\r\n            // packlevel : 0,\r\n            countrycode: usercountry,\r\n            isbonus : false,\r\n            familyaddress : getFamilyFromReferral(teamaddress),\r\n            pbalance: 0,\r\n            rbalance : 0,\r\n            rank : 0,\r\n            gHeight: getHeight(teamaddress),\r\n            status : Status.CREATED,\r\n            gpv :0,\r\n            isKyc : false,\r\n            lastBuy:[uint(0),0],\r\n            traininglevel :0,\r\n            earnings:[uint(0),0,0,0,0,0,0]\r\n        });\r\n        users[useraddress] = user;\r\n        useridmap[lastuid] = useraddress;\r\n        userLockTime[useraddress] = locktime;\r\n        countrypool[usercountry].push(useraddress);\r\n        userDownlink[teamaddress].push(useraddress);\r\n\r\n        /*-------------------Emitter--------------*/\r\n        emit Registration(\r\n\t    useraddress,\r\n            users[useraddress].countrycode,\r\n            users[useraddress].gHeight,\r\n            users[useraddress].teamaddress\r\n        );\r\n\r\n    }\r\n\r\n    function buypackage( uint pack ,uint amount) external {\r\n        \r\n        uint _amount = amount/1000000;\r\n        require(isUserExists(msg.sender), \"user not exists\");\r\n        require(pack > users[msg.sender].lastBuy[1] && pack < total_packs && pack>0, \"check pack purchase\");\r\n        require(Packs[pack]<= _amount, \"invalid amount of wholesale package purchase\");\r\n        require(tether.allowance(msg.sender,address(this)) >= amount,\"set allowance\");\r\n        \r\n        if(discountValid(msg.sender,pack)){\r\n            uint newAmount = (Packs[pack] - Packs[users[msg.sender].lastBuy[1]])*1000000;\r\n            tether.transferFrom(msg.sender,address(this),newAmount); \r\n            disburse(msg.sender, newAmount, pack);            \r\n        }else{\r\n            tether.transferFrom(msg.sender,address(this),amount); \r\n            disburse(msg.sender, amount, pack);\r\n        }\r\n        \r\n        userPackages[msg.sender].push(pack);\r\n        users[msg.sender].lastBuy = [now,pack];\r\n        emit newPackage (\r\n          msg.sender,\r\n          pack\r\n        );\r\n    }\r\n    \r\n    function raiseTrainingLevel(address [] useraddress, uint[] pack) external  payable {\r\n        require(isRegistrar[msg.sender],\"Not a registrar\");\r\n        require(useraddress.length == pack.length,\"useraddress length not equal to packs length\");\r\n       for(uint i=0;i<useraddress.length;i++){\r\n        require(isUserExists(useraddress[i]), \"user not exists\");\r\n        require(total_packs >= pack[i], \"invalid pack\");\r\n\r\n        require(users[useraddress[i]].trainingpackage[pack[i]].purchased, \"Pack is not purchased.\");\r\n        users[useraddress[i]].isbonus = true;\r\n        users[useraddress[i]].traininglevel= ++users[useraddress[i]].traininglevel;\r\n\r\n        emit RaiseTrainingLevel(\r\n            \r\n            useraddress[i],\r\n            users[useraddress[i]].traininglevel,\r\n            users[useraddress[i]].rank\r\n        );   \r\n       }\r\n    }\r\n\r\n    function redeemEarning(address useraddress) public{\r\n        require(isUserExists(useraddress), \"user not exists\");\r\n        require(users[msg.sender].pbalance>0, \"insufficient balance\");\r\n        tether.transfer(useraddress,users[useraddress].pbalance);\r\n        users[useraddress].rbalance = users[useraddress].rbalance + users[useraddress].pbalance;\r\n        users[useraddress].pbalance = 0;\r\n\r\n        emit RedeemEarning(\r\n            useraddress,\r\n            users[useraddress].pbalance,\r\n            users[useraddress].rbalance\r\n        );\r\n    }\r\n\r\n    /*-----------non-payable functions---------------\r\n    -----------------------------------*/\r\n\r\n    function addRegistrar(address registrar) public onlyOwner{\r\n        isRegistrar[registrar] = true;\r\n    }\r\n    \r\n    function removeRegistrar(address registrar) public onlyOwner{\r\n        isRegistrar[registrar] = false;\r\n    } \r\n    \r\n    function updateLockTime(address useraddress ,uint locktime ) public{\r\n        require(useraddress==msg.sender);\r\n        require(locktime> 6,\"must be greater than 6 months\");\r\n        require(isUserExists(useraddress),\"user not exist\");\r\n        userLockTime[useraddress] = locktime;\r\n        \r\n        emit LockTimeUpdate(\r\n            useraddress, \r\n            locktime\r\n        );\r\n    }\r\n\r\n    function discountValid(address useraddress,uint pack) public view returns(bool _bool){\r\n       uint  _lastPack =  users[useraddress].lastBuy[1] ;\r\n       uint  _lastTime =  users[useraddress].lastBuy[0];\r\n       \r\n       if(_lastPack==0 || pack<= _lastPack || now - _lastTime >= 30 days){\r\n           return false;\r\n       }else{\r\n           return true;\r\n       }\r\n    }\r\n    \r\n    function getEarnings(address useraddress) public view returns(uint[7] memory _earnings){\r\n        return users[useraddress].earnings;\r\n    }\r\n    \r\n    function getidfromaddress(address useraddress) public view returns(uint userID){\r\n        return users[useraddress].userid;\r\n    }\r\n    \r\n    function getLastBuyPack(address useraddress) public view returns(uint[2] memory _lastpack){\r\n        return users[useraddress].lastBuy;\r\n    }\r\n    \r\n    function getCountryUsersCount(uint country) public view returns (uint count){\r\n        return countrypool[country].length;\r\n    }\r\n\r\n    function getTrainingLevel(address useraddress, uint pack) public view returns (uint tlevel, uint upack) {\r\n        return (users[useraddress].traininglevel, pack);\r\n\r\n    }\r\n\r\n    function getUserDownLink(address useraddress) public view  returns (address[] memory addr) {\r\n        if(userDownlink[useraddress].length != 0){\r\n            return userDownlink[useraddress];\r\n        }\r\n        else{\r\n            address[] memory pack;\r\n            return pack ;\r\n        }\r\n    }\r\n\r\n    /*-----------Helper functions---------------\r\n    -----------------------------------*/\r\n    \r\n    function getAllPacksofUsers(address useraddress) public view returns(uint[] memory pck) {\r\n        return userPackages[useraddress];\r\n    }\r\n\r\n    function getAllLevelsofUsers(address useraddress,uint pack) public view returns(uint lvl) {\r\n        \r\n        if(users[useraddress].trainingpackage[pack].purchased){\r\n            return users[useraddress].traininglevel;\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n\r\n    function isAddress(address _address) private view returns (bool value){\r\n        uint32 size;\r\n        assembly {\r\n                size := extcodesize(_address)\r\n        }\r\n        return(size==0);\r\n    }\r\n\r\n    function isUserExists(address user) public view returns (bool) {\r\n        return userExist[user];\r\n    }\r\n\r\n    function checkCountry(uint country) private pure returns (bool) {\r\n        return (country <= 200);\r\n    }\r\n\r\n    function getFamilyFromReferral(address referrerAddres) private view returns (address addr) {\r\n        if (users[referrerAddres].teamaddress != address(0)){\r\n            return users[referrerAddres].teamaddress;\r\n        }\r\n        else {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    function getFamilyFromUser(address useraddress) private view returns (address addr) {\r\n        if (users[users[useraddress].teamaddress].teamaddress != address(0)){\r\n            return users[users[useraddress].teamaddress].teamaddress;\r\n        }\r\n        else {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    function getTeam(address useraddress) private view returns (address addr) {\r\n        return users[useraddress].teamaddress;\r\n    }\r\n\r\n    function getGminus2(address useraddress) private view returns (address gaddr) {\r\n\r\n        if(users[useraddress].teamaddress == address(0)){\r\n            return address(0);\r\n        }\r\n        else{\r\n            return users[users[useraddress].teamaddress].familyaddress;\r\n        }\r\n    }\r\n    \r\n    function getHeight(address referrerAddres) private view returns (uint ghgt) {\r\n        return users[referrerAddres].gHeight +1;\r\n    }\r\n\r\n    function disburse(address useraddress, uint amount, uint pack) private {\r\n\r\n      uint leftamount;\r\n      uint disbursedamount;\r\n\r\n      //disburse 10% to the team\r\n      disbursedamount = disburseTeam(useraddress, amount);\r\n      leftamount = amount - disbursedamount;\r\n\r\n      //disburse 3% to family\r\n      disbursedamount = disburseFamily(useraddress,  amount);\r\n      leftamount = leftamount - disbursedamount;\r\n\r\n      //disbruse 4% to match and +1% +2% +3% to higher rank users\r\n      disbursedamount = disburseMatch(useraddress,amount);\r\n      leftamount = leftamount - disbursedamount;\r\n\r\n      //disburse 2% to country\r\n      disbursedamount = disburseCountryPool(useraddress, amount);\r\n      leftamount = leftamount - disbursedamount;\r\n\r\n      //disburse 1% to Global\r\n      disbursedamount = disburseOMGPool(useraddress, amount);\r\n      leftamount = leftamount - disbursedamount;\r\n      \r\n      payoutGpv(useraddress,amount);\r\n      tether.transfer(expenseAddress,leftamount);\r\n      /* address(uint160(owner)).transfer(leftamount); */\r\n    \r\n      users[useraddress].status = Status.ACTIVE;\r\n      // users[msg.sender].packlevel = pack;\r\n      users[useraddress].rank = pack;\r\n      // users[msg.sender].trainingpackage[0].traininglevel[pack]=0;\r\n\r\n      users[useraddress].trainingpackage[pack].package=pack;\r\n      users[useraddress].traininglevel=0;\r\n      users[useraddress].trainingpackage[pack].purchased=true;     \r\n    }\r\n\r\n    function disburseTeam(address useraddress, uint amount) private  returns (uint amnt) {\r\n        address teamaddress = getTeam(useraddress);\r\n        if(teamaddress == address(0)){\r\n            return 0;\r\n        }\r\n        else if(users[teamaddress].status == Status.CREATED) {\r\n            return amount;\r\n        }\r\n        else{\r\n            users[teamaddress].pbalance = users[teamaddress].pbalance+ (amount * 10)/100;\r\n            users[teamaddress].earnings[0] += (amount * 10)/100;\r\n            // gpvUpdater(useraddress,teamaddress);\r\n            return (amount * 10)/100;\r\n        }\r\n    }\r\n\r\n    function disburseFamily(address useraddress, uint amount) private  returns (uint amnt) {\r\n        address familyaddress = getFamilyFromUser(useraddress);\r\n        if(familyaddress != address(0)){\r\n            if(users[familyaddress].status == Status.CREATED){\r\n                return 0;\r\n            }\r\n            else{\r\n                users[familyaddress].pbalance = users[familyaddress].pbalance+ (amount * 30)/1000;\r\n                users[familyaddress].earnings[1] += (amount * 30)/1000;\r\n                \r\n                return (amount * 30)/1000;\r\n            }\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function disburseMatch(address useraddress, uint amount) private  returns (uint amnt) {\r\n        uint commissionamount;\r\n        uint disbursed ;\r\n        uint gold_due;\r\n        uint diamond_due;\r\n        uint plat_due;\r\n        \r\n        address familyaddress = getFamilyFromUser(useraddress);\r\n        if(familyaddress != address(0)){\r\n            users[familyaddress].earnings[2] += (amount * 4)/1000;\r\n            users[familyaddress].pbalance += (amount * 4)/1000;\r\n            disbursed += (amount * 4)/1000;\r\n        }else{\r\n            return 0;\r\n        }\r\n\r\n        address teamaddress = getTeam(familyaddress);\r\n        if(teamaddress != address(0)){\r\n            users[teamaddress].earnings[2] += (amount * 136)/100000;\r\n            users[teamaddress].pbalance += (amount * 136)/100000;\r\n            amount = (amount * 136)/100000;\r\n            disbursed += amount;\r\n        }else{\r\n            return disbursed;\r\n        }\r\n\r\n        address matchaddress = getGminus2(useraddress);\r\n        if(matchaddress==address(0)){\r\n            return disbursed;\r\n        }\r\n        else{\r\n            while(matchaddress != address(0)){\r\n\r\n                if(users[matchaddress].status == Status.CREATED){\r\n                    matchaddress = users[matchaddress].teamaddress;\r\n                }\r\n                else{\r\n                    \r\n                    commissionamount = (amount *4 )/100; //checkmatch = 4%\r\n                    \r\n                    gold_due = gold_due +commissionamount;\r\n                    diamond_due = diamond_due + commissionamount;\r\n                    plat_due = plat_due + commissionamount;\r\n                    \r\n                    if( users[useraddress].trainingpackage[11].purchased){//PlatinumFounder\r\n                        commissionamount += (plat_due*3)/100;\r\n                        plat_due = 0;\r\n                    }\r\n                    else if( users[useraddress].trainingpackage[10].purchased){//DiamondFounder\r\n                        commissionamount += (diamond_due*2)/100;\r\n                        diamond_due = 0;\r\n                    }\r\n                    else if( users[useraddress].trainingpackage[9].purchased ){  // Gold-founder\r\n                        commissionamount += (gold_due)/100;\r\n                        gold_due = 0;\r\n                    }\r\n                 \r\n                    users[matchaddress].pbalance = users[matchaddress].pbalance + commissionamount;\r\n                    users[matchaddress].earnings[2] += commissionamount;\r\n                    matchaddress = users[matchaddress].teamaddress;\r\n                    amount = commissionamount;\r\n                    disbursed = disbursed + amount;\r\n                }\r\n            }\r\n            return disbursed;\r\n        }\r\n    }\r\n\r\n    function disburseCountryPool(address useraddress, uint amount) private  returns (uint amnt) {\r\n        uint country = users[useraddress].countrycode;\r\n        uint disbursed;\r\n\r\n        for(uint i=0; i < countEliPool[country].length && disbursed <= ((amount*2)/100); i++){\r\n                uint gpv = users[countEliPool[country][i]].gpv;\r\n\t\t\t\tuint countDisbursed = (amount * countrycommissionprice*gpv)/(100*totalCountryGpv[users[useraddress].countrycode]);\r\n                users[countEliPool[country][i]].pbalance = users[countEliPool[country][i]].pbalance + countDisbursed;\r\n                users[countEliPool[country][i]].earnings[3] += countDisbursed;\r\n                disbursed = disbursed + countDisbursed;\r\n            }\r\n        \r\n        return disbursed;\r\n    }\r\n\r\n    function disburseOMGPool(address useraddress, uint amount) private  returns (uint amnt) {\r\n        uint disbursed;\r\n\r\n    \tfor(uint i=orgPool.length ; i > 0 ; i--) {\r\n    \t    uint gpvOrg = users[orgPool[i]].gpv;\r\n    \t    users[orgPool[i]].earnings[4] += (amount * orgComPrice *gpvOrg)/(100*totalGpv);\r\n    \t    users[orgPool[i]].pbalance += (amount * orgComPrice *gpvOrg)/(100*totalGpv);\r\n            disbursed += (amount * orgComPrice *gpvOrg)/(100*totalGpv);\r\n    \t}\r\n    \r\n    \tfor( i=milPool.length ; i > 0 ; i--) {\r\n    \t    uint gpvMill = users[milPool[i]].gpv;\r\n    \t    users[milPool[i]].earnings[4] += (amount * milComPrice *gpvMill)/(100*totalGpv);\r\n    \t    users[milPool[i]].pbalance = (amount * milComPrice *gpvMill)/(100*totalGpv);\r\n            disbursed += (amount * milComPrice *gpvMill)/(100*totalGpv);\r\n    \t}\r\n    \r\n    \tfor(i=gloPool.length ; i > 0 ; i--) {\r\n    \t    uint gpvGlo = users[gloPool[i]].gpv;\r\n    \t    users[gloPool[i]].earnings[4] += (amount * gloComPrice *gpvGlo)/(100*totalGpv);\r\n    \t    users[gloPool[i]].pbalance = (amount * gloComPrice *gpvGlo)/(100*totalGpv);\r\n            disbursed += (amount * gloComPrice *gpvGlo)/(100*totalGpv);\r\n    \t}\r\n\r\n\t    return disbursed;\r\n    }\r\n\r\n    function checkPackPurchased(address useraddress, uint pack) public view returns (uint userpack, uint usertraininglevel, bool packpurchased){\r\n        if(users[useraddress].trainingpackage[pack].purchased){\r\n            return (pack, users[useraddress].traininglevel, users[useraddress].trainingpackage[pack].purchased);\r\n        }\r\n    }\r\n\r\n    function payoutGpv(address useraddress,uint amount) private{\r\n\r\n        totalGpv = totalGpv + (amount*(users[useraddress].gHeight-1));  \r\n        totalCountryGpv[users[useraddress].countrycode] = totalCountryGpv[users[useraddress].countrycode] + (amount*users[useraddress].gHeight-1);\r\n        address _Address = users[useraddress].teamaddress;\r\n        for(uint i = users[useraddress].gHeight-1 ; i>0 ;i--){\r\n            users[_Address].gpv += amount;\r\n            _Address = users[_Address].teamaddress;\r\n            \r\n            if(users[_Address].gpv > poolEli[0]  && !orgpool[_Address] && checkEligible(_Address,poolEli[4])){\r\n                orgpool[_Address] = true;\r\n\t\t        orgPool.push(_Address);\r\n            }\r\n            if(users[_Address].gpv > poolEli[1] && !millpool[_Address] && checkEligible(_Address,poolEli[5])){\r\n                millpool[_Address] = true;\r\n\t\t        milPool.push(_Address);\r\n            }\r\n            if(users[_Address].gpv > poolEli[2] && !globalpool[_Address]){\r\n                globalpool[_Address] = true;\r\n\t\t        milPool.push(_Address);\r\n            }\r\n            if(users[_Address].gpv > poolEli[3] && !isCountryEli[_Address] && users[_Address].isKyc == true){\r\n                isCountryEli[_Address] =true;\r\n\t\t        countEliPool[users[useraddress].countrycode].push(_Address);\r\n\r\n            }\r\n         }\r\n    }\r\n    \r\n    function checkEligible(address useraddress,uint amount) private view returns(bool){\r\n        uint a = 0 ;\r\n        address [] memory _addresses = getUserDownLink(useraddress);\r\n        if(_addresses.length < 5){\r\n                return false;\r\n        }\r\n        for(uint i =0;i< _addresses.length;i++){\r\n            if(users[_addresses[i]].gpv > amount){\r\n                a += 1;\r\n             }\r\n            if(a>=5){\r\n              return true;\r\n            }\r\n        }\r\n        return false;\r\n        \r\n    }\r\n    \r\n    function setKyc(address useraddress) public onlyOwner{\r\n        users[useraddress].isKyc = true;\r\n        \r\n        emit KycDone(\r\n            useraddress\r\n            );\r\n    }\r\n   \r\n    function updateEligibilty(uint _orgEli,uint _millEli,uint _gloEli,uint _countEli,uint _orgDownEli,uint _millDownEli ) public onlyOwner{\r\n        uint i;\r\n        uint j;\r\n        poolEli[5] = _millDownEli;\r\n        poolEli[4] = _orgDownEli;\r\n        gloPool.length = 0;\r\n        milPool.length = 0;\r\n        orgPool.length = 0; \r\n        if(poolEli[0] != _orgEli){\r\n           poolEli[0] = _orgEli;\r\n           for(  i= 0; i<totalcountry;i++){\r\n               for( j=0; j<countrypool[i].length; j++){\r\n                   orgpool[countrypool[i][j]] = false;\r\n                   if(checkEligible(countrypool[i][j],poolEli[0])){\r\n                       orgpool[countrypool[i][j]] = true;\r\n                       orgPool.push(countrypool[i][j]);\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        if(poolEli[1] != _millEli){\r\n            poolEli[1] = _millEli;\r\n            for(  i= 0; i<totalcountry;i++){\r\n                for( j=0; j<countrypool[i].length; j++){\r\n                    millpool[countrypool[i][j]] = false;\r\n                    if(checkEligible(countrypool[i][j],poolEli[0])){\r\n                        millpool[countrypool[i][j]] = true;\r\n                        milPool.push(countrypool[i][j]);\r\n                    } \r\n                }\r\n            }\r\n        }     \r\n        if(poolEli[2] != _gloEli){\r\n            poolEli[2] = _gloEli;\r\n            for(  i= 0; i<totalcountry;i++){\r\n                for( j=0; j<countrypool[i].length; j++){\r\n                    globalpool[countrypool[i][j]] = false;\r\n                    if(users[countrypool[i][j]].gpv > poolEli[2]){\r\n                       globalpool[countrypool[i][j]] = true;\r\n                       gloPool.push(countrypool[i][j]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if(poolEli[3] != _countEli){\r\n            poolEli[3] = _countEli;\r\n            for(  i= 0; i<totalcountry;i++){\r\n                countEliPool[i].length = 0;\r\n                for( j=0; j<countrypool[i].length; j++){\r\n                    isCountryEli[countrypool[i][j]] = false;\r\n                    if(users[countrypool[i][j]].gpv > poolEli[3] && users[countrypool[i][j]].isKyc == true){\r\n                        isCountryEli[countrypool[i][j]] =true;\r\n                        countEliPool[users[countrypool[i][j]].countrycode].push(countrypool[i][j]);\r\n                    }               \r\n                }\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Packs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"},{\"name\":\"pack\",\"type\":\"uint256\"}],\"name\":\"getAllLevelsofUsers\",\"outputs\":[{\"name\":\"lvl\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"}],\"name\":\"redeemEarning\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"}],\"name\":\"getEarnings\",\"outputs\":[{\"name\":\"_earnings\",\"type\":\"uint256[7]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"},{\"name\":\"locktime\",\"type\":\"uint256\"}],\"name\":\"updateLockTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"country\",\"type\":\"uint256\"}],\"name\":\"getCountryUsersCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"}],\"name\":\"getidfromaddress\",\"outputs\":[{\"name\":\"userID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"},{\"name\":\"referrerAddress\",\"type\":\"address\"},{\"name\":\"usercountry\",\"type\":\"uint256\"},{\"name\":\"locktime\",\"type\":\"uint256\"}],\"name\":\"registration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"useridmap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"}],\"name\":\"getLastBuyPack\",\"outputs\":[{\"name\":\"_lastpack\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"},{\"name\":\"pack\",\"type\":\"uint256\"}],\"name\":\"getTrainingLevel\",\"outputs\":[{\"name\":\"tlevel\",\"type\":\"uint256\"},{\"name\":\"upack\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalCountryGpv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"},{\"name\":\"pack\",\"type\":\"uint256\"}],\"name\":\"discountValid\",\"outputs\":[{\"name\":\"_bool\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"}],\"name\":\"getAllPacksofUsers\",\"outputs\":[{\"name\":\"pck\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"},{\"name\":\"pack\",\"type\":\"uint256\"}],\"name\":\"checkPackPurchased\",\"outputs\":[{\"name\":\"userpack\",\"type\":\"uint256\"},{\"name\":\"usertraininglevel\",\"type\":\"uint256\"},{\"name\":\"packpurchased\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orgEli\",\"type\":\"uint256\"},{\"name\":\"_millEli\",\"type\":\"uint256\"},{\"name\":\"_gloEli\",\"type\":\"uint256\"},{\"name\":\"_countEli\",\"type\":\"uint256\"},{\"name\":\"_orgDownEli\",\"type\":\"uint256\"},{\"name\":\"_millDownEli\",\"type\":\"uint256\"}],\"name\":\"updateEligibilty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCountryEli\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pack\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buypackage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"},{\"name\":\"referrerAddress\",\"type\":\"address\"},{\"name\":\"usercountry\",\"type\":\"uint256\"},{\"name\":\"pack\",\"type\":\"uint256\"},{\"name\":\"rbal\",\"type\":\"uint256\"},{\"name\":\"gbv\",\"type\":\"uint256\"},{\"name\":\"userEarnings\",\"type\":\"uint256[7]\"},{\"name\":\"lastBuy\",\"type\":\"uint256[2]\"},{\"name\":\"ltime\",\"type\":\"uint256\"}],\"name\":\"superRegister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"globalpool\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"}],\"name\":\"setKyc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"millpool\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"userid\",\"type\":\"uint256\"},{\"name\":\"countrycode\",\"type\":\"uint256\"},{\"name\":\"pbalance\",\"type\":\"uint256\"},{\"name\":\"rbalance\",\"type\":\"uint256\"},{\"name\":\"rank\",\"type\":\"uint256\"},{\"name\":\"gHeight\",\"type\":\"uint256\"},{\"name\":\"gpv\",\"type\":\"uint256\"},{\"name\":\"isbonus\",\"type\":\"bool\"},{\"name\":\"isKyc\",\"type\":\"bool\"},{\"name\":\"teamaddress\",\"type\":\"address\"},{\"name\":\"familyaddress\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"traininglevel\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"registrar\",\"type\":\"address\"}],\"name\":\"addRegistrar\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastuid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"registrar\",\"type\":\"address\"}],\"name\":\"removeRegistrar\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"orgpool\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address[]\"},{\"name\":\"pack\",\"type\":\"uint256[]\"}],\"name\":\"raiseTrainingLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userDownlink\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRegistrar\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGpv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"useraddress\",\"type\":\"address\"}],\"name\":\"getUserDownLink\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ownerAddress\",\"type\":\"address\"},{\"name\":\"_expenseAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"useraddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"countrycode\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gHeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"teamaddress\",\"type\":\"address\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"useraddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pack\",\"type\":\"uint256\"}],\"name\":\"newPackage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"useraddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tlevel\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint256\"}],\"name\":\"RaiseTrainingLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"useraddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pbalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rbalance\",\"type\":\"uint256\"}],\"name\":\"RedeemEarning\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"useraddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"locktime\",\"type\":\"uint256\"}],\"name\":\"LockTimeUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"useraddress\",\"type\":\"address\"}],\"name\":\"KycDone\",\"type\":\"event\"}]","ContractName":"PhoenixTiger","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000756018b28ac84029630a89f65d275518e79e8190000000000000000000000000865ced03955296d4489782ef7393f1364e28dec6","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://719648f2264a0057f7206f2a8870734b9bcdd2878f35e0e708e3c894c8f98056"}]}