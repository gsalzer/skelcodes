{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 { // brief interface for moloch erc20 token txs\r\n    function balanceOf(address who) external view returns (uint256);\r\n    \r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface IWETH { // brief interface for ether wrapping contract \r\n    function deposit() payable external;\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n        \r\n        _;\r\n        \r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract Moloch is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    /***************\r\n    GLOBAL CONSTANTS\r\n    ***************/\r\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\r\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\r\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\r\n    uint256 public proposalDeposit; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\r\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\r\n    uint256 public processingReward; // default = 0.1 - amount of ETH to give to whoever processes a proposal\r\n    uint256 public summoningRate; // rate to convert into shares during summoning time (default = 10000000000000000000 wei amt. // 100 wETH => 10 shares)\r\n    uint256 public summoningTermination; // termination time for summoning tribute (can be restarted via governance param adjustments)\r\n    uint256 public summoningTime; // needed to determine the current period\r\n\r\n    address public depositToken; // deposit token contract reference; default = wETH\r\n    address public wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // wrapping contract for raw payable ether\r\n\r\n    // HARD-CODED LIMITS\r\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\r\n    // with periods or shares, yet big enough to not limit reasonable use cases.\r\n    uint256 constant MAX_INPUT = 10**18; // maximum bound for reasonable limits\r\n    uint256 constant MAX_TOKEN_WHITELIST_COUNT = 400; // maximum number of whitelisted tokens\r\n    uint256 constant MAX_TOKEN_GUILDBANK_COUNT = 200; // maximum number of tokens with non-zero balance in guildbank\r\n\r\n    // ***************\r\n    // EVENTS\r\n    // ***************\r\n    event SummonComplete(address[] indexed summoners, address[] tokens, uint256 summoningTime, uint256 periodDuration, uint256 votingPeriodLength, uint256 gracePeriodLength, uint256 proposalDeposit, uint256 dilutionBound, uint256 processingReward, uint256 summonerStake, uint256 summoningDeposit, uint256 summoningRate, uint256 summoningTermination);\r\n    event MakeSummoningTribute(address indexed memberAddress, uint256 indexed tribute, uint256 indexed shares);\r\n    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, bytes32 details, bool[6] flags, uint256 proposalId, address indexed delegateKey, address indexed memberAddress);\r\n    event SponsorProposal(address indexed delegateKey, address indexed memberAddress, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);\r\n    event SubmitVote(uint256 proposalId, uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\r\n    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessWhitelistProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessGuildKickProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);\r\n    event TokensCollected(address indexed token, uint256 amountToCollect);\r\n    event CancelProposal(uint256 indexed proposalId, address applicantAddress);\r\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\r\n    event Withdraw(address indexed memberAddress, address token, uint256 amount);\r\n\r\n    // *******************\r\n    // INTERNAL ACCOUNTING\r\n    // *******************\r\n    uint256 public proposalCount; // total proposals submitted\r\n    uint256 public totalShares; // total shares across all members\r\n    uint256 public totalLoot; // total loot across all members\r\n    uint256 public totalGuildBankTokens; // total tokens with non-zero balance in guild bank\r\n\r\n    address public constant GUILD = address(0xdead);\r\n    address public constant ESCROW = address(0xbeef);\r\n    address public constant TOTAL = address(0xbabe);\r\n    mapping(address => mapping(address => uint256)) public userTokenBalances; // userTokenBalances[userAddress][tokenAddress]\r\n\r\n    enum Vote {\r\n        Null, // default value, counted as abstention\r\n        Yes,\r\n        No\r\n    }\r\n\r\n    struct Member {\r\n        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated\r\n        uint256 shares; // the # of voting shares assigned to this member\r\n        uint256 loot; // the loot amount available to this member (combined with shares on ragequit)\r\n        bool exists; // always true once a member has been created\r\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\r\n        uint256 jailed; // set to proposalIndex of a passing guild kick proposal for this member, prevents voting on and sponsoring proposals\r\n    }\r\n\r\n    struct Proposal {\r\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as guild kick target for gkick proposals)\r\n        address proposer; // the account that submitted the proposal (can be non-member)\r\n        address sponsor; // the member that sponsored the proposal (moving it into the queue)\r\n        uint256 sharesRequested; // the # of shares the applicant is requesting\r\n        uint256 lootRequested; // the amount of loot the applicant is requesting\r\n        uint256 tributeOffered; // amount of tokens offered as tribute\r\n        address tributeToken; // tribute token contract reference\r\n        uint256 paymentRequested; // amount of tokens requested as payment\r\n        address paymentToken; // payment token contract reference\r\n        uint256 startingPeriod; // the period in which voting can start for this proposal\r\n        uint256 yesVotes; // the total number of YES votes for this proposal\r\n        uint256 noVotes; // the total number of NO votes for this proposal\r\n        bool[6] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n        bytes32 details; // proposal details to add context for members \r\n        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\r\n        mapping(address => Vote) votesByMember; // the votes on this proposal by each member\r\n    }\r\n\r\n    mapping(address => bool) public tokenWhitelist;\r\n    address[] public approvedTokens;\r\n\r\n    mapping(address => bool) public proposedToWhitelist;\r\n    mapping(address => bool) public proposedToKick;\r\n\r\n    mapping(address => Member) public members;\r\n    mapping(address => address) public memberAddressByDelegateKey;\r\n\r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    uint256[] public proposalQueue;\r\n\r\n    modifier onlyMember {\r\n        require(members[msg.sender].shares > 0 || members[msg.sender].loot > 0, \"not member\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyShareholder {\r\n        require(members[msg.sender].shares > 0, \"not shareholder\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDelegate {\r\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"not delegate\");\r\n        _;\r\n    }\r\n    \r\n    /******************\r\n    SUMMONING FUNCTIONS\r\n    ******************/\r\n    constructor(\r\n        address[] memory _summoners,\r\n        address[] memory _approvedTokens,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _proposalDeposit,\r\n        uint256 _dilutionBound,\r\n        uint256 _processingReward,\r\n        uint256 _summonerStake,\r\n        uint256 _summoningDeposit,\r\n        uint256 _summoningRate,\r\n        uint256 _summoningTermination\r\n    ) public {\r\n        require(_votingPeriodLength <= MAX_INPUT, \"_votingPeriodLength maxed\");\r\n        require(_gracePeriodLength <= MAX_INPUT, \"_gracePeriodLength maxed\");\r\n        require(_dilutionBound <= MAX_INPUT, \"_dilutionBound maxed\");\r\n        require(_approvedTokens.length <= MAX_TOKEN_WHITELIST_COUNT, \"tokens maxed\");\r\n        \r\n        depositToken = _approvedTokens[0];\r\n        \r\n        if (_summoningDeposit > 0) {\r\n            unsafeAddToBalance(GUILD, depositToken, _summoningDeposit);\r\n            totalGuildBankTokens += 1;\r\n        }\r\n        \r\n        // NOTE: move event up here, avoid stack too deep if too many approved tokens\r\n        emit SummonComplete(_summoners, _approvedTokens, now, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDeposit, _dilutionBound, _processingReward, _summonerStake, _summoningDeposit, _summoningRate, _summoningTermination);\r\n        \r\n        for (uint256 i = 0; i < _summoners.length; i++) {\r\n            members[_summoners[i]] = Member(_summoners[i], _summonerStake, 0, true, 0, 0);\r\n            memberAddressByDelegateKey[_summoners[i]] = _summoners[i];\r\n        }\r\n\r\n        for (uint256 i = 0; i < _approvedTokens.length; i++) {\r\n            require(!tokenWhitelist[_approvedTokens[i]], \"token duplicated\");\r\n            tokenWhitelist[_approvedTokens[i]] = true;\r\n            approvedTokens.push(_approvedTokens[i]);\r\n        }\r\n        \r\n        periodDuration = _periodDuration;\r\n        votingPeriodLength = _votingPeriodLength;\r\n        gracePeriodLength = _gracePeriodLength;\r\n        proposalDeposit = _proposalDeposit;\r\n        dilutionBound = _dilutionBound;\r\n        processingReward = _processingReward;\r\n        summoningRate = _summoningRate;\r\n        summoningTermination = _summoningTermination;\r\n        summoningTime = now;\r\n        totalShares = _summoners.length.mul(_summonerStake);\r\n    }\r\n\r\n    function makeSummoningTribute(uint256 tribute) payable public {\r\n        require(members[msg.sender].exists == true, \"not member\");\r\n        require(getCurrentPeriod() <= summoningTermination, \"summoning period over\");        \r\n        require(tribute >= summoningRate, \"tribute insufficient\");\r\n\r\n        if (depositToken == wETH && msg.value > 0) {\r\n            require(msg.value == tribute, \"insufficient ETH\");\r\n            IWETH(wETH).deposit();\r\n            (bool success, ) = wETH.call.value(msg.value)(\"\");\r\n            require(success, \"transfer failed\");\r\n            IWETH(wETH).transfer(address(this), msg.value);\r\n        } else {\r\n            require(IERC20(depositToken).transferFrom(msg.sender, address(this), tribute), \"transfer failed\");\r\n        }\r\n        \r\n        unsafeAddToBalance(GUILD, depositToken, tribute);\r\n        if (userTokenBalances[GUILD][depositToken] == 0) {totalGuildBankTokens += 1;}\r\n        \r\n        uint256 shares = tribute.div(summoningRate);\r\n        require(totalShares + shares <= MAX_INPUT, \"shares maxed\");\r\n        members[msg.sender].shares += shares;\r\n        totalShares += shares;\r\n\r\n        emit MakeSummoningTribute(msg.sender, tribute, shares);\r\n    }\r\n    \r\n    function makePayment(address paymentToken, uint256 payment) public {\r\n        require(tokenWhitelist[paymentToken], \"paymentToken not whitelisted\");\r\n        require(IERC20(paymentToken).transferFrom(msg.sender, address(this), payment), \"transfer failed\");\r\n\r\n        unsafeAddToBalance(GUILD, paymentToken, payment);\r\n        if (userTokenBalances[GUILD][paymentToken] == 0) {totalGuildBankTokens += 1;}\r\n    }\r\n    \r\n    /*****************\r\n    PROPOSAL FUNCTIONS\r\n    *****************/\r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        bytes32 details\r\n    ) payable public nonReentrant returns (uint256 proposalId) {\r\n        require(sharesRequested.add(lootRequested) <= MAX_INPUT, \"shares maxed\");\r\n        require(tokenWhitelist[tributeToken], \"tributeToken not whitelisted\");\r\n        require(tokenWhitelist[paymentToken], \"paymentToken not whitelisted\");\r\n        require(applicant != address(0), \"applicant zeroed\");\r\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant address unreservable\");\r\n        require(members[applicant].jailed == 0, \"applicant jailed\");\r\n\r\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, \"guildbank maxed\");\r\n        }\r\n        \r\n        // collect tribute from proposer and store it in the Moloch until the proposal is processed\r\n        if (tributeToken == wETH && msg.value > 0) {\r\n            require(msg.value == tributeOffered, \"insufficient ETH\");\r\n            IWETH(wETH).deposit();\r\n            (bool success, ) = wETH.call.value(msg.value)(\"\");\r\n            require(success, \"transfer failed\");\r\n            IWETH(wETH).transfer(address(this), msg.value);\r\n        } else {\r\n            require(IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered), \"transfer failed\");\r\n        }\r\n        \r\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\r\n\r\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n\r\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\r\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\r\n    }\r\n\r\n    function submitWhitelistProposal(address tokenToWhitelist, bytes32 details) public nonReentrant returns (uint256 proposalId) {\r\n        require(tokenToWhitelist != address(0), \"need token\");\r\n        require(!tokenWhitelist[tokenToWhitelist], \"already whitelisted\");\r\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"whitelist maxed\");\r\n\r\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n        flags[4] = true; // whitelist\r\n\r\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags);\r\n        return proposalCount - 1;\r\n    }\r\n\r\n    function submitGuildKickProposal(address memberToKick, bytes32 details) public nonReentrant returns (uint256 proposalId) {\r\n        Member memory member = members[memberToKick];\r\n\r\n        require(member.shares > 0 || member.loot > 0, \"must have share or loot\");\r\n        require(members[memberToKick].jailed == 0, \"already jailed\");\r\n\r\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n        flags[5] = true; // guild kick\r\n\r\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags);\r\n        return proposalCount - 1;\r\n    }\r\n\r\n    function _submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        bytes32 details,\r\n        bool[6] memory flags\r\n    ) internal {\r\n        Proposal memory proposal = Proposal({\r\n            applicant : applicant,\r\n            proposer : msg.sender,\r\n            sponsor : address(0),\r\n            sharesRequested : sharesRequested,\r\n            lootRequested : lootRequested,\r\n            tributeOffered : tributeOffered,\r\n            tributeToken : tributeToken,\r\n            paymentRequested : paymentRequested,\r\n            paymentToken : paymentToken,\r\n            startingPeriod : 0,\r\n            yesVotes : 0,\r\n            noVotes : 0,\r\n            flags : flags,\r\n            details : details,\r\n            maxTotalSharesAndLootAtYesVote : 0\r\n        });\r\n\r\n        proposals[proposalCount] = proposal;\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        // NOTE: argument order matters, avoid stack too deep\r\n        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, proposalCount, msg.sender, memberAddress);\r\n        proposalCount += 1;\r\n    }\r\n\r\n    function sponsorProposal(uint256 proposalId) public nonReentrant onlyDelegate {\r\n        // collect proposal deposit from sponsor and store it in the Moloch until the proposal is processed\r\n        require(IERC20(depositToken).transferFrom(msg.sender, address(this), proposalDeposit), \"deposit failed\");\r\n        unsafeAddToBalance(ESCROW, depositToken, proposalDeposit);\r\n\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.proposer != address(0), \"unproposed\");\r\n        require(!proposal.flags[0], \"already sponsored\");\r\n        require(!proposal.flags[3], \"cancelled\");\r\n        require(members[proposal.applicant].jailed == 0, \"applicant jailed\");\r\n\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, \"guildbank maxed\");\r\n        }\r\n\r\n        // whitelist proposal\r\n        if (proposal.flags[4]) {\r\n            require(!tokenWhitelist[address(proposal.tributeToken)], \"already whitelisted\");\r\n            require(!proposedToWhitelist[address(proposal.tributeToken)], \"already whitelist proposed\");\r\n            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"whitelist maxed\");\r\n            proposedToWhitelist[address(proposal.tributeToken)] = true;\r\n\r\n        // guild kick proposal\r\n        } else if (proposal.flags[5]) {\r\n            require(!proposedToKick[proposal.applicant], \"kick already proposed\");\r\n            proposedToKick[proposal.applicant] = true;\r\n        }\r\n\r\n        // compute startingPeriod for proposal\r\n        uint256 startingPeriod = max(\r\n            getCurrentPeriod(),\r\n            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length.sub(1)]].startingPeriod\r\n        ).add(1);\r\n\r\n        proposal.startingPeriod = startingPeriod;\r\n\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        proposal.sponsor = memberAddress;\r\n\r\n        proposal.flags[0] = true; // sponsored\r\n\r\n        // append proposal to the queue\r\n        proposalQueue.push(proposalId);\r\n        \r\n        emit SponsorProposal(msg.sender, memberAddress, proposalId, proposalQueue.length.sub(1), startingPeriod);\r\n    }\r\n\r\n    // NOTE: In MolochV2 proposalIndex !== proposalId\r\n    function submitVote(uint256 proposalIndex, uint8 uintVote) public nonReentrant onlyDelegate {\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(proposalIndex < proposalQueue.length, \"unproposed\");\r\n        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(uintVote < 3, \"not < 3\");\r\n        Vote vote = Vote(uintVote);\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"voting pending\");\r\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"proposal expired\");\r\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"member voted\");\r\n        require(vote == Vote.Yes || vote == Vote.No, \"must vote Yes or No\");\r\n\r\n        proposal.votesByMember[memberAddress] = vote;\r\n\r\n        if (vote == Vote.Yes) {\r\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\r\n\r\n            // set highest index (latest) yes vote - must be processed for member to ragequit\r\n            if (proposalIndex > member.highestIndexYesVote) {\r\n                member.highestIndexYesVote = proposalIndex;\r\n            }\r\n\r\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\r\n            if (totalShares.add(totalLoot) > proposal.maxTotalSharesAndLootAtYesVote) {\r\n                proposal.maxTotalSharesAndLootAtYesVote = totalShares.add(totalLoot);\r\n            }\r\n\r\n        } else if (vote == Vote.No) {\r\n            proposal.noVotes = proposal.noVotes.add(member.shares);\r\n        }\r\n     \r\n        // NOTE: subgraph indexes by proposalId not proposalIndex since proposalIndex isn't set untill it's been sponsored but proposal is created on submission\r\n        emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, memberAddress, uintVote);\r\n    }\r\n\r\n    function processProposal(uint256 proposalIndex) public nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(!proposal.flags[4] && !proposal.flags[5], \"not standard proposal\");\r\n\r\n        proposal.flags[1] = true; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        // Make the proposal fail if the new total number of shares and loot exceeds the limit\r\n        if (totalShares.add(totalLoot).add(proposal.sharesRequested).add(proposal.lootRequested) > MAX_INPUT) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance\r\n        if (proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it would result in too many tokens with non-zero balance in guild bank\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0 && totalGuildBankTokens >= MAX_TOKEN_GUILDBANK_COUNT) {\r\n           didPass = false;\r\n        }\r\n\r\n        // PROPOSAL PASSED\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n\r\n            // if the applicant is already a member, add to their existing shares & loot\r\n            if (members[proposal.applicant].exists) {\r\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\r\n                members[proposal.applicant].loot = members[proposal.applicant].loot.add(proposal.lootRequested);\r\n\r\n            // the applicant is a new member, create a new record for them\r\n            } else {\r\n                // if the applicant address is already taken by a member's delegateKey, reset it to their member address\r\n                if (members[memberAddressByDelegateKey[proposal.applicant]].exists) {\r\n                    address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\r\n                    memberAddressByDelegateKey[memberToOverride] = memberToOverride;\r\n                    members[memberToOverride].delegateKey = memberToOverride;\r\n                }\r\n\r\n                // use applicant address as delegateKey by default\r\n                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, proposal.lootRequested, true, 0, 0);\r\n                memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\r\n            }\r\n\r\n            // mint new shares & loot\r\n            totalShares = totalShares.add(proposal.sharesRequested);\r\n            totalLoot = totalLoot.add(proposal.lootRequested);\r\n\r\n            // if the proposal tribute is the first tokens of its kind to make it into the guild bank, increment total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.tributeToken] == 0 && proposal.tributeOffered > 0) {\r\n                totalGuildBankTokens += 1;\r\n            }\r\n\r\n            unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);\r\n            unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposal.paymentRequested);\r\n\r\n            // if the proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {\r\n                totalGuildBankTokens -= 1;\r\n            }\r\n\r\n        // PROPOSAL FAILED\r\n        } else {\r\n            // return all tokens to the proposer (not the applicant, because funds come from proposer)\r\n            unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        }\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n\r\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processWhitelistProposal(uint256 proposalIndex) public nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[4], \"not whitelist proposal\");\r\n\r\n        proposal.flags[1] = true; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (approvedTokens.length >= MAX_TOKEN_WHITELIST_COUNT) {\r\n            didPass = false;\r\n        }\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n\r\n            tokenWhitelist[address(proposal.tributeToken)] = true;\r\n            approvedTokens.push(proposal.tributeToken);\r\n        }\r\n\r\n        proposedToWhitelist[address(proposal.tributeToken)] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n\r\n        emit ProcessWhitelistProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processGuildKickProposal(uint256 proposalIndex) public nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[5], \"not guild kick\");\r\n\r\n        proposal.flags[1] = true; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n            Member storage member = members[proposal.applicant];\r\n            member.jailed = proposalIndex;\r\n\r\n            // transfer shares to loot\r\n            member.loot = member.loot.add(member.shares);\r\n            totalShares = totalShares.sub(member.shares);\r\n            totalLoot = totalLoot.add(member.shares);\r\n            member.shares = 0; // revoke all shares\r\n        }\r\n\r\n        proposedToKick[proposal.applicant] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n\r\n        emit ProcessGuildKickProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function _didPass(uint256 proposalIndex) internal view returns (bool didPass) {\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        didPass = proposal.yesVotes > proposal.noVotes;\r\n\r\n        // Make the proposal fail if the dilutionBound is exceeded\r\n        if ((totalShares.add(totalLoot)).mul(dilutionBound) < proposal.maxTotalSharesAndLootAtYesVote) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if the applicant is jailed\r\n        // - for standard proposals, we don't want the applicant to get any shares/loot/payment\r\n        // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter\r\n        if (members[proposal.applicant].jailed != 0) {\r\n            didPass = false;\r\n        }\r\n\r\n        return didPass;\r\n    }\r\n\r\n    function _validateProposalForProcessing(uint256 proposalIndex) internal view {\r\n        require(proposalIndex < proposalQueue.length, \"no such proposal\");\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"proposal not ready\");\r\n        require(proposal.flags[1] == false, \"proposal already processed\");\r\n        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex.sub(1)]].flags[1], \"previous proposal unprocessed\");\r\n    }\r\n\r\n    function _returnDeposit(address sponsor) internal {\r\n        unsafeInternalTransfer(ESCROW, msg.sender, depositToken, processingReward);\r\n        unsafeInternalTransfer(ESCROW, sponsor, depositToken, proposalDeposit.sub(processingReward));\r\n    }\r\n\r\n    function ragequit(uint256 sharesToBurn, uint256 lootToBurn) public nonReentrant onlyMember {\r\n        _ragequit(msg.sender, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function _ragequit(address memberAddress, uint256 sharesToBurn, uint256 lootToBurn) internal {\r\n        uint256 initialTotalSharesAndLoot = totalShares.add(totalLoot);\r\n\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(member.shares >= sharesToBurn, \"insufficient shares\");\r\n        require(member.loot >= lootToBurn, \"insufficient loot\");\r\n\r\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\r\n\r\n        uint256 sharesAndLootToBurn = sharesToBurn.add(lootToBurn);\r\n\r\n        // burn shares and loot\r\n        member.shares = member.shares.sub(sharesToBurn);\r\n        member.loot = member.loot.sub(lootToBurn);\r\n        totalShares = totalShares.sub(sharesToBurn);\r\n        totalLoot = totalLoot.sub(lootToBurn);\r\n\r\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\r\n            uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][approvedTokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\r\n            if (amountToRagequit > 0) { // gas optimization to allow a higher maximum token limit\r\n                // deliberately not using safemath here to keep overflows from preventing the function execution (which would break ragekicks)\r\n                // if a token overflows, it is because the supply was artificially inflated to oblivion, so we probably don't care about it anyways\r\n                userTokenBalances[GUILD][approvedTokens[i]] -= amountToRagequit;\r\n                userTokenBalances[memberAddress][approvedTokens[i]] += amountToRagequit;\r\n            }\r\n        }\r\n\r\n        emit Ragequit(msg.sender, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function ragekick(address memberToKick) public nonReentrant {\r\n        Member storage member = members[memberToKick];\r\n\r\n        require(member.jailed != 0, \"member not jailed\");\r\n        require(member.loot > 0, \"member must have loot\"); // note - should be impossible for jailed member to have shares\r\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\r\n\r\n        _ragequit(memberToKick, 0, member.loot);\r\n    }\r\n\r\n    function withdrawBalance(address token, uint256 amount) public nonReentrant {\r\n        _withdrawBalance(token, amount);\r\n    }\r\n\r\n    function withdrawBalances(address[] memory tokens, uint256[] memory amounts, bool max) public nonReentrant {\r\n        require(tokens.length == amounts.length, \"tokens + amounts arrays must match\");\r\n\r\n        for (uint256 i=0; i < tokens.length; i++) {\r\n            uint256 withdrawAmount = amounts[i];\r\n            if (max) { // withdraw the maximum balance\r\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\r\n            }\r\n\r\n            _withdrawBalance(tokens[i], withdrawAmount);\r\n        }\r\n    }\r\n    \r\n    function _withdrawBalance(address token, uint256 amount) internal {\r\n        require(userTokenBalances[msg.sender][token] >= amount, \"insufficient balance\");\r\n        unsafeSubtractFromBalance(msg.sender, token, amount);\r\n        require(IERC20(token).transfer(msg.sender, amount), \"transfer failed\");\r\n        emit Withdraw(msg.sender, token, amount);\r\n    }\r\n\r\n    function collectTokens(address token) public nonReentrant onlyDelegate {\r\n        uint256 amountToCollect = IERC20(token).balanceOf(address(this)).sub(userTokenBalances[TOTAL][token]);\r\n        // only collect if 1) there are tokens to collect 2) token is whitelisted 3) token has non-zero balance\r\n        require(amountToCollect > 0, \"no tokens\");\r\n        require(tokenWhitelist[token], \"not whitelisted\");\r\n        require(userTokenBalances[GUILD][token] > 0, \"no guild balance\");\r\n        \r\n        unsafeAddToBalance(GUILD, token, amountToCollect);\r\n        emit TokensCollected(token, amountToCollect);\r\n    }\r\n\r\n    // NOTE: requires that delegate key which sent the original proposal cancels, msg.sender == proposal.proposer\r\n    function cancelProposal(uint256 proposalId) public nonReentrant {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(!proposal.flags[0], \"proposal already sponsored\");\r\n        require(!proposal.flags[3], \"proposal already cancelled\");\r\n        require(msg.sender == proposal.proposer, \"only proposer cancels\");\r\n\r\n        proposal.flags[3] = true; // cancelled\r\n        \r\n        unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        emit CancelProposal(proposalId, msg.sender);\r\n    }\r\n\r\n    function updateDelegateKey(address newDelegateKey) public nonReentrant onlyShareholder {\r\n        require(newDelegateKey != address(0), \"newDelegateKey zeroed\");\r\n\r\n        // skip checks if member is setting the delegate key to their member address\r\n        if (newDelegateKey != msg.sender) {\r\n            require(!members[newDelegateKey].exists, \"cannot overwrite members\");\r\n            require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"cannot overwrite delegate keys\");\r\n        }\r\n\r\n        Member storage member = members[msg.sender];\r\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\r\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\r\n        member.delegateKey = newDelegateKey;\r\n\r\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\r\n    }\r\n\r\n    // can only ragequit if the latest proposal you voted YES on has been processed\r\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\r\n        require(highestIndexYesVote < proposalQueue.length, \"no such proposal\");\r\n        return proposals[proposalQueue[highestIndexYesVote]].flags[1];\r\n    }\r\n\r\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\r\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\r\n    }\r\n    \r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return now.sub(summoningTime).div(periodDuration);\r\n    }\r\n\r\n    function getProposalQueueLength() public view returns (uint256) {\r\n        return proposalQueue.length;\r\n    }\r\n\r\n    function getProposalFlags(uint256 proposalId) public view returns (bool[6] memory) {\r\n        return proposals[proposalId].flags;\r\n    }\r\n\r\n    function getUserTokenBalance(address user, address token) public view returns (uint256) {\r\n        return userTokenBalances[user][token];\r\n    }\r\n\r\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) {\r\n        require(members[memberAddress].exists, \"no such member\");\r\n        require(proposalIndex < proposalQueue.length, \"unproposed\");\r\n        return proposals[proposalQueue[proposalIndex]].votesByMember[memberAddress];\r\n    }\r\n\r\n    function getTokenCount() public view returns (uint256) {\r\n        return approvedTokens.length;\r\n    }\r\n\r\n    /***************\r\n    HELPER FUNCTIONS\r\n    ***************/\r\n    function unsafeAddToBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] += amount;\r\n        userTokenBalances[TOTAL][token] += amount;\r\n    }\r\n\r\n    function unsafeSubtractFromBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] -= amount;\r\n        userTokenBalances[TOTAL][token] -= amount;\r\n    }\r\n\r\n    function unsafeInternalTransfer(address from, address to, address token, uint256 amount) internal {\r\n        unsafeSubtractFromBalance(from, token, amount);\r\n        unsafeAddToBalance(to, token, amount);\r\n    }\r\n\r\n    function fairShare(uint256 balance, uint256 shares, uint256 totalSharesAndLoot) internal pure returns (uint256) {\r\n        require(totalSharesAndLoot != 0);\r\n\r\n        if (balance == 0) { return 0; }\r\n\r\n        uint256 prod = balance * shares;\r\n\r\n        if (prod / balance == shares) { // no overflow in multiplication above?\r\n            return prod / totalSharesAndLoot;\r\n        }\r\n\r\n        return (balance / totalSharesAndLoot) * shares;\r\n    }  \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_summoners\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_approvedTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_periodDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_votingPeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gracePeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_proposalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dilutionBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_processingReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_summonerStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_summoningDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_summoningRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_summoningTermination\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"applicantAddress\",\"type\":\"address\"}],\"name\":\"CancelProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tribute\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"MakeSummoningTribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessGuildKickProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessWhitelistProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootToBurn\",\"type\":\"uint256\"}],\"name\":\"Ragequit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"}],\"name\":\"SponsorProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool[6]\",\"name\":\"flags\",\"type\":\"bool[6]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"SubmitProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"uintVote\",\"type\":\"uint8\"}],\"name\":\"SubmitVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"summoners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"summoningTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votingPeriodLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gracePeriodLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dilutionBound\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"processingReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"summonerStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"summoningDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"summoningRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"summoningTermination\",\"type\":\"uint256\"}],\"name\":\"SummonComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToCollect\",\"type\":\"uint256\"}],\"name\":\"TokensCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDelegateKey\",\"type\":\"address\"}],\"name\":\"UpdateDelegateKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ESCROW\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GUILD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"highestIndexYesVote\",\"type\":\"uint256\"}],\"name\":\"canRagequit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancelProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"collectTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dilutionBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"getMemberProposalVote\",\"outputs\":[{\"internalType\":\"enum Moloch.Vote\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalFlags\",\"outputs\":[{\"internalType\":\"bool[6]\",\"name\":\"\",\"type\":\"bool[6]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProposalQueueLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUserTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gracePeriodLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"}],\"name\":\"hasVotingPeriodExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"makePayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tribute\",\"type\":\"uint256\"}],\"name\":\"makeSummoningTribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberAddressByDelegateKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"members\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loot\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"highestIndexYesVote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jailed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processGuildKickProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processWhitelistProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"processingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yesVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noVotes\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalSharesAndLootAtYesVote\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposedToKick\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposedToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberToKick\",\"type\":\"address\"}],\"name\":\"ragekick\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootToBurn\",\"type\":\"uint256\"}],\"name\":\"ragequit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"sponsorProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberToKick\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"submitGuildKickProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"submitProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"uintVote\",\"type\":\"uint8\"}],\"name\":\"submitVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenToWhitelist\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"submitWhitelistProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"summoningRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"summoningTermination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"summoningTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGuildBankTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDelegateKey\",\"type\":\"address\"}],\"name\":\"updateDelegateKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTokenBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingPeriodLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"max\",\"type\":\"bool\"}],\"name\":\"withdrawBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Moloch","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000003c0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000ab1800000000000000000000000000000000000000000000000000000000000000010000000000000000000000001c0aa8ccd568d90d61659f060d1bfb1e6f855a200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://44717a70892c190a220a389c71527d78fec552554a2e63c2dc8ee3899a752df6"}]}