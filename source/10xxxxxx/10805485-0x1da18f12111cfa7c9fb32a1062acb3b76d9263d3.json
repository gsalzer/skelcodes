{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract ReentrancyGuard {\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        _guardCounter = 1;\n    }\n\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\ncontract Context {\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface CompoundInterface {\n    function mint(uint256 mintAmount) external returns ( uint256 );\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n    function exchangeRateStored() external view returns (uint);\n}\n\n/*\n * @title  Pool\n * @notice Abstract pool to facilitate tracking of shares in a pool\n */\ncontract Pool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 private _totalShares;\n    mapping(address => uint256) private _shares;\n\n    /**\n     * @dev Pool constructor\n     */\n    constructor() internal {\n    }\n\n    /*** VIEW ***/\n\n    /**\n     * @dev Get the total number of shares in pool\n     * @return uint256 total shares\n     */\n    function totalShares()\n        public\n        view\n        returns (uint256)\n    {\n        return _totalShares;\n    }\n\n    /**\n     * @dev Get the share of a given account\n     * @param _account User for which to retrieve balance\n     * @return uint256 shares\n     */\n    function sharesOf(address _account)\n        public\n        view\n        returns (uint256)\n    {\n        return _shares[_account];\n    }\n\n    /*** INTERNAL ***/\n\n    /**\n     * @dev Add a given amount of shares to a given account\n     * @param _account Account to increase shares for\n     * @param _amount Units of shares\n     */\n    function _increaseShares(address _account, uint256 _amount)\n        internal\n    {\n        _totalShares = _totalShares.add(_amount);\n        _shares[_account] = _shares[_account].add(_amount);\n    }\n\n    /**\n     * @dev Remove a given amount of shares from a given account\n     * @param _account Account to decrease shares for\n     * @param _amount Units of shares\n     */\n    function _decreaseShares(address _account, uint256 _amount)\n        internal\n    {\n        _totalShares = _totalShares.sub(_amount);\n        _shares[_account] = _shares[_account].sub(_amount);\n    }\n}\n\n/**\n * @title EarningPool\n * @dev Pool that tracks shares of an underlying token, of which are deposited into COMPOUND.\n        Earnings from provider is sent to recipients\n */\ncontract EarningPool is ReentrancyGuard, Ownable, Pool {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public underlyingToken;\n\n    // Compound cToken address (provider)\n    address public compound;\n\n    // Provider reward token address\n    address public rewardToken;\n\n    // Address where earning are dispensed to\n    address public earningRecipient;\n\n    // Address where rewards are dispensed to\n    address public rewardRecipient;\n\n    // Fee factor mantissa, 1e18 = 100%\n    uint256 public withdrawFeeFactorMantissa;\n\n    uint256 public earningDispenseThreshold;\n    uint256 public rewardDispenseThreshold;\n\n    event Deposited(address indexed beneficiary, uint256 amount, address payer);\n    event Withdrawn(address indexed beneficiary, uint256 amount, address payer);\n    event Dispensed(address indexed token, uint256 amount);\n\n    /**\n     * @dev EarningPool constructor\n     * @param _underlyingToken The underlying token thats is earning interest from provider\n     * @param _rewardToken Provider reward token\n     * @param _compound Compound cToken address for underlying token\n     */\n    constructor (\n        address _underlyingToken,\n        address _rewardToken,\n        address _compound\n    )\n        Pool()\n        public\n    {\n        underlyingToken = _underlyingToken;\n        rewardToken = _rewardToken;\n        compound = _compound;\n\n        _approveUnderlyingToProvider();\n    }\n\n    /*** USER ***/\n\n    /**\n     * @dev Deposit underlying into pool\n     * @param _beneficiary Address to benefit from the deposit\n     * @param _amount Amount of underlying to deposit\n     */\n    function deposit(address _beneficiary, uint256 _amount)\n        external\n        nonReentrant\n    {\n        _deposit(_beneficiary, _amount);\n    }\n\n    /**\n     * @dev Withdraw underlying from pool\n     * @param _beneficiary Address to benefit from the withdraw\n     * @param _amount Amount of underlying to withdraw\n     * @return uint256 Actual amount of underlying withdrawn\n     */\n    function withdraw(address _beneficiary, uint256 _amount)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        return _withdraw(_beneficiary, _amount);\n    }\n\n    /**\n     * @dev Transfer underlying token interest earned to recipient\n     * @return uint256 Amount dispensed\n     */\n    function dispenseEarning() public returns (uint256) {\n        if (earningRecipient == address(0)) {\n           return 0;\n        }\n\n        uint256 earnings = calcUndispensedEarningInUnderlying();\n        // total dispense amount = earning + withdraw fee\n        uint256 totalDispenseAmount =  earnings.add(balanceInUnderlying());\n        if (totalDispenseAmount < earningDispenseThreshold) {\n           return 0;\n        }\n\n        // Withdraw earning from provider\n        _withdrawFromProvider(earnings);\n\n        // Transfer earning + withdraw fee to recipient\n        IERC20(underlyingToken).safeTransfer(earningRecipient, totalDispenseAmount);\n\n        emit Dispensed(underlyingToken, totalDispenseAmount);\n\n        return totalDispenseAmount;\n    }\n\n    /**\n     * @dev Transfer reward token earned to recipient\n     * @return uint256 Amount dispensed\n     */\n    function dispenseReward() public returns (uint256) {\n        if (rewardRecipient == address(0)) {\n           return 0;\n        }\n\n        uint256 rewards = calcUndispensedProviderReward();\n        if (rewards < rewardDispenseThreshold) {\n           return 0;\n        }\n\n        // Transfer COMP rewards to recipient\n        IERC20(rewardToken).safeTransfer(rewardRecipient, rewards);\n\n        emit Dispensed(rewardToken, rewards);\n\n        return rewards;\n    }\n\n    /*** VIEW ***/\n\n    /**\n     * @dev Get balance of underlying token in this pool\n     *      Should equal to withdraw fee unless underlyings are sent to pool\n     * @return uint256 Underlying token balance\n     */\n    function balanceInUnderlying() public view returns (uint256) {\n        return IERC20(underlyingToken).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Get balance of COMP cToken in this pool\n     * @return uint256 COMP cToken balance\n     */\n    function balanceCompound() public view returns (uint256) {\n        return IERC20(compound).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Get balance of compound token in this pool converted to underlying\n     * @return uint256 Underlying token balance\n     */\n    function balanceCompoundInUnderlying() public view returns (uint256) {\n        // Mantisa 1e18 to decimals\n        uint256 b = balanceCompound();\n        if (b > 0) {\n          b = b.mul(CompoundInterface(compound).exchangeRateStored()).div(1e18);\n        }\n        return b;\n    }\n\n    /**\n     * @dev Calculate total underlying balance of this pool\n     *      Total balance of underlying = total provider underlying balance (deposit + interest accrued) + withdraw fee\n     * @return uint256 Underlying token balance\n     */\n    function calcPoolValueInUnderlying() public view returns (uint256) {\n        return balanceCompoundInUnderlying() // compound\n               .add(balanceInUnderlying()); // withdraw fee\n    }\n\n    /**\n     * @dev Calculate outstanding interest earning of underlying token in this pool\n     *      Earning = total provider underlying balance - total deposit\n     * @return uint256 Underlying token balance\n     */\n    function calcUndispensedEarningInUnderlying() public view returns(uint256) {\n        return balanceCompoundInUnderlying().sub(totalShares());\n    }\n\n    /**\n     * @dev Get outstanding reward token in pool\n     * @return uint256 Reward token balance\n     */\n    function calcUndispensedProviderReward() public view returns(uint256) {\n        return IERC20(rewardToken).balanceOf(address(this));\n    }\n\n    /*** ADMIN ***/\n\n    function setWithdrawFeeFactor(uint256 _withdrawFeeFactorManitssa)\n        public\n        onlyOwner\n    {\n        withdrawFeeFactorMantissa = _withdrawFeeFactorManitssa;\n    }\n\n    function setEarningRecipient(address _recipient)\n        public\n        onlyOwner\n    {\n        earningRecipient = _recipient;\n    }\n\n    function setRewardRecipient(address _recipient)\n        public\n        onlyOwner\n    {\n        rewardRecipient = _recipient;\n    }\n\n    function setEarningDispenseThreshold(uint256 _threshold)\n        public\n        onlyOwner\n    {\n        earningDispenseThreshold = _threshold;\n    }\n\n    function setRewardDispenseThreshold(uint256 _threshold)\n        public\n        onlyOwner\n    {\n        rewardDispenseThreshold = _threshold;\n    }\n\n\n    /*** INTERNAL ***/\n\n    function _deposit(address _beneficiary, uint256 _amount)\n        internal\n    {\n        require(_amount > 0, \"EARNING_POOL: deposit must be greater than 0\");\n\n        // Transfer underlying from payer into pool\n        IERC20(underlyingToken).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Supply underlying to provider\n        _supplyToProvider(_amount);\n\n        // increase pool shares for beneficiary\n        _increaseShares(_beneficiary, _amount);\n\n        emit Deposited(_beneficiary, _amount, msg.sender);\n    }\n\n    function _withdraw(address _beneficiary, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        require(_amount > 0, \"EARNING_POOL: withdraw must be greater than 0\");\n        require(_amount <= sharesOf(msg.sender), \"EARNING_POOL: withdraw insufficient shares\");\n\n        // Withdraw underlying from provider\n        _withdrawFromProvider(_amount);\n\n        // decrease pool shares from payer\n        _decreaseShares(msg.sender, _amount);\n\n        // Collect withdraw fee\n        uint256 withdrawFee = _amount.mul(withdrawFeeFactorMantissa).div(1e18);\n        uint256 withdrawAmountLessFee = _amount.sub(withdrawFee);\n\n        // Transfer underlying to beneficiary\n        IERC20(underlyingToken).safeTransfer(_beneficiary, withdrawAmountLessFee);\n\n        emit Withdrawn(_beneficiary, withdrawAmountLessFee, msg.sender);\n\n        return withdrawAmountLessFee;\n    }\n\n    /**\n     * @dev Approve underlying token to providers\n     */\n    function _approveUnderlyingToProvider() internal {\n        IERC20(underlyingToken).safeApprove(compound, uint256(-1));\n    }\n\n    /**\n     * @dev Withdraw some underlying from Compound\n     * @param _amount Amount of underlying to withdraw\n     */\n    function _withdrawFromProvider(uint256 _amount) internal {\n        require(balanceCompoundInUnderlying() >= _amount, \"COMPOUND: withdraw insufficient funds\");\n        require(CompoundInterface(compound).redeemUnderlying(_amount) == 0, \"COMPOUND: redeemUnderlying failed\");\n    }\n\n    /**\n     * @dev Withdraw some underlying to Compound\n     * @param _amount Amount of underlying to supply\n     */\n    function _supplyToProvider(uint256 _amount) internal {\n        // Check compound rcode\n        require(CompoundInterface(compound).mint(_amount) == 0, \"COMPOUND: mint failed\");\n    }\n}\n\n/**\n * @title USDCPool\n * @dev Earning pool for USDC\n */\ncontract USDCPool is EarningPool {\n    constructor ()\n        EarningPool (\n            address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), // USDC\n            address(0xc00e94Cb662C3520282E6f5717214004A7f26888), // reward token\n            address(0x39AA39c021dfbaE8faC545936693aC917d5E7563) // compound cUSDC\n        )\n        public\n    {\n    }\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Dispensed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceCompound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceCompoundInUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceInUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcPoolValueInUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcUndispensedEarningInUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcUndispensedProviderReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compound\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dispenseEarning\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dispenseReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earningDispenseThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earningRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardDispenseThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"setEarningDispenseThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"setEarningRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"setRewardDispenseThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"setRewardRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawFeeFactorManitssa\",\"type\":\"uint256\"}],\"name\":\"setWithdrawFeeFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawFeeFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"USDCPool","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"50000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}