{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/IOrbsRewardsDistribution.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\ninterface IOrbsRewardsDistribution {\r\n    event RewardDistributed(string distributionEvent, address indexed recipient, uint256 amount);\r\n\r\n    event RewardsDistributionAnnounced(string distributionEvent, bytes32[] batchHash, uint256 batchCount);\r\n    event RewardsBatchExecuted(string distributionEvent, bytes32 batchHash, uint256 batchIndex);\r\n    event RewardsDistributionAborted(string distributionEvent, bytes32[] abortedBatchHashes, uint256[] abortedBatchIndices);\r\n    event RewardsDistributionCompleted(string distributionEvent);\r\n\r\n    event RewardsDistributorReassigned(address indexed previousRewardsDistributor, address indexed newRewardsDistributor);\r\n\r\n    function announceDistributionEvent(string distributionEvent, bytes32[] batchHashes) external;\r\n    function abortDistributionEvent(string distributionEvent) external;\r\n\r\n    function executeCommittedBatch(string distributionEvent, address[] recipients, uint256[] amounts, uint256 batchIndex) external;\r\n\r\n    function distributeRewards(string distributionEvent, address[] recipients, uint256[] amounts) external;\r\n\r\n    function getPendingBatches(string distributionEvent) external view returns (bytes32[] pendingBatchHashes, uint256[] pendingBatchIndices);\r\n    function reassignRewardsDistributor(address _newRewardsDistributor) external;\r\n    function isRewardsDistributor() external returns (bool);\r\n}\r\n\r\n// File: contracts/IStakingContract.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/// @title An interface for distributing rewards to staking contracts.\r\ninterface IStakingContract {\r\n\r\n    /// @dev Distributes staking rewards to a list of addresses by directly adding rewards to their stakes. This method\r\n    /// assumes that the user has already approved at least the required amount using ERC20 approve. Since this is a\r\n    /// convenience method, we aren't concerned about reaching block gas limit by using large lists. We assume that\r\n    /// callers will be able to properly batch/paginate their requests.\r\n    /// @param _totalAmount uint256 The total amount of rewards to distributes.\r\n    /// @param _stakeOwners address[] The addresses of the stake owners.\r\n    /// @param _amounts uint256[] The amounts of the rewards.\r\n    function distributeRewards(uint256 _totalAmount, address[] _stakeOwners, uint256[] _amounts) external;\r\n}\r\n\r\n// File: contracts/OrbsRewardsDistributionForStaking.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Orbs rewards distribution smart contract.\r\ncontract OrbsRewardsDistributionForStaking is Ownable, IOrbsRewardsDistribution {\r\n\r\n    struct Distribution {\r\n        uint256 pendingBatchCount;\r\n        bool hasPendingBatches;\r\n        bytes32[] batchHashes;\r\n    }\r\n\r\n    /// The Orbs token smart contract address.\r\n    IStakingContract public staking;\r\n\r\n    /// The Orbs token smart contract address.\r\n    IERC20 public orbs;\r\n\r\n    /// Mapping of all ongoing distribution events.\r\n    /// Distribution events are identified by a unique string\r\n    /// for the duration of their execution.\r\n    /// After completion or abortion the same name may be used again.\r\n    mapping(string => Distribution) distributions;\r\n\r\n    /// Address of an optional rewards-distributor account/contract.\r\n    /// Meant to be used in the future, should an alternate implementation of\r\n    /// batch commitment mechanism will be needed. Alternately, manual\r\n    /// transfers without batch commitment may be executed by rewardsDistributor.\r\n    /// Only the address of rewardsDistributor may call distributeRewards()\r\n    address public rewardsDistributor;\r\n\r\n    /// Constructor to set Orbs token contract address.\r\n    /// @param _orbs IERC20 The address of the Orbs token contract.\r\n    constructor(IStakingContract _staking, IERC20 _orbs) public {\r\n        require(address(_orbs) != address(0), \"Address must not be 0!\");\r\n        require(address(_staking) != address(0), \"Address must not be 0!\");\r\n\r\n        rewardsDistributor = address(0);\r\n        orbs = _orbs;\r\n        staking = _staking;\r\n    }\r\n\r\n    /// Announce a new distribution event, and commits to a list of transfer batch\r\n    /// hashes. Only the contract owner may call this method. The method verifies\r\n    /// a distributionEvent with the same name is not currently ongoing.\r\n    /// It then records commitments for all reward payments in the form of batch\r\n    /// hashes array to state.\r\n    /// @param _distributionEvent string Name of a new distribution event\r\n    /// @param _batchHashes bytes32[] The address of the OrbsValidators contract.\r\n    function announceDistributionEvent(string _distributionEvent, bytes32[] _batchHashes) external onlyOwner {\r\n        require(!distributions[_distributionEvent].hasPendingBatches, \"distribution event is currently ongoing\");\r\n        require(_batchHashes.length > 0, \"at least one batch must be announced\");\r\n\r\n        for (uint256 i = 0; i < _batchHashes.length; i++) {\r\n            require(_batchHashes[i] != bytes32(0), \"batch hash may not be 0x0\");\r\n        }\r\n\r\n        // store distribution event record\r\n        Distribution storage distribution = distributions[_distributionEvent];\r\n        distribution.pendingBatchCount = _batchHashes.length;\r\n        distribution.hasPendingBatches = true;\r\n        distribution.batchHashes = _batchHashes;\r\n\r\n        emit RewardsDistributionAnnounced(_distributionEvent, _batchHashes, _batchHashes.length);\r\n    }\r\n\r\n    /// Aborts an ongoing distributionEvent and revokes all batch commitments.\r\n    /// Only the contract owner may call this method.\r\n    /// @param _distributionEvent string Name of a new distribution event\r\n    function abortDistributionEvent(string _distributionEvent) external onlyOwner {\r\n        require(distributions[_distributionEvent].hasPendingBatches, \"distribution event is not currently ongoing\");\r\n\r\n        (bytes32[] memory abortedBatchHashes, uint256[] memory abortedBatchIndices) = this.getPendingBatches(_distributionEvent);\r\n\r\n        delete distributions[_distributionEvent];\r\n\r\n        emit RewardsDistributionAborted(_distributionEvent, abortedBatchHashes, abortedBatchIndices);\r\n    }\r\n\r\n    /// Distributes the rewards to staking contract for each recipient\r\n    /// Carry out and log transfers in batch. receives two arrays of same length\r\n    /// representing rewards payments for a list of reward recipients.\r\n    /// distributionEvent is only provided for logging purposes.\r\n    /// @param _distributionEvent string Name of a new distribution event\r\n    /// @param _recipients address[] a list of recipients addresses\r\n    /// @param _amounts uint256[] a list of amounts to transfer each recipient at the corresponding array index\r\n    function _distributeRewards(string _distributionEvent, address[] _recipients, uint256[] _amounts) private {\r\n        uint256 batchSize = _recipients.length;\r\n        require(batchSize == _amounts.length, \"array length mismatch\");\r\n\r\n        address[] memory tempRecipientArr = new address[](1);\r\n        uint256[] memory tempAmountArr = new uint256[](1);\r\n\r\n        for (uint256 i = 0; i < batchSize; i++) {\r\n            if (_amounts[i] == 0) {\r\n                emit RewardDistributed(_distributionEvent, _recipients[i], 0);\r\n                continue; // staking contract does not accept 0 amounts\r\n            }\r\n\r\n            require(_recipients[i] != address(0), \"recipient must be a valid address\");\r\n\r\n            orbs.approve(staking, _amounts[i]);\r\n\r\n            tempRecipientArr[0] = _recipients[i];\r\n            tempAmountArr[0] = _amounts[i];\r\n\r\n            staking.distributeRewards(tempAmountArr[0], tempRecipientArr, tempAmountArr);\r\n\r\n            emit RewardDistributed(_distributionEvent, _recipients[i], _amounts[i]);\r\n        }\r\n    }\r\n\r\n    /// Perform a single batch transfer, bypassing announcement/commitment flow.\r\n    /// Only the assigned rewardsDistributor account may call this method.\r\n    /// Provided to allow another contract or user to implement an alternative\r\n    /// batch commitment mechanism, should on be needed in the future.\r\n    /// @param _distributionEvent string Name of a new distribution event\r\n    /// @param _recipients address[] a list of recipients addresses\r\n    /// @param _amounts uint256[] a list of amounts to transfer each recipient at the corresponding array index\r\n    function distributeRewards(string _distributionEvent, address[] _recipients, uint256[] _amounts) external onlyRewardsDistributor {\r\n        _distributeRewards(_distributionEvent, _recipients, _amounts);\r\n    }\r\n\r\n    /// Accepts a batch of payments associated with a distributionEvent.\r\n    /// The batch will be executed only if it matches the commitment hash\r\n    /// published by this contract's owner in a previous\r\n    /// announceDistributionEvent() call. Once validated against an existing\r\n    /// batch hash commitment, the commitment is cleared to ensure the batch\r\n    /// cannot be executed twice.\r\n    /// If this was the last batch in distributionEvent, the event record is\r\n    /// cleared logged as completed.\r\n    /// @param _distributionEvent string Name of a new distribution event\r\n    /// @param _recipients address[] a list of recipients addresses\r\n    /// @param _amounts uint256[] a list of amounts to transfer each recipient at the corresponding array index\r\n    /// @param _batchIndex uint256 index of the specified batch in commitments array\r\n    function executeCommittedBatch(string _distributionEvent, address[] _recipients, uint256[] _amounts, uint256 _batchIndex) external {\r\n        Distribution storage distribution = distributions[_distributionEvent];\r\n        bytes32[] storage batchHashes = distribution.batchHashes;\r\n\r\n        require(_recipients.length == _amounts.length, \"array length mismatch\");\r\n        require(_recipients.length > 0, \"at least one reward must be included in a batch\");\r\n        require(distribution.hasPendingBatches, \"distribution event is not currently ongoing\");\r\n        require(batchHashes.length > _batchIndex, \"batch number out of range\");\r\n        require(batchHashes[_batchIndex] != bytes32(0), \"specified batch number already executed\");\r\n\r\n        bytes32 calculatedHash = calcBatchHash(_recipients, _amounts, _batchIndex);\r\n        require(batchHashes[_batchIndex] == calculatedHash, \"batch hash does not match\");\r\n\r\n        distribution.pendingBatchCount--;\r\n        batchHashes[_batchIndex] = bytes32(0); // delete\r\n\r\n        if (distribution.pendingBatchCount == 0) {\r\n            delete distributions[_distributionEvent];\r\n            emit RewardsDistributionCompleted(_distributionEvent);\r\n        }\r\n        emit RewardsBatchExecuted(_distributionEvent, calculatedHash, _batchIndex);\r\n\r\n        _distributeRewards(_distributionEvent, _recipients, _amounts);\r\n    }\r\n\r\n    /// Returns all pending (not yet executed) batch hashes and indices\r\n    /// associated with a distributionEvent.\r\n    /// @param _distributionEvent string Name of a new distribution event\r\n    /// @return pendingBatchHashes bytes32[]\r\n    /// @return pendingBatchIndices uint256[]\r\n    function getPendingBatches(string _distributionEvent) external view returns (bytes32[] pendingBatchHashes, uint256[] pendingBatchIndices) {\r\n        Distribution storage distribution = distributions[_distributionEvent];\r\n        bytes32[] storage batchHashes = distribution.batchHashes;\r\n        uint256 pendingBatchCount = distribution.pendingBatchCount;\r\n        uint256 batchHashesLength = distribution.batchHashes.length;\r\n\r\n        pendingBatchHashes = new bytes32[](pendingBatchCount);\r\n        pendingBatchIndices = new uint256[](pendingBatchCount);\r\n\r\n        uint256 addNextAt = 0;\r\n        for (uint256 i = 0; i < batchHashesLength; i++) {\r\n            bytes32 hash = batchHashes[i];\r\n            if (hash != bytes32(0)) {\r\n                pendingBatchIndices[addNextAt] = i;\r\n                pendingBatchHashes[addNextAt] = hash;\r\n                addNextAt++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// For disaster recovery purposes. transfers all orbs from this contract to owner.\r\n    /// Only the contract owner may call this method.\r\n    /// Transfers away any Orbs balance from this contract to the owners address\r\n    function drainOrbs() external onlyOwner {\r\n        uint256 balance = orbs.balanceOf(address(this));\r\n        orbs.transfer(owner(), balance);\r\n    }\r\n\r\n    /// Assigns a new rewards-distributor account.\r\n    /// To revoke the current rewards-distributor's rights call this method with 0x0.\r\n    /// Only the contract owner may call this method.\r\n    /// @param _newRewardsDistributor The address to set as the new rewards-distributor.\r\n    function reassignRewardsDistributor(address _newRewardsDistributor) external onlyOwner {\r\n        emit RewardsDistributorReassigned(rewardsDistributor, _newRewardsDistributor);\r\n        rewardsDistributor = _newRewardsDistributor;\r\n    }\r\n\r\n    /// Return true if `msg.sender` is the assigned rewards-distributor.\r\n    function isRewardsDistributor() public view returns(bool) {\r\n        return msg.sender == rewardsDistributor;\r\n    }\r\n\r\n    /// Throws if called by any account other than the rewards-distributor.\r\n    modifier onlyRewardsDistributor() {\r\n        require(isRewardsDistributor(), \"only the assigned rewards-distributor may call this method\");\r\n        _;\r\n    }\r\n\r\n    /// Computes a hash code form a batch payment specification.\r\n    /// @param _recipients address[] a list of recipients addresses\r\n    /// @param _amounts uint256[] a list of amounts to transfer each recipient at the corresponding array index\r\n    /// @param _batchIndex uint256 index of the specified batch in commitments array\r\n    function calcBatchHash(address[] _recipients, uint256[] _amounts, uint256 _batchIndex) private pure returns (bytes32) {\r\n        bytes memory batchData = abi.encodePacked(_batchIndex, _recipients.length, _recipients, _amounts);\r\n\r\n        uint256 expectedLength = 32 * (2 + _recipients.length + _amounts.length);\r\n        require(batchData.length == expectedLength, \"unexpected data length\");\r\n\r\n        return keccak256(batchData);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newRewardsDistributor\",\"type\":\"address\"}],\"name\":\"reassignRewardsDistributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_distributionEvent\",\"type\":\"string\"},{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"distributeRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsDistributor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_distributionEvent\",\"type\":\"string\"},{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_batchIndex\",\"type\":\"uint256\"}],\"name\":\"executeCommittedBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drainOrbs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_distributionEvent\",\"type\":\"string\"},{\"name\":\"_batchHashes\",\"type\":\"bytes32[]\"}],\"name\":\"announceDistributionEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRewardsDistributor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orbs\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_distributionEvent\",\"type\":\"string\"}],\"name\":\"abortDistributionEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_distributionEvent\",\"type\":\"string\"}],\"name\":\"getPendingBatches\",\"outputs\":[{\"name\":\"pendingBatchHashes\",\"type\":\"bytes32[]\"},{\"name\":\"pendingBatchIndices\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_staking\",\"type\":\"address\"},{\"name\":\"_orbs\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"distributionEvent\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"distributionEvent\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"batchHash\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"batchCount\",\"type\":\"uint256\"}],\"name\":\"RewardsDistributionAnnounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"distributionEvent\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"batchHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"batchIndex\",\"type\":\"uint256\"}],\"name\":\"RewardsBatchExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"distributionEvent\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"abortedBatchHashes\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"abortedBatchIndices\",\"type\":\"uint256[]\"}],\"name\":\"RewardsDistributionAborted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"distributionEvent\",\"type\":\"string\"}],\"name\":\"RewardsDistributionCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousRewardsDistributor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newRewardsDistributor\",\"type\":\"address\"}],\"name\":\"RewardsDistributorReassigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OrbsRewardsDistributionForStaking","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000001d59af68e2dcb44e04c50e05f62e7043f2656c3000000000000000000000000ff56cc6b1e6ded347aa0b7676c85ab0b3d08b0fa","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a3bec3edf50a7288e2298cb51f07da3b9ed98873d04e441649b3b6158c44d0ed"}]}