{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function owner() external view returns (address);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ISushiSwapPoolNames {\n    function logos(uint256) external view returns(string memory);\n    function names(uint256) external view returns(string memory);\n    function setPoolInfo(uint256 pid, string memory logo, string memory name) external;\n}\n\ninterface ISushiToken is IERC20{\n    function delegates(address who) external view returns(address);\n    function getCurrentVotes(address who) external view returns(uint256);\n    function nonces(address who) external view returns(uint256);\n}\n\ninterface IMasterChef {\n    function BONUS_MULTIPLIER() external view returns (uint256);\n    function bonusEndBlock() external view returns (uint256);\n    function devaddr() external view returns (address);\n    function migrator() external view returns (address);\n    function owner() external view returns (address);\n    function startBlock() external view returns (uint256);\n    function sushi() external view returns (address);\n    function sushiPerBlock() external view returns (uint256);\n    function totalAllocPoint() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function poolInfo(uint256 nr) external view returns (address, uint256, uint256, uint256);\n    function userInfo(uint256 nr, address who) external view returns (uint256, uint256);\n    function pendingSushi(uint256 nr, address who) external view returns (uint256);\n}\n\ninterface IFactory {\n    function getPair(address token0, address token1) external view returns (address);\n}\n\ninterface IPair is IERC20 {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112, uint112, uint32);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"Overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"Underflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"Mul Overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"Div by 0\");\n        uint256 c = a / b;\n\n        return c;\n    }\n}\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract BoringCryptoTokenScanner is Ownable\n{\n    using SafeMath for uint256;\n\n    mapping(uint256 => address) public tokens;\n    uint256 public tokenCount;\n\n    function add(address token) public onlyOwner {\n        tokens[tokenCount] = token;\n        tokenCount++;\n    }\n    \n    function change(uint256 id, address token) public onlyOwner {\n        tokens[id] = token;\n    }\n    \n    function remove() public onlyOwner {\n        tokenCount--;\n        tokens[tokenCount] = address(0);\n    }\n\n    struct Balance {\n        address token;\n        uint256 balance;\n    }\n    \n    struct TokenInfo {\n        address token;\n        uint256 decimals;\n        string name;\n        string symbol;\n    }\n\n    function getInfo(address[] calldata extra) public view returns(TokenInfo[] memory) {\n        TokenInfo[] memory infos = new TokenInfo[](tokenCount + extra.length);\n\n        for (uint256 i = 0; i < tokenCount; i++) {\n            IERC20 token = IERC20(tokens[i]);\n            infos[i].token = address(token);\n            infos[i].decimals = token.decimals();\n            infos[i].name = token.name();\n            infos[i].symbol = token.symbol();\n        }\n\n        for (uint256 i = 0; i < extra.length; i++) {\n            IERC20 token = IERC20(extra[i]);\n            uint256 index = tokenCount + i;\n            infos[index].token = address(token);\n            infos[index].decimals = token.decimals();\n            infos[index].name = token.name();\n            infos[index].symbol = token.symbol();\n        }\n\n        return infos;\n    }\n\n    function getSpecificInfo(address[] calldata extra) public view returns(TokenInfo[] memory) {\n        TokenInfo[] memory infos = new TokenInfo[](extra.length);\n\n        for (uint256 i = 0; i < extra.length; i++) {\n            IERC20 token = IERC20(extra[i]);\n            infos[i].token = address(token);\n            infos[i].decimals = token.decimals();\n            infos[i].name = token.name();\n            infos[i].symbol = token.symbol();\n        }\n\n        return infos;\n    }\n\n    function getBalances(address who, address[] calldata extra) public view returns(Balance[] memory) {\n        Balance[] memory balances = new Balance[](tokenCount + extra.length);\n\n        for (uint256 i = 0; i < tokenCount; i++) {\n            IERC20 token = IERC20(tokens[i]);\n            balances[i].token = address(token);\n            balances[i].balance = token.balanceOf(who);\n        }\n        \n        for (uint256 i = 0; i < extra.length; i++) {\n            IERC20 token = IERC20(extra[i]);\n            balances[tokenCount + i].token = address(token);\n            balances[tokenCount + i].balance = token.balanceOf(who);\n        }\n        \n        return balances;\n    }\n\n    function getSpecificBalances(address who, address[] calldata extra) public view returns(Balance[] memory) {\n        Balance[] memory balances = new Balance[](extra.length);\n\n        for (uint256 i = 0; i < extra.length; i++) {\n            IERC20 token = IERC20(extra[i]);\n            balances[i].token = address(token);\n            balances[i].balance = token.balanceOf(who);\n        }\n        \n        return balances;\n    }\n}\n\n\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"change\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"extra\",\"type\":\"address[]\"}],\"name\":\"getBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoTokenScanner.Balance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"extra\",\"type\":\"address[]\"}],\"name\":\"getInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct BoringCryptoTokenScanner.TokenInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"extra\",\"type\":\"address[]\"}],\"name\":\"getSpecificBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoTokenScanner.Balance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"extra\",\"type\":\"address[]\"}],\"name\":\"getSpecificInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct BoringCryptoTokenScanner.TokenInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BoringCryptoTokenScanner","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}