{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @emilianobonassi/gas-saver/ChiGasSaver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract IFreeFromUpTo is IERC20 {\r\n    function freeFromUpTo(address from, uint256 value) external returns(uint256 freed);\r\n}\r\n\r\n\r\ncontract ChiGasSaver {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    modifier saveGas(address payable sponsor) {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\r\n\r\n        IFreeFromUpTo chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n        chi.freeFromUpTo(sponsor, (gasSpent + 14154) / 41947);\r\n    }\r\n}\r\n\r\n// File: contracts/GasTokenRefundModuleV2.sol\r\n\r\n// File: @gnosis.pm/safe-contracts/contracts/common/SelfAuthorized.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n/// @title SelfAuthorized - authorizes current contract to perform actions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/safe-contracts/contracts/common/MasterCopy.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n\r\n/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\r\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract MasterCopy is SelfAuthorized {\r\n\r\n    event ChangedMasterCopy(address masterCopy);\r\n\r\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n    // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address private masterCopy;\r\n\r\n    /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n    /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n    public\r\n    authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n        emit ChangedMasterCopy(_masterCopy);\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/safe-contracts/contracts/common/Enum.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n/// @title Enum - Collection of enums\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/safe-contracts/contracts/base/Executor.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n\r\n/// @title Executor - A contract that can execute transactions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Executor {\r\n\r\n    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\r\n    internal\r\n    returns (bool success)\r\n    {\r\n        if (operation == Enum.Operation.Call)\r\n            success = executeCall(to, value, data, txGas);\r\n        else if (operation == Enum.Operation.DelegateCall)\r\n            success = executeDelegateCall(to, data, txGas);\r\n        else\r\n            success = false;\r\n    }\r\n\r\n    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\r\n    internal\r\n    returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\r\n    internal\r\n    returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/safe-contracts/contracts/base/ModuleManager.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract ModuleManager is SelfAuthorized, Executor {\r\n\r\n    event EnabledModule(Module module);\r\n    event DisabledModule(Module module);\r\n    event ExecutionFromModuleSuccess(address indexed module);\r\n    event ExecutionFromModuleFailure(address indexed module);\r\n\r\n    address internal constant SENTINEL_MODULES = address(0x1);\r\n\r\n    mapping (address => address) internal modules;\r\n\r\n    function setupModules(address to, bytes memory data)\r\n    internal\r\n    {\r\n        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != address(0))\r\n        // Setup has to complete successfully or transaction fails.\r\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\r\n    }\r\n\r\n    /// @dev Allows to add a module to the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param module Module to be whitelisted.\r\n    function enableModule(Module module)\r\n    public\r\n    authorized\r\n    {\r\n        // Module address cannot be null or sentinel.\r\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        // Module cannot be added twice.\r\n        require(modules[address(module)] == address(0), \"Module has already been added\");\r\n        modules[address(module)] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = address(module);\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows to remove a module from the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(Module prevModule, Module module)\r\n    public\r\n    authorized\r\n    {\r\n        // Validate module address and check that it corresponds to module index.\r\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\r\n        modules[address(prevModule)] = modules[address(module)];\r\n        modules[address(module)] = address(0);\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        // Only whitelisted modules are allowed.\r\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\r\n        // Execute transaction without further confirmations.\r\n        success = execute(to, value, data, operation, gasleft());\r\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\r\n        else emit ExecutionFromModuleFailure(msg.sender);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n    public\r\n    returns (bool success, bytes memory returnData)\r\n    {\r\n        success = execTransactionFromModule(to, value, data, operation);\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n        // Load free memory location\r\n            let ptr := mload(0x40)\r\n        // We allocate memory for the return data by setting the free memory location to\r\n        // current free memory location + data size + 32 bytes for data size value\r\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\r\n        // Store the size\r\n            mstore(ptr, returndatasize())\r\n        // Store the data\r\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\r\n        // Point the return data to the correct memory location\r\n            returnData := ptr\r\n        }\r\n    }\r\n\r\n    /// @dev Returns array of first 10 modules.\r\n    /// @return Array of modules.\r\n    function getModules()\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n    {\r\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\r\n        return array;\r\n    }\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @param start Start of the page.\r\n    /// @param pageSize Maximum number of modules that should be returned.\r\n    /// @return Array of modules.\r\n    function getModulesPaginated(address start, uint256 pageSize)\r\n    public\r\n    view\r\n    returns (address[] memory array, address next)\r\n    {\r\n        // Init array with max page size\r\n        array = new address[](pageSize);\r\n\r\n        // Populate return array\r\n        uint256 moduleCount = 0;\r\n        address currentModule = modules[start];\r\n        while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\r\n            array[moduleCount] = currentModule;\r\n            currentModule = modules[currentModule];\r\n            moduleCount++;\r\n        }\r\n        next = currentModule;\r\n        // Set correct size of returned array\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            mstore(array, moduleCount)\r\n        }\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/safe-contracts/contracts/base/Module.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n\r\n\r\n/// @title Module - Base class for modules.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Module is MasterCopy {\r\n\r\n    ModuleManager public manager;\r\n\r\n    modifier authorized() {\r\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager()\r\n    internal\r\n    {\r\n        // manager can only be 0 at initalization of contract.\r\n        // Check ensures that setup function can only be called once.\r\n        require(address(manager) == address(0), \"Manager has already been set\");\r\n        manager = ModuleManager(msg.sender);\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/safe-contracts/contracts/base/OwnerManager.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract OwnerManager is SelfAuthorized {\r\n\r\n    event AddedOwner(address owner);\r\n    event RemovedOwner(address owner);\r\n    event ChangedThreshold(uint256 threshold);\r\n\r\n    address internal constant SENTINEL_OWNERS = address(0x1);\r\n\r\n    mapping(address => address) internal owners;\r\n    uint256 ownerCount;\r\n    uint256 internal threshold;\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _owners List of Safe owners.\r\n    /// @param _threshold Number of required confirmations for a Safe transaction.\r\n    function setupOwners(address[] memory _owners, uint256 _threshold)\r\n    internal\r\n    {\r\n        // Threshold can only be 0 at initialization.\r\n        // Check ensures that setup function can only be called once.\r\n        require(threshold == 0, \"Owners have already been setup\");\r\n        // Validate that threshold is smaller than number of added owners.\r\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n        // Initializing Safe owners.\r\n        address currentOwner = SENTINEL_OWNERS;\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            // Owner address cannot be null.\r\n            address owner = _owners[i];\r\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n            // No duplicate owners allowed.\r\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\r\n            owners[currentOwner] = owner;\r\n            currentOwner = owner;\r\n        }\r\n        owners[currentOwner] = SENTINEL_OWNERS;\r\n        ownerCount = _owners.length;\r\n        threshold = _threshold;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param owner New owner address.\r\n    /// @param _threshold New threshold.\r\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\r\n    public\r\n    authorized\r\n    {\r\n        // Owner address cannot be null.\r\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        // No duplicate owners allowed.\r\n        require(owners[owner] == address(0), \"Address is already an owner\");\r\n        owners[owner] = owners[SENTINEL_OWNERS];\r\n        owners[SENTINEL_OWNERS] = owner;\r\n        ownerCount++;\r\n        emit AddedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold)\r\n            changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n    /// @param owner Owner address to be removed.\r\n    /// @param _threshold New threshold.\r\n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\r\n    public\r\n    authorized\r\n    {\r\n        // Only allow to remove an owner, if threshold can still be reached.\r\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\r\n        // Validate owner address and check that it corresponds to owner index.\r\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\r\n        owners[prevOwner] = owners[owner];\r\n        owners[owner] = address(0);\r\n        ownerCount--;\r\n        emit RemovedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold)\r\n            changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n    /// @param oldOwner Owner address to be replaced.\r\n    /// @param newOwner New owner address.\r\n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\r\n    public\r\n    authorized\r\n    {\r\n        // Owner address cannot be null.\r\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        // No duplicate owners allowed.\r\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\r\n        // Validate oldOwner address and check that it corresponds to owner index.\r\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\r\n        owners[newOwner] = owners[oldOwner];\r\n        owners[prevOwner] = newOwner;\r\n        owners[oldOwner] = address(0);\r\n        emit RemovedOwner(oldOwner);\r\n        emit AddedOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to update the number of required confirmations by Safe owners.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param _threshold New threshold.\r\n    function changeThreshold(uint256 _threshold)\r\n    public\r\n    authorized\r\n    {\r\n        // Validate that threshold is smaller than number of owners.\r\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n        threshold = _threshold;\r\n        emit ChangedThreshold(threshold);\r\n    }\r\n\r\n    function getThreshold()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return threshold;\r\n    }\r\n\r\n    function isOwner(address owner)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\r\n    }\r\n\r\n    /// @dev Returns array of owners.\r\n    /// @return Array of Safe owners.\r\n    function getOwners()\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n    {\r\n        address[] memory array = new address[](ownerCount);\r\n\r\n        // populate return array\r\n        uint256 index = 0;\r\n        address currentOwner = owners[SENTINEL_OWNERS];\r\n        while(currentOwner != SENTINEL_OWNERS) {\r\n            array[index] = currentOwner;\r\n            currentOwner = owners[currentOwner];\r\n            index ++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\n\r\n/// @title GasToken Refund Module - Allows to execute transactions using CHI Gas Tokens.\r\n/// @author Emiliano Bonassi - <bonassi.emiliano@gmail.com>\r\ncontract GasTokenRefundModuleV2 is Module, ChiGasSaver {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant NAME = \"GasToken Refund Module\";\r\n    string public constant VERSION = \"2.0.0\";\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _manager Address of the manager, the safe contract.\r\n    function setup(address payable _manager) public {\r\n        require(address(manager) == address(0), \"Manager has already been set\");\r\n        if (_manager == address(0)) {\r\n            manager = ModuleManager(msg.sender);\r\n        } else {\r\n            manager = ModuleManager(_manager);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns if executed correctly.\r\n    /// @param to Recipient.\r\n    /// @param value Value.\r\n    /// @param data Data.\r\n    /// @return Returns if transaction can be executed.\r\n    function executeWithGasTokenRefund(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    )\r\n    public\r\n    saveGas(address(uint160(address(manager))))\r\n    returns (bool) {\r\n        // Only Safe owners are allowed to execute transactions.\r\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \"Method can only be called by an owner\");\r\n        require(manager.execTransactionFromModule(to, value, data, Enum.Operation.Call), \"Could not execute transaction\");\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"masterCopy\",\"type\":\"address\"}],\"name\":\"ChangedMasterCopy\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterCopy\",\"type\":\"address\"}],\"name\":\"changeMasterCopy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeWithGasTokenRefund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract ModuleManager\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GasTokenRefundModuleV2","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://967582ec12a86ed47bc02f62f012a01f149a02905bad9c6bc6aaf04878fdd014"}]}