{"status":"1","message":"OK","result":[{"SourceCode":"{\"Governance.sol\":{\"content\":\"pragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../SafeMath.sol\\\";\\nimport \\\"../NamedContract.sol\\\";\\nimport \\\"./GovernanceStorage.sol\\\";\\nimport \\\"./IGovernanceTimelock.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\nimport \\\"./GovernanceEvent.sol\\\";\\n\\n/// @title Governance Contract\\ncontract Governance is NamedContract, GovernanceStorage, GovernanceEvent {\\n    using SafeMath for uint256;\\n\\n    constructor() public {\\n        setContractName(\\u0027Swipe Governance\\u0027);\\n    }\\n\\n    function initialize(\\n        address timelockAddress,\\n        address stakingAddress,\\n        address guardian\\n    ) external {\\n        require(\\n            !_initialized,\\n            \\\"Contract has been already initialized\\\"\\n        );\\n\\n        _timelock = IGovernanceTimelock(timelockAddress);\\n        _staking = IStaking(stakingAddress);\\n        _guardian = guardian;\\n\\n        _initialized = true;\\n\\n        emit Initialize(\\n            timelockAddress,\\n            stakingAddress,\\n            _guardian\\n        );\\n    }\\n\\n    /**\\n     * @notice Authorizes the transfer of guardianship from guardian to the provided address.\\n     * NOTE: No transfer will occur unless authorizedAddress calls assumeGuardianship( ).\\n     * This authorization may be removed by another call to this function authorizing\\n     * the null address.\\n     *\\n     * @param authorizedAddress The address authorized to become the new guardian.\\n     */\\n    function authorizeGuardianshipTransfer(address authorizedAddress) external {\\n        require(\\n            msg.sender == _guardian,\\n            \\\"Only the guardian can authorize a new address to become guardian\\\"\\n        );\\n\\n        _authorizedNewGuardian = authorizedAddress;\\n\\n        emit GuardianshipTransferAuthorization(_authorizedNewGuardian);\\n    }\\n\\n    /**\\n     * @notice Transfers guardianship of this contract to the _authorizedNewGuardian.\\n     */\\n    function assumeGuardianship() external {\\n        require(\\n            msg.sender == _authorizedNewGuardian,\\n            \\\"Only the authorized new guardian can accept guardianship\\\"\\n        );\\n\\n        address oldValue = _guardian;\\n        _guardian = _authorizedNewGuardian;\\n        _authorizedNewGuardian = address(0);\\n\\n        emit GuardianUpdate(\\n            oldValue,\\n            _guardian\\n        );\\n    }\\n\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    function setQuorumVotes(uint256 quorumVotes) external {\\n        require(\\n            msg.sender == _guardian,\\n            \\\"Only the guardian can set quorum votes\\\"\\n        );\\n\\n        uint256 oldValue = _quorumVotes;\\n        _quorumVotes = quorumVotes; \\n\\n        emit QuorumVotesUpdate(\\n            oldValue,\\n            _quorumVotes\\n        );\\n    }\\n\\n    /// @notice The number of votes required in order for a voter to become a proposer\\n    function setProposalThreshold(uint256 proposalThreshold) external {\\n        require(\\n            msg.sender == _guardian,\\n            \\\"Only the guardian can set proposal threshold\\\"\\n        );\\n\\n        uint256 oldValue = _proposalThreshold;\\n        _proposalThreshold = proposalThreshold; \\n\\n        emit ProposalThresholdUpdate(\\n            oldValue,\\n            _proposalThreshold\\n        );\\n    }\\n\\n    /// @notice The maximum number of actions that can be included in a proposal\\n    function setProposalMaxOperations(uint256 proposalMaxOperations) external {\\n        require(\\n            msg.sender == _guardian,\\n            \\\"Only the guardian can set proposal max operations\\\"\\n        );\\n\\n        uint256 oldValue = _proposalMaxOperations;\\n        _proposalMaxOperations = proposalMaxOperations; \\n\\n        emit ProposalMaxOperationsUpdate(\\n            oldValue,\\n            _proposalMaxOperations\\n        );\\n    }\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed\\n    function setVotingDelay(uint256 votingDelay) external {\\n        require(\\n            msg.sender == _guardian,\\n            \\\"Only the guardian can set voting delay\\\"\\n        );\\n\\n        uint256 oldValue = _votingDelay;\\n        _votingDelay = votingDelay; \\n\\n        emit VotingDelayUpdate(\\n            oldValue,\\n            _votingDelay\\n        );\\n    }\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    function setVotingPeriod(uint256 votingPeriod) external {\\n        require(\\n            msg.sender == _guardian,\\n            \\\"Only the guardian can set voting period\\\"\\n        );\\n\\n        uint256 oldValue = _votingPeriod;\\n        _votingPeriod = votingPeriod; \\n\\n        emit VotingPeriodUpdate(\\n            oldValue,\\n            _votingPeriod\\n        );\\n    }\\n\\n    function internalGetVotingPower(address voter, uint256 blockNumber) internal view returns (uint256 votingPower) {\\n        votingPower = _staking.getPriorStakedAmount(voter, blockNumber);\\n    }\\n\\n    function propose(\\n        address[] memory targets,\\n        uint256[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas,\\n        string memory description\\n    ) public returns (uint256) {\\n        require(\\n            internalGetVotingPower(msg.sender, 0) \\u003e= _proposalThreshold,\\n            \\\"The proposer votes below proposal threshold\\\"\\n        );\\n\\n        require(\\n            targets.length == values.length \\u0026\\u0026 targets.length == signatures.length \\u0026\\u0026 targets.length == calldatas.length,\\n            \\\"Operation parameters mismatch\\\"\\n        );\\n\\n        require(\\n            targets.length \\u003c= _proposalMaxOperations,\\n            \\\"Too many operations\\\"\\n        );\\n\\n        uint256 latestProposalId = _latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n            ProposalState proposersLatestProposalState = state(latestProposalId);\\n            \\n            require(\\n                proposersLatestProposalState != ProposalState.Active,\\n                \\\"One live proposal per proposer, found an already active proposal\\\"\\n            );\\n            \\n            require(\\n                proposersLatestProposalState != ProposalState.Pending,\\n                \\\"One live proposal per proposer, found an already pending proposal\\\"\\n            );\\n        }\\n\\n        uint256 startBlock = block.number.add(_votingDelay);\\n        uint256 endBlock = startBlock.add(_votingPeriod);\\n\\n        _proposalCount++;\\n        Proposal memory newProposal = Proposal({\\n            id: _proposalCount,\\n            proposer: msg.sender,\\n            eta: 0,\\n            targets: targets,\\n            values: values,\\n            signatures: signatures,\\n            calldatas: calldatas,\\n            startBlock: startBlock,\\n            endBlock: endBlock,\\n            upVotes: 0,\\n            downVotes: 0,\\n            canceled: false,\\n            executed: false,\\n            voterCount: 0\\n        });\\n\\n        _proposals[newProposal.id] = newProposal;\\n        _latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n        emit ProposalCreation(\\n            newProposal.id,\\n            msg.sender,\\n            targets,\\n            values,\\n            signatures,\\n            calldatas,\\n            startBlock,\\n            endBlock,\\n            description\\n        );\\n\\n        return newProposal.id;\\n    }\\n\\n    function queue(uint256 proposalId) external {\\n        require(\\n            internalUpdateState(proposalId) == ProposalState.Succeeded,\\n            \\\"Proposal can only be queued if it is succeeded\\\"\\n        );\\n\\n        Proposal storage proposal = _proposals[proposalId];\\n        uint256 eta = block.timestamp.add(_timelock._delay());\\n        for (uint i = 0; i \\u003c proposal.targets.length; i++) {\\n            internalQueueOrRevert(\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                eta\\n            );\\n        }\\n        proposal.eta = eta;\\n\\n        emit ProposalQueue(proposalId, eta);\\n    }\\n\\n    function internalQueueOrRevert(\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data,\\n        uint256 eta\\n    ) internal {\\n        require(\\n            !_timelock._queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\\n            \\\"The proposal operation already queued at eta\\\"\\n        );\\n\\n        _timelock.queueTransaction(\\n            target,\\n            value,\\n            signature,\\n            data,\\n            eta\\n        );\\n    }\\n\\n    function execute(uint256 proposalId) external payable {\\n        require(\\n            state(proposalId) == ProposalState.Queued,\\n            \\\"Proposal can only be executed if it is queued\\\"\\n        );\\n\\n        Proposal storage proposal = _proposals[proposalId];\\n        proposal.executed = true;\\n        for (uint256 i = 0; i \\u003c proposal.targets.length; i++) {\\n            _timelock.executeTransaction.value(\\n                proposal.values[i]\\n            )(\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                proposal.eta\\n            );\\n        }\\n\\n        emit ProposalExecution(proposalId);\\n    }\\n\\n    function cancel(uint256 proposalId) external {\\n        Proposal storage proposal = _proposals[proposalId];\\n\\n        require(\\n            msg.sender == _guardian || internalGetVotingPower(proposal.proposer, proposal.endBlock) \\u003c _proposalThreshold,\\n            \\\"The proposer does not meet threshold\\\"\\n        );\\n\\n        require(\\n            internalUpdateState(proposalId) != ProposalState.Executed,\\n            \\\"Cannot cancel executed proposal\\\"\\n        );\\n\\n        proposal.canceled = true;\\n        for (uint i = 0; i \\u003c proposal.targets.length; i++) {\\n            _timelock.cancelTransaction(\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                proposal.eta\\n            );\\n        }\\n\\n        emit ProposalCancel(proposalId);\\n    }\\n\\n    function getProposal(uint256 proposalId) external view returns (\\n        uint256 id,\\n        address proposer,\\n        uint256 eta,\\n        uint256 startBlock,\\n        uint256 endBlock,\\n        uint256 upVotes,\\n        uint256 downVotes,\\n        bool canceled,\\n        bool executed\\n    ) {\\n        Proposal storage proposal = _proposals[proposalId];\\n\\n        (uint256 priorUpVotes, uint256 priorDownVotes) = getVotes(proposalId);\\n\\n        return (\\n            proposal.id,\\n            proposal.proposer,\\n            proposal.eta,\\n            proposal.startBlock,\\n            proposal.endBlock,\\n            priorUpVotes,\\n            priorDownVotes,\\n            proposal.canceled,\\n            proposal.executed\\n        );\\n    }\\n\\n    function getOperations(uint256 proposalId) external view returns (\\n        address[] memory targets,\\n        uint256[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas\\n    ) {\\n        Proposal storage proposal = _proposals[proposalId];\\n        \\n        return (\\n            proposal.targets,\\n            proposal.values,\\n            proposal.signatures,\\n            proposal.calldatas\\n        );\\n    }\\n\\n    function getVoters(uint256 proposalId) external view returns (uint256 voterCount, address[] memory voters) {\\n        Proposal storage proposal = _proposals[proposalId];\\n\\n        voterCount = proposal.voterCount;\\n        voters = new address[](proposal.voterCount);\\n        for (uint i = 0; i \\u003c proposal.voterCount; i++) {\\n            voters[i] = proposal.voters[i];\\n        }\\n    }\\n\\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\\n        Proposal storage proposal = _proposals[proposalId];\\n\\n        Receipt memory receipt = proposal.receipts[voter];\\n        receipt.votes = internalGetVotingPower(voter, proposal.endBlock);\\n        \\n        return receipt;\\n    }\\n\\n    function getVotes(uint256 proposalId) public view returns (uint256 upVotes, uint256 downVotes) {\\n        Proposal storage proposal = _proposals[proposalId];\\n\\n        for (uint i = 0; i \\u003c proposal.voterCount; i++) {\\n            address voter = proposal.voters[i];\\n            Receipt storage receipt = proposal.receipts[voter];\\n            uint256 votes = internalGetVotingPower(voter, proposal.endBlock);\\n            if (receipt.support) {\\n                upVotes = upVotes.add(votes);\\n            } else {\\n                downVotes = downVotes.add(votes);\\n            }\\n        }\\n    }\\n\\n    function internalUpdateState(uint256 proposalId) internal returns (ProposalState) {\\n        require(\\n            _proposalCount \\u003e= proposalId \\u0026\\u0026 proposalId \\u003e 0,\\n            \\\"Invalid proposal id\\\"\\n        );\\n\\n        Proposal storage proposal = _proposals[proposalId];\\n\\n        uint256 upVotes;\\n        uint256 downVotes;\\n        for (uint i = 0; i \\u003c proposal.voterCount; i++) {\\n            address voter = proposal.voters[i];\\n            Receipt storage receipt = proposal.receipts[voter];\\n            uint256 votingPower = internalGetVotingPower(voter, proposal.endBlock);\\n            receipt.votes = votingPower;\\n            if (receipt.support) {\\n                upVotes = upVotes.add(votingPower);\\n            } else {\\n                downVotes = downVotes.add(votingPower);\\n            }\\n        }\\n\\n        proposal.upVotes = upVotes;\\n        proposal.downVotes = downVotes;\\n\\n        return internalState(proposalId, upVotes, downVotes);\\n    }\\n\\n    function state(uint256 proposalId) public view returns (ProposalState) {\\n        return internalState(proposalId, 0, 0);\\n    }\\n\\n    function internalState(uint256 proposalId, uint256 upVotes, uint256 downVotes) internal view returns (ProposalState) {\\n        require(\\n            _proposalCount \\u003e= proposalId \\u0026\\u0026 proposalId \\u003e 0,\\n            \\\"Invalid proposal id\\\"\\n        );\\n\\n        Proposal storage proposal = _proposals[proposalId];\\n        if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (block.number \\u003c= proposal.startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number \\u003c= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else {\\n            if (upVotes == 0 \\u0026\\u0026 downVotes == 0) {\\n                (upVotes, downVotes) = getVotes(proposalId);\\n            }\\n            if (upVotes \\u003c= downVotes || upVotes \\u003c _quorumVotes) {\\n                return ProposalState.Defeated;\\n            } else if (proposal.eta == 0) {\\n                return ProposalState.Succeeded;\\n            } else if (proposal.executed) {\\n                return ProposalState.Executed;\\n            } else if (block.timestamp \\u003e= proposal.eta.add(_timelock._gracePeriod())) {\\n                return ProposalState.Expired;\\n            } else {\\n                return ProposalState.Queued;\\n            }\\n        }\\n    }\\n\\n    function castVote(uint256 proposalId, bool support) external {\\n        return internalCastVote(msg.sender, proposalId, support);\\n    }\\n\\n    function castVoteBySig(\\n        uint256 proposalId,\\n        bool support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        bytes32 domainSeparator = keccak256(abi.encode(_domainTypeHash, keccak256(bytes(name)), internalGetChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(_ballotTypeHash, proposalId, support));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        \\n        require(\\n            signatory != address(0),\\n            \\\"Invalid signature\\\"\\n        );\\n\\n        return internalCastVote(\\n            signatory,\\n            proposalId,\\n            support\\n        );\\n    }\\n\\n    function internalCastVote(\\n        address voter,\\n        uint256 proposalId,\\n        bool support\\n    ) internal {\\n        require(\\n            state(proposalId) == ProposalState.Active,\\n            \\\"Voting is closed\\\"\\n        );\\n\\n        Proposal storage proposal = _proposals[proposalId];\\n        Receipt storage receipt = proposal.receipts[voter];\\n\\n        require(\\n            receipt.hasVoted == false,\\n            \\\"The voter already voted\\\"\\n        );\\n        \\n        uint256 votes = internalGetVotingPower(voter, proposal.endBlock);\\n\\n        require(\\n            votes \\u003e 0,\\n            \\\"The voting power is zero\\\"\\n        );\\n\\n        proposal.voters[proposal.voterCount] = voter;\\n        proposal.voterCount++;\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support;\\n        receipt.votes = votes;\\n\\n        emit Vote(\\n            voter,\\n            proposalId,\\n            support,\\n            votes\\n        );\\n    }\\n\\n    function assumeTimelockGuardianship() external {\\n        require(\\n            msg.sender == _guardian,\\n            \\\"Only the guardian can assume timelock guardianship\\\"\\n        );\\n\\n        _timelock.assumeGuardianship();\\n    }\\n\\n    function queueAuthorizeGuardianshipTransfer(address authorizedAddress, uint256 eta) external {\\n        require(\\n            msg.sender == _guardian,\\n            \\\"Only the guardian can queue timelock guardianship transfer transaction\\\"\\n        );\\n\\n        _timelock.queueTransaction(\\n            address(_timelock),\\n            0,\\n            \\\"authorizeGuardianshipTransfer(address)\\\",\\n            abi.encode(authorizedAddress),\\n            eta\\n        );\\n    }\\n\\n    function executeAuthorizeGuardianshipTransfer(address authorizedAddress, uint256 eta) external {\\n        require(\\n            msg.sender == _guardian,\\n            \\\"Only the guardian can execute timelock guardianship transfer transaction\\\"\\n        );\\n\\n        _timelock.executeTransaction(\\n            address(_timelock),\\n            0,\\n            \\\"authorizeGuardianshipTransfer(address)\\\",\\n            abi.encode(authorizedAddress),\\n            eta\\n        );\\n    }\\n\\n    function internalGetChainId() internal pure returns (uint256 chainId) {\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n}\\n\"},\"GovernanceEvent.sol\":{\"content\":\"pragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\n/// @title Governance Event Contract\\ncontract GovernanceEvent {\\n    /// @notice An event emitted when initialize\\n    event Initialize(\\n        address indexed timelockAddress,\\n        address indexed stakingAddress,\\n        address indexed guardian\\n    );\\n\\n    event GuardianshipTransferAuthorization(\\n        address indexed authorizedAddress\\n    );\\n\\n    event GuardianUpdate(\\n        address indexed oldValue,\\n        address indexed newValue\\n    );\\n\\n    event QuorumVotesUpdate(\\n        uint256 indexed oldValue,\\n        uint256 indexed newValue\\n    );\\n\\n    event ProposalThresholdUpdate(\\n        uint256 indexed oldValue,\\n        uint256 indexed newValue\\n    );\\n\\n    event ProposalMaxOperationsUpdate(\\n        uint256 indexed oldValue,\\n        uint256 indexed newValue\\n    );\\n\\n    event VotingDelayUpdate(\\n        uint256 indexed oldValue,\\n        uint256 indexed newValue\\n    );\\n\\n    event VotingPeriodUpdate(\\n        uint256 indexed oldValue,\\n        uint256 indexed newValue\\n    );\\n\\n    event ProposalCreation(\\n        uint256 indexed id,\\n        address indexed proposer,\\n        address[] targets,\\n        uint256[] values,\\n        string[] signatures,\\n        bytes[] calldatas,\\n        uint256 indexed startBlock,\\n        uint256 endBlock,\\n        string description\\n    );\\n\\n    event Vote(\\n        address indexed voter,\\n        uint256 indexed proposalId,\\n        bool indexed support,\\n        uint256 votes\\n    );\\n\\n    event ProposalCancel(\\n        uint256 indexed id\\n    );\\n\\n    event ProposalQueue(\\n        uint256 indexed id,\\n        uint256 indexed eta\\n    );\\n\\n    event ProposalExecution(\\n        uint256 indexed id\\n    );\\n}\\n\"},\"GovernanceStorage.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\nimport \\\"./IGovernanceTimelock.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\n\\n/// @title Governance Storage Contract\\ncontract GovernanceStorage {\\n\\n    /// @notice Initialized flag - indicates that initialization was made once\\n    bool internal _initialized;\\n\\n    /// @notice The name of this contract\\n    string public constant name = \\\"Swipe Governance\\\";\\n\\n    /// @notice The address of the Swipe Timelock\\n    IGovernanceTimelock public _timelock;\\n\\n    /// @notice The address of the Swipe Staking contract\\n    IStaking public _staking;\\n\\n    /// @notice The address of the governance guardian\\n    address public _guardian;\\n\\n    address public _authorizedNewGuardian;\\n\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    uint256 public _quorumVotes;\\n\\n    /// @notice The number of votes required in order for a voter to become a proposer\\n    uint256 public _proposalThreshold;\\n\\n    /// @notice The maximum number of actions that can be included in a proposal\\n    uint256 public _proposalMaxOperations;\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed\\n    uint256 public _votingDelay;\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    uint256 public _votingPeriod;\\n\\n    /// @notice The total number of proposals\\n    uint256 public _proposalCount;\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint256 id;\\n\\n        /// @notice Creator of the proposal\\n        address proposer;\\n\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint256 eta;\\n\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n\\n        /// @notice The ordered list of values (assumeGuardianship i.e. msg.value) to be passed to the calls to be made\\n        uint256[] values;\\n\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint256 startBlock;\\n\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint256 endBlock;\\n\\n        /// @notice Current number of votes in favor of this proposal\\n        uint256 upVotes;\\n\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint256 downVotes;\\n\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n\\n        /// @notice The entire set of voters\\n        uint256 voterCount;\\n        mapping (uint256 =\\u003e address) voters;\\n\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping (address =\\u003e Receipt) receipts;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n\\n        /// @notice Whether or not the voter supports the proposal\\n        bool support;\\n\\n        /// @notice The number of votes the voter had, which were cast, or current number\\n        uint256 votes;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed\\n    }\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping (uint256 =\\u003e Proposal) internal _proposals;\\n\\n    /// @notice The latest proposal for each proposer\\n    mapping (address =\\u003e uint256) public _latestProposalIds;\\n\\n    /// @notice The EIP-712 typehash for the contract\\u0027s domain\\n    bytes32 public constant _domainTypeHash = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant _ballotTypeHash = keccak256(\\\"Ballot(uint256 proposalId,bool support)\\\");\\n\\n}\\n\"},\"IGovernanceTimelock.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ninterface IGovernanceTimelock {\\n    function _delay() external view returns (uint256);\\n    function _gracePeriod() external view returns (uint256);\\n    function assumeGuardianship() external;\\n    function _queuedTransactions(bytes32 txHash) external view returns (bool);\\n    function queueTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external returns (bytes32);\\n    function cancelTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external;\\n    function executeTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external payable returns (bytes memory);\\n}\"},\"IStaking.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ninterface IStaking {\\n    function getPriorStakedAmount(address staker, uint256 blockNumber) external view returns (uint256);\\n}\"},\"NamedContract.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/// @title Named Contract\\ncontract NamedContract {\\n    /// @notice The name of contract, which can be set once\\n    string public name;\\n\\n    /// @notice Sets contract name.\\n    function setContractName(string memory newName) internal {\\n        name = newName;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"GuardianUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"}],\"name\":\"GuardianshipTransferAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"timelockAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakingAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalExecution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"ProposalMaxOperationsUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"ProposalQueue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"ProposalThresholdUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"QuorumVotesUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"VotingDelayUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"VotingPeriodUpdate\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"_authorizedNewGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_ballotTypeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_domainTypeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_latestProposalIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_proposalMaxOperations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_proposalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_quorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_staking\",\"outputs\":[{\"internalType\":\"contract IStaking\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_timelock\",\"outputs\":[{\"internalType\":\"contract IGovernanceTimelock\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_votingDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"assumeGuardianship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"assumeTimelockGuardianship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"}],\"name\":\"authorizeGuardianshipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"castVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"castVoteBySig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"executeAuthorizeGuardianshipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getOperations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"downVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"internalType\":\"struct GovernanceStorage.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getVoters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"voterCount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"voters\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"upVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"downVotes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"timelockAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"queueAuthorizeGuardianshipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalMaxOperations\",\"type\":\"uint256\"}],\"name\":\"setProposalMaxOperations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalThreshold\",\"type\":\"uint256\"}],\"name\":\"setProposalThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quorumVotes\",\"type\":\"uint256\"}],\"name\":\"setQuorumVotes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"votingDelay\",\"type\":\"uint256\"}],\"name\":\"setVotingDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"votingPeriod\",\"type\":\"uint256\"}],\"name\":\"setVotingPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum GovernanceStorage.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Governance","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://678cb3c0316a9625f7d7c385a11a26688df6449248961d13874888719fd95a0b"}]}