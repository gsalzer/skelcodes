{"status":"1","message":"OK","result":[{"SourceCode":"{\"EternalStorageData.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n * @author Quant Network\\n * @title EternalStorage\\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\\n */\\ncontract EternalStorage {\\n\\n  mapping(bytes32 =\\u003e bool) internal boolStorage;\\n  mapping(bytes32 =\\u003e address) internal addressStorage;\\n  mapping(bytes32 =\\u003e string) internal stringStorage;\\n  mapping(bytes32 =\\u003e bytes) internal bytesStorage;\\n\\n  mapping(bytes32 =\\u003e bytes1) internal bytes1Storage;\\n  mapping(bytes32 =\\u003e bytes2) internal bytes2Storage;\\n  mapping(bytes32 =\\u003e bytes4) internal bytes4Storage;\\n  mapping(bytes32 =\\u003e bytes8) internal bytes8Storage;\\n  mapping(bytes32 =\\u003e bytes16) internal bytes16Storage;\\n  mapping(bytes32 =\\u003e bytes32) internal bytes32Storage;\\n  \\n  mapping(bytes32 =\\u003e int8) internal int8Storage;\\n  mapping(bytes32 =\\u003e int16) internal int16Storage;\\n  mapping(bytes32 =\\u003e int32) internal int32Storage;\\n  mapping(bytes32 =\\u003e int64) internal int64Storage;\\n  mapping(bytes32 =\\u003e int128) internal int128Storage;\\n  mapping(bytes32 =\\u003e int256) internal int256Storage;\\n  \\n  mapping(bytes32 =\\u003e uint8) internal uint8Storage;\\n  mapping(bytes32 =\\u003e uint16) internal uint16Storage;\\n  mapping(bytes32 =\\u003e uint32) internal uint32Storage;\\n  mapping(bytes32 =\\u003e uint64) internal uint64Storage;\\n  mapping(bytes32 =\\u003e uint128) internal uint128Storage;\\n  mapping(bytes32 =\\u003e uint256) internal uint256Storage;\\n\\n\\n}\"},\"TreasuryBase.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title TreasuryAbstract\\n * @dev Sets the main variables of a Treasury contract and allows other contracts to easily interface with a Treasury contract without knowing the whole code. \\n */\\ncontract TreasuryBase is UpgradeableProxy {\\n    \\n        // the connected factory of this treasury\\n        bytes constant private treasurysFactory1 = \\u00271.treasurysFactory\\u0027;\\n        // the connected rulelist of this treasury\\n        bytes constant private treasurysRuleList1 = \\u00271.treasurysRuleList\\u0027;\\n        // the treasury\\u0027s escrowed deposit\\n        bytes constant private treasurysDeposit1 = \\u00271.treasuryDeposit\\u0027;\\n        // the QNT address of this treasury (possible cold wallet)   \\n        bytes constant private QNTAddress1 = \\u00271.QNTAddress\\u0027;\\n        // the operator address of this treasury, which can call other smart contract functions on behalf of the treasury\\n        bytes constant private operatorAddress1 = \\u00271.operatorAddress\\u0027;\\n        // whether this treasury is currently paused (true) or active (false)\\n        bytes constant private circuitBreakerOn1 = \\u00271.circuitBreakerOn\\u0027;\\n        // the fee the MAPP has to pay for any dispute raised per gateway\\n        bytes constant private mappDisputeFeeMultipler1 = \\u00271.mappDisputeFeeMultipler\\u0027;\\n        // the commission divider charged for every mapp to gateway transaction. \\n        // The divider is used with the original fee of the function.\\n        // I.e a commission divider of 2 is equal to 50% commission\\n        bytes constant private commissionDivider1 = \\u00271.commissionDivider\\u0027;\\n        // the penalty multiplier the treasury has to pay if it has been found in breach of \\n        // one of its verification rules. The mulitipication is used with the original fee of the function.\\n        // I.e. a treasuryPenalty of 10 is equal to a 10x penalty\\n        bytes constant private  treasuryPenaltyMultipler1 = \\u00271.treasuryPenaltyMultipler\\u0027;\\n        // the penalty multiplier a gateway has to pay if it has be found in breach of\\n        // one of its verification rules. The mulitipication is used with the original fee of the function\\n        // I.e. a gatewayPenalty of 5 is equal to a 5x penalty.\\n        bytes constant private gatewayPenaltyMultipler1 = \\u00271.gatewayPenaltyMultipler\\u0027;\\n\\n        /**\\n         * set a new factory for this treasury\\n         */        \\n        function treasurysFactory(address newTreasurysFactory) internal {\\n            addressStorage[keccak256(treasurysFactory1)] = newTreasurysFactory;\\n        } \\n        \\n        \\n        /**\\n         * set a new rulelist for this treasury\\n         */        \\n        function treasurysRuleList(address newTreasurysRuleList) internal {\\n            addressStorage[keccak256(treasurysRuleList1)] = newTreasurysRuleList;\\n        } \\n\\n        /**\\n         * set a new treasury deposit \\n         */        \\n        function treasurysDeposit(address newTreasuryDeposit) internal {\\n            addressStorage[keccak256(treasurysDeposit1)] = newTreasuryDeposit;\\n        }\\n        \\n        /**\\n         * set a new QNTAddress for this treasury\\n         */        \\n        function QNTAddress(address newQNTAddress) internal {\\n            addressStorage[keccak256(QNTAddress1)] = newQNTAddress;\\n        }\\n        \\n        /**\\n         * set a new operator for this treasury\\n         */        \\n        function operatorAddress(address newOperator) internal {\\n            addressStorage[keccak256(operatorAddress1)] = newOperator;\\n        }\\n        \\n        /**\\n         * set the circuitbreaker of this treasury\\n         */        \\n        function circuitBreakerOn(bool newCircuitBreakerOn) internal {\\n            boolStorage[keccak256(circuitBreakerOn1)] = newCircuitBreakerOn;\\n        }\\n        \\n        /**\\n         * set the mapp dispute fee multiplier\\n         */        \\n        function mappDisputeFeeMultipler(uint16 newMappDisputeFeeMultipler) internal {\\n            uint16Storage[keccak256(mappDisputeFeeMultipler1)] = newMappDisputeFeeMultipler;\\n        }\\n        \\n \\n        /**\\n         * set the commission divider\\n         */        \\n        function commissionDivider(uint16 neCommissionDivider) internal {\\n            uint16Storage[keccak256(commissionDivider1)] = neCommissionDivider;\\n        }\\n\\n        /**\\n         * set the treasury dispute multiplier\\n         */        \\n        function treasuryPenaltyMultipler(uint16 newTreasuryPenaltyMultipler) internal {\\n            uint16Storage[keccak256(treasuryPenaltyMultipler1)] = newTreasuryPenaltyMultipler;\\n        }\\n\\n        /**\\n         * set the gateway dispute multiplier\\n         */        \\n        function gatewayPenaltyMultipler(uint16 newGatewayPenaltyMultipler) internal {\\n            uint16Storage[keccak256(gatewayPenaltyMultipler1)] = newGatewayPenaltyMultipler;\\n        }\\n\\n      /**\\n       * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n       */\\n      function admin() public view returns (address) {\\n          return addressStorage[keccak256(\\u0027proxy.admin\\u0027)];   \\n      }\\n    \\n        /**\\n        * @return - the number of hours wait time for any critical update\\n        */        \\n        function speedBumpHours() public view returns (uint16){\\n            return uint16Storage[keccak256(\\u0027proxy.speedBumpHours\\u0027)];\\n        }\\n     \\n        /**\\n         * @return - the connected factory of this treasury\\n         */        \\n        function treasurysFactory() public view returns (address){\\n            return addressStorage[keccak256(treasurysFactory1)];\\n        } \\n        \\n        /**\\n         * @return - the connected rulelist of this treasury\\n         */        \\n        function treasurysRuleList() public view returns (address){\\n            return addressStorage[keccak256(treasurysRuleList1)];\\n        } \\n\\n\\n        /**\\n         * @return - the treasury\\u0027s escrowed deposit\\n         */        \\n        function treasurysDeposit() public view returns (address){\\n            return addressStorage[keccak256(treasurysDeposit1)];\\n        }\\n        \\n        /**\\n         * @return - the withdrawal address of this treasury\\n         */        \\n        function QNTAddress() public view returns (address){\\n            return addressStorage[keccak256(QNTAddress1)];\\n        }\\n        \\n        /**\\n         * @return - the operator of this treasury\\n         */        \\n        function operatorAddress() public view returns (address){\\n            return addressStorage[keccak256(operatorAddress1)];\\n        }\\n        \\n        /**\\n         * @return - whether this treasury is currently active or not\\n         */        \\n        function circuitBreakerOn() public view returns (bool){\\n            return boolStorage[keccak256(circuitBreakerOn1)];\\n        }\\n        \\n        /**\\n         * @return - the fee the mapp has to pay for any dispute raised per gateway\\n         */        \\n        function mappDisputeFeeMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(mappDisputeFeeMultipler1)];\\n        }\\n        \\n \\n        /**\\n         * @return the commission divider charged for every mapp to gateway transaction.\\n         * The divider is used with the original fee of the function.\\n         * I.e a commission divider of 2 is equal to 50% commission\\n         */        \\n        function commissionDivider() public view returns (uint16){\\n            return uint16Storage[keccak256(commissionDivider1)];\\n        }\\n\\n        /**\\n         * @return - the penalty multiplier for the treasury has to pay if it has been found in breach of\\n         * one of its verification rules. The mulitipication is used with the original fee of the function.\\n         * I.e. a treasuryPenalty of 10 is equal to a 10x penalty\\n         */        \\n        function treasuryPenaltyMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(treasuryPenaltyMultipler1)];\\n        }\\n\\n        /**\\n         * @return - the penalty multiplier a gateway has to pay if it has be found in breach of\\n         * one of its verification rules. The mulitipication is used with the original fee of the function\\n         * I.e. a gatewayPenalty of 5 is equal to a 5x penalty.\\n         */        \\n        function gatewayPenaltyMultipler() public view returns (uint16){\\n            return uint16Storage[keccak256(gatewayPenaltyMultipler1)];\\n        }\\n    \\n}\"},\"TreasuryFactoryBase.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title FactoryAbstract\\n * @dev Sets the main variables of a Treasury Factory contract and allows other contracts to easily interface with a Treasury Factory contract without knowing the whole code.\\n */\\ncontract FactoryBase is UpgradeableProxy {\\n    \\n    // stores the mapping of MAPP (multi-chain app) -\\u003e treasury payment channels\\n    bytes constant private mappChannels1 = \\u00271.mappChannels\\u0027;\\n    // stores the mapping of MAPP -\\u003e escrowed deposits contracts\\n    bytes constant private mappDeposits1 = \\u00271.mappDeposits\\u0027;\\n    //  stores the number of registered gateways\\n    bytes constant private mappCount1 = \\u00271.mappCount\\u0027;\\n    // stores the mapping of treasury -\\u003e gateway payment channels\\n    bytes constant private gatewayChannels1 = \\u00271.gatewayChannels\\u0027;\\n    //  stores the mapping of gateway -\\u003e escrowed deposits contracts\\n    bytes constant private gatewayDeposits1 = \\u00271.gatewayDeposits\\u0027;\\n    //  stores the number of registered gateways\\n    bytes constant private gatewayCount1 = \\u00271.gatewayCount\\u0027;\\n    \\n    /**\\n     * sets the payment channel for this mapp (multi-chain app)\\n     */\\n    function mappChannel(address mappOperator, address channel) internal {\\n        addressStorage[keccak256(abi.encodePacked(mappChannels1,mappOperator))] = channel;\\n    }\\n    \\n    /**\\n     * sets the escrowed deposit contract for this mapp\\n     */\\n    function mappDeposit(address mappOperator, address depositContract) internal {\\n        addressStorage[keccak256(abi.encodePacked(mappDeposits1,mappOperator))] = depositContract;\\n    }\\n    \\n    /**\\n     * sets the number of gateways\\n     */\\n    function mappCount(uint32 count) internal {\\n        uint32Storage[keccak256(abi.encodePacked(mappCount1))] = count;\\n    }\\n    \\n    /**\\n     * sets the payment channel for this gateway\\n     */\\n    function gatewayChannel(address gatewayOperator, address channel) internal {\\n        addressStorage[keccak256(abi.encodePacked(gatewayChannels1,gatewayOperator))] = channel;\\n    }\\n    \\n    /**\\n     * sets the escrowed deposit contract for this gateway\\n     */\\n    function gatewayDeposit(address gatewayOperator, address deposit) internal {\\n        addressStorage[keccak256(abi.encodePacked(gatewayDeposits1,gatewayOperator))] =  deposit;\\n    }\\n    \\n    /**\\n     * sets the number of gateways\\n     */\\n    function gatewayCount(uint32 count) internal {\\n        uint32Storage[keccak256(abi.encodePacked(gatewayCount1))] =  count;\\n    }\\n\\n    /**\\n     * @return - the payment channel for this mapp (multi-chain app)\\n     */\\n    function mappChannel(address mappOperator) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(mappChannels1,mappOperator))];\\n    }\\n    \\n    /**\\n     * @return - the escrowed deposit for this mapp (multi-chain app)\\n     */\\n    function mappDeposit(address mappOperator) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(mappDeposits1,mappOperator))];\\n    }\\n    \\n    /**\\n     * @return - the number of mapps\\n     */\\n    function mappCount() public view returns (uint32) {\\n        return uint32Storage[keccak256(abi.encodePacked(mappCount1))];\\n    }\\n    \\n    /**\\n     * @return - the payment channel for this gateway\\n     */\\n    function gatewayChannel(address gatewayOperator) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(gatewayChannels1,gatewayOperator))];\\n    }\\n    \\n    /**\\n     * @return - the escrowed deposit for this gateway\\n     */\\n    function gatewayDeposit(address gatewayOperator) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(gatewayDeposits1,gatewayOperator))];\\n    }\\n    \\n    /**\\n     * @return - the number of gateways\\n     */\\n    function gatewayCount() public view returns (uint32) {\\n        return uint32Storage[keccak256(abi.encodePacked(gatewayCount1))];\\n    }\\n    \\n}\\n\\n/**\\n * @author Quant Network\\n * @title Allows contracts to easily interface with an EscrowedDeposit contract without knowing the whole code\\n */\\ncontract EscrowedDepositAbstract {\\n    \\n    \\n    /**\\n     * The rule list contract can deduct QNT from this escrow and send it to the receiver (without closing the escrow)\\n     * @param tokenAmount - the amount to deduct\\n     * @param ruleAddress - the contract address detailing the specific rule that has been broken\\n     */\\n    function deductDeposit(uint256 tokenAmount, address ruleAddress) external;\\n\\n}\"},\"TreasuryRuleList.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./TreasuryBase.sol\\\";\\nimport \\\"./TreasuryFactoryBase.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title Allows contracts holding mapp, treasury and gateway rules to be easily found\\n */\\ncontract RuleLists is UpgradeableProxy {\\n    \\n    // the rules that the mapps needs to abide by\\n    bytes constant private mappRules1 = \\u00271.mappRules\\u0027;\\n    // the rules that the treasury needs to abide by\\n    bytes constant private treasuryRules1 = \\u00271.treasuryRules\\u0027;\\n    // the rules that the gateways needs to abide by\\n    bytes constant private gatewayRules1 = \\u00271.gatewayRules\\u0027;\\n    // the number of rules that the mapps needs to abide by\\n    bytes constant private mappRuleIndex1 = \\u00271.mappRuleIndex\\u0027;\\n    // the number of rules that the treasury needs to abide by\\n    bytes constant private treasuryRuleIndex1 = \\u00271.treasuryRuleIndex\\u0027;\\n    // the number of rules that the gateways needs to abide by\\n    bytes constant private gatewayRuleIndex1 = \\u00271.gatewayRuleIndex\\u0027;\\n    // the linked treasury contract\\n    bytes constant private treasuryAddress1 = \\u00271.treasuryaddress\\u0027;\\n    // this contract\\u0027s current registered speed bumps. Array index [0] is for mapps, [1] for treasury and [2] for gateway.\\n    bytes constant private speedBumpRule1 = \\u00271.speedBump.rule\\u0027;\\n    bytes constant private speedBumpTimeCreated1 = \\u00271.speedBump.timeCreated\\u0027;\\n    bytes constant private speedBumpWaitingHours1 = \\u00271.speedBump.waitingHours\\u0027;\\n    \\n    // The event fired when a new rule is stored here:\\n    event addedRule(string stakeholder, uint256 index);\\n    // The event fired when a rule has been used:\\n    event usedRule(uint16 ruleIndex, address slashed, uint256 value);\\n    // The event fired when a speed bump has been updated\\n    event updatedSpeedBump(address rule, uint8 speedBumpIndex);\\n    \\n    /**\\n     * All functions with this modifier can only be called by the current treasury address\\n     * of the contract\\n     */\\n    modifier onlyTreasury(){\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        if (msg.sender != t.operatorAddress()){\\n            revert(\\\"Only the treasury contract\\u0027s operator address can modify this contract\\u0027s associated storage\\\");\\n        } else {\\n            _; // otherwise carry on with the computation\\n        }\\n    }\\n    \\n    /**\\n    * Sets the contract and initialises the variables\\n    * @param linkedTreasuryContract - the address of the linked treasury contract\\n    */  \\n    function initialize (address linkedTreasuryContract) external {\\n        require(!initialized(),\\\"contract can only be initialised once\\\");\\n       addressStorage[keccak256(treasuryAddress1)] = linkedTreasuryContract;\\n        initializeNow(); //sets this contract to initialized\\n    }\\n    \\n    /**\\n     * Adds a rule to the correct stakeholder\\u0027s list. All rules should follow the template code\\n     * @param speedBumpIndex - which speed bump to use: 0 for mapp, 1 for treasury, 2 for gateway\\n     * param: speedBumps[speedBumpIndex].rule - the address of a smart contract detailing this specific rule\\n     */\\n    function addRule(uint8 speedBumpIndex) external onlyTreasury() {\\n        require(((speedBumpIndex \\u003e= 0)\\u0026\\u0026(speedBumpIndex \\u003c= 2)), \\\"Speed bump index must between 0 and 2 inclusive\\\");\\n        require(speedBumpTimeCreated(speedBumpIndex) \\u003e 0, \\\"Time created must be \\u003e0 (to stop replays of the speed bump)\\\");\\n        require(now \\u003e speedBumpTimeCreated(speedBumpIndex) + (speedBumpWaitingHours(speedBumpIndex)*1 hours), \\\"The speed bump time period must have passed\\\");\\n        if (speedBumpIndex == 0){\\n            //add rule\\n            mappRules(speedBumpRule(0));\\n            //wipe speed bump\\n            deleteSpeedBump(0);\\n            //update rule\\n            emit addedRule(\\\"mapps\\\", mappRuleIndex());\\n        } else if (speedBumpIndex == 1){\\n            //add rule\\n            treasuryRules(speedBumpRule(1));\\n            //wipe speed bump\\n            deleteSpeedBump(1);\\n            //update rule\\n            emit addedRule(\\\"treasury\\\", treasuryRuleIndex());\\n        } else if (speedBumpIndex == 2){\\n            //add rule\\n            gatewayRules(speedBumpRule(2));\\n            //wipe speed bump\\n            deleteSpeedBump(2);\\n            //update rule\\n            emit addedRule(\\\"gateways\\\", gatewayRuleIndex());\\n        }\\n    }\\n \\n    /**\\n    * Creates a SpeedBump request for either a mapp, treasury or gateway update as defined by the stakeholder parameter\\n    * @param stakeholder - what will this speedBump be used for. \\n    * Pass through \\\"mapp\\\" to subsequently use the addRule() function to add a rule for the mapps\\n    * Pass through \\\"treasury\\\" to subsequently use the addRule() function to add a rule for the treasury\\n    * Pass through \\\"gateway\\\" to subsequently use the addRule() function to add a rule for the gateways\\n    * @param rule - the address of a smart contract detailing this specific rule\\n    */ \\n    function updateSpeedBump(string calldata stakeholder, address rule) external onlyTreasury() {\\n        if (keccak256(abi.encodePacked(stakeholder)) == keccak256(abi.encodePacked(\\\"mapp\\\"))){\\n            addSpeedBump(rule, 0);\\n            //emit event\\n            emit updatedSpeedBump(rule,0);\\n        } else if (keccak256(abi.encodePacked(stakeholder)) == keccak256(abi.encodePacked(\\\"treasury\\\"))){\\n            addSpeedBump(rule, 1);\\n            //emit event\\n            emit updatedSpeedBump(rule,1);\\n        } else if (keccak256(abi.encodePacked(stakeholder)) == keccak256(abi.encodePacked(\\\"gateway\\\"))){\\n            addSpeedBump(rule, 2);\\n            //emit event\\n            emit updatedSpeedBump(rule,2);\\n        } else {\\n            revert(\\\"The rule needs to be for a mapp, treasury or gateway\\\");\\n        }   \\n    }\\n\\n    /**\\n     * Uses a rule. Only rule contracts themselves can invoke this function\\n     * @param toSlash - which address has broken the rule\\n     * @param multiple - what is the multiple for the slash used to calculate the final penalty. \\n     * This will be the function fee for gateways and the number of gateways for mapps\\n     * @param ruleIndex - the index of the stakeholder rule broken (0 = mapp, 1 = treasury, 2 = gateway)\\n     */    \\n    function useRule(address toSlash, uint multiple, uint16 ruleIndex) external {\\n        uint256 multipler;\\n        require(((ruleIndex \\u003e= 0)\\u0026\\u0026(ruleIndex \\u003c= 2)), \\\"Rule index must between 0 and 2 inclusive\\\");\\n        //load the correct deposit contract\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        FactoryBase f = FactoryBase(t.treasurysFactory());\\n        address escrowedDepositAddr;\\n        if (ruleIndex == 0){\\n            require (mappRules(ruleIndex) == msg.sender, \\\"Calling address must be a mapp rule\\\");\\n            multipler = t.mappDisputeFeeMultipler();\\n            escrowedDepositAddr = f.mappDeposit(toSlash);\\n        } else if (ruleIndex == 1){\\n            require (treasuryRules(ruleIndex) == msg.sender, \\\"Calling address must be a treasury rule\\\"); \\n            multipler = t.treasuryPenaltyMultipler();\\n            escrowedDepositAddr = t.treasurysDeposit();\\n        } else if (ruleIndex == 2){\\n            require (gatewayRules(ruleIndex) == msg.sender, \\\"Calling address must be a gateway rule\\\");\\n            multipler = t.gatewayPenaltyMultipler();\\n            escrowedDepositAddr = f.gatewayDeposit(toSlash);\\n        }\\n        //take the correct slashed amount from the deposit contract\\n        uint256 penalty = multipler*multiple;\\n        require(penalty \\u003e 0, \\\"penalty \\u003c= 0\\\");\\n        EscrowedDepositAbstract(escrowedDepositAddr).deductDeposit(penalty, msg.sender);\\n        //emit event\\n        emit usedRule(ruleIndex, toSlash, penalty);\\n    }\\n\\n    /**\\n     * Adds a new mapp rule\\n     * @param newRule - the address describing the new rule\\n     */\\n    function mappRules(address newRule) internal {\\n        //get current index\\n        uint16 index = mappRuleIndex();\\n        index += 1;\\n        addressStorage[keccak256(abi.encodePacked(mappRules1,index))] = newRule;\\n        //increase index\\n        uint16Storage[keccak256(mappRuleIndex1)] = index; \\n    }\\n\\n    /**\\n     * Adds a new treasury rule\\n     * @param newRule - the address describing the new rule\\n     */\\n    function treasuryRules(address newRule) internal {\\n        //get current index\\n        uint16 index = treasuryRuleIndex();\\n        index += 1;\\n        addressStorage[keccak256(abi.encodePacked(treasuryRules1,index))] = newRule;\\n        //increase index\\n        uint16Storage[keccak256(treasuryRuleIndex1)] = index;\\n    }\\n\\n    /**\\n     * Adds a new gateway rule\\n     * @param newRule - the address describing the new rule\\n     */\\n    function gatewayRules(address newRule) internal {\\n        //get current index\\n        uint16 index = gatewayRuleIndex();\\n        index += 1;\\n        addressStorage[keccak256(abi.encodePacked(gatewayRules1,index))] = newRule;\\n        //increase index\\n        uint16Storage[keccak256(treasuryRuleIndex1)] = index;\\n    }\\n \\n    /**\\n     * Adds a new speed bump \\n     * @param newRule - the address describing the new rule\\n     * @param speedBumpIndex - which speed bump is being added\\n     */    \\n    function addSpeedBump(address newRule, uint8 speedBumpIndex) internal {\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        addressStorage[keccak256(abi.encodePacked(speedBumpRule1,speedBumpIndex))] = newRule;\\n        uint256Storage[keccak256(abi.encodePacked(speedBumpTimeCreated1,speedBumpIndex))]  = now;\\n        uint16Storage[keccak256(abi.encodePacked(speedBumpWaitingHours1,speedBumpIndex))] = t.speedBumpHours();\\n    }\\n\\n    /**\\n     * Deletes a speed bump \\n     * @param speedBumpIndex - which speed bump is being deleted\\n     */\\n    function deleteSpeedBump(uint8 speedBumpIndex) internal {\\n        addressStorage[keccak256(abi.encodePacked(speedBumpRule1,speedBumpIndex))] = address(0x0);\\n        uint256Storage[keccak256(abi.encodePacked(speedBumpTimeCreated1,speedBumpIndex))]  = 0;\\n        uint16Storage[keccak256(abi.encodePacked(speedBumpWaitingHours1,speedBumpIndex))] = 0;\\n    }\\n    \\n    /**\\n    * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n    */\\n    function admin() public view returns (address) {\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        return t.admin();   \\n    }\\n      \\n    /**\\n    * @return - the number of hours wait time for any critical update\\n    */        \\n    function speedBumpHours() public view returns (uint16){\\n        TreasuryBase t = TreasuryBase(treasuryAddress());\\n        return t.speedBumpHours();\\n    }\\n \\n    /**\\n     * Reads the linked treasury contract address\\n     * @return - the treasury contract\\n     */       \\n    function treasuryAddress() public view returns (address) {\\n        return addressStorage[keccak256(treasuryAddress1)];\\n    }\\n    \\n    /**\\n     * Reads the contract rule address in a SpeedBump\\n     * @param speedBumpIndex - the speed bump to look up\\n     * @return - the specific rule\\n     */        \\n    function speedBumpRule(uint8 speedBumpIndex) public view returns (address) {\\n        return addressStorage[keccak256(abi.encodePacked(speedBumpRule1,speedBumpIndex))];\\n    }\\n    \\n    /**\\n     * Reads the time the speedBump was created at\\n     * @param speedBumpIndex - the speed bump to look up\\n     * @return - the creation time\\n     */         \\n    function speedBumpTimeCreated(uint8 speedBumpIndex) public view returns (uint256) {\\n        return uint256Storage[keccak256(abi.encodePacked(speedBumpTimeCreated1,speedBumpIndex))];\\n    }\\n    \\n    /**\\n     * Reads the number of hours until the SpeedBump can be used\\n     * @param speedBumpIndex - the speed bump to look up\\n     * @return - the number of hours\\n     */       \\n    function speedBumpWaitingHours(uint8 speedBumpIndex) public view returns (uint16) {\\n        return uint16Storage[keccak256(abi.encodePacked(speedBumpWaitingHours1,speedBumpIndex))];\\n    }\\n\\n    /**\\n     * Reads a specific mapp rule smart  contract  address\\n     * @param index - the specific index of the rule to read\\n     * @return - the address\\n     */ \\n    function mappRules(uint16 index) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(mappRules1,index))];\\n    }\\n\\n    /**\\n     * Reads a specific treasury rule smart  contract  address\\n     * @param index - the specific index of the rule to read\\n     * @return - the address\\n     */ \\n    function treasuryRules(uint16 index) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(treasuryRules1,index))];\\n    }\\n\\n    /**\\n     * Reads a specific gateway rule smart  contract  address\\n     * @param index - the specific index of the rule to read\\n     * @return - the address\\n     */ \\n    function gatewayRules(uint16 index) public view returns (address){\\n        return addressStorage[keccak256(abi.encodePacked(gatewayRules1,index))];\\n    }\\n\\n    /**\\n     * Reads number of mapp rule smart contracts\\n     * @return - the number of mapp rules\\n     */ \\n    function mappRuleIndex() public view returns (uint16){\\n        return uint16Storage[keccak256(mappRuleIndex1)];\\n    }\\n\\n    /**\\n     * Reads number of treasury rule smart contracts\\n     * @return - the number of treasury rules\\n     */ \\n    function treasuryRuleIndex() public view returns (uint16){\\n        return uint16Storage[keccak256(treasuryRuleIndex1)];\\n    }\\n\\n    /**\\n     * Reads number of gateway rule smart contracts\\n     * @return - the number of gateway rules\\n     */ \\n    function gatewayRuleIndex() public view returns (uint16){\\n        return uint16Storage[keccak256(gatewayRuleIndex1)];\\n    }\\n    \\n    \\n}\"},\"UpgradeableProxy.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./EternalStorageData.sol\\\";\\n\\n/**\\n * @author Quant Network\\n * @title UpgradeableProxy\\n * @dev This contract allows the proxy to be upgradeable and owned\\n */\\ncontract UpgradeableProxy is EternalStorage {\\n    \\n    /**\\n   * Sets the admin of the proxy. Only the admin address can change this\\n   */\\n  function setAdmin() external {\\n      require(msg.sender ==admin(), \\u0027only admin can call this function\\u0027);\\n      uint256 sbTime = uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)];\\n      require(now \\u003e sbTime, \\\"this speed bump cannot be used yet\\\");\\n        require(sbTime \\u003e 0, \\\"use after time cannot be 0\\\");\\n      //change storage\\n      addressStorage[keccak256(\\u0027proxy.admin\\u0027)] = addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)];\\n      //remove speed bump\\n       addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)] = address(0);\\n  }\\n  \\n    /**\\n   * Sets the implementation of the proxy. Only the admin address can upgrade the smart contract logic\\n   */\\n  function setImplementation() external {\\n      require(msg.sender ==admin(), \\u0027only admin can call this function\\u0027);\\n      uint256 sbTime = uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)];\\n      require(now \\u003e sbTime, \\\"this speed bump cannot be used yet\\\");\\n      require(sbTime \\u003e 0, \\\"use after time cannot be 0\\\");\\n      addressStorage[keccak256(\\u0027proxy.implementation\\u0027)] = addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)]; \\n      addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)] = address(0); \\n  }\\n  \\n    /**\\n   * Adds a speed bump to change the admin or implementation. Only the admin address can change this\\n   */\\n  function changeProxyVariables(address nextAdmin, address nextImplementation) external {\\n      require(msg.sender == admin(), \\u0027only admin can call this function\\u0027);\\n        addressStorage[keccak256(\\u0027proxy.speedbump.admin\\u0027)] = nextAdmin;\\n        addressStorage[keccak256(\\u0027proxy.speedbump.implementation\\u0027)] = nextImplementation;\\n        //note that admin and implementation functions are separate above to align with more upgradeability patterns\\n        uint256Storage[keccak256(\\u0027proxy.speedbump.useAfterTime\\u0027)] = now + (speedBumpHours()*1 hours);\\n  }\\n\\n   /**\\n   * sets the contract as initialised\\n   */ \\n  function initializeNow() internal {\\n      boolStorage[keccak256(\\u0027proxy.initialized\\u0027)] = true;    \\n  }\\n  \\n    /**\\n    * set the speed bump time of this contract\\n    */        \\n    function speedBumpHours(uint16 newSpeedBumpHours) internal {\\n        uint16Storage[keccak256(\\u0027proxy.speedBumpHours\\u0027)] = newSpeedBumpHours;\\n    }\\n  \\n  /**\\n   * @return - the admin of the proxy. Only the admin address can upgrade the smart contract logic\\n   */\\n  function admin() public view returns (address);\\n \\n  /**\\n   * @return - the address of the current smart contract logic\\n   */ \\n  function implementation() public view returns (address) {\\n      return addressStorage[keccak256(\\u0027proxy.implementation\\u0027)];    \\n  }\\n  \\n  /**\\n   * @return - whether the smart contract has  been initialized (true) or not (false)\\n   */ \\n  function initialized() public view returns (bool) {\\n      return boolStorage[keccak256(\\u0027proxy.initialized\\u0027)];    \\n  }\\n  \\n    /**\\n    * @return - the number of hours wait time for any critical update\\n    */        \\n    function speedBumpHours() public view returns (uint16);\\n  \\n    \\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"stakeholder\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"addedRule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rule\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"speedBumpIndex\",\"type\":\"uint8\"}],\"name\":\"updatedSpeedBump\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"ruleIndex\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"slashed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"usedRule\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"speedBumpIndex\",\"type\":\"uint8\"}],\"name\":\"addRule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nextImplementation\",\"type\":\"address\"}],\"name\":\"changeProxyVariables\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gatewayRuleIndex\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"gatewayRules\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"linkedTreasuryContract\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mappRuleIndex\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"mappRules\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"speedBumpHours\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"speedBumpIndex\",\"type\":\"uint8\"}],\"name\":\"speedBumpRule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"speedBumpIndex\",\"type\":\"uint8\"}],\"name\":\"speedBumpTimeCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"speedBumpIndex\",\"type\":\"uint8\"}],\"name\":\"speedBumpWaitingHours\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasuryRuleIndex\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"treasuryRules\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"stakeholder\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"rule\",\"type\":\"address\"}],\"name\":\"updateSpeedBump\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toSlash\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"multiple\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"ruleIndex\",\"type\":\"uint16\"}],\"name\":\"useRule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RuleLists","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://37d78180aee849ada18e3e629b599f9042d57df5a74c3a47c85950e0426986b7"}]}