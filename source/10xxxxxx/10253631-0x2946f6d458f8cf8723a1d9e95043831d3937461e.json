{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/interfaces/IBridgeValidators.sol\n\npragma solidity 0.4.24;\n\ninterface IBridgeValidators {\n    function isValidator(address _validator) external view returns (bool);\n    function requiredSignatures() external view returns (uint256);\n    function owner() external view returns (address);\n}\n\n// File: contracts/libraries/Message.sol\n\npragma solidity 0.4.24;\n\n\nlibrary Message {\n    // function uintToString(uint256 inputValue) internal pure returns (string) {\n    //     // figure out the length of the resulting string\n    //     uint256 length = 0;\n    //     uint256 currentValue = inputValue;\n    //     do {\n    //         length++;\n    //         currentValue /= 10;\n    //     } while (currentValue != 0);\n    //     // allocate enough memory\n    //     bytes memory result = new bytes(length);\n    //     // construct the string backwards\n    //     uint256 i = length - 1;\n    //     currentValue = inputValue;\n    //     do {\n    //         result[i--] = byte(48 + currentValue % 10);\n    //         currentValue /= 10;\n    //     } while (currentValue != 0);\n    //     return string(result);\n    // }\n\n    function addressArrayContains(address[] array, address value) internal pure returns (bool) {\n        for (uint256 i = 0; i < array.length; i++) {\n            if (array[i] == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // layout of message :: bytes:\n    // offset  0: 32 bytes :: uint256 - message length\n    // offset 32: 20 bytes :: address - recipient address\n    // offset 52: 32 bytes :: uint256 - value\n    // offset 84: 32 bytes :: bytes32 - transaction hash\n    // offset 104: 20 bytes :: address - contract address to prevent double spending\n\n    // mload always reads 32 bytes.\n    // so we can and have to start reading recipient at offset 20 instead of 32.\n    // if we were to read at 32 the address would contain part of value and be corrupted.\n    // when reading from offset 20 mload will read 12 bytes (most of them zeros) followed\n    // by the 20 recipient address bytes and correctly convert it into an address.\n    // this saves some storage/gas over the alternative solution\n    // which is padding address to 32 bytes and reading recipient at offset 32.\n    // for more details see discussion in:\n    // https://github.com/paritytech/parity-bridge/issues/61\n    function parseMessage(bytes message)\n        internal\n        pure\n        returns (address recipient, uint256 amount, bytes32 txHash, address contractAddress)\n    {\n        require(isMessageValid(message));\n        assembly {\n            recipient := mload(add(message, 20))\n            amount := mload(add(message, 52))\n            txHash := mload(add(message, 84))\n            contractAddress := mload(add(message, 104))\n        }\n    }\n\n    function isMessageValid(bytes _msg) internal pure returns (bool) {\n        return _msg.length == requiredMessageLength();\n    }\n\n    function requiredMessageLength() internal pure returns (uint256) {\n        return 104;\n    }\n\n    function recoverAddressFromSignedMessage(bytes signature, bytes message, bool isAMBMessage)\n        internal\n        pure\n        returns (address)\n    {\n        require(signature.length == 65);\n        bytes32 r;\n        bytes32 s;\n        bytes1 v;\n\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := mload(add(signature, 0x60))\n        }\n        return ecrecover(hashMessage(message, isAMBMessage), uint8(v), r, s);\n    }\n\n    function hashMessage(bytes message, bool isAMBMessage) internal pure returns (bytes32) {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n        if (isAMBMessage) {\n            return keccak256(abi.encodePacked(prefix, uintToString(message.length), message));\n        } else {\n            string memory msgLength = \"104\";\n            return keccak256(abi.encodePacked(prefix, msgLength, message));\n        }\n    }\n\n    /**\n    * @dev Validates provided signatures, only first requiredSignatures() number\n    * of signatures are going to be validated, these signatures should be from different validators.\n    * @param _message bytes message used to generate signatures\n    * @param _signatures bytes blob with signatures to be validated.\n    * First byte X is a number of signatures in a blob,\n    * next X bytes are v components of signatures,\n    * next 32 * X bytes are r components of signatures,\n    * next 32 * X bytes are s components of signatures.\n    * @param _validatorContract contract, which conforms to the IBridgeValidators interface,\n    * where info about current validators and required signatures is stored.\n    * @param isAMBMessage true if _message is an AMB message with arbitrary length.\n    */\n    function hasEnoughValidSignatures(\n        bytes _message,\n        bytes _signatures,\n        IBridgeValidators _validatorContract,\n        bool isAMBMessage\n    ) internal view {\n        require(isAMBMessage || isMessageValid(_message));\n        uint256 requiredSignatures = _validatorContract.requiredSignatures();\n        uint256 amount;\n        assembly {\n            amount := and(mload(add(_signatures, 1)), 0xff)\n        }\n        require(amount >= requiredSignatures);\n        bytes32 hash = hashMessage(_message, isAMBMessage);\n        address[] memory encounteredAddresses = new address[](requiredSignatures);\n\n        for (uint256 i = 0; i < requiredSignatures; i++) {\n            uint8 v;\n            bytes32 r;\n            bytes32 s;\n            uint256 posr = 33 + amount + 32 * i;\n            uint256 poss = posr + 32 * amount;\n            assembly {\n                v := mload(add(_signatures, add(2, i)))\n                r := mload(add(_signatures, posr))\n                s := mload(add(_signatures, poss))\n            }\n\n            address recoveredAddress = ecrecover(hash, v, r, s);\n            require(_validatorContract.isValidator(recoveredAddress));\n            require(!addressArrayContains(encounteredAddresses, recoveredAddress));\n            encounteredAddresses[i] = recoveredAddress;\n        }\n    }\n\n    function uintToString(uint256 i) internal pure returns (string) {\n        if (i == 0) return \"0\";\n        uint256 j = i;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(length);\n        uint256 k = length - 1;\n        while (i != 0) {\n            bstr[k--] = bytes1(48 + (i % 10));\n            i /= 10;\n        }\n        return string(bstr);\n    }\n}\n\n// File: contracts/libraries/ArbitraryMessage.sol\n\npragma solidity 0.4.24;\n\nlibrary ArbitraryMessage {\n    /**\n    * @dev Unpacks data fields from AMB message\n    * layout of message :: bytes:\n    * offset  0              : 32 bytes :: uint256 - message length\n    * offset 32              : 32 bytes :: bytes32 - messageId\n    * offset 64              : 20 bytes :: address - sender address\n    * offset 84              : 20 bytes :: address - executor contract\n    * offset 104             : 4 bytes  :: uint32  - gasLimit\n    * offset 108             : 1 bytes  :: uint8   - source chain id length (X)\n    * offset 109             : 1 bytes  :: uint8   - destination chain id length (Y)\n    * offset 110             : 1 bytes  :: bytes1  - dataType\n    * (optional) 111         : 32 bytes :: uint256 - gasPrice\n    * (optional) 111         : 1 bytes  :: bytes1  - gasPriceSpeed\n    * offset 111/143/112     : X bytes  :: bytes   - source chain id\n    * offset 111/143/112 + X : Y bytes  :: bytes   - destination chain id\n\n    * NOTE: when message structure is changed, make sure that MESSAGE_PACKING_VERSION from VersionableAMB is updated as well\n    * NOTE: assembly code uses calldatacopy, make sure that message is passed as the first argument in the calldata\n    * @param _data encoded message\n    */\n    function unpackData(bytes _data)\n        internal\n        pure\n        returns (\n            bytes32 messageId,\n            address sender,\n            address executor,\n            uint32 gasLimit,\n            bytes1 dataType,\n            uint256[2] chainIds,\n            uint256 gasPrice,\n            bytes memory data\n        )\n    {\n        // 32 (message id) + 20 (sender) + 20 (executor) + 4 (gasLimit) + 1 (source chain id length) + 1 (destination chain id length) + 1 (dataType)\n        uint256 srcdataptr = 32 + 20 + 20 + 4 + 1 + 1 + 1;\n        uint256 datasize;\n\n        assembly {\n            messageId := mload(add(_data, 32)) // 32 bytes\n            sender := and(mload(add(_data, 52)), 0xffffffffffffffffffffffffffffffffffffffff) // 20 bytes\n\n            // executor (20 bytes) + gasLimit (4 bytes) + srcChainIdLength (1 byte) + dstChainIdLength (1 bytes) + dataType (1 byte) + remainder (5 bytes)\n            let blob := mload(add(_data, 84))\n\n            // after bit shift left 12 bytes are zeros automatically\n            executor := shr(96, blob)\n            gasLimit := and(shr(64, blob), 0xffffffff)\n\n            // load source chain id length\n            let chainIdLength := byte(24, blob)\n\n            dataType := and(shl(208, blob), 0xFF00000000000000000000000000000000000000000000000000000000000000)\n            switch dataType\n                case 0x0000000000000000000000000000000000000000000000000000000000000000 {\n                    gasPrice := 0\n                }\n                case 0x0100000000000000000000000000000000000000000000000000000000000000 {\n                    gasPrice := mload(add(_data, 111)) // 32\n                    srcdataptr := add(srcdataptr, 32)\n                }\n                case 0x0200000000000000000000000000000000000000000000000000000000000000 {\n                    gasPrice := 0\n                    srcdataptr := add(srcdataptr, 1)\n                }\n\n            // at this moment srcdataptr points to sourceChainId\n\n            // mask for sourceChainId\n            // e.g. length X -> (1 << (X * 8)) - 1\n            let mask := sub(shl(shl(3, chainIdLength), 1), 1)\n\n            // increase payload offset by length of source chain id\n            srcdataptr := add(srcdataptr, chainIdLength)\n\n            // write sourceChainId\n            mstore(chainIds, and(mload(add(_data, srcdataptr)), mask))\n\n            // at this moment srcdataptr points to destinationChainId\n\n            // load destination chain id length\n            chainIdLength := byte(25, blob)\n\n            // mask for destinationChainId\n            // e.g. length X -> (1 << (X * 8)) - 1\n            mask := sub(shl(shl(3, chainIdLength), 1), 1)\n\n            // increase payload offset by length of destination chain id\n            srcdataptr := add(srcdataptr, chainIdLength)\n\n            // write destinationChainId\n            mstore(add(chainIds, 32), and(mload(add(_data, srcdataptr)), mask))\n\n            // at this moment srcdataptr points to payload\n\n            // datasize = message length - payload offset\n            datasize := sub(mload(_data), srcdataptr)\n        }\n\n        data = new bytes(datasize);\n        assembly {\n            // 36 = 4 (selector) + 32 (bytes length header)\n            srcdataptr := add(srcdataptr, 36)\n\n            // calldataload(4) - offset of first bytes argument in the calldata\n            calldatacopy(add(data, 32), add(calldataload(4), srcdataptr), datasize)\n        }\n    }\n}\n\n// File: contracts/interfaces/IUpgradeabilityOwnerStorage.sol\n\npragma solidity 0.4.24;\n\ninterface IUpgradeabilityOwnerStorage {\n    function upgradeabilityOwner() external view returns (address);\n}\n\n// File: contracts/upgradeable_contracts/Upgradeable.sol\n\npragma solidity 0.4.24;\n\n\ncontract Upgradeable {\n    // Avoid using onlyUpgradeabilityOwner name to prevent issues with implementation from proxy contract\n    modifier onlyIfUpgradeabilityOwner() {\n        require(msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner());\n        /* solcov ignore next */\n        _;\n    }\n}\n\n// File: contracts/upgradeability/EternalStorage.sol\n\npragma solidity 0.4.24;\n\n/**\n * @title EternalStorage\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\n */\ncontract EternalStorage {\n    mapping(bytes32 => uint256) internal uintStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => bool) internal boolStorage;\n    mapping(bytes32 => int256) internal intStorage;\n\n}\n\n// File: contracts/upgradeable_contracts/Initializable.sol\n\npragma solidity 0.4.24;\n\n\ncontract Initializable is EternalStorage {\n    bytes32 internal constant INITIALIZED = 0x0a6f646cd611241d8073675e00d1a1ff700fbf1b53fcf473de56d1e6e4b714ba; // keccak256(abi.encodePacked(\"isInitialized\"))\n\n    function setInitialize() internal {\n        boolStorage[INITIALIZED] = true;\n    }\n\n    function isInitialized() public view returns (bool) {\n        return boolStorage[INITIALIZED];\n    }\n}\n\n// File: contracts/upgradeable_contracts/InitializableBridge.sol\n\npragma solidity 0.4.24;\n\n\ncontract InitializableBridge is Initializable {\n    bytes32 internal constant DEPLOYED_AT_BLOCK = 0xb120ceec05576ad0c710bc6e85f1768535e27554458f05dcbb5c65b8c7a749b0; // keccak256(abi.encodePacked(\"deployedAtBlock\"))\n\n    function deployedAtBlock() external view returns (uint256) {\n        return uintStorage[DEPLOYED_AT_BLOCK];\n    }\n}\n\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary AddressUtils {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param _addr address to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address _addr) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(_addr) }\n    return size > 0;\n  }\n\n}\n\n// File: contracts/upgradeable_contracts/ValidatorStorage.sol\n\npragma solidity 0.4.24;\n\ncontract ValidatorStorage {\n    bytes32 internal constant VALIDATOR_CONTRACT = 0x5a74bb7e202fb8e4bf311841c7d64ec19df195fee77d7e7ae749b27921b6ddfe; // keccak256(abi.encodePacked(\"validatorContract\"))\n}\n\n// File: contracts/upgradeable_contracts/Validatable.sol\n\npragma solidity 0.4.24;\n\n\n\n\ncontract Validatable is EternalStorage, ValidatorStorage {\n    function validatorContract() public view returns (IBridgeValidators) {\n        return IBridgeValidators(addressStorage[VALIDATOR_CONTRACT]);\n    }\n\n    modifier onlyValidator() {\n        require(validatorContract().isValidator(msg.sender));\n        /* solcov ignore next */\n        _;\n    }\n\n    function requiredSignatures() public view returns (uint256) {\n        return validatorContract().requiredSignatures();\n    }\n\n}\n\n// File: contracts/upgradeable_contracts/Ownable.sol\n\npragma solidity 0.4.24;\n\n\n\n/**\n * @title Ownable\n * @dev This contract has an owner address providing basic authorization control\n */\ncontract Ownable is EternalStorage {\n    bytes4 internal constant UPGRADEABILITY_OWNER = 0x6fde8202; // upgradeabilityOwner()\n\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param previousOwner representing the address of the previous owner\n    * @param newOwner representing the address of the new owner\n    */\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner());\n        /* solcov ignore next */\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any account other than contract itself or owner.\n    */\n    modifier onlyRelevantSender() {\n        // proxy owner if used through proxy, address(0) otherwise\n        require(\n            !address(this).call(abi.encodeWithSelector(UPGRADEABILITY_OWNER)) || // covers usage without calling through storage proxy\n                msg.sender == IUpgradeabilityOwnerStorage(this).upgradeabilityOwner() || // covers usage through regular proxy calls\n                msg.sender == address(this) // covers calls through upgradeAndCall proxy method\n        );\n        /* solcov ignore next */\n        _;\n    }\n\n    bytes32 internal constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; // keccak256(abi.encodePacked(\"owner\"))\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function owner() public view returns (address) {\n        return addressStorage[OWNER];\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner the address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0));\n        setOwner(newOwner);\n    }\n\n    /**\n    * @dev Sets a new owner address\n    */\n    function setOwner(address newOwner) internal {\n        emit OwnershipTransferred(owner(), newOwner);\n        addressStorage[OWNER] = newOwner;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address _who) public view returns (uint256);\n  function transfer(address _to, uint256 _value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address _owner, address _spender)\n    public view returns (uint256);\n\n  function transferFrom(address _from, address _to, uint256 _value)\n    public returns (bool);\n\n  function approve(address _spender, uint256 _value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: contracts/upgradeable_contracts/Sacrifice.sol\n\npragma solidity 0.4.24;\n\ncontract Sacrifice {\n    constructor(address _recipient) public payable {\n        selfdestruct(_recipient);\n    }\n}\n\n// File: contracts/libraries/Address.sol\n\npragma solidity 0.4.24;\n\n\n/**\n * @title Address\n * @dev Helper methods for Address type.\n */\nlibrary Address {\n    /**\n    * @dev Try to send native tokens to the address. If it fails, it will force the transfer by creating a selfdestruct contract\n    * @param _receiver address that will receive the native tokens\n    * @param _value the amount of native tokens to send\n    */\n    function safeSendValue(address _receiver, uint256 _value) internal {\n        if (!_receiver.send(_value)) {\n            (new Sacrifice).value(_value)(_receiver);\n        }\n    }\n}\n\n// File: contracts/upgradeable_contracts/Claimable.sol\n\npragma solidity 0.4.24;\n\n\n\ncontract Claimable {\n    bytes4 internal constant TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n\n    modifier validAddress(address _to) {\n        require(_to != address(0));\n        /* solcov ignore next */\n        _;\n    }\n\n    function claimValues(address _token, address _to) internal {\n        if (_token == address(0)) {\n            claimNativeCoins(_to);\n        } else {\n            claimErc20Tokens(_token, _to);\n        }\n    }\n\n    function claimNativeCoins(address _to) internal {\n        uint256 value = address(this).balance;\n        Address.safeSendValue(_to, value);\n    }\n\n    function claimErc20Tokens(address _token, address _to) internal {\n        ERC20Basic token = ERC20Basic(_token);\n        uint256 balance = token.balanceOf(this);\n        safeTransfer(_token, _to, balance);\n    }\n\n    function safeTransfer(address _token, address _to, uint256 _value) internal {\n        bytes memory returnData;\n        bool returnDataResult;\n        bytes memory callData = abi.encodeWithSelector(TRANSFER, _to, _value);\n        assembly {\n            let result := call(gas, _token, 0x0, add(callData, 0x20), mload(callData), 0, 32)\n            returnData := mload(0)\n            returnDataResult := mload(0)\n\n            switch result\n                case 0 {\n                    revert(0, 0)\n                }\n        }\n\n        // Return data is optional\n        if (returnData.length > 0) {\n            require(returnDataResult);\n        }\n    }\n}\n\n// File: contracts/upgradeable_contracts/VersionableBridge.sol\n\npragma solidity 0.4.24;\n\ncontract VersionableBridge {\n    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {\n        return (5, 0, 0);\n    }\n\n    /* solcov ignore next */\n    function getBridgeMode() external pure returns (bytes4);\n}\n\n// File: contracts/upgradeable_contracts/BasicBridge.sol\n\npragma solidity 0.4.24;\n\n\n\n\n\n\n\n\ncontract BasicBridge is InitializableBridge, Validatable, Ownable, Upgradeable, Claimable, VersionableBridge {\n    event GasPriceChanged(uint256 gasPrice);\n    event RequiredBlockConfirmationChanged(uint256 requiredBlockConfirmations);\n\n    bytes32 internal constant GAS_PRICE = 0x55b3774520b5993024893d303890baa4e84b1244a43c60034d1ced2d3cf2b04b; // keccak256(abi.encodePacked(\"gasPrice\"))\n    bytes32 internal constant REQUIRED_BLOCK_CONFIRMATIONS = 0x916daedf6915000ff68ced2f0b6773fe6f2582237f92c3c95bb4d79407230071; // keccak256(abi.encodePacked(\"requiredBlockConfirmations\"))\n\n    function setGasPrice(uint256 _gasPrice) external onlyOwner {\n        require(_gasPrice > 0);\n        uintStorage[GAS_PRICE] = _gasPrice;\n        emit GasPriceChanged(_gasPrice);\n    }\n\n    function gasPrice() external view returns (uint256) {\n        return uintStorage[GAS_PRICE];\n    }\n\n    function setRequiredBlockConfirmations(uint256 _blockConfirmations) external onlyOwner {\n        require(_blockConfirmations > 0);\n        uintStorage[REQUIRED_BLOCK_CONFIRMATIONS] = _blockConfirmations;\n        emit RequiredBlockConfirmationChanged(_blockConfirmations);\n    }\n\n    function requiredBlockConfirmations() external view returns (uint256) {\n        return uintStorage[REQUIRED_BLOCK_CONFIRMATIONS];\n    }\n\n    function claimTokens(address _token, address _to) public onlyIfUpgradeabilityOwner validAddress(_to) {\n        claimValues(_token, _to);\n    }\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/VersionableAMB.sol\n\npragma solidity 0.4.24;\n\n\ncontract VersionableAMB is VersionableBridge {\n    // message format version as a single 4-bytes number padded to 32-bytes\n    // value, included into every outgoing relay request\n    //\n    // the message version should be updated every time when\n    // - new field appears\n    // - some field removed\n    // - fields order is changed\n    bytes32 internal constant MESSAGE_PACKING_VERSION = 0x00050000 << 224;\n\n    /**\n     * Returns currently used bridge version\n     * @return (major, minor, patch) version triple\n     */\n    function getBridgeInterfacesVersion() external pure returns (uint64 major, uint64 minor, uint64 patch) {\n        return (5, 0, 1);\n    }\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/BasicAMB.sol\n\npragma solidity 0.4.24;\n\n\n\ncontract BasicAMB is BasicBridge, VersionableAMB {\n    bytes32 internal constant MAX_GAS_PER_TX = 0x2670ecc91ec356e32067fd27b36614132d727b84a1e03e08f412a4f2cf075974; // keccak256(abi.encodePacked(\"maxGasPerTx\"))\n    bytes32 internal constant NONCE = 0x7ab1577440dd7bedf920cb6de2f9fc6bf7ba98c78c85a3fa1f8311aac95e1759; // keccak256(abi.encodePacked(\"nonce\"))\n    bytes32 internal constant SOURCE_CHAIN_ID = 0x67d6f42a1ed69c62022f2d160ddc6f2f0acd37ad1db0c24f4702d7d3343a4add; // keccak256(abi.encodePacked(\"sourceChainId\"))\n    bytes32 internal constant SOURCE_CHAIN_ID_LENGTH = 0xe504ae1fd6471eea80f18b8532a61a9bb91fba4f5b837f80a1cfb6752350af44; // keccak256(abi.encodePacked(\"sourceChainIdLength\"))\n    bytes32 internal constant DESTINATION_CHAIN_ID = 0xbbd454018e72a3f6c02bbd785bacc49e46292744f3f6761276723823aa332320; // keccak256(abi.encodePacked(\"destinationChainId\"))\n    bytes32 internal constant DESTINATION_CHAIN_ID_LENGTH = 0xfb792ae4ad11102b93f26a51b3749c2b3667f8b561566a4806d4989692811594; // keccak256(abi.encodePacked(\"destinationChainIdLength\"))\n\n    /**\n     * Initializes AMB contract\n     * @param _sourceChainId chain id of a network where this contract is deployed\n     * @param _destinationChainId chain id of a network where all outgoing messages are directed\n     * @param _validatorContract address of the validators contract\n     * @param _maxGasPerTx maximum amount of gas per one message execution\n     * @param _gasPrice default gas price used by oracles for sending transactions in this network\n     * @param _requiredBlockConfirmations number of block confirmations oracle will wait before processing passed messages\n     * @param _owner address of new bridge owner\n     */\n    function initialize(\n        uint256 _sourceChainId,\n        uint256 _destinationChainId,\n        address _validatorContract,\n        uint256 _maxGasPerTx,\n        uint256 _gasPrice,\n        uint256 _requiredBlockConfirmations,\n        address _owner\n    ) external onlyRelevantSender returns (bool) {\n        require(!isInitialized());\n        require(AddressUtils.isContract(_validatorContract));\n        require(_gasPrice > 0);\n        require(_requiredBlockConfirmations > 0);\n\n        _setChainIds(_sourceChainId, _destinationChainId);\n        addressStorage[VALIDATOR_CONTRACT] = _validatorContract;\n        uintStorage[DEPLOYED_AT_BLOCK] = block.number;\n        uintStorage[MAX_GAS_PER_TX] = _maxGasPerTx;\n        uintStorage[GAS_PRICE] = _gasPrice;\n        uintStorage[REQUIRED_BLOCK_CONFIRMATIONS] = _requiredBlockConfirmations;\n        setOwner(_owner);\n        setInitialize();\n\n        emit RequiredBlockConfirmationChanged(_requiredBlockConfirmations);\n        emit GasPriceChanged(_gasPrice);\n\n        return isInitialized();\n    }\n\n    function getBridgeMode() external pure returns (bytes4 _data) {\n        return 0x2544fbb9; // bytes4(keccak256(abi.encodePacked(\"arbitrary-message-bridge-core\")))\n    }\n\n    function maxGasPerTx() public view returns (uint256) {\n        return uintStorage[MAX_GAS_PER_TX];\n    }\n\n    function setMaxGasPerTx(uint256 _maxGasPerTx) external onlyOwner {\n        uintStorage[MAX_GAS_PER_TX] = _maxGasPerTx;\n    }\n\n    /**\n     * Updates chain ids of used networks\n     * @param _sourceChainId chain id for current network\n     * @param _destinationChainId chain id for opposite network\n     */\n    function setChainIds(uint256 _sourceChainId, uint256 _destinationChainId) external onlyOwner {\n        _setChainIds(_sourceChainId, _destinationChainId);\n    }\n\n    /**\n     * Internal function for retrieving current nonce value\n     * @return nonce value\n     */\n    function _nonce() internal view returns (uint64) {\n        return uint64(uintStorage[NONCE]);\n    }\n\n    /**\n     * Internal function for updating nonce value\n     * @param _nonce new nonce value\n     */\n    function _setNonce(uint64 _nonce) internal {\n        uintStorage[NONCE] = uint256(_nonce);\n    }\n\n    /**\n     * Internal function for updating chain ids of used networks\n     * @param _sourceChainId chain id for current network\n     * @param _destinationChainId chain id for opposite network\n     */\n    function _setChainIds(uint256 _sourceChainId, uint256 _destinationChainId) internal {\n        require(_sourceChainId > 0 && _destinationChainId > 0);\n        require(_sourceChainId != _destinationChainId);\n        uint256 sourceChainIdLength = 0;\n        uint256 destinationChainIdLength = 0;\n        uint256 mask = 0xff;\n\n        for (uint256 i = 1; sourceChainIdLength == 0 || destinationChainIdLength == 0; i++) {\n            if (sourceChainIdLength == 0 && _sourceChainId & mask == _sourceChainId) {\n                sourceChainIdLength = i;\n            }\n            if (destinationChainIdLength == 0 && _destinationChainId & mask == _destinationChainId) {\n                destinationChainIdLength = i;\n            }\n            mask = (mask << 8) | 0xff;\n        }\n\n        uintStorage[SOURCE_CHAIN_ID] = _sourceChainId;\n        uintStorage[SOURCE_CHAIN_ID_LENGTH] = sourceChainIdLength;\n        uintStorage[DESTINATION_CHAIN_ID] = _destinationChainId;\n        uintStorage[DESTINATION_CHAIN_ID_LENGTH] = destinationChainIdLength;\n    }\n\n    /**\n     * Internal function for retrieving chain id for the source network\n     * @return chain id for the current network\n     */\n    function _sourceChainId() internal view returns (uint256) {\n        return uintStorage[SOURCE_CHAIN_ID];\n    }\n\n    /**\n     * Internal function for retrieving chain id length for the source network\n     * @return chain id for the current network\n     */\n    function _sourceChainIdLength() internal view returns (uint256) {\n        return uintStorage[SOURCE_CHAIN_ID_LENGTH];\n    }\n\n    /**\n     * Internal function for retrieving chain id for the destination network\n     * @return chain id for the destination network\n     */\n    function _destinationChainId() internal view returns (uint256) {\n        return uintStorage[DESTINATION_CHAIN_ID];\n    }\n\n    /**\n     * Internal function for retrieving chain id length for the destination network\n     * @return chain id for the destination network\n     */\n    function _destinationChainIdLength() internal view returns (uint256) {\n        return uintStorage[DESTINATION_CHAIN_ID_LENGTH];\n    }\n\n    /**\n     * Internal function for validating version of the received message\n     * @param _messageId id of the received message\n     */\n    function _isMessageVersionValid(bytes32 _messageId) internal returns (bool) {\n        return\n            _messageId & 0xffffffff00000000000000000000000000000000000000000000000000000000 == MESSAGE_PACKING_VERSION;\n    }\n\n    /**\n     * Internal function for validating destination chain id of the received message\n     * @param _chainId destination chain id of the received message\n     */\n    function _isDestinationChainIdValid(uint256 _chainId) internal returns (bool res) {\n        return _chainId == _sourceChainId();\n    }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n\n// File: contracts/libraries/Bytes.sol\n\npragma solidity 0.4.24;\n\n/**\n * @title Bytes\n * @dev Helper methods to transform bytes to other solidity types.\n */\nlibrary Bytes {\n    /**\n    * @dev Converts bytes array to bytes32.\n    * Truncates bytes array if its size is more than 32 bytes.\n    * NOTE: This function does not perform any checks on the received parameter.\n    * Make sure that the _bytes argument has a correct length, not less than 32 bytes.\n    * A case when _bytes has length less than 32 will lead to the undefined behaviour,\n    * since assembly will read data from memory that is not related to the _bytes argument.\n    * @param _bytes to be converted to bytes32 type\n    * @return bytes32 type of the firsts 32 bytes array in parameter.\n    */\n    function bytesToBytes32(bytes _bytes) internal pure returns (bytes32 result) {\n        assembly {\n            result := mload(add(_bytes, 32))\n        }\n    }\n\n    /**\n    * @dev Truncate bytes array if its size is more than 20 bytes.\n    * NOTE: Similar to the bytesToBytes32 function, make sure that _bytes is not shorter than 20 bytes.\n    * @param _bytes to be converted to address type\n    * @return address included in the firsts 20 bytes of the bytes array in parameter.\n    */\n    function bytesToAddress(bytes _bytes) internal pure returns (address addr) {\n        assembly {\n            addr := mload(add(_bytes, 20))\n        }\n    }\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/MessageProcessor.sol\n\npragma solidity 0.4.24;\n\n\n\ncontract MessageProcessor is EternalStorage {\n    bytes32 internal constant MESSAGE_SENDER = 0x7b58b2a669d8e0992eae9eaef641092c0f686fd31070e7236865557fa1571b5b; // keccak256(abi.encodePacked(\"messageSender\"))\n    bytes32 internal constant MESSAGE_ID = 0xe34bb2103dc34f2c144cc216c132d6ffb55dac57575c22e089161bbe65083304; // keccak256(abi.encodePacked(\"messageId\"))\n    bytes32 internal constant MESSAGE_SOURCE_CHAIN_ID = 0x7f0fcd9e49860f055dd0c1682d635d309ecb5e3011654c716d9eb59a7ddec7d2; // keccak256(abi.encodePacked(\"messageSourceChainId\"))\n\n    /**\n    * @dev Returns a status of the message that came from the other side.\n    * @param _messageId id of the message from the other side that triggered a call.\n    * @return true if call executed successfully.\n    */\n    function messageCallStatus(bytes32 _messageId) external view returns (bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"messageCallStatus\", _messageId))];\n    }\n\n    /**\n    * @dev Sets a status of the message that came from the other side.\n    * @param _messageId id of the message from the other side that triggered a call.\n    * @param _status execution status, true if executed successfully.\n    */\n    function setMessageCallStatus(bytes32 _messageId, bool _status) internal {\n        boolStorage[keccak256(abi.encodePacked(\"messageCallStatus\", _messageId))] = _status;\n    }\n\n    /**\n    * @dev Returns a data hash of the failed message that came from the other side.\n    * NOTE: dataHash was used previously to identify outgoing message before AMB message id was introduced.\n    * It is kept for backwards compatibility with old mediators contracts.\n    * @param _messageId id of the message from the other side that triggered a call.\n    * @return keccak256 hash of message data.\n    */\n    function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32) {\n        return bytes32(uintStorage[keccak256(abi.encodePacked(\"failedMessageDataHash\", _messageId))]);\n    }\n\n    /**\n    * @dev Sets a data hash of the failed message that came from the other side.\n    * NOTE: dataHash was used previously to identify outgoing message before AMB message id was introduced.\n    * It is kept for backwards compatibility with old mediators contracts.\n    * @param _messageId id of the message from the other side that triggered a call.\n    * @param data of the processed message.\n    */\n    function setFailedMessageDataHash(bytes32 _messageId, bytes data) internal {\n        uintStorage[keccak256(abi.encodePacked(\"failedMessageDataHash\", _messageId))] = uint256(keccak256(data));\n    }\n\n    /**\n    * @dev Returns a receiver address of the failed message that came from the other side.\n    * @param _messageId id of the message from the other side that triggered a call.\n    * @return receiver address.\n    */\n    function failedMessageReceiver(bytes32 _messageId) external view returns (address) {\n        return addressStorage[keccak256(abi.encodePacked(\"failedMessageReceiver\", _messageId))];\n    }\n\n    /**\n    * @dev Sets a sender address of the failed message that came from the other side.\n    * @param _messageId id of the message from the other side that triggered a call.\n    * @param _receiver address of the receiver.\n    */\n    function setFailedMessageReceiver(bytes32 _messageId, address _receiver) internal {\n        addressStorage[keccak256(abi.encodePacked(\"failedMessageReceiver\", _messageId))] = _receiver;\n    }\n\n    /**\n    * @dev Returns a sender address of the failed message that came from the other side.\n    * @param _messageId id of the message from the other side that triggered a call.\n    * @return sender address on the other side.\n    */\n    function failedMessageSender(bytes32 _messageId) external view returns (address) {\n        return addressStorage[keccak256(abi.encodePacked(\"failedMessageSender\", _messageId))];\n    }\n\n    /**\n    * @dev Sets a sender address of the failed message that came from the other side.\n    * @param _messageId id of the message from the other side that triggered a call.\n    * @param _sender address of the sender on the other side.\n    */\n    function setFailedMessageSender(bytes32 _messageId, address _sender) internal {\n        addressStorage[keccak256(abi.encodePacked(\"failedMessageSender\", _messageId))] = _sender;\n    }\n\n    /**\n    * @dev Returns an address of the sender on the other side for the currently processed message.\n    * Can be used by executors for getting other side caller address.\n    * @return address of the sender on the other side.\n    */\n    function messageSender() external view returns (address) {\n        return addressStorage[MESSAGE_SENDER];\n    }\n\n    /**\n    * @dev Sets an address of the sender on the other side for the currently processed message.\n    * @param _sender address of the sender on the other side.\n    */\n    function setMessageSender(address _sender) internal {\n        addressStorage[MESSAGE_SENDER] = _sender;\n    }\n\n    /**\n    * @dev Returns an id of the currently processed message.\n    * @return id of the message that originated on the other side.\n    */\n    function messageId() public view returns (bytes32) {\n        return bytes32(uintStorage[MESSAGE_ID]);\n    }\n\n    /**\n    * @dev Returns an id of the currently processed message.\n    * NOTE: transactionHash was used previously to identify incoming message before AMB message id was introduced.\n    * It is kept for backwards compatibility with old mediators contracts, although it doesn't return txHash anymore.\n    * @return id of the message that originated on the other side.\n    */\n    function transactionHash() external view returns (bytes32) {\n        return messageId();\n    }\n\n    /**\n    * @dev Sets a message id of the currently processed message.\n    * @param _messageId id of the message that originated on the other side.\n    */\n    function setMessageId(bytes32 _messageId) internal {\n        uintStorage[MESSAGE_ID] = uint256(_messageId);\n    }\n\n    /**\n    * @dev Returns an originating chain id of the currently processed message.\n    * @return source chain id of the message that originated on the other side.\n    */\n    function messageSourceChainId() external view returns (uint256) {\n        return uintStorage[MESSAGE_SOURCE_CHAIN_ID];\n    }\n\n    /**\n    * @dev Returns an originating chain id of the currently processed message.\n    * @return source chain id of the message that originated on the other side.\n    */\n    function setMessageSourceChainId(uint256 _sourceChainId) internal returns (uint256) {\n        uintStorage[MESSAGE_SOURCE_CHAIN_ID] = _sourceChainId;\n    }\n\n    /**\n    * @dev Processes received message. Makes a call to the message executor,\n    * sets dataHash, receive, sender variables for failed messages.\n    * @param _sender sender address on the other side.\n    * @param _executor address of an executor.\n    * @param _messageId id of the processed message.\n    * @param _gasLimit gas limit for a call to executor.\n    * @param _sourceChainId source chain id is of the received message.\n    * @param _data calldata for a call to executor.\n    */\n    function processMessage(\n        address _sender,\n        address _executor,\n        bytes32 _messageId,\n        uint256 _gasLimit,\n        bytes1, /* dataType */\n        uint256, /* gasPrice */\n        uint256 _sourceChainId,\n        bytes memory _data\n    ) internal {\n        bool status = _passMessage(_sender, _executor, _data, _gasLimit, _messageId, _sourceChainId);\n\n        setMessageCallStatus(_messageId, status);\n        if (!status) {\n            setFailedMessageDataHash(_messageId, _data);\n            setFailedMessageReceiver(_messageId, _executor);\n            setFailedMessageSender(_messageId, _sender);\n        }\n        emitEventOnMessageProcessed(_sender, _executor, _messageId, status);\n    }\n\n    /**\n    * @dev Makes a call to the message executor.\n    * @param _sender sender address on the other side.\n    * @param _contract address of an executor contract.\n    * @param _data calldata for a call to executor.\n    * @param _gas gas limit for a call to executor.\n    * @param _messageId id of the processed message.\n    * @param _sourceChainId source chain id is of the received message.\n    */\n    function _passMessage(\n        address _sender,\n        address _contract,\n        bytes _data,\n        uint256 _gas,\n        bytes32 _messageId,\n        uint256 _sourceChainId\n    ) internal returns (bool) {\n        setMessageSender(_sender);\n        setMessageId(_messageId);\n        setMessageSourceChainId(_sourceChainId);\n        bool status = _contract.call.gas(_gas)(_data);\n        setMessageSender(address(0));\n        setMessageId(bytes32(0));\n        setMessageSourceChainId(0);\n        return status;\n    }\n\n    /* solcov ignore next */\n    function emitEventOnMessageProcessed(address sender, address executor, bytes32 messageId, bool status) internal;\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/MessageDelivery.sol\n\npragma solidity 0.4.24;\n\n\n\n\n\n\ncontract MessageDelivery is BasicAMB, MessageProcessor {\n    using SafeMath for uint256;\n\n    /**\n    * @dev Requests message relay to the opposite network\n    * @param _contract executor address on the other side\n    * @param _data calldata passed to the executor on the other side\n    * @param _gas gas limit used on the other network for executing a message\n    */\n    function requireToPassMessage(address _contract, bytes _data, uint256 _gas) public returns (bytes32) {\n        // it is not allowed to pass messages while other messages are processed\n        require(messageId() == bytes32(0));\n\n        require(_gas >= getMinimumGasUsage(_data) && _gas <= maxGasPerTx());\n\n        bytes32 _messageId;\n        bytes memory header = _packHeader(_contract, _gas);\n        _setNonce(_nonce() + 1);\n\n        assembly {\n            _messageId := mload(add(header, 32))\n        }\n\n        bytes memory eventData = abi.encodePacked(header, _data);\n\n        emitEventOnMessageRequest(_messageId, eventData);\n        return _messageId;\n    }\n\n    /**\n    * @dev Returns a lower limit on gas limit for the particular message data\n    * @param _data calldata passed to the executor on the other side\n    */\n    function getMinimumGasUsage(bytes _data) public pure returns (uint256 gas) {\n        // From Ethereum Yellow Paper\n        // 68 gas is paid for every non-zero byte of data or code for a transaction\n        // Starting from Istanbul hardfork, 16 gas is paid (EIP-2028)\n        return _data.length.mul(16);\n    }\n\n    /**\n    * @dev Packs message header into a single bytes blob\n    * @param _contract executor address on the other side\n    * @param _gas gas limit used on the other network for executing a message\n    */\n    function _packHeader(address _contract, uint256 _gas) internal view returns (bytes memory header) {\n        uint256 sourceChainId = _sourceChainId();\n        uint256 sourceChainIdLength = _sourceChainIdLength();\n        uint256 destinationChainId = _destinationChainId();\n        uint256 destinationChainIdLength = _destinationChainIdLength();\n\n        bytes32 mVer = MESSAGE_PACKING_VERSION;\n        uint256 nonce = _nonce();\n\n        // Bridge id is recalculated every time again and again, since it is still cheaper than using SLOAD opcode (800 gas)\n        bytes32 bridgeId = keccak256(abi.encodePacked(sourceChainId, address(this))) &\n            0x00000000ffffffffffffffffffffffffffffffffffffffff0000000000000000;\n        // 79 = 4 + 20 + 8 + 20 + 20 + 4 + 1 + 1 + 1\n        header = new bytes(79 + sourceChainIdLength + destinationChainIdLength);\n\n        // In order to save the gas, the header is packed in the reverse order.\n        // With such approach, it is possible to store right-aligned values without any additional bit shifts.\n        assembly {\n            let ptr := add(header, mload(header)) // points to the last word of header\n            mstore(ptr, destinationChainId)\n            mstore(sub(ptr, destinationChainIdLength), sourceChainId)\n\n            mstore(add(header, 79), 0x00)\n            mstore(add(header, 78), destinationChainIdLength)\n            mstore(add(header, 77), sourceChainIdLength)\n            mstore(add(header, 76), _gas)\n            mstore(add(header, 72), _contract)\n            mstore(add(header, 52), caller)\n\n            mstore(add(header, 32), or(mVer, or(bridgeId, nonce)))\n        }\n    }\n\n    /* solcov ignore next */\n    function emitEventOnMessageRequest(bytes32 messageId, bytes encodedData) internal;\n}\n\n// File: contracts/upgradeable_contracts/MessageRelay.sol\n\npragma solidity 0.4.24;\n\n\ncontract MessageRelay is EternalStorage {\n    function relayedMessages(bytes32 _txHash) public view returns (bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"relayedMessages\", _txHash))];\n    }\n\n    function setRelayedMessages(bytes32 _txHash, bool _status) internal {\n        boolStorage[keccak256(abi.encodePacked(\"relayedMessages\", _txHash))] = _status;\n    }\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/BasicForeignAMB.sol\n\npragma solidity 0.4.24;\n\n\n\n\n\n\ncontract BasicForeignAMB is BasicAMB, MessageRelay, MessageDelivery {\n    /**\n    * @dev Validates provided signatures and relays a given message\n    * @param _data bytes to be relayed\n    * @param _signatures bytes blob with signatures to be validated\n    */\n    function executeSignatures(bytes _data, bytes _signatures) external {\n        Message.hasEnoughValidSignatures(_data, _signatures, validatorContract(), true);\n\n        bytes32 messageId;\n        address sender;\n        address executor;\n        uint32 gasLimit;\n        bytes1 dataType;\n        uint256[2] memory chainIds;\n        uint256 gasPrice;\n        bytes memory data;\n\n        (messageId, sender, executor, gasLimit, dataType, chainIds, gasPrice, data) = ArbitraryMessage.unpackData(\n            _data\n        );\n        require(_isMessageVersionValid(messageId));\n        require(_isDestinationChainIdValid(chainIds[1]));\n        require(!relayedMessages(messageId));\n        setRelayedMessages(messageId, true);\n        processMessage(sender, executor, messageId, gasLimit, dataType, gasPrice, chainIds[0], data);\n    }\n}\n\n// File: contracts/upgradeable_contracts/arbitrary_message/ForeignAMB.sol\n\npragma solidity 0.4.24;\n\n\ncontract ForeignAMB is BasicForeignAMB {\n    event UserRequestForAffirmation(bytes32 indexed messageId, bytes encodedData);\n    event RelayedMessage(address indexed sender, address indexed executor, bytes32 indexed messageId, bool status);\n\n    function emitEventOnMessageRequest(bytes32 messageId, bytes encodedData) internal {\n        emit UserRequestForAffirmation(messageId, encodedData);\n    }\n\n    function emitEventOnMessageProcessed(address sender, address executor, bytes32 messageId, bool status) internal {\n        emit RelayedMessage(sender, executor, messageId, status);\n    }\n}\n","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"transactionHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_txHash\",\"type\":\"bytes32\"}],\"name\":\"relayedMessages\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sourceChainId\",\"type\":\"uint256\"},{\"name\":\"_destinationChainId\",\"type\":\"uint256\"},{\"name\":\"_validatorContract\",\"type\":\"address\"},{\"name\":\"_maxGasPerTx\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"name\":\"_requiredBlockConfirmations\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredBlockConfirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"executeSignatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getMinimumGasUsage\",\"outputs\":[{\"name\":\"gas\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_messageId\",\"type\":\"bytes32\"}],\"name\":\"failedMessageReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBridgeMode\",\"outputs\":[{\"name\":\"_data\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sourceChainId\",\"type\":\"uint256\"},{\"name\":\"_destinationChainId\",\"type\":\"uint256\"}],\"name\":\"setChainIds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_messageId\",\"type\":\"bytes32\"}],\"name\":\"failedMessageSender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"messageId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxGasPerTx\",\"type\":\"uint256\"}],\"name\":\"setMaxGasPerTx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployedAtBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBridgeInterfacesVersion\",\"outputs\":[{\"name\":\"major\",\"type\":\"uint64\"},{\"name\":\"minor\",\"type\":\"uint64\"},{\"name\":\"patch\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"messageSourceChainId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockConfirmations\",\"type\":\"uint256\"}],\"name\":\"setRequiredBlockConfirmations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_messageId\",\"type\":\"bytes32\"}],\"name\":\"messageCallStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"messageSender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"requireToPassMessage\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_messageId\",\"type\":\"bytes32\"}],\"name\":\"failedMessageDataHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGasPerTx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"encodedData\",\"type\":\"bytes\"}],\"name\":\"UserRequestForAffirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"RelayedMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"GasPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requiredBlockConfirmations\",\"type\":\"uint256\"}],\"name\":\"RequiredBlockConfirmationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ForeignAMB","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}