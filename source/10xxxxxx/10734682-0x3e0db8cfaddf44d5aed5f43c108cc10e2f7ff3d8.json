{"status":"1","message":"OK","result":[{"SourceCode":"// Dependency file: contracts/interfaces/IERC20.sol\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// Dependency file: contracts/ballots/DemaxBallot.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n// pragma solidity >=0.6.6;\r\n\r\n// import '../interfaces/IERC20.sol';\r\n\r\n/**\r\n * @title DemaxBallot\r\n * @dev Implements voting process along with vote delegation\r\n */\r\ncontract DemaxBallot {\r\n\r\n    struct Voter {\r\n        uint weight; // weight is accumulated by delegation\r\n        bool voted;  // if true, that person already voted\r\n        address delegate; // person delegated to\r\n        uint vote;   // index of the voted proposal\r\n    }\r\n\r\n    mapping(address => Voter) public voters;\r\n    mapping(uint => uint) public proposals;\r\n\r\n    address public governor;\r\n    address public proposer;\r\n    uint public value;\r\n    uint public endBlockNumber;\r\n    bool public ended;\r\n    string public subject;\r\n    string public content;\r\n\r\n    uint private constant NONE = 0;\r\n    uint private constant YES = 1;\r\n    uint private constant NO = 2;\r\n\r\n    uint public total;\r\n    uint public createTime;\r\n\r\n    modifier onlyGovernor() {\r\n        require(msg.sender == governor, 'DemaxBallot: FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new ballot.\r\n     */\r\n    constructor(address _proposer, uint _value, uint _endBlockNumber, address _governor, string memory _subject, string memory _content) public {\r\n        proposer = _proposer;\r\n        value = _value;\r\n        endBlockNumber = _endBlockNumber;\r\n        governor = _governor;\r\n        subject = _subject;\r\n        content = _content;\r\n        proposals[YES] = 0;\r\n        proposals[NO] = 0;\r\n        createTime = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Give 'voter' the right to vote on this ballot.\r\n     * @param voter address of voter\r\n     */\r\n    function _giveRightToVote(address voter) private returns (Voter storage) {\r\n        require(block.number < endBlockNumber, \"Bollot is ended\");\r\n        Voter storage sender = voters[voter];\r\n        require(!sender.voted, \"You already voted\");\r\n        sender.weight += IERC20(governor).balanceOf(voter);\r\n        require(sender.weight != 0, \"Has no right to vote\");\r\n        return sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Delegate your vote to the voter 'to'.\r\n     * @param to address to which vote is delegated\r\n     */\r\n    function delegate(address to) public {\r\n        Voter storage sender = _giveRightToVote(msg.sender);\r\n        require(to != msg.sender, \"Self-delegation is disallowed\");\r\n\r\n        while (voters[to].delegate != address(0)) {\r\n            to = voters[to].delegate;\r\n\r\n            // We found a loop in the delegation, not allowed.\r\n            require(to != msg.sender, \"Found loop in delegation\");\r\n        }\r\n        sender.voted = true;\r\n        sender.delegate = to;\r\n        Voter storage delegate_ = voters[to];\r\n        if (delegate_.voted) {\r\n            // If the delegate already voted,\r\n            // directly add to the number of votes\r\n            proposals[delegate_.vote] += sender.weight;\r\n            total += sender.weight;\r\n        } else {\r\n            // If the delegate did not vote yet,\r\n            // add to her weight.\r\n            delegate_.weight += sender.weight;\r\n            total += sender.weight;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\r\n     * @param proposal index of proposal in the proposals array\r\n     */\r\n    function vote(uint proposal) public {\r\n        Voter storage sender = _giveRightToVote(msg.sender);\r\n        require(proposal==YES || proposal==NO, 'Only vote 1 or 2');\r\n        sender.voted = true;\r\n        sender.vote = proposal;\r\n        proposals[proposal] += sender.weight;\r\n        total += sender.weight;\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the winning proposal taking all previous votes into account.\r\n     * @return winningProposal_ index of winning proposal in the proposals array\r\n     */\r\n    function winningProposal() public view returns (uint) {\r\n        if (proposals[YES] > proposals[NO]) {\r\n            return YES;\r\n        } else if (proposals[YES] < proposals[NO]) {\r\n            return NO;\r\n        } else {\r\n            return NONE;\r\n        }\r\n    }\r\n\r\n    function result() public view returns (bool) {\r\n        uint winner = winningProposal();\r\n        if (winner == YES) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function end() public onlyGovernor returns (bool) {\r\n        require(block.number >= endBlockNumber, \"ballot not yet ended\");\r\n        require(!ended, \"end has already been called\");\r\n        ended = true;\r\n        return result();\r\n    }\r\n\r\n    function weight(address user) external view returns (uint) {\r\n        Voter memory voter = voters[user];\r\n        return voter.weight;\r\n    }\r\n\r\n}\r\n\r\npragma solidity >=0.6.6;\r\n\r\n// import \"./DemaxBallot.sol\";\r\n\r\ncontract DemaxBallotFactory {\r\n\r\n    event Created(address indexed proposer, address indexed ballotAddr, uint createTime);\r\n\r\n    constructor () public {\r\n    }\r\n\r\n    function create(address _proposer, uint _value, uint _endBlockNumber, string calldata _subject, string calldata _content) external returns (address) {\r\n        require(_value >= 0, 'DemaxBallotFactory: INVALID_PARAMTERS');\r\n        address ballotAddr = address(\r\n            new DemaxBallot(_proposer, _value, _endBlockNumber, msg.sender, _subject, _content)\r\n        );\r\n        emit Created(_proposer, ballotAddr, block.timestamp);\r\n        return ballotAddr;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ballotAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_subject\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_content\",\"type\":\"string\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DemaxBallotFactory","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4f8013c095ddb2ce1f68810e827614009f18891dda950c5664871a9d5b725999"}]}