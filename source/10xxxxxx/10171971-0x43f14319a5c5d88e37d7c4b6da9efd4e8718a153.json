{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title Wallet\r\n/// @dev Base contract for smart wallets.\r\n///      Sub-contracts must NOT use non-default constructor to initialize\r\n///      wallet states, instead, `init` shall be used. This is to enable\r\n///      proxies to be deployed in front of the real wallet contract for\r\n///      saving gas.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\ninterface Wallet\r\n{\r\n    function owner() external view returns (address);\r\n\r\n    /// @dev Set a new owner.\r\n    function setOwner(address newOwner) external;\r\n\r\n    /// @dev Set up this wallet by assigning an original owner and a\r\n    ///      list of initial modules. For each module, its `init` method\r\n    ///      will be called with `address(this)` as the parameter.\r\n    ///\r\n    ///      Note that calling this method more than once will throw.\r\n    ///\r\n    /// @param _controller The Controller instance.\r\n    /// @param _owner The owner of this wallet, must not be address(0).\r\n    /// @param _boostrapModule The bootstrap module.\r\n    function setup(address _controller, address _owner, address _boostrapModule) external;\r\n\r\n    /// @dev Adds a new module. The `init` method of the module\r\n    ///      will be called with `address(this)` as the parameter.\r\n    ///      This method must throw if the module has already been added.\r\n    /// @param _module The module's address.\r\n    function addModule(address _module) external;\r\n\r\n    /// @dev Removes an existing module. This method must throw if the module\r\n    ///      has NOT been added or the module is the wallet's only module.\r\n    /// @param _module The module's address.\r\n    function removeModule(address _module) external;\r\n\r\n    /// @dev Returns the list of modules added to this wallet in the order\r\n    ///      they were added.\r\n    /// @return _modules The list of modules added to this wallet.\r\n    function modules() external view returns (address[] memory _modules);\r\n\r\n    /// @dev Checks if a module has been added to this wallet.\r\n    /// @param _module The module to check.\r\n    /// @return True if the module exists; False otherwise.\r\n    function hasModule(address _module) external view returns (bool);\r\n\r\n    /// @dev Binds a method from the given module to this\r\n    ///      wallet so the method can be invoked using this wallet's default\r\n    ///      function.\r\n    ///      Note that this method must throw when the given module has\r\n    ///      not been added to this wallet.\r\n    /// @param _method The method's 4-byte selector.\r\n    /// @param _module The module's address. Use address(0) to unbind the method.\r\n    function bindMethod(bytes4 _method, address _module) external;\r\n\r\n    /// @dev Returns the module the given method has been bound to.\r\n    /// @param _method The method's 4-byte selector.\r\n    /// @return _module The address of the bound module. If no binding exists,\r\n    ///                 returns address(0) instead.\r\n    function boundMethodModule(bytes4 _method) external view returns (address _module);\r\n\r\n    /// @dev Performs generic transactions. Any module that has been added to this\r\n    ///      wallet can use this method to transact on any third-party contract with\r\n    ///      msg.sender as this wallet itself.\r\n    ///\r\n    ///      This method will emit `Transacted` event if it doesn't throw.\r\n    ///\r\n    ///      Note: this method must ONLY allow invocations from a module that has\r\n    ///      been added to this wallet. The wallet owner shall NOT be permitted\r\n    ///      to call this method directly.\r\n    ///\r\n    /// @param mode The transaction mode, 1 for CALL, 2 for DELEGATECALL.\r\n    /// @param to The desitination address.\r\n    /// @param value The amount of Ether to transfer.\r\n    /// @param data The data to send over using `to.call{value: value}(data)`\r\n    /// @return returnData The transaction's return value.\r\n    function transact(\r\n        uint8    mode,\r\n        address  to,\r\n        uint     value,\r\n        bytes    calldata data\r\n        )\r\n        external\r\n        returns (bytes memory returnData);\r\n}\r\n\r\n\r\n\r\n/// @title DataStore\r\n/// @dev Modules share states by accessing the same storage instance.\r\n///      Using ModuleStorage will achieve better module decoupling.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\ncontract DataStore\r\n{\r\n  modifier onlyWalletModule(address wallet)\r\n    {\r\n        require(Wallet(wallet).hasModule(msg.sender), \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n}\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\nlibrary Data\r\n{\r\n    struct Guardian\r\n    {\r\n        address  addr;\r\n        uint     group;\r\n        uint     validSince;\r\n        uint     validUntil;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title SecurityStore\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by Argent's contract codebase:\r\n/// https://github.com/argentlabs/argent-contracts\r\ncontract SecurityStore is DataStore\r\n{\r\n    struct Wallet\r\n    {\r\n        address    inheritor;\r\n        uint128    lastActive; // the latest timestamp the owner is considered to be active\r\n        uint128    lock;\r\n        address    lockedBy;   // the module that locked the wallet.\r\n\r\n        Data.Guardian[]            guardians;\r\n        mapping (address => uint)  guardianIdx;\r\n    }\r\n\r\n    mapping (address => Wallet) public wallets;\r\n\r\n    constructor() public DataStore() {}\r\n\r\n    function isGuardian(\r\n        address wallet,\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        Data.Guardian memory guardian = getGuardian(wallet, addr);\r\n        return guardian.addr != address(0) && isGuardianValid(guardian);\r\n    }\r\n\r\n    function isGuardianOrPendingAddition(\r\n        address wallet,\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        Data.Guardian memory guardian = getGuardian(wallet, addr);\r\n        return guardian.addr != address(0) && (isGuardianValid(guardian) || isGuardianPendingAddition(guardian));\r\n    }\r\n\r\n    function getGuardian(\r\n        address wallet,\r\n        address guardianAddr\r\n        )\r\n        public\r\n        view\r\n        returns (Data.Guardian memory)\r\n    {\r\n        uint index = wallets[wallet].guardianIdx[guardianAddr];\r\n        if(index > 0) {\r\n            return wallets[wallet].guardians[index-1];\r\n        }\r\n    }\r\n\r\n    function guardians(address wallet)\r\n        public\r\n        view\r\n        returns (Data.Guardian[] memory validGuardians)\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        validGuardians = new Data.Guardian[](w.guardians.length);\r\n        uint index = 0;\r\n        for (uint i = 0; i < w.guardians.length; i++) {\r\n            Data.Guardian memory g = w.guardians[i];\r\n            if (isGuardianValid(g)) {\r\n                validGuardians[index] = g;\r\n                index ++;\r\n            }\r\n        }\r\n        assembly { mstore(validGuardians, index) }\r\n    }\r\n\r\n    function numGuardians(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return guardians(wallet).length;\r\n    }\r\n\r\n    function numGuardiansWithPending(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        uint num = 0;\r\n        for (uint i = 0; i < w.guardians.length; i++) {\r\n            Data.Guardian memory g = w.guardians[i];\r\n            if (isGuardianValid(g) || isGuardianPendingAddition(g)) {\r\n                num ++;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n\r\n    function addGuardian(\r\n        address wallet,\r\n        address guardianAddr,\r\n        uint    group,\r\n        uint    validSince\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        cleanRemovedGuardians(wallet);\r\n\r\n        require(guardianAddr != address(0), \"ZERO_ADDRESS\");\r\n        Wallet storage w = wallets[wallet];\r\n\r\n        uint pos = w.guardianIdx[guardianAddr];\r\n        require(pos == 0, \"GUARDIAN_EXISTS\");\r\n\r\n        // Add the new guardian\r\n        Data.Guardian memory g = Data.Guardian(guardianAddr, group, validSince, 0);\r\n        w.guardians.push(g);\r\n        w.guardianIdx[guardianAddr] = w.guardians.length;\r\n    }\r\n\r\n    function cancelGuardianAddition(\r\n        address wallet,\r\n        address guardianAddr\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        cleanRemovedGuardians(wallet);\r\n\r\n        Wallet storage w = wallets[wallet];\r\n        uint idx = w.guardianIdx[guardianAddr];\r\n        require(idx > 0, \"GUARDIAN_NOT_EXISTS\");\r\n        require(\r\n            isGuardianPendingAddition(w.guardians[idx - 1]),\r\n            \"NOT_PENDING_ADDITION\"\r\n        );\r\n\r\n        Data.Guardian memory lastGuardian = w.guardians[w.guardians.length - 1];\r\n        if (guardianAddr != lastGuardian.addr) {\r\n            w.guardians[idx - 1] = lastGuardian;\r\n            w.guardianIdx[lastGuardian.addr] = idx;\r\n        }\r\n        w.guardians.pop();\r\n        delete w.guardianIdx[guardianAddr];\r\n    }\r\n\r\n    function removeGuardian(\r\n        address wallet,\r\n        address guardianAddr,\r\n        uint    validUntil\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        cleanRemovedGuardians(wallet);\r\n\r\n        Wallet storage w = wallets[wallet];\r\n        uint idx = w.guardianIdx[guardianAddr];\r\n        require(idx > 0, \"GUARDIAN_NOT_EXISTS\");\r\n\r\n        w.guardians[idx - 1].validUntil = validUntil;\r\n    }\r\n\r\n    function removeAllGuardians(address wallet)\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n         Wallet storage w = wallets[wallet];\r\n         for (uint i = 0; i < w.guardians.length; i++) {\r\n            delete w.guardianIdx[w.guardians[i].addr];\r\n         }\r\n         delete w.guardians;\r\n    }\r\n\r\n    function cancelGuardianRemoval(\r\n        address wallet,\r\n        address guardianAddr\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        cleanRemovedGuardians(wallet);\r\n\r\n        Wallet storage w = wallets[wallet];\r\n        uint idx = w.guardianIdx[guardianAddr];\r\n        require(idx > 0, \"GUARDIAN_NOT_EXISTS\");\r\n\r\n        require(\r\n            isGuardianPendingRemoval(w.guardians[idx - 1]),\r\n            \"NOT_PENDING_REMOVAL\"\r\n         );\r\n\r\n        w.guardians[idx - 1].validUntil = 0;\r\n    }\r\n\r\n    function getLock(address wallet)\r\n        public\r\n        view\r\n        returns (uint _lock, address _module)\r\n    {\r\n        _lock = uint(wallets[wallet].lock);\r\n        _module = wallets[wallet].lockedBy;\r\n    }\r\n\r\n    function setLock(\r\n        address wallet,\r\n        uint    lock\r\n        )\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        require(lock == 0 || lock > now, \"INVALID_LOCK_TIME\");\r\n        uint128 _lock = uint128(lock);\r\n        require(uint(_lock) == lock, \"LOCK_TOO_LARGE\");\r\n\r\n        wallets[wallet].lock = _lock;\r\n        wallets[wallet].lockedBy = msg.sender;\r\n    }\r\n\r\n    function touchLastActive(address wallet)\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        wallets[wallet].lastActive = uint128(now);\r\n    }\r\n\r\n    function inheritor(address wallet)\r\n        public\r\n        view\r\n        returns (\r\n            address who,\r\n            uint    lastActive\r\n        )\r\n    {\r\n        who = wallets[wallet].inheritor;\r\n        lastActive = uint(wallets[wallet].lastActive);\r\n    }\r\n\r\n    function setInheritor(address wallet, address who)\r\n        public\r\n        onlyWalletModule(wallet)\r\n    {\r\n        wallets[wallet].inheritor = who;\r\n        wallets[wallet].lastActive = uint128(now);\r\n    }\r\n\r\n    function cleanRemovedGuardians(address wallet)\r\n        private\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n\r\n        for (int i = int(w.guardians.length) - 1; i >= 0; i--) {\r\n            Data.Guardian memory g = w.guardians[uint(i)];\r\n            if (isGuardianExpired(g)) {\r\n                Data.Guardian memory lastGuardian = w.guardians[w.guardians.length - 1];\r\n\r\n                if (g.addr != lastGuardian.addr) {\r\n                    w.guardians[uint(i)] = lastGuardian;\r\n                    w.guardianIdx[lastGuardian.addr] = uint(i) + 1;\r\n                }\r\n                w.guardians.pop();\r\n                delete w.guardianIdx[g.addr];\r\n            }\r\n        }\r\n    }\r\n\r\n    function isGuardianValid(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.validSince > 0 && guardian.validSince <= now &&\r\n            !isGuardianExpired(guardian);\r\n    }\r\n\r\n    function isGuardianPendingAddition(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.validSince > now;\r\n    }\r\n\r\n    function isGuardianPendingRemoval(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.validUntil > now;\r\n    }\r\n\r\n    function isGuardianExpired(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.validUntil > 0 &&\r\n            guardian.validUntil <= now;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardianAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validSince\",\"type\":\"uint256\"}],\"name\":\"addGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardianAddr\",\"type\":\"address\"}],\"name\":\"cancelGuardianAddition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardianAddr\",\"type\":\"address\"}],\"name\":\"cancelGuardianRemoval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardianAddr\",\"type\":\"address\"}],\"name\":\"getGuardian\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validSince\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct Data.Guardian\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_lock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"guardians\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validSince\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct Data.Guardian[]\",\"name\":\"validGuardians\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"inheritor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastActive\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isGuardian\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isGuardianOrPendingAddition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"numGuardians\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"numGuardiansWithPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"removeAllGuardians\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardianAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"}],\"name\":\"removeGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setInheritor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lock\",\"type\":\"uint256\"}],\"name\":\"setLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"touchLastActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"inheritor\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"lastActive\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lock\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"lockedBy\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SecurityStore","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://01bc7ea1496b107568260e0548803945c8e23866cfdc86f47bb267ff6bc842d6"}]}