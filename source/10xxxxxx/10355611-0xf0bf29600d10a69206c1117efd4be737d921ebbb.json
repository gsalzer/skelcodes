{"status":"1","message":"OK","result":[{"SourceCode":"// Insidual Token $DUAL - A DEFLATIONARY TOKEN WITH A PURPOSE\r\n// Inspired by the open source project SHUFFLE\r\n//--------------------------------------------\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event TransferOwnership(address _from, address _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit TransferOwnership(address(0), msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner) external onlyOwner {\r\n        emit TransferOwnership(owner, _owner);\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ncontract StorageUnit {\r\n    address private owner;\r\n    mapping(bytes32 => bytes32) private store;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function write(bytes32 _key, bytes32 _value) external {\r\n        /* solium-disable-next-line */\r\n        require(msg.sender == owner);\r\n        store[_key] = _value;\r\n    }\r\n\r\n    function read(bytes32 _key) external view returns (bytes32) {\r\n        return store[_key];\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\nlibrary IsContract {\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        /* solium-disable-next-line */\r\n        assembly { codehash := extcodehash(_addr) }\r\n        return codehash != bytes32(0) && codehash != bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\nlibrary DistributedStorage {\r\n    function contractSlot(bytes32 _struct) private view returns (address) {\r\n        return address(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0xff),\r\n                        address(this),\r\n                        _struct,\r\n                        keccak256(type(StorageUnit).creationCode)\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    function deploy(bytes32 _struct) private {\r\n        bytes memory slotcode = type(StorageUnit).creationCode;\r\n        /* solium-disable-next-line */\r\n        assembly{ pop(create2(0, add(slotcode, 0x20), mload(slotcode), _struct)) }\r\n    }\r\n\r\n    function write(\r\n        bytes32 _struct,\r\n        bytes32 _key,\r\n        bytes32 _value\r\n    ) internal {\r\n        StorageUnit store = StorageUnit(contractSlot(_struct));\r\n        if (!IsContract.isContract(address(store))) {\r\n            deploy(_struct);\r\n        }\r\n\r\n        /* solium-disable-next-line */\r\n        (bool success, ) = address(store).call(\r\n            abi.encodeWithSelector(\r\n                store.write.selector,\r\n                _key,\r\n                _value\r\n            )\r\n        );\r\n\r\n        require(success, \"error writing storage\");\r\n    }\r\n\r\n    function read(\r\n        bytes32 _struct,\r\n        bytes32 _key\r\n    ) internal view returns (bytes32) {\r\n        StorageUnit store = StorageUnit(contractSlot(_struct));\r\n        if (!IsContract.isContract(address(store))) {\r\n            return bytes32(0);\r\n        }\r\n\r\n        /* solium-disable-next-line */\r\n        (bool success, bytes memory data) = address(store).staticcall(\r\n            abi.encodeWithSelector(\r\n                store.read.selector,\r\n                _key\r\n            )\r\n        );\r\n\r\n        require(success, \"error reading storage\");\r\n        return abi.decode(data, (bytes32));\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ncontract Inject {\r\n    bytes32 private stub;\r\n\r\n    modifier requestGas(uint256 _factor) {\r\n        if (tx.gasprice == 0 || gasleft() > block.gaslimit) {\r\n            uint256 startgas = gasleft();\r\n            _;\r\n            uint256 delta = startgas - gasleft();\r\n            uint256 target = (delta * _factor) / 100;\r\n            startgas = gasleft();\r\n            while (startgas - gasleft() < target) {\r\n\r\n                stub = keccak256(abi.encodePacked(stub));\r\n            }\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\nlibrary AddressMinMound {\r\n    using AddressMinMound for AddressMinMound.Mound;\r\n\r\n    struct Mound {\r\n        uint256[] entries;\r\n        mapping(address => uint256) index;\r\n    }\r\n\r\n    function initialize(Mound storage _mound) internal {\r\n        require(_mound.entries.length == 0, \"already initialized\");\r\n        _mound.entries.push(0);\r\n    }\r\n\r\n    function encode(address _addr, uint256 _value) internal pure returns (uint256 _entry) {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            _entry := not(or(and(0xffffffffffffffffffffffffffffffffffffffff, _addr), shl(160, _value)))\r\n        }\r\n    }\r\n\r\n    function decode(uint256 _entry) internal pure returns (address _addr, uint256 _value) {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            let entry := not(_entry)\r\n            _addr := and(entry, 0xffffffffffffffffffffffffffffffffffffffff)\r\n            _value := shr(160, entry)\r\n        }\r\n    }\r\n\r\n    function decodeAddress(uint256 _entry) internal pure returns (address _addr) {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            _addr := and(not(_entry), 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n    }\r\n\r\n    function top(Mound storage _mound) internal view returns(address, uint256) {\r\n        if (_mound.entries.length < 2) {\r\n            return (address(0), 0);\r\n        }\r\n\r\n        return decode(_mound.entries[1]);\r\n    }\r\n\r\n    function has(Mound storage _mound, address _addr) internal view returns (bool) {\r\n        return _mound.index[_addr] != 0;\r\n    }\r\n\r\n    function size(Mound storage _mound) internal view returns (uint256) {\r\n        return _mound.entries.length - 1;\r\n    }\r\n\r\n    function entry(Mound storage _mound, uint256 _i) internal view returns (address, uint256) {\r\n        return decode(_mound.entries[_i + 1]);\r\n    }\r\n\r\n    function popTop(Mound storage _mound) internal returns(address _addr, uint256 _value) {\r\n        // Mound true or false\r\n        uint256 moundLength = _mound.entries.length;\r\n        require(moundLength > 1, \"The mound does not exist\");\r\n\r\n        // Origin Mound Value\r\n        (_addr, _value) = decode(_mound.entries[1]);\r\n        _mound.index[_addr] = 0;\r\n\r\n        if (moundLength == 2) {\r\n            _mound.entries.length = 1;\r\n        } else {\r\n            uint256 val = _mound.entries[moundLength - 1];\r\n            _mound.entries[1] = val;\r\n            _mound.entries.length = moundLength - 1;\r\n\r\n            uint256 ind = 1;\r\n\r\n            ind = _mound.deflatIt(ind, val);\r\n\r\n            _mound.index[decodeAddress(val)] = ind;\r\n        }\r\n    }\r\n\r\n    function insert(Mound storage _mound, address _addr, uint256 _value) internal {\r\n        require(_mound.index[_addr] == 0, \"The entry already exists\");\r\n\r\n        uint256 encoded = encode(_addr, _value);\r\n        _mound.entries.push(encoded);\r\n\r\n        uint256 currentIndex = _mound.entries.length - 1;\r\n\r\n        currentIndex = _mound.inflatIt(currentIndex, encoded);\r\n\r\n        _mound.index[_addr] = currentIndex;\r\n    }\r\n\r\n    function update(Mound storage _mound, address _addr, uint256 _value) internal {\r\n        uint256 ind = _mound.index[_addr];\r\n        require(ind != 0, \"The entry does not exist\");\r\n\r\n        uint256 can = encode(_addr, _value);\r\n        uint256 val = _mound.entries[ind];\r\n        uint256 newInd;\r\n\r\n        if (can < val) {\r\n            // deflate It\r\n            newInd = _mound.deflatIt(ind, can);\r\n        } else if (can > val) {\r\n            // inflate It\r\n            newInd = _mound.inflatIt(ind, can);\r\n        } else {\r\n\r\n            return;\r\n        }\r\n\r\n        _mound.entries[newInd] = can;\r\n\r\n        if (newInd != ind) {\r\n            _mound.index[_addr] = newInd;\r\n        }\r\n    }\r\n\r\n    function inflatIt(Mound storage _mound, uint256 _ind, uint256 _val) internal returns (uint256 ind) {\r\n        ind = _ind;\r\n        if (ind != 1) {\r\n            uint256 parent = _mound.entries[ind / 2];\r\n            while (parent < _val) {\r\n                (_mound.entries[ind / 2], _mound.entries[ind]) = (_val, parent);\r\n\r\n                _mound.index[decodeAddress(parent)] = ind;\r\n\r\n                ind = ind / 2;\r\n                if (ind == 1) {\r\n                    break;\r\n                }\r\n                parent = _mound.entries[ind / 2];\r\n            }\r\n        }\r\n    }\r\n\r\n    function deflatIt(Mound storage _mound, uint256 _ind, uint256 _val) internal returns (uint256 ind) {\r\n\r\n        ind = _ind;\r\n\r\n        uint256 lenght = _mound.entries.length;\r\n        uint256 target = lenght - 1;\r\n\r\n        while (ind * 2 < lenght) {\r\n\r\n            uint256 j = ind * 2;\r\n\r\n            uint256 leftChild = _mound.entries[j];\r\n\r\n            uint256 childValue;\r\n\r\n            if (target > j) {\r\n\r\n                uint256 rightChild = _mound.entries[j + 1];\r\n\r\n                if (leftChild < rightChild) {\r\n                    childValue = rightChild;\r\n                    j = j + 1;\r\n                } else {\r\n\r\n                    childValue = leftChild;\r\n                }\r\n            } else {\r\n\r\n                childValue = leftChild;\r\n            }\r\n\r\n            if (_val > childValue) {\r\n                break;\r\n            }\r\n\r\n            (_mound.entries[ind], _mound.entries[j]) = (childValue, _val);\r\n\r\n            _mound.index[decodeAddress(childValue)] = ind;\r\n\r\n            ind = j;\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ncontract Mound is Ownable {\r\n    using AddressMinMound for AddressMinMound.Mound;\r\n\r\n    // Mound\r\n    AddressMinMound.Mound private mound;\r\n\r\n    // Mound events\r\n    event Joinmound(address indexed _address, uint256 _balance, uint256 _prevSize);\r\n    event Leavemound(address indexed _address, uint256 _balance, uint256 _prevSize);\r\n\r\n    uint256 public constant TOP_SIZE = 100;\r\n\r\n    constructor() public {\r\n        mound.initialize();\r\n    }\r\n\r\n    function topSize() external pure returns (uint256) {\r\n        return TOP_SIZE;\r\n    }\r\n\r\n    function addressAt(uint256 _i) external view returns (address addr) {\r\n        (addr, ) = mound.entry(_i);\r\n    }\r\n\r\n    function indexOf(address _addr) external view returns (uint256) {\r\n        return mound.index[_addr];\r\n    }\r\n\r\n    function entry(uint256 _i) external view returns (address, uint256) {\r\n        return mound.entry(_i);\r\n    }\r\n\r\n    function top() external view returns (address, uint256) {\r\n        return mound.top();\r\n    }\r\n\r\n    function size() external view returns (uint256) {\r\n        return mound.size();\r\n    }\r\n\r\n    function update(address _addr, uint256 _new) external onlyOwner {\r\n        uint256 _size = mound.size();\r\n\r\n        if (_size == 0) {\r\n            emit Joinmound(_addr, _new, 0);\r\n            mound.insert(_addr, _new);\r\n            return;\r\n        }\r\n\r\n        (, uint256 lastBal) = mound.top();\r\n        if (mound.has(_addr)) {\r\n            mound.update(_addr, _new);\r\n             if (_new == 0) {\r\n                mound.popTop();\r\n                emit Leavemound(_addr, 0, _size);\r\n            }\r\n        } else {\r\n\r\n            if (_new != 0 && (_size < TOP_SIZE || lastBal < _new)) {\r\n        \r\n                if (_size >= TOP_SIZE) {\r\n                    (address _poped, uint256 _balance) = mound.popTop();\r\n                    emit Leavemound(_poped, _balance, _size);\r\n                }\r\n\r\n                // New\r\n                mound.insert(_addr, _new);\r\n                emit Joinmound(_addr, _new, _size);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ncontract InsidualToken is Ownable, Inject, IERC20 {\r\n    using DistributedStorage for bytes32;\r\n    using SafeMath for uint256;\r\n\r\n    // Distribution\r\n    event Choosen(address indexed _addr, uint256 _value);\r\n\r\n    // Org\r\n    event SetName(string _prev, string _new);\r\n    event SetExtraGas(uint256 _prev, uint256 _new);\r\n    event Setmound(address _prev, address _new);\r\n    event WhitelistFrom(address _addr, bool _whitelisted);\r\n    event WhitelistTo(address _addr, bool _whitelisted);\r\n\r\n    uint256 public totalSupply;\r\n\r\n    bytes32 private constant BALANCE_KEY = keccak256(\"balance\");\r\n\r\n    // Mechanism\r\n    uint256 public constant FEE = 50;\r\n\r\n    // Token\r\n    string public name = \"Insidual Token\";\r\n    string public constant symbol = \"DUAL\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    // fee whitelist\r\n    mapping(address => bool) public whitelistFrom;\r\n    mapping(address => bool) public whitelistTo;\r\n\r\n    // mound\r\n    Mound public mound;\r\n\r\n    // internal\r\n    uint256 public extraGas;\r\n    bool inited;\r\n\r\n    function init(\r\n        address _to,\r\n        uint256 _amount\r\n    ) external {\r\n        // Init limited to one\r\n        assert(!inited);\r\n        inited = true;\r\n\r\n        assert(totalSupply == 0);\r\n        assert(address(mound) == address(0));\r\n\r\n        // Create mound\r\n        mound = new Mound();\r\n        emit Setmound(address(0), address(mound));\r\n\r\n        extraGas = 15;\r\n        emit SetExtraGas(0, extraGas);\r\n        emit Transfer(address(0), _to, _amount);\r\n        _setBalance(_to, _amount);\r\n        totalSupply = _amount;\r\n    }\r\n\r\n    // Get Functions\r\n\r\n    function _toKey(address a) internal pure returns (bytes32) {\r\n        return bytes32(uint256(a));\r\n    }\r\n\r\n    function _balanceOf(address _addr) internal view returns (uint256) {\r\n        return uint256(_toKey(_addr).read(BALANCE_KEY));\r\n    }\r\n\r\n    function _allowance(address _addr, address _spender) internal view returns (uint256) {\r\n        return uint256(_toKey(_addr).read(keccak256(abi.encodePacked(\"allowance\", _spender))));\r\n    }\r\n\r\n    function _nonce(address _addr, uint256 _cat) internal view returns (uint256) {\r\n        return uint256(_toKey(_addr).read(keccak256(abi.encodePacked(\"nonce\", _cat))));\r\n    }\r\n\r\n    // Set Functions\r\n\r\n    function _setAllowance(address _addr, address _spender, uint256 _value) internal {\r\n        _toKey(_addr).write(keccak256(abi.encodePacked(\"allowance\", _spender)), bytes32(_value));\r\n    }\r\n\r\n    function _setNonce(address _addr, uint256 _cat, uint256 _value) internal {\r\n        _toKey(_addr).write(keccak256(abi.encodePacked(\"nonce\", _cat)), bytes32(_value));\r\n    }\r\n\r\n    function _setBalance(address _addr, uint256 _balance) internal {\r\n        _toKey(_addr).write(BALANCE_KEY, bytes32(_balance));\r\n        mound.update(_addr, _balance);\r\n    }\r\n\r\n    // Distribution Functions\r\n\r\n    function _isWhitelisted(address _from, address _to) internal view returns (bool) {\r\n        return whitelistFrom[_from]||whitelistTo[_to];\r\n    }\r\n\r\n    function _random(address _s1, uint256 _s2, uint256 _s3, uint256 _max) internal pure returns (uint256) {\r\n        uint256 rand = uint256(keccak256(abi.encodePacked(_s1, _s2, _s3)));\r\n        return rand % (_max + 1);\r\n    }\r\n\r\n    function _pickChoosen(address _from, uint256 _value) internal returns (address choosen) {\r\n        uint256 magnitude = Math.orderOfMagnitude(_value);\r\n        uint256 nonce = _nonce(_from, magnitude);\r\n        _setNonce(_from, magnitude, nonce + 1);\r\n        // choose from mound\r\n        choosen = mound.addressAt(_random(_from, nonce, magnitude, mound.size() - 1));\r\n    }\r\n\r\n    function _transferFrom(address _operator, address _from, address _to, uint256 _value, bool _payFee) internal {\r\n        if (_value == 0) {\r\n            emit Transfer(_from, _to, 0);\r\n            return;\r\n        }\r\n\r\n        uint256 balanceFrom = _balanceOf(_from);\r\n        require(balanceFrom >= _value, \"balance not enough\");\r\n\r\n        if (_from != _operator) {\r\n            uint256 allowanceFrom = _allowance(_from, _operator);\r\n            if (allowanceFrom != uint(-1)) {\r\n                require(allowanceFrom >= _value, \"allowance not enough\");\r\n                _setAllowance(_from, _operator, allowanceFrom.sub(_value));\r\n            }\r\n        }\r\n\r\n        uint256 receive = _value;\r\n        uint256 burn = 0;\r\n        uint256 distribute = 0;\r\n\r\n        _setBalance(_from, balanceFrom.sub(_value));\r\n\r\n        // Fees Calculation\r\n        if (_payFee || !_isWhitelisted(_from, _to)) {\r\n            // SAME for BURN and DISTRIBUTION\r\n            burn = _value.divRound(FEE);\r\n            distribute = _value == 1 ? 0 : burn;\r\n\r\n            receive = receive.sub(burn.add(distribute));\r\n\r\n            // Burn \r\n            totalSupply = totalSupply.sub(burn);\r\n            emit Transfer(_from, address(0), burn);\r\n\r\n            // Distribute to choosen add\r\n            address choosen = _pickChoosen(_from, _value);\r\n            // Tokens to choosen\r\n            _setBalance(choosen, _balanceOf(choosen).add(distribute));\r\n            emit Choosen(choosen, distribute);\r\n            emit Transfer(_from, choosen, distribute);\r\n        }\r\n\r\n        assert(burn.add(distribute).add(receive) == _value);\r\n\r\n        _setBalance(_to, _balanceOf(_to).add(receive));\r\n        emit Transfer(_from, _to, receive);\r\n    }\r\n\r\n    // Org functions\r\n\r\n    function setWhitelistedTo(address _addr, bool _whitelisted) external onlyOwner {\r\n        emit WhitelistTo(_addr, _whitelisted);\r\n        whitelistTo[_addr] = _whitelisted;\r\n    }\r\n\r\n    function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyOwner {\r\n        emit WhitelistFrom(_addr, _whitelisted);\r\n        whitelistFrom[_addr] = _whitelisted;\r\n    }\r\n\r\n    function setName(string calldata _name) external onlyOwner {\r\n        emit SetName(name, _name);\r\n        name = _name;\r\n    }\r\n\r\n    function setExtraGas(uint256 _gas) external onlyOwner {\r\n        emit SetExtraGas(extraGas, _gas);\r\n        extraGas = _gas;\r\n    }\r\n\r\n    function setmound(Mound _mound) external onlyOwner {\r\n        emit Setmound(address(mound), address(_mound));\r\n        mound = _mound;\r\n    }\r\n\r\n    // Mound functions\r\n\r\n    function topSize() external view returns (uint256) {\r\n        return mound.topSize();\r\n    }\r\n\r\n    function moundSize() external view returns (uint256) {\r\n        return mound.size();\r\n    }\r\n\r\n    function moundEntry(uint256 _i) external view returns (address, uint256) {\r\n        return mound.entry(_i);\r\n    }\r\n\r\n    function moundTop() external view returns (address, uint256) {\r\n        return mound.top();\r\n    }\r\n\r\n    function moundIndex(address _addr) external view returns (uint256) {\r\n        return mound.indexOf(_addr);\r\n    }\r\n\r\n    function getNonce(address _addr, uint256 _cat) external view returns (uint256) {\r\n        return _nonce(_addr, _cat);\r\n    }\r\n\r\n    // ERC20 functions\r\n\r\n    function balanceOf(address _addr) external view returns (uint256) {\r\n        return _balanceOf(_addr);\r\n    }\r\n\r\n    function allowance(address _addr, address _spender) external view returns (uint256) {\r\n        return _allowance(_addr, _spender);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool) {\r\n        emit Approval(msg.sender, _spender, _value);\r\n        _setAllowance(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\r\n        _transferFrom(msg.sender, msg.sender, _to, _value, false);\r\n        return true;\r\n    }\r\n\r\n    function transferWithFee(address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\r\n        _transferFrom(msg.sender, msg.sender, _to, _value, true);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\r\n        _transferFrom(msg.sender, _from, _to, _value, false);\r\n        return true;\r\n    }\r\n\r\n    function transferFromWithFee(address _from, address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\r\n        _transferFrom(msg.sender, _from, _to, _value, true);\r\n        return true;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        uint256 z = x + y;\r\n        require(z >= x, \"Add overflow\");\r\n        return z;\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(x >= y, \"Sub underflow\");\r\n        return x - y;\r\n    }\r\n\r\n    function mult(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 z = x * y;\r\n        require(z / x == y, \"Mult overflow\");\r\n        return z;\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"Div by zero\");\r\n        return x / y;\r\n    }\r\n\r\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"Div by zero\");\r\n        uint256 r = x / y;\r\n        if (x % y != 0) {\r\n            r = r + 1;\r\n        }\r\n\r\n        return r;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\nlibrary Math {\r\n    function orderOfMagnitude(uint256 input) internal pure returns (uint256){\r\n        uint256 counter = uint(-1);\r\n        uint256 temp = input;\r\n\r\n        do {\r\n            temp /= 10;\r\n            counter++;\r\n        } while (temp != 0);\r\n\r\n        return counter;\r\n    }\r\n\r\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a < _b) {\r\n            return _a;\r\n        } else {\r\n            return _b;\r\n        }\r\n    }\r\n\r\n    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a > _b) {\r\n            return _a;\r\n        } else {\r\n            return _b;\r\n        }\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Choosen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prev\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"SetExtraGas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_prev\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_new\",\"type\":\"string\"}],\"name\":\"SetName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_prev\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"Setmound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"WhitelistFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"WhitelistTo\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cat\",\"type\":\"uint256\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mound\",\"outputs\":[{\"internalType\":\"contract Mound\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"moundEntry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"moundIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moundSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moundTop\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"setExtraGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Mound\",\"name\":\"_mound\",\"type\":\"address\"}],\"name\":\"setmound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"topSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromWithFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferWithFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"InsidualToken","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c319b6cca50a7b94c6e3bf2319668578dbc8c0d9d851e3945190d8d6f790ef18"}]}