{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y > 0, \"ds-math-div-overflow\");\r\n        z = x / y;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20SafeTransfer {\r\n    function doTransferOut(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal returns (bool) {\r\n        IERC20 token = IERC20(_token);\r\n        bool result;\r\n\r\n        token.transfer(_to, _amount);\r\n\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {\r\n                    result := not(0)\r\n                }\r\n                case 32 {\r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)\r\n                }\r\n                default {\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function doTransferFrom(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal returns (bool) {\r\n        IERC20 token = IERC20(_token);\r\n        bool result;\r\n\r\n        token.transferFrom(_from, _to, _amount);\r\n\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {\r\n                    result := not(0)\r\n                }\r\n                case 32 {\r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)\r\n                }\r\n                default {\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function doApprove(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal returns (bool) {\r\n        IERC20 token = IERC20(_token);\r\n        bool result;\r\n\r\n        token.approve(_to, _amount);\r\n\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {\r\n                    result := not(0)\r\n                }\r\n                case 32 {\r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)\r\n                }\r\n                default {\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\ninterface DFStore {\r\n    function getFeeRate(uint ct) external view returns (uint);\r\n    function getMinBurnAmount() external view returns (uint);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface DFProtocolView {\r\n    function getPrice(uint _tokenIdx) external view returns (uint);\r\n    function getFeeRate(uint _processIdx) external view returns (uint);\r\n}\r\n\r\ninterface DFProtocol{\r\n    function deposit(address _tokenID, uint _feeTokenIdx, uint _tokenAmount) external returns (uint);\r\n    function destroy(uint _feeTokenIdx, uint _usdxAmount) external;\r\n}\r\n\r\ninterface Curve {\r\n    function exchange_underlying(int128 inputIndex, int128 outputIndex, uint256 inputAmount, uint256 minOutput) external;\r\n}\r\n\r\ninterface IChi {\r\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\r\n}\r\n\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() external view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract swapUSDx is ERC20SafeTransfer, Ownable {\r\n    using SafeMath for uint256;\r\n    uint256 private BASE = 10 ** 18;\r\n\r\n    event SwapUSDx(address targetToken, uint256 inputAmount, uint256 outputAmount);\r\n\r\n    constructor () public {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    IChi public chi = IChi(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n\r\n    address internal USDx = 0xeb269732ab75A6fD61Ea60b06fE994cD32a83549;\r\n    address internal DF = 0x431ad2ff6a9C365805eBaD47Ee021148d6f7DBe0;\r\n\r\n    address internal DFEngineContract = 0x3ea496977A356024bE096c1068a57Bd0B92c7d7c;\r\n    DFProtocol internal DFProtocolContract = DFProtocol(0x5843F1Ccc5baA448528eb0e8Bc567Cda7eD1A1E8);\r\n    DFProtocolView internal DFProtocolViewContract = DFProtocolView(0x097Dd22173f0e382daE42baAEb9bDBC9fdf3396F);\r\n    DFStore internal DFStoreContract = DFStore(0xD30d06b276867CfA2266542791242fF37C91BA8d);\r\n\r\n    address internal yPool = 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;\r\n    address internal paxPool = 0x06364f10B501e868329afBc005b3492902d6C763;\r\n    address internal sUSD = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\r\n\r\n    address internal uniswapRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    address[] public underlyingTokens = [\r\n        0x8E870D67F660D95d5be530380D0eC0bd388289E1, // PAX\r\n        0x0000000000085d4780B73119b644AE5ecd22b376, // TUSD\r\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48  // USDC\r\n    ];\r\n\r\n    address internal USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n\r\n    modifier discountCHI {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 *  msg.data.length;\r\n        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\r\n    }\r\n\r\n    /**\r\n     * @dev Based on current DF price and the amount of USDx, calculate how many DF does the\r\n     *      `msg.sender` need when destroies USDx.\r\n     * @param _amount Total amount of USDx would be destroied.\r\n     */\r\n    function getDFAmount(uint256 _amount) internal view returns (uint256) {\r\n        // 0 means DF\r\n        uint256 _dfPrice =  DFProtocolViewContract.getPrice(uint256(0));\r\n        // 1 means this processing is `destroy`\r\n        uint256 _rate = DFProtocolViewContract.getFeeRate(uint256(1));\r\n        uint256 _dfAmount = _amount.mul(_rate).mul(BASE).div(uint256(10000).mul(_dfPrice));\r\n        return _dfAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate how many USDx will the `msg.sender` cost when wants to get a specific\r\n     *      amount of DF.\r\n     * @param _amount Total amount of DF would be cost.\r\n     */\r\n    function getSpendingUSDxAmount(uint256 _amount) internal view returns (uint256) {\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = USDx;\r\n        _path[1] = DF;\r\n        uint[] memory _returnAmounts = IUniswapV2Router(uniswapRouter).getAmountsIn(_amount, _path);\r\n        return _returnAmounts[0];\r\n    }\r\n\r\n    /**\r\n     * @dev Uses this function to prepare for all authority needed.\r\n     */\r\n    function multiApprove() external onlyOwner discountCHI returns (bool) {\r\n        // When swaps USDx to DF in the uniswap.\r\n        require(doApprove(USDx, uniswapRouter, uint256(-1)), \"multiApprove: approve uniswap failed!\");\r\n        // When destroy USDx.\r\n        // - 1. DF.approve(DFEngineContract, -1)\r\n        require(doApprove(DF, DFEngineContract, uint256(-1)), \"multiApprove: DF approves DFEngine failed!\");\r\n        // - 2. USDx.approve(DFEngineContract, -1)\r\n        require(doApprove(USDx, DFEngineContract, uint256(-1)), \"multiApprove: USDx approves DFEngine failed!\");\r\n        // When swaps token to get USDC\r\n        require(doApprove(underlyingTokens[0], paxPool, uint256(-1)), \"multiApprove: PAX approves paxpool failed!\");\r\n        require(doApprove(underlyingTokens[1], yPool, uint256(-1)), \"multiApprove: TUSD approves ypool failed!\");\r\n        // When swaps token to get USDT\r\n        require(doApprove(underlyingTokens[2], sUSD, uint256(-1)), \"multiApprove: USDC approves sUSD failed!\");\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps USDx to DF in the Uniswap.\r\n     * @param _inputAmount Amount of USDx to swap to get DF.\r\n     */\r\n    function swapUSDxToDF(uint256 _inputAmount) internal {\r\n        uint256 _dfAmount =  getDFAmount(_inputAmount);\r\n        uint256 _expectedUSDxAmount = getSpendingUSDxAmount(_dfAmount);\r\n        uint256 _usdxAmount =  _expectedUSDxAmount % DFStoreContract.getMinBurnAmount() > 0\r\n                              ? (_expectedUSDxAmount / DFStoreContract.getMinBurnAmount() + 1) * DFStoreContract.getMinBurnAmount()\r\n                              : _expectedUSDxAmount ;\r\n\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = USDx;\r\n        _path[1] = DF;\r\n\r\n        // swap parts of USDx to DF.\r\n        IUniswapV2Router(uniswapRouter).swapExactTokensForTokens(\r\n            _usdxAmount,\r\n            _dfAmount,\r\n            _path,\r\n            address(this),\r\n            block.timestamp + 3600\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the final amount of target token when swaps.\r\n     * @param _targetToken Asset that swaps to get.\r\n     * @param _inputAmount Amount to swap.\r\n     * @param _minReturn Minimum amount to get when swaps.\r\n     */\r\n    function getAmountOut(address _targetToken, uint256 _inputAmount, uint256 _minReturn) external returns (uint256) {\r\n        // transfer USDx from user to this contract.\r\n        require(\r\n            doTransferFrom(\r\n                USDx,\r\n                msg.sender,\r\n                address(this),\r\n                _inputAmount\r\n            ),\r\n            \"swap: USDx transferFrom failed!\"\r\n        );\r\n\r\n        swapUSDxToDF(_inputAmount);\r\n\r\n        // destroy the remaining USDx with DF.\r\n        DFProtocolContract.destroy(0, IERC20(USDx).balanceOf(address(this)));\r\n\r\n        if (_targetToken == underlyingTokens[2]){\r\n            // TUSD -> USDC\r\n            uint256 _totalAmount = IERC20(underlyingTokens[1]).balanceOf(address(this));\r\n            Curve(yPool).exchange_underlying(int128(3), int128(1), _totalAmount,uint256(0));\r\n            // PAX -> USDC\r\n            _totalAmount = IERC20(underlyingTokens[0]).balanceOf(address(this));\r\n            Curve(paxPool).exchange_underlying(int128(3), int128(1), _totalAmount,uint256(0));\r\n        } else if (_targetToken == USDT) {\r\n            // USDC -> USDT\r\n            uint256 _totalAmount = IERC20(underlyingTokens[2]).balanceOf(address(this));\r\n            Curve(sUSD).exchange_underlying(int128(1), int128(2), _totalAmount,uint256(0));\r\n            // TUSD -> USDT\r\n            _totalAmount = IERC20(underlyingTokens[1]).balanceOf(address(this));\r\n            Curve(yPool).exchange_underlying(int128(3), int128(2), _totalAmount,uint256(0));\r\n            // PAX -> USDC\r\n            _totalAmount = IERC20(underlyingTokens[0]).balanceOf(address(this));\r\n            Curve(paxPool).exchange_underlying(int128(3), int128(2), _totalAmount,uint256(0));\r\n        }\r\n\r\n        uint256 _finalBalance = IERC20(_targetToken).balanceOf(address(this));\r\n        // transfer target token to caller`msg.sender`\r\n        require(doTransferOut(_targetToken, msg.sender, _finalBalance), \"swap: Transfer targetToken out failed!\");\r\n        require(doTransferOut(DF, msg.sender, IERC20(DF).balanceOf(address(this))), \"swap: Transfer DF out failed!\");\r\n\r\n        emit SwapUSDx(_targetToken, _inputAmount, _finalBalance);\r\n        return _finalBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps token to get target token.\r\n     * @param _targetToken Asset that swaps to get.\r\n     * @param _inputAmount Amount to swap.\r\n     * @param _minReturn Minimum amount to get when swaps.\r\n     */\r\n    function swapUSDxTo(address _targetToken, uint256 _inputAmount, uint256 _minReturn) public discountCHI returns (uint256) {\r\n        // transfer USDx from user to this contract.\r\n        require(\r\n            doTransferFrom(\r\n                USDx,\r\n                msg.sender,\r\n                address(this),\r\n                _inputAmount\r\n            ),\r\n            \"swap: USDx transferFrom failed!\"\r\n        );\r\n\r\n        swapUSDxToDF(_inputAmount);\r\n\r\n        // destroy the remaining USDx with DF.\r\n        DFProtocolContract.destroy(0, IERC20(USDx).balanceOf(address(this)));\r\n\r\n        if (_targetToken == underlyingTokens[2]){\r\n            // TUSD -> USDC\r\n            uint256 _totalAmount = IERC20(underlyingTokens[1]).balanceOf(address(this));\r\n            Curve(yPool).exchange_underlying(int128(3), int128(1), _totalAmount, uint256(0));\r\n            // PAX -> USDC\r\n            _totalAmount = IERC20(underlyingTokens[0]).balanceOf(address(this));\r\n            Curve(paxPool).exchange_underlying(int128(3), int128(1), _totalAmount, uint256(0));\r\n        } else if (_targetToken == USDT) {\r\n            // USDC -> USDT\r\n            uint256 _totalAmount = IERC20(underlyingTokens[2]).balanceOf(address(this));\r\n            Curve(sUSD).exchange_underlying(int128(1), int128(2), _totalAmount, uint256(0));\r\n            // TUSD -> USDT\r\n            _totalAmount = IERC20(underlyingTokens[1]).balanceOf(address(this));\r\n            Curve(yPool).exchange_underlying(int128(3), int128(2), _totalAmount, uint256(0));\r\n            // PAX -> USDT\r\n            _totalAmount = IERC20(underlyingTokens[0]).balanceOf(address(this));\r\n            Curve(paxPool).exchange_underlying(int128(3), int128(2), _totalAmount, uint256(0));\r\n        }\r\n\r\n        uint256 _finalBalance = IERC20(_targetToken).balanceOf(address(this));\r\n        require(_finalBalance >= _minReturn, \"swap: Too large slippage to succeed!\");\r\n        // transfer target token to caller`msg.sender`\r\n        require(doTransferOut(_targetToken, msg.sender, _finalBalance), \"swap: Transfer targetToken out failed!\");\r\n        require(doTransferOut(DF, msg.sender, IERC20(DF).balanceOf(address(this))), \"swap: Transfer DF out failed!\");\r\n\r\n        emit SwapUSDx(_targetToken, _inputAmount, _finalBalance);\r\n        return _finalBalance;\r\n    }\r\n\r\n    function swapStep1(address _targetToken, uint256 _inputAmount, uint256 _minReturn) public discountCHI {\r\n        // transfer USDx from user to this contract.\r\n        require(\r\n            doTransferFrom(\r\n                USDx,\r\n                msg.sender,\r\n                address(this),\r\n                _inputAmount\r\n            ),\r\n            \"swap: USDx transferFrom failed!\"\r\n        );\r\n\r\n        swapUSDxToDF(_inputAmount);\r\n\r\n        // destroy the remaining USDx with DF.\r\n        DFProtocolContract.destroy(0, IERC20(USDx).balanceOf(address(this)));\r\n    }\r\n\r\n    function swapStep2() public discountCHI {\r\n        // USDC -> USDT\r\n        uint256 _totalAmount = IERC20(underlyingTokens[2]).balanceOf(address(this));\r\n        Curve(sUSD).exchange_underlying(int128(1), int128(2), _totalAmount, uint256(0));\r\n    }\r\n\r\n    function swapStep3() public discountCHI {\r\n        // TUSD -> USDT\r\n        uint256 _totalAmount = IERC20(underlyingTokens[1]).balanceOf(address(this));\r\n        Curve(yPool).exchange_underlying(int128(3), int128(2), _totalAmount, uint256(0));\r\n    }\r\n\r\n    function swapStep4() public discountCHI {\r\n        // PAX -> USDT\r\n        uint256 _totalAmount = IERC20(underlyingTokens[0]).balanceOf(address(this));\r\n        Curve(paxPool).exchange_underlying(int128(3), int128(2), _totalAmount, uint256(0));\r\n    }\r\n\r\n    function swapStep5(address _targetToken, uint256 _minReturn) public discountCHI {\r\n        uint256 _finalBalance = IERC20(_targetToken).balanceOf(address(this));\r\n        require(_finalBalance >= _minReturn, \"swap: Too large slippage to succeed!\");\r\n        // transfer target token to caller`msg.sender`\r\n        require(doTransferOut(_targetToken, msg.sender, _finalBalance), \"swap: Transfer targetToken out failed!\");\r\n\r\n    }\r\n\r\n    function swapStep6() public discountCHI {\r\n        require(doTransferOut(DF, msg.sender, IERC20(DF).balanceOf(address(this))), \"swap: Transfer DF out failed!\");\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer unexpected toke out, but only for owner.\r\n     */\r\n    function transferOut(address _token, address _to, uint256 _amount) external onlyOwner {\r\n        require(\r\n            doTransferOut(\r\n                _token,\r\n                _to,\r\n                _amount\r\n            ),\r\n            \"transferOut: Transfer token out failed!\"\r\n        );\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"name\":\"SwapUSDx\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"chi\",\"outputs\":[{\"internalType\":\"contract IChi\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"multiApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"swapStep1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"swapStep2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"swapStep3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"swapStep4\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"swapStep5\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"swapStep6\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"swapUSDxTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"underlyingTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"swapUSDx","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://88bef41d21ac5c8c2017ee917e6e19cf01f37fe4525344bd49d10b68685058e9"}]}