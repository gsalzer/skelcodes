{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/governance/AavePropositionPower.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Capped.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\\\";\\n\\n/// @title AavePropositionPower\\n/// @author Aave\\n/// @notice Asset to control the permissions on the actions in AaveProtoGovernance, like:\\n///  - Register a new Proposal\\ncontract AavePropositionPower is ERC20Capped, ERC20Detailed {\\n\\n    /// @notice Constructor\\n    /// @param name Asset name\\n    /// @param symbol Asset symbol\\n    /// @param decimals Asset decimals\\n    /// @param council List of addresses which will receive tokens initially\\n    /// @param cap The cap of tokens to mint, length of the council list\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals,\\n        address[] memory council,\\n        uint256 cap\\n    )\\n    public ERC20Capped(cap * 1 ether) ERC20Detailed(name, symbol, decimals) {\\n        require(cap == council.length, \\\"INCONSISTENT_CAP_AND_COUNCIL_SIZE\\\");\\n        for (uint256 i = 0; i < cap; i++) {\\n            _mint(council[i], 1 ether);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Capped.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20Mintable.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20Mintable} that adds a cap to the supply of tokens.\\n */\\ncontract ERC20Capped is ERC20Mintable {\\n    uint256 private _cap;\\n\\n    /**\\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\\n     * set once during construction.\\n     */\\n    constructor (uint256 cap) public {\\n        require(cap > 0, \\\"ERC20Capped: cap is 0\\\");\\n        _cap = cap;\\n    }\\n\\n    /**\\n     * @dev Returns the cap on the token's total supply.\\n     */\\n    function cap() public view returns (uint256) {\\n        return _cap;\\n    }\\n\\n    /**\\n     * @dev See {ERC20Mintable-mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `value` must not cause the total supply to go over the cap.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        require(totalSupply().add(value) <= _cap, \\\"ERC20Capped: cap exceeded\\\");\\n        super._mint(account, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Mintable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"../../access/roles/MinterRole.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\\n * which have permission to mint (create) new tokens as they see fit.\\n *\\n * At construction, the deployer of the contract is the only minter.\\n */\\ncontract ERC20Mintable is ERC20, MinterRole {\\n    /**\\n     * @dev See {ERC20-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the {MinterRole}.\\n     */\\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\\n        _mint(account, amount);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n     /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/roles/MinterRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"../Roles.sol\\\";\\n\\ncontract MinterRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    Roles.Role private _minters;\\n\\n    constructor () internal {\\n        _addMinter(_msgSender());\\n    }\\n\\n    modifier onlyMinter() {\\n        require(isMinter(_msgSender()), \\\"MinterRole: caller does not have the Minter role\\\");\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters.has(account);\\n    }\\n\\n    function addMinter(address account) public onlyMinter {\\n        _addMinter(account);\\n    }\\n\\n    function renounceMinter() public {\\n        _removeMinter(_msgSender());\\n    }\\n\\n    function _addMinter(address account) internal {\\n        _minters.add(account);\\n        emit MinterAdded(account);\\n    }\\n\\n    function _removeMinter(address account) internal {\\n        _minters.remove(account);\\n        emit MinterRemoved(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Roles.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/AaveProtoGovernance.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"../interfaces/IGovernanceParamsProvider.sol\\\";\\nimport \\\"../interfaces/IAssetVotingWeightProvider.sol\\\";\\nimport \\\"../interfaces/IProposalExecutor.sol\\\";\\nimport \\\"../interfaces/IAaveProtoGovernance.sol\\\";\\n\\n\\n/// @title AaveProtoGovernance\\n/// @author Aave\\n/// @notice Smart contract containing voting logic and registering voting proposals.\\n///  - Allows to granular resolution per proposal\\n///  - Fixes the voting logic\\n///  - Keeps all the data related with all the proposals\\n///  - Allows voters to submit, override or cancel votes directly\\n///  - Allows relayers to submit, override or cancel votes on behalf of voters\\n///  - Once the voting and validation periods finish, executes a DELEGATECALL to the proposalExecutor of the\\n///    corresponding proposal\\n///  - The creation of a new proposal can only be triggered by an account with a certain amount of AavePropositionPower\\ncontract AaveProtoGovernance is IAaveProtoGovernance {\\n    using SafeMath for uint256;\\n    using ECDSA for bytes32;\\n\\n    struct Voter {\\n        /// @notice Vote with 0 always as abstain.\\n        ///  In a YES/NO scenario, YES would be 1, NO would be 2\\n        uint256 vote;\\n        /// @notice Weight of the asset coming from the IAssetVotingWeightProvider\\n        uint256 weight;\\n        /// @notice Asset balance used to vote\\n        uint256 balance;\\n        /// @notice The nonce of the voter address, to protect agains vote replay attacks\\n        //  It is increased in 1 unit on both voting and cancel vote of an user. When the\\n        //  user vote overrides his previous vote, it is double increased\\n        uint256 nonce;\\n        /// @notice Address of the asset using to vote, locked in the voter address\\n        IERC20 asset;\\n    }\\n\\n    struct Proposal {\\n        /// @notice Hashed type of the proposal, for example keccak256(UPGRADE_ADDRESS_PROPOSAL)\\n        bytes32 proposalType;\\n        /// @notice Count of the current units of votes accumulated until the current moment (each time somebody votes + 1)\\n        uint256 totalVotes;\\n        /// @notice Threshold required calculated offchain from the aggregated total supply of the whitelisted\\n        ///  assets multiplied by the voting weight of each asset\\n        ///  Example: With 2 whitelisted tokens with 1 and 2 as respective voting weights and 10 000 and 20 000\\n        ///  respective total supplies, the aggregated voting power would be (10000 * 1) + (20000 * 2) = 50000,\\n        ///  so a threshold equivalent to the 50% of total voting power would be 25000\\n        uint256 threshold;\\n        /// @notice Variable to control how many changes to Voting state are allowed\\n        /// (both initially from Initializing and from Validating every time the threshold is crossed down\\n        ///  due to double votes)\\n        uint256 maxMovesToVotingAllowed;\\n        /// @notice Current amount of times the proposal went to Voting state\\n        uint256 movesToVoting;\\n        /// @notice Minimum number of blocks the proposal needs to be in Voting before being able to change to\\n        /// Validating\\n        uint256 votingBlocksDuration;\\n        /// @notice Minimum number of blocks the proposal needs to be in Validating before being able to be executed\\n        uint256 validatingBlocksDuration;\\n        /// @notice Block number where the current status started\\n        uint256 currentStatusInitBlock;\\n        /// @notice Block number when the proposal was created\\n        uint256 initProposalBlock;\\n        /// @notice Mapping choice id => voting power accumulated in the choice\\n        mapping(uint256 => uint256) votes;\\n        /// @notice Mapping of voters: Voting Wallet address => vote information\\n        mapping(address => Voter) voters;\\n        /// @notice Smart contract in charge of .execute() a certain payload\\n        address proposalExecutor;\\n        /// @notice Status of the proposal\\n        ProposalStatus proposalStatus;\\n    }\\n\\n    /// @notice State Machine\\n    ///  - Initializing: temporary state during the newProposal() execution, before changing to Voting.\\n    ///  - Voting: Once newProposal() execution finishes. Voters are able to vote or cancel their votes.\\n    ///  - Validating: After the voting period ends and the proposal threshold gets crossed by one of the\\n    ///      allowed choices. During this period, everybody is be able to call challengeVoters() in order\\n    ///      to invalidate votes result of double-voting attacks. If the threshold is crossed down at any point,\\n    ///      the state changes again to Voting. The validating period will have a defined time\\n    ///      length, after which (since the point where the proposal was moved from Voting status)\\n    ///      the resolveProposal() function could be called\\n    ///  - Executed: After the proposal is resolved\\n    enum ProposalStatus {Initializing, Voting, Validating, Executed}\\n\\n    event ProposalCreated(\\n        uint256 indexed proposalId,\\n        bytes32 indexed ipfsHash,\\n        bytes32 indexed proposalType,\\n        uint256 propositionPowerOfCreator,\\n        uint256 threshold,\\n        uint256 maxMovesToVotingAllowed,\\n        uint256 votingBlocksDuration,\\n        uint256 validatingBlocksDuration,\\n        address proposalExecutor\\n    );\\n    event StatusChangeToVoting(uint256 indexed proposalId, uint256 movesToVoting);\\n    event StatusChangeToValidating(uint256 indexed proposalId);\\n    event StatusChangeToExecuted(uint256 indexed proposalId);\\n    event VoteEmitted(\\n        uint256 indexed proposalId,\\n        address indexed voter,\\n        uint256 indexed vote,\\n        IERC20 asset,\\n        uint256 weight,\\n        uint256 balance\\n    );\\n    event VoteCancelled(\\n        uint256 indexed proposalId,\\n        address indexed voter,\\n        uint256 indexed vote,\\n        IERC20 asset,\\n        uint256 weight,\\n        uint256 balance,\\n        uint256 proposalStatusBefore\\n    );\\n    event YesWins(uint256 indexed proposalId, uint256 abstainVotingPower, uint256 yesVotingPower, uint256 noVotingPower);\\n    event NoWins(uint256 indexed proposalId, uint256 abstainVotingPower, uint256 yesVotingPower, uint256 noVotingPower);\\n    event AbstainWins(uint256 indexed proposalId, uint256 abstainVotingPower, uint256 yesVotingPower, uint256 noVotingPower);\\n\\n    /// @notice 0: Abstain, 1: YES, 2: NO\\n    uint256 public constant COUNT_CHOICES = 2;\\n\\n    /// @notice Taking as reference the LEND token supply, a minimum of 13M of LEND token (1% of supply)\\n    //  on the AssetVotingWeightProvider) can be set as threshold in a new proposal\\n    uint256 public constant MIN_THRESHOLD = 13000000 ether;\\n\\n    /// @notice Minimum number of blocks for a proposal's votingBlocksDuration and validatingBlocksDuration\\n    uint256 public constant MIN_STATUS_DURATION = 1660;  // ~6h with 13s blocktime\\n\\n    /// @notice Minimum for a proposal's maxMovesToVotingAllowed\\n    uint256 public constant MIN_MAXMOVESTOVOTINGALLOWED = 2;\\n\\n    /// @notice Maximum for a proposal's maxMovesToVotingAllowed\\n    uint256 public constant MAX_MAXMOVESTOVOTINGALLOWED = 6;\\n\\n    /// @notice Smart contract holding the global parameters needed in this AaveProtoGovernance\\n    IGovernanceParamsProvider private govParamsProvider;\\n\\n    Proposal[] private proposals;\\n\\n    constructor(IGovernanceParamsProvider _govParamsProvider) public {\\n        govParamsProvider = _govParamsProvider;\\n    }\\n\\n    /// @notice Fallback function, not allowing transfer of ETH\\n    function() external payable {\\n        revert(\\\"ETH_TRANSFER_NOT_ALLOWED\\\");\\n    }\\n\\n    /// @notice Registers a new proposal\\n    ///  - Allowed only for holders of aavePropositionPower with more than 100/propositionPowerThreshold % of the total supply\\n    ///  - It sets the proposalStatus of the proposal to Voting\\n    /// @param _proposalType Hashed type of the proposal\\n    /// @param _ipfsHash bytes32-formatted IPFS hash, removed the first 2 bytes of the multihash (multihash identifier)\\n    /// @param _threshold Threshold required calculated offchain from the aggregated total supply of the whitelisted\\n    ///                 assets multiplied by the voting weight of each asset\\n    /// @param _proposalExecutor Smart contract in charge of .execute() a certain payload\\n    /// @param _votingBlocksDuration Minimum number of blocks the proposal needs to be in Voting before being able\\n    ///                              to change to Validating\\n    /// @param _validatingBlocksDuration Minimum number of blocks the proposal needs to be in Validating before being\\n    ///                                  able to be executed\\n    /// @param _maxMovesToVotingAllowed Variable to control how many changes to Voting state are allowed\\n    function newProposal(\\n        bytes32 _proposalType,\\n        bytes32 _ipfsHash,\\n        uint256 _threshold,\\n        address _proposalExecutor,\\n        uint256 _votingBlocksDuration,\\n        uint256 _validatingBlocksDuration,\\n        uint256 _maxMovesToVotingAllowed\\n    ) external {\\n        IERC20 _propositionPower = govParamsProvider.getPropositionPower();\\n        uint256 _propositionPowerOfCreator = _propositionPower.balanceOf(msg.sender);\\n\\n        // Creation of block to avoid \\\"Stack too deep\\\"\\n        {\\n            uint256 _propositionPowerTotalSupply = _propositionPower.totalSupply();\\n            require(_propositionPowerTotalSupply > 0 &&\\n                _propositionPowerOfCreator >= _propositionPowerTotalSupply.div(govParamsProvider.getPropositionPowerThreshold()),\\n            \\\"INVALID_PROPOSITION_POWER_BALANCE\\\");\\n            require(_threshold >= MIN_THRESHOLD, \\\"INVALID_THRESHOLD\\\");\\n            require(_votingBlocksDuration >= MIN_STATUS_DURATION, \\\"INVALID_VOTING_BLOCKS_DURATION\\\");\\n            require(_validatingBlocksDuration >= MIN_STATUS_DURATION, \\\"INVALID_VALIDATING_BLOCKS_DURATION\\\");\\n            require(_maxMovesToVotingAllowed >= MIN_MAXMOVESTOVOTINGALLOWED &&\\n                _maxMovesToVotingAllowed <= MAX_MAXMOVESTOVOTINGALLOWED,\\n            \\\"INVALID_MAXVOTESTOVOTINGALLOWED\\\");\\n        }\\n\\n        uint256 _proposalId = proposals.push(Proposal({\\n            proposalType: _proposalType,\\n            totalVotes: 0,\\n            threshold: _threshold,\\n            maxMovesToVotingAllowed: _maxMovesToVotingAllowed,\\n            movesToVoting: 0,\\n            votingBlocksDuration: _votingBlocksDuration,\\n            validatingBlocksDuration: _validatingBlocksDuration,\\n            currentStatusInitBlock: 0,\\n            initProposalBlock: block.number,\\n            proposalExecutor: _proposalExecutor,\\n            proposalStatus: ProposalStatus.Initializing\\n        })).sub(1);\\n\\n        internalMoveToVoting(_proposalId);\\n\\n        emit ProposalCreated(\\n            _proposalId,\\n            _ipfsHash,\\n            _proposalType,\\n            _propositionPowerOfCreator,\\n            _threshold,\\n            _maxMovesToVotingAllowed,\\n            _votingBlocksDuration,\\n            _validatingBlocksDuration,\\n            _proposalExecutor\\n        );\\n    }\\n\\n    /// @notice Verifies the consistency of the action's params and their correct signature\\n    function verifyParamsConsistencyAndSignature(\\n        bytes32 _paramsHashByRelayer,\\n        bytes32 _paramsHashBySigner,\\n        bytes memory _signature,\\n        address _signer\\n    ) public pure {\\n        require(_paramsHashBySigner == _paramsHashByRelayer, \\\"INCONSISTENT_HASHES\\\");\\n        require(_signer == _paramsHashByRelayer.toEthSignedMessageHash().recover(_signature), \\\"SIGNATURE_NOT_VALID\\\");\\n    }\\n\\n    /// @notice Verifies the nonce of a voter on a proposal\\n    /// @param _proposalId The id of the proposal\\n    /// @param _voter The address of the voter\\n    /// @param _relayerNonce The nonce submitted by the relayer\\n    function verifyNonce(uint256 _proposalId, address _voter, uint256 _relayerNonce) public view {\\n        Proposal storage _proposal = proposals[_proposalId];\\n        require(_proposal.voters[_voter].nonce.add(1) == _relayerNonce, \\\"INVALID_NONCE\\\");\\n    }\\n\\n    /// @notice Validates an action submitted by a relayer\\n    /// @param _paramsHashByRelayer Hash of the params of the action, hashed by the relayer on-chain\\n    /// @param _paramsHashBySigner Hash of the params of the action, hashed by the signer off-chain, received by the relayer\\n    /// @param _signature Signature of the hashed params by the signer, created by the signer offchain, received by the relayer\\n    /// @param _signer The address of the signer\\n    /// @param _proposalId The id of the proposal\\n    /// @param _relayerNonce The nonce by the relayer\\n    function validateRelayAction(\\n        bytes32 _paramsHashByRelayer,\\n        bytes32 _paramsHashBySigner,\\n        bytes memory _signature,\\n        address _signer,\\n        uint256 _proposalId,\\n        uint256 _relayerNonce)\\n    public view {\\n        verifyParamsConsistencyAndSignature(_paramsHashByRelayer, _paramsHashBySigner, _signature, _signer);\\n        verifyNonce(_proposalId, _signer, _relayerNonce);\\n    }\\n\\n    /// @notice Internal function to change proposalStatus to Voting\\n    /// @param _proposalId The id of the proposal\\n    function internalMoveToVoting(uint256 _proposalId) internal {\\n        Proposal storage _proposal = proposals[_proposalId];\\n        _proposal.proposalStatus = ProposalStatus.Voting;\\n        _proposal.currentStatusInitBlock = block.number;\\n        _proposal.movesToVoting++;\\n        emit StatusChangeToVoting(_proposalId, _proposal.movesToVoting);\\n    }\\n\\n    /// @notice Internal function to change proposalStatus from Voting to Validating\\n    /// @param _proposalId The id of the proposal\\n    function internalMoveToValidating(uint256 _proposalId) internal {\\n        Proposal storage _proposal = proposals[_proposalId];\\n        _proposal.proposalStatus = ProposalStatus.Validating;\\n        _proposal.currentStatusInitBlock = block.number;\\n        emit StatusChangeToValidating(_proposalId);\\n    }\\n\\n    /// @notice Internal function to change proposalStatus from Validating to Executed\\n    ///  once the proposal is resolved\\n    /// @param _proposalId The id of the proposal\\n    function internalMoveToExecuted(uint256 _proposalId) internal {\\n        Proposal storage _proposal = proposals[_proposalId];\\n        _proposal.proposalStatus = ProposalStatus.Executed;\\n        emit StatusChangeToExecuted(_proposalId);\\n    }\\n\\n    /// @notice Function called by a voter to submit his vote directly\\n    function submitVoteByVoter(uint256 _proposalId, uint256 _vote, IERC20 _asset) external {\\n        internalSubmitVote(_proposalId, _vote, msg.sender, _asset);\\n    }\\n\\n    /// @notice Function called by any address relaying signed vote params from another wallet.\\n    //   Initially this relayer is thought to be a \\\"hot\\\" wallet of the voter,\\n    ///  allowing this way to keep the voting asset funds in a \\\"cold\\\" wallet, create an offline\\n    ///  signature with it and forwarding everything to the \\\"hot\\\" wallet to submit.\\n    ///  This function is completely opened, as the nonce + signature methods protects against\\n    ///  any malicious actor.\\n    function submitVoteByRelayer(\\n        uint256 _proposalId,\\n        uint256 _vote,\\n        address _voter,\\n        IERC20 _asset,\\n        uint256 _nonce,\\n        bytes calldata _signature,\\n        bytes32 _paramsHashByVoter)\\n    external {\\n        validateRelayAction(\\n            keccak256(abi.encodePacked(_proposalId, _vote, _voter, _asset, _nonce)),\\n            _paramsHashByVoter,\\n            _signature,\\n            _voter,\\n            _proposalId,\\n            _nonce);\\n        internalSubmitVote(_proposalId, _vote, _voter, _asset);\\n    }\\n\\n    /// @notice Function called by a voter to cancel his vote directly\\n    /// @param _proposalId The id of the proposal\\n    function cancelVoteByVoter(uint256 _proposalId) external {\\n        Proposal storage _proposal = proposals[_proposalId];\\n        require(_proposal.proposalStatus == ProposalStatus.Voting, \\\"VOTING_STATUS_REQUIRED\\\");\\n        internalCancelVote(_proposalId, msg.sender);\\n    }\\n\\n    /// @notice Same logic as submitVoteByRelayer, but to cancel a current vote by a _voter\\n    /// @param _proposalId The id of the proposal\\n    /// @param _nonce The current nonce of the voter in the proposal\\n    /// @param _voter The address of the voter\\n    /// @param _signature The signature of the tx, created by the voter and sent to the relayer\\n    /// @param _paramsHashByVoter Params hash to validate against the signature\\n    function cancelVoteByRelayer(\\n        uint256 _proposalId,\\n        address _voter,\\n        uint256 _nonce,\\n        bytes calldata _signature,\\n        bytes32 _paramsHashByVoter)\\n    external {\\n        Proposal storage _proposal = proposals[_proposalId];\\n        require(_proposal.proposalStatus == ProposalStatus.Voting, \\\"VOTING_STATUS_REQUIRED\\\");\\n        validateRelayAction(\\n            keccak256(abi.encodePacked(_proposalId, _voter, _nonce)),\\n            _paramsHashByVoter,\\n            _signature,\\n            _voter,\\n            _proposalId,\\n            _nonce);\\n        internalCancelVote(_proposalId, _voter);\\n    }\\n\\n    /// @notice Internal function to submit a vote. This function is called from\\n    ///  the external voting functions, by relayers and directly by voters\\n    ///  - If the voter has already voted, override the vote with the new one\\n    ///  - The vote is only allowed if the _asset is whitelisted in the assetVotingWeightProvider\\n    ///  - The _vote needs to be amongst the valid voting choices\\n    ///  - The _voter voter address needs to have _asset amount locked\\n    /// @param _proposalId The id of the proposal\\n    /// @param _vote A value between 0 and COUNT_CHOICES (included)\\n    /// @param _asset The asset locked in the _voter address, used to vote\\n    /// @param _voter the voter address, original signer of the transaction\\n    function internalSubmitVote(uint256 _proposalId, uint256 _vote, address _voter, IERC20 _asset) internal {\\n        Proposal storage _proposal = proposals[_proposalId];\\n        require(_proposal.proposalStatus == ProposalStatus.Voting, \\\"VOTING_STATUS_REQUIRED\\\");\\n        uint256 _assetVotingWeight = govParamsProvider.getAssetVotingWeightProvider().getVotingWeight(_asset);\\n        require(_assetVotingWeight != 0, \\\"ASSET_NOT_LISTED\\\");\\n        require(_vote <= COUNT_CHOICES, \\\"INVALID_VOTE_PARAM\\\");\\n        uint256 _voterAssetBalance = _asset.balanceOf(_voter);\\n        require(_voterAssetBalance > 0, \\\"INVALID_VOTER_BALANCE\\\");\\n\\n        // If the voter is replacing a previous vote, cancel the previous one first, to avoid double counting\\n        if (address(_proposal.voters[_voter].asset) != address(0)) {\\n            internalCancelVote(_proposalId, _voter);\\n        }\\n\\n        uint256 _assetWeight = _assetVotingWeight;\\n        uint256 _votingPower = _voterAssetBalance.mul(_assetWeight);\\n        _proposal.totalVotes = _proposal.totalVotes.add(1);\\n        _proposal.votes[_vote] = _votingPower.add(_proposal.votes[_vote]);\\n        Voter storage voter = _proposal.voters[_voter];\\n        voter.vote = _vote;\\n        voter.weight = _assetWeight;\\n        voter.balance = _voterAssetBalance;\\n        voter.asset = _asset;\\n        voter.nonce = voter.nonce.add(1);\\n\\n        emit VoteEmitted(_proposalId, _voter, _vote, voter.asset, _assetWeight, _voterAssetBalance);\\n\\n        tryToMoveToValidating(_proposalId);\\n    }\\n\\n    /// @notice Function to move to Validating the proposal in the case the last vote action\\n    ///  was done before the required votingBlocksDuration passed\\n    /// @param _proposalId The id of the proposal\\n    function tryToMoveToValidating(uint256 _proposalId) public {\\n        Proposal storage _proposal = proposals[_proposalId];\\n        require(_proposal.proposalStatus == ProposalStatus.Voting, \\\"VOTING_STATUS_REQUIRED\\\");\\n        if (_proposal.currentStatusInitBlock.add(_proposal.votingBlocksDuration) <= block.number) {\\n            for (uint256 i = 0; i <= COUNT_CHOICES; i++) {\\n                if (_proposal.votes[i] > _proposal.threshold) {\\n                    internalMoveToValidating(_proposalId);\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Internal fuction to cancel a vote. This function is called from\\n    ///  the external cancel vote functions (by relayers and directly by voters),\\n    ///  from challengeVoters() and from internalSubmitVote()\\n    /// @param _proposalId The id of the proposal\\n    /// @param _voter the voter address, original signer of the transaction\\n    function internalCancelVote(uint256 _proposalId, address _voter) internal {\\n        Proposal storage _proposal = proposals[_proposalId];\\n        Voter storage voter = _proposal.voters[_voter];\\n        Voter memory _cachedVoter = voter;\\n\\n        require(_cachedVoter.balance > 0, \\\"VOTER_WITHOUT_VOTE\\\");\\n\\n        _proposal.votes[_cachedVoter.vote] = _proposal.votes[_cachedVoter.vote].sub(\\n            _cachedVoter.balance.mul(\\n                _cachedVoter.weight\\n            )\\n        );\\n        _proposal.totalVotes = _proposal.totalVotes.sub(1);\\n        voter.weight = 0;\\n        voter.balance = 0;\\n        voter.vote = 0;\\n        voter.asset = IERC20(address(0));\\n        voter.nonce = voter.nonce.add(1);\\n        emit VoteCancelled(\\n            _proposalId,\\n            _voter,\\n            _cachedVoter.vote,\\n            _cachedVoter.asset,\\n            _cachedVoter.weight,\\n            _cachedVoter.balance,\\n            uint256(_proposal.proposalStatus)\\n        );\\n    }\\n\\n    /// @notice Called during the Validating period in order to cancel invalid votes\\n    ///  where the voter was trying a double-voting attack\\n    /// @param _proposalId The id of the proposal\\n    /// @param _voters List of voters to challenge\\n    function challengeVoters(uint256 _proposalId, address[] calldata _voters) external {\\n\\n        Proposal storage _proposal = proposals[_proposalId];\\n        require(_proposal.proposalStatus == ProposalStatus.Validating, \\\"VALIDATING_STATUS_REQUIRED\\\");\\n\\n        for (uint256 i = 0; i < _voters.length; i++) {\\n            address _voterAddress = _voters[i];\\n            Voter memory _voter = _proposal.voters[_voterAddress];\\n            uint256 _voterAssetBalance = _voter.asset.balanceOf(_voterAddress);\\n            if (_voterAssetBalance < _voter.balance) {\\n                internalCancelVote(_proposalId, _voterAddress);\\n            }\\n        }\\n\\n        if (_proposal.movesToVoting < _proposal.maxMovesToVotingAllowed &&\\n            _proposal.votes[getLeadingChoice(_proposalId)] < _proposal.threshold) {\\n            internalMoveToVoting(_proposalId);\\n        }\\n    }\\n\\n    /// @notice Function to resolve a proposal\\n    ///  - It only validates that the state is correct and the validating minimum blocks have passed,\\n    ///    as at that point, the % of the leading option doesn't matter\\n    ///  - If the resolution is YES, do a DELEGATECALL to the execute() of the proposalExecutor of the proposal\\n    ///  - If the resolution is ABSTAIN or NO, just change the state to Executed\\n    /// @param _proposalId The id of the proposal\\n    function resolveProposal(uint256 _proposalId) external {\\n        Proposal storage _proposal = proposals[_proposalId];\\n\\n        require(_proposal.proposalStatus == ProposalStatus.Validating, \\\"VALIDATING_STATUS_REQUIRED\\\");\\n        require(_proposal.currentStatusInitBlock.add(_proposal.validatingBlocksDuration) <= block.number, \\\"NOT_ENOUGH_BLOCKS_IN_VALIDATING\\\");\\n        require(_proposal.initProposalBlock.add(getLimitBlockOfProposal(_proposalId)) >= block.number, \\\"BLOCK_ABOVE_THE_PROPOSAL_LIMIT\\\");\\n\\n        uint256 _leadingChoice = getLeadingChoice(_proposalId);\\n\\n        if (_leadingChoice == 1) {\\n            (bool _success,) = _proposal.proposalExecutor.delegatecall(abi.encodeWithSignature(\\\"execute()\\\"));\\n            require(_success, \\\"resolveProposal(). DELEGATECALL_REVERTED\\\");\\n            emit YesWins(_proposalId, _proposal.votes[0], _proposal.votes[1], _proposal.votes[2]);\\n        } else if (_leadingChoice == 2) {\\n            emit NoWins(_proposalId, _proposal.votes[0], _proposal.votes[1], _proposal.votes[2]);\\n        } else {\\n            emit AbstainWins(_proposalId, _proposal.votes[0], _proposal.votes[1], _proposal.votes[2]);\\n        }\\n        internalMoveToExecuted(_proposalId);\\n    }\\n\\n    /// @notice Return the limit block of the proposal from where it will not be possible to resolve it anymore\\n    ///  - The double of the sum(voting blocks, validating blocks) multiplied by the maxMovesToVotingAllowed\\n    /// @param _proposalId The id of the proposal\\n    /// @return uint256 The limit block number\\n    function getLimitBlockOfProposal(uint256 _proposalId) public view returns(uint256 _limitBlockProposal) {\\n        Proposal memory _proposal = proposals[_proposalId];\\n        uint256 _maxMovesToVotingAllowed = _proposal.maxMovesToVotingAllowed;\\n        uint256 _votingBlocksDuration = _proposal.votingBlocksDuration;\\n        uint256 _validatingBlocksDuration = _proposal.validatingBlocksDuration;\\n        _limitBlockProposal = _maxMovesToVotingAllowed.mul(2).mul(\\n            _votingBlocksDuration.add(_validatingBlocksDuration)\\n        );\\n    }\\n\\n    /// @notice Gets the current leading choice in votes\\n    /// @param _proposalId The id of the proposal\\n    /// @return uint256 The numeric reference of the choice\\n    function getLeadingChoice(uint256 _proposalId) public view returns(uint256) {\\n        uint256 _leadingChoice = 0;\\n        uint256 _tempCandidate = 0;\\n        Proposal storage _proposal = proposals[_proposalId];\\n        for (uint256 i = 0; i <= COUNT_CHOICES; i++) {\\n            if (_proposal.votes[i] > _tempCandidate) {\\n                _leadingChoice = i;\\n                _tempCandidate = _proposal.votes[i];\\n            }\\n        }\\n        return _leadingChoice;\\n    }\\n\\n    /// @notice Get the basic data of a proposal\\n    /// @param _proposalId The id of the proposal\\n    /// @return Proposal The basic data of the proposal\\n    function getProposalBasicData(uint256 _proposalId) external view returns(\\n        uint256 _totalVotes,\\n        uint256 _threshold,\\n        uint256 _maxMovesToVotingAllowed,\\n        uint256 _movesToVoting,\\n        uint256 _votingBlocksDuration,\\n        uint256 _validatingBlocksDuration,\\n        uint256 _currentStatusInitBlock,\\n        uint256 _initProposalBlock,\\n        uint256 _proposalStatus,\\n        address _proposalExecutor,\\n        bytes32 _proposalType\\n    ) {\\n        require(_proposalId < proposals.length, \\\"INVALID_PROPOSAL_ID\\\");\\n        Proposal storage _proposal = proposals[_proposalId];\\n        _totalVotes = _proposal.totalVotes;\\n        _threshold = _proposal.threshold;\\n        _maxMovesToVotingAllowed = _proposal.maxMovesToVotingAllowed;\\n        _movesToVoting = _proposal.movesToVoting;\\n        _votingBlocksDuration = _proposal.votingBlocksDuration;\\n        _validatingBlocksDuration = _proposal.validatingBlocksDuration;\\n        _currentStatusInitBlock = _proposal.currentStatusInitBlock;\\n        _initProposalBlock = _proposal.initProposalBlock;\\n        _proposalStatus = uint256(_proposal.proposalStatus);\\n        _proposalExecutor = _proposal.proposalExecutor;\\n        _proposalType = _proposal.proposalType;\\n    }\\n\\n    /// @notice Get the voting data of a voter on a particular proposal\\n    /// @param _proposalId The id of the proposal\\n    /// @param _voterAddress _voterAddress The address of the voter\\n    /// @return Voter The data of the voter\\n    function getVoterData(uint256 _proposalId, address _voterAddress) external view returns(\\n        uint256 _vote,\\n        uint256 _weight,\\n        uint256 _balance,\\n        uint256 _nonce,\\n        IERC20 _asset\\n    ) {\\n        require(_proposalId < proposals.length, \\\"INVALID_PROPOSAL_ID\\\");\\n        Voter storage _voter = proposals[_proposalId].voters[_voterAddress];\\n        _vote = _voter.vote;\\n        _weight = _voter.weight;\\n        _balance = _voter.balance;\\n        _nonce = _voter.nonce;\\n        _asset = _voter.asset;\\n    }\\n\\n    /// @notice Get the total votes-related data of a proposal\\n    /// @param _proposalId The id of the proposal\\n    /// @return uint256[3] The array with the accumulated voting power for every choice (ABSTAIN, YES, NO)\\n    function getVotesData(uint256 _proposalId) external view returns(uint256[3] memory) {\\n        require(_proposalId < proposals.length, \\\"INVALID_PROPOSAL_ID\\\");\\n        Proposal storage _proposal = proposals[_proposalId];\\n        uint256[3] memory _votes = [_proposal.votes[0],_proposal.votes[1],_proposal.votes[2]];\\n        return _votes;\\n    }\\n\\n    /// @notice Return the address of the govParamsProvider\\n    /// @return address The address of the govParamsProvider\\n    function getGovParamsProvider() external view returns(address _govParamsProvider) {\\n        return address(govParamsProvider);\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * NOTE: This call _does not revert_ if the signature is invalid, or\\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\\n     * the zero address is returned.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            return (address(0));\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            return address(0);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        return ecrecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernanceParamsProvider.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"./IAssetVotingWeightProvider.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IGovernanceParamsProvider {\\n    function setPropositionPowerThreshold(uint256 _propositionPowerThreshold) external;\\n    function setPropositionPower(IERC20 _propositionPower) external;\\n    function setAssetVotingWeightProvider(IAssetVotingWeightProvider _assetVotingWeightProvider) external;\\n    function getPropositionPower() external view returns(IERC20);\\n    function getPropositionPowerThreshold() external view returns(uint256);\\n    function getAssetVotingWeightProvider() external view returns(IAssetVotingWeightProvider);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IAssetVotingWeightProvider.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IAssetVotingWeightProvider {\\n    function getVotingWeight(IERC20 _asset) external view returns(uint256);\\n    function setVotingWeight(IERC20 _asset, uint256 _weight) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IProposalExecutor.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface IProposalExecutor {\\n    function execute() external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IAaveProtoGovernance.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n\\ninterface IAaveProtoGovernance {\\n    function newProposal(\\n        bytes32 _proposalType,\\n        bytes32 _ipfsHash,\\n        uint256 _threshold,\\n        address _proposalExecutor,\\n        uint256 _votingBlocksDuration,\\n        uint256 _validatingBlocksDuration,\\n        uint256 _maxMovesToVotingAllowed\\n    ) external;\\n    function submitVoteByVoter(uint256 _proposalId, uint256 _vote, IERC20 _asset) external;\\n    function submitVoteByRelayer(\\n        uint256 _proposalId,\\n        uint256 _vote,\\n        address _voter,\\n        IERC20 _asset,\\n        uint256 _nonce,\\n        bytes calldata _signature,\\n        bytes32 _paramsHashByVoter\\n    ) external;\\n    function cancelVoteByVoter(uint256 _proposalId) external;\\n    function cancelVoteByRelayer(\\n        uint256 _proposalId,\\n        address _voter,\\n        uint256 _nonce,\\n        bytes calldata _signature,\\n        bytes32 _paramsHashByVoter\\n    ) external;\\n    function tryToMoveToValidating(uint256 _proposalId) external;\\n    function challengeVoters(uint256 _proposalId, address[] calldata _voters) external;\\n    function resolveProposal(uint256 _proposalId) external;\\n\\n    function getLimitBlockOfProposal(uint256 _proposalId) external view returns(uint256 _limitBlockProposal);\\n    function getLeadingChoice(uint256 _proposalId) external view returns(uint256);\\n    function getProposalBasicData(uint256 _proposalId) external view returns(\\n        uint256 _totalVotes,\\n        uint256 _threshold,\\n        uint256 _maxMovesToVotingAllowed,\\n        uint256 _movesToVoting,\\n        uint256 _votingBlocksDuration,\\n        uint256 _validatingBlocksDuration,\\n        uint256 _currentStatusInitBlock,\\n        uint256 _initProposalBlock,\\n        uint256 _proposalStatus,\\n        address _proposalExecutor,\\n        bytes32 _proposalType\\n    );\\n    function getVoterData(uint256 _proposalId, address _voterAddress) external view returns(\\n        uint256 _vote,\\n        uint256 _weight,\\n        uint256 _balance,\\n        uint256 _nonce,\\n        IERC20 _asset\\n    );\\n    function getVotesData(uint256 _proposalId) external view returns(uint256[3] memory);\\n    function getGovParamsProvider() external view returns(address _govParamsProvider);\\n\\n    function verifyParamsConsistencyAndSignature(\\n        bytes32 _paramsHashByRelayer,\\n        bytes32 _paramsHashBySigner,\\n        bytes calldata _signature,\\n        address _signer\\n    ) external pure;\\n    function verifyNonce(uint256 _proposalId, address _voter, uint256 _relayerNonce) external view;\\n    function validateRelayAction(\\n        bytes32 _paramsHashByRelayer,\\n        bytes32 _paramsHashBySigner,\\n        bytes calldata _signature,\\n        address _signer,\\n        uint256 _proposalId,\\n        uint256 _relayerNonce\\n    ) external view;\\n}\"\r\n    },\r\n    \"contracts/governance/AssetVotingWeightProvider.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\n\\nimport \\\"../interfaces/IAssetVotingWeightProvider.sol\\\";\\n\\n/// @title AssetVotingWeightProvider\\n/// @notice Smart contract to register whitelisted assets with its voting weight per asset\\n///  - The ownership is on the AaveProtoGovernance, that way the whitelisting of new assets or\\n///    the change of the weight of a current one will be done through governance.\\ncontract AssetVotingWeightProvider is Ownable, IAssetVotingWeightProvider {\\n\\n    event AssetWeightSet(IERC20 indexed asset, address indexed setter, uint256 weight);\\n\\n    mapping(address => uint256) private votingWeights;\\n\\n    /// @notice Constructor\\n    /// @param _assets Dynamic array of asset addresses\\n    /// @param _weights Dynamic array of asset weights, for each one of _assets\\n    constructor(IERC20[] memory _assets, uint256[] memory _weights) public {\\n        require(_assets.length == _weights.length, \\\"INCONSISTENT_ASSETS_WEIGHTS_LENGTHS\\\");\\n        for (uint256 i = 0; i < _assets.length; i++) {\\n            internalSetVotingWeight(_assets[i], _weights[i]);\\n        }\\n    }\\n\\n    /// @notice Gets the weight of an asset\\n    /// @param _asset The asset smart contract address\\n    /// @return The uint256 weight of the asset\\n    function getVotingWeight(IERC20 _asset) public view returns(uint256) {\\n        address asset = address(_asset);\\n        return votingWeights[asset];\\n    }\\n\\n    /// @notice Sets the weight for an asset\\n    /// @param _asset The asset smart contract address\\n    /// @param _weight The asset smart contract address\\n    /// @return The uint256 weight of the asset\\n    function setVotingWeight(IERC20 _asset, uint256 _weight) external onlyOwner {\\n        internalSetVotingWeight(_asset, _weight);\\n    }\\n\\n    /// @notice Internal function to set the weight for an asset\\n    /// @param _asset The asset smart contract address\\n    /// @return The uint256 weight of the asset\\n    function internalSetVotingWeight(IERC20 _asset, uint256 _weight) internal {\\n        address asset = address(_asset);\\n        votingWeights[asset] = _weight;\\n        emit AssetWeightSet(_asset, msg.sender, _weight);\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = _msgSender();\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/GovernanceParamsProvider.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"../interfaces/IGovernanceParamsProvider.sol\\\";\\n\\ncontract GovernanceParamsProvider is Ownable, IGovernanceParamsProvider {\\n\\n    event AssetVotingWeightProviderSet(address indexed setter, IAssetVotingWeightProvider  assetVotingWeightProvider);\\n    event PropositionPowerThresholdSet(address indexed setter, uint256  propositionPowerThreshold);\\n    event PropositionPowerSet(address indexed setter, IERC20 propositionPower);\\n\\n    /// @notice Address of the smart contract providing the weight of the whitelisted assets\\n    IAssetVotingWeightProvider private assetVotingWeightProvider;\\n\\n    /// @notice Used to get the percentage of the supply of propositionPower needed to register a proposal\\n    uint256 private propositionPowerThreshold;\\n\\n    /// @notice Address of the asset to control who can register new proposals\\n    IERC20 private propositionPower;\\n\\n    constructor(\\n        uint256 _propositionPowerThreshold,\\n        IERC20 _propositionPower,\\n        IAssetVotingWeightProvider _assetVotingWeightProvider\\n    ) public {\\n        internalSetPropositionPowerThreshold(_propositionPowerThreshold);\\n        internalSetPropositionPower(_propositionPower);\\n        internalSetAssetVotingWeightProvider(_assetVotingWeightProvider);\\n    }\\n\\n    /// @notice Sets the propositionPowerThreshold\\n    /// @param _propositionPowerThreshold The address of the propositionPowerThreshold\\n    function setPropositionPowerThreshold(uint256 _propositionPowerThreshold) external onlyOwner {\\n        internalSetPropositionPowerThreshold(_propositionPowerThreshold);\\n    }\\n\\n    /// @notice Sets the propositionPower\\n    /// @param _propositionPower The address of the propositionPower\\n    function setPropositionPower(IERC20 _propositionPower) external onlyOwner {\\n        internalSetPropositionPower(_propositionPower);\\n    }\\n\\n    /// @notice Sets the assetVotingWeightProvider\\n    /// @param _assetVotingWeightProvider The address of the assetVotingWeightProvider\\n    function setAssetVotingWeightProvider(IAssetVotingWeightProvider _assetVotingWeightProvider) external onlyOwner {\\n        internalSetAssetVotingWeightProvider(_assetVotingWeightProvider);\\n    }\\n\\n    /// @notice Sets the propositionPowerThreshold\\n    /// @param _propositionPowerThreshold The numeric propositionPowerThreshold\\n    function internalSetPropositionPowerThreshold(uint256 _propositionPowerThreshold) internal {\\n        propositionPowerThreshold = _propositionPowerThreshold;\\n        emit PropositionPowerThresholdSet(msg.sender, _propositionPowerThreshold);\\n    }\\n\\n    /// @notice Sets the propositionPower\\n    /// @param _propositionPower The address of the propositionPower\\n    function internalSetPropositionPower(IERC20 _propositionPower) internal {\\n        propositionPower = _propositionPower;\\n        emit PropositionPowerSet(msg.sender, _propositionPower);\\n    }\\n\\n    /// @notice Sets the assetVotingWeightProvider\\n    /// @param _assetVotingWeightProvider The address of the assetVotingWeightProvider\\n    function internalSetAssetVotingWeightProvider(IAssetVotingWeightProvider _assetVotingWeightProvider) internal {\\n        assetVotingWeightProvider = _assetVotingWeightProvider;\\n        emit AssetVotingWeightProviderSet(msg.sender, _assetVotingWeightProvider);\\n    }\\n\\n    /// @notice Return the address of the propositionPower\\n    /// @return The address of the propositionPower\\n    function getPropositionPower() external view returns(IERC20) {\\n        return propositionPower;\\n    }\\n\\n    /// @notice Returns the propositionPowerThreshold\\n    /// @return The propositionPowerThreshold\\n    function getPropositionPowerThreshold() external view returns(uint256) {\\n        return propositionPowerThreshold;\\n    }\\n\\n    /// @notice Returns the assetVotingWeightProvider address\\n    /// @return The address of the assetVotingWeightProvider\\n    function getAssetVotingWeightProvider() external view returns(IAssetVotingWeightProvider) {\\n        return assetVotingWeightProvider;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n/**\\n@title ILendingPoolAddressesProvider interface\\n@notice provides the interface to fetch the LendingPoolCore address\\n */\\n\\ncontract ILendingPoolAddressesProvider {\\n\\n    function getLendingPool() public view returns (address);\\n    function setLendingPoolImpl(address _pool) public;\\n\\n    function getLendingPoolCore() public view returns (address payable);\\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\\n\\n    function getLendingPoolConfigurator() public view returns (address);\\n    function setLendingPoolConfiguratorImpl(address _configurator) public;\\n\\n    function getLendingPoolDataProvider() public view returns (address);\\n    function setLendingPoolDataProviderImpl(address _provider) public;\\n\\n    function getLendingPoolParametersProvider() public view returns (address);\\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public;\\n\\n    function getTokenDistributor() public view returns (address);\\n    function setTokenDistributor(address _tokenDistributor) public;\\n\\n\\n    function getFeeProvider() public view returns (address);\\n    function setFeeProviderImpl(address _feeProvider) public;\\n\\n    function getLendingPoolLiquidationManager() public view returns (address);\\n    function setLendingPoolLiquidationManager(address _manager) public;\\n\\n    function getLendingPoolManager() public view returns (address);\\n    function setLendingPoolManager(address _lendingPoolManager) public;\\n\\n    function getPriceOracle() public view returns (address);\\n    function setPriceOracle(address _priceOracle) public;\\n\\n    function getLendingRateOracle() public view returns (address);\\n    function setLendingRateOracle(address _lendingRateOracle) public;\\n\\n}\"\r\n    },\r\n    \"contracts/libraries/openzeppelin-upgradeability/AdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./BaseAdminUpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title AdminUpgradeabilityProxy\\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \\n * initializing the implementation, admin, and init data.\\n */\\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\\n    /**\\n   * Contract constructor.\\n   * @param _logic address of the initial implementation.\\n   * @param _admin Address of the proxy administrator.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeabilityProxy(_logic, _data) {\\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(_admin);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/openzeppelin-upgradeability/BaseAdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./UpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title BaseAdminUpgradeabilityProxy\\n * @dev This contract combines an upgradeability proxy with an authorization\\n * mechanism for administrative tasks.\\n * All external functions in this contract must be guarded by the\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\n * feature proposal that would enable this to be done automatically.\\n */\\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n    /**\\n   * @dev Emitted when the administration has been transferred.\\n   * @param previousAdmin Address of the previous admin.\\n   * @param newAdmin Address of the new admin.\\n   */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n   * @dev Storage slot with the admin of the contract.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\n   * to the implementation.\\n   */\\n    modifier ifAdmin() {\\n        if (msg.sender == _admin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n   * @return The address of the proxy admin.\\n   */\\n    function admin() external ifAdmin returns (address) {\\n        return _admin();\\n    }\\n\\n    /**\\n   * @return The address of the implementation.\\n   */\\n    function implementation() external ifAdmin returns (address) {\\n        return _implementation();\\n    }\\n\\n    /**\\n   * @dev Changes the admin of the proxy.\\n   * Only the current admin can call this function.\\n   * @param newAdmin Address to transfer proxy administration to.\\n   */\\n    function changeAdmin(address newAdmin) external ifAdmin {\\n        require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\n        emit AdminChanged(_admin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n   * @dev Upgrade the backing implementation of the proxy.\\n   * Only the admin can call this function.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\n   * on the new implementation.\\n   * This is useful to initialize the proxied contract.\\n   * @param newImplementation Address of the new implementation.\\n   * @param data Data to send as msg.data in the low level call.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeTo(newImplementation);\\n        (bool success, ) = newImplementation.delegatecall(data);\\n        require(success);\\n    }\\n\\n    /**\\n   * @return The admin slot.\\n   */\\n    function _admin() internal view returns (address adm) {\\n        bytes32 slot = ADMIN_SLOT;\\n        //solium-disable-next-line\\n        assembly {\\n            adm := sload(slot)\\n        }\\n    }\\n\\n    /**\\n   * @dev Sets the address of the proxy admin.\\n   * @param newAdmin Address of the new proxy admin.\\n   */\\n    function _setAdmin(address newAdmin) internal {\\n        bytes32 slot = ADMIN_SLOT;\\n        //solium-disable-next-line\\n        assembly {\\n            sstore(slot, newAdmin)\\n        }\\n    }\\n\\n    /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n    function _willFallback() internal {\\n        require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\n        super._willFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/openzeppelin-upgradeability/UpgradeabilityProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./BaseUpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title UpgradeabilityProxy\\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\\n * implementation and init data.\\n */\\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\\n    /**\\n   * @dev Contract constructor.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n    constructor(address _logic, bytes memory _data) public payable {\\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if (_data.length > 0) {\\n            (bool success, ) = _logic.delegatecall(_data);\\n            require(success);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/openzeppelin-upgradeability/BaseUpgradeabilityProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title BaseUpgradeabilityProxy\\n * @dev This contract implements a proxy that allows to change the\\n * implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract BaseUpgradeabilityProxy is Proxy {\\n    /**\\n   * @dev Emitted when the implementation is upgraded.\\n   * @param implementation Address of the new implementation.\\n   */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n   * @dev Storage slot with the address of the current implementation.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n   * @dev Returns the current implementation.\\n   * @return Address of the current implementation\\n   */\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        //solium-disable-next-line\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n   * @dev Upgrades the proxy to a new implementation.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n   * @dev Sets the implementation address of the proxy.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n    function _setImplementation(address newImplementation) internal {\\n        require(\\n            Address.isContract(newImplementation),\\n            \\\"Cannot set a proxy implementation to a non-contract address\\\"\\n        );\\n\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n        //solium-disable-next-line\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/openzeppelin-upgradeability/Proxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Proxy\\n * @dev Implements delegation of calls to other contracts, with proper\\n * forwarding of return values and bubbling of failures.\\n * It defines a fallback function that delegates all calls to the address\\n * returned by the abstract _implementation() internal function.\\n */\\ncontract Proxy {\\n    /**\\n   * @dev Fallback function.\\n   * Implemented entirely in `_fallback`.\\n   */\\n    function() external payable {\\n        _fallback();\\n    }\\n\\n    /**\\n   * @return The Address of the implementation.\\n   */\\n    function _implementation() internal view returns (address);\\n\\n    /**\\n   * @dev Delegates execution to an implementation contract.\\n   * This is a low level function that doesn't return to its internal call site.\\n   * It will return to the external caller whatever the implementation returns.\\n   * @param implementation Address to delegate.\\n   */\\n    function _delegate(address implementation) internal {\\n        //solium-disable-next-line\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize)\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize)\\n\\n            switch result\\n                // delegatecall returns 0 on error.\\n                case 0 {\\n                    revert(0, returndatasize)\\n                }\\n                default {\\n                    return(0, returndatasize)\\n                }\\n        }\\n    }\\n\\n    /**\\n   * @dev Function that is run as the first thing in the fallback function.\\n   * Can be redefined in derived contracts to add functionality.\\n   * Redefinitions must call super._willFallback().\\n   */\\n    function _willFallback() internal {}\\n\\n    /**\\n   * @dev fallback implementation.\\n   * Extracted to enable manual triggering.\\n   */\\n    function _fallback() internal {\\n        _willFallback();\\n        _delegate(_implementation());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract's constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\n     * function returns false is an externally-owned account (EOA) and not a\\n     * contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/openzeppelin-upgradeability/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.6.0;\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n    /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n    bool private initialized;\\n\\n    /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n    bool private initializing;\\n\\n    /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n    modifier initializer() {\\n        require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n        bool isTopLevelCall = !initializing;\\n        if (isTopLevelCall) {\\n            initializing = true;\\n            initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        uint256 cs;\\n        //solium-disable-next-line\\n        assembly {\\n            cs := extcodesize(address)\\n        }\\n        return cs == 0;\\n    }\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/openzeppelin-upgradeability/InitializableAdminUpgradeabilityProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./BaseAdminUpgradeabilityProxy.sol\\\";\\nimport \\\"./InitializableUpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title InitializableAdminUpgradeabilityProxy\\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \\n * initializing the implementation, admin, and init data.\\n */\\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\\n    /**\\n   * Contract initializer.\\n   * @param _logic address of the initial implementation.\\n   * @param _admin Address of the proxy administrator.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n    function initialize(address _logic, address _admin, bytes memory _data) public payable {\\n        require(_implementation() == address(0));\\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(_admin);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/openzeppelin-upgradeability/InitializableUpgradeabilityProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./BaseUpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title InitializableUpgradeabilityProxy\\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\\n * implementation and init data.\\n */\\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n    /**\\n   * @dev Contract initializer.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n    function initialize(address _logic, bytes memory _data) public payable {\\n        require(_implementation() == address(0));\\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if (_data.length > 0) {\\n            (bool success, ) = _logic.delegatecall(_data);\\n            require(success);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/openzeppelin-upgradeability/VersionedInitializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.6.0;\\n\\n/**\\n * @title VersionedInitializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n *\\n * @author Aave, inspired by the OpenZeppelin Initializable contract\\n */\\ncontract VersionedInitializable {\\n    /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n    uint256 private lastInitializedRevision = 0;\\n\\n    /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n    bool private initializing;\\n\\n    /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n    modifier initializer() {\\n        uint256 revision = getRevision();\\n        require(initializing || isConstructor() || revision > lastInitializedRevision, \\\"Contract instance has already been initialized\\\");\\n\\n        bool isTopLevelCall = !initializing;\\n        if (isTopLevelCall) {\\n            initializing = true;\\n            lastInitializedRevision = revision;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            initializing = false;\\n        }\\n    }\\n\\n    /// @dev returns the revision number of the contract.\\n    /// Needs to be defined in the inherited class as a constant.\\n    function getRevision() internal pure returns(uint256);\\n\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        uint256 cs;\\n        //solium-disable-next-line\\n        assembly {\\n            cs := extcodesize(address)\\n        }\\n        return cs == 0;\\n    }\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/AddressStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ncontract AddressStorage {\\n    mapping(bytes32 => address) private addresses;\\n\\n    function getAddress(bytes32 _key) public view returns (address) {\\n        return addresses[_key];\\n    }\\n\\n    function _setAddress(bytes32 _key, address _value) internal {\\n        addresses[_key] = _value;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/FailingProposalExecutor.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"../interfaces/IProposalExecutor.sol\\\";\\n\\ncontract FailingProposalExecutor is IProposalExecutor {\\n\\n    /// @notice Fallback function, not allowing transfer of ETH\\n    function() external payable {\\n        revert(\\\"ETH_TRANSFER_NOT_ALLOWED\\\");\\n    }\\n\\n    function execute() external {\\n        require(false, \\\"FORCED_REVERT\\\");\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/mocks/LendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"../libraries/openzeppelin-upgradeability/InitializableAdminUpgradeabilityProxy.sol\\\";\\n\\nimport \\\"./AddressStorage.sol\\\";\\nimport \\\"../interfaces/ILendingPoolAddressesProvider.sol\\\";\\n\\n/**\\n* @title LendingPoolAddressesProvider contract\\n* @notice Is the main registry of the protocol. All the different components of the protocol are accessible\\n* through the addresses provider.\\n* @author Aave\\n**/\\n\\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider, AddressStorage {\\n    //events\\n    event LendingPoolUpdated(address indexed newAddress);\\n    event LendingPoolCoreUpdated(address indexed newAddress);\\n    event LendingPoolParametersProviderUpdated(address indexed newAddress);\\n    event LendingPoolManagerUpdated(address indexed newAddress);\\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\\n    event LendingPoolLiquidationManagerUpdated(address indexed newAddress);\\n    event LendingPoolDataProviderUpdated(address indexed newAddress);\\n    event EthereumAddressUpdated(address indexed newAddress);\\n    event PriceOracleUpdated(address indexed newAddress);\\n    event LendingRateOracleUpdated(address indexed newAddress);\\n    event FeeProviderUpdated(address indexed newAddress);\\n    event TokenDistributorUpdated(address indexed newAddress);\\n\\n    event ProxyCreated(bytes32 id, address indexed newAddress);\\n\\n    bytes32 private constant LENDING_POOL = \\\"LENDING_POOL\\\";\\n    bytes32 private constant LENDING_POOL_CORE = \\\"LENDING_POOL_CORE\\\";\\n    bytes32 private constant LENDING_POOL_CONFIGURATOR = \\\"LENDING_POOL_CONFIGURATOR\\\";\\n    bytes32 private constant LENDING_POOL_PARAMETERS_PROVIDER = \\\"PARAMETERS_PROVIDER\\\";\\n    bytes32 private constant LENDING_POOL_MANAGER = \\\"LENDING_POOL_MANAGER\\\";\\n    bytes32 private constant LENDING_POOL_LIQUIDATION_MANAGER = \\\"LIQUIDATION_MANAGER\\\";\\n    bytes32 private constant LENDING_POOL_FLASHLOAN_PROVIDER = \\\"FLASHLOAN_PROVIDER\\\";\\n    bytes32 private constant DATA_PROVIDER = \\\"DATA_PROVIDER\\\";\\n    bytes32 private constant ETHEREUM_ADDRESS = \\\"ETHEREUM_ADDRESS\\\";\\n    bytes32 private constant PRICE_ORACLE = \\\"PRICE_ORACLE\\\";\\n    bytes32 private constant LENDING_RATE_ORACLE = \\\"LENDING_RATE_ORACLE\\\";\\n    bytes32 private constant FEE_PROVIDER = \\\"FEE_PROVIDER\\\";\\n    bytes32 private constant WALLET_BALANCE_PROVIDER = \\\"WALLET_BALANCE_PROVIDER\\\";\\n    bytes32 private constant TOKEN_DISTRIBUTOR = \\\"TOKEN_DISTRIBUTOR\\\";\\n\\n\\n    /**\\n    * @dev returns the address of the LendingPool proxy\\n    * @return the lending pool proxy address\\n    **/\\n    function getLendingPool() public view returns (address) {\\n        return getAddress(LENDING_POOL);\\n    }\\n\\n\\n    /**\\n    * @dev updates the implementation of the lending pool\\n    * @param _pool the new lending pool implementation\\n    **/\\n    function setLendingPoolImpl(address _pool) public onlyOwner {\\n        updateImplInternal(LENDING_POOL, _pool);\\n        emit LendingPoolUpdated(_pool);\\n    }\\n\\n    /**\\n    * @dev returns the address of the LendingPoolCore proxy\\n    * @return the lending pool core proxy address\\n     */\\n    function getLendingPoolCore() public view returns (address payable) {\\n        address payable core = address(uint160(getAddress(LENDING_POOL_CORE)));\\n        return core;\\n    }\\n\\n    /**\\n    * @dev updates the implementation of the lending pool core\\n    * @param _lendingPoolCore the new lending pool core implementation\\n    **/\\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public onlyOwner {\\n        updateImplInternal(LENDING_POOL_CORE, _lendingPoolCore);\\n        emit LendingPoolCoreUpdated(_lendingPoolCore);\\n    }\\n\\n    /**\\n    * @dev returns the address of the LendingPoolConfigurator proxy\\n    * @return the lending pool configurator proxy address\\n    **/\\n    function getLendingPoolConfigurator() public view returns (address) {\\n        return getAddress(LENDING_POOL_CONFIGURATOR);\\n    }\\n\\n    /**\\n    * @dev updates the implementation of the lending pool configurator\\n    * @param _configurator the new lending pool configurator implementation\\n    **/\\n    function setLendingPoolConfiguratorImpl(address _configurator) public onlyOwner {\\n        updateImplInternal(LENDING_POOL_CONFIGURATOR, _configurator);\\n        emit LendingPoolConfiguratorUpdated(_configurator);\\n    }\\n\\n    /**\\n    * @dev returns the address of the LendingPoolDataProvider proxy\\n    * @return the lending pool data provider proxy address\\n     */\\n    function getLendingPoolDataProvider() public view returns (address) {\\n        return getAddress(DATA_PROVIDER);\\n    }\\n\\n    /**\\n    * @dev updates the implementation of the lending pool data provider\\n    * @param _provider the new lending pool data provider implementation\\n    **/\\n    function setLendingPoolDataProviderImpl(address _provider) public onlyOwner {\\n        updateImplInternal(DATA_PROVIDER, _provider);\\n        emit LendingPoolDataProviderUpdated(_provider);\\n    }\\n\\n    /**\\n    * @dev returns the address of the LendingPoolParametersProvider proxy\\n    * @return the address of the Lending pool parameters provider proxy\\n    **/\\n    function getLendingPoolParametersProvider() public view returns (address) {\\n        return getAddress(LENDING_POOL_PARAMETERS_PROVIDER);\\n    }\\n\\n    /**\\n    * @dev updates the implementation of the lending pool parameters provider\\n    * @param _parametersProvider the new lending pool parameters provider implementation\\n    **/\\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public onlyOwner {\\n        updateImplInternal(LENDING_POOL_PARAMETERS_PROVIDER, _parametersProvider);\\n        emit LendingPoolParametersProviderUpdated(_parametersProvider);\\n    }\\n\\n    /**\\n    * @dev returns the address of the FeeProvider proxy\\n    * @return the address of the Fee provider proxy\\n    **/\\n    function getFeeProvider() public view returns (address) {\\n        return getAddress(FEE_PROVIDER);\\n    }\\n\\n    /**\\n    * @dev updates the implementation of the FeeProvider proxy\\n    * @param _feeProvider the new lending pool fee provider implementation\\n    **/\\n    function setFeeProviderImpl(address _feeProvider) public {\\n        updateImplInternal(FEE_PROVIDER, _feeProvider);\\n        emit FeeProviderUpdated(_feeProvider);\\n    }\\n\\n    /**\\n    * @dev returns the address of the LendingPoolLiquidationManager. Since the manager is used\\n    * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\\n    * the addresses are changed directly.\\n    * @return the address of the Lending pool liquidation manager\\n    **/\\n\\n    function getLendingPoolLiquidationManager() public view returns (address) {\\n        return getAddress(LENDING_POOL_LIQUIDATION_MANAGER);\\n    }\\n\\n    /**\\n    * @dev updates the address of the Lending pool liquidation manager\\n    * @param _manager the new lending pool liquidation manager address\\n    **/\\n    function setLendingPoolLiquidationManager(address _manager) public onlyOwner {\\n        _setAddress(LENDING_POOL_LIQUIDATION_MANAGER, _manager);\\n        emit LendingPoolLiquidationManagerUpdated(_manager);\\n    }\\n\\n    /**\\n    * @dev the functions below are storing specific addresses that are outside the context of the protocol\\n    * hence the upgradable proxy pattern is not used\\n    **/\\n\\n\\n    function getLendingPoolManager() public view returns (address) {\\n        return getAddress(LENDING_POOL_MANAGER);\\n    }\\n\\n    function setLendingPoolManager(address _lendingPoolManager) public {\\n        _setAddress(LENDING_POOL_MANAGER, _lendingPoolManager);\\n        emit LendingPoolManagerUpdated(_lendingPoolManager);\\n    }\\n\\n    function getPriceOracle() public view returns (address) {\\n        return getAddress(PRICE_ORACLE);\\n    }\\n\\n    function setPriceOracle(address _priceOracle) public onlyOwner {\\n        _setAddress(PRICE_ORACLE, _priceOracle);\\n        emit PriceOracleUpdated(_priceOracle);\\n    }\\n\\n    function getLendingRateOracle() public view returns (address) {\\n        return getAddress(LENDING_RATE_ORACLE);\\n    }\\n\\n    function setLendingRateOracle(address _lendingRateOracle) public onlyOwner {\\n        _setAddress(LENDING_RATE_ORACLE, _lendingRateOracle);\\n        emit LendingRateOracleUpdated(_lendingRateOracle);\\n    }\\n\\n\\n    function getTokenDistributor() public view returns (address) {\\n        return getAddress(TOKEN_DISTRIBUTOR);\\n    }\\n\\n    function setTokenDistributor(address _tokenDistributor) public onlyOwner {\\n        _setAddress(TOKEN_DISTRIBUTOR, _tokenDistributor);\\n        emit TokenDistributorUpdated(_tokenDistributor);\\n    }\\n\\n\\n    /**\\n    * @dev internal function to update the implementation of a specific component of the protocol\\n    * @param _id the id of the contract to be updated\\n    * @param _newAddress the address of the new implementation\\n    **/\\n    function updateImplInternal(bytes32 _id, address _newAddress) internal {\\n        address payable proxyAddress = address(uint160(getAddress(_id)));\\n\\n        InitializableAdminUpgradeabilityProxy proxy = InitializableAdminUpgradeabilityProxy(proxyAddress);\\n        bytes memory params = abi.encodeWithSignature(\\\"initialize(address)\\\", address(this));\\n\\n        if (proxyAddress == address(0)) {\\n            proxy = new InitializableAdminUpgradeabilityProxy();\\n            proxy.initialize(_newAddress, address(this), params);\\n            _setAddress(_id, address(proxy));\\n            emit ProxyCreated(_id, address(proxy));\\n        } else {\\n            proxy.upgradeToAndCall(_newAddress, params);\\n        }\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/ProposalExecutor.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"../interfaces/IProposalExecutor.sol\\\";\\nimport \\\"./LendingPoolAddressesProvider.sol\\\";\\n\\ncontract ProposalExecutor is IProposalExecutor {\\n\\n    event ProposalExecuted(\\n        address indexed executor,\\n        address indexed lendingPoolAddressesProvider,\\n        address indexed newAddress\\n    );\\n\\n    /// @notice Fallback function, not allowing transfer of ETH\\n    function() external payable {\\n        revert(\\\"ETH_TRANSFER_NOT_ALLOWED\\\");\\n    }\\n\\n    function execute() external {\\n        // Hardcoded address because of the determinism on buidlerevm\\n        address _addressesProvider = 0x7c2C195CD6D34B8F845992d380aADB2730bB9C6F;\\n        address _newLendingPoolManager = 0x0000000000000000000000000000000000000001;\\n        LendingPoolAddressesProvider(_addressesProvider).setLendingPoolManager(_newLendingPoolManager);\\n        emit ProposalExecuted(address(this), _addressesProvider, _newLendingPoolManager);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/mocks/TestVotingAssetA.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Mintable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\\\";\\n\\n/// @title TestVotingAssetA\\n/// @author Aave\\n/// @notice An ERC20 mintable and burnable token to use as whitelisted\\n///  voting asset on proposals\\ncontract TestVotingAssetA is ERC20Burnable, ERC20Mintable, ERC20Detailed {\\n\\n    /// @notice Constructor\\n    /// @param name Asset name\\n    /// @param symbol Asset symbol\\n    /// @param decimals Asset decimals\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals\\n    )\\n    public ERC20Detailed(name, symbol, decimals) {}\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\ncontract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev See {ERC20-_burnFrom}.\\n     */\\n    function burnFrom(address account, uint256 amount) public {\\n        _burnFrom(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/TestVotingAssetB.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Mintable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\\\";\\n\\n/// @title TestVotingAssetB\\n/// @author Aave\\n/// @notice An ERC20 mintable and burnable token to use as whitelisted\\n///  voting asset on proposals\\ncontract TestVotingAssetB is ERC20Burnable, ERC20Mintable, ERC20Detailed {\\n\\n    /// @notice Constructor\\n    /// @param name Asset name\\n    /// @param symbol Asset symbol\\n    /// @param decimals Asset decimals\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals\\n    )\\n    public ERC20Detailed(name, symbol, decimals) {}\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"council\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AavePropositionPower","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000016416176652050726f706f736974696f6e20506f77657200000000000000000000000000000000000000000000000000000000000000000000000000000000000341505000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000b9062896ec3a615a4e4444df183f0531a77218ae000000000000000000000000f7692c7920c174bdcc3387e8ec1fb2a6bd3ed906","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}