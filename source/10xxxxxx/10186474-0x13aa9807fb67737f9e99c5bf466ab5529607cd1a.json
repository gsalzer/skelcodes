{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\n\r\nabstract contract DSProxyInterface {\r\n\r\n    /// Truffle wont compile if this isn't commented\r\n    // function execute(bytes memory _code, bytes memory _data)\r\n    //     public virtual\r\n    //     payable\r\n    //     returns (address, bytes32);\r\n\r\n    function execute(address _target, bytes memory _data) public virtual payable returns (bytes32);\r\n\r\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\r\n\r\n    function owner() public virtual returns (address);\r\n}\r\n\r\n/// @title Implements logic for calling MCDSaverProxy always from same contract\r\ncontract MCDMonitorProxy {\r\n\r\n    uint public CHANGE_PERIOD;\r\n    address public monitor;\r\n    address public owner;\r\n    address public newMonitor;\r\n    uint public changeRequestedTimestamp;\r\n\r\n    mapping(address => bool) public allowed;\r\n\r\n    // if someone who is allowed become malicious, owner can't be changed\r\n    modifier onlyAllowed() {\r\n        require(allowed[msg.sender] || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMonitor() {\r\n        require (msg.sender == monitor);\r\n        _;\r\n    }\r\n\r\n    constructor(uint _changePeriod) public {\r\n        owner = msg.sender;\r\n        CHANGE_PERIOD = _changePeriod * 1 days;\r\n    }\r\n\r\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\r\n    /// @param _monitor Address of Monitor contract\r\n    function setMonitor(address _monitor) public onlyAllowed {\r\n        require(monitor == address(0));\r\n        monitor = _monitor;\r\n    }\r\n\r\n    /// @notice Only monitor contract is able to call execute on users proxy\r\n    /// @param _owner Address of cdp owner (users DSProxy address)\r\n    /// @param _saverProxy Address of MCDSaverProxy\r\n    /// @param _data Data to send to MCDSaverProxy\r\n    function callExecute(address _owner, address _saverProxy, bytes memory _data) public onlyMonitor {\r\n        // execute reverts if calling specific method fails\r\n        DSProxyInterface(_owner).execute(_saverProxy, _data);\r\n    }\r\n\r\n    /// @notice Allowed users are able to start procedure for changing monitor\r\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\r\n    /// @param _newMonitor address of new monitor\r\n    function changeMonitor(address _newMonitor) public onlyAllowed {\r\n        changeRequestedTimestamp = now;\r\n        newMonitor = _newMonitor;\r\n    }\r\n\r\n    /// @notice At any point allowed users are able to cancel monitor change\r\n    function cancelMonitorChange() public onlyAllowed {\r\n        changeRequestedTimestamp = 0;\r\n        newMonitor = address(0);\r\n    }\r\n\r\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\r\n    function confirmNewMonitor() public onlyAllowed {\r\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\r\n        require(changeRequestedTimestamp != 0);\r\n        require(newMonitor != address(0));\r\n\r\n        monitor = newMonitor;\r\n        newMonitor = address(0);\r\n        changeRequestedTimestamp = 0;\r\n    }\r\n\r\n    /// @notice Allowed users are able to add new allowed user\r\n    /// @param _user Address of user that will be allowed\r\n    function addAllowed(address _user) public onlyAllowed {\r\n        allowed[_user] = true;\r\n    }\r\n\r\n    /// @notice Allowed users are able to remove allowed user\r\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\r\n    /// @param _user Address of allowed user\r\n    function removeAllowed(address _user) public onlyAllowed {\r\n        allowed[_user] = false;\r\n    }\r\n}\r\n\r\n/// @title Implements enum Method\r\ncontract Static {\r\n\r\n    enum Method { Boost, Repay }\r\n}\r\n\r\nabstract contract ISubscriptions is Static {\r\n\r\n    function canCall(Method _method, uint _cdpId) external virtual view returns(bool, uint);\r\n    function getOwner(uint _cdpId) external virtual view returns(address);\r\n    function ratioGoodAfter(Method _method, uint _cdpId) external virtual view returns(bool, uint);\r\n    function getRatio(uint _cdpId) public view virtual returns (uint);\r\n    function getSubscribedInfo(uint _cdpId) public virtual view returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt);\r\n    function unsubscribeIfMoved(uint _cdpId) public virtual;\r\n}\r\n\r\nabstract contract Manager {\r\n    function last(address) virtual public returns (uint);\r\n    function cdpCan(address, uint, address) virtual public view returns (uint);\r\n    function ilks(uint) virtual public view returns (bytes32);\r\n    function owns(uint) virtual public view returns (address);\r\n    function urns(uint) virtual public view returns (address);\r\n    function vat() virtual public view returns (address);\r\n    function open(bytes32, address) virtual public returns (uint);\r\n    function give(uint, address) virtual public;\r\n    function cdpAllow(uint, address, uint) virtual public;\r\n    function urnAllow(address, uint) virtual public;\r\n    function frob(uint, int, int) virtual public;\r\n    function flux(uint, address, uint) virtual public;\r\n    function move(uint, address, uint) virtual public;\r\n    function exit(address, uint, address, uint) virtual public;\r\n    function quit(uint, address) virtual public;\r\n    function enter(address, uint) virtual public;\r\n    function shift(uint, uint) virtual public;\r\n}\r\n\r\ncontract AdminAuth {\r\n\r\n    address public owner;\r\n    address public admin;\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @notice Admin is set by owner first time, after that admin is super role and has permission to change owner\r\n    /// @param _admin Address of multisig that becomes admin\r\n    function setAdminByOwner(address _admin) public {\r\n        require(msg.sender == owner);\r\n        require(admin == address(0));\r\n\r\n        admin = _admin;\r\n    }\r\n\r\n    /// @notice Admin is able to set new admin\r\n    /// @param _admin Address of multisig that becomes new admin\r\n    function setAdminByAdmin(address _admin) public {\r\n        require(msg.sender == admin);\r\n\r\n        admin = _admin;\r\n    }\r\n\r\n    /// @notice Admin is able to change owner\r\n    /// @param _owner Address of new owner\r\n    function setOwnerByAdmin(address _owner) public {\r\n        require(msg.sender == admin);\r\n\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\ncontract Auth is AdminAuth {\r\n\r\n\tbool public ALL_AUTHORIZED = false;\r\n\r\n\tmapping(address => bool) public authorized;\r\n\r\n\tmodifier onlyAuthorized() {\r\n        require(ALL_AUTHORIZED || authorized[msg.sender]);\r\n        _;\r\n    }\r\n\r\n\tconstructor() public {\r\n\t\tauthorized[msg.sender] = true;\r\n\t}\r\n\r\n\tfunction setAuthorized(address _user, bool _approved) public onlyOwner {\r\n\t\tauthorized[_user] = _approved;\r\n\t}\r\n\r\n\tfunction setAllAuthorized(bool _authorized) public onlyOwner {\r\n\t\tALL_AUTHORIZED = _authorized;\r\n\t}\r\n}\r\n\r\nabstract contract DSGuard {\r\n    function canCall(address src_, address dst_, bytes4 sig) public view virtual returns (bool);\r\n\r\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\r\n\r\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\r\n\r\n    function permit(address src, address dst, bytes32 sig) public virtual;\r\n\r\n    function forbid(address src, address dst, bytes32 sig) public virtual;\r\n}\r\n\r\nabstract contract DSGuardFactory {\r\n    function newGuard() public virtual returns (DSGuard guard);\r\n}\r\n\r\nabstract contract DSAuthority {\r\n    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority(address indexed authority);\r\n    event LogSetOwner(address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority public authority;\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_) public auth {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_) public auth {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract ProxyPermission {\r\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\r\n\r\n    /// @notice Called in the context of DSProxy to authorize an address\r\n    /// @param _contractAddr Address which will be authorized\r\n    function givePermission(address _contractAddr) public {\r\n        address currAuthority = address(DSAuth(address(this)).authority());\r\n        DSGuard guard = DSGuard(currAuthority);\r\n\r\n        if (currAuthority == address(0)) {\r\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\r\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\r\n        }\r\n\r\n        guard.permit(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\r\n    }\r\n\r\n    /// @notice Called in the context of DSProxy to remove authority of an address\r\n    /// @param _contractAddr Auth address which will be removed from authority list\r\n    function removePermission(address _contractAddr) public {\r\n        address currAuthority = address(DSAuth(address(this)).authority());\r\n        \r\n        // if there is no authority, that means that contract doesn't have permission\r\n        if (currAuthority == address(0)) {\r\n            return;\r\n        }\r\n\r\n        DSGuard guard = DSGuard(currAuthority);\r\n        guard.forbid(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\r\n    }\r\n}\r\n\r\ncontract SubscriptionsMigration is Auth {\r\n\r\n\t// proxyPermission address\r\n\taddress public proxyPermission;\r\n\r\n\r\n\taddress public monitorProxyAddress = 0x93Efcf86b6a7a33aE961A7Ec6C741F49bce11DA7;\r\n\t// v1 monitor proxy\r\n\tMCDMonitorProxy public monitorProxyContract = MCDMonitorProxy(monitorProxyAddress);\r\n\t// v1 subscriptions contract\r\n\tISubscriptions public subscriptionsContract = ISubscriptions(0x83152CAA0d344a2Fd428769529e2d490A88f4393);\r\n\t// v2 subscriptions proxy with \"migrate\" method\r\n\taddress public subscriptionsProxyV2address = 0xd6f2125bF7FE2bc793dE7685EA7DEd8bff3917DD;\r\n\t// v2 subscriptions address (needs to be passed to migrate method)\r\n\taddress public subscriptionsV2address = 0xC45d4f6B6bf41b6EdAA58B01c4298B8d9078269a;\r\n\t// v1 subscriptions address\r\n\taddress public subscriptionsV1address = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;\r\n\t// v1 subscriptions proxy address\r\n\taddress public subscriptionsProxyV1address = 0xA5D33b02dBfFB3A9eF26ec21F15c43BdB53EB455;\r\n\t// manager to check if owner is valid\r\n\tManager public manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\r\n\r\n\tconstructor(address _proxyPermission) public {\r\n\t\tproxyPermission = _proxyPermission;\r\n\t}\r\n\r\n\tfunction migrate(uint[] memory _cdps) public onlyAuthorized {\r\n\r\n\t\tfor (uint i=0; i<_cdps.length; i++) {\r\n\t\t\tif (_cdps[i] == 0) continue;\r\n\r\n\t\t\tbool sub;\r\n\t\t\tuint minRatio;\r\n\t\t\tuint maxRatio;\r\n\t\t\tuint optimalRepay;\r\n\t\t\tuint optimalBoost;\r\n\t\t\taddress cdpOwner;\r\n\t\t\tuint collateral;\r\n\r\n\t\t\t// get data for specific cdp\r\n\t\t\t(sub, minRatio, maxRatio, optimalRepay, optimalBoost, cdpOwner, collateral,) = subscriptionsContract.getSubscribedInfo(_cdps[i]);\r\n\r\n\t\t\t// if user is not the owner anymore, we will have to unsub him manually\r\n\t\t\tif (cdpOwner != _getOwner(_cdps[i])) {\r\n\t\t\t\tcontinue;\r\n\t\t\t} \r\n\r\n\t\t\t// call migrate method on SubscriptionsProxyV2 through users DSProxy if cdp is subbed and have collateral\r\n\t\t\tif (sub && collateral > 0) {\r\n\t\t\t\tmonitorProxyContract.callExecute(cdpOwner, subscriptionsProxyV2address, abi.encodeWithSignature(\"migrate(uint256,uint128,uint128,uint128,uint128,bool,bool,address)\", _cdps[i], minRatio, maxRatio, optimalBoost, optimalRepay, true, true, subscriptionsV2address));\r\n\t\t\t} else {\r\n\t\t\t\t// if cdp is subbed but no collateral, just unsubscribe user\r\n\t\t\t\tif (sub) {\r\n\t\t\t\t\t_unsubscribe(_cdps[i], cdpOwner);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// don't remove authority here because we wouldn't be able to unsub or migrate if user have more than one cdp\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removeAuthority(address[] memory _users) public onlyAuthorized {\r\n\r\n\t\tfor (uint i=0; i<_users.length; i++) {\r\n\t\t\t_removeAuthority(_users[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _unsubscribe(uint _cdpId, address _cdpOwner) internal onlyAuthorized {\r\n\t\taddress currAuthority = address(DSAuth(_cdpOwner).authority());\r\n\t\t// if no authority return\r\n\t\tif (currAuthority == address(0)) return;\r\n        DSGuard guard = DSGuard(currAuthority);\r\n\r\n        // if we don't have permission on specific authority, return\r\n        if (!guard.canCall(monitorProxyAddress, _cdpOwner, bytes4(keccak256(\"execute(address,bytes)\")))) return;\r\n\r\n        // call unsubscribe on v1 proxy through users DSProxy\r\n\t\tmonitorProxyContract.callExecute(_cdpOwner, subscriptionsProxyV1address, abi.encodeWithSignature(\"unsubscribe(uint256,address)\", _cdpId, subscriptionsV1address));\r\n\t}\r\n\r\n\tfunction _removeAuthority(address _cdpOwner) internal onlyAuthorized {\r\n\r\n\t\taddress currAuthority = address(DSAuth(_cdpOwner).authority());\r\n\t\t// if no authority return\r\n\t\tif (currAuthority == address(0)) return;\r\n        DSGuard guard = DSGuard(currAuthority);\r\n\r\n        // if we don't have permission, that means its already removed\r\n        if (!guard.canCall(monitorProxyAddress, _cdpOwner, bytes4(keccak256(\"execute(address,bytes)\")))) return;\r\n\r\n\t\tmonitorProxyContract.callExecute(_cdpOwner, proxyPermission, abi.encodeWithSignature(\"removePermission(address)\", monitorProxyAddress));\r\n\t}\r\n\r\n\t/// @notice Returns an address that owns the CDP\r\n    /// @param _cdpId Id of the CDP\r\n    function _getOwner(uint _cdpId) internal view returns(address) {\r\n        return manager.owns(_cdpId);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyPermission\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ALL_AUTHORIZED\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract Manager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_cdps\",\"type\":\"uint256[]\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monitorProxyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monitorProxyContract\",\"outputs\":[{\"internalType\":\"contract MCDMonitorProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyPermission\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"removeAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdminByAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdminByOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_authorized\",\"type\":\"bool\"}],\"name\":\"setAllAuthorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setAuthorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwnerByAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionsContract\",\"outputs\":[{\"internalType\":\"contract ISubscriptions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionsProxyV1address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionsProxyV2address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionsV1address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionsV2address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SubscriptionsMigration","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"0000000000000000000000005d63204cad8bbf6dcdb33b67455b782d1b8ad845","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6a6f5dad7cf9b2bf91d2ff397a8481acd1a405fb941290c43c3984692b8b6ac1"}]}