{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.0;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\r\n*/\r\n \r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n  function ceil(uint a, uint m) internal pure returns (uint r) {\r\n    return (a + m - 1) / m * m;\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\nabstract contract ERC20Interface {\r\n    function totalSupply() public virtual view returns (uint);\r\n    function balanceOf(address tokenOwner) public virtual view returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) public virtual view returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) public virtual returns (bool success);\r\n    function approve(address spender, uint256 tokens) public virtual returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) public virtual returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\ncontract DGN_STAKE is Owned{\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    uint256 public penaltyFee = 5; //5% penlaty fee applicable before lock up time \r\n    uint256 public totalRewards;\r\n    uint256 public totalStakes;\r\n    \r\n    uint256 public firstYearRate = 20;\r\n    uint256 public secondYearRate = 15;\r\n    uint256 public afterSecondYearRate = 10;\r\n    \r\n    uint256 public firstYearStakingPeriod = 1 weeks;\r\n    uint256 public secondYearStakingPeriod = 3 days;\r\n    uint256 public afterSecondYearStakingPeriod = 24 hours;\r\n    \r\n    uint256 private contractStartDate;\r\n    \r\n    address constant DGN = 0x7461C43bb1E96863233D72A09191008ee9217Ee8;\r\n    \r\n    struct DepositedToken{\r\n        bool Exist;\r\n        uint256 activeDeposit;\r\n        uint256 totalDeposits;\r\n        uint256 startTime;\r\n        uint256 pendingGains;\r\n        uint256 lastClaimedDate;\r\n        uint256 totalGained;\r\n        address referrer;\r\n    }\r\n    \r\n    mapping(address => DepositedToken) users;\r\n    \r\n    event Staked(address staker, uint256 tokens);\r\n    event AddedToExistingStake(uint256 tokens);\r\n    event TokensClaimed(address claimer, uint256 stakedTokens);\r\n    event RewardClaimed(address claimer, uint256 reward);\r\n\r\n    \r\n    //#########################################################################################################################################################//\r\n    //####################################################STAKING EXTERNAL FUNCTIONS###########################################################################//\r\n    //#########################################################################################################################################################//    \r\n    \r\n    constructor() public{\r\n        contractStartDate = block.timestamp;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Start staking\r\n    // @param _tokenAddress address of the token asset\r\n    // @param _amount amount of tokens to deposit\r\n    // ------------------------------------------------------------------------\r\n    function STAKE(uint256 _amount, address _referrerID) public {\r\n        require(_referrerID == address(0) || users[_referrerID].Exist, \"Invalid Referrer Id\");\r\n        \r\n        // add new stake\r\n        _newDeposit(DGN, _amount, _referrerID);\r\n        \r\n        // update referral reward\r\n        _updateReferralReward(_amount, _referrerID);\r\n        \r\n        // transfer tokens from user to the contract balance\r\n        ERC20Interface(DGN).transferFrom(msg.sender, address(this), _amount);\r\n        \r\n        emit Staked(msg.sender, _amount);\r\n        \r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Claim reward and staked tokens\r\n    // @required user must be a staker\r\n    // @required must be claimable\r\n    // ------------------------------------------------------------------------\r\n    function ClaimStakedTokens() external {\r\n        require(users[msg.sender].activeDeposit > 0, \"no running stake\");\r\n        \r\n        uint256 _penaltyFee = 0;\r\n        \r\n        if(users[msg.sender].startTime + latestStakingPeriod() > now){ // claiming before lock up time\r\n            _penaltyFee = penaltyFee; \r\n        }\r\n        \r\n        uint256 toTransfer = users[msg.sender].activeDeposit.sub(_onePercent(users[msg.sender].activeDeposit).mul(_penaltyFee));\r\n        // transfer staked tokens - apply 5% penalty and send back staked tokens\r\n        ERC20Interface(DGN).transfer(msg.sender, toTransfer);\r\n        \r\n        // check if we have any pending reward, add it to pendingGains var\r\n        users[msg.sender].pendingGains = pendingReward(msg.sender);\r\n        \r\n        emit TokensClaimed(msg.sender, toTransfer);\r\n        \r\n        // update amount \r\n        users[msg.sender].activeDeposit = 0;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Claim reward and staked tokens\r\n    // @required user must be a staker\r\n    // @required must be claimable\r\n    // ------------------------------------------------------------------------\r\n    function ClaimReward() public {\r\n        require(pendingReward(msg.sender) > 0, \"nothing pending to claim\");\r\n    \r\n        // transfer the reward to the claimer\r\n        ERC20Interface(DGN).transfer(msg.sender, pendingReward(msg.sender)); \r\n        \r\n        emit RewardClaimed(msg.sender, pendingReward(msg.sender));\r\n        \r\n        // add claimed reward to global stats\r\n        totalRewards += pendingReward(msg.sender);\r\n        \r\n        // add the reward to total claimed rewards\r\n        users[msg.sender].totalGained += pendingReward(msg.sender);\r\n        // update lastClaim amount\r\n        users[msg.sender].lastClaimedDate = now;\r\n        // reset previous rewards\r\n        users[msg.sender].pendingGains = 0;\r\n    }\r\n    \r\n    //#########################################################################################################################################################//\r\n    //####################################################STAKING QUERIES######################################################################################//\r\n    //#########################################################################################################################################################//\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the pending reward\r\n    // ------------------------------------------------------------------------\r\n    function pendingReward(address _caller) public view returns(uint256 _pendingReward){\r\n        uint256 _totalStakedTime = 0;\r\n        uint256 expiryDate = (latestStakingPeriod()).add(users[_caller].startTime);\r\n        \r\n        if(now < expiryDate)\r\n            _totalStakedTime = now.sub(users[_caller].lastClaimedDate);\r\n        else{\r\n            if(users[_caller].lastClaimedDate >= expiryDate) // if claimed after expirydate already\r\n                _totalStakedTime = 0;\r\n            else\r\n                _totalStakedTime = expiryDate.sub(users[_caller].lastClaimedDate);\r\n        }\r\n            \r\n        uint256 _reward_token_second = ((latestStakingRate()).mul(10 ** 21)).div(365 days); // added extra 10^21\r\n        \r\n        uint256 reward =  ((users[_caller].activeDeposit).mul(_totalStakedTime.mul(_reward_token_second))).div(10 ** 23); // remove extra 10^21 // the two extra 10^2 is for 100 (%)\r\n        \r\n        return (reward.add(users[_caller].pendingGains));\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the active stake of the user\r\n    // ------------------------------------------------------------------------\r\n    function yourActiveStake(address _user) public view returns(uint256 _activeStake){\r\n        return users[_user].activeDeposit;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the total stakes of the user\r\n    // ------------------------------------------------------------------------\r\n    function yourTotalStakesTillToday(address _user) public view returns(uint256 _totalStakes){\r\n        return users[_user].totalDeposits;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the time of last stake of user\r\n    // ------------------------------------------------------------------------\r\n    function StakedOn(address _user) public view returns(uint256 _unixLastStakedTime){\r\n        return users[_user].startTime;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get total earned rewards from stake\r\n    // ------------------------------------------------------------------------\r\n    function totalStakeRewardsClaimedTillToday(address _user) public view returns(uint256 _totalEarned){\r\n        return users[_user].totalGained;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the staking rate\r\n    // ------------------------------------------------------------------------\r\n    function latestStakingRate() public view returns(uint256 APY){\r\n        uint256 yearOfContract = (((block.timestamp).sub(contractStartDate)).div(365 days)).add(1);\r\n        uint256 rate;\r\n        \r\n        if(yearOfContract == 1)\r\n            rate = firstYearRate;\r\n            \r\n        else if(yearOfContract == 2)\r\n            rate = secondYearRate;\r\n        else\r\n            rate = afterSecondYearRate;\r\n            \r\n        return rate;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the staking period \r\n    // ------------------------------------------------------------------------\r\n    function latestStakingPeriod() public view returns(uint256 Period){\r\n        uint256 yearOfContract = (((block.timestamp).sub(contractStartDate)).div(365 days)).add(1);\r\n        uint256 period;\r\n        \r\n        if(yearOfContract == 1)\r\n            period = firstYearStakingPeriod;\r\n            \r\n        else if(yearOfContract == 2)\r\n            period = secondYearStakingPeriod;\r\n        else\r\n            period = afterSecondYearStakingPeriod;\r\n            \r\n        return period;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Query to get the staking time left\r\n    // ------------------------------------------------------------------------\r\n    function stakingTimeLeft(address _user) public view returns(uint256 _secsLeft){\r\n        if(users[_user].activeDeposit > 0){\r\n            uint256 left = 0; \r\n            uint256 expiryDate = (latestStakingPeriod()).add(StakedOn(_user));\r\n        \r\n            if(now < expiryDate)\r\n                left = expiryDate.sub(now);\r\n            \r\n            return left;\r\n        } \r\n        else\r\n            return 0;\r\n    }\r\n    \r\n    //#########################################################################################################################################################//\r\n    //################################################################COMMON UTILITIES#########################################################################//\r\n    //#########################################################################################################################################################//    \r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Internal function to add new deposit\r\n    // ------------------------------------------------------------------------        \r\n    function _newDeposit(address _tokenAddress, uint256 _amount, address _referrerID) internal{\r\n        require(users[msg.sender].activeDeposit ==  0, \"Already running\");\r\n        require(_tokenAddress == DGN, \"Only DGN tokens supported\");\r\n        \r\n        // add that token into the contract balance\r\n        // check if we have any pending reward, add it to pendingGains variable\r\n        \r\n        users[msg.sender].pendingGains = pendingReward(msg.sender);\r\n\r\n        users[msg.sender].activeDeposit = _amount;\r\n        users[msg.sender].totalDeposits += _amount;\r\n        users[msg.sender].startTime = now;\r\n        users[msg.sender].lastClaimedDate = now;\r\n        users[msg.sender].referrer = _referrerID;\r\n        users[msg.sender].Exist = true;\r\n        \r\n        totalStakes += _amount;\r\n        \r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Calculates onePercent of the uint256 amount sent\r\n    // ------------------------------------------------------------------------\r\n    function _onePercent(uint256 _tokens) internal pure returns (uint256){\r\n        uint256 roundValue = _tokens.ceil(100);\r\n        uint onePercentofTokens = roundValue.mul(100).div(100 * 10**uint(2));\r\n        return onePercentofTokens;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Updates the reward for referrer\r\n    // ------------------------------------------------------------------------\r\n    function _updateReferralReward(uint256 _amount, address _referrerID) private{\r\n        users[_referrerID].pendingGains +=  _onePercent(_amount);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"AddedToExistingStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedTokens\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ClaimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimStakedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrerID\",\"type\":\"address\"}],\"name\":\"STAKE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"StakedOn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_unixLastStakedTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"afterSecondYearRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"afterSecondYearStakingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstYearRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstYearStakingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestStakingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Period\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestStakingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondYearRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondYearStakingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"stakingTimeLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_secsLeft\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"totalStakeRewardsClaimedTillToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalEarned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"yourActiveStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_activeStake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"yourTotalStakesTillToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalStakes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DGN_STAKE","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f029d8ec53f4d50b84459e9fa776b819841e5111434268f0d6c745e36be40516"}]}