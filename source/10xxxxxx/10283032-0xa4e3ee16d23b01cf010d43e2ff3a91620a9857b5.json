{"status":"1","message":"OK","result":[{"SourceCode":"// ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\r\npragma solidity ^0.5.2;\r\n\r\ncontract MimcConstraintPoly {\r\n    // The Memory map during the execution of this contract is as follows:\r\n    // [0x0, 0x20) - periodic_column/consts0_a.\r\n    // [0x20, 0x40) - periodic_column/consts1_a.\r\n    // [0x40, 0x60) - periodic_column/consts2_a.\r\n    // [0x60, 0x80) - periodic_column/consts3_a.\r\n    // [0x80, 0xa0) - periodic_column/consts4_a.\r\n    // [0xa0, 0xc0) - periodic_column/consts5_a.\r\n    // [0xc0, 0xe0) - periodic_column/consts6_a.\r\n    // [0xe0, 0x100) - periodic_column/consts7_a.\r\n    // [0x100, 0x120) - periodic_column/consts8_a.\r\n    // [0x120, 0x140) - periodic_column/consts9_a.\r\n    // [0x140, 0x160) - periodic_column/consts0_b.\r\n    // [0x160, 0x180) - periodic_column/consts1_b.\r\n    // [0x180, 0x1a0) - periodic_column/consts2_b.\r\n    // [0x1a0, 0x1c0) - periodic_column/consts3_b.\r\n    // [0x1c0, 0x1e0) - periodic_column/consts4_b.\r\n    // [0x1e0, 0x200) - periodic_column/consts5_b.\r\n    // [0x200, 0x220) - periodic_column/consts6_b.\r\n    // [0x220, 0x240) - periodic_column/consts7_b.\r\n    // [0x240, 0x260) - periodic_column/consts8_b.\r\n    // [0x260, 0x280) - periodic_column/consts9_b.\r\n    // [0x280, 0x2a0) - mat00.\r\n    // [0x2a0, 0x2c0) - mat01.\r\n    // [0x2c0, 0x2e0) - trace_length.\r\n    // [0x2e0, 0x300) - mat10.\r\n    // [0x300, 0x320) - mat11.\r\n    // [0x320, 0x340) - input_value_a.\r\n    // [0x340, 0x360) - output_value_a.\r\n    // [0x360, 0x380) - input_value_b.\r\n    // [0x380, 0x3a0) - output_value_b.\r\n    // [0x3a0, 0x3c0) - trace_generator.\r\n    // [0x3c0, 0x3e0) - oods_point.\r\n    // [0x3e0, 0x9e0) - coefficients.\r\n    // [0x9e0, 0xca0) - oods_values.\r\n    // ----------------------- end of input data - -------------------------\r\n    // [0xca0, 0xcc0) - composition_degree_bound.\r\n    // [0xcc0, 0xce0) - intermediate_value/after_lin_transform0_a_0.\r\n    // [0xce0, 0xd00) - intermediate_value/after_lin_transform0_b_0.\r\n    // [0xd00, 0xd20) - intermediate_value/after_lin_transform1_a_0.\r\n    // [0xd20, 0xd40) - intermediate_value/after_lin_transform1_b_0.\r\n    // [0xd40, 0xd60) - intermediate_value/after_lin_transform2_a_0.\r\n    // [0xd60, 0xd80) - intermediate_value/after_lin_transform2_b_0.\r\n    // [0xd80, 0xda0) - intermediate_value/after_lin_transform3_a_0.\r\n    // [0xda0, 0xdc0) - intermediate_value/after_lin_transform3_b_0.\r\n    // [0xdc0, 0xde0) - intermediate_value/after_lin_transform4_a_0.\r\n    // [0xde0, 0xe00) - intermediate_value/after_lin_transform4_b_0.\r\n    // [0xe00, 0xe20) - intermediate_value/after_lin_transform5_a_0.\r\n    // [0xe20, 0xe40) - intermediate_value/after_lin_transform5_b_0.\r\n    // [0xe40, 0xe60) - intermediate_value/after_lin_transform6_a_0.\r\n    // [0xe60, 0xe80) - intermediate_value/after_lin_transform6_b_0.\r\n    // [0xe80, 0xea0) - intermediate_value/after_lin_transform7_a_0.\r\n    // [0xea0, 0xec0) - intermediate_value/after_lin_transform7_b_0.\r\n    // [0xec0, 0xee0) - intermediate_value/after_lin_transform8_a_0.\r\n    // [0xee0, 0xf00) - intermediate_value/after_lin_transform8_b_0.\r\n    // [0xf00, 0xf20) - intermediate_value/after_lin_transform9_a_0.\r\n    // [0xf20, 0xf40) - intermediate_value/after_lin_transform9_b_0.\r\n    // [0xf40, 0xf80) - expmods.\r\n    // [0xf80, 0xfe0) - denominator_invs.\r\n    // [0xfe0, 0x1040) - denominators.\r\n    // [0x1040, 0x1060) - numerators.\r\n    // [0x1060, 0x10c0) - adjustments.\r\n    // [0x10c0, 0x1180) - expmod_context.\r\n\r\n    function() external {\r\n        uint256 res;\r\n        assembly {\r\n            let PRIME := 0x30000003000000010000000000000001\r\n            // Copy input from calldata to memory.\r\n            calldatacopy(0x0, 0x0, /*Input data size*/ 0xca0)\r\n            let point := /*oods_point*/ mload(0x3c0)\r\n            // Initialize composition_degree_bound to 2 * trace_length.\r\n            mstore(0xca0, mul(2, /*trace_length*/ mload(0x2c0)))\r\n            function expmod(base, exponent, modulus) -> res {\r\n              let p := /*expmod_context*/ 0x10c0\r\n              mstore(p, 0x20)                 // Length of Base.\r\n              mstore(add(p, 0x20), 0x20)      // Length of Exponent.\r\n              mstore(add(p, 0x40), 0x20)      // Length of Modulus.\r\n              mstore(add(p, 0x60), base)      // Base.\r\n              mstore(add(p, 0x80), exponent)  // Exponent.\r\n              mstore(add(p, 0xa0), modulus)   // Modulus.\r\n              // Call modexp precompile.\r\n              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\r\n                revert(0, 0)\r\n              }\r\n              res := mload(p)\r\n            }\r\n\r\n            function degreeAdjustment(compositionPolynomialDegreeBound, constraintDegree, numeratorDegree,\r\n                                       denominatorDegree) -> res {\r\n              res := sub(sub(compositionPolynomialDegreeBound, 1),\r\n                         sub(add(constraintDegree, numeratorDegree), denominatorDegree))\r\n            }\r\n\r\n            {\r\n              // Prepare expmods for denominators and numerators.\r\n\r\n              // expmods[0] = point^trace_length.\r\n              mstore(0xf40, expmod(point, /*trace_length*/ mload(0x2c0), PRIME))\r\n\r\n              // expmods[1] = trace_generator^(trace_length - 1).\r\n              mstore(0xf60, expmod(/*trace_generator*/ mload(0x3a0), sub(/*trace_length*/ mload(0x2c0), 1), PRIME))\r\n\r\n            }\r\n\r\n            {\r\n              // Prepare denominators for batch inverse.\r\n\r\n              // Denominator for constraints: 'step0_a', 'step0_b', 'step1_a', 'step1_b', 'step2_a', 'step2_b', 'step3_a', 'step3_b', 'step4_a', 'step4_b', 'step5_a', 'step5_b', 'step6_a', 'step6_b', 'step7_a', 'step7_b', 'step8_a', 'step8_b', 'step9_a', 'step9_b'.\r\n              // denominators[0] = point^trace_length - 1.\r\n              mstore(0xfe0,\r\n                     addmod(/*point^trace_length*/ mload(0xf40), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'input_a', 'input_b'.\r\n              // denominators[1] = point - 1.\r\n              mstore(0x1000,\r\n                     addmod(point, sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'output_a', 'output_b'.\r\n              // denominators[2] = point - trace_generator^(trace_length - 1).\r\n              mstore(0x1020,\r\n                     addmod(point, sub(PRIME, /*trace_generator^(trace_length - 1)*/ mload(0xf60)), PRIME))\r\n\r\n            }\r\n\r\n            {\r\n              // Compute the inverses of the denominators into denominatorInvs using batch inverse.\r\n\r\n              // Start by computing the cumulative product.\r\n              // Let (d_0, d_1, d_2, ..., d_{n-1}) be the values in denominators. After this loop\r\n              // denominatorInvs will be (1, d_0, d_0 * d_1, ...) and prod will contain the value of\r\n              // d_0 * ... * d_{n-1}.\r\n              // Compute the offset between the partialProducts array and the input values array.\r\n              let productsToValuesOffset := 0x60\r\n              let prod := 1\r\n              let partialProductEndPtr := 0xfe0\r\n              for { let partialProductPtr := 0xf80 }\r\n                  lt(partialProductPtr, partialProductEndPtr)\r\n                  { partialProductPtr := add(partialProductPtr, 0x20) } {\r\n                  mstore(partialProductPtr, prod)\r\n                  // prod *= d_{i}.\r\n                  prod := mulmod(prod,\r\n                                 mload(add(partialProductPtr, productsToValuesOffset)),\r\n                                 PRIME)\r\n              }\r\n\r\n              let firstPartialProductPtr := 0xf80\r\n              // Compute the inverse of the product.\r\n              let prodInv := expmod(prod, sub(PRIME, 2), PRIME)\r\n\r\n              if eq(prodInv, 0) {\r\n                  // Solidity generates reverts with reason that look as follows:\r\n                  // 1. 4 bytes with the constant 0x08c379a0 (== Keccak256(b'Error(string)')[:4]).\r\n                  // 2. 32 bytes offset bytes (always 0x20 as far as i can tell).\r\n                  // 3. 32 bytes with the length of the revert reason.\r\n                  // 4. Revert reason string.\r\n\r\n                  mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                  mstore(0x4, 0x20)\r\n                  mstore(0x24, 0x1e)\r\n                  mstore(0x44, \"Batch inverse product is zero.\")\r\n                  revert(0, 0x62)\r\n              }\r\n\r\n              // Compute the inverses.\r\n              // Loop over denominator_invs in reverse order.\r\n              // currentPartialProductPtr is initialized to one past the end.\r\n              let currentPartialProductPtr := 0xfe0\r\n              for { } gt(currentPartialProductPtr, firstPartialProductPtr) { } {\r\n                  currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\r\n                  // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\r\n                  mstore(currentPartialProductPtr,\r\n                         mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\r\n                  // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\r\n                  prodInv := mulmod(prodInv,\r\n                                     mload(add(currentPartialProductPtr, productsToValuesOffset)),\r\n                                     PRIME)\r\n              }\r\n            }\r\n\r\n            {\r\n              // Compute numerators and adjustment polynomials.\r\n\r\n              // Numerator for constraints 'step9_a', 'step9_b'.\r\n              // numerators[0] = point - trace_generator^(trace_length - 1).\r\n              mstore(0x1040,\r\n                     addmod(point, sub(PRIME, /*trace_generator^(trace_length - 1)*/ mload(0xf60)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'step0_a', 'step0_b', 'step1_a', 'step1_b', 'step2_a', 'step2_b', 'step3_a', 'step3_b', 'step4_a', 'step4_b', 'step5_a', 'step5_b', 'step6_a', 'step6_b', 'step7_a', 'step7_b', 'step8_a', 'step8_b'.\r\n              // adjustments[0] = point^degreeAdjustment(composition_degree_bound, 3 * (trace_length - 1), 0, trace_length).\r\n              mstore(0x1060,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0xca0), mul(3, sub(/*trace_length*/ mload(0x2c0), 1)), 0, /*trace_length*/ mload(0x2c0)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'step9_a', 'step9_b'.\r\n              // adjustments[1] = point^degreeAdjustment(composition_degree_bound, 3 * (trace_length - 1), 1, trace_length).\r\n              mstore(0x1080,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0xca0), mul(3, sub(/*trace_length*/ mload(0x2c0), 1)), 1, /*trace_length*/ mload(0x2c0)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'input_a', 'output_a', 'input_b', 'output_b'.\r\n              // adjustments[2] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, 1).\r\n              mstore(0x10a0,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0xca0), sub(/*trace_length*/ mload(0x2c0), 1), 0, 1), PRIME))\r\n\r\n            }\r\n\r\n            {\r\n              // Compute the result of the composition polynomial.\r\n\r\n              {\r\n              // after_lin_transform0_a_0 = mat00 * (column0_row0 - consts0_a) + mat01 * (column10_row0 - consts0_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat00*/ mload(0x280),\r\n                  addmod(\r\n                    /*column0_row0*/ mload(0x9e0),\r\n                    sub(PRIME, /*periodic_column/consts0_a*/ mload(0x0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat01*/ mload(0x2a0),\r\n                  addmod(\r\n                    /*column10_row0*/ mload(0xb40),\r\n                    sub(PRIME, /*periodic_column/consts0_b*/ mload(0x140)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xcc0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform0_b_0 = mat10 * (column0_row0 - consts0_a) + mat11 * (column10_row0 - consts0_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat10*/ mload(0x2e0),\r\n                  addmod(\r\n                    /*column0_row0*/ mload(0x9e0),\r\n                    sub(PRIME, /*periodic_column/consts0_a*/ mload(0x0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat11*/ mload(0x300),\r\n                  addmod(\r\n                    /*column10_row0*/ mload(0xb40),\r\n                    sub(PRIME, /*periodic_column/consts0_b*/ mload(0x140)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xce0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform1_a_0 = mat00 * (column1_row0 - consts1_a) + mat01 * (column11_row0 - consts1_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat00*/ mload(0x280),\r\n                  addmod(\r\n                    /*column1_row0*/ mload(0xa20),\r\n                    sub(PRIME, /*periodic_column/consts1_a*/ mload(0x20)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat01*/ mload(0x2a0),\r\n                  addmod(\r\n                    /*column11_row0*/ mload(0xb80),\r\n                    sub(PRIME, /*periodic_column/consts1_b*/ mload(0x160)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xd00, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform1_b_0 = mat10 * (column1_row0 - consts1_a) + mat11 * (column11_row0 - consts1_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat10*/ mload(0x2e0),\r\n                  addmod(\r\n                    /*column1_row0*/ mload(0xa20),\r\n                    sub(PRIME, /*periodic_column/consts1_a*/ mload(0x20)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat11*/ mload(0x300),\r\n                  addmod(\r\n                    /*column11_row0*/ mload(0xb80),\r\n                    sub(PRIME, /*periodic_column/consts1_b*/ mload(0x160)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xd20, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform2_a_0 = mat00 * (column2_row0 - consts2_a) + mat01 * (column12_row0 - consts2_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat00*/ mload(0x280),\r\n                  addmod(\r\n                    /*column2_row0*/ mload(0xa40),\r\n                    sub(PRIME, /*periodic_column/consts2_a*/ mload(0x40)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat01*/ mload(0x2a0),\r\n                  addmod(\r\n                    /*column12_row0*/ mload(0xba0),\r\n                    sub(PRIME, /*periodic_column/consts2_b*/ mload(0x180)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xd40, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform2_b_0 = mat10 * (column2_row0 - consts2_a) + mat11 * (column12_row0 - consts2_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat10*/ mload(0x2e0),\r\n                  addmod(\r\n                    /*column2_row0*/ mload(0xa40),\r\n                    sub(PRIME, /*periodic_column/consts2_a*/ mload(0x40)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat11*/ mload(0x300),\r\n                  addmod(\r\n                    /*column12_row0*/ mload(0xba0),\r\n                    sub(PRIME, /*periodic_column/consts2_b*/ mload(0x180)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xd60, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform3_a_0 = mat00 * (column3_row0 - consts3_a) + mat01 * (column13_row0 - consts3_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat00*/ mload(0x280),\r\n                  addmod(\r\n                    /*column3_row0*/ mload(0xa60),\r\n                    sub(PRIME, /*periodic_column/consts3_a*/ mload(0x60)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat01*/ mload(0x2a0),\r\n                  addmod(\r\n                    /*column13_row0*/ mload(0xbc0),\r\n                    sub(PRIME, /*periodic_column/consts3_b*/ mload(0x1a0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xd80, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform3_b_0 = mat10 * (column3_row0 - consts3_a) + mat11 * (column13_row0 - consts3_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat10*/ mload(0x2e0),\r\n                  addmod(\r\n                    /*column3_row0*/ mload(0xa60),\r\n                    sub(PRIME, /*periodic_column/consts3_a*/ mload(0x60)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat11*/ mload(0x300),\r\n                  addmod(\r\n                    /*column13_row0*/ mload(0xbc0),\r\n                    sub(PRIME, /*periodic_column/consts3_b*/ mload(0x1a0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xda0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform4_a_0 = mat00 * (column4_row0 - consts4_a) + mat01 * (column14_row0 - consts4_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat00*/ mload(0x280),\r\n                  addmod(\r\n                    /*column4_row0*/ mload(0xa80),\r\n                    sub(PRIME, /*periodic_column/consts4_a*/ mload(0x80)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat01*/ mload(0x2a0),\r\n                  addmod(\r\n                    /*column14_row0*/ mload(0xbe0),\r\n                    sub(PRIME, /*periodic_column/consts4_b*/ mload(0x1c0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xdc0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform4_b_0 = mat10 * (column4_row0 - consts4_a) + mat11 * (column14_row0 - consts4_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat10*/ mload(0x2e0),\r\n                  addmod(\r\n                    /*column4_row0*/ mload(0xa80),\r\n                    sub(PRIME, /*periodic_column/consts4_a*/ mload(0x80)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat11*/ mload(0x300),\r\n                  addmod(\r\n                    /*column14_row0*/ mload(0xbe0),\r\n                    sub(PRIME, /*periodic_column/consts4_b*/ mload(0x1c0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xde0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform5_a_0 = mat00 * (column5_row0 - consts5_a) + mat01 * (column15_row0 - consts5_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat00*/ mload(0x280),\r\n                  addmod(\r\n                    /*column5_row0*/ mload(0xaa0),\r\n                    sub(PRIME, /*periodic_column/consts5_a*/ mload(0xa0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat01*/ mload(0x2a0),\r\n                  addmod(\r\n                    /*column15_row0*/ mload(0xc00),\r\n                    sub(PRIME, /*periodic_column/consts5_b*/ mload(0x1e0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xe00, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform5_b_0 = mat10 * (column5_row0 - consts5_a) + mat11 * (column15_row0 - consts5_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat10*/ mload(0x2e0),\r\n                  addmod(\r\n                    /*column5_row0*/ mload(0xaa0),\r\n                    sub(PRIME, /*periodic_column/consts5_a*/ mload(0xa0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat11*/ mload(0x300),\r\n                  addmod(\r\n                    /*column15_row0*/ mload(0xc00),\r\n                    sub(PRIME, /*periodic_column/consts5_b*/ mload(0x1e0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xe20, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform6_a_0 = mat00 * (column6_row0 - consts6_a) + mat01 * (column16_row0 - consts6_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat00*/ mload(0x280),\r\n                  addmod(\r\n                    /*column6_row0*/ mload(0xac0),\r\n                    sub(PRIME, /*periodic_column/consts6_a*/ mload(0xc0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat01*/ mload(0x2a0),\r\n                  addmod(\r\n                    /*column16_row0*/ mload(0xc20),\r\n                    sub(PRIME, /*periodic_column/consts6_b*/ mload(0x200)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xe40, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform6_b_0 = mat10 * (column6_row0 - consts6_a) + mat11 * (column16_row0 - consts6_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat10*/ mload(0x2e0),\r\n                  addmod(\r\n                    /*column6_row0*/ mload(0xac0),\r\n                    sub(PRIME, /*periodic_column/consts6_a*/ mload(0xc0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat11*/ mload(0x300),\r\n                  addmod(\r\n                    /*column16_row0*/ mload(0xc20),\r\n                    sub(PRIME, /*periodic_column/consts6_b*/ mload(0x200)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xe60, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform7_a_0 = mat00 * (column7_row0 - consts7_a) + mat01 * (column17_row0 - consts7_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat00*/ mload(0x280),\r\n                  addmod(\r\n                    /*column7_row0*/ mload(0xae0),\r\n                    sub(PRIME, /*periodic_column/consts7_a*/ mload(0xe0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat01*/ mload(0x2a0),\r\n                  addmod(\r\n                    /*column17_row0*/ mload(0xc40),\r\n                    sub(PRIME, /*periodic_column/consts7_b*/ mload(0x220)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xe80, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform7_b_0 = mat10 * (column7_row0 - consts7_a) + mat11 * (column17_row0 - consts7_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat10*/ mload(0x2e0),\r\n                  addmod(\r\n                    /*column7_row0*/ mload(0xae0),\r\n                    sub(PRIME, /*periodic_column/consts7_a*/ mload(0xe0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat11*/ mload(0x300),\r\n                  addmod(\r\n                    /*column17_row0*/ mload(0xc40),\r\n                    sub(PRIME, /*periodic_column/consts7_b*/ mload(0x220)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xea0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform8_a_0 = mat00 * (column8_row0 - consts8_a) + mat01 * (column18_row0 - consts8_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat00*/ mload(0x280),\r\n                  addmod(\r\n                    /*column8_row0*/ mload(0xb00),\r\n                    sub(PRIME, /*periodic_column/consts8_a*/ mload(0x100)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat01*/ mload(0x2a0),\r\n                  addmod(\r\n                    /*column18_row0*/ mload(0xc60),\r\n                    sub(PRIME, /*periodic_column/consts8_b*/ mload(0x240)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xec0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform8_b_0 = mat10 * (column8_row0 - consts8_a) + mat11 * (column18_row0 - consts8_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat10*/ mload(0x2e0),\r\n                  addmod(\r\n                    /*column8_row0*/ mload(0xb00),\r\n                    sub(PRIME, /*periodic_column/consts8_a*/ mload(0x100)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat11*/ mload(0x300),\r\n                  addmod(\r\n                    /*column18_row0*/ mload(0xc60),\r\n                    sub(PRIME, /*periodic_column/consts8_b*/ mload(0x240)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xee0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform9_a_0 = mat00 * (column9_row0 - consts9_a) + mat01 * (column19_row0 - consts9_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat00*/ mload(0x280),\r\n                  addmod(\r\n                    /*column9_row0*/ mload(0xb20),\r\n                    sub(PRIME, /*periodic_column/consts9_a*/ mload(0x120)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat01*/ mload(0x2a0),\r\n                  addmod(\r\n                    /*column19_row0*/ mload(0xc80),\r\n                    sub(PRIME, /*periodic_column/consts9_b*/ mload(0x260)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xf00, val)\r\n              }\r\n\r\n\r\n              {\r\n              // after_lin_transform9_b_0 = mat10 * (column9_row0 - consts9_a) + mat11 * (column19_row0 - consts9_b).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*mat10*/ mload(0x2e0),\r\n                  addmod(\r\n                    /*column9_row0*/ mload(0xb20),\r\n                    sub(PRIME, /*periodic_column/consts9_a*/ mload(0x120)),\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*mat11*/ mload(0x300),\r\n                  addmod(\r\n                    /*column19_row0*/ mload(0xc80),\r\n                    sub(PRIME, /*periodic_column/consts9_b*/ mload(0x260)),\r\n                    PRIME),\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0xf20, val)\r\n              }\r\n\r\n\r\n              {\r\n              // Constraint expression for step0_a: column1_row0 - after_lin_transform0_a_0 * after_lin_transform0_a_0 * after_lin_transform0_a_0.\r\n              let val := addmod(\r\n                /*column1_row0*/ mload(0xa20),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform0_a_0*/ mload(0xcc0),\r\n                      /*intermediate_value/after_lin_transform0_a_0*/ mload(0xcc0),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform0_a_0*/ mload(0xcc0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[0] + coefficients[1] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[0]*/ mload(0x3e0),\r\n                                       mulmod(/*coefficients[1]*/ mload(0x400),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step0_b: column11_row0 - after_lin_transform0_b_0 * after_lin_transform0_b_0 * after_lin_transform0_b_0.\r\n              let val := addmod(\r\n                /*column11_row0*/ mload(0xb80),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform0_b_0*/ mload(0xce0),\r\n                      /*intermediate_value/after_lin_transform0_b_0*/ mload(0xce0),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform0_b_0*/ mload(0xce0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[2] + coefficients[3] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[2]*/ mload(0x420),\r\n                                       mulmod(/*coefficients[3]*/ mload(0x440),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step1_a: column2_row0 - after_lin_transform1_a_0 * after_lin_transform1_a_0 * after_lin_transform1_a_0.\r\n              let val := addmod(\r\n                /*column2_row0*/ mload(0xa40),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform1_a_0*/ mload(0xd00),\r\n                      /*intermediate_value/after_lin_transform1_a_0*/ mload(0xd00),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform1_a_0*/ mload(0xd00),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[4] + coefficients[5] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[4]*/ mload(0x460),\r\n                                       mulmod(/*coefficients[5]*/ mload(0x480),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step1_b: column12_row0 - after_lin_transform1_b_0 * after_lin_transform1_b_0 * after_lin_transform1_b_0.\r\n              let val := addmod(\r\n                /*column12_row0*/ mload(0xba0),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform1_b_0*/ mload(0xd20),\r\n                      /*intermediate_value/after_lin_transform1_b_0*/ mload(0xd20),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform1_b_0*/ mload(0xd20),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[6] + coefficients[7] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[6]*/ mload(0x4a0),\r\n                                       mulmod(/*coefficients[7]*/ mload(0x4c0),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step2_a: column3_row0 - after_lin_transform2_a_0 * after_lin_transform2_a_0 * after_lin_transform2_a_0.\r\n              let val := addmod(\r\n                /*column3_row0*/ mload(0xa60),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform2_a_0*/ mload(0xd40),\r\n                      /*intermediate_value/after_lin_transform2_a_0*/ mload(0xd40),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform2_a_0*/ mload(0xd40),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[8] + coefficients[9] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[8]*/ mload(0x4e0),\r\n                                       mulmod(/*coefficients[9]*/ mload(0x500),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step2_b: column13_row0 - after_lin_transform2_b_0 * after_lin_transform2_b_0 * after_lin_transform2_b_0.\r\n              let val := addmod(\r\n                /*column13_row0*/ mload(0xbc0),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform2_b_0*/ mload(0xd60),\r\n                      /*intermediate_value/after_lin_transform2_b_0*/ mload(0xd60),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform2_b_0*/ mload(0xd60),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[10] + coefficients[11] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[10]*/ mload(0x520),\r\n                                       mulmod(/*coefficients[11]*/ mload(0x540),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step3_a: column4_row0 - after_lin_transform3_a_0 * after_lin_transform3_a_0 * after_lin_transform3_a_0.\r\n              let val := addmod(\r\n                /*column4_row0*/ mload(0xa80),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform3_a_0*/ mload(0xd80),\r\n                      /*intermediate_value/after_lin_transform3_a_0*/ mload(0xd80),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform3_a_0*/ mload(0xd80),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[12] + coefficients[13] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[12]*/ mload(0x560),\r\n                                       mulmod(/*coefficients[13]*/ mload(0x580),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step3_b: column14_row0 - after_lin_transform3_b_0 * after_lin_transform3_b_0 * after_lin_transform3_b_0.\r\n              let val := addmod(\r\n                /*column14_row0*/ mload(0xbe0),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform3_b_0*/ mload(0xda0),\r\n                      /*intermediate_value/after_lin_transform3_b_0*/ mload(0xda0),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform3_b_0*/ mload(0xda0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[14] + coefficients[15] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[14]*/ mload(0x5a0),\r\n                                       mulmod(/*coefficients[15]*/ mload(0x5c0),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step4_a: column5_row0 - after_lin_transform4_a_0 * after_lin_transform4_a_0 * after_lin_transform4_a_0.\r\n              let val := addmod(\r\n                /*column5_row0*/ mload(0xaa0),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform4_a_0*/ mload(0xdc0),\r\n                      /*intermediate_value/after_lin_transform4_a_0*/ mload(0xdc0),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform4_a_0*/ mload(0xdc0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[16] + coefficients[17] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[16]*/ mload(0x5e0),\r\n                                       mulmod(/*coefficients[17]*/ mload(0x600),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step4_b: column15_row0 - after_lin_transform4_b_0 * after_lin_transform4_b_0 * after_lin_transform4_b_0.\r\n              let val := addmod(\r\n                /*column15_row0*/ mload(0xc00),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform4_b_0*/ mload(0xde0),\r\n                      /*intermediate_value/after_lin_transform4_b_0*/ mload(0xde0),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform4_b_0*/ mload(0xde0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[18] + coefficients[19] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[18]*/ mload(0x620),\r\n                                       mulmod(/*coefficients[19]*/ mload(0x640),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step5_a: column6_row0 - after_lin_transform5_a_0 * after_lin_transform5_a_0 * after_lin_transform5_a_0.\r\n              let val := addmod(\r\n                /*column6_row0*/ mload(0xac0),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform5_a_0*/ mload(0xe00),\r\n                      /*intermediate_value/after_lin_transform5_a_0*/ mload(0xe00),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform5_a_0*/ mload(0xe00),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[20] + coefficients[21] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[20]*/ mload(0x660),\r\n                                       mulmod(/*coefficients[21]*/ mload(0x680),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step5_b: column16_row0 - after_lin_transform5_b_0 * after_lin_transform5_b_0 * after_lin_transform5_b_0.\r\n              let val := addmod(\r\n                /*column16_row0*/ mload(0xc20),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform5_b_0*/ mload(0xe20),\r\n                      /*intermediate_value/after_lin_transform5_b_0*/ mload(0xe20),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform5_b_0*/ mload(0xe20),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[22] + coefficients[23] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[22]*/ mload(0x6a0),\r\n                                       mulmod(/*coefficients[23]*/ mload(0x6c0),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step6_a: column7_row0 - after_lin_transform6_a_0 * after_lin_transform6_a_0 * after_lin_transform6_a_0.\r\n              let val := addmod(\r\n                /*column7_row0*/ mload(0xae0),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform6_a_0*/ mload(0xe40),\r\n                      /*intermediate_value/after_lin_transform6_a_0*/ mload(0xe40),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform6_a_0*/ mload(0xe40),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[24] + coefficients[25] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[24]*/ mload(0x6e0),\r\n                                       mulmod(/*coefficients[25]*/ mload(0x700),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step6_b: column17_row0 - after_lin_transform6_b_0 * after_lin_transform6_b_0 * after_lin_transform6_b_0.\r\n              let val := addmod(\r\n                /*column17_row0*/ mload(0xc40),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform6_b_0*/ mload(0xe60),\r\n                      /*intermediate_value/after_lin_transform6_b_0*/ mload(0xe60),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform6_b_0*/ mload(0xe60),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[26] + coefficients[27] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[26]*/ mload(0x720),\r\n                                       mulmod(/*coefficients[27]*/ mload(0x740),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step7_a: column8_row0 - after_lin_transform7_a_0 * after_lin_transform7_a_0 * after_lin_transform7_a_0.\r\n              let val := addmod(\r\n                /*column8_row0*/ mload(0xb00),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform7_a_0*/ mload(0xe80),\r\n                      /*intermediate_value/after_lin_transform7_a_0*/ mload(0xe80),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform7_a_0*/ mload(0xe80),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[28] + coefficients[29] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[28]*/ mload(0x760),\r\n                                       mulmod(/*coefficients[29]*/ mload(0x780),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step7_b: column18_row0 - after_lin_transform7_b_0 * after_lin_transform7_b_0 * after_lin_transform7_b_0.\r\n              let val := addmod(\r\n                /*column18_row0*/ mload(0xc60),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform7_b_0*/ mload(0xea0),\r\n                      /*intermediate_value/after_lin_transform7_b_0*/ mload(0xea0),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform7_b_0*/ mload(0xea0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[30] + coefficients[31] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[30]*/ mload(0x7a0),\r\n                                       mulmod(/*coefficients[31]*/ mload(0x7c0),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step8_a: column9_row0 - after_lin_transform8_a_0 * after_lin_transform8_a_0 * after_lin_transform8_a_0.\r\n              let val := addmod(\r\n                /*column9_row0*/ mload(0xb20),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform8_a_0*/ mload(0xec0),\r\n                      /*intermediate_value/after_lin_transform8_a_0*/ mload(0xec0),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform8_a_0*/ mload(0xec0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[32] + coefficients[33] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[32]*/ mload(0x7e0),\r\n                                       mulmod(/*coefficients[33]*/ mload(0x800),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step8_b: column19_row0 - after_lin_transform8_b_0 * after_lin_transform8_b_0 * after_lin_transform8_b_0.\r\n              let val := addmod(\r\n                /*column19_row0*/ mload(0xc80),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform8_b_0*/ mload(0xee0),\r\n                      /*intermediate_value/after_lin_transform8_b_0*/ mload(0xee0),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform8_b_0*/ mload(0xee0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[34] + coefficients[35] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[34]*/ mload(0x820),\r\n                                       mulmod(/*coefficients[35]*/ mload(0x840),\r\n                                              /*adjustments[0]*/mload(0x1060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step9_a: column0_row1 - after_lin_transform9_a_0 * after_lin_transform9_a_0 * after_lin_transform9_a_0.\r\n              let val := addmod(\r\n                /*column0_row1*/ mload(0xa00),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform9_a_0*/ mload(0xf00),\r\n                      /*intermediate_value/after_lin_transform9_a_0*/ mload(0xf00),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform9_a_0*/ mload(0xf00),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(trace_length - 1).\r\n              // val *= numerators[0].\r\n              val := mulmod(val, mload(0x1040), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[36] + coefficients[37] * adjustments[1]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[36]*/ mload(0x860),\r\n                                       mulmod(/*coefficients[37]*/ mload(0x880),\r\n                                              /*adjustments[1]*/mload(0x1080),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for step9_b: column10_row1 - after_lin_transform9_b_0 * after_lin_transform9_b_0 * after_lin_transform9_b_0.\r\n              let val := addmod(\r\n                /*column10_row1*/ mload(0xb60),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    mulmod(\r\n                      /*intermediate_value/after_lin_transform9_b_0*/ mload(0xf20),\r\n                      /*intermediate_value/after_lin_transform9_b_0*/ mload(0xf20),\r\n                      PRIME),\r\n                    /*intermediate_value/after_lin_transform9_b_0*/ mload(0xf20),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(trace_length - 1).\r\n              // val *= numerators[0].\r\n              val := mulmod(val, mload(0x1040), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0xf80), PRIME)\r\n\r\n              // res += val * (coefficients[38] + coefficients[39] * adjustments[1]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[38]*/ mload(0x8a0),\r\n                                       mulmod(/*coefficients[39]*/ mload(0x8c0),\r\n                                              /*adjustments[1]*/mload(0x1080),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for input_a: column0_row0 - input_value_a.\r\n              let val := addmod(/*column0_row0*/ mload(0x9e0), sub(PRIME, /*input_value_a*/ mload(0x320)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[1].\r\n              val := mulmod(val, mload(0xfa0), PRIME)\r\n\r\n              // res += val * (coefficients[40] + coefficients[41] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[40]*/ mload(0x8e0),\r\n                                       mulmod(/*coefficients[41]*/ mload(0x900),\r\n                                              /*adjustments[2]*/mload(0x10a0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for output_a: column9_row0 - output_value_a.\r\n              let val := addmod(/*column9_row0*/ mload(0xb20), sub(PRIME, /*output_value_a*/ mload(0x340)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(trace_length - 1).\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0xfc0), PRIME)\r\n\r\n              // res += val * (coefficients[42] + coefficients[43] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[42]*/ mload(0x920),\r\n                                       mulmod(/*coefficients[43]*/ mload(0x940),\r\n                                              /*adjustments[2]*/mload(0x10a0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for input_b: column10_row0 - input_value_b.\r\n              let val := addmod(/*column10_row0*/ mload(0xb40), sub(PRIME, /*input_value_b*/ mload(0x360)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[1].\r\n              val := mulmod(val, mload(0xfa0), PRIME)\r\n\r\n              // res += val * (coefficients[44] + coefficients[45] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[44]*/ mload(0x960),\r\n                                       mulmod(/*coefficients[45]*/ mload(0x980),\r\n                                              /*adjustments[2]*/mload(0x10a0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for output_b: column19_row0 - output_value_b.\r\n              let val := addmod(/*column19_row0*/ mload(0xc80), sub(PRIME, /*output_value_b*/ mload(0x380)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(trace_length - 1).\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0xfc0), PRIME)\r\n\r\n              // res += val * (coefficients[46] + coefficients[47] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[46]*/ mload(0x9a0),\r\n                                       mulmod(/*coefficients[47]*/ mload(0x9c0),\r\n                                              /*adjustments[2]*/mload(0x10a0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n            mstore(0, res)\r\n            return(0, 0x20)\r\n            }\r\n        }\r\n    }\r\n}\r\n// ---------- End of auto-generated code. ----------","ABI":"[{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}]","ContractName":"MimcConstraintPoly","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8aec54a06ead05b1a28587c0d1e6ef4dc2584a55a540ddd6034f83bd8f34fe04"}]}