{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4 .25;\r\n\r\n/**\r\n *      /$$$$$                       /$$           /$$$$$$$   /$$$$$$  /$$$$$$$\r\n *     |__  $$                      | $$          | $$__  $$ /$$__  $$| $$__  $$\r\n *        | $$ /$$   /$$  /$$$$$$$ /$$$$$$        | $$  \\ $$|__/  \\ $$| $$  \\ $$\r\n *        | $$| $$  | $$ /$$_____/|_  $$_/        | $$$$$$$/  /$$$$$$/| $$$$$$$/\r\n *   /$$  | $$| $$  | $$|  $$$$$$   | $$          | $$____/  /$$____/ | $$____/\r\n *  | $$  | $$| $$  | $$ \\____  $$  | $$ /$$      | $$      | $$      | $$\r\n *  |  $$$$$$/|  $$$$$$/ /$$$$$$$/  |  $$$$/      | $$      | $$$$$$$$| $$\r\n *   \\______/  \\______/ |_______/    \\___/        |__/      |________/|__/\r\n *  \"---....--'                                                 `---`  `---'           `---`\r\n * This product is protected under license.  Any unauthorized copy, modification, or use without\r\n * express written consent from the creators is prohibited.\r\n * Get touch with us justrunio2020@gmail.com\r\n * WARNING:  THIS PRODUCT IS HIGHLY ADDICTIVE.  IF YOU HAVE AN ADDICTIVE NATURE.  DO NOT PLAY.\r\n */\r\n\r\npragma solidity ^ 0.4 .24;\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, throws on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b)\r\n  internal\r\n  pure\r\n  returns(uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    require(c / a == b, \"SafeMath mul failed\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b)\r\n  internal\r\n  pure\r\n  returns(uint256) {\r\n    require(b <= a, \"SafeMath sub failed\");\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, throws on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b)\r\n  internal\r\n  pure\r\n  returns(uint256 c) {\r\n    c = a + b;\r\n    require(c >= a, \"SafeMath add failed\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev gives square root of given x.\r\n   */\r\n  function sqrt(uint256 x)\r\n  internal\r\n  pure\r\n  returns(uint256 y) {\r\n    uint256 z = ((add(x, 1)) / 2);\r\n    y = x;\r\n    while (z < y) {\r\n      y = z;\r\n      z = ((add((x / z), z)) / 2);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev gives square. multiplies x by x\r\n   */\r\n  function sq(uint256 x)\r\n  internal\r\n  pure\r\n  returns(uint256) {\r\n    return (mul(x, x));\r\n  }\r\n\r\n  /**\r\n   * @dev x to the power of y \r\n   */\r\n  function pwr(uint256 x, uint256 y)\r\n  internal\r\n  pure\r\n  returns(uint256) {\r\n    if (x == 0)\r\n      return (0);\r\n    else if (y == 0)\r\n      return (1);\r\n    else {\r\n      uint256 z = x;\r\n      for (uint256 i = 1; i < y; i++)\r\n        z = mul(z, x);\r\n      return (z);\r\n    }\r\n  }\r\n}\r\n\r\npragma solidity 0.4 .25;\r\n\r\nlibrary Data {\r\n\r\n  struct Player {\r\n\r\n    uint signInTime;\r\n\r\n    uint signInDay;\r\n\r\n    uint consume;\r\n\r\n    uint dynamicIncome;\r\n\r\n    uint totalEth;\r\n\r\n    uint sellIncome;\r\n\r\n    bool isNew;\r\n\r\n    bool isExist;\r\n\r\n    address superiorAddr;\r\n\r\n    address[] subordinateAddr;\r\n  }\r\n\r\n  struct PlayerData {\r\n\r\n    uint wallet;\r\n\r\n    uint runIncome;\r\n\r\n    uint withdrawnIncome;\r\n\r\n    uint totalPerformance;\r\n\r\n    uint settledLotteryIncome;\r\n  }\r\n\r\n  struct Run {\r\n\r\n    uint runPool;\r\n\r\n    uint endTime;\r\n\r\n    uint totalConsume;\r\n\r\n    uint record;\r\n\r\n    uint count;\r\n\r\n    uint num;\r\n\r\n    uint count2;\r\n\r\n    uint totalEth;\r\n\r\n    uint[] recordArr;\r\n\r\n    address lastAddr;\r\n\r\n    address[] lastAddrs;\r\n\r\n    mapping(address => uint) plyrMask;\r\n\r\n    mapping(address => uint) consumeMap;\r\n\r\n    mapping(address => uint) personalEth;\r\n  }\r\n\r\n  struct Scratch {\r\n\r\n    uint prizeNumber;\r\n\r\n    mapping(address => mapping(uint => uint)) roundIncome;\r\n\r\n    mapping(address => mapping(uint => uint[])) numberMap;\r\n\r\n    mapping(address => mapping(uint => uint[])) ethMap;\r\n\r\n    mapping(address => mapping(uint => uint[])) winMap;\r\n  }\r\n\r\n  struct Lottery {\r\n\r\n    uint lotteryPool;\r\n\r\n    uint unopenedBonus;\r\n\r\n    uint number;\r\n\r\n    uint time;\r\n\r\n    uint tokenNumber;\r\n\r\n    mapping(uint => uint[]) winNumber;\r\n\r\n    mapping(address => uint[]) lotteryMap;\r\n\r\n    mapping(uint => uint) awardAmount;\r\n  }\r\n\r\n  struct SaleQueue {\r\n\r\n    address addr;\r\n\r\n    uint tokenNumber;\r\n\r\n    uint remainingAmount;\r\n\r\n  }\r\n\r\n  struct PersonalSaleInfo {\r\n\r\n    uint tokenNumber;\r\n\r\n    uint saleNumber;\r\n  }\r\n\r\n  function rand(uint256 _length, uint256 num, uint256 salt) internal view returns(uint256) {\r\n    uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, num, salt)));\r\n    return random % _length;\r\n  }\r\n\r\n  function returnArray(uint len, uint range, uint number, uint salt) internal view returns(uint[]) {\r\n    uint[] memory numberArray = new uint[](len);\r\n    uint i = 0;\r\n    while (true) {\r\n      number = number + 9;\r\n      uint temp = rand(range, number, salt);\r\n      if (temp == 0) {\r\n        continue;\r\n      }\r\n      numberArray[i] = temp;\r\n      i++;\r\n      if (i == len) {\r\n        break;\r\n      }\r\n    }\r\n    return numberArray;\r\n  }\r\n\r\n  function generatePrizeNumber(uint256 seed, uint256 salt) internal view returns(uint) {\r\n    uint number = 0;\r\n    while (number < 10000) {\r\n      seed++;\r\n      number = rand(100000, seed, salt);\r\n    }\r\n    return number;\r\n  }\r\n}\r\n\r\n\r\ncontract ExRun {\r\n  address owner;\r\n  address foundationAddr;\r\n  address lotteryAddr;\r\n  address runAddr;\r\n  address[] tempAddr;\r\n  /** SaleIndex */\r\n  uint saleIndex = 0;\r\n  bool active = false;\r\n  TokenRun token;\r\n  JustRun run;\r\n  /** SaleQueue */\r\n  Data.SaleQueue[] saleQueue;\r\n  mapping(address => Data.Player) playerMap;\r\n  mapping(address => Data.PersonalSaleInfo) personalMap;\r\n\r\n  constructor(\r\n    address _ownerAddr,\r\n    address _foundationAddr,\r\n    address _tokenAddr\r\n  ) public {\r\n    owner = _ownerAddr;\r\n    foundationAddr = _foundationAddr;\r\n    token = TokenRun(_tokenAddr);\r\n  }\r\n\r\n  /** Send ETH to buy Token from ExRun contract\r\n   *   Send 0eth to sell all token to ExRun Contract\r\n   *   The first time you send 0eth to contract,you will register if not\r\n   *   and you get the AirDrop Run Token,and the second time you will sell all your saleable Run Token\r\n   */\r\n  function() public payable {\r\n    uint _eth = msg.value;\r\n    bool flag = isContract(msg.sender);\r\n    /** only accept ETH from normal address */\r\n    if (!flag) {\r\n      if (_eth > 0) {\r\n        /** Send ETH to buy Token from ExRun contract */\r\n        buyCore(msg.sender, address(0x0), _eth);\r\n      } else {\r\n        uint tokenValue = token.calcTokenReceived(3 * 10 ** 15);\r\n        /** The first time send 0eth */\r\n        if (playerMap[msg.sender].isExist == false) {\r\n          register(msg.sender, address(0x0));\r\n          token.getToken(tokenValue);\r\n          token.transfer(msg.sender, tokenValue);\r\n          playerMap[msg.sender].isNew = false;\r\n        } else if (playerMap[msg.sender].isNew == true) {\r\n          token.getToken(tokenValue);\r\n          token.transfer(msg.sender, tokenValue);\r\n          playerMap[msg.sender].isNew = false;\r\n        } else {\r\n          /** The second time send 0eth */\r\n          sellCore(msg.sender, 0);\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /** Active Contract with runAddr,lotteryAddr */\r\n  function activation(address _runAddr, address _lotteryAddr) external {\r\n    require(active == false, \"activated\");\r\n    require(owner == msg.sender, \"Insufficient permissions\");\r\n    runAddr = _runAddr;\r\n    lotteryAddr = _lotteryAddr;\r\n    run = JustRun(_runAddr);\r\n    active = true;\r\n  }\r\n\r\n  /** Verify that the address is a contract address */\r\n  function isContract(address _addr) private view returns(bool) {\r\n    uint size;\r\n    assembly {\r\n      size: = extcodesize(_addr)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  function register(address addr, address superiorAddr) private {\r\n    if (playerMap[addr].isExist == true) {\r\n      return;\r\n    }\r\n    Data.Player memory player;\r\n    player = Data.Player({\r\n      signInTime: 0,\r\n      signInDay: 0,\r\n      consume: 0,\r\n      dynamicIncome: 0,\r\n      totalEth: 0,\r\n      sellIncome: 0,\r\n      isNew: true,\r\n      isExist: true,\r\n      superiorAddr: superiorAddr,\r\n      subordinateAddr: tempAddr\r\n    });\r\n    if (superiorAddr == address(0x0) || playerMap[superiorAddr].isExist == false) {\r\n      player.superiorAddr = address(0x0);\r\n    } else {\r\n      playerMap[superiorAddr].subordinateAddr.push(addr);\r\n    }\r\n    playerMap[addr] = player;\r\n  }\r\n\r\n  /** Calculate sign-in to get tokens */\r\n  function calcSignInToken(uint day) private view returns(uint) {\r\n    uint number = token.calcTokenReceived(10 ** 15);\r\n    uint num = SafeMath.add(100, SafeMath.mul(4, day));\r\n    uint tokenValue = SafeMath.div(SafeMath.mul(number, num), 100);\r\n    return tokenValue;\r\n  }\r\n\r\n  /** Buy Token Core Logic */\r\n  function buyCore(address addr, address superiorAddr, uint _eth) private {\r\n    require(_eth >= 10 ** 16, \"At least 0.01eth per purchase\");\r\n    register(addr, superiorAddr);\r\n    uint number = token.calcTokenReceived(_eth);\r\n    playerMap[addr].totalEth = SafeMath.add(playerMap[addr].totalEth, _eth);\r\n    uint tokenNumber;\r\n    uint queueNumber;\r\n    (tokenNumber, queueNumber) = getTokenSaleNumber();\r\n    if (number > SafeMath.add(tokenNumber, queueNumber)) {\r\n      purchaseQueueCore(queueNumber);\r\n      contractPurchaseCore(tokenNumber, 0, true);\r\n      token.transfer(addr, SafeMath.add(tokenNumber, queueNumber));\r\n      uint m = token.calcTokenValue(SafeMath.sub(number, SafeMath.add(tokenNumber, queueNumber)));\r\n      addr.transfer(m);\r\n      runAddr.transfer(SafeMath.sub(_eth, m));\r\n      return;\r\n    } else if (SafeMath.div(SafeMath.mul(number, 70), 100) > tokenNumber) {\r\n      purchaseQueueCore(SafeMath.sub(number, tokenNumber));\r\n      contractPurchaseCore(tokenNumber, 0, true);\r\n      token.transfer(addr, number);\r\n      runAddr.transfer(_eth);\r\n      return;\r\n    } else if (SafeMath.div(SafeMath.mul(number, 30), 100) > queueNumber) {\r\n      purchaseQueueCore(queueNumber);\r\n      uint n = SafeMath.sub(SafeMath.div(SafeMath.mul(number, 30), 100), queueNumber);\r\n      contractPurchaseCore(SafeMath.sub(number, queueNumber), n, false);\r\n      token.transfer(addr, number);\r\n    } else {\r\n      uint value = SafeMath.div(SafeMath.mul(number, 30), 100);\r\n      purchaseQueueCore(value);\r\n      contractPurchaseCore(SafeMath.sub(number, value), 0, false);\r\n      token.transfer(addr, number);\r\n    }\r\n    uint pct = dividendDynamicIncome(addr, _eth);\r\n    run.tokenDividend(_eth, pct);\r\n    uint foundationNumber = SafeMath.div(SafeMath.mul(_eth, 20), 100);\r\n    foundationAddr.transfer(foundationNumber);\r\n    runAddr.transfer(SafeMath.sub(_eth, foundationNumber));\r\n  }\r\n\r\n  /** Dynamic Income Logic */\r\n  function dividendDynamicIncome(address addr, uint _eth) private returns(uint) {\r\n    address playerAddr = addr;\r\n    uint proportion = 9;\r\n    uint pct = 17;\r\n    for (uint i = 0; i < 3; i++) {\r\n      if (playerMap[playerAddr].superiorAddr == address(0x0)) {\r\n        break;\r\n      }\r\n      uint income = SafeMath.div(SafeMath.mul(_eth, proportion), 100);\r\n      uint number = SafeMath.div(playerMap[playerMap[playerAddr].superiorAddr].totalEth * 10 ** 8, playerMap[addr].totalEth);\r\n      if (number < 10000000) {\r\n        uint temp = income;\r\n        income = SafeMath.div(SafeMath.mul(number, income), 10 ** 7);\r\n        run.updateWallet(address(0x0), SafeMath.sub(temp, income));\r\n      }\r\n      run.updateWallet(playerMap[playerAddr].superiorAddr, income);\r\n      playerMap[playerMap[playerAddr].superiorAddr].dynamicIncome = SafeMath.add(playerMap[playerMap[playerAddr].superiorAddr]\r\n        .dynamicIncome, income);\r\n      pct = SafeMath.sub(pct, proportion);\r\n      playerAddr = playerMap[playerAddr].superiorAddr;\r\n      if (i == 0) {\r\n        proportion = 6;\r\n      }\r\n      if (i == 1) {\r\n        proportion = 2;\r\n      }\r\n    }\r\n    return pct;\r\n  }\r\n\r\n  /** buy token from contract */\r\n  function contractPurchaseCore(uint tokenNumber, uint number, bool flag) private {\r\n    if (tokenNumber == 0) {\r\n      return;\r\n    }\r\n    if (flag) {\r\n      uint money = token.calcTokenValue(tokenNumber);\r\n      run.updateWallet(address(0x0), money);\r\n    } else {\r\n      if (number > 0) {\r\n        run.updateWallet(address(0x0), token.calcTokenValue(number));\r\n      }\r\n    }\r\n    token.getToken(tokenNumber);\r\n  }\r\n\r\n  function getTokenSaleNumber() private view returns(uint, uint) {\r\n    uint surplusSupply = token.surplusSupply();\r\n    uint index = saleIndex;\r\n    uint count = 0;\r\n    uint number = 0;\r\n    while (index < saleQueue.length) {\r\n      number = SafeMath.add(number, saleQueue[index].remainingAmount);\r\n      index++;\r\n      count++;\r\n      if (count == 10) {\r\n        break;\r\n      }\r\n    }\r\n    return (surplusSupply, number);\r\n  }\r\n\r\n  /** buy token from Queue */\r\n  function purchaseQueueCore(uint value) private {\r\n    if (value == 0) {\r\n      return;\r\n    }\r\n    uint quantity = value;\r\n    uint _eth = token.calcTokenValue(value);\r\n    if (saleQueue.length > 0 && saleIndex < saleQueue.length) {\r\n      for (int index = 0; index < 10; index++) {\r\n        uint count = 0;\r\n        if (quantity <= saleQueue[saleIndex].remainingAmount) {\r\n          saleQueue[saleIndex].remainingAmount = SafeMath.sub(saleQueue[saleIndex].remainingAmount, quantity);\r\n          personalMap[saleQueue[saleIndex].addr].saleNumber = SafeMath.add(personalMap[saleQueue[saleIndex].addr].saleNumber,\r\n            quantity);\r\n          count = quantity;\r\n          quantity = 0;\r\n        } else {\r\n          quantity = SafeMath.sub(quantity, saleQueue[saleIndex].remainingAmount);\r\n          personalMap[saleQueue[saleIndex].addr].saleNumber = SafeMath.add(personalMap[saleQueue[saleIndex].addr].saleNumber,\r\n            saleQueue[saleIndex].remainingAmount);\r\n          count = saleQueue[saleIndex].remainingAmount;\r\n          delete saleQueue[saleIndex].remainingAmount;\r\n        }\r\n\r\n        uint pct = SafeMath.div(SafeMath.mul(count, 10 ** 8), value);\r\n        uint money = SafeMath.div(SafeMath.mul(pct, _eth), 10 ** 8);\r\n        playerMap[saleQueue[saleIndex].addr].sellIncome = SafeMath.add(playerMap[saleQueue[saleIndex].addr].sellIncome,\r\n          money);\r\n        run.updateWallet(saleQueue[saleIndex].addr, money);\r\n        if (saleQueue[saleIndex].remainingAmount == 0) {\r\n          delete saleQueue[saleIndex];\r\n          saleIndex++;\r\n        }\r\n        if (quantity == 0 || saleIndex >= saleQueue.length) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Sell core logic */\r\n  function sellCore(address addr, uint value) private {\r\n    uint balance = token.balanceOf(addr);\r\n    require(value <= balance, \"insufficient token\");\r\n    uint number = this.getNumberOfSellableTokens(addr);\r\n    if (value == 0) {\r\n      value = number;\r\n      if (value > balance) {\r\n        value = balance;\r\n      }\r\n    }\r\n    require(value <= number && value > 0, \"Insufficient number of tokens available for sale\");\r\n    uint price = token.sellingPrice();\r\n    require(SafeMath.mul(price, value) >= 10 ** 16, \"Each sale of at least 0.01eth token\");\r\n    Data.SaleQueue memory s = Data.SaleQueue(addr, value, value);\r\n    personalMap[addr].tokenNumber = SafeMath.add(personalMap[addr].tokenNumber, value);\r\n    saleQueue.push(s);\r\n    token.advancedTransfer(addr, value);\r\n  }\r\n\r\n  function getPlayerSaleInfo(address addr) external view returns(uint, uint) {\r\n    require(owner == msg.sender || addr == msg.sender, \"Insufficient permissions\");\r\n    Data.PersonalSaleInfo storage info = personalMap[addr];\r\n    return (info.tokenNumber, info.saleNumber);\r\n  }\r\n\r\n  function getPlayerInfo(address addr) external view returns(uint, uint, uint, bool, bool, address[]) {\r\n    require(owner == msg.sender || addr == msg.sender, \"Insufficient permissions\");\r\n    Data.Player storage player = playerMap[addr];\r\n    return (player.signInTime, player.signInDay, player.consume, player.isNew, player.isExist, player.subordinateAddr);\r\n  }\r\n\r\n  /** the number player can get tokens when they sign in next time */\r\n  function nextCalcSignInToken() external view returns(uint) {\r\n    Data.Player storage player = playerMap[msg.sender];\r\n    return calcSignInToken(player.signInDay);\r\n  }\r\n\r\n  function sellToken(uint value) external {\r\n    sellCore(msg.sender, value);\r\n  }\r\n\r\n  /** Player sign in */\r\n  function signIn() external {\r\n    require(isContract(msg.sender) == false, \"Not a normal user\");\r\n    Data.Player storage player = playerMap[msg.sender];\r\n    require(player.isExist == true, \"unregistered\");\r\n    uint _nowTime = now;\r\n    uint day = 24 * 60 * 60;\r\n    uint hour = 12 * 60 * 60;\r\n    require(_nowTime >= SafeMath.add(player.signInTime, hour) || player.signInTime == 0, \"Checked in\");\r\n    if (_nowTime - player.signInTime >= 2 * day) {\r\n      player.signInDay = 0;\r\n    }\r\n    uint tokenValue = calcSignInToken(player.signInDay);\r\n    if (player.signInDay < 100) {\r\n      player.signInDay = player.signInDay + 1;\r\n    }\r\n    token.getToken(tokenValue);\r\n    token.transfer(msg.sender, tokenValue);\r\n    player.signInTime = _nowTime;\r\n  }\r\n\r\n  /** Players buy tokens with superiorAddr */\r\n  function buyToken(address superiorAddr) external payable {\r\n    uint _eth = msg.value;\r\n    buyCore(msg.sender, superiorAddr, _eth);\r\n  }\r\n\r\n  function getSaleQueue() external view returns(address[], uint[], uint[]) {\r\n    require(msg.sender == owner, \"Insufficient permissions\");\r\n    address[] memory addrs = new address[](saleQueue.length);\r\n    uint[] memory tokenNumbers = new uint[](saleQueue.length);\r\n    uint[] memory remainingAmounts = new uint[](saleQueue.length);\r\n    for (uint i = 0; i < saleQueue.length; i++) {\r\n      addrs[i] = saleQueue[i].addr;\r\n      tokenNumbers[i] = saleQueue[i].tokenNumber;\r\n      remainingAmounts[i] = saleQueue[i].remainingAmount;\r\n    }\r\n    return (addrs, tokenNumbers, remainingAmounts);\r\n  }\r\n\r\n  /** get sellable token number */\r\n  function getNumberOfSellableTokens(address addr) external view returns(uint) {\r\n    return SafeMath.sub(SafeMath.mul(playerMap[addr].consume, 3), personalMap[addr].tokenNumber);\r\n  }\r\n\r\n  /** If can buy token */\r\n  function judgeBuyToken() external view returns(bool) {\r\n    uint surplusSupply = token.surplusSupply();\r\n    if (surplusSupply == 0) {\r\n      return saleIndex < saleQueue.length;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function getIncome(address addr) external view returns(uint, uint) {\r\n    require(runAddr == msg.sender || owner == msg.sender || addr == msg.sender, \"Insufficient permissions\");\r\n    return (playerMap[addr].dynamicIncome, playerMap[addr].sellIncome);\r\n  }\r\n\r\n  /** Register API for JustRun and LotteryRun */\r\n  function externalRegister(address addr, address superiorAddr) external {\r\n    require(msg.sender == runAddr || msg.sender == lotteryAddr, \"Insufficient permissions\");\r\n    register(addr, superiorAddr);\r\n  }\r\n\r\n  /** get your superiorAddr */\r\n  function getSuperiorAddr(address addr) external view returns(address) {\r\n    require(runAddr == msg.sender || owner == msg.sender || addr == msg.sender, \"Insufficient permissions\");\r\n    return playerMap[addr].superiorAddr;\r\n  }\r\n\r\n  /**API for JustRun*/\r\n  function updatePlayerEth(address addr, uint _eth) external {\r\n    require(runAddr == msg.sender, \"Insufficient permissions\");\r\n    playerMap[addr].totalEth = SafeMath.add(playerMap[addr].totalEth, _eth);\r\n  }\r\n\r\n  /**API for JustRun*/\r\n  function updateTokenConsume(address addr, uint value) external {\r\n    require(runAddr == msg.sender, \"Insufficient permissions\");\r\n    playerMap[addr].consume = SafeMath.add(playerMap[addr].consume, value);\r\n  }\r\n\r\n  /**API for JustRun*/\r\n  function buyTokenByRun(address addr, uint _eth) external {\r\n    require(runAddr == msg.sender, \"Insufficient permissions\");\r\n    uint value = token.calcTokenReceived(_eth);\r\n    uint tokenNumber;\r\n    uint queueNumber;\r\n    (tokenNumber, queueNumber) = getTokenSaleNumber();\r\n    if (value > queueNumber && tokenNumber > SafeMath.sub(value, queueNumber)) {\r\n      purchaseQueueCore(queueNumber);\r\n      contractPurchaseCore(SafeMath.sub(value, queueNumber), 0, true);\r\n      token.transfer(addr, value);\r\n    } else if (value > queueNumber) {\r\n      uint money = token.calcTokenValue(SafeMath.sub(value, queueNumber));\r\n      run.updateWallet(address(0x0), money);\r\n      purchaseQueueCore(queueNumber);\r\n      token.transfer(addr, queueNumber);\r\n    } else {\r\n      purchaseQueueCore(queueNumber);\r\n      token.transfer(addr, queueNumber);\r\n    }\r\n  }\r\n\r\n  /**API for JustRun*/\r\n  function updateDynamicIncome(address addr, uint _eth) external {\r\n    require(runAddr == msg.sender, \"Insufficient permissions\");\r\n    playerMap[addr].dynamicIncome = SafeMath.add(playerMap[addr].dynamicIncome, _eth);\r\n  }\r\n\r\n  /**API for JustRun*/\r\n  function getPlayerTotalEth(address addr) external view returns(uint) {\r\n    require(runAddr == msg.sender || owner == msg.sender || addr == msg.sender, \"Insufficient permissions\");\r\n    return playerMap[addr].totalEth;\r\n  }\r\n\r\n  function aaa(uint256 a, uint256 b) external pure returns (uint256) {\r\n      return a + b;\r\n  }\r\n\r\n  function bbb(uint256 a, uint256 b) external pure returns (uint256) {\r\n      return a - b;\r\n  }\r\n\r\n}\r\n\r\ncontract JustRun {\r\n  function tokenDividend(uint _eth, uint pct) external;\r\n\r\n  function updateWallet(address addr, uint _eth) external;\r\n}\r\n\r\ncontract TokenRun {\r\n  function calcTokenReceived(uint _eth) external view returns(uint);\r\n\r\n  function getToken(uint value) external;\r\n\r\n  function transfer(address to, uint value) public;\r\n\r\n  function advancedTransfer(address addr, uint value) external;\r\n\r\n  function sellingPrice() public view returns(uint);\r\n\r\n  function surplusSupply() public view returns(uint);\r\n\r\n  function calcTokenValue(uint tokenNumber) external view returns(uint);\r\n\r\n  function balanceOf(address addr) public view returns(uint);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateTokenConsume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"name\":\"externalRegister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"sellToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextCalcSignInToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_runAddr\",\"type\":\"address\"},{\"name\":\"_lotteryAddr\",\"type\":\"address\"}],\"name\":\"activation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"aaa\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"judgeBuyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaleQueue\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superiorAddr\",\"type\":\"address\"}],\"name\":\"buyToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayerSaleInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getSuperiorAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayerTotalEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"signIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"bbb\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"updatePlayerEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getNumberOfSellableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"updateDynamicIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"buyTokenByRun\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ownerAddr\",\"type\":\"address\"},{\"name\":\"_foundationAddr\",\"type\":\"address\"},{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ExRun","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000119eb8e686423e56b7cfc6f211c8cd4a9f71e3cc000000000000000000000000725307b2d0e1e51917820ff299d2fb355e6d17e400000000000000000000000079dd747cb3d8f9c45805813d4b52e398b258c7d0","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e7e89294b596591a5b8a3ae22cb743b3ea1ac957ba28e5ebed3bee4193fb7e30"}]}