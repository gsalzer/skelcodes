{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary StableMath {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @notice Token Ratios are used when converting between units of bAsset, mAsset and MTA\r\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\r\n     * @dev bAsset ratio unit for use in exact calculations,\r\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\r\n     */\r\n    uint256 private constant RATIO_SCALE = 1e8;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides an interface to the ratio unit\r\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\r\n     */\r\n    function getRatioScale() internal pure returns (uint256) {\r\n        return RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x.mul(FULL_SCALE);\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(uint256 x, uint256 y, uint256 scale)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        uint256 z = x.mul(y);\r\n        // return 9e38 / 1e18 = 9e18\r\n        return z.div(scale);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x.mul(y);\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil.div(FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        uint256 z = x.mul(FULL_SCALE);\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return z.div(y);\r\n    }\r\n\r\n\r\n    /***************************************\r\n                  RATIO FUNCS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the ratio scale\r\n     */\r\n    function mulRatioTruncate(uint256 x, uint256 ratio)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, rounding up the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              ratio scale, rounded up to the closest base unit.\r\n     */\r\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. How much mAsset should I burn for this bAsset (x)?\r\n        // 1e18 * 1e8 = 1e26\r\n        uint256 scaled = x.mul(ratio);\r\n        // 1e26 + 9.99e7 = 100..00.999e8\r\n        uint256 ceil = scaled.add(RATIO_SCALE.sub(1));\r\n        // return 100..00.999e8 / 1e8 = 1e18\r\n        return ceil.div(RATIO_SCALE);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\r\n     *      i.e. How much bAsset is this mAsset worth?\r\n     * @param x     Left hand operand in division\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divRatioPrecisely(uint256 x, uint256 ratio)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        // e.g. 1e14 * 1e8 = 1e22\r\n        uint256 y = x.mul(RATIO_SCALE);\r\n        // return 1e22 / 1e12 = 1e10\r\n        return y.div(ratio);\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\ninterface MassetStructs {\r\n\r\n    /** @dev Stores high level basket info */\r\n    struct Basket {\r\n\r\n        /** @dev Array of Bassets currently active */\r\n        Basset[] bassets;\r\n\r\n        /** @dev Max number of bAssets that can be present in any Basket */\r\n        uint8 maxBassets;\r\n\r\n        /** @dev Some bAsset is undergoing re-collateralisation */\r\n        bool undergoingRecol;\r\n\r\n        /**\r\n         * @dev In the event that we do not raise enough funds from the auctioning of a failed Basset,\r\n         * The Basket is deemed as failed, and is undercollateralised to a certain degree.\r\n         * The collateralisation ratio is used to calc Masset burn rate.\r\n         */\r\n        bool failed;\r\n        uint256 collateralisationRatio;\r\n\r\n    }\r\n\r\n    /** @dev Stores bAsset info. The struct takes 5 storage slots per Basset */\r\n    struct Basset {\r\n\r\n        /** @dev Address of the bAsset */\r\n        address addr;\r\n\r\n        /** @dev Status of the basset,  */\r\n        BassetStatus status; // takes uint8 datatype (1 byte) in storage\r\n\r\n        /** @dev An ERC20 can charge transfer fee, for example USDT, DGX tokens. */\r\n        bool isTransferFeeCharged; // takes a byte in storage\r\n\r\n        /**\r\n         * @dev 1 Basset * ratio / ratioScale == x Masset (relative value)\r\n         *      If ratio == 10e8 then 1 bAsset = 10 mAssets\r\n         *      A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\r\n         */\r\n        uint256 ratio;\r\n\r\n        /** @dev Target weights of the Basset (100% == 1e18) */\r\n        uint256 maxWeight;\r\n\r\n        /** @dev Amount of the Basset that is held in Collateral */\r\n        uint256 vaultBalance;\r\n\r\n    }\r\n\r\n    /** @dev Status of the Basset - has it broken its peg? */\r\n    enum BassetStatus {\r\n        Default,\r\n        Normal,\r\n        BrokenBelowPeg,\r\n        BrokenAbovePeg,\r\n        Blacklisted,\r\n        Liquidating,\r\n        Liquidated,\r\n        Failed\r\n    }\r\n\r\n    /** @dev Internal details on Basset */\r\n    struct BassetDetails {\r\n        Basset bAsset;\r\n        address integrator;\r\n        uint8 index;\r\n    }\r\n\r\n    /** @dev All details needed to Forge with multiple bAssets */\r\n    struct ForgePropsMulti {\r\n        bool isValid; // Flag to signify that forge bAssets have passed validity check\r\n        Basset[] bAssets;\r\n        address[] integrators;\r\n        uint8[] indexes;\r\n    }\r\n\r\n    /** @dev All details needed for proportionate Redemption */\r\n    struct RedeemPropsMulti {\r\n        uint256 colRatio;\r\n        Basset[] bAssets;\r\n        address[] integrators;\r\n        uint8[] indexes;\r\n    }\r\n}\r\n\r\ncontract IBasketManager is MassetStructs {\r\n    function paused() external view returns (bool);\r\n    function getBasket() external view returns (Basket memory b);\r\n    function getBasset(address _token) external view\r\n        returns (Basset memory bAsset);\r\n}\r\n\r\ncontract IForgeValidator is MassetStructs {\r\n    function validateRedemption(\r\n        bool basketIsFailed,\r\n        uint256 _totalVault,\r\n        Basset[] calldata _allBassets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _bassetQuantities) external pure returns (bool, string memory, bool);\r\n}\r\n\r\ninterface IMasset {\r\n    function getBasketManager() external view returns(address);\r\n    function forgeValidator() external view returns(address);\r\n    function totalSupply() external view returns(uint256);\r\n    function swapFee() external view returns(uint256);\r\n}\r\n\r\n/**\r\n * @title   MassetRedemptionValidator\r\n * @author  Stability Labs Pty. Ltd.\r\n * @notice  Returns the validity and output of a given redemption\r\n * @dev     VERSION: 1.0\r\n *          DATE:    2020-06-18\r\n */\r\ncontract MassetRedemptionValidator is MassetStructs {\r\n\r\n    using StableMath for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    function getRedeemValidity(\r\n        address _mAsset,\r\n        uint256 _mAssetQuantity,\r\n        address _outputBasset\r\n    )\r\n        public\r\n        view\r\n        returns (bool, string memory, uint256 output)\r\n    {\r\n        // Convert the `mAssetQuantity` (input) into bAsset units\r\n        IBasketManager basketManager = IBasketManager(IMasset(_mAsset).getBasketManager());\r\n        Basset memory bAsset = basketManager.getBasset(_outputBasset);\r\n        uint256 bAssetOutput = _mAssetQuantity.divRatioPrecisely(bAsset.ratio);\r\n\r\n        // Prepare params for internal validity\r\n        address[] memory bAssets = new address[](1);\r\n        uint256[] memory quantities = new uint256[](1);\r\n        bAssets[0] = _outputBasset;\r\n        quantities[0] = bAssetOutput;\r\n\r\n        return _getRedeemValidity(_mAsset, bAssets, quantities);\r\n    }\r\n\r\n    function _getRedeemValidity(\r\n        address _mAsset,\r\n        address[] memory _bAssets,\r\n        uint256[] memory _bAssetQuantities\r\n    )\r\n        internal\r\n        view\r\n        returns (bool, string memory, uint256 output)\r\n    {\r\n        uint256 bAssetCount = _bAssetQuantities.length;\r\n        require(bAssetCount == 1 && bAssetCount == _bAssets.length, \"Input array mismatch\");\r\n\r\n        IMasset mAsset = IMasset(_mAsset);\r\n        IBasketManager basketManager = IBasketManager(mAsset.getBasketManager());\r\n\r\n        Basket memory basket = basketManager.getBasket();\r\n\r\n        if(basket.undergoingRecol || basketManager.paused()){\r\n            return (false, \"Invalid basket state\", 0);\r\n        }\r\n\r\n        (bool redemptionValid, string memory reason, bool applyFee) =\r\n            _validateRedeem(mAsset, _bAssetQuantities, _bAssets[0], basket.failed, mAsset.totalSupply(),  basket.bassets);\r\n        if(!redemptionValid){\r\n            return (false, reason, 0);\r\n        }\r\n        uint256 fee = applyFee ? mAsset.swapFee() : 0;\r\n        uint256 feeAmount = _bAssetQuantities[0].mulTruncate(fee);\r\n        uint256 outputMinusFee = _bAssetQuantities[0].sub(feeAmount);\r\n        return (true, \"\", outputMinusFee);\r\n    }\r\n\r\n    function _validateRedeem(\r\n        IMasset mAsset,\r\n        uint256[] memory quantities,\r\n        address bAsset,\r\n        bool failed,\r\n        uint256 supply,\r\n        Basset[] memory allBassets\r\n    )\r\n        internal\r\n        view\r\n        returns (bool, string memory, bool)\r\n    {\r\n        IForgeValidator forgeValidator = IForgeValidator(mAsset.forgeValidator());\r\n        uint8[] memory bAssetIndexes = new uint8[](1);\r\n        for(uint8 i = 0; i < uint8(allBassets.length); i ++) {\r\n            if(allBassets[i].addr == bAsset) {\r\n                bAssetIndexes[0] = i;\r\n                break;\r\n            }\r\n        }\r\n        return forgeValidator.validateRedemption(failed, supply, allBassets, bAssetIndexes, quantities);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_mAssetQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_outputBasset\",\"type\":\"address\"}],\"name\":\"getRedeemValidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MassetRedemptionValidator","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://388525c5bfc1ec0cf6bf165ad3b3ed2b052ad142729df5786980b45dc86db6cb"}]}