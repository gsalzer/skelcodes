{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function initialize(address, address) external;\n}\n\n// File: contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeToSetter(address) external;\n}\n\n// File: contracts/uniswapv2/interfaces/ICrosschainPair.sol\n\npragma solidity >=0.5.0;\n\ninterface ICrosschainPair {\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function initialize(address, address) external;\n}\n\n// File: contracts/uniswapv2/interfaces/ICrosschainFactory.sol\n\npragma solidity >=0.5.0;\n\ninterface ICrosschainFactory {\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function migrator() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function getCfxReceiveAddr(address pair) external view returns (address cfxReceiveAddr);\n    function WETH() external view returns (address);\n\n    function setMigrator(address) external;\n}\n\n// File: contracts/Migrator.sol\n\npragma solidity 0.6.12;\n\n\n\n\n\n\ncontract Migrator {\n    address public master;\n    ICrosschainFactory public factory;\n    uint256 public notBeforeBlock;\n    uint256 public desiredLiquidity = uint256(-1);\n    mapping(address => bool) public originalFactories;\n    address public operatorAddr;\n\n    constructor(\n        address _master,\n        address[] memory _oldFactories,\n        ICrosschainFactory _factory,\n        uint256 _notBeforeBlock\n    ) public {\n        master = _master;\n        factory = _factory;\n        notBeforeBlock = _notBeforeBlock;\n\n        operatorAddr = msg.sender;\n        uint range = _oldFactories.length;\n        require(range > 0, \"Migrate: oldFactory Empty\");\n\n        for (uint i = 0; i < range; i++) {\n            originalFactories[_oldFactories[i]] = true;\n        }\n    }\n\n    function migrate(IUniswapV2Pair orig) public returns (ICrosschainPair) {\n        require(msg.sender == master, \"not from master access\");\n        require(block.number >= notBeforeBlock, \"too early to migrate\");\n        require(originalFactories[orig.factory()], \"not from old factory\");\n        address token0 = orig.token0();\n        address token1 = orig.token1();\n        ICrosschainPair pair = ICrosschainPair(factory.getPair(token0, token1));\n        if (pair == ICrosschainPair(address(0))) {\n            pair = ICrosschainPair(factory.createPair(token0, token1));\n        }\n\n        uint256 lp = orig.balanceOf(msg.sender);\n        if (lp == 0) return pair;\n        desiredLiquidity = lp;\n        orig.transferFrom(msg.sender, address(orig), lp);\n        orig.burn(address(pair));\n        pair.mint(msg.sender);\n        desiredLiquidity = uint256(-1);\n\n        return pair;\n    }\n\n    function setOperatorAddr(address _operatorAddr) external {\n        require(msg.sender == operatorAddr, 'MoonSwap: FORBIDDEN');\n        operatorAddr = _operatorAddr;\n    }\n\n    // when config update, operator immediately change Factory\n    function setOriginalFactory(address _factory, bool _status) external {\n        require(msg.sender == operatorAddr, 'MoonSwap: FORBIDDEN');\n        originalFactories[_factory] = _status;\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_master\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_oldFactories\",\"type\":\"address[]\"},{\"internalType\":\"contract ICrosschainFactory\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_notBeforeBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"desiredLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract ICrosschainFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"orig\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[{\"internalType\":\"contract ICrosschainPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notBeforeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"originalFactories\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operatorAddr\",\"type\":\"address\"}],\"name\":\"setOperatorAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setOriginalFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Migrator","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b60c12d2a4069d339f49943fc45df6785b43609600000000000000000000000000000000000000000000000000000000000000800000000000000000000000009ae110d8d733575a3b1e306f1146a5ff8fa173f40000000000000000000000000000000000000000000000000000000000a6ab7400000000000000000000000000000000000000000000000000000000000000020000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}