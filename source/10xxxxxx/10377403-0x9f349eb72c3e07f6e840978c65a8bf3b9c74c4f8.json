{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/sol6/IERC20.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function decimals() external view returns (uint8 digits);\r\n\r\n    function totalSupply() external view returns (uint256 supply);\r\n}\r\n\r\n\r\n// to support backward compatible contract name -- so function signature remains same\r\nabstract contract ERC20 is IERC20 {\r\n\r\n}\r\n\r\n// File: contracts/sol6/utils/zeppelin/ReentrancyGuard.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/Dao/IEpochUtils.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface IEpochUtils {\r\n    function epochPeriodInSeconds() external view returns (uint256);\r\n\r\n    function firstEpochStartTimestamp() external view returns (uint256);\r\n\r\n    function getCurrentEpochNumber() external view returns (uint256);\r\n\r\n    function getEpochNumber(uint256 timestamp) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/Dao/IKyberStaking.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberStaking is IEpochUtils {\r\n    event Delegated(\r\n        address indexed staker,\r\n        address indexed representative,\r\n        uint256 indexed epoch,\r\n        bool isDelegated\r\n    );\r\n    event Deposited(uint256 curEpoch, address indexed staker, uint256 amount);\r\n    event Withdraw(uint256 indexed curEpoch, address indexed staker, uint256 amount);\r\n\r\n    function initAndReturnStakerDataForCurrentEpoch(address staker)\r\n        external\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        );\r\n\r\n    function deposit(uint256 amount) external;\r\n\r\n    function delegate(address dAddr) external;\r\n\r\n    function withdraw(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice return combine data (stake, delegatedStake, representative) of a staker\r\n     * @dev allow to get staker data up to current epoch + 1\r\n     */\r\n    function getStakerData(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        );\r\n\r\n    function getLatestStakerData(address staker)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        );\r\n\r\n    /**\r\n     * @notice return raw data of a staker for an epoch\r\n     *         WARN: should be used only for initialized data\r\n     *          if data has not been initialized, it will return all 0\r\n     *          pool master shouldn't use this function to compute/distribute rewards of pool members\r\n     */\r\n    function getStakerRawData(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        );\r\n}\r\n\r\n// File: contracts/sol6/IKyberDao.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberDao is IEpochUtils {\r\n    event Voted(address indexed staker, uint indexed epoch, uint indexed campaignID, uint option);\r\n\r\n    function getLatestNetworkFeeDataWithCache()\r\n        external\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\r\n\r\n    function getLatestBRRDataWithCache()\r\n        external\r\n        returns (\r\n            uint256 burnInBps,\r\n            uint256 rewardInBps,\r\n            uint256 rebateInBps,\r\n            uint256 epoch,\r\n            uint256 expiryTimestamp\r\n        );\r\n\r\n    function handleWithdrawal(address staker, uint256 penaltyAmount) external;\r\n\r\n    function vote(uint256 campaignID, uint256 option) external;\r\n\r\n    function getLatestNetworkFeeData()\r\n        external\r\n        view\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\r\n\r\n    function shouldBurnRewardForEpoch(uint256 epoch) external view returns (bool);\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for a past epoch only\r\n     *       fee handler should call this function when a staker wants to claim reward\r\n     *       return 0 if staker has no votes or stakes\r\n     */\r\n    function getPastEpochRewardPercentageInPrecision(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for the current epoch\r\n     *       reward percentage is not finalized until the current epoch is ended\r\n     */\r\n    function getCurrentEpochRewardPercentageInPrecision(address staker)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/utils/zeppelin/SafeMath.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/Dao/EpochUtils.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ncontract EpochUtils is IEpochUtils {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public override epochPeriodInSeconds;\r\n    uint256 public override firstEpochStartTimestamp;\r\n\r\n    function getCurrentEpochNumber() public view override returns (uint256) {\r\n        return getEpochNumber(now);\r\n    }\r\n\r\n    function getEpochNumber(uint256 timestamp) public view override returns (uint256) {\r\n        if (timestamp < firstEpochStartTimestamp || epochPeriodInSeconds == 0) {\r\n            return 0;\r\n        }\r\n        // ((timestamp - firstEpochStartTimestamp) / epochPeriodInSeconds) + 1;\r\n        return ((timestamp.sub(firstEpochStartTimestamp)).div(epochPeriodInSeconds)).add(1);\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/Dao/KyberStaking.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice   This contract is using SafeMath for uint, which is inherited from EpochUtils\r\n *           Some events are moved to interface, easier for public uses\r\n *           Staking contract will be deployed by KyberDao's contract\r\n */\r\ncontract KyberStaking is IKyberStaking, EpochUtils, ReentrancyGuard {\r\n    struct StakerData {\r\n        uint256 stake;\r\n        uint256 delegatedStake;\r\n        address representative;\r\n    }\r\n\r\n    IERC20 public immutable kncToken;\r\n    IKyberDao public immutable kyberDao;\r\n\r\n    // staker data per epoch, including stake, delegated stake and representative\r\n    mapping(uint256 => mapping(address => StakerData)) internal stakerPerEpochData;\r\n    // latest data of a staker, including stake, delegated stake, representative\r\n    mapping(address => StakerData) internal stakerLatestData;\r\n    // true/false: if data has been initialized at an epoch for a staker\r\n    mapping(uint256 => mapping(address => bool)) internal hasInited;\r\n\r\n    // event is fired if something is wrong with withdrawal\r\n    // even though the withdrawal is still successful\r\n    event WithdrawDataUpdateFailed(uint256 curEpoch, address staker, uint256 amount);\r\n\r\n    constructor(\r\n        IERC20 _kncToken,\r\n        uint256 _epochPeriod,\r\n        uint256 _startTimestamp,\r\n        IKyberDao _kyberDao\r\n    ) public {\r\n        require(_epochPeriod > 0, \"ctor: epoch period is 0\");\r\n        require(_startTimestamp >= now, \"ctor: start in the past\");\r\n        require(_kncToken != IERC20(0), \"ctor: kncToken 0\");\r\n        require(_kyberDao != IKyberDao(0), \"ctor: kyberDao 0\");\r\n\r\n        epochPeriodInSeconds = _epochPeriod;\r\n        firstEpochStartTimestamp = _startTimestamp;\r\n        kncToken = _kncToken;\r\n        kyberDao = _kyberDao;\r\n    }\r\n\r\n    /**\r\n     * @dev calls to set delegation for msg.sender, will take effect from the next epoch\r\n     * @param newRepresentative address to delegate to\r\n     */\r\n    function delegate(address newRepresentative) external override {\r\n        require(newRepresentative != address(0), \"delegate: representative 0\");\r\n        address staker = msg.sender;\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n\r\n        initDataIfNeeded(staker, curEpoch);\r\n\r\n        address curRepresentative = stakerPerEpochData[curEpoch + 1][staker].representative;\r\n        // nothing changes here\r\n        if (newRepresentative == curRepresentative) {\r\n            return;\r\n        }\r\n\r\n        uint256 updatedStake = stakerPerEpochData[curEpoch + 1][staker].stake;\r\n\r\n        // reduce delegatedStake for curRepresentative if needed\r\n        if (curRepresentative != staker) {\r\n            initDataIfNeeded(curRepresentative, curEpoch);\r\n\r\n            stakerPerEpochData[curEpoch + 1][curRepresentative].delegatedStake =\r\n                stakerPerEpochData[curEpoch + 1][curRepresentative].delegatedStake.sub(updatedStake);\r\n            stakerLatestData[curRepresentative].delegatedStake =\r\n                stakerLatestData[curRepresentative].delegatedStake.sub(updatedStake);\r\n\r\n            emit Delegated(staker, curRepresentative, curEpoch, false);\r\n        }\r\n\r\n        stakerLatestData[staker].representative = newRepresentative;\r\n        stakerPerEpochData[curEpoch + 1][staker].representative = newRepresentative;\r\n\r\n        // ignore if staker is delegating back to himself\r\n        if (newRepresentative != staker) {\r\n            initDataIfNeeded(newRepresentative, curEpoch);\r\n            stakerPerEpochData[curEpoch + 1][newRepresentative].delegatedStake =\r\n                stakerPerEpochData[curEpoch + 1][newRepresentative].delegatedStake.add(updatedStake);\r\n            stakerLatestData[newRepresentative].delegatedStake =\r\n                stakerLatestData[newRepresentative].delegatedStake.add(updatedStake);\r\n            emit Delegated(staker, newRepresentative, curEpoch, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev call to stake more KNC for msg.sender\r\n     * @param amount amount of KNC to stake\r\n     */\r\n    function deposit(uint256 amount) external override {\r\n        require(amount > 0, \"deposit: amount is 0\");\r\n\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        address staker = msg.sender;\r\n\r\n        // collect KNC token from staker\r\n        require(\r\n            kncToken.transferFrom(staker, address(this), amount),\r\n            \"deposit: can not get token\"\r\n        );\r\n\r\n        initDataIfNeeded(staker, curEpoch);\r\n\r\n        stakerPerEpochData[curEpoch + 1][staker].stake =\r\n            stakerPerEpochData[curEpoch + 1][staker].stake.add(amount);\r\n        stakerLatestData[staker].stake =\r\n            stakerLatestData[staker].stake.add(amount);\r\n\r\n        // increase delegated stake for address that staker has delegated to (if it is not staker)\r\n        address representative = stakerPerEpochData[curEpoch + 1][staker].representative;\r\n        if (representative != staker) {\r\n            initDataIfNeeded(representative, curEpoch);\r\n            stakerPerEpochData[curEpoch + 1][representative].delegatedStake =\r\n                stakerPerEpochData[curEpoch + 1][representative].delegatedStake.add(amount);\r\n            stakerLatestData[representative].delegatedStake =\r\n                stakerLatestData[representative].delegatedStake.add(amount);\r\n        }\r\n\r\n        emit Deposited(curEpoch, staker, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev call to withdraw KNC from staking, it could affect reward when calling KyberDao handleWithdrawal\r\n     * @param amount amount of KNC to withdraw\r\n     */\r\n    function withdraw(uint256 amount) external override nonReentrant {\r\n        require(amount > 0, \"withdraw: amount is 0\");\r\n\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        address staker = msg.sender;\r\n\r\n        require(\r\n            stakerLatestData[staker].stake >= amount,\r\n            \"withdraw: latest amount staked < withdrawal amount\"\r\n        );\r\n\r\n        (bool success, ) = address(this).call(\r\n            abi.encodeWithSignature(\r\n                \"handleWithdrawal(address,uint256,uint256)\",\r\n                staker,\r\n                amount,\r\n                curEpoch\r\n            )\r\n        );\r\n        if (!success) {\r\n            // Note: should catch this event to check if something went wrong\r\n            emit WithdrawDataUpdateFailed(curEpoch, staker, amount);\r\n        }\r\n\r\n        stakerLatestData[staker].stake = stakerLatestData[staker].stake.sub(amount);\r\n\r\n        // transfer KNC back to staker\r\n        require(kncToken.transfer(staker, amount), \"withdraw: can not transfer knc\");\r\n        emit Withdraw(curEpoch, staker, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev initialize data if needed, then return staker's data for current epoch\r\n     * @dev for safe, only allow calling this func from KyberDao address\r\n     * @param staker - staker's address to initialize and get data for\r\n     */\r\n    function initAndReturnStakerDataForCurrentEpoch(address staker)\r\n        external\r\n        override\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        )\r\n    {\r\n        require(\r\n            msg.sender == address(kyberDao),\r\n            \"initAndReturnData: only kyberDao\"\r\n        );\r\n\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        initDataIfNeeded(staker, curEpoch);\r\n\r\n        StakerData memory stakerData = stakerPerEpochData[curEpoch][staker];\r\n        stake = stakerData.stake;\r\n        delegatedStake = stakerData.delegatedStake;\r\n        representative = stakerData.representative;\r\n    }\r\n\r\n    /**\r\n     * @notice return raw data of a staker for an epoch\r\n     *         WARN: should be used only for initialized data\r\n     *          if data has not been initialized, it will return all 0\r\n     *          pool master shouldn't use this function to compute/distribute rewards of pool members\r\n     * @dev  in KyberDao contract, if staker wants to claim reward for past epoch,\r\n     *       we must know the staker's data for that epoch\r\n     *       if the data has not been initialized, it means staker hasn't done any action -> no reward\r\n     */\r\n    function getStakerRawData(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        )\r\n    {\r\n        StakerData memory stakerData = stakerPerEpochData[epoch][staker];\r\n        stake = stakerData.stake;\r\n        delegatedStake = stakerData.delegatedStake;\r\n        representative = stakerData.representative;\r\n    }\r\n\r\n    /**\r\n     * @dev allow to get data up to current epoch + 1\r\n     */\r\n    function getStake(address staker, uint256 epoch) external view returns (uint256) {\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        if (epoch > curEpoch + 1) {\r\n            return 0;\r\n        }\r\n        uint256 i = epoch;\r\n        while (true) {\r\n            if (hasInited[i][staker]) {\r\n                return stakerPerEpochData[i][staker].stake;\r\n            }\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n            i--;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev allow to get data up to current epoch + 1\r\n     */\r\n    function getDelegatedStake(address staker, uint256 epoch) external view returns (uint256) {\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        if (epoch > curEpoch + 1) {\r\n            return 0;\r\n        }\r\n        uint256 i = epoch;\r\n        while (true) {\r\n            if (hasInited[i][staker]) {\r\n                return stakerPerEpochData[i][staker].delegatedStake;\r\n            }\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n            i--;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev allow to get data up to current epoch + 1\r\n     */\r\n    function getRepresentative(address staker, uint256 epoch) external view returns (address) {\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        if (epoch > curEpoch + 1) {\r\n            return address(0);\r\n        }\r\n        uint256 i = epoch;\r\n        while (true) {\r\n            if (hasInited[i][staker]) {\r\n                return stakerPerEpochData[i][staker].representative;\r\n            }\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n            i--;\r\n        }\r\n        // not delegated to anyone, default to yourself\r\n        return staker;\r\n    }\r\n\r\n    /**\r\n     * @notice return combine data (stake, delegatedStake, representative) of a staker\r\n     * @dev allow to get staker data up to current epoch + 1\r\n     */\r\n    function getStakerData(address staker, uint256 epoch)\r\n        external view override\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        )\r\n    {\r\n        stake = 0;\r\n        delegatedStake = 0;\r\n        representative = address(0);\r\n\r\n        uint256 curEpoch = getCurrentEpochNumber();\r\n        if (epoch > curEpoch + 1) {\r\n            return (stake, delegatedStake, representative);\r\n        }\r\n        uint256 i = epoch;\r\n        while (true) {\r\n            if (hasInited[i][staker]) {\r\n                stake = stakerPerEpochData[i][staker].stake;\r\n                delegatedStake = stakerPerEpochData[i][staker].delegatedStake;\r\n                representative = stakerPerEpochData[i][staker].representative;\r\n                return (stake, delegatedStake, representative);\r\n            }\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n            i--;\r\n        }\r\n        // not delegated to anyone, default to yourself\r\n        representative = staker;\r\n    }\r\n\r\n    function getLatestRepresentative(address staker) external view returns (address) {\r\n        return\r\n            stakerLatestData[staker].representative == address(0)\r\n                ? staker\r\n                : stakerLatestData[staker].representative;\r\n    }\r\n\r\n    function getLatestDelegatedStake(address staker) external view returns (uint256) {\r\n        return stakerLatestData[staker].delegatedStake;\r\n    }\r\n\r\n    function getLatestStakeBalance(address staker) external view returns (uint256) {\r\n        return stakerLatestData[staker].stake;\r\n    }\r\n\r\n    function getLatestStakerData(address staker)\r\n        external view override\r\n        returns (\r\n            uint256 stake,\r\n            uint256 delegatedStake,\r\n            address representative\r\n        )\r\n    {\r\n        stake = stakerLatestData[staker].stake;\r\n        delegatedStake = stakerLatestData[staker].delegatedStake;\r\n        representative = stakerLatestData[staker].representative == address(0)\r\n                ? staker\r\n                : stakerLatestData[staker].representative;\r\n    }\r\n\r\n    /**\r\n    * @dev  separate logics from withdraw, so staker can withdraw as long as amount <= staker's deposit amount\r\n            calling this function from withdraw function, ignore reverting\r\n    * @param staker staker that is withdrawing\r\n    * @param amount amount to withdraw\r\n    * @param curEpoch current epoch\r\n    */\r\n    function handleWithdrawal(\r\n        address staker,\r\n        uint256 amount,\r\n        uint256 curEpoch\r\n    ) external {\r\n        require(msg.sender == address(this), \"only staking contract\");\r\n        initDataIfNeeded(staker, curEpoch);\r\n        // Note: update latest stake will be done after this function\r\n        // update staker's data for next epoch\r\n        stakerPerEpochData[curEpoch + 1][staker].stake =\r\n            stakerPerEpochData[curEpoch + 1][staker].stake.sub(amount);\r\n\r\n        address representative = stakerPerEpochData[curEpoch][staker].representative;\r\n        uint256 curStake = stakerPerEpochData[curEpoch][staker].stake;\r\n        uint256 lStakeBal = stakerLatestData[staker].stake.sub(amount);\r\n        uint256 newStake = curStake.min(lStakeBal);\r\n        uint256 reduceAmount = curStake.sub(newStake); // newStake is always <= curStake\r\n\r\n        if (reduceAmount > 0) {\r\n            if (representative != staker) {\r\n                initDataIfNeeded(representative, curEpoch);\r\n                // staker has delegated to representative, withdraw will affect representative's delegated stakes\r\n                stakerPerEpochData[curEpoch][representative].delegatedStake =\r\n                    stakerPerEpochData[curEpoch][representative].delegatedStake.sub(reduceAmount);\r\n            }\r\n            stakerPerEpochData[curEpoch][staker].stake = newStake;\r\n            // call KyberDao to reduce reward, if staker has delegated, then pass his representative\r\n            if (address(kyberDao) != address(0)) {\r\n                // don't revert if KyberDao revert so data will be updated correctly\r\n                (bool success, ) = address(kyberDao).call(\r\n                    abi.encodeWithSignature(\r\n                        \"handleWithdrawal(address,uint256)\",\r\n                        representative,\r\n                        reduceAmount\r\n                    )\r\n                );\r\n                if (!success) {\r\n                    emit WithdrawDataUpdateFailed(curEpoch, staker, amount);\r\n                }\r\n            }\r\n        }\r\n        representative = stakerPerEpochData[curEpoch + 1][staker].representative;\r\n        if (representative != staker) {\r\n            initDataIfNeeded(representative, curEpoch);\r\n            stakerPerEpochData[curEpoch + 1][representative].delegatedStake =\r\n                stakerPerEpochData[curEpoch + 1][representative].delegatedStake.sub(amount);\r\n            stakerLatestData[representative].delegatedStake =\r\n                stakerLatestData[representative].delegatedStake.sub(amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev initialize data if it has not been initialized yet\r\n     * @param staker staker's address to initialize\r\n     * @param epoch should be current epoch\r\n     */\r\n    function initDataIfNeeded(address staker, uint256 epoch) internal {\r\n        address representative = stakerLatestData[staker].representative;\r\n        if (representative == address(0)) {\r\n            // not delegate to anyone, consider as delegate to yourself\r\n            stakerLatestData[staker].representative = staker;\r\n            representative = staker;\r\n        }\r\n\r\n        uint256 ldStake = stakerLatestData[staker].delegatedStake;\r\n        uint256 lStakeBal = stakerLatestData[staker].stake;\r\n\r\n        if (!hasInited[epoch][staker]) {\r\n            hasInited[epoch][staker] = true;\r\n            StakerData storage stakerData = stakerPerEpochData[epoch][staker];\r\n            stakerData.representative = representative;\r\n            stakerData.delegatedStake = ldStake;\r\n            stakerData.stake = lStakeBal;\r\n        }\r\n\r\n        // whenever stakers deposit/withdraw/delegate, the current and next epoch data need to be updated\r\n        // as the result, we will also initialize data for staker at the next epoch\r\n        if (!hasInited[epoch + 1][staker]) {\r\n            hasInited[epoch + 1][staker] = true;\r\n            StakerData storage nextEpochStakerData = stakerPerEpochData[epoch + 1][staker];\r\n            nextEpochStakerData.representative = representative;\r\n            nextEpochStakerData.delegatedStake = ldStake;\r\n            nextEpochStakerData.stake = lStakeBal;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_kncToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epochPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"contract IKyberDao\",\"name\":\"_kyberDao\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDelegated\",\"type\":\"bool\"}],\"name\":\"Delegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"curEpoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"curEpoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"curEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawDataUpdateFailed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRepresentative\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochPeriodInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstEpochStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getDelegatedStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getEpochNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getLatestDelegatedStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getLatestRepresentative\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getLatestStakeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getLatestStakerData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getRepresentative\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getStakerData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getStakerRawData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curEpoch\",\"type\":\"uint256\"}],\"name\":\"handleWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"initAndReturnStakerDataForCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"representative\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kncToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberDao\",\"outputs\":[{\"internalType\":\"contract IKyberDao\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KyberStaking","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"430","ConstructorArguments":"000000000000000000000000dd974d5c2e2928dea5f71b9825b8b646686bd2000000000000000000000000000000000000000000000000000000000000000a8c000000000000000000000000000000000000000000000000000000005EFD5BC000000000000000000000000039E507f4F7c3e85eD799FDbdf04E42104a8f6b9A","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e226a6302b84b358849f5b5e0f541d9614dcdad0cedb6d983293d343b1243995"}]}