{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.7.1;\npragma experimental ABIEncoderV2;\n\n\n// \n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n\n// \n// Uniswap V2 Router Interface.\n// Used on the Main-Net, and Public Test-Nets.\ninterface IUniswapRouter {\n    // Get Factory and WETH addresses.\n    function factory()  external pure returns (address);\n    function WETH()     external pure returns (address);\n\n    // Create/add to a liquidity pair using ETH.\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline )                 \n                                        external \n                                        payable \n        returns (\n            uint amountToken, \n            uint amountETH, \n            uint liquidity \n        );\n\n    // Remove liquidity pair.\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline ) \n                                        external\n        returns (\n            uint amountETH\n        );\n\n    // Get trade output amount, given an input.\n    function getAmountsOut(\n        uint amountIn, \n        address[] memory path ) \n                                        external view \n        returns (\n            uint[] memory amounts\n        );\n\n    // Get trade input amount, given an output.\n    function getAmountsIn(\n        uint amountOut, \n        address[] memory path )\n                                        external view\n        returns (\n            uint[] memory amounts\n        );\n}\n\n// Uniswap Factory interface.\n// We use it only to obtain the Token Exchange Pair address.\ninterface IUniswapFactory {\n    function getPair(\n        address tokenA, \n        address tokenB )\n                                        external view \n    returns ( address pair );\n}\n\n// Uniswap Pair interface (it's also an ERC20 token).\n// Used to get reserves, and token price.\ninterface IUniswapPair is IERC20\n{\n    // Addresses of the first and second pool-kens.\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n\n    // Get the pair's token pool reserves.\n    function getReserves() \n                                        external view \n    returns (\n        uint112 reserve0, \n        uint112 reserve1,\n        uint32 blockTimestampLast\n    );\n}\n\n// \n/**\n *  The Core Settings contract, which defines the global constants,\n *  which are used in the pool and related contracts (such as \n *  OWNER_ADDRESS), and also defines the percentage simulation\n *  code, to use the same percentage precision across all contracts.\n */\ncontract CoreUniLotterySettings {\n    // Percentage calculations.\n    // As Solidity doesn't have floats, we have to use integers for\n    // percentage arithmetics.\n    // We set 1 percent to be equal to 1,000,000 - thus, we\n    // simulate 6 decimal points when computing percentages.\n    uint32 public constant PERCENT = 10 ** 6;\n    uint32 constant BASIS_POINT = PERCENT / 100;\n\n    uint32 constant _100PERCENT = 100 * PERCENT;\n\n    /** The UniLottery Owner's address.\n     *\n     *  In the current version, The Owner has rights to:\n     *  - Take up to 10% profit from every lottery.\n     *  - Pool liquidity into the pool and unpool it.\n     *  - Start new Auto-Mode & Manual-Mode lotteries.\n     *  - Set randomness provider gas price & other settings.\n     */\n\n    // Public Testnets: 0xb13CB9BECcB034392F4c9Db44E23C3Fb5fd5dc63 \n    // MainNet:         0x1Ae51bec001a4fA4E3b06A5AF2e0df33A79c01e2\n\n    address payable public constant OWNER_ADDRESS =\n        address( uint160( 0x1Ae51bec001a4fA4E3b06A5AF2e0df33A79c01e2 ) );\n\n\n    // Maximum lottery fee the owner can imburse on transfers.\n    uint32 constant MAX_OWNER_LOTTERY_FEE = 1 * PERCENT;\n\n    // Minimum amout of profit percentage that must be distributed\n    // to lottery winners.\n    uint32 constant MIN_WINNER_PROFIT_SHARE = 40 * PERCENT;\n\n    // Min & max profits the owner can take from lottery net profit.\n    uint32 constant MIN_OWNER_PROFITS = 3 * PERCENT;\n    uint32 constant MAX_OWNER_PROFITS = 10 * PERCENT;\n\n    // Min & max amount of lottery profits that the pool must get.\n    uint32 constant MIN_POOL_PROFITS = 10 * PERCENT;\n    uint32 constant MAX_POOL_PROFITS = 60 * PERCENT;\n\n    // Maximum lifetime of a lottery - 1 month (4 weeks).\n    uint32 constant MAX_LOTTERY_LIFETIME = 4 weeks;\n\n    // Callback gas requirements for a lottery's ending callback,\n    // and for the Pool's Scheduled Callback.\n    // Must be determined empirically.\n    uint32 constant LOTTERY_RAND_CALLBACK_GAS = 200000;\n    uint32 constant AUTO_MODE_SCHEDULED_CALLBACK_GAS = 3800431;\n}\n\n// \n// implement OpenZeppelin's ERC20 token.\n// Use the Uniswap Interfaces.\n// Use Core Settings.\n// Interface of the Main Pool Contract, with the functions that we'll\n// be calling from our contract.\ninterface IUniLotteryPool {\n    function lotteryFinish( uint totalReturn, uint profitAmount )\n    external payable;\n}\n\n// The Randomness Provider interface.\ninterface IRandomnessProvider {\n    function requestRandomSeedForLotteryFinish()    external;\n}\n\n/**\n *  Simple, gas-efficient lottery, which uses Uniswap as liquidity provider,\n *  and determines the lottery winners through a 3 different approaches\n *  (explained in detail on EndingAlgoType documentation).\n *\n *  This contract contains all code of the lottery contract, and \n *  lotteries themselves are just storage-container stubs, which use\n *  DelegateCall mechanism to execute this actual lottery code on\n *  their behalf.\n *\n *  Lottery workflow consists of these consecutive stages:\n *\n *  1. Initialization stage: Main Pool deploys this lottery contract,\n *      and calls initialize() with initial Ether funds provided.\n *      Lottery mints initial token supply and provides the liquidity\n *      to Uniswap, with whole token supply and initial Ether funds.\n *      Then, lottery becomes Active - trading tokens becomes allowed.\n *\n *  2. Active Stage:    Token transfers occurs on this stage, and \n *      finish probability is Zero. Our ETH funds in Uniswap increases\n *      in this stage.\n *      When certain criteria of holder count and fund gains are met,\n *      the Finishing stage begins.\n *  \n *  3. Finishing Stage:     It can be considered a second part of\n *      an Active stage, because all token transfers and Uniswap trading\n *      are still allowed and occur actively.\n *      However, on this stage, for every transfer, a pseudo-random\n *      number is rolled, and if that rolled number is below a specific\n *      threshold, lottery de-activates, and Ending stage begins, when\n *      token transfers are denied.\n *      The threshold is determined by Finish Probability, which\n *      increases on every transfer on this stage.\n *\n *      However, notice that if Finishing Criteria (holder count and\n *      fund gains) are no-longer met, Finishing Stage pauses, and\n *      we get back to Active Stage.\n *\n *  4. Ending-Mining Stage - Step One:\n *      On this stage, we Remove our contract's liquidity share\n *      from Uniswap, then transfer the profits to the Pool and\n *      the Owner addresses.\n *\n *      Then, we call the Randomness Provider, requesting the Random Seed,\n *      which later should be passed to us by calling our callback\n *      (finish_randomnessProviderCallback).\n *\n *      Miner, who completes this step, gets portion of Mining Rewards,\n *      which are a dedicated profit share to miners.\n *\n *  5. Ending-Mining Stage - Step Two:  On this stage, if  *\n *      However, if Randomness Provider hasn't given us a seed after\n *      specific amount of time, on this step, before starting the\n *      Winner Selection Algorithm, an Alternative Seed Generation\n *      is performed, where the pseudo-random seed is generated based\n *      on data in our and Storage contracts (transfer hash, etc.).\n *\n *      If we're using MinedWinnerSelection ending algorithm type, then\n *      on this step the miner performs the gas-intensive Winner Selection \n *      Algorithm, which involves complex score calculations in a loop, and\n *      then sorting the selected winners array.\n *\n *      Miner who successfully completes this step, gets a portion of\n *      the Mining Rewards.\n *\n *  6. Completion Stage (Winner Prize Claiming stage):  On this stage,\n *      the Lottery Winners can finally claim their Lottery Prizes,\n *      by calling a prize claim function on our contract.\n *\n *      If we're using WinnerSelfValidation ending algorithm, winner\n *      computes and validates his final score on this function by\n *      himself, so the prize claim transaction can be gas-costly.\n *\n *      However, is RolledRandomness or MinedWinnerSelection algorithms\n *      are used, this function is cheap in terms of gas.\n *\n *      However, if some of winners fail to claim their prizes after\n *      a specific amount of time (specified in config), then those\n *      prizes can then be claimed by Lottery Main Pool too.\n */\ncontract Lottery is ERC20, CoreUniLotterySettings\n{\n    // ===================== Events ===================== //\n\n    // After initialize() function finishes.\n    event LotteryInitialized();\n\n    // Emitted when lottery active stage ends (Mining Stage starts),\n    // on Mining Stage Step 1, after transferring profits to their\n    // respective owners (pool and OWNER_ADDRESS).\n    event LotteryEnd(\n        uint128 totalReturn,\n        uint128 profitAmount\n    );\n\n    // Emitted when on final finish, we call Randomness Provider\n    // to callback us with random value.\n    event RandomnessProviderCalled();\n\n    // Requirements for finishing stage start have been reached - \n    // finishing stage has started.\n    event FinishingStageStarted();\n\n    // We were currently on the finishing stage, but some requirement\n    // is no longer met. We must stop the finishing stage.\n    event FinishingStageStopped();\n\n    // New Referral ID has been generated.\n    event ReferralIDGenerated(\n        address referrer,\n        uint256 id\n    );\n\n    // New referral has been registered with a valid referral ID.\n    event ReferralRegistered(\n        address referree,\n        address referrer,\n        uint256 id\n    );\n\n    // Fallback funds received.\n    event FallbackEtherReceiver(\n        address sender,\n        uint value\n    );\n\n\n    // ======================  Structs & Enums  ====================== //\n\n    // Lottery Stages. \n    // Described in more detail above, on contract's main doc.\n    enum STAGE\n    {\n        // Initial stage - before the initialize() function is called.\n        INITIAL,\n\n        // Active Stage: On this stage, all token trading occurs.\n        ACTIVE,\n\n        // Finishing stage:\n        // This is when all finishing criteria are met, and for every\n        // transfer, we're rolling a pseudo-random number to determine\n        // if we should end the lottery (move to Ending stage).\n        FINISHING,\n\n        // Ending - Mining Stage:\n        // This stage starts after we lottery is no longer active,\n        // finishing stage ends. On this stage, Miners perform the\n        // Ending Algorithm and other operations.\n        ENDING_MINING,\n\n        // Lottery is completed - this is set after the Mining Stage ends.\n        // In this stage, Lottery Winners can claim their prizes.\n        COMPLETION,\n\n        // DISABLED stage. Used when we want a lottery contract to be\n        // absolutely disabled - so no state-modifying functions could\n        // be called.\n        // This is used in DelegateCall scenarios, where state-contract\n        // delegate-calls code contract, to save on deployment costs.\n        DISABLED\n    }\n\n\n    // Ending algorithm types enum.\n    enum EndingAlgoType\n    {\n        // 1. Mined Winner Selection Algorithm.\n        //  This algorithm is executed by a Lottery Miner in a single\n        //  transaction, on Mining Step 2.\n        //\n        //  On that single transaction, all ending scores for all\n        //  holders are computed, and a sorted winner array is formed,\n        //  which is written onto the LotteryStorage state.\n        //  Thus, it's gas expensive, and suitable only for small\n        //  holder numbers (up to 300).\n        //\n        // Pros:\n        //  + Guaranteed deterministically specifiable winner prize\n        //    distribution - for example, if we specify that there\n        //    must be 2 winners, of which first gets 60% of prize funds,\n        //    and second gets 40% of prize funds, then it's\n        //    guarateed that prize funds will be distributed just\n        //    like that.\n        //\n        //  + Low gas cost of prize claims - only ~ 40,000 gas for\n        //    claiming a prize.\n        //\n        // Cons:\n        //  - Not scaleable - as the Winner Selection Algorithm is\n        //    executed in a single transaction, it's limited by \n        //    block gas limit - 12,500,000 on the MainNet.\n        //    Thus, the lottery is limited to ~300 holders, and\n        //    max. ~200 winners of those holders.\n        //    So, it's suitable for only express-lotteries, where\n        //    a lottery runs only until ~300 holders are reached.\n        //\n        //  - High mining costs - if lottery has 300 holders,\n        //    mining transaction takes up whole block gas limit.\n        //\n        MinedWinnerSelection,\n\n        // 2. Winner Self-Validation Algorithm.\n        //\n        //  This algorithm does no operations during the Mining Stage\n        //  (except for setting up a Random Seed in Lottery Storage) -\n        //  the winner selection (obtaining a winner rank) is done by\n        //  the winners themselves, when calling the prize claim\n        //  functions.\n        //\n        //  This algorithm relies on a fact that by the time that\n        //  random seed is obtained, all data needed for winner selection\n        //  is already there - the holder scores of the Active Stage\n        //  (ether contributed, time factors, token balance), and\n        //  the Random Data (random seed + nonce (holder's address)),\n        //  so, there is no need to compute and sort the scores for the\n        //  whole holder array.\n        //\n        //  It's done like this: the holder checks if he's a winner, using\n        //  a view-function off-chain, and if so, he calls the \n        //  claimWinnerPrize() function, which obtains his winner rank\n        //  on O(n) time, and does no writing to contract states,\n        //  except for prize transfer-related operations.\n        //\n        //  When computing the winner's rank on LotteryStorage,\n        //  O(n) time is needed, as we loop through the holders array,\n        //  computing ending scores for each holder, using already-known\n        //  data. \n        //  However that means that for every prize claim, all scores of\n        //  all holders must be re-computed.\n        //  Computing a score for a single holder takes roughly 1500 gas\n        //  (400 for 3 slots SLOAD, and ~300 for arithmetic operations).\n        //\n        //  So, this algorithm makes prize claims more expensive for\n        //  every lottery holder.\n        //  If there's 1000 holders, prize claim takes up 1,500,000 gas,\n        //  so, this algorithm is not suitable for small prizes,\n        //  because gas fee would be higher than the prize amount won.\n        //\n        // Pros:\n        //  + Guaranteed deterministically specifiable winner prize\n        //    distribution (same as for algorithm 1).\n        //\n        //  + No mining costs for winner selection algorithm.\n        //\n        //  + More scalable than algorithm 1.\n        //\n        // Cons:\n        //  - High gas costs of prize claiming, rising with the number\n        //    of lottery holders - 1500 for every lottery holder.\n        //    Thus, suitable for only large prize amounts.\n        //\n        WinnerSelfValidation,\n\n        // 3. Rolled-Randomness algorithm.\n        //\n        //  This algorithm is the most cheapest in terms of gas, but\n        //  the winner prize distribution is non-deterministic.\n        //\n        //  This algorithm doesn't employ miners (no mining costs),\n        //  and doesn't require to compute scores for every holder\n        //  prior to getting a winner's rank, thus is the most scalable.\n        //\n        //  It works like this: a holder checks his winner status by\n        //  computing only his own randomized score (rolling a random\n        //  number from the random seed, and multiplying it by holder's\n        //  Active Stage score), and computing this randomized-score's\n        //  ratio relative to maximum available randomized score.\n        //  The higher the ratio, the higher the winner rank is.\n        //\n        //  However, many players can roll very high or low scores, and\n        //  get the same prizes, so it's difficult to make a fair and\n        //  efficient deterministic prize distribution mechanism, so\n        //  we have to fallback to specific heuristic workarounds.\n        //\n        // Pros:\n        //  + Scalable: O(1) complexity for computing a winner rank,\n        //      so there can be an unlimited amount of lottery holders,\n        //      and gas costs for winner selection and prize claim would\n        //      still be constant & low.\n        //\n        //  + Gas-efficient: gas costs for all winner-related operations\n        //      are constant and low, because only single holder's score\n        //      is computed.\n        //\n        //  + Doesn't require mining - even more gas savings.\n        //\n        // Cons:\n        //  + Hard to make a deterministic and fair prize distribution\n        //      mechanism, because of un-known environment - as only\n        //      single holder's score is compared to max-available\n        //      random score, not taking into account other holder\n        //      scores.\n        //\n        RolledRandomness\n    }\n\n\n    /**\n     *  Gas-efficient, minimal config, which specifies only basic,\n     *  most-important and most-used settings.\n     */\n    struct LotteryConfig\n    {\n        // ================ Misc Settings =============== //\n\n        // --------- Slot --------- //\n\n        // Initial lottery funds (initial market cap).\n        // Specified by pool, and is used to check if initial funds \n        // transferred to fallback are correct - equal to this value.\n        uint initialFunds;\n\n\n        // --------- Slot --------- //\n\n        // The minimum ETH value of lottery funds, that, once\n        // reached on an exchange liquidity pool (Uniswap, or our\n        // contract), must be guaranteed to not shrink below this value.\n        // \n        // This is accomplished in _transfer() function, by denying \n        // all sells that would drop the ETH amount in liquidity pool\n        // below this value.\n        // \n        // But on initial lottery stage, before this minimum requirement\n        // is reached for the first time, all sells are allowed.\n        //\n        // This value is expressed in ETH - total amount of ETH funds\n        // that we own in Uniswap liquidity pair.\n        //\n        // So, if initial funds were 10 ETH, and this is set to 100 ETH,\n        // after liquidity pool's ETH value reaches 100 ETH, all further\n        // sells which could drop the liquidity amount below 100 ETH,\n        // would be denied by require'ing in _transfer() function\n        // (transactions would be reverted).\n        //\n        uint128 fundRequirement_denySells;\n\n        // ETH value of our funds that we own in Uniswap Liquidity Pair,\n        // that's needed to start the Finishing Stage.\n        uint128 finishCriteria_minFunds;\n\n\n        // --------- Slot --------- //\n\n        // Maximum lifetime of a lottery - maximum amount of time \n        // allowed for lottery to stay active.\n        // By default, it's two weeks.\n        // If lottery is still active (hasn't returned funds) after this\n        // time, lottery will stop on the next token transfer.\n        uint32 maxLifetime;\n\n        // Maximum prize claiming time - for how long the winners\n        // may be able to claim their prizes after lottery ending.\n        uint32 prizeClaimTime;\n\n        // Token transfer burn rates for buyers, and a default rate for\n        // sells and non-buy-sell transfers.\n        uint32 burn_buyerRate;\n        uint32 burn_defaultRate;\n\n        // Maximum amount of tokens (in percentage of initial supply)\n        // to be allowed to own by a single wallet.\n        uint32 maxAmountForWallet_percentageOfSupply;\n\n        // The required amount of time that must pass after\n        // the request to Randomness Provider has been made, for\n        // external actors to be able to initiate alternative\n        // seed generation algorithm.\n        uint32 REQUIRED_TIME_WAITING_FOR_RANDOM_SEED;\n        \n        \n        // ================ Profit Shares =============== //\n\n        // \"Mined Uniswap Lottery\" ending Ether funds, which were obtained\n        // by removing token liquidity from Uniswap, are transfered to\n        // these recipient categories:\n        //\n        //  1. The Main Pool:   Initial funds, plus Pool's profit share.\n        //  2. The Owner:       Owner's profit share.\n        //\n        //  3. The Miners:      Miner rewards for executing the winner\n        //      selection algorithm stages.\n        //      The more holders there are, the more stages the \n        //      winner selection algorithm must undergo.\n        //      Each Miner, who successfully completed an algorithm\n        //      stage, will get ETH reward equal to:\n        //      (minerProfitShare / totalAlgorithmStages).\n        //\n        //  4. The Lottery Winners:     All remaining funds are given to\n        //      Lottery Winners, which were determined by executing\n        //      the Winner Selection Algorithm at the end of the lottery\n        //      (Miners executed it).\n        //      The Winners can claim their prizes by calling a \n        //      dedicated function in our contract.\n        //\n        //  The profit shares of #1 and #2 have controlled value ranges \n        //  specified in CoreUniLotterySettings.\n        //\n        //  All these shares are expressed as percentages of the\n        //  lottery profit amount (totalReturn - initialFunds).\n        //  Percentages are expressed using the PERCENT constant, \n        //  defined in CoreUniLotterySettings.\n        //\n        //  Here we specify profit shares of Pool, Owner, and the Miners.\n        //  Winner Prize Fund is all that's left (must be more than 50%\n        //  of all profits).\n        //\n\n        uint32 poolProfitShare;\n        uint32 ownerProfitShare;\n\n        // --------- Slot --------- //\n\n        uint32 minerProfitShare;\n        \n        \n        // =========== Lottery Finish criteria =========== //\n\n        // Lottery finish by design is a whole soft stage, that\n        // starts when criteria for holders and fund gains are met.\n        // During this stage, for every token transfer, a pseudo-random\n        // number will be rolled for lottery finish, with increasing \n        // probability.\n        //\n        // There are 2 ways that this probability increase is \n        // implemented:\n        // 1. Increasing on every new holder.\n        // 2. Increasing on every transaction after finish stage\n        //    was initiated.\n        //\n        // On every new holder, probability increases more than on\n        // new transactions.\n        //\n        // However, if during this stage some criteria become \n        // no-longer-met, the finish stage is cancelled.\n        // This cancel can be implemented by setting finish probability\n        // to zero, or leaving it as it was, but pausing the finishing\n        // stage.\n        // This is controlled by finish_resetProbabilityOnStop flag -\n        // if not set, probability stays the same, when the finishing\n        // stage is discontinued. \n\n        // ETH value of our funds that we own in Uniswap Liquidity Pair,\n        // that's needed to start the Finishing Stage.\n        //\n        // LOOK ABOVE - arranged for tight-packing.\n\n        // Minimum number of token holders required to start the\n        // finishing stage.\n        uint32 finishCriteria_minNumberOfHolders;\n\n        // Minimum amount of time that lottery must be active.\n        uint32 finishCriteria_minTimeActive;\n\n        // Initial finish probability, when finishing stage was\n        // just initiated.\n        uint32 finish_initialProbability;\n\n        // Finishing probability increase steps, for every new \n        // transaction and every new holder.\n        // If holder number decreases, probability decreases.\n        uint32 finish_probabilityIncreaseStep_transaction;\n        uint32 finish_probabilityIncreaseStep_holder;\n\n\n        // =========== Winner selection config =========== //\n\n        // Winner selection algorithm settings.\n        //\n        // Algorithm is based on score, which is calculated for \n        // every holder on lottery finish, and is comprised of\n        // the following parts.\n        // Each part is normalized to range ( 0 - scorePoints ), \n        // from smallest to largest value of each holder;\n        //\n        // After scores are computed, they are multiplied by \n        // holder count factor (holderCount / holderCountDivisor),\n        // and finally, multiplied by safely-generated random values,\n        // to get end winning scores.\n        // The top scorers win prizes.\n        //\n        // By default setting, max score is 40 points, and it's\n        // comprised of the following parts:\n        //\n        // 1. Ether contributed (when buying from Uniswap or contract). \n        //    Gets added when buying, and subtracted when selling.\n        //      Default: 10 points.\n        //\n        // 2. Amount of lottery tokens holder has on finish.\n        //      Default: 5 points.\n        //\n        // 3. Ether contributed, multiplied by the relative factor\n        //      of time - that is/*, \"block.timestamp\" */minus \"lotteryStartTime\".\n        //      This way, late buyers can get more points even if\n        //      they get little tokens and don't spend much ether.\n        //      Default: 5 points.\n        //\n        // 4. Refferrer bonus. For every player that joined with\n        //      your referral ID, you get (that player's score) / 10 \n        //      points! This goes up to specified max score.\n        //      Also, every player who provides a valid referral ID,\n        //      gets 2 points for free!\n        //      Default max bonus: 20 points.\n        //\n        int16 maxPlayerScore_etherContributed;\n        int16 maxPlayerScore_tokenHoldingAmount;\n        int16 maxPlayerScore_timeFactor;\n        int16 maxPlayerScore_refferalBonus;\n\n        // --------- Slot --------- //\n\n        // Score-To-Random ration data (as a rational ratio number).\n        // For example if 1:5, then scorePart = 1, and randPart = 5.\n        uint16 randRatio_scorePart;\n        uint16 randRatio_randPart;\n\n        // Time factor divisor - interval of time, in seconds, after\n        // which time factor is increased by one.\n        uint16 timeFactorDivisor;\n\n        // Bonus score a player should get when registering a valid\n        // referral code obtained from a referrer.\n        int16 playerScore_referralRegisteringBonus;\n\n\n        // Are we resetting finish probability when finishing stage\n        // stops, if some criteria are no longer met?\n        bool finish_resetProbabilityOnStop;\n\n\n        // =========== Winner Prize Fund Settings =========== //\n\n        // There are 2 available modes that we can use to distribute\n        // winnings: a computable sequence (geometrical progression),\n        // or an array of winner prize fund share percentages.\n\n        // More gas efficient is to use a computable sequence, \n        // where each winner gets a share equal to (factor * fundsLeft).\n        // Factor is in range [0.01 - 1.00] - simulated as [1% - 100%].\n        //\n        // For example:\n        // Winner prize fund is 100 ethers, Factor is 1/4 (25%), and \n        // there are 5 winners total (winnerCount), and sequenced winner\n        // count is 2 (sequencedWinnerCount).\n        //\n        // So, we pre-compute the upper shares, till we arrive to the\n        // sequenced winner count, in a loop:\n        // - Winner 1: 0.25 * 100 = 25 eth; 100 - 25 = 75 eth left.\n        // - Winner 2: 0.25 * 75 ~= 19 eth; 75  - 19 = 56 eth left.\n        //\n        // Now, we compute the left-over winner shares, which are\n        // winners that get their prizes from the funds left after the\n        // sequence winners.\n        //\n        // So, we just divide the leftover funds (56 eth), by 3,\n        // because winnerCount - sequencedWinnerCount = 3.\n        // - Winner 3 = 56 / 3 = 18 eth;\n        // - Winner 4 = 56 / 3 = 18 eth;\n        // - Winner 5 = 56 / 3 = 18 eth;\n        //\n\n        // If this value is 0, then we'll assume that array-mode is\n        // to be used.\n        uint32 prizeSequenceFactor;\n\n        // Maximum number of winners that the prize sequence can yield,\n        // plus the leftover winners, which will get equal shares of\n        // the remainder from the first-prize sequence.\n        \n        uint16 prizeSequence_winnerCount;\n\n        // How many winners would get sequence-computed prizes.\n        // The left-over winners\n        // This is needed because prizes in sequence tend to zero, so\n        // we need to limit the sequence to avoid very small prizes,\n        // and to avoid the remainder.\n        uint16 prizeSequence_sequencedWinnerCount;\n\n        // Initial token supply (without decimals).\n        uint48 initialTokenSupply;\n\n        // Ending Algorithm type.\n        // More about the 3 algorithm types above.\n        uint8 endingAlgoType;\n\n\n        // --------- Slot --------- //\n\n        // Array mode: The winner profit share percentages array. \n        // For example, lottery profits can be distributed this way:\n        //\n        // Winner profit shares (8 winners):\n        // [ 20%, 15%, 10%, 5%, 4%, 3%, 2%, 1% ] = 60% of profits.\n        // Owner profits: 10%\n        // Pool profits:  30%\n        //\n        // Pool profit share is not defined explicitly in the config, so\n        // when we internally validate specified profit shares, we \n        // assume the pool share to be the left amount until 100% ,\n        // but we also make sure that this amount is at least equal to\n        // MIN_POOL_PROFITS, defined in CoreSettings.\n        //\n        uint32[] winnerProfitShares;\n\n    }\n\n\n    // ========================= Constants ========================= //\n\n\n    // The Miner Profits - max/min values.\n    // These aren't defined in Core Settings, because Miner Profits\n    // are only specific to this lottery type.\n\n    uint32 constant MIN_MINER_PROFITS = 1 * PERCENT;\n    uint32 constant MAX_MINER_PROFITS = 10 * PERCENT;\n\n\n    // Uniswap Router V2 contract instance.\n    // Address is the same for MainNet, and all public testnets.\n    IUniswapRouter constant uniswapRouter = IUniswapRouter(\n        address( 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D ) );\n\n\n    // Public-accessible ERC20 token specific constants.\n    string constant public name = \"UniLottery Token\";\n    string constant public symbol = \"ULT\";\n    uint256 constant public decimals = 18;\n\n\n    // =================== State Variables =================== //\n\n    // ------- Initial Slots ------- //\n\n    // The config which is passed to constructor.\n    LotteryConfig internal cfg;\n\n    // ------- Slot ------- //\n\n    // The Lottery Storage contract, which stores all holder data,\n    // such as scores, referral tree data, etc.\n    LotteryStorage public lotStorage;\n\n    // ------- Slot ------- //\n\n    // Pool address. Set on constructor from msg.sender.\n    address payable public poolAddress;\n\n    // ------- Slot ------- //\n    \n    // Randomness Provider address.\n    address public randomnessProvider;\n\n    // ------- Slot ------- //\n\n    // Exchange address. In Uniswap mode, it's the Uniswap liquidity \n    // pair's address, where trades execute.\n    address public exchangeAddress;\n\n    // Start date.\n    uint32 public startDate;\n\n    // Completion (Mining Phase End) date.\n    uint32 public completionDate;\n    \n    // The date when Randomness Provider was called, requesting a\n    // random seed for the lottery finish.\n    // Also, when this variable becomes Non-Zero, it indicates that we're\n    // on Ending Stage Part One: waiting for the random seed.\n    uint32 finish_timeRandomSeedRequested;\n\n    // ------- Slot ------- //\n\n    // WETH address. Set by calling Router's getter, on constructor.\n    address WETHaddress;\n\n    // Is the WETH first or second token in our Uniswap Pair?\n    bool uniswap_ethFirst;\n\n    // If we are, or were before, on finishing stage, this is the\n    // probability of lottery going to Ending Stage on this transaction.\n    uint32 finishProbablity;\n    \n    // Re-Entrancy Lock (Mutex).\n    // We protect for reentrancy in the Fund Transfer functions.\n    bool reEntrancyMutexLocked;\n    \n    // On which stage we are currently.\n    uint8 public lotteryStage;\n    \n    // Indicator for whether the lottery fund gains have passed a \n    // minimum fund gain requirement.\n    // After that time point (when this bool is set), the token sells\n    // which could drop the fund value below the requirement, would\n    // be denied.\n    bool fundGainRequirementReached;\n    \n    // The current step of the Mining Stage.\n    uint16 miningStep;\n\n    // If we're currently on Special Transfer Mode - that is, we allow\n    // direct transfers between parties even in NON-ACTIVE state.\n    bool specialTransferModeEnabled;\n\n\n    // ------- Slot ------- //\n    \n    // Per-Transaction Pseudo-Random hash value (transferHashValue).\n    // This value is computed on every token transfer, by keccak'ing\n    // the last (current) transferHashValue, msg.sender, block.timestamp, and \n    // transaction count.\n    //\n    // This is used on Finishing Stage, as a pseudo-random number,\n    // which is used to check if we should end the lottery (move to\n    // Ending Stage).\n    uint256 transferHashValue;\n\n    // ------- Slot ------- //\n\n    // On lottery end, get & store the lottery total ETH return\n    // (including initial funds), and profit amount.\n    uint128 public ending_totalReturn;\n    uint128 public ending_profitAmount;\n\n    // ------- Slot ------- //\n\n    // The mapping that contains TRUE for addresses that already claimed\n    // their lottery winner prizes.\n    // Used only in COMPLETION, on claimWinnerPrize(), to check if\n    // msg.sender has already claimed his prize.\n    mapping( address => bool ) public prizeClaimersAddresses;\n\n\n    // ============= Private/internal functions ============= //\n\n\n    // Pool Only modifier.\n    modifier poolOnly {\n        require( msg.sender == poolAddress/*,\n                 \"Function can be called only by the pool!\" */);\n        _;\n    }\n\n    // Only randomness provider allowed modifier.\n    modifier randomnessProviderOnly {\n        require( msg.sender == randomnessProvider/*,\n                 \"Function can be called only by the UniLottery\"\n                 \" Randomness Provider!\" */);\n        _;\n    }\n\n    // Execute function only on specific lottery stage.\n    modifier onlyOnStage( STAGE _stage ) \n    {\n        require( lotteryStage == uint8( _stage )/*,\n                 \"Function cannot be called on current stage!\" */);\n        _;\n    }\n\n    // Modifier for protecting the function from re-entrant calls,\n    // by using a locked Re-Entrancy Lock (Mutex).\n    modifier mutexLOCKED\n    {\n        require( ! reEntrancyMutexLocked/*, \n                    \"Re-Entrant Calls are NOT ALLOWED!\" */);\n\n        reEntrancyMutexLocked = true;\n        _;\n        reEntrancyMutexLocked = false;\n    }\n\n\n    // Check if we're currently on a specific stage.\n    function onStage( STAGE _stage )\n                                                internal view\n    returns( bool )\n    {\n        return ( lotteryStage == uint8( _stage ) );\n    }\n\n\n    /**\n     *  Check if token transfer to specific wallet won't exceed \n     *  maximum token amount allowed to own by a single wallet.\n     *\n     *  @return true, if holder's balance with \"amount\" added,\n     *      would exceed the max allowed single holder's balance\n     *      (by default, that is 5% of total supply).\n     */\n    function transferExceedsMaxBalance( \n            address holder, uint amount )\n                                                internal view\n    returns( bool )\n    {\n        uint maxAllowedBalance = \n            ( totalSupply() * cfg.maxAmountForWallet_percentageOfSupply ) /\n            ( _100PERCENT );\n\n        return ( ( balanceOf( holder ) + amount ) > maxAllowedBalance );\n    }\n\n\n    /**\n     *  Update holder data.\n     *  This function is called by _transfer() function, just before\n     *  transfering final amount of tokens directly from sender to\n     *  receiver.\n     *  At this point, all burns/mints have been done, and we're sure\n     *  that this transfer is valid and must be successful.\n     *\n     *  In all modes, this function is used to update the holder array.\n     *\n     *  However, on external exchange modes (e.g. on Uniswap mode),\n     *  it is also used to track buy/sell ether value, to update holder\n     *  scores, when token buys/sells cannot be tracked directly.\n     *\n     *  If, however, we use Standalone mode, we are the exchange,\n     *  so on _transfer() we already know the ether value, which is\n     *  set to currentBuySellEtherValue variable.\n     *\n     *  @param amountSent - the token amount that is deducted from\n     *      sender's balance. This includes burn, and owner fee.\n     *\n     *  @param amountReceived - the token amount that receiver \n     *      actually receives, after burns and fees.\n     *\n     *  @return holderCountChanged - indicates whether holder count\n     *      changes during this transfer - new holder joins or leaves\n     *      (true), or no change occurs (false).\n     */\n    function updateHolderData_preTransfer(\n            address sender,\n            address receiver,\n            uint256 amountSent,\n            uint256 amountReceived )\n                                                internal\n    returns( bool holderCountChanged )\n    {\n        // Update holder array, if new token holder joined, or if\n        // a holder transfered his whole balance.\n        holderCountChanged = false;\n\n        // Sender transferred his whole balance - no longer a holder.\n        if( balanceOf( sender ) == amountSent ) \n        {\n            lotStorage.removeHolder( sender );\n            holderCountChanged = true;\n        }\n\n        // Receiver didn't have any tokens before - add it to holders.\n        if( balanceOf( receiver ) == 0 && amountReceived > 0 )\n        {\n            lotStorage.addHolder( receiver );\n            holderCountChanged = true;\n        }\n\n        // Update holder score factors: if buy/sell occured, update\n        // etherContributed and timeFactors scores,\n        // and also propagate the scores through the referral chain\n        // to the parent referrers (this is done in Storage contract).\n\n        // This lottery operates only on external exchange (Uniswap)\n        // mode, so we have to find out the buy/sell Ether value by \n        // calling the external exchange (Uniswap pair) contract.\n\n        // Temporary variable to store current transfer's buy/sell\n        // value in Ethers.\n        int buySellValue;\n\n        // Sender is an exchange - buy detected.\n        if( sender == exchangeAddress && receiver != exchangeAddress ) \n        {\n            // Use the Router's functionality.\n            // Set the exchange path to WETH -> ULT\n            // (ULT is Lottery Token, and it's address is our address).\n            address[] memory path = new address[]( 2 );\n            path[ 0 ] = WETHaddress;\n            path[ 1 ] = address(this);\n\n            uint[] memory ethAmountIn = uniswapRouter.getAmountsIn(\n                amountSent,     // uint amountOut, \n                path            // address[] path\n            );\n\n            buySellValue = int( ethAmountIn[ 0 ] );\n            \n            // Compute time factor value for the current ether value.\n            // buySellValue is POSITIVE.\n            // When computing Time Factors, leave only 2 ether decimals.\n            int timeFactorValue = ( buySellValue / (1 ether / 100) ) * \n                int( (block.timestamp - startDate) / cfg.timeFactorDivisor );\n\n            if( timeFactorValue == 0 )\n                timeFactorValue = 1;\n\n            // Update and propagate the buyer (receiver) scores.\n            lotStorage.updateAndPropagateScoreChanges(\n                    receiver,\n                    int80( buySellValue ),\n                    int80( timeFactorValue ),\n                    int80( amountReceived ) );\n        }\n\n        // Receiver is an exchange - sell detected.\n        else if( sender != exchangeAddress && receiver == exchangeAddress )\n        {\n            // Use the Router's functionality.\n            // Set the exchange path to ULT -> WETH\n            // (ULT is Lottery Token, and it's address is our address).\n            address[] memory path = new address[]( 2 );\n            path[ 0 ] = address(this);\n            path[ 1 ] = WETHaddress;\n\n            uint[] memory ethAmountOut = uniswapRouter.getAmountsOut(\n                amountReceived,     // uint amountIn\n                path                // address[] path\n            );\n\n            // It's a sell (ULT -> WETH), so set value to NEGATIVE.\n            buySellValue = int( -1 ) * int( ethAmountOut[ 1 ] );\n            \n            // Compute time factor value for the current ether value.\n            // buySellValue is NEGATIVE.\n            int timeFactorValue = ( buySellValue / (1 ether / 100) ) * \n                int( (block.timestamp - startDate) / cfg.timeFactorDivisor );\n\n            if( timeFactorValue == 0 )\n                timeFactorValue = -1;\n\n            // Update and propagate the seller (sender) scores.\n            lotStorage.updateAndPropagateScoreChanges(\n                    sender,\n                    int80( buySellValue ),\n                    int80( timeFactorValue ),\n                    -1 * int80( amountSent ) );\n        }\n\n        // Neither Sender nor Receiver are exchanges - default transfer.\n        // Tokens just got transfered between wallets, without \n        // exchanging for ETH - so etherContributed_change = 0. \n        // On this case, update both sender's & receiver's scores.\n        //\n        else {\n            buySellValue = 0;\n\n            lotStorage.updateAndPropagateScoreChanges( sender, 0, 0, \n                                            -1 * int80( amountSent ) );\n\n            lotStorage.updateAndPropagateScoreChanges( receiver, 0, 0, \n                                            int80( amountReceived ) );\n        }\n\n        // Check if lottery liquidity pool funds have already\n        // reached a minimum required ETH value.\n        uint ethFunds = getCurrentEthFunds();\n\n        if( !fundGainRequirementReached &&\n            ethFunds >= cfg.fundRequirement_denySells )\n        {\n            fundGainRequirementReached = true;\n        }\n\n        // Check whether this token transfer is allowed if it's a sell\n        // (if buySellValue is negative):\n        //\n        // If we've already reached the minimum fund gain requirement,\n        // and this sell would shrink lottery liquidity pool's ETH funds\n        // below this requirement, then deny this sell, causing this \n        // transaction to fail.\n\n        if( fundGainRequirementReached &&\n            buySellValue < 0 &&\n            ( uint( -1 * buySellValue ) >= ethFunds ||\n              ethFunds - uint( -1 * buySellValue ) < \n                cfg.fundRequirement_denySells ) )\n        {\n            require( false/*, \"This sell would drop the lottery ETH funds\"\n                            \"below the minimum requirement threshold!\" */);\n        }\n    }\n    \n    \n    /**\n     *  Check for finishing stage start conditions.\n     *  - If some conditions are met, start finishing stage!\n     *    Do it by setting \"onFinishingStage\" bool.\n     *  - If we're currently on finishing stage, and some condition\n     *    is no longer met, then stop the finishing stage.\n     */\n    function checkFinishingStageConditions()\n                                                    internal\n    {\n        // Firstly, check if lottery hasn't exceeded it's maximum lifetime.\n        // If so, don't check anymore, just set finishing stage, and\n        // end the lottery on further call of checkForEnding().\n        if( (block.timestamp - startDate) > cfg.maxLifetime ) \n        {\n            lotteryStage = uint8( STAGE.FINISHING );\n            return;\n        }\n\n        // Compute & check the finishing criteria.\n\n        // Notice that we adjust the config-specified fund gain\n        // percentage increase to uint-mode, by adding 100 percents,\n        // because we don't deal with negative percentages, and here\n        // we represent loss as a percentage below 100%, and gains\n        // as percentage above 100%.\n        // So, if in regular gains notation, it's said 10% gain,\n        // in uint mode, it's said 110% relative increase.\n        //\n        // (Also, remember that losses are impossible in our lottery\n        //  working scheme).\n\n        if( lotStorage.getHolderCount() >= cfg.finishCriteria_minNumberOfHolders\n            &&\n            getCurrentEthFunds() >= cfg.finishCriteria_minFunds\n            &&\n            (block.timestamp - startDate) >= cfg.finishCriteria_minTimeActive )\n        {\n            if( onStage( STAGE.ACTIVE ) )\n            {\n                // All conditions are met - start the finishing stage.\n                lotteryStage = uint8( STAGE.FINISHING );\n\n                emit FinishingStageStarted();\n            }\n        }\n\n        else if( onStage( STAGE.FINISHING ) )\n        {\n            // However, what if some condition was not met, but we're\n            // already on the finishing stage?\n            // If so, we must stop the finishing stage.\n            // But what to do with the finishing probability?\n            // Config specifies if it should be reset or maintain it's\n            // value until the next time finishing stage is started.\n\n            lotteryStage = uint8( STAGE.ACTIVE );\n\n            if( cfg.finish_resetProbabilityOnStop )\n                finishProbablity = cfg.finish_initialProbability;\n\n            emit FinishingStageStopped();\n        }\n    }\n\n\n    /**\n     *  We're currently on finishing stage - so let's check if\n     *  we should end the lottery block.timestamp!\n     *\n     *  This function is called from _transfer(), only if we're sure\n     *  that we're currently on finishing stage (onFinishingStage\n     *  variable is set).\n     *\n     *  Here, we compute the pseudo-random number from hash of\n     *  current message's sender, block.timestamp, and other values,\n     *  and modulo it to the current finish probability.\n     *  If it's equal to 1, then we end the lottery!\n     *\n     *  Also, here we update the finish probability according to\n     *  probability update criteria - holder count, and tx count.\n     *\n     *  @param holderCountChanged - indicates whether Holder Count\n     *      has changed during this transfer (new holder joined, or\n     *      a holder sold all his tokens).\n     */\n    function checkForEnding( bool holderCountChanged )\n                                                            internal\n    {\n        // At first, check if lottery max lifetime is exceeded.\n        // If so, start ending procedures right block.timestamp.\n        if( (block.timestamp - startDate) > cfg.maxLifetime )\n        {\n            startEndingStage();\n            return;\n        }\n\n        // Now, we know that lottery lifetime is still OK, and we're\n        // currently on Finishing Stage (because this function is\n        // called only when onFinishingStage is set).\n        //\n        // Now, check if we should End the lottery, by computing\n        // a modulo on a pseudo-random number, which is a transfer\n        // hash, computed for every transfer on _transfer() function.\n        //\n        // Get the modulo amount according to current finish \n        // probability.\n        // We use precision of 0.01% - notice the \"10000 *\" before\n        // 100 PERCENT.\n        // Later, when modulo'ing, we'll check if value is below 10000.\n        //\n        uint prec = 10000;\n        uint modAmount = (prec * _100PERCENT) / finishProbablity;\n\n        if( ( transferHashValue % modAmount ) <= prec )\n        {\n            // Finish probability is met! Commence lottery end - \n            // start Ending Stage.\n            startEndingStage();\n            return;\n        }\n\n        // Finish probability wasn't met.\n        // Update the finish probability, by increasing it!\n\n        // Transaction count criteria.\n        // As we know that this function is called on every new \n        // transfer (transaction), we don't check if transactionCount\n        // increased or not - we just perform probability update.\n\n        finishProbablity += cfg.finish_probabilityIncreaseStep_transaction;\n\n        // Now, perform holder count criteria update.\n        // Finish probability increases, no matter if holder count\n        // increases or decreases.\n        if( holderCountChanged )\n            finishProbablity += cfg.finish_probabilityIncreaseStep_holder;\n    }\n\n\n    /**\n     *  Start the Ending Stage, by De-Activating the lottery,\n     *  to deny all further token transfers (excluding the one when\n     *  removing liquidity from Uniswap), and transition into the \n     *  Mining Phase - set the lotteryStage to MINING.\n     */\n    function startEndingStage()\n                                                internal\n    {\n        lotteryStage = uint8( STAGE.ENDING_MINING );\n    }\n\n\n    /**\n     *  Execute the first step of the Mining Stage - request a \n     *  Random Seed from the Randomness Provider.\n     *\n     *  Here, we call the Randomness Provider, asking for a true random seed\n     *  to be passed to us into our callback, named \n     *  \"finish_randomnessProviderCallback()\".\n     *\n     *  When that callback will be called, our storage's random seed will\n     *  be set, and we'll be able to start the Ending Algorithm on\n     *  further mining steps.\n     *\n     *  Notice that Randomness Provider must already be funded, to\n     *  have enough Ether for Provable fee and the gas costs of our\n     *  callback function, which are quite high, because of winner\n     *  selection algorithm, which is computationally expensive.\n     *\n     *  The Randomness Provider is always funded by the Pool,\n     *  right before the Pool deploys and starts a new lottery, so\n     *  as every lottery calls the Randomness Provider only once,\n     *  the one-call-fund method for every lottery is sufficient.\n     *\n     *  Also notice, that Randomness Provider might fail to call\n     *  our callback due to some unknown reasons!\n     *  Then, the lottery profits could stay locked in this \n     *  lottery contract forever ?!!\n     *\n     *  No! We've thought about that - we've implemented the\n     *  Alternative Ending mechanism, where, if specific time passes \n     *  after we've made a request to Randomness Provider, and\n     *  callback hasn't been called yet, we allow external actor to\n     *  execute the Alternative ending, which basically does the\n     *  same things as the default ending, just that the Random Seed\n     *  will be computed locally in our contract, using the\n     *  Pseudo-Random mechanism, which could compute a reasonably\n     *  fair and safe value using data from holder array, and other\n     *  values, described in more detail on corresponding function's\n     *  description.\n     */\n    function mine_requestRandomSeed()\n                                                internal\n    {\n        // We're sure that the Randomness Provider has enough funds.\n        // Execute the random request, and get ready for Ending Algorithm.\n\n        IRandomnessProvider( randomnessProvider )\n            .requestRandomSeedForLotteryFinish();\n\n        // Store the time when random seed has been requested, to\n        // be able to alternatively handle the lottery finish, if\n        // randomness provider doesn't call our callback for some\n        // reason.\n        finish_timeRandomSeedRequested = uint32( block.timestamp );\n\n        // Emit appropriate events.\n        emit RandomnessProviderCalled();\n    }\n\n\n    /** PAYABLE [ OUT ] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n     *\n     *  Transfer the Owner & Pool profit shares, when lottery ends.\n     *  This function is the first one that's executed on the Mining\n     *  Stage.\n     *  This is the first step of Mining. So, the Miner who executes this\n     *  function gets the mining reward.\n     *\n     *  This function's job is to Gather the Profits & Initial Funds,\n     *  and Transfer them to Profiters - that is, to The Pool, and\n     *  to The Owner.\n     *\n     *  The Miners' profit share and Winner Prize Fund stay in this\n     *  contract.\n     *\n     *  On this function, we (in this order):\n     *\n     *  1. Remove all liquidity from Uniswap (if using Uniswap Mode),\n     *      pulling it to our contract's wallet.\n     *\n     *  2. Transfer the Owner and the Pool ETH profit shares to\n     *      Owner and Pool addresses.\n     *\n     *  * This function transfers Ether out of our contract:\n     *      - We transfer the Profits to Pool and Owner addresses.\n     */\n    function mine_removeUniswapLiquidityAndTransferProfits()\n                                                                internal\n                                                                mutexLOCKED\n    {\n        // We've already approved our token allowance to Router.\n        // Now, approve Uniswap liquidity token's Router allowance.\n        ERC20( exchangeAddress ).approve( address(uniswapRouter), uint(-1) );\n\n        // Enable the SPECIAL-TRANSFER mode, to allow Uniswap to transfer\n        // the tokens from Pair to Router, and then from Router to us.\n        specialTransferModeEnabled = true;\n\n        // Remove liquidity!\n        uint amountETH = uniswapRouter\n            .removeLiquidityETHSupportingFeeOnTransferTokens(\n                address(this),          // address token,\n                ERC20( exchangeAddress ).balanceOf( address(this) ),\n                0,                      // uint amountTokenMin,\n                0,                      // uint amountETHMin,\n                address(this),          // address to,\n                (block.timestamp + 10000000)        // uint deadline\n            );\n\n        // Tokens are transfered. Disable the special transfer mode.\n        specialTransferModeEnabled = false;\n\n        // Check that we've got a correct amount of ETH.\n        require( address(this).balance >= amountETH &&\n                 address(this).balance >= cfg.initialFunds/*,\n                 \"Incorrect amount of ETH received from Uniswap!\" */);\n\n\n        // Compute the Profit Amount (current balance - initial funds).\n        ending_totalReturn = uint128( address(this).balance );\n        ending_profitAmount = ending_totalReturn - uint128( cfg.initialFunds );\n\n        // Compute, and Transfer Owner's profit share and \n        // Pool's profit share to their respective addresses.\n\n        uint poolShare = ( ending_profitAmount * cfg.poolProfitShare ) /\n                         ( _100PERCENT );\n\n        uint ownerShare = ( ending_profitAmount * cfg.ownerProfitShare ) /\n                          ( _100PERCENT );\n\n        // To pool, transfer it's profit share plus initial funds.\n        IUniLotteryPool( poolAddress ).lotteryFinish\n            { value: poolShare + cfg.initialFunds }\n            ( ending_totalReturn, ending_profitAmount );\n\n        // Transfer Owner's profit share.\n        OWNER_ADDRESS.transfer( ownerShare );\n\n        // Emit ending event.\n        emit LotteryEnd( ending_totalReturn, ending_profitAmount );\n    }\n\n\n    /**\n     *  Executes a single step of the Winner Selection Algorithm\n     *  (the Ending Algorithm).\n     *  The algorithm itself is being executed in the Storage contract.\n     *\n     *  On current design, whole algorithm is executed in a single step.\n     *\n     *  This function is executed only in the Mining stage, and\n     *  accounts for most of the gas spent during mining.\n     */\n    function mine_executeEndingAlgorithmStep()\n                                                            internal\n    {\n        // Launch the winner algorithm, to execute the next step.\n        lotStorage.executeWinnerSelectionAlgorithm();\n    }\n\n\n\n    // =============== Public functions =============== //\n\n\n    /**\n     *  Constructor of this delegate code contract.\n     *  Here, we set OUR STORAGE's lotteryStage to DISABLED, because\n     *  we don't want anybody to call this contract directly.\n     */\n    constructor()\n    {\n        lotteryStage = uint8( STAGE.DISABLED );\n    }\n\n\n    /**\n     *  Construct the lottery contract which is delegating it's\n     *  call to us.\n     *\n     *  @param config - LotteryConfig structure to use in this lottery.\n     *\n     *      Future approach: ABI-encoded Lottery Config \n     *      (different implementations might use different config \n     *      structures, which are ABI-decoded inside the implementation).\n     *\n     *      Also, this \"config\" includes the ABI-encoded temporary values, \n     *      which are not part of persisted LotteryConfig, but should\n     *      be used only in constructor - for example, values to be\n     *      assigned to storage variables, such as ERC20 token's\n     *      name, symbol, and decimals.\n     *\n     *  @param _poolAddress - Address of the Main UniLottery Pool, which\n     *      provides initial funds, and receives it's profit share.\n     *\n     *  @param _randomProviderAddress - Address of a Randomness Provider,\n     *      to use for obtaining random seeds.\n     *\n     *  @param _storageAddress  - Address of a Lottery Storage.\n     *      Storage contract is a separate contract which holds all \n     *      lottery token holder data, such as intermediate scores.\n     *\n     */\n    function construct( \n            LotteryConfig memory config,\n            address payable _poolAddress,\n            address _randomProviderAddress,\n            address _storageAddress )\n                                                        external\n    {\n        // Check if contract wasn't already constructed!\n        require( poolAddress == address( 0 )/*,\n                 \"Contract is already constructed!\" */);\n\n        // Set the Pool's Address - notice that it's not the\n        // msg.sender, because lotteries aren't created directly\n        // by the Pool, but by the Lottery Factory!\n        poolAddress = _poolAddress;\n\n        // Set the Randomness Provider address.\n        randomnessProvider = _randomProviderAddress;\n\n\n        // Check the minimum & maximum requirements for config\n        // profit & lifetime parameters.\n\n        require( config.maxLifetime <= MAX_LOTTERY_LIFETIME/*,\n                 \"Lottery maximum lifetime is too high!\" */);\n\n        require( config.poolProfitShare >= MIN_POOL_PROFITS &&\n                 config.poolProfitShare <= MAX_POOL_PROFITS/*,\n                 \"Pool profit share is invalid!\" */);\n\n        require( config.ownerProfitShare >= MIN_OWNER_PROFITS &&\n                 config.ownerProfitShare <= MAX_OWNER_PROFITS/*,\n                 \"Owner profit share is invalid!\" */);\n\n        require( config.minerProfitShare >= MIN_MINER_PROFITS &&\n                 config.minerProfitShare <= MAX_MINER_PROFITS/*,\n                 \"Miner profit share is invalid!\" */);\n\n        // Check if time factor divisor is higher than 2 minutes.\n        // That's because int40 wouldn't be able to handle precisions\n        // of smaller time factor divisors.\n        require( config.timeFactorDivisor >= 2 minutes /*,\n                 \"Time factor divisor is lower than 2 minutes!\"*/ );\n\n        // Check if winner profit share is good.\n        uint32 totalWinnerShare = \n            (_100PERCENT) - config.poolProfitShare\n                            - config.ownerProfitShare\n                            - config.minerProfitShare;\n\n        require( totalWinnerShare >= MIN_WINNER_PROFIT_SHARE/*,\n                 \"Winner profit share is too low!\" */);\n\n        // Check if ending algorithm params are good.\n        require( config.randRatio_scorePart != 0    &&\n                 config.randRatio_randPart  != 0    &&\n                 ( config.randRatio_scorePart + \n                   config.randRatio_randPart    ) < 10000/*,\n                 \"Random Ratio params are invalid!\" */);\n\n        require( config.endingAlgoType == \n                    uint8( EndingAlgoType.MinedWinnerSelection ) ||\n                 config.endingAlgoType == \n                    uint8( EndingAlgoType.WinnerSelfValidation ) ||\n                 config.endingAlgoType == \n                    uint8( EndingAlgoType.RolledRandomness )/*,\n                 \"Wrong Ending Algorithm Type!\" */);\n\n        // Set the number of winners (winner count).\n        // If using Computed Sequence winner prize shares, set that\n        // value, and if it's zero, then we're using the Array-Mode\n        // prize share specification.\n        if( config.prizeSequence_winnerCount == 0 &&\n            config.winnerProfitShares.length != 0 )\n            config.prizeSequence_winnerCount = \n                uint16( config.winnerProfitShares.length );\n\n\n        // Setup our Lottery Storage - initialize, and set the\n        // Algorithm Config.\n\n        LotteryStorage _lotStorage = LotteryStorage( _storageAddress );\n\n        // Setup a Winner Score Config for the winner selection algo,\n        // to be used in the Lottery Storage.\n        LotteryStorage.WinnerAlgorithmConfig memory winnerConfig;\n\n        // Algorithm type.\n        winnerConfig.endingAlgoType = config.endingAlgoType;\n\n        // Individual player max score parts.\n        winnerConfig.maxPlayerScore_etherContributed =\n            config.maxPlayerScore_etherContributed;\n\n        winnerConfig.maxPlayerScore_tokenHoldingAmount =\n            config.maxPlayerScore_tokenHoldingAmount;\n\n        winnerConfig.maxPlayerScore_timeFactor =\n            config.maxPlayerScore_timeFactor;\n\n        winnerConfig.maxPlayerScore_refferalBonus =\n            config.maxPlayerScore_refferalBonus;\n\n        // Score-To-Random ratio parts.\n        winnerConfig.randRatio_scorePart = config.randRatio_scorePart;\n        winnerConfig.randRatio_randPart = config.randRatio_randPart;\n\n        // Set winner count (no.of winners).\n        winnerConfig.winnerCount = config.prizeSequence_winnerCount;\n\n\n        // Initialize the storage (bind it to our contract).\n        _lotStorage.initialize( winnerConfig );\n\n        // Set our immutable variable.\n        lotStorage = _lotStorage;\n\n\n        // Now, set our config to the passed config.\n        cfg = config;\n\n        // Might be un-needed (can be replaced by Constant on the MainNet):\n        WETHaddress = uniswapRouter.WETH();\n    }\n\n\n    /** PAYABLE [ IN  ] <<<<<<<<<<<<<<<<<<<<<<<<<<<<\n     *\n     *  Fallback Receive Ether function.\n     *  Used to receive ETH funds back from Uniswap, on lottery's end,\n     *  when removing liquidity.\n     */\n    receive()       external payable\n    {\n        emit FallbackEtherReceiver( msg.sender, msg.value );\n    }\n\n\n\n    /** PAYABLE [ IN  ] <<<<<<<<<<<<<<<<<<<<<<<<<<<<\n     *  PAYABLE [ OUT ] >>>>>>>>>>>>>>>>>>>>>>>>>>>>\n     *\n     *  Initialization function.\n     *  Here, the most important startup operations are made - \n     *  such as minting initial token supply and transfering it to\n     *  the Uniswap liquidity pair, in exchange for UNI-v2 tokens.\n     *\n     *  This function is called by the pool, when transfering\n     *  initial funds to this contract.\n     *\n     *  What's payable?\n     *  - Pool transfers initial funds to our contract.\n     *  - We transfer that initial fund Ether to Uniswap liquidity pair\n     *    when creating/providing it.\n     */\n    function initialize()   \n                                        external\n                                        payable\n                                        poolOnly\n                                        mutexLOCKED\n                                        onlyOnStage( STAGE.INITIAL )\n    {\n        // Check if pool transfered correct amount of funds.\n        require( address( this ).balance == cfg.initialFunds/*,\n                 \"Invalid amount of funds transfered!\" */);\n\n        // Set start date.\n        startDate = uint32( block.timestamp );\n\n        // Set the initial transfer hash value.\n        transferHashValue = uint( keccak256( \n                abi.encodePacked( msg.sender, block.timestamp ) ) );\n\n        // Set initial finish probability, to be used when finishing\n        // stage starts.\n        finishProbablity = cfg.finish_initialProbability;\n        \n        \n        // ===== Active operations - mint & distribute! ===== //\n\n        // Mint full initial supply of tokens to our contract address!\n        _mint( address(this), \n               uint( cfg.initialTokenSupply ) * (10 ** decimals) );\n\n        // Now - prepare to create a new Uniswap Liquidity Pair,\n        // with whole our total token supply and initial funds ETH\n        // as the two liquidity reserves.\n        \n        // Approve Uniswap Router to allow it to spend our tokens.\n        // Set maximum amount available.\n        _approve( address(this), address( uniswapRouter ), uint(-1) );\n\n        // Provide liquidity - the Router will automatically\n        // create a new Pair.\n        \n        uniswapRouter.addLiquidityETH \n        { value: address(this).balance }\n        (\n            address(this),          // address token,\n            totalSupply(),          // uint amountTokenDesired,\n            totalSupply(),          // uint amountTokenMin,\n            address(this).balance,  // uint amountETHMin,\n            address(this),          // address to,\n            (block.timestamp + 1000)            // uint deadline\n        );\n\n        // Get the Pair address - that will be the exchange address.\n        exchangeAddress = IUniswapFactory( uniswapRouter.factory() )\n            .getPair( WETHaddress, address(this) );\n\n        // We assume that the token reserves of the pair are good,\n        // and that we own the full amount of liquidity tokens.\n\n        // Find out which of the pair tokens is WETH - is it the \n        // first or second one. Use it later, when getting our share.\n        if( IUniswapPair( exchangeAddress ).token0() == WETHaddress )\n            uniswap_ethFirst = true;\n        else\n            uniswap_ethFirst = false;\n\n\n        // Move to ACTIVE lottery stage.\n        // Now, all token transfers will be allowed.\n        lotteryStage = uint8( STAGE.ACTIVE );\n\n        // Lottery is initialized. We're ready to emit event.\n        emit LotteryInitialized();\n    }\n\n\n    // Return this lottery's initial funds, as were specified in the config.\n    //\n    function getInitialFunds()          external view\n    returns( uint )\n    {\n        return cfg.initialFunds;\n    }\n\n    // Return active (still not returned to pool) initial fund value.\n    // If no-longer-active, return 0 (default) - because funds were \n    // already returned back to the pool.\n    //\n    function getActiveInitialFunds()    external view\n    returns( uint )\n    {\n        if( onStage( STAGE.ACTIVE ) )\n            return cfg.initialFunds;\n        return 0;\n    }\n\n\n    /**\n     *  Get current Exchange's Token and ETH reserves.\n     *  We're on Uniswap mode, so get reserves from Uniswap.\n     */\n    function getReserves() \n                                                        external view\n    returns( uint _ethReserve, uint _tokenReserve )\n    {\n        // Use data from Uniswap pair contract.\n        ( uint112 res0, uint112 res1, ) = \n            IUniswapPair( exchangeAddress ).getReserves();\n\n        if( uniswap_ethFirst )\n            return ( res0, res1 );\n        else\n            return ( res1, res0 );\n    }\n\n\n    /**\n     *  Get our share (ETH amount) of the Uniswap Pair ETH reserve,\n     *  of our Lottery tokens ULT-WETH liquidity pair.\n     */\n    function getCurrentEthFunds()\n                                                        public view\n    returns( uint ethAmount )\n    {\n        IUniswapPair pair = IUniswapPair( exchangeAddress );\n        \n        ( uint112 res0, uint112 res1, ) = pair.getReserves();\n        uint resEth = uint( uniswap_ethFirst ? res0 : res1 );\n\n        // Compute our amount of the ETH reserve, based on our\n        // percentage of our liquidity token balance to total supply.\n        uint liqTokenPercentage = \n            ( pair.balanceOf( address(this) ) * (_100PERCENT) ) /\n            ( pair.totalSupply() );\n\n        // Compute and return the ETH reserve.\n        return ( resEth * liqTokenPercentage ) / (_100PERCENT);\n    }\n\n\n    /**\n     *  Get current finish probability.\n     *  If it's ACTIVE stage, return 0 automatically.\n     */\n    function getFinishProbability()\n                                                        external view\n    returns( uint32 )\n    {\n        if( onStage( STAGE.FINISHING ) )\n            return finishProbablity;\n        return 0;\n    }\n\n\n    \n    /**\n     *  Generate a referral ID for msg.sender, who must be a token holder.\n     *  Referral ID is used to refer other wallets into playing our\n     *  lottery.\n     *  - Referrer gets bonus points for every wallet that bought \n     *    lottery tokens and specified his referral ID.\n     *  - Referrees (wallets who got referred by registering a valid\n     *    referral ID, corresponding to some referrer), get some\n     *    bonus points for specifying (registering) a referral ID.\n     *\n     *  Referral ID is a uint256 number, which is generated by\n     *  keccak256'ing the holder's address, holder's current\n     *  token ballance, and current time.\n     */\n    function generateReferralID()\n                                        external\n                                        onlyOnStage( STAGE.ACTIVE )\n    {\n        uint256 refID = lotStorage.generateReferralID( msg.sender );\n\n        // Emit approppriate events.\n        emit ReferralIDGenerated( msg.sender, refID );\n    }\n\n\n    /**\n     *  Register a referral for a msg.sender (must be token holder),\n     *  using a valid referral ID got from a referrer.\n     *  This function is called by a referree, who obtained a\n     *  valid referral ID from some referrer, who previously\n     *  generated it using generateReferralID().\n     *\n     *  You can only register a referral once!\n     *  When you do so, you get bonus referral points!\n     */\n    function registerReferral( \n            uint256 referralID )\n                                        external\n                                        onlyOnStage( STAGE.ACTIVE )\n    {\n        address referrer = lotStorage.registerReferral( \n                msg.sender,\n                cfg.playerScore_referralRegisteringBonus,\n                referralID );\n\n        // Emit approppriate events.\n        emit ReferralRegistered( msg.sender, referrer, referralID );\n    }\n\n\n    /**\n     *  The most important function of this contract - Transfer Function.\n     *\n     *  Here, all token burning, intermediate score tracking, and \n     *  finish condition checking is performed, according to the \n     *  properties specified in config.\n     */\n    function _transfer( address sender,\n                        address receiver,\n                        uint256 amount )\n                                            internal\n                                            override\n    {\n        // Check if transfers are allowed in current state.\n        // On Non-Active stage, transfers are allowed only from/to\n        // our contract.\n        // As we don't have Standalone Mode on this lottery variation,\n        // that means that tokens to/from our contract are travelling\n        // only when we transfer them to Uniswap Pair, and when\n        // Uniswap transfers them back to us, on liquidity remove.\n        //\n        // On this state, we also don't perform any burns nor\n        // holding trackings - just transfer and return.\n\n        if( !onStage( STAGE.ACTIVE )    &&\n            !onStage( STAGE.FINISHING ) &&\n            ( sender == address(this) || receiver == address(this) ||\n              specialTransferModeEnabled ) )\n        {\n            super._transfer( sender, receiver, amount );\n            return;\n        }\n\n        // Now, we know that we're NOT on special mode.\n        // Perform standard checks & brecks.\n        require( ( onStage( STAGE.ACTIVE ) || \n                   onStage( STAGE.FINISHING ) )/*,\n                 \"Token transfers are only allowed on ACTIVE stage!\" */);\n                 \n        // Can't transfer zero tokens, or use address(0) as sender.\n        require( amount != 0 && sender != address(0)/*,\n                 \"Amount is zero, or transfering from zero address.\" */);\n\n\n        // Compute the Burn Amount - if buying tokens from an exchange,\n        // we use a lower burn rate - to incentivize buying!\n        // Otherwise (if selling or just transfering between wallets),\n        // we use a higher burn rate.\n        uint burnAmount;\n\n        // It's a buy - sender is an exchange.\n        if( sender == exchangeAddress )\n            burnAmount = ( amount * cfg.burn_buyerRate ) / (_100PERCENT);\n        else\n            burnAmount = ( amount * cfg.burn_defaultRate ) / (_100PERCENT);\n        \n        // Now, compute the final amount to be gotten by the receiver.\n        uint finalAmount = amount - burnAmount;\n\n        // Check if receiver's balance won't exceed the max-allowed!\n        // Receiver must not be an exchange.\n        if( receiver != exchangeAddress )\n        {\n            require( !transferExceedsMaxBalance( receiver, finalAmount )/*,\n                \"Receiver's balance would exceed maximum after transfer!\"*/);\n        }\n\n        // Now, update holder data array accordingly.\n        bool holderCountChanged = updateHolderData_preTransfer( \n                sender, \n                receiver, \n                amount,             // Amount Sent (Pre-Fees)\n                finalAmount         // Amount Received (Post-Fees).\n        );\n\n        // All is ok - perform the burn and token transfers block.timestamp.\n\n        // Burn token amount from sender's balance.\n        super._burn( sender, burnAmount );\n\n        // Finally, transfer the final amount from sender to receiver.\n        super._transfer( sender, receiver, finalAmount );\n\n\n        // Compute new Pseudo-Random transfer hash, which must be\n        // computed for every transfer, and is used in the\n        // Finishing Stage as a pseudo-random unique value for \n        // every transfer, by which we determine whether lottery\n        // should end on this transfer.\n        //\n        // Compute it like this: keccak the last (current) \n        // transferHashValue, msg.sender, sender, receiver, amount.\n\n        transferHashValue = uint( keccak256( abi.encodePacked(\n            transferHashValue, msg.sender, sender, receiver, amount ) ) );\n\n\n        // Check if we should be starting a finishing stage block.timestamp.\n        checkFinishingStageConditions();\n\n        // If we're on finishing stage, check for ending conditions.\n        // If ending check is satisfied, the checkForEnding() function\n        // starts ending operations.\n        if( onStage( STAGE.FINISHING ) )\n            checkForEnding( holderCountChanged );\n    }\n\n\n    /**\n     *  Callback function, which is called from Randomness Provider,\n     *  after it obtains a random seed to be passed to us, after\n     *  we have initiated The Ending Stage, on which random seed\n     *  is used to generate random factors for Winner Selection\n     *  algorithm.\n     */ \n    function finish_randomnessProviderCallback(\n            uint256 randomSeed,\n            uint256 /*callID*/ )\n                                                external\n                                                randomnessProviderOnly\n    {\n        // Set the random seed in the Storage Contract.\n        lotStorage.setRandomSeed( randomSeed );\n\n        // If algo-type is not Mined Winner Selection, then by block.timestamp\n        // we assume lottery as COMPL3T3D.\n        if( cfg.endingAlgoType != uint8(EndingAlgoType.MinedWinnerSelection) )\n        {\n            lotteryStage = uint8( STAGE.COMPLETION );\n            completionDate = uint32( block.timestamp );\n        }\n    }\n\n\n    /**\n     *  Function checks if we can initiate Alternative Seed generation.\n     *\n     *  Alternative approach to Lottery Random Seed is used only when\n     *  Randomness Provider doesn't work, and doesn't call the\n     *  above callback.\n     *\n     *  This alternative approach can be initiated by Miners, when\n     *  these conditions are met:\n     *  - Lottery is on Ending (Mining) stage.\n     *  - Request to Randomness Provider was made at least X time ago,\n     *    and our callback hasn't been called yet.\n     *\n     *  If these conditions are met, we can initiate the Alternative\n     *  Random Seed generation, which generates a seed based on our\n     *  state.\n     */\n    function alternativeSeedGenerationPossible()\n                                                        internal view\n    returns( bool )\n    {\n        return ( onStage( STAGE.ENDING_MINING ) &&\n                 ( (block.timestamp - finish_timeRandomSeedRequested) >\n                   cfg.REQUIRED_TIME_WAITING_FOR_RANDOM_SEED ) );\n    }\n\n\n    /**\n     *  Return this lottery's config, using ABIEncoderV2.\n     */\n    /*function getLotteryConfig()\n                                                    external view\n    returns( LotteryConfig memory ourConfig )\n    {\n        return cfg;\n    }*/\n\n\n    /**\n     *  Checks if Mining is currently available.\n     */\n    function isMiningAvailable()\n                                                    external view\n    returns( bool )\n    {\n        return onStage( STAGE.ENDING_MINING ) && \n               ( miningStep == 0 || \n                 ( miningStep == 1 && \n                   ( lotStorage.getRandomSeed() != 0 ||\n                     alternativeSeedGenerationPossible() )\n                 ) );\n    }\n\n\n    /** PAYABLE [ OUT ] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n     *\n     *  Mining function, to be executed on Ending (Mining) stage.\n     *\n     *  \"Mining\" approach is used in this lottery, to use external\n     *  actors for executing the gas-expensive Ending Algorithm,\n     *  and other ending operations, such as profit transfers.\n     *\n     *  \"Miners\" can be any external actors who call this function.\n     *  When Miner successfully completes a Mining Step, he gets \n     *  a Mining Reward, which is a certain portion of lottery's profit\n     *  share, dedicated to Miners.\n     *\n     *  NOT-IMPLEMENTED APPROACH:\n     *\n     *  All these operations are divided into \"mining steps\", which are\n     *  smaller components, which fit into reasonable gas limits.\n     *  All \"steps\" are designed to take up similar amount of gas.\n     *\n     *  For example, if total lottery profits (total ETH got from\n     *  pulling liquidity out of Uniswap, minus initial funds),\n     *  is 100 ETH, Miner Profit Share is 10%, and there are 5 mining\n     *  steps total, then for a singe step executed, miner will get:\n     *\n     *  (100 * 0.1) / 5 = 2 ETH.\n     *\n     *  ---------------------------------\n     *\n     *  CURRENTLY IMPLEMENTED APPROACH:\n     *\n     *  As the above-defined approach would consume very much gas for\n     *  inter-step intermediate state storage, we have thought that\n     *  for block.timestamp, it's better to have only 2 mining steps, the second of\n     *  which performs the whole Winner Selection Algorithm.\n     *\n     *  This is because performing the whole algorithm at once would save\n     *  us up to 10x more gas in total, than executing it in steps.\n     *\n     *  However, this solution is not scalable, because algorithm has\n     *  to fit into block gas limit (10,000,000 gas), so we are limited\n     *  to a certain safe maximum number of token holders, which is\n     *  empirically determined during testing, and defined in the\n     *  MAX_SAFE_NUMBER_OF_HOLDERS constant, which is checked against the\n     *  config value \"finishCriteria_minNumberOfHolders\" in constructor.\n     *\n     *  So, in this approach, there are only 2 mining steps:\n     *\n     *  1. Remove liquidity from Uniswap, transfer profit shares to\n     *      the Pool and the Owner Address, and request Random Seed\n     *      from the Randomness Provider.\n     *      Reward: 25% of total Mining Rewards.\n     *\n     *  2. Perform the whole Winner Selection Algorithm inside the\n     *      Lottery Storage contract.\n     *      Reward: 75% of total Mining Rewards.\n     *\n     *  * Function transfers Ether out of our contract:\n     *    - Transfers the current miner's reward to msg.sender.\n     */\n    function mine()\n                                external\n                                onlyOnStage( STAGE.ENDING_MINING )\n    {\n        uint currentStepReward;\n\n        // Perform different operations on different mining steps.\n\n        // Step 0:  Remove liquidity from Uniswap, transfer profits to\n        //          Pool and Owner addresses. Also, request a Random Seed\n        //          from the Randomness Provider.\n        if( miningStep == 0 )\n        {\n            mine_requestRandomSeed();\n            mine_removeUniswapLiquidityAndTransferProfits();\n\n            // Compute total miner reward amount, then compute this \n            // step's reward later.\n            uint totalMinerRewards = \n                ( ending_profitAmount * cfg.minerProfitShare ) / \n                ( _100PERCENT );\n\n            // Step 0 reward is 10% for Algo type 1.\n            if( cfg.endingAlgoType == uint8(EndingAlgoType.MinedWinnerSelection) )\n            {\n                currentStepReward = ( totalMinerRewards * (10 * PERCENT) ) /\n                                    ( _100PERCENT );\n            }\n            // If other algo-types, second step is not normally needed,\n            // so here we take 80% of miner rewards.\n            // If Randomness Provider won't give us a seed after\n            // specific amount of time, we'll initiate a second step,\n            // with remaining 20% of miner rewords.\n            else\n            {\n                currentStepReward = ( totalMinerRewards * (80 * PERCENT) ) /\n                                    ( _100PERCENT );\n            }\n\n            require( currentStepReward <= totalMinerRewards/*, \"BUG 1694\" */);\n        }\n\n        // Step 1:\n        //  If we use MinedWinnerSelection algo-type, then execute the \n        //  winner selection algorithm.\n        //  Otherwise, check if Random Provider hasn't given us a\n        //  random seed long enough, so that we have to generate a\n        //  seed locally.\n        else\n        {\n            // Check if we can go into this step when using specific\n            // ending algorithm types.\n            if( cfg.endingAlgoType != uint8(EndingAlgoType.MinedWinnerSelection) )\n            {\n                require( lotStorage.getRandomSeed() == 0 &&\n                         alternativeSeedGenerationPossible()/*,\n                         \"Second Mining Step is not available for \"\n                         \"current Algo-Type on these conditions!\" */);\n            }\n\n            // Compute total miner reward amount, then compute this \n            // step's reward later.\n            uint totalMinerRewards = \n                ( ending_profitAmount * cfg.minerProfitShare ) / \n                ( _100PERCENT );\n\n            // Firstly, check if random seed is already obtained.\n            // If not, check if we should generate it locally.\n            if( lotStorage.getRandomSeed() == 0 )\n            {\n                if( alternativeSeedGenerationPossible() )\n                {\n                    // Set random seed inside the Storage Contract,\n                    // but using our contract's transferHashValue as the\n                    // random seed.\n                    // We believe that this hash has enough randomness\n                    // to be considered a fairly good random seed,\n                    // because it has beed chain-computed for every\n                    // token transfer that has occured in ACTIVE stage.\n                    //\n                    lotStorage.setRandomSeed( transferHashValue );\n\n                    // If using Non-Mined algorithm types, reward for this\n                    // step is 20% of miner funds.\n                    if( cfg.endingAlgoType != \n                        uint8(EndingAlgoType.MinedWinnerSelection) )\n                    {\n                        currentStepReward = \n                            ( totalMinerRewards * (20 * PERCENT) ) /\n                            ( _100PERCENT );\n                    }\n                }\n                else\n                {\n                    // If alternative seed generation is not yet possible\n                    // (not enough time passed since the rand.provider\n                    // request was made), then mining is not available\n                    // currently.\n                    require( false/*, \"Mining not yet available!\" */);\n                }\n            }\n\n            // Now, we know that  Random Seed is obtained.\n            // If we use this algo-type, perform the actual\n            // winner selection algorithm.\n            if( cfg.endingAlgoType == uint8(EndingAlgoType.MinedWinnerSelection) )\n            {\n                mine_executeEndingAlgorithmStep();\n\n                // Set the prize amount to SECOND STEP prize amount (90%).\n                currentStepReward = ( totalMinerRewards * (90 * PERCENT) ) /\n                                    ( _100PERCENT );\n            }\n\n            // Now we've completed both Mining Steps, it means MINING stage\n            // is finally completed!\n            // Transition to COMPLETION stage, and set lottery completion\n            // time to NOW.\n\n            lotteryStage = uint8( STAGE.COMPLETION );\n            completionDate = uint32( block.timestamp );\n\n            require( currentStepReward <= totalMinerRewards/*, \"BUG 2007\" */);\n        }\n\n        // Now, transfer the reward to miner!\n        // Check for bugs too - if the computed amount doesn't exceed.\n\n        // Increment the mining step - move to next step (if there is one).\n        miningStep++;\n\n        // Check & Lock the Re-Entrancy Lock for transfers.\n        require( ! reEntrancyMutexLocked/*, \"Re-Entrant call detected!\" */);\n        reEntrancyMutexLocked = true;\n\n        // Finally, transfer the reward to message sender!\n        msg.sender.transfer( currentStepReward );\n\n        // UnLock ReEntrancy Lock.\n        reEntrancyMutexLocked = false;\n    }\n\n\n    /**\n     *  Function computes winner prize amount for winner at rank #N.\n     *  Prerequisites: Must be called only on STAGE.COMPLETION stage,\n     *  because we use the final profits amount here, and that value\n     *  (ending_profitAmount) is known only on COMPLETION stage.\n     *\n     *  @param rankingPosition - ranking position of a winner.\n     *  @return finalPrizeAmount - prize amount, in Wei, of this winner.\n     */\n    function getWinnerPrizeAmount(\n            uint rankingPosition )\n                                                        public view\n    returns( uint finalPrizeAmount )\n    {\n        // Calculate total winner prize fund profit percentage & amount.\n        uint winnerProfitPercentage = \n            (_100PERCENT) - cfg.poolProfitShare - \n            cfg.ownerProfitShare - cfg.minerProfitShare;\n\n        uint totalPrizeAmount =\n            ( ending_profitAmount * winnerProfitPercentage ) /\n            ( _100PERCENT );\n\n\n        // We compute the prize amounts differently for the algo-type\n        // RolledRandomness, because distribution of these prizes is\n        // non-deterministic - multiple holders could fall onto the\n        // same ranking position, due to randomness of rolled score.\n        //\n        if( cfg.endingAlgoType == uint8(EndingAlgoType.RolledRandomness) )\n        {\n            // Here, we'll use Prize Sequence Factor approach differently.\n            // We'll use the prizeSequenceFactor value not to compute\n            // a geometric progression, but to compute an arithmetic\n            // progression, where each ranking position will get a\n            // prize equal to \n            // \"totalPrizeAmount - rankingPosition * singleWinnerShare\"\n            //\n            // singleWinnerShare is computed as a value corresponding\n            // to single-winner's share of total prize amount.\n            //\n            // Using such an approach, winner at rank 0 would get a\n            // prize equal to whole totalPrizeAmount, but, as the\n            // scores are rolled using random factor, it's very unlikely\n            // to get a such high score, so most likely such prize\n            // won't ever be claimed, but it is a possibility.\n            //\n            // Most of the winners in this approach are likely to\n            // roll scores in the middle, so would get prizes equal to\n            // 1-10% of total prize funds.\n\n            uint singleWinnerShare = totalPrizeAmount / \n                                     cfg.prizeSequence_winnerCount;\n\n            return totalPrizeAmount - rankingPosition * singleWinnerShare;\n        }\n\n        // Now, we know that ending algorithm is normal (deterministic).\n        // So, compute the prizes in a standard way.\n\n        // If using Computed Sequence: loop for \"rankingPosition\"\n        // iterations, while computing the prize shares.\n        // If \"rankingPosition\" is larger than sequencedWinnerCount,\n        // then compute the prize from sequence-leftover amount.\n        if( cfg.prizeSequenceFactor != 0 )\n        {\n            require( rankingPosition < cfg.prizeSequence_winnerCount/*,\n                     \"Invalid ranking position!\" */);\n\n            // Leftover: If prizeSequenceFactor is 25%, it's 75%.\n            uint leftoverPercentage = \n                (_100PERCENT) - cfg.prizeSequenceFactor;\n\n            // Loop until the needed iteration.\n            uint loopCount = ( \n                rankingPosition >= cfg.prizeSequence_sequencedWinnerCount ?\n                cfg.prizeSequence_sequencedWinnerCount :\n                rankingPosition\n            );\n\n            for( uint i = 0; i < loopCount; i++ )\n            {\n                totalPrizeAmount = \n                    ( totalPrizeAmount * leftoverPercentage ) /\n                    ( _100PERCENT );\n            }\n\n            // Get end prize amount - sequenced, or leftover.\n            // Leftover-mode.\n            if( loopCount == cfg.prizeSequence_sequencedWinnerCount &&\n                cfg.prizeSequence_winnerCount > \n                cfg.prizeSequence_sequencedWinnerCount )\n            {\n                // Now, totalPrizeAmount equals all leftover-group winner\n                // prize funds.\n                // So, just divide it by number of leftover winners.\n                finalPrizeAmount = \n                    ( totalPrizeAmount ) /\n                    ( cfg.prizeSequence_winnerCount -\n                      cfg.prizeSequence_sequencedWinnerCount );\n            }\n            // Sequenced-mode\n            else\n            {\n                finalPrizeAmount = \n                    ( totalPrizeAmount * cfg.prizeSequenceFactor ) /\n                    ( _100PERCENT );\n            }\n        }\n\n        // Else, if we're using Pre-Specified Array of winner profit\n        // shares, just get the share at the corresponding index.\n        else\n        {\n            require( rankingPosition < cfg.winnerProfitShares.length );\n\n            finalPrizeAmount = \n                ( totalPrizeAmount *\n                  cfg.winnerProfitShares[ rankingPosition ] ) /\n                ( _100PERCENT );\n        }\n    }\n\n\n    /**\n     *  After lottery has completed, this function returns if msg.sender\n     *  is one of lottery winners, and the position in winner rankings.\n     *  \n     *  Function must be used to obtain the ranking position before\n     *  calling claimWinnerPrize().\n     *\n     *  @param addr - address whose status to check.\n     */\n    function getWinnerStatus( address addr )\n                                                        external view\n    returns( bool isWinner, uint32 rankingPosition, \n             uint prizeAmount )\n    {\n        if( !onStage( STAGE.COMPLETION ) || balanceOf( addr ) == 0 )\n            return (false , 0, 0);\n\n        ( isWinner, rankingPosition ) =\n            lotStorage.getWinnerStatus( addr );\n\n        if( isWinner )\n        {\n            prizeAmount = getWinnerPrizeAmount( rankingPosition );\n            if( prizeAmount > address(this).balance )\n                prizeAmount = address(this).balance;\n        }\n    }\n\n\n    /**\n     *  Compute the intermediate Active Stage player score.\n     *  This score is Player Score, not randomized.\n     *  @param addr - address to check.\n     */\n    function getPlayerIntermediateScore( address addr )\n                                                        external view\n    returns( uint )\n    {\n        return lotStorage.getPlayerActiveStageScore( addr );\n    }\n\n\n    /** PAYABLE [ OUT ] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n     *\n     *  Claim the winner prize of msg.sender, if he is one of the winners.\n     *\n     *  This function must be provided a ranking position of msg.sender,\n     *  which must be obtained using the function above.\n     *  \n     *  The Lottery Storage then just checks if holder address in the\n     *  winner array element at position rankingPosition is the same\n     *  as msg.sender's.\n     *\n     *  If so, then claim request is valid, and we can give the appropriate\n     *  prize to that winner.\n     *  Prize can be determined by a computed factor-based sequence, or\n     *  from the pre-specified winner array.\n     *\n     *  * This function transfers Ether out of our contract:\n     *    - Sends the corresponding winner prize to the msg.sender.\n     *\n     *  @param rankingPosition - the position of Winner Array, that\n     *      msg.sender says he is in (obtained using getWinnerStatus).\n     */\n    function claimWinnerPrize(\n            uint32 rankingPosition )\n                                    external\n                                    onlyOnStage( STAGE.COMPLETION )\n                                    mutexLOCKED\n    {\n        // Check if msg.sender hasn't already claimed his prize.\n        require( ! prizeClaimersAddresses[ msg.sender ]/*,\n                 \"msg.sender has already claimed his prize!\" */);\n\n        // msg.sender must have at least some of UniLottery Tokens.\n        require( balanceOf( msg.sender ) != 0/*,\n                 \"msg.sender's token balance can't be zero!\" */);\n\n        // Check if there are any prize funds left yet.\n        require( address(this).balance != 0/*,\n                 \"All prize funds have already been claimed!\" */);\n\n        // If using Mined Selection Algo, check if msg.sender is \n        // really on that ranking position - algo was already executed.\n        if( cfg.endingAlgoType == uint8(EndingAlgoType.MinedWinnerSelection) )\n        {\n            require( lotStorage.minedSelection_isAddressOnWinnerPosition(\n                            msg.sender, rankingPosition )/*,\n                     \"msg.sender is not on specified winner position!\" */);\n        }\n        // For other algorithms, get ranking position by executing\n        // a specific algorithm of that algo-type.\n        else\n        {\n            bool isWinner;\n            ( isWinner, rankingPosition ) =\n                lotStorage.getWinnerStatus( msg.sender );\n\n            require( isWinner/*, \"msg.sender is not a winner!\" */);\n        }\n\n        // Compute the prize amount, using our internal function.\n        uint finalPrizeAmount = getWinnerPrizeAmount( rankingPosition ); \n\n        // If prize is small and computation precision errors occured,\n        // leading it to be larger than our balance, fix it.\n        if( finalPrizeAmount > address(this).balance )\n            finalPrizeAmount = address(this).balance;\n\n\n        // Transfer the Winning Prize to msg.sender!\n        msg.sender.transfer( finalPrizeAmount );\n\n\n        // Mark msg.sender as already claimed his prize.\n        prizeClaimersAddresses[ msg.sender ] = true;\n    }\n\n\n    /** PAYABLE [ OUT ] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n     *\n     *  Transfer the leftover Winner Prize Funds of this contract to the\n     *  Main UniLottery Pool, if prize claim deadline has been exceeded.\n     *\n     *  Function can only be called from the Main Pool, and if some\n     *  winners haven't managed to claim their prizes on time, their\n     *  prizes will go back to UniLottery Pool.\n     *\n     *  * Function transfers Ether out of our contract:\n     *    - Transfer the leftover funds to the Pool (msg.sender).\n     */\n    function getUnclaimedPrizes()\n                                        external\n                                        poolOnly\n                                        onlyOnStage( STAGE.COMPLETION )\n                                        mutexLOCKED\n    {\n        // Check if prize claim deadline has passed.\n        require( completionDate != 0 &&\n                 ( block.timestamp - completionDate ) > cfg.prizeClaimTime/*,\n                 \"Prize claim deadline not reached yet!\" */);\n\n        // Just transfer it all to the Pool.\n        poolAddress.transfer( address(this).balance );\n    }\n\n}\n\n/**\n *  The Lottery Storage contract.\n *\n *  This contract is used to store all Holder Data of a specific lottery\n *  contract - that includes lottery token holders list, and every\n *  holder's intermediate scores (HolderData structure).\n *\n *  When the lottery, that this storage belongs to, ends, then \n *  this Storage contract also performs the whole winner selection\n *  algorithm.\n *\n *  Also, one of this contract's purposes is to split code,\n *  to avoid the 24kb code size limit error.\n *\n *  Notice, that Lottery and LotteryStorage contracts must have a\n *  1:1 relationship - every Lottery has only one Storage, and\n *  every Storage belongs to only one Lottery.\n *\n *  The LotteryStorage contracts are being created from the \n *  LotteryStorageFactory contract, and only after that, the parent\n *  Lottery is created, so Lottery must initialize it's Storage,\n *  by calling initialize() function on freshly-created Storage,\n *  which set's the Lottery address, and locks it.\n */\ncontract LotteryStorage is CoreUniLotterySettings\n{\n    // ==================== Structs & Constants ==================== //\n\n    // Struct of holder data & scores.\n    struct HolderData \n    {\n        // --------- Slot --------- //\n\n        // If this holder provided a valid referral ID, this is the \n        // address of a referrer - the user who generated the said\n        // referral ID.\n        address referrer;\n\n        // Bonus score points, which can be given in certain events,\n        // such as when player registers a valid referral ID.\n        int16 bonusScore;\n\n        // Number of all child referrees, including multi-level ones.\n        // Updated by traversing child->parent way, incrementing\n        // every node's counter by one.\n        // Used in Winner Selection Algorithm, to determine how much\n        // to divide the accumulated referree scores by.\n        uint16 referreeCount;\n\n\n        // --------- Slot --------- //\n\n        // If this holder has generated his own referral ID, this is\n        // that ID. If he hasn't generated an ID, this is zero.\n        uint256 referralID;\n\n\n        // --------- Slot --------- //\n\n        // The intermediate individual score factor variables.\n        // Ether contributed: ( buys - sells ). Can be negative.\n        int40 etherContributed;\n\n        // Time x ether factor: (relativeTxTime * etherAmount).\n        int40 timeFactors;\n\n        // Token balance score factor of this holder - we use int,\n        // for easier computation of player scores in our algorithms.\n        int40 tokenBalance;\n\n        // Accumulated referree score factors - ether contributed by\n        // all referrees, time factors, and token balances of all\n        // referrees.\n        int40 referree_etherContributed;\n        int40 referree_timeFactors;\n        int40 referree_tokenBalance;\n    }\n\n\n    // Final Score (end lottery score * randomValue) structure.\n    struct FinalScore \n    {\n        address addr;           // 20 bytes \\\n        uint16 holderIndex;     // 2 bytes  | = 30 bytes => 1 slot.\n        uint64 score;           // 8 bytes  /\n    }\n\n\n    // Winner Indexes structure - used to efficiently store Winner\n    // indexes in holder's array, after completing the Winner Selection\n    // Algorithm.\n    // To save Space, we store these in a struct, with uint16 array\n    // with 16 items - so this struct takes up excactly 1 slot.\n    struct WinnerIndexStruct\n    {\n        uint16[ 16 ] indexes;\n    }\n\n\n    // A structure which is used by Winner Selection algorithm,\n    // which is a subset of the LotteryConfig structure, containing\n    // only items necessary for executing the Winner Selection algorigm.\n    // More detailed member description can be found in LotteryConfig\n    // structure description.\n    // Takes up only one slot!\n    struct WinnerAlgorithmConfig\n    {\n        // --------- Slot --------- //\n\n        // Individual player max score parts.\n        int16 maxPlayerScore_etherContributed;\n        int16 maxPlayerScore_tokenHoldingAmount;\n        int16 maxPlayerScore_timeFactor;\n        int16 maxPlayerScore_refferalBonus;\n\n        // Number of lottery winners.\n        uint16 winnerCount;\n\n        // Score-To-Random ration data (as a rational ratio number).\n        // For example if 1:5, then scorePart = 1, and randPart = 5.\n        uint16 randRatio_scorePart;\n        uint16 randRatio_randPart;\n\n        // The Ending Algorithm type.\n        uint8 endingAlgoType;\n    }\n\n\n    // Structure containing the minimum and maximum values of\n    // holder intermediate scores.\n    // These values get updated on transfers during ACTIVE stage,\n    // when holders buy/sell tokens.\n    //\n    // Used in winner selection algorithm, to normalize the scores in\n    // a single loop, to avoid looping additional time to find min/max.\n    //\n    // Structure takes up only a single slot!\n    //\n    struct MinMaxHolderScores\n    {\n        // --------- Slot --------- //\n\n        int40 holderScore_etherContributed_min;\n        int40 holderScore_etherContributed_max;\n\n        int40 holderScore_timeFactors_min;\n        int40 holderScore_timeFactors_max;\n\n        int40 holderScore_tokenBalance_min;\n        int40 holderScore_tokenBalance_max;\n    }\n\n    // Referral score variant of the structure above.\n    // Also, only a single slot!\n    //\n    struct MinMaxReferralScores\n    {\n        // --------- Slot --------- //\n\n        // Min&Max values for referrer scores.\n        int40 referralScore_etherContributed_min;\n        int40 referralScore_etherContributed_max;\n\n        int40 referralScore_timeFactors_min;\n        int40 referralScore_timeFactors_max;\n\n        int40 referralScore_tokenBalance_min;\n        int40 referralScore_tokenBalance_max;\n    }\n\n    // ROOT_REFERRER constant.\n    // Used to prevent cyclic dependencies on referral tree.\n    address constant ROOT_REFERRER = address( 1 );\n\n    // Max referral tree depth - maximum number of referrees that\n    // a referrer can get.\n    uint constant MAX_REFERRAL_DEPTH = 10;\n\n    // Precision of division operations.\n    int constant PRECISION = 10000;\n\n    // Random number modulo to use when obtaining random numbers from\n    // the random seed + nonce, using keccak256.\n    // This is the maximum available Score Random Factor, plus one.\n    // By default, 10^9 (one billion).\n    //\n    uint constant RANDOM_MODULO = (10 ** 9);\n\n    // Maximum number of holders that the MinedWinnerSelection algorithm\n    // can process. Related to block gas limit.\n    uint constant MINEDSELECTION_MAX_NUMBER_OF_HOLDERS = 300;\n\n    // Maximum number of holders that the WinnerSelfValidation algorithm\n    // can process. Related to block gas limit.\n    uint constant SELFVALIDATION_MAX_NUMBER_OF_HOLDERS = 1200;\n\n\n    // ==================== State Variables ==================== //\n\n    // --------- Slot --------- //\n\n    // The Lottery address that this storage belongs to.\n    // Is set by the \"initialize()\", called by corresponding Lottery.\n    address lottery;\n\n    // The Random Seed, that was passed to us from Randomness Provider,\n    // or generated alternatively.\n    uint64 randomSeed;\n\n    // The actual number of winners that there will be. Set after\n    // completing the Winner Selection Algorithm.\n    uint16 numberOfWinners;\n\n    // Bool indicating if Winner Selection Algorithm has been executed.\n    bool algorithmCompleted;\n\n\n    // --------- Slot --------- //\n\n    // Winner Algorithm config. Specified in Initialization().\n    WinnerAlgorithmConfig algConfig;\n\n    // --------- Slot --------- //\n\n    // The Min-Max holder score storage.\n    MinMaxHolderScores public minMaxScores;\n    MinMaxReferralScores public minMaxReferralScores;\n\n    // --------- Slot --------- //\n\n    // Array of holders.\n    address[] public holders;\n\n    // --------- Slot --------- //\n\n    // Holder array indexes mapping, for O(1) array element access.\n    mapping( address => uint ) holderIndexes;\n\n    // --------- Slot --------- //\n\n    // Mapping of holder data.\n    mapping( address => HolderData ) public holderData;\n\n    // --------- Slot --------- //\n\n    // Mapping of referral IDs to addresses of holders who generated\n    // those IDs.\n    mapping( uint256 => address ) referrers;\n\n    // --------- Slot --------- //\n\n    // The array of final-sorted winners (set after Winner Selection\n    // Algorithm completes), that contains the winners' indexes\n    // in the \"holders\" array, to save space.\n    //\n    // Notice that by using uint16, we can fit 16 items into one slot!\n    // So, if there are 160 winners, we only take up 10 slots, so\n    // only 20,000 * 10 = 200,000 gas gets consumed!\n    //\n    WinnerIndexStruct[] sortedWinnerIndexes;\n\n\n\n    // ==============       Internal (Private) Functions    ============== //\n\n    // Lottery-Only modifier.\n    modifier lotteryOnly\n    {\n        require( msg.sender == address( lottery )/*,\n                 \"Function can only be called by Lottery that this\"\n                 \"Storage Contract belongs to!\" */);\n        _;\n    }\n\n\n    // ============== [ BEGIN ] LOTTERY QUICKSORT FUNCTIONS ============== //\n\n    /**\n     *  QuickSort and QuickSelect algorithm functionality code.\n     *\n     *  These algorithms are used to find the lottery winners in\n     *  an array of final random-factored scores.\n     *  As the highest-scorers win, we need to sort an array to\n     *  identify them.\n     *\n     *  For this task, we use QuickSelect to partition array into\n     *  winner part (elements with score larger than X, where X is\n     *  n-th largest element, where n is number of winners),\n     *  and others (non-winners), who are ignored to save computation\n     *  power.\n     *  Then we sort the winner part only, using QuickSort, and\n     *  distribute prizes to winners accordingly.\n     */\n\n    // Swap function used in QuickSort algorithms.\n    //\n    function QSort_swap( FinalScore[] memory list, \n                         uint a, uint b )               \n                                                        internal pure\n    {\n        FinalScore memory tmp = list[ a ];\n        list[ a ] = list[ b ];\n        list[ b ] = tmp;\n    }\n\n    // Standard Hoare's partition scheme function, used for both\n    // QuickSort and QuickSelect.\n    //\n    function QSort_partition( \n            FinalScore[] memory list, \n            int lo, int hi )\n                                                        internal pure\n    returns( int newPivotIndex )\n    {\n        uint64 pivot = list[ uint( hi + lo ) / 2 ].score;\n        int i = lo - 1;\n        int j = hi + 1;\n\n        while( true ) \n        {\n            do {\n                i++;\n            } while( list[ uint( i ) ].score > pivot ) ;\n\n            do {\n                j--;\n            } while( list[ uint( j ) ].score < pivot ) ;\n\n            if( i >= j )\n                return j;\n\n            QSort_swap( list, uint( i ), uint( j ) );\n        }\n    }\n\n    // QuickSelect's Lomuto partition scheme.\n    //\n    function QSort_LomutoPartition(\n            FinalScore[] memory list,\n            uint left, uint right, uint pivotIndex )\n                                                        internal pure\n    returns( uint newPivotIndex )\n    {\n        uint pivotValue = list[ pivotIndex ].score;\n        QSort_swap( list, pivotIndex, right );  // Move pivot to end\n        uint storeIndex = left;\n        \n        for( uint i = left; i < right; i++ )\n        {\n            if( list[ i ].score > pivotValue ) {\n                QSort_swap( list, storeIndex, i );\n                storeIndex++;\n            }\n        }\n\n        // Move pivot to its final place, and return the pivot's index.\n        QSort_swap( list, right, storeIndex );\n        return storeIndex;\n    }\n\n    // QuickSelect algorithm (iterative).\n    //\n    function QSort_QuickSelect(\n            FinalScore[] memory list,\n            int left, int right, int k )\n                                                        internal pure\n    returns( int indexOfK )\n    {\n        while( true ) {\n            if( left == right )\n                return left;\n\n            int pivotIndex = int( QSort_LomutoPartition( list, \n                    uint(left), uint(right), uint(right) ) );\n\n            if( k == pivotIndex )\n                return k;\n            else if( k < pivotIndex )\n                right = pivotIndex - 1;\n            else\n                left = pivotIndex + 1;\n        }\n    }\n\n    // Standard QuickSort function.\n    //\n    function QSort_QuickSort(\n            FinalScore[] memory list,\n            int lo, int hi )\n                                                        internal pure\n    {\n        if( lo < hi ) {\n            int p = QSort_partition( list, lo, hi );\n            QSort_QuickSort( list, lo, p );\n            QSort_QuickSort( list, p + 1, hi );\n        }\n    }\n\n    // ============== [ END ]   LOTTERY QUICKSORT FUNCTIONS ============== //\n\n    // ------------ Ending Stage - Winner Selection Algorithm ------------ //\n\n    /**\n     *  Compute the individual player score factors for a holder.\n     *  Function split from the below one (ending_Stage_2), to avoid\n     *  \"Stack too Deep\" errors.\n     */\n    function computeHolderIndividualScores( \n            WinnerAlgorithmConfig memory cfg,\n            MinMaxHolderScores memory minMax,\n            HolderData memory hdata )\n                                                        internal pure\n    returns( int individualScore )\n    {\n        // Normalize the scores, by subtracting minimum and dividing\n        // by maximum, to get the score values specified in cfg.\n        // Use precision of 100, then round.\n        //\n        // Notice that we're using int arithmetics, so division \n        // truncates. That's why we use PRECISION, to simulate\n        // rounding.\n        //\n        // This formula is better explained in example.\n        // In this example, we use variable abbreviations defined\n        // below, on formula's right side comments.\n        //\n        // Say, values are these in our example:\n        // e = 4, eMin = 1, eMax = 8, MS = 5, P = 10.\n        //\n        // So, let's calculate the score using the formula:\n        // ( ( ( (4 - 1) * 10 * 5 ) / (8 - 1) ) + (10 / 2) ) / 10 =\n        // ( ( (    3    * 10 * 5 ) /    7    ) +     5    ) / 10 =\n        // ( (         150          /    7    ) +     5    ) / 10 =\n        // ( (         150          /    7    ) +     5    ) / 10 =\n        // (                    20              +     5    ) / 10 =\n        //                          25                       / 10 =\n        //                        [ 2.5 ]                         = 2\n        //\n        // So, with truncation, we see that for e = 4, the score\n        // is 2 out of 5 maximum.\n        // That's because the minimum ether contributed was 1, and\n        // maximum was 8.\n        // So, 4 stays below the middle, and gets a nicely rounded \n        // score of 2.\n\n        // Compute etherContributed.\n        int score_etherContributed = ( (\n            ( int( hdata.etherContributed -                      // e\n                   minMax.holderScore_etherContributed_min )     // eMin\n              * PRECISION * cfg.maxPlayerScore_etherContributed )// P * MS\n            / int( minMax.holderScore_etherContributed_max -     // eMax\n                   minMax.holderScore_etherContributed_min )     // eMin\n        ) + (PRECISION / 2) ) / PRECISION;\n\n        // Compute timeFactors.\n        int score_timeFactors = ( (\n            ( int( hdata.timeFactors -                          // e\n                   minMax.holderScore_timeFactors_min )         // eMin\n              * PRECISION * cfg.maxPlayerScore_timeFactor )     // P * MS\n            / int( minMax.holderScore_timeFactors_max -         // eMax\n                   minMax.holderScore_timeFactors_min )         // eMin\n        ) + (PRECISION / 2) ) / PRECISION;\n\n        // Compute tokenBalance.\n        int score_tokenBalance = ( (\n            ( int( hdata.tokenBalance -                         // e\n                   minMax.holderScore_tokenBalance_min )        // eMin\n              * PRECISION * cfg.maxPlayerScore_tokenHoldingAmount )\n            / int( minMax.holderScore_tokenBalance_max -        // eMax\n                   minMax.holderScore_tokenBalance_min )        // eMin\n        ) + (PRECISION / 2) ) / PRECISION;\n\n        // Return the accumulated individual score (excluding referrees).\n        return score_etherContributed + score_timeFactors +\n               score_tokenBalance;\n    }\n\n\n    /**\n     *  Compute the unified Referree-Score of a player, who's got\n     *  the accumulated factor-scores of all his referrees in his \n     *  holderData structure.\n     *\n     *  @param individualToReferralRatio - an int value, computed \n     *      before starting the winner score computation loop, in \n     *      the ending_Stage_2 initial part, to save computation\n     *      time later.\n     *      This is the ratio of the maximum available referral score,\n     *      to the maximum available individual score, as defined in\n     *      the config (for example, if max.ref.score is 20, and \n     *      max.ind.score is 40, then the ratio is 20/40 = 0.5).\n     *      \n     *      We use this ratio to transform the computed accumulated\n     *      referree individual scores to the standard referrer's\n     *      score, by multiplying by that ratio.\n     */\n    function computeReferreeScoresForHolder( \n            int individualToReferralRatio,\n            WinnerAlgorithmConfig memory cfg,\n            MinMaxReferralScores memory minMax,\n            HolderData memory hdata )\n                                                        internal pure\n    returns( int unifiedReferreeScore )\n    {\n        // If number of referrees of this HODLer is Zero, then\n        // his referree score is also zero.\n        if( hdata.referreeCount == 0 )\n            return 0;\n\n        // Now, compute the Referree's Accumulated Scores.\n        //\n        // Here we use the same formula as when computing individual\n        // scores (in the function above), but we use referree parts\n        // instead.\n\n        // Compute etherContributed.\n        int referreeScore_etherContributed = ( (\n            ( int( hdata.referree_etherContributed -\n                   minMax.referralScore_etherContributed_min )\n              * PRECISION * cfg.maxPlayerScore_etherContributed )\n            / int( minMax.referralScore_etherContributed_max -\n                   minMax.referralScore_etherContributed_min )\n        ) );\n\n        // Compute timeFactors.\n        int referreeScore_timeFactors = ( (\n            ( int( hdata.referree_timeFactors -\n                   minMax.referralScore_timeFactors_min )\n              * PRECISION * cfg.maxPlayerScore_timeFactor )\n            / int( minMax.referralScore_timeFactors_max -\n                   minMax.referralScore_timeFactors_min )\n        ) );\n\n        // Compute tokenBalance.\n        int referreeScore_tokenBalance = ( (\n            ( int( hdata.referree_tokenBalance -\n                   minMax.referralScore_tokenBalance_min )\n              * PRECISION * cfg.maxPlayerScore_tokenHoldingAmount )\n            / int( minMax.referralScore_tokenBalance_max -\n                   minMax.referralScore_tokenBalance_min )\n        ) );\n\n\n        // Accumulate 'em all !\n        // Then, multiply it by the ratio of all individual max scores\n        // (maxPlayerScore_etherContributed, timeFactor, tokenBalance),\n        // to the maxPlayerScore_refferalBonus.\n        // Use the same precision.\n        unifiedReferreeScore = int( ( (\n                ( ( referreeScore_etherContributed +\n                    referreeScore_timeFactors +\n                    referreeScore_tokenBalance ) + (PRECISION / 2)\n                ) / PRECISION\n            ) * individualToReferralRatio\n        ) / PRECISION );\n    }\n\n\n    /**\n     *  Update Min & Max values for individual holder scores.\n     */\n    function priv_updateMinMaxScores_individual(\n            MinMaxHolderScores memory minMax,\n            int40 _etherContributed,\n            int40 _timeFactors,\n            int40 _tokenBalance )\n                                                    internal\n                                                    pure\n    {\n        // etherContributed:\n        if( _etherContributed > \n            minMax.holderScore_etherContributed_max )\n            minMax.holderScore_etherContributed_max = \n                _etherContributed;\n\n        if( _etherContributed <\n            minMax.holderScore_etherContributed_min )\n            minMax.holderScore_etherContributed_min = \n                _etherContributed;\n\n        // timeFactors:\n        if( _timeFactors > \n            minMax.holderScore_timeFactors_max )\n            minMax.holderScore_timeFactors_max = \n                _timeFactors;\n\n        if( _timeFactors <\n            minMax.holderScore_timeFactors_min )\n            minMax.holderScore_timeFactors_min = \n                _timeFactors;\n\n        // tokenBalance:\n        if( _tokenBalance > \n            minMax.holderScore_tokenBalance_max )\n            minMax.holderScore_tokenBalance_max = \n                _tokenBalance;\n\n        if( _tokenBalance <\n            minMax.holderScore_tokenBalance_min )\n            minMax.holderScore_tokenBalance_min = \n                _tokenBalance;\n    }\n\n\n    /**\n     *  Update Min & Max values for referral scores.\n     */\n    function priv_updateMinMaxScores_referral(\n            MinMaxReferralScores memory minMax,\n            int40 _etherContributed,\n            int40 _timeFactors,\n            int40 _tokenBalance )\n                                                    internal\n                                                    pure\n    {\n        // etherContributed:\n        if( _etherContributed > \n            minMax.referralScore_etherContributed_max )\n            minMax.referralScore_etherContributed_max = \n                _etherContributed;\n\n        if( _etherContributed <\n            minMax.referralScore_etherContributed_min )\n            minMax.referralScore_etherContributed_min = \n                _etherContributed;\n\n        // timeFactors:\n        if( _timeFactors > \n            minMax.referralScore_timeFactors_max )\n            minMax.referralScore_timeFactors_max = \n                _timeFactors;\n\n        if( _timeFactors <\n            minMax.referralScore_timeFactors_min )\n            minMax.referralScore_timeFactors_min = \n                _timeFactors;\n\n        // tokenBalance:\n        if( _tokenBalance > \n            minMax.referralScore_tokenBalance_max )\n            minMax.referralScore_tokenBalance_max = \n                _tokenBalance;\n\n        if( _tokenBalance <\n            minMax.referralScore_tokenBalance_min )\n            minMax.referralScore_tokenBalance_min = \n                _tokenBalance;\n    }\n\n\n\n    // =================== PUBLIC FUNCTIONS =================== //\n\n    /**\n     *  Update current holder's score with given change values, and\n     *  Propagate the holder's current transfer's score changes\n     *  through the referral chain, updating every parent referrer's\n     *  accumulated referree scores, until the ROOT_REFERRER or zero\n     *  address referrer is encountered.\n     */\n    function updateAndPropagateScoreChanges(\n            address holder,\n            int __etherContributed_change,\n            int __timeFactors_change,\n            int __tokenBalance_change )\n                                                        public\n                                                        lotteryOnly\n    {\n        // Convert the data into shrinked format - leave only\n        // 4 decimals of Ether precision, and drop the decimal part\n        // of ULT tokens absolutely.\n        // Don't change TimeFactors, as it is already adjusted in\n        // Lottery contract's code.\n        int40 timeFactors_change = int40( __timeFactors_change );\n\n        int40 etherContributed_change = int40(\n            __etherContributed_change / int(1 ether / 10000) );\n \n        int40 tokenBalance_change = int40(\n            __tokenBalance_change / int(1 ether) );\n\n        // Update current holder's score.\n        holderData[ holder ].etherContributed += etherContributed_change;\n        holderData[ holder ].timeFactors += timeFactors_change;\n        holderData[ holder ].tokenBalance += tokenBalance_change;\n\n        // Check if scores are exceeding current min/max scores, \n        // and if so, update the min/max scores.\n        MinMaxHolderScores memory minMaxCpy = minMaxScores;\n        MinMaxReferralScores memory minMaxRefCpy = minMaxReferralScores;\n\n        priv_updateMinMaxScores_individual(\n            minMaxCpy,\n            holderData[ holder ].etherContributed,\n            holderData[ holder ].timeFactors,\n            holderData[ holder ].tokenBalance\n        );\n\n        // Propagate the score through the referral chain.\n        // Dive at maximum to the depth of 10, to avoid \"Outta Gas\"\n        // errors.\n        uint depth = 0;\n        address referrerAddr = holderData[ holder ].referrer;\n\n        while( referrerAddr != ROOT_REFERRER && \n               referrerAddr != address( 0 )  &&\n               depth < MAX_REFERRAL_DEPTH )\n        {\n            // Update this referrer's accumulated referree scores.\n            holderData[ referrerAddr ].referree_etherContributed +=\n                etherContributed_change;\n\n            holderData[ referrerAddr ].referree_timeFactors +=\n                timeFactors_change;\n\n            holderData[ referrerAddr ].referree_tokenBalance +=\n                tokenBalance_change;\n\n            // Update MinMax according to this referrer's score.\n            priv_updateMinMaxScores_referral(\n                minMaxRefCpy,\n                holderData[ referrerAddr ].referree_etherContributed,\n                holderData[ referrerAddr ].referree_timeFactors,\n                holderData[ referrerAddr ].referree_tokenBalance\n            );\n\n            // Move to the higher-level referrer.\n            referrerAddr = holderData[ referrerAddr ].referrer;\n            depth++;\n        }\n\n        // Check if MinMax have changed. If so, update it.\n        if( keccak256( abi.encode( minMaxCpy ) ) != \n            keccak256( abi.encode( minMaxScores ) ) )\n            minMaxScores = minMaxCpy;\n\n        // Check referral part.\n        if( keccak256( abi.encode( minMaxRefCpy ) ) != \n            keccak256( abi.encode( minMaxReferralScores ) ) )\n            minMaxReferralScores = minMaxRefCpy;\n    }\n\n\n    /**\n     *  Pure function to fix an in-memory copy of MinMaxScores,\n     *  by changing equal min-max pairs to differ by one.\n     *  This is needed to avoid division-by-zero in some calculations.\n     */\n    function priv_fixMinMaxIfEqual(\n            MinMaxHolderScores memory minMaxCpy,\n            MinMaxReferralScores memory minMaxRefCpy )\n                                                            internal\n                                                            pure\n    {\n        // Individual part\n        if( minMaxCpy.holderScore_etherContributed_min ==\n            minMaxCpy.holderScore_etherContributed_max )\n            minMaxCpy.holderScore_etherContributed_max =\n            minMaxCpy.holderScore_etherContributed_min + 1;\n\n        if( minMaxCpy.holderScore_timeFactors_min ==\n            minMaxCpy.holderScore_timeFactors_max )\n            minMaxCpy.holderScore_timeFactors_max =\n            minMaxCpy.holderScore_timeFactors_min + 1;\n\n        if( minMaxCpy.holderScore_tokenBalance_min ==\n            minMaxCpy.holderScore_tokenBalance_max )\n            minMaxCpy.holderScore_tokenBalance_max =\n            minMaxCpy.holderScore_tokenBalance_min + 1;\n\n        // Referral part\n        if( minMaxRefCpy.referralScore_etherContributed_min ==\n            minMaxRefCpy.referralScore_etherContributed_max )\n            minMaxRefCpy.referralScore_etherContributed_max =\n            minMaxRefCpy.referralScore_etherContributed_min + 1;\n\n        if( minMaxRefCpy.referralScore_timeFactors_min ==\n            minMaxRefCpy.referralScore_timeFactors_max )\n            minMaxRefCpy.referralScore_timeFactors_max =\n            minMaxRefCpy.referralScore_timeFactors_min + 1;\n\n        if( minMaxRefCpy.referralScore_tokenBalance_min ==\n            minMaxRefCpy.referralScore_tokenBalance_max )\n            minMaxRefCpy.referralScore_tokenBalance_max =\n            minMaxRefCpy.referralScore_tokenBalance_min + 1;\n    }\n\n\n    /** \n     *  Function executes the Lottery Winner Selection Algorithm,\n     *  and writes the final, sorted array, containing winner rankings.\n     *\n     *  This function is called from the Lottery's Mining Stage Step 2,\n     *\n     *  This is the final function that lottery performs actively - \n     *  and arguably the most important - because it determines \n     *  lottery winners through Winner Selection Algorithm.\n     *\n     *  The random seed must be already set, before calling this function.\n     */\n    function executeWinnerSelectionAlgorithm()\n                                                        public\n                                                        lotteryOnly\n    {\n        // Copy the Winner Algo Config into memory, to avoid using\n        // 400-gas costing SLOAD every time we need to load something.\n        WinnerAlgorithmConfig memory cfg = algConfig;\n\n        // Can only be performed if algorithm is MinedWinnerSelection!\n        require( cfg.endingAlgoType ==\n                 uint8(Lottery.EndingAlgoType.MinedWinnerSelection)/*,\n                 \"Algorithm cannot be performed on current Algo-Type!\" */);\n\n        // Now, we gotta find the winners using a Randomized Score-Based\n        // Winner Selection Algorithm.\n        //\n        // During transfers, all player intermediate scores \n        // (etherContributed, timeFactors, and tokenBalances) were\n        // already set in every holder's HolderData structure,\n        // during operations of updateHolderData_preTransfer() function.\n        //\n        // Minimum and maximum values are also known, so normalization\n        // will be easy.\n        // All referral tree score data were also properly propagated\n        // during operations of updateAndPropagateScoreChanges() function.\n        //\n        // All we block.timestamp have to do, is loop through holder array, and\n        // compute randomized final scores for every holder, into\n        // the Final Score array.\n\n        // Declare the Final Score array - computed for all holders.\n        uint ARRLEN = \n            ( holders.length > MINEDSELECTION_MAX_NUMBER_OF_HOLDERS ?\n              MINEDSELECTION_MAX_NUMBER_OF_HOLDERS : holders.length );\n\n        FinalScore[] memory finalScores = new FinalScore[] ( ARRLEN );\n\n        // Compute the precision-adjusted constant ratio of \n        // referralBonus max score to the player individual max scores.\n\n        int individualToReferralRatio = \n            ( PRECISION * cfg.maxPlayerScore_refferalBonus ) /\n            ( int( cfg.maxPlayerScore_etherContributed ) + \n              int( cfg.maxPlayerScore_timeFactor ) +\n              int( cfg.maxPlayerScore_tokenHoldingAmount ) );\n\n        // Max available player score.\n        int maxAvailablePlayerScore = int(\n                cfg.maxPlayerScore_etherContributed + \n                cfg.maxPlayerScore_timeFactor +\n                cfg.maxPlayerScore_tokenHoldingAmount +\n                cfg.maxPlayerScore_refferalBonus );\n\n\n        // Random Factor of scores, to maintain random-to-determined\n        // ratio equal to specific value (1:5 for example - \n        // \"randPart\" == 5/*, \"scorePart\" */== 1).\n        //\n        // maxAvailablePlayerScore * FACT   ---   scorePart\n        // RANDOM_MODULO                    ---   randPart\n        //\n        //                                  RANDOM_MODULO * scorePart\n        // maxAvailablePlayerScore * FACT = -------------------------\n        //                                          randPart\n        //\n        //              RANDOM_MODULO * scorePart\n        // FACT = --------------------------------------\n        //          randPart * maxAvailablePlayerScore\n\n        int SCORE_RAND_FACT =\n            ( PRECISION * int(RANDOM_MODULO * cfg.randRatio_scorePart) ) /\n            ( int(cfg.randRatio_randPart) * maxAvailablePlayerScore );\n\n\n        // Fix Min-Max scores, to avoid division by zero, if min == max.\n        // If min == max, make the difference equal to 1.\n        MinMaxHolderScores memory minMaxCpy = minMaxScores;\n        MinMaxReferralScores memory minMaxRefCpy = minMaxReferralScores;\n\n        priv_fixMinMaxIfEqual( minMaxCpy, minMaxRefCpy );\n\n        // Loop through all the holders.\n        for( uint i = 0; i < ARRLEN; i++ )\n        {\n            // Fetch the needed holder data to in-memory hdata variable,\n            // to save gas on score part computing functions.\n            HolderData memory hdata;\n\n            // Slot 1:\n            hdata.etherContributed =\n                holderData[ holders[ i ] ].etherContributed;\n            hdata.timeFactors =\n                holderData[ holders[ i ] ].timeFactors;\n            hdata.tokenBalance =\n                holderData[ holders[ i ] ].tokenBalance;\n            hdata.referreeCount =\n                holderData[ holders[ i ] ].referreeCount;\n\n            // Slot 2:\n            hdata.referree_etherContributed =\n                holderData[ holders[ i ] ].referree_etherContributed;\n            hdata.referree_timeFactors =\n                holderData[ holders[ i ] ].referree_timeFactors;\n            hdata.referree_tokenBalance =\n                holderData[ holders[ i ] ].referree_tokenBalance;\n            hdata.bonusScore =\n                holderData[ holders[ i ] ].bonusScore;\n\n\n            // Now, add bonus score, and compute total player's score:\n            // Bonus part, individual score part, and referree score part.\n            int totalPlayerScore = \n                    hdata.bonusScore\n                    +\n                    computeHolderIndividualScores(\n                        cfg, minMaxCpy, hdata )\n                    +\n                    computeReferreeScoresForHolder( \n                        individualToReferralRatio, cfg, \n                        minMaxRefCpy, hdata );\n\n\n            // Check if total player score <= 0. If so, make it equal\n            // to 1, because otherwise randomization won't be possible.\n            if( totalPlayerScore <= 0 )\n                totalPlayerScore = 1;\n\n            // Now, check if it's not more than max! If so, lowerify.\n            // This could have happen'd because of bonus.\n            if( totalPlayerScore > maxAvailablePlayerScore )\n                totalPlayerScore = maxAvailablePlayerScore;\n\n\n            // Multiply the score by the Random Modulo Adjustment\n            // Factor, to get fairer ratio of random-to-determined data.\n            totalPlayerScore =  ( totalPlayerScore * SCORE_RAND_FACT ) /\n                                ( PRECISION );\n\n            // Score is computed!\n            // Now, randomize it, and add to Final Scores Array.\n            // We use keccak to generate a random number from random seed,\n            // using holder's address as a nonce.\n\n            uint modulizedRandomNumber = uint(\n                keccak256( abi.encodePacked( randomSeed, holders[ i ] ) )\n            ) % RANDOM_MODULO;\n\n            // Add the random number, to introduce the random factor.\n            // Ratio of (current) totalPlayerScore to modulizedRandomNumber\n            // is the same as ratio of randRatio_scorePart to \n            // randRatio_randPart.\n\n            uint endScore = uint( totalPlayerScore ) + modulizedRandomNumber;\n\n            // Finally, set this holder's final score data.\n            finalScores[ i ].addr = holders[ i ];\n            finalScores[ i ].holderIndex = uint16( i );\n            finalScores[ i ].score = uint64( endScore );\n        }\n\n        // All final scores are block.timestamp computed.\n        // Sort the array, to find out the highest scores!\n\n        // Firstly, partition an array to only work on top K scores,\n        // where K is the number of winners.\n        // There can be a rare case where specified number of winners is\n        // more than lottery token holders. We got that covered.\n\n        require( finalScores.length > 0 );\n\n        uint K = cfg.winnerCount - 1;\n        if( K > finalScores.length-1 )\n            K = finalScores.length-1;   // Must be THE LAST ELEMENT's INDEX.\n\n        // Use QuickSelect to do this.\n        QSort_QuickSelect( finalScores, 0, \n            int( finalScores.length - 1 ), int( K ) );\n\n        // Now, QuickSort only the first K items, because the rest\n        // item scores are not high enough to become winners.\n        QSort_QuickSort( finalScores, 0, int( K ) );\n\n        // Now, the winner array is sorted, with the highest scores\n        // sitting at the first positions!\n        // Let's set up the winner indexes array, where we'll store\n        // the winners' indexes in the holders array.\n        // So, if this array is [8, 2, 3], that means that\n        // Winner #1 is holders[8], winner #2 is holders[2], and\n        // winner #3 is holders[3].\n\n        // Set the Number Of Winners variable.\n        numberOfWinners = uint16( K + 1 );\n\n        // Now, we can loop through the first numberOfWinners elements, to set\n        // the holder indexes!\n        // Loop through 16 elements at a time, to fill the structs.\n        for( uint offset = 0; offset < numberOfWinners; offset += 16 )\n        {\n            WinnerIndexStruct memory windStruct;\n            uint loopStop = ( offset + 16 > numberOfWinners ?\n                              numberOfWinners : offset + 16 );\n\n            for( uint i = offset; i < loopStop; i++ )\n            {\n                windStruct.indexes[ i - offset ] =finalScores[ i ].holderIndex;\n            }\n\n            // Push this block.timestamp-filled struct to the storage array!\n            sortedWinnerIndexes.push( windStruct );\n        }\n\n        // That's it! We're done!\n        algorithmCompleted = true;\n    }\n\n\n    /**\n     *  Add a holder to holders array.\n     *  @param holder   - address of a holder to add.\n     */\n    function addHolder( address holder )\n                                                        public\n                                                        lotteryOnly\n    {\n        // Add it to list, and set index in the mapping.\n        holders.push( holder );\n        holderIndexes[ holder ] = holders.length - 1;\n    }\n\n    /**\n     *  Removes the holder 'sender' from the Holders Array.\n     *  However, this holder's HolderData structure persists!\n     *\n     *  Notice that no index validity checks are performed, so, if\n     *  'sender' is not present in \"holderIndexes\" mapping, this\n     *  function will remove the 0th holder instead!\n     *  This is not a problem for us, because Lottery calls this\n     *  function only when it's absolutely certain that 'sender' is\n     *  present in the holders array.\n     *\n     *  @param sender   - address of a holder to remove.\n     *      Named 'sender', because when token sender sends away all\n     *      his tokens, he must then be removed from holders array.\n     */\n    function removeHolder( address sender )\n                                                        public\n                                                        lotteryOnly\n    {\n        // Get index of the sender address in the holders array.\n        uint index = holderIndexes[ sender ];\n\n        // Remove the sender from array, by copying last element's\n        // value into the index'th element, where sender was before.\n        holders[ index ] = holders[ holders.length - 1 ];\n\n        // Remove the last element of array, which we've just copied.\n        holders.pop();\n\n        // Update indexes: remove the sender's index from the mapping,\n        // and change the previoulsy-last element's index to the\n        // one where we copied it - where sender was before.\n        delete holderIndexes[ sender ];\n        holderIndexes[ holders[ index ] ] = index;\n    }\n\n\n    /**\n     *  Get holder array length.\n     */\n    function getHolderCount()\n                                                    public view\n    returns( uint )\n    {\n        return holders.length;\n    }\n\n\n    /**\n     *  Generate a referral ID for a token holder.\n     *  Referral ID is used to refer other wallets into playing our\n     *  lottery.\n     *  - Referrer gets bonus points for every wallet that bought \n     *    lottery tokens and specified his referral ID.\n     *  - Referrees (wallets who got referred by registering a valid\n     *    referral ID, corresponding to some referrer), get some\n     *    bonus points for specifying (registering) a referral ID.\n     *\n     *  Referral ID is a uint256 number, which is generated by\n     *  keccak256'ing the holder's address, holder's current\n     *  token ballance, and current time.\n     */\n    function generateReferralID( address holder )\n                                                            public\n                                                            lotteryOnly\n    returns( uint256 referralID )\n    {\n        // Check if holder has some tokens, and doesn't\n        // have his own referral ID yet.\n        require( holderData[ holder ].tokenBalance != 0/*,\n                 \"holder doesn't have any lottery tokens!\" */);\n\n        require( holderData[ holder ].referralID == 0/*,\n                 \"Holder already has a referral ID!\" */);\n\n        // Generate a referral ID with keccak.\n        uint256 refID = uint256( keccak256( abi.encodePacked( \n                holder, holderData[ holder ].tokenBalance, block.timestamp ) ) );\n\n        // Specify the ID as current ID of this holder.\n        holderData[ holder ].referralID = refID;\n\n        // If this holder wasn't referred by anyone (his referrer is\n        // not set), and he's block.timestamp generated his own ID, he won't\n        // be able to register as a referree of someone else \n        // from block.timestamp on.\n        // This is done to prevent circular dependency in referrals.\n        // Do it by setting a referrer to ROOT_REFERRER address,\n        // which is an invalid address (address(1)).\n        if( holderData[ holder ].referrer == address( 0 ) )\n            holderData[ holder ].referrer = ROOT_REFERRER;\n\n        // Create a new referrer with this ID.\n        referrers[ refID ] = holder;\n        \n        return refID;\n    }\n\n\n    /**\n     *  Register a referral for a token holder, using a valid\n     *  referral ID got from a referrer.\n     *  This function is called by a referree, who obtained a\n     *  valid referral ID from some referrer, who previously\n     *  generated it using generateReferralID().\n     *\n     *  You can only register a referral once!\n     *  When you do so, you get bonus referral points!\n     */\n    function registerReferral(\n            address holder,\n            int16 referralRegisteringBonus,\n            uint256 referralID )\n                                                            public\n                                                            lotteryOnly\n    returns( address _referrerAddress )\n    {\n        // Check if this holder has some tokens, and if he hasn't\n        // registered a referral yet.\n        require( holderData[ holder ].tokenBalance != 0/*,\n                 \"holder doesn't have any lottery tokens!\" */);\n\n        require( holderData[ holder ].referrer == address( 0 )/*,\n                 \"holder already has registered a referral!\" */);\n\n        // Create a local memory copy of minMaxReferralScores.\n        MinMaxReferralScores memory minMaxRefCpy = minMaxReferralScores;\n\n        // Get the referrer's address from his ID, and specify\n        // it as a referrer of holder.\n        holderData[ holder ].referrer = referrers[ referralID ];\n\n        // Bonus points are added to this holder's score for\n        // registering a referral!\n        holderData[ holder ].bonusScore = referralRegisteringBonus;\n\n        // Increment number of referrees for every parent referrer,\n        // by traversing a referral tree child->parent way.\n        address referrerAddr = holderData[ holder ].referrer;\n\n        // Set the return value.\n        _referrerAddress = referrerAddr;\n\n        // Traverse a tree.\n        while( referrerAddr != ROOT_REFERRER && \n               referrerAddr != address( 0 ) )\n        {\n            // Increment referree count for this referrrer.\n            holderData[ referrerAddr ].referreeCount++;\n\n            // Update the Referrer Scores of the referrer, adding this\n            // referree's scores to it's current values.\n            holderData[ referrerAddr ].referree_etherContributed +=\n                holderData[ holder ].etherContributed;\n\n            holderData[ referrerAddr ].referree_timeFactors +=\n                holderData[ holder ].timeFactors;\n\n            holderData[ referrerAddr ].referree_tokenBalance +=\n                holderData[ holder ].tokenBalance;\n\n            // Update MinMax according to this referrer's score.\n            priv_updateMinMaxScores_referral(\n                minMaxRefCpy,\n                holderData[ referrerAddr ].referree_etherContributed,\n                holderData[ referrerAddr ].referree_timeFactors,\n                holderData[ referrerAddr ].referree_tokenBalance\n            );\n\n            // Move to the higher-level referrer.\n            referrerAddr = holderData[ referrerAddr ].referrer;\n        }\n\n        // Update MinMax Referral Scores if needed.\n        if( keccak256( abi.encode( minMaxRefCpy ) ) != \n            keccak256( abi.encode( minMaxReferralScores ) ) )\n            minMaxReferralScores = minMaxRefCpy;\n\n        return _referrerAddress;\n    }\n\n\n    /**\n     *  Sets our random seed to some value.\n     *  Should be called from Lottery, after obtaining random seed from\n     *  the Randomness Provider.\n     */\n    function setRandomSeed( uint _seed )\n                                                    external\n                                                    lotteryOnly\n    {\n        randomSeed = uint64( _seed );\n    }\n\n\n    /**\n     *  Initialization function.\n     *  Here, we bind our contract to the Lottery contract that \n     *  this Storage belongs to.\n     *  The parent lottery must call this function - hence, we set\n     *  \"lottery\" to msg.sender.\n     *\n     *  When this function is called, our contract must be not yet\n     *  initialized - \"lottery\" address must be Zero!\n     *\n     *  Here, we also set our Winner Algorithm config, which is a\n     *  subset of LotteryConfig, fitting into 1 storage slot.\n     */\n    function initialize(\n            WinnerAlgorithmConfig memory _wcfg )\n                                                        public\n    {\n        require( address( lottery ) == address( 0 )/*,\n                 \"Storage is already initialized!\" */);\n\n        // Set the Lottery address (msg.sender can't be zero),\n        // and thus, set our contract to initialized!\n        lottery = msg.sender;\n\n        // Set the Winner-Algo-Config.\n        algConfig = _wcfg;\n\n        // NOT-NEEDED: Set initial min-max scores: min is INT_MAX.\n        /*minMaxScores.holderScore_etherContributed_min = int80( 2 ** 78 );\n        minMaxScores.holderScore_timeFactors_min    = int80( 2 ** 78 );\n        minMaxScores.holderScore_tokenBalance_min   = int80( 2 ** 78 );\n        */\n    }\n\n\n    // ==================== Views ==================== //\n\n\n    // Returns the current random seed.\n    // If the seed hasn't been set yet (or set to 0), returns 0.\n    //\n    function getRandomSeed()\n                                                    external view\n    returns( uint )\n    {\n        return randomSeed;\n    }\n\n\n    // Check if Winner Selection Algorithm has beed executed.\n    //\n    function minedSelection_algorithmAlreadyExecuted()\n                                                        external view\n    returns( bool )\n    {\n        return algorithmCompleted;\n    }\n\n    /**\n     *  After lottery has completed, this function returns if \"addr\"\n     *  is one of lottery winners, and the position in winner rankings.\n     *  Function is used to obtain the ranking position before\n     *  calling claimWinnerPrize() on Lottery.\n     *\n     *  This function should be called off-chain, and then using the\n     *  retrieved data, one can call claimWinnerPrize().\n     */\n    function minedSelection_getWinnerStatus(\n            address addr )\n                                                        public view\n    returns( bool isWinner, \n             uint32 rankingPosition )\n    {\n        // Loop through the whole winner indexes array, trying to\n        // find if \"addr\" is one of the winner addresses.\n        for( uint16 i = 0; i < numberOfWinners; i++ )\n        {\n            // Check if holder on this winner ranking's index position\n            // is addr, if so, good!\n            uint pos = sortedWinnerIndexes[ i / 16 ].indexes[ i % 16 ];\n\n            if( holders[ pos ] == addr )\n            {\n                return ( true, i );\n            }\n        }\n\n        // The \"addr\" is not a winner.\n        return ( false, 0 );\n    }\n\n    /**\n     *  Checks if address is on specified winner ranking position.\n     *  Used in Lottery, to check if msg.sender is really the \n     *  winner #rankingPosition, as he claims to be.\n     */\n    function minedSelection_isAddressOnWinnerPosition( \n            address addr,\n            uint32  rankingPosition )\n                                                    external view\n    returns( bool )\n    {\n        if( rankingPosition >= numberOfWinners )\n            return false;\n\n        // Just check if address at \"holders\" array \n        // index \"sortedWinnerIndexes[ position ]\" is really the \"addr\".\n        uint pos = sortedWinnerIndexes[ rankingPosition / 16 ]\n                    .indexes[ rankingPosition % 16 ];\n\n        return ( holders[ pos ] == addr );\n    }\n\n\n    /**\n     *  Returns an array of all winner addresses, sorted by their\n     *  ranking position (winner #1 first, #2 second, etc.).\n     */\n    function minedSelection_getAllWinners()\n                                                    external view\n    returns( address[] memory )\n    {\n        address[] memory winners = new address[] ( numberOfWinners );\n\n        for( uint i = 0; i < numberOfWinners; i++ )\n        {\n            uint pos = sortedWinnerIndexes[ i / 16 ].indexes[ i % 16 ];\n            winners[ i ] = holders[ pos ];\n        }\n\n        return winners;\n    }\n\n\n    /**\n     *  Compute the Lottery Active Stage Score of a token holder.\n     *\n     *  This function computes the Active Stage (pre-randomization)\n     *  player score, and should generally be used to compute player\n     *  intermediate scores - while lottery is still active or on\n     *  finishing stage, before random random seed is obtained.\n     */\n    function getPlayerActiveStageScore( address holderAddr )\n                                                            external view\n    returns( uint playerScore )\n    {\n        // Copy the Winner Algo Config into memory, to avoid using\n        // 400-gas costing SLOAD every time we need to load something.\n        WinnerAlgorithmConfig memory cfg = algConfig;\n\n        // Check if holderAddr is a holder at all!\n        if( holders[ holderIndexes[ holderAddr ] ] != holderAddr )\n            return 0;\n\n        // Compute the precision-adjusted constant ratio of \n        // referralBonus max score to the player individual max scores.\n\n        int individualToReferralRatio = \n            ( PRECISION * cfg.maxPlayerScore_refferalBonus ) /\n            ( int( cfg.maxPlayerScore_etherContributed ) + \n              int( cfg.maxPlayerScore_timeFactor ) +\n              int( cfg.maxPlayerScore_tokenHoldingAmount ) );\n\n        // Max available player score.\n        int maxAvailablePlayerScore = int(\n                cfg.maxPlayerScore_etherContributed + \n                cfg.maxPlayerScore_timeFactor +\n                cfg.maxPlayerScore_tokenHoldingAmount +\n                cfg.maxPlayerScore_refferalBonus );\n\n        // Fix Min-Max scores, to avoid division by zero, if min == max.\n        // If min == max, make the difference equal to 1.\n        MinMaxHolderScores memory minMaxCpy = minMaxScores;\n        MinMaxReferralScores memory minMaxRefCpy = minMaxReferralScores;\n\n        priv_fixMinMaxIfEqual( minMaxCpy, minMaxRefCpy );\n\n        // Now, add bonus score, and compute total player's score:\n        // Bonus part, individual score part, and referree score part.\n        int totalPlayerScore = \n                holderData[ holderAddr ].bonusScore\n                +\n                computeHolderIndividualScores(\n                    cfg, minMaxCpy, holderData[ holderAddr ] )\n                +\n                computeReferreeScoresForHolder( \n                    individualToReferralRatio, cfg, \n                    minMaxRefCpy, holderData[ holderAddr ] );\n\n\n        // Check if total player score <= 0. If so, make it equal\n        // to 1, because otherwise randomization won't be possible.\n        if( totalPlayerScore <= 0 )\n            totalPlayerScore = 1;\n\n        // Now, check if it's not more than max! If so, lowerify.\n        // This could have happen'd because of bonus.\n        if( totalPlayerScore > maxAvailablePlayerScore )\n            totalPlayerScore = maxAvailablePlayerScore;\n\n        // Return the score!\n        return uint( totalPlayerScore );\n    }\n\n\n\n    /**\n     *  Internal sub-procedure of the function below, used to obtain\n     *  a final, randomized score of a Single Holder.\n     */\n    function priv_getSingleHolderScore(\n            address hold3r,\n            int individualToReferralRatio,\n            int maxAvailablePlayerScore,\n            int SCORE_RAND_FACT,\n            WinnerAlgorithmConfig memory cfg,\n            MinMaxHolderScores memory minMaxCpy,\n            MinMaxReferralScores memory minMaxRefCpy )\n                                                        internal view\n    returns( uint endScore )\n    {\n        // Fetch the needed holder data to in-memory hdata variable,\n        // to save gas on score part computing functions.\n        HolderData memory hdata;\n\n        // Slot 1:\n        hdata.etherContributed =\n            holderData[ hold3r ].etherContributed;\n        hdata.timeFactors =\n            holderData[ hold3r ].timeFactors;\n        hdata.tokenBalance =\n            holderData[ hold3r ].tokenBalance;\n        hdata.referreeCount =\n            holderData[ hold3r ].referreeCount;\n\n        // Slot 2:\n        hdata.referree_etherContributed =\n            holderData[ hold3r ].referree_etherContributed;\n        hdata.referree_timeFactors =\n            holderData[ hold3r ].referree_timeFactors;\n        hdata.referree_tokenBalance =\n            holderData[ hold3r ].referree_tokenBalance;\n        hdata.bonusScore =\n            holderData[ hold3r ].bonusScore;\n\n\n        // Now, add bonus score, and compute total player's score:\n        // Bonus part, individual score part, and referree score part.\n        int totalPlayerScore = \n                hdata.bonusScore\n                +\n                computeHolderIndividualScores(\n                    cfg, minMaxCpy, hdata )\n                +\n                computeReferreeScoresForHolder( \n                    individualToReferralRatio, cfg, \n                    minMaxRefCpy, hdata );\n\n\n        // Check if total player score <= 0. If so, make it equal\n        // to 1, because otherwise randomization won't be possible.\n        if( totalPlayerScore <= 0 )\n            totalPlayerScore = 1;\n\n        // Now, check if it's not more than max! If so, lowerify.\n        // This could have happen'd because of bonus.\n        if( totalPlayerScore > maxAvailablePlayerScore )\n            totalPlayerScore = maxAvailablePlayerScore;\n\n\n        // Multiply the score by the Random Modulo Adjustment\n        // Factor, to get fairer ratio of random-to-determined data.\n        totalPlayerScore =  ( totalPlayerScore * SCORE_RAND_FACT ) /\n                            ( PRECISION );\n\n        // Score is computed!\n        // Now, randomize it, and add to Final Scores Array.\n        // We use keccak to generate a random number from random seed,\n        // using holder's address as a nonce.\n\n        uint modulizedRandomNumber = uint(\n            keccak256( abi.encodePacked( randomSeed, hold3r ) )\n        ) % RANDOM_MODULO;\n\n        // Add the random number, to introduce the random factor.\n        // Ratio of (current) totalPlayerScore to modulizedRandomNumber\n        // is the same as ratio of randRatio_scorePart to \n        // randRatio_randPart.\n\n        return uint( totalPlayerScore ) + modulizedRandomNumber;\n    }\n\n\n    /**\n     *  Winner Self-Validation algo-type main function.\n     *  Here, we compute scores for all lottery holders iteratively\n     *  in O(n) time, and thus get the winner ranking position of\n     *  the holder in question.\n     *\n     *  This function performs essentialy the same steps as the\n     *  Mined-variant (executeWinnerSelectionAlgorithm), but doesn't\n     *  write anything to blockchain.\n     *\n     *  @param holderAddr - address of a holder whose rank we want to find.\n     */\n    function winnerSelfValidation_getWinnerStatus(\n            address holderAddr )\n                                                        internal view\n    returns( bool isWinner, uint rankingPosition )\n    {\n        // Copy the Winner Algo Config into memory, to avoid using\n        // 400-gas costing SLOAD every time we need to load something.\n        WinnerAlgorithmConfig memory cfg = algConfig;\n\n        // Can only be performed if algorithm is WinnerSelfValidation!\n        require( cfg.endingAlgoType ==\n                 uint8(Lottery.EndingAlgoType.WinnerSelfValidation)/*,\n                 \"Algorithm cannot be performed on current Algo-Type!\" */);\n\n        // Check if holderAddr is a holder at all!\n        require( holders[ holderIndexes[ holderAddr ] ] == holderAddr/*,\n                 \"holderAddr is not a lottery token holder!\" */);\n\n        // Now, we gotta find the winners using a Randomized Score-Based\n        // Winner Selection Algorithm.\n        //\n        // During transfers, all player intermediate scores \n        // (etherContributed, timeFactors, and tokenBalances) were\n        // already set in every holder's HolderData structure,\n        // during operations of updateHolderData_preTransfer() function.\n        //\n        // Minimum and maximum values are also known, so normalization\n        // will be easy.\n        // All referral tree score data were also properly propagated\n        // during operations of updateAndPropagateScoreChanges() function.\n        //\n        // All we block.timestamp have to do, is loop through holder array, and\n        // compute randomized final scores for every holder.\n\n        // Compute the precision-adjusted constant ratio of \n        // referralBonus max score to the player individual max scores.\n\n        int individualToReferralRatio = \n            ( PRECISION * cfg.maxPlayerScore_refferalBonus ) /\n            ( int( cfg.maxPlayerScore_etherContributed ) + \n              int( cfg.maxPlayerScore_timeFactor ) +\n              int( cfg.maxPlayerScore_tokenHoldingAmount ) );\n\n        // Max available player score.\n        int maxAvailablePlayerScore = int(\n                cfg.maxPlayerScore_etherContributed + \n                cfg.maxPlayerScore_timeFactor +\n                cfg.maxPlayerScore_tokenHoldingAmount +\n                cfg.maxPlayerScore_refferalBonus );\n\n\n        // Random Factor of scores, to maintain random-to-determined\n        // ratio equal to specific value (1:5 for example - \n        // \"randPart\" == 5/*, \"scorePart\" */== 1).\n        //\n        // maxAvailablePlayerScore * FACT   ---   scorePart\n        // RANDOM_MODULO                    ---   randPart\n        //\n        //                                  RANDOM_MODULO * scorePart\n        // maxAvailablePlayerScore * FACT = -------------------------\n        //                                          randPart\n        //\n        //              RANDOM_MODULO * scorePart\n        // FACT = --------------------------------------\n        //          randPart * maxAvailablePlayerScore\n\n        int SCORE_RAND_FACT =\n            ( PRECISION * int(RANDOM_MODULO * cfg.randRatio_scorePart) ) /\n            ( int(cfg.randRatio_randPart) * maxAvailablePlayerScore );\n\n\n        // Fix Min-Max scores, to avoid division by zero, if min == max.\n        // If min == max, make the difference equal to 1.\n        MinMaxHolderScores memory minMaxCpy = minMaxScores;\n        MinMaxReferralScores memory minMaxRefCpy = minMaxReferralScores;\n\n        priv_fixMinMaxIfEqual( minMaxCpy, minMaxRefCpy );\n\n        // How many holders had higher scores than \"holderAddr\".\n        // Used to obtain the final winner rank of \"holderAddr\".\n        uint numOfHoldersHigherThan = 0;\n\n        // The final (randomized) score of \"holderAddr\".\n        uint holderAddrsFinalScore = priv_getSingleHolderScore(\n            holderAddr,\n            individualToReferralRatio,\n            maxAvailablePlayerScore,\n            SCORE_RAND_FACT,\n            cfg, minMaxCpy, minMaxRefCpy );\n\n        // Index of holderAddr.\n        uint holderAddrIndex = holderIndexes[ holderAddr ];\n\n\n        // Loop through all the allowed holders.\n        for( uint i = 0; \n             i < ( holders.length < SELFVALIDATION_MAX_NUMBER_OF_HOLDERS ? \n                   holders.length : SELFVALIDATION_MAX_NUMBER_OF_HOLDERS );\n             i++ )\n        {\n            // Skip the holderAddr's index.\n            if( i == holderAddrIndex )\n                continue;\n\n            // Compute the score using helper function.\n            uint endScore = priv_getSingleHolderScore(\n                holders[ i ],\n                individualToReferralRatio,\n                maxAvailablePlayerScore,\n                SCORE_RAND_FACT,\n                cfg, minMaxCpy, minMaxRefCpy );\n\n            // Check if score is higher than HolderAddr's, and if so, check.\n            if( endScore > holderAddrsFinalScore )\n                numOfHoldersHigherThan++;\n        }\n\n        // All scores are checked!\n        // Now, we can obtain holderAddr's winner rank based on how\n        // many scores were above holderAddr's score!\n\n        isWinner = ( numOfHoldersHigherThan < cfg.winnerCount ); \n        rankingPosition = numOfHoldersHigherThan;\n    }\n\n\n\n    /**\n     *  Rolled-Randomness algo-type main function.\n     *  Here, we only compute the score of the holder in question,\n     *  and compare it to maximum-available final score, divided\n     *  by no-of-winners.\n     *\n     *  @param holderAddr - address of a holder whose rank we want to find.\n     */\n    function rolledRandomness_getWinnerStatus(\n            address holderAddr )\n                                                        internal view\n    returns( bool isWinner, uint rankingPosition )\n    {\n        // Copy the Winner Algo Config into memory, to avoid using\n        // 400-gas costing SLOAD every time we need to load something.\n        WinnerAlgorithmConfig memory cfg = algConfig;\n\n        // Can only be performed if algorithm is RolledRandomness!\n        require( cfg.endingAlgoType ==\n                 uint8(Lottery.EndingAlgoType.RolledRandomness)/*,\n                 \"Algorithm cannot be performed on current Algo-Type!\" */);\n\n        // Check if holderAddr is a holder at all!\n        require( holders[ holderIndexes[ holderAddr ] ] == holderAddr/*,\n                 \"holderAddr is not a lottery token holder!\" */);\n\n        // Now, we gotta find the winners using a Randomized Score-Based\n        // Winner Selection Algorithm.\n        //\n        // During transfers, all player intermediate scores \n        // (etherContributed, timeFactors, and tokenBalances) were\n        // already set in every holder's HolderData structure,\n        // during operations of updateHolderData_preTransfer() function.\n        //\n        // Minimum and maximum values are also known, so normalization\n        // will be easy.\n        // All referral tree score data were also properly propagated\n        // during operations of updateAndPropagateScoreChanges() function.\n        //\n        // All we block.timestamp have to do, is loop through holder array, and\n        // compute randomized final scores for every holder.\n\n        // Compute the precision-adjusted constant ratio of \n        // referralBonus max score to the player individual max scores.\n\n        int individualToReferralRatio = \n            ( PRECISION * cfg.maxPlayerScore_refferalBonus ) /\n            ( int( cfg.maxPlayerScore_etherContributed ) + \n              int( cfg.maxPlayerScore_timeFactor ) +\n              int( cfg.maxPlayerScore_tokenHoldingAmount ) );\n\n        // Max available player score.\n        int maxAvailablePlayerScore = int(\n                cfg.maxPlayerScore_etherContributed + \n                cfg.maxPlayerScore_timeFactor +\n                cfg.maxPlayerScore_tokenHoldingAmount +\n                cfg.maxPlayerScore_refferalBonus );\n\n\n        // Random Factor of scores, to maintain random-to-determined\n        // ratio equal to specific value (1:5 for example - \n        // \"randPart\" == 5, \"scorePart\" == 1).\n        //\n        // maxAvailablePlayerScore * FACT   ---   scorePart\n        // RANDOM_MODULO                    ---   randPart\n        //\n        //                                  RANDOM_MODULO * scorePart\n        // maxAvailablePlayerScore * FACT = -------------------------\n        //                                          randPart\n        //\n        //              RANDOM_MODULO * scorePart\n        // FACT = --------------------------------------\n        //          randPart * maxAvailablePlayerScore\n\n        int SCORE_RAND_FACT =\n            ( PRECISION * int(RANDOM_MODULO * cfg.randRatio_scorePart) ) /\n            ( int(cfg.randRatio_randPart) * maxAvailablePlayerScore );\n\n\n        // Fix Min-Max scores, to avoid division by zero, if min == max.\n        // If min == max, make the difference equal to 1.\n        MinMaxHolderScores memory minMaxCpy = minMaxScores;\n        MinMaxReferralScores memory minMaxRefCpy = minMaxReferralScores;\n\n        priv_fixMinMaxIfEqual( minMaxCpy, minMaxRefCpy );\n\n        // The final (randomized) score of \"holderAddr\".\n        uint holderAddrsFinalScore = priv_getSingleHolderScore(\n            holderAddr,\n            individualToReferralRatio,\n            maxAvailablePlayerScore,\n            SCORE_RAND_FACT,\n            cfg, minMaxCpy, minMaxRefCpy );\n\n        // Now, compute the Max-Final-Random Score, divide it\n        // by the Holder Count, and get the ranking by placing this\n        // holder's score in it's corresponding part.\n        //\n        // In this approach, we assume linear randomness distribution.\n        // In practice, distribution might be a bit different, but this\n        // approach is the most efficient.\n        //\n        // Max-Final-Score (randomized) is the highest available score\n        // that can be achieved, and is made by adding together the\n        // maximum availabe Player Score Part and maximum available\n        // Random Part (equals RANDOM_MODULO).\n        // These parts have a ratio equal to config-specified\n        // randRatio_scorePart to randRatio_randPart.\n        //\n        // So, if player's active stage's score is low (1), but rand-part\n        // in ratio is huge, then the score is mostly random, so \n        // maxFinalScore is close to the RANDOM_MODULO - maximum random\n        // value that can be rolled.\n        //\n        // If, however, we use 1:1 playerScore-to-Random Ratio, then\n        // playerScore and RandomScore make up equal parts of end score,\n        // so the maxFinalScore is actually two times larger than\n        // RANDOM_MODULO, so player needs to score more\n        // player-points to get larger prizes.\n        //\n        // In default configuration, playerScore-to-random ratio is 1:3,\n        // so there's a good randomness factor, so even the low-scoring\n        // players can reasonably hope to get larger prizes, but\n        // the higher is player's active stage score, the more\n        // chances of scoring a high final score a player gets, with\n        // the higher-end of player scores basically guaranteeing\n        // themselves a specific prize amount, if winnerCount is\n        // big enough to overlap.\n\n        int maxRandomPart      = int( RANDOM_MODULO - 1 );\n        int maxPlayerScorePart = ( SCORE_RAND_FACT * maxAvailablePlayerScore )\n                                 / PRECISION;\n\n        uint maxFinalScore = uint( maxRandomPart + maxPlayerScorePart );\n\n        // Compute the amount that single-holder's virtual part\n        // might take up in the max-final score.\n        uint singleHolderPart = maxFinalScore / holders.length;\n\n        // Now, compute how many single-holder-parts are there in\n        // this holder's score.\n        uint holderAddrScorePartCount = holderAddrsFinalScore /\n                                        singleHolderPart;\n\n        // The ranking is that number, minus holders length.\n        // If very high score is scored, default to position 0 (highest).\n        rankingPosition = (\n            holderAddrScorePartCount < holders.length ?\n            holders.length - holderAddrScorePartCount : 0\n        );\n\n        isWinner = ( rankingPosition < cfg.winnerCount );\n    }\n\n\n    /**\n     *  Genericized, algorithm type-dependent getWinnerStatus function.\n     */\n    function getWinnerStatus(\n            address addr )\n                                                        external view\n    returns( bool isWinner, uint32 rankingPosition )\n    {\n        bool _isW;\n        uint _rp;\n\n        if( algConfig.endingAlgoType == \n            uint8(Lottery.EndingAlgoType.RolledRandomness) )\n        {\n            (_isW, _rp) = rolledRandomness_getWinnerStatus( addr );\n            return ( _isW, uint32( _rp ) );\n        }\n\n        if( algConfig.endingAlgoType ==\n            uint8(Lottery.EndingAlgoType.WinnerSelfValidation) )\n        {\n            (_isW, _rp) = winnerSelfValidation_getWinnerStatus( addr );\n            return ( _isW, uint32( _rp ) );\n        }\n\n        if( algConfig.endingAlgoType ==\n            uint8(Lottery.EndingAlgoType.MinedWinnerSelection) )\n        {\n            (_isW, _rp) = minedSelection_getWinnerStatus( addr );\n            return ( _isW, uint32( _rp ) );\n        }\n    }\n\n}\n\n// \n/**\n *  This is a storage-stub contract of the Lottery Token, which contains\n *  only the state (storage) of a Lottery Token, and delegates all logic\n *  to the actual code implementation.\n *  This approach is very gas-efficient for deploying new lotteries.\n */\ncontract LotteryStub {\n    // ============ ERC20 token contract's storage ============ //\n\n    // ------- Slot ------- //\n\n    // Balances of token holders.\n    mapping (address => uint256) private _balances;\n\n    // ------- Slot ------- //\n\n    // Allowances of spenders for a specific token owner.\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    // ------- Slot ------- //\n\n    // Total supply of the token.\n    uint256 private _totalSupply;\n\n\n    // ============== Lottery contract's storage ============== //\n\n    // ------- Initial Slots ------- //\n\n    // The config which is passed to constructor.\n    Lottery.LotteryConfig internal cfg;\n\n    // ------- Slot ------- //\n\n    // The Lottery Storage contract, which stores all holder data,\n    // such as scores, referral tree data, etc.\n    LotteryStorage /*public*/ lotStorage;\n\n    // ------- Slot ------- //\n\n    // Pool address. Set on constructor from msg.sender.\n    address payable /*public*/ poolAddress;\n\n    // ------- Slot ------- //\n    \n    // Randomness Provider address.\n    address /*public*/ randomnessProvider;\n\n    // ------- Slot ------- //\n\n    // Exchange address. In Uniswap mode, it's the Uniswap liquidity \n    // pair's address, where trades execute.\n    address /*public*/ exchangeAddress;\n\n    // Start date.\n    uint32 /*public*/ startDate;\n\n    // Completion (Mining Phase End) date.\n    uint32 /*public*/ completionDate;\n    \n    // The date when Randomness Provider was called, requesting a\n    // random seed for the lottery finish.\n    // Also, when this variable becomes Non-Zero, it indicates that we're\n    // on Ending Stage Part One: waiting for the random seed.\n    uint32 finish_timeRandomSeedRequested;\n\n    // ------- Slot ------- //\n\n    // WETH address. Set by calling Router's getter, on constructor.\n    address WETHaddress;\n\n    // Is the WETH first or second token in our Uniswap Pair?\n    bool uniswap_ethFirst;\n\n    // If we are, or were before, on finishing stage, this is the\n    // probability of lottery going to Ending Stage on this transaction.\n    uint32 finishProbablity;\n    \n    // Re-Entrancy Lock (Mutex).\n    // We protect for reentrancy in the Fund Transfer functions.\n    bool reEntrancyMutexLocked;\n    \n    // On which stage we are currently.\n    uint8 /*public*/ lotteryStage;\n    \n    // Indicator for whether the lottery fund gains have passed a \n    // minimum fund gain requirement.\n    // After that time point (when this bool is set), the token sells\n    // which could drop the fund value below the requirement, would\n    // be denied.\n    bool fundGainRequirementReached;\n    \n    // The current step of the Mining Stage.\n    uint16 miningStep;\n\n    // If we're currently on Special Transfer Mode - that is, we allow\n    // direct transfers between parties even in NON-ACTIVE state.\n    bool specialTransferModeEnabled;\n\n\n    // ------- Slot ------- //\n    \n    // Per-Transaction Pseudo-Random hash value (transferHashValue).\n    // This value is computed on every token transfer, by keccak'ing\n    // the last (current) transferHashValue, msg.sender, block.timestamp, and \n    // transaction count.\n    //\n    // This is used on Finishing Stage, as a pseudo-random number,\n    // which is used to check if we should end the lottery (move to\n    // Ending Stage).\n    uint256 transferHashValue;\n\n    // ------- Slot ------- //\n\n    // On lottery end, get & store the lottery total ETH return\n    // (including initial funds), and profit amount.\n    uint128 /*public*/ ending_totalReturn;\n    uint128 /*public*/ ending_profitAmount;\n\n    // ------- Slot ------- //\n\n    // The mapping that contains TRUE for addresses that already claimed\n    // their lottery winner prizes.\n    // Used only in COMPLETION, on claimWinnerPrize(), to check if\n    // msg.sender has already claimed his prize.\n    mapping( address => bool ) /*public*/ prizeClaimersAddresses;\n\n\n\n    // =================== OUR CONTRACT'S OWN STORAGE =================== //\n\n    // The address of the delegate contract, containing actual logic.\n    address payable public __delegateContract;\n\n\n    // ===================          Functions         =================== //\n\n    // Constructor.\n    // Just set the delegate's address.\n    function stub_construct( address payable _delegateAddr )\n                                                                external\n    {\n        require( __delegateContract == address(0) );\n        __delegateContract = _delegateAddr;\n    }\n\n    // Fallback payable function, which delegates any call to our\n    // contract, into the delegate contract.\n    fallback()\n                external payable \n    {\n        // DelegateCall the delegate code contract.\n        ( bool success, bytes memory data ) =\n            __delegateContract.delegatecall( msg.data );\n\n        // Use inline assembly to be able to return value from the fallback.\n        // (by default, returning a value from fallback is not possible,\n        // but it's still possible to manually copy data to the\n        // return buffer.\n        assembly\n        {\n            // delegatecall returns 0 (false) on error.\n            // Add 32 bytes to \"data\" pointer, because first slot (32 bytes)\n            // contains the length, and we use return value's length\n            // from returndatasize() opcode.\n            switch success\n                case 0  { revert( add( data, 32 ), returndatasize() ) }\n                default { return( add( data, 32 ), returndatasize() ) }\n        }\n    }\n\n    // Receive ether function.\n    receive()   external payable\n    { }\n\n}\n\n/**\n *  LotteryStorage contract's storage-stub.\n *  Uses delagate calls to execute actual code on this contract's behalf.\n */\ncontract LotteryStorageStub {\n    // =============== LotteryStorage contract's storage ================ //\n\n    // --------- Slot --------- //\n\n    // The Lottery address that this storage belongs to.\n    // Is set by the \"initialize()\", called by corresponding Lottery.\n    address lottery;\n\n    // The Random Seed, that was passed to us from Randomness Provider,\n    // or generated alternatively.\n    uint64 randomSeed;\n\n    // The actual number of winners that there will be. Set after\n    // completing the Winner Selection Algorithm.\n    uint16 numberOfWinners;\n\n    // Bool indicating if Winner Selection Algorithm has been executed.\n    bool algorithmCompleted;\n\n\n    // --------- Slot --------- //\n\n    // Winner Algorithm config. Specified in Initialization().\n    LotteryStorage.WinnerAlgorithmConfig algConfig;\n\n    // --------- Slot --------- //\n\n    // The Min-Max holder score storage.\n    LotteryStorage.MinMaxHolderScores minMaxScores;\n\n    // --------- Slot --------- //\n\n    // Array of holders.\n    address[] /*public*/ holders;\n\n    // --------- Slot --------- //\n\n    // Holder array indexes mapping, for O(1) array element access.\n    mapping( address => uint ) holderIndexes;\n\n    // --------- Slot --------- //\n\n    // Mapping of holder data.\n    mapping( address => LotteryStorage.HolderData ) /*public*/ holderData;\n\n    // --------- Slot --------- //\n\n    // Mapping of referral IDs to addresses of holders who generated\n    // those IDs.\n    mapping( uint256 => address ) referrers;\n\n    // --------- Slot --------- //\n\n    // The array of final-sorted winners (set after Winner Selection\n    // Algorithm completes), that contains the winners' indexes\n    // in the \"holders\" array, to save space.\n    //\n    // Notice that by using uint16, we can fit 16 items into one slot!\n    // So, if there are 160 winners, we only take up 10 slots, so\n    // only 20,000 * 10 = 200,000 gas gets consumed!\n    //\n    LotteryStorage.WinnerIndexStruct[] sortedWinnerIndexes;\n\n\n    // =================== OUR CONTRACT'S OWN STORAGE =================== //\n\n    // The address of the delegate contract, containing actual logic.\n    address public __delegateContract;\n\n\n    // ===================          Functions         =================== //\n\n\n    // Constructor.\n    // Just set the delegate's address.\n    function stub_construct( address _delegateAddr )\n                                                                external\n    {\n        require( __delegateContract == address(0) );\n        __delegateContract = _delegateAddr;\n    }\n\n\n    // Fallback function, which delegates any call to our\n    // contract, into the delegate contract.\n    fallback()\n                external\n    {\n        // DelegateCall the delegate code contract.\n        ( bool success, bytes memory data ) =\n            __delegateContract.delegatecall( msg.data );\n\n        // Use inline assembly to be able to return value from the fallback.\n        // (by default, returning a value from fallback is not possible,\n        // but it's still possible to manually copy data to the\n        // return buffer.\n        assembly\n        {\n            // delegatecall returns 0 (false) on error.\n            // Add 32 bytes to \"data\" pointer, because first slot (32 bytes)\n            // contains the length, and we use return value's length\n            // from returndatasize() opcode.\n            switch success\n                case 0  { revert( add( data, 32 ), returndatasize() ) }\n                default { return( add( data, 32 ), returndatasize() ) }\n        }\n    }\n}\n\n// \n/**\n *  The Factory contract, used to deploy new Lottery Storage contracts.\n *  Every Lottery must have exactly one Storage, which is used by the\n *  main Lottery token contract, to store holder data, and on ending, to\n *  execute the winner selection and prize distribution -\n *  these operations are done in LotteryStorage contract functions.\n */\ncontract UniLotteryStorageFactory {\n    // The Pool Address.\n    address payable poolAddress;\n\n    // The Delegate Logic contract, containing all code for\n    // all LotteryStorage contracts to be deployed.\n    address immutable public delegateContract;\n\n    // Pool-Only modifier.\n    modifier poolOnly \n    {\n        require( msg.sender == poolAddress/*,\n                 \"Function can only be called by the Main Pool!\" */);\n        _;\n    }\n\n    // Constructor.\n    // Deploy the Delegate Contract here.\n    //\n    constructor()\n    {\n        delegateContract = address( new LotteryStorage() );\n    }\n\n    // Initialization function.\n    // Set the poolAddress as msg.sender, and lock it.\n    function initialize()\n                                                            external\n    {\n        require( poolAddress == address( 0 )/*,\n                 \"Initialization has already finished!\" */);\n\n        // Set the Pool's Address.\n        poolAddress = msg.sender;\n    }\n\n    /**\n     * Deploy a new Lottery Storage Stub, to be used by it's corresponding\n     * Lottery Stub, which will be created later, passing this Storage\n     * we create here.\n     *  @return newStorage - the Lottery Storage Stub contract just deployed.\n     */\n    function createNewStorage()\n                                                            public\n                                                            poolOnly\n    returns( address newStorage )\n    {\n        LotteryStorageStub stub = new LotteryStorageStub();\n        stub.stub_construct( delegateContract );\n        return address( stub );\n    }\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"createNewStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newStorage\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delegateContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UniLotteryStorageFactory","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"9000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}