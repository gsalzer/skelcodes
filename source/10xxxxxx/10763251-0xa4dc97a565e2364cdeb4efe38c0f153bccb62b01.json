{"status":"1","message":"OK","result":[{"SourceCode":"// File: solidity-common/contracts/library/SafeMath.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n/**\r\n * 算术操作\r\n */\r\nlibrary SafeMath {\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function wad() public pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    function ray() public pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\r\n        if (a > 3) {\r\n            b = a;\r\n            uint256 x = a / 2 + 1;\r\n            while (x < b) {\r\n                b = x;\r\n                x = (a / x + x) / 2;\r\n            }\r\n        } else if (a != 0) {\r\n            b = 1;\r\n        }\r\n    }\r\n\r\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / WAD;\r\n    }\r\n\r\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / RAY;\r\n    }\r\n\r\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, WAD), b);\r\n    }\r\n\r\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, WAD), b / 2) / b;\r\n    }\r\n\r\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, RAY), b);\r\n    }\r\n\r\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, RAY), b / 2) / b;\r\n    }\r\n\r\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = WAD;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = wmul(result, x);\r\n            }\r\n            x = wmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = RAY;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = rmul(result, x);\r\n            }\r\n            x = rmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: solidity-common/contracts/interface/IERC20.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n/**\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n */\r\ninterface IERC20 {\r\n    /**\r\n    * 可选方法\r\n    */\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * 必须方法\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * 事件类型\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/library/TransferHelper.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success,) = to.call.value(value)(new bytes(0));\r\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/interface/IBtswapETH.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\ninterface IBtswapETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function withdraw(uint256) external;\r\n\r\n}\r\n\r\n// File: contracts/interface/IBtswapFactory.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\ninterface IBtswapFactory {\r\n    function FEE_RATE_DENOMINATOR() external view returns (uint256);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function feeRateNumerator() external view returns (uint256);\r\n\r\n    function initCodeHash() external view returns (bytes32);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setRouter(address) external;\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n\r\n    function setFeeRateNumerator(uint256) external;\r\n\r\n    function setInitCodeHash(bytes32) external;\r\n\r\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\r\n\r\n    function pairFor(address factory, address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function getReserves(address factory, address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\r\n\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(address factory, uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(address factory, uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\r\n\r\n}\r\n\r\n// File: contracts/interface/IBtswapPairToken.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\ninterface IBtswapPairToken {\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function router() external view returns (address);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address, address) external;\r\n\r\n    function price(address token) external view returns (uint256);\r\n\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n}\r\n\r\n// File: contracts/interface/IBtswapRouter02.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\ninterface IBtswapRouter02 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function BT() external pure returns (address);\r\n\r\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n\r\n    function removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETHWithPermit(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline) external payable returns (uint256[] memory amounts);\r\n\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external view returns (uint256 amountB);\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external returns (uint256 amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint256 amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n\r\n    function weth(address token) external view returns (uint256);\r\n\r\n    function onTransfer(address sender, address recipient) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/interface/IBtswapToken.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\ninterface IBtswapToken {\r\n    function swap(address account, address input, uint256 amount, address output) external returns (bool);\r\n\r\n    function liquidity(address account, address pair) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/interface/IBtswapWhitelistedRole.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\ninterface IBtswapWhitelistedRole {\r\n    function getWhitelistedsLength() external view returns (uint256);\r\n\r\n    function isWhitelisted(address) external view returns (bool);\r\n\r\n    function whitelisteds(uint256) external view returns (address);\r\n\r\n}\r\n\r\n// File: contracts/biz/BtswapRouter.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BtswapRouter is IBtswapRouter02 {\r\n    using SafeMath for uint256;\r\n\r\n    address public factory;\r\n    address public WETH;\r\n    address public BT;\r\n\r\n    constructor(address _factory, address _WETH, address _BT) public {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n        BT = _BT;\r\n    }\r\n\r\n    function() external payable {\r\n        // only accept ETH via fallback from the WETH contract\r\n        assert(msg.sender == WETH);\r\n    }\r\n\r\n    function pairFor(address tokenA, address tokenB) public view returns (address pair){\r\n        pair = IBtswapFactory(factory).pairFor(factory, tokenA, tokenB);\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin\r\n    ) internal returns (uint256 amountA, uint256 amountB) {\r\n        // create the pair if it doesn\"t exist yet\r\n        if (IBtswapFactory(factory).getPair(tokenA, tokenB) == address(0)) {\r\n            IBtswapFactory(factory).createPair(tokenA, tokenB);\r\n        }\r\n        (uint256 reserveA, uint256 reserveB) = IBtswapFactory(factory).getReserves(factory, tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint256 amountBOptimal = IBtswapFactory(factory).quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, \"BtswapRouter: INSUFFICIENT_B_AMOUNT\");\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint256 amountAOptimal = IBtswapFactory(factory).quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, \"BtswapRouter: INSUFFICIENT_A_AMOUNT\");\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external ensure(deadline) returns (uint256 amountA, uint256 amountB, uint256 liquidity) {\r\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        address pair = pairFor(tokenA, tokenB);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IBtswapPairToken(pair).mint(to);\r\n        IBtswapToken(BT).liquidity(msg.sender, pair);\r\n    }\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable ensure(deadline) returns (uint256 amountToken, uint256 amountETH, uint256 liquidity) {\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            WETH,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = pairFor(token, WETH);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        IBtswapETH(WETH).deposit.value(amountETH)();\r\n        assert(IBtswapETH(WETH).transfer(pair, amountETH));\r\n        liquidity = IBtswapPairToken(pair).mint(to);\r\n        IBtswapToken(BT).liquidity(msg.sender, pair);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) public ensure(deadline) returns (uint256 amountA, uint256 amountB) {\r\n        address pair = pairFor(tokenA, tokenB);\r\n        // send liquidity to pair\r\n        IBtswapPairToken(pair).transferFrom(msg.sender, pair, liquidity);\r\n        (uint256 amount0, uint256 amount1) = IBtswapPairToken(pair).burn(to);\r\n        IBtswapToken(BT).liquidity(msg.sender, pair);\r\n        (address token0,) = IBtswapFactory(factory).sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= amountAMin, \"BtswapRouter: INSUFFICIENT_A_AMOUNT\");\r\n        require(amountB >= amountBMin, \"BtswapRouter: INSUFFICIENT_B_AMOUNT\");\r\n    }\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) public ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, amountToken);\r\n        IBtswapETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint256 amountA, uint256 amountB) {\r\n        address pair = pairFor(tokenA, tokenB);\r\n        uint256 value = approveMax ? uint256(- 1) : liquidity;\r\n        IBtswapPairToken(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint256 amountToken, uint256 amountETH) {\r\n        address pair = pairFor(token, WETH);\r\n        uint256 value = approveMax ? uint256(- 1) : liquidity;\r\n        IBtswapPairToken(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) public ensure(deadline) returns (uint256 amountETH) {\r\n        (, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\n        IBtswapETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint256 amountETH) {\r\n        address pair = pairFor(token, WETH);\r\n        uint256 value = approveMax ? uint256(- 1) : liquidity;\r\n        IBtswapPairToken(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint256[] memory amounts, address[] memory path, address _to) internal {\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = IBtswapFactory(factory).sortTokens(input, output);\r\n            uint256 amountInput = amounts[i];\r\n            uint256 amountOut = amounts[i + 1];\r\n            IBtswapToken(BT).swap(msg.sender, input, amountInput, output);\r\n            (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\r\n            address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : _to;\r\n            IBtswapPairToken(pairFor(input, output)).swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\r\n        amounts = IBtswapFactory(factory).getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, \"BtswapRouter: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\r\n        amounts = IBtswapFactory(factory).getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, \"BtswapRouter: EXCESSIVE_INPUT_AMOUNT\");\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable ensure(deadline) returns (uint256[] memory amounts){\r\n        require(path[0] == WETH, \"BtswapRouter: INVALID_PATH\");\r\n        amounts = IBtswapFactory(factory).getAmountsOut(factory, msg.value, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, \"BtswapRouter: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        IBtswapETH(WETH).deposit.value(amounts[0])();\r\n        assert(IBtswapETH(WETH).transfer(pairFor(path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactETH(uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline) external ensure(deadline) returns (uint256[] memory amounts){\r\n        require(path[path.length - 1] == WETH, \"BtswapRouter: INVALID_PATH\");\r\n        amounts = IBtswapFactory(factory).getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, \"BtswapRouter: EXCESSIVE_INPUT_AMOUNT\");\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\r\n        _swap(amounts, path, address(this));\r\n        IBtswapETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapExactTokensForETH(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external ensure(deadline) returns (uint256[] memory amounts){\r\n        require(path[path.length - 1] == WETH, \"BtswapRouter: INVALID_PATH\");\r\n        amounts = IBtswapFactory(factory).getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, \"BtswapRouter: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\r\n        _swap(amounts, path, address(this));\r\n        IBtswapETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline) external payable ensure(deadline) returns (uint256[] memory amounts){\r\n        require(path[0] == WETH, \"BtswapRouter: INVALID_PATH\");\r\n        amounts = IBtswapFactory(factory).getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= msg.value, \"BtswapRouter: EXCESSIVE_INPUT_AMOUNT\");\r\n        IBtswapETH(WETH).deposit.value(amounts[0])();\r\n        assert(IBtswapETH(WETH).transfer(pairFor(path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal {\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = IBtswapFactory(factory).sortTokens(input, output);\r\n            IBtswapPairToken pair = IBtswapPairToken(pairFor(input, output));\r\n            uint256 amountInput;\r\n            uint256 amountOutput;\r\n            {// scope to avoid stack too deep errors\r\n                (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\r\n                (uint256 reserveInput, uint256 reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n                amountOutput = IBtswapFactory(factory).getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n            IBtswapToken(BT).swap(msg.sender, input, amountInput, output);\r\n            (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\r\n            address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amountIn);\r\n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"BtswapRouter: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    }\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable ensure(deadline) {\r\n        require(path[0] == WETH, \"BtswapRouter: INVALID_PATH\");\r\n        uint256 amountIn = msg.value;\r\n        IBtswapETH(WETH).deposit.value(amountIn)();\r\n        assert(IBtswapETH(WETH).transfer(pairFor(path[0], path[1]), amountIn));\r\n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"BtswapRouter: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    }\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external ensure(deadline) {\r\n        require(path[path.length - 1] == WETH, \"BtswapRouter: INVALID_PATH\");\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amountIn);\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\r\n        require(amountOut >= amountOutMin, \"BtswapRouter: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        IBtswapETH(WETH).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(to, amountOut);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) public view returns (uint256 amountB) {\r\n        return IBtswapFactory(factory).quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) public view returns (uint256 amountOut){\r\n        return IBtswapFactory(factory).getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) public view returns (uint256 amountIn){\r\n        return IBtswapFactory(factory).getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] memory path) public view returns (uint256[] memory amounts){\r\n        return IBtswapFactory(factory).getAmountsOut(factory, amountIn, path);\r\n    }\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] memory path) public view returns (uint256[] memory amounts){\r\n        return IBtswapFactory(factory).getAmountsIn(factory, amountOut, path);\r\n    }\r\n\r\n    function weth(address token) public view returns (uint256) {\r\n        uint256 price = 0;\r\n\r\n        if (WETH == token) {\r\n            price = SafeMath.wad();\r\n        }\r\n        else if (IBtswapFactory(factory).getPair(token, WETH) != address(0)) {\r\n            price = IBtswapPairToken(IBtswapFactory(factory).getPair(token, WETH)).price(token);\r\n        }\r\n        else {\r\n            uint256 length = IBtswapWhitelistedRole(factory).getWhitelistedsLength();\r\n            for (uint256 index = 0; index < length; index++) {\r\n                address base = IBtswapWhitelistedRole(factory).whitelisteds(index);\r\n                if (IBtswapFactory(factory).getPair(token, base) != address(0) && IBtswapFactory(factory).getPair(base, WETH) != address(0)) {\r\n                    uint256 price0 = IBtswapPairToken(IBtswapFactory(factory).getPair(token, base)).price(token);\r\n                    uint256 price1 = IBtswapPairToken(IBtswapFactory(factory).getPair(base, WETH)).price(base);\r\n                    price = price0.wmul(price1);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return price;\r\n    }\r\n\r\n    function onTransfer(address sender, address recipient) public onlyPair returns (bool) {\r\n        IBtswapToken(BT).liquidity(sender, msg.sender);\r\n        IBtswapToken(BT).liquidity(recipient, msg.sender);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function isPair(address pair) public view returns (bool) {\r\n        return IBtswapFactory(factory).getPair(IBtswapPairToken(pair).token0(), IBtswapPairToken(pair).token1()) == pair;\r\n    }\r\n\r\n    modifier onlyPair() {\r\n        require(isPair(msg.sender), \"BtswapRouter: caller is not the pair\");\r\n        _;\r\n    }\r\n\r\n    modifier ensure(uint256 deadline) {\r\n        require(deadline >= block.timestamp, \"BtswapRouter: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_BT\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"BT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"onTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"pairFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETHSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BtswapRouter","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001fed2e360a5afb2ac4b047102a7012a57f3c8cab000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000cb4336d9aa2027f563437b721b34c56a3e7a23f4","EVMVersion":"Default","Library":"SafeMath:1eae93c8544c7935815aadea5cc5aedd04326680","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://73f0d81d05ff7f6df45469641159ac1fae238723aa3f5fcd7c5462af4be159a7"}]}