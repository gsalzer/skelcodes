{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\n\n// File: openzeppelin-solidity/contracts/math/Math.sol\n\n/**\n * @title Math\n * @dev Assorted math operations\n */\nlibrary Math {\n  /**\n  * @dev Returns the largest of two numbers.\n  */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n  * @dev Returns the smallest of two numbers.\n  */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n  * @dev Calculates the average of two numbers. Since these are integers,\n  * averages of an even and odd number cannot be represented, and will be\n  * rounded down.\n  */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow, so we distribute\n    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: contracts/migrations/SGAToSGRTokenExchange.sol\n\n/**\n * Details of usage of licenced software see here: https://www.sogur.com/software/readme_v1\n */\n\n/**\n * @title SGA to SGR Token Exchange.\n */\ncontract SGAToSGRTokenExchange {\n    string public constant VERSION = \"1.0.0\";\n\n    using Math for uint256;\n    // Exchanged SGA tokens are transferred to this address. The zero address can not be used as transfer to this address will revert.\n    address public constant SGA_TARGET_ADDRESS = address(1);\n\n    IERC20 public sgaToken;\n    IERC20 public sgrToken;\n\n    event ExchangeSgaForSgrCompleted(address indexed _sgaHolder, uint256 _exchangedAmount);\n\n    /**\n     * @dev Create the contract.\n     * @param _sgaTokenAddress The SGA token contract address.\n     * @param _sgrTokenAddress The SGR token contract address.\n     */\n    constructor(address _sgaTokenAddress, address _sgrTokenAddress) public {\n        require(_sgaTokenAddress != address(0), \"SGA token address is illegal\");\n        require(_sgrTokenAddress != address(0), \"SGR token address is illegal\");\n\n        sgaToken = IERC20(_sgaTokenAddress);\n        sgrToken = IERC20(_sgrTokenAddress);\n    }\n\n\n    /**\n     * @dev Exchange SGA to SGR.\n     */\n    function exchangeSGAtoSGR() external {\n        handleExchangeSGAtoSGRFor(msg.sender);\n    }\n\n    /**\n     * @dev Exchange SGA to SGR for a given sga holder.\n     * @param _sgaHolder The sga holder address.\n     */\n    function exchangeSGAtoSGRFor(address _sgaHolder) external {\n        require(_sgaHolder != address(0), \"SGA holder address is illegal\");\n        handleExchangeSGAtoSGRFor(_sgaHolder);\n    }\n\n    /**\n     * @dev Handle the SGA to SGR exchange.\n     */\n    function handleExchangeSGAtoSGRFor(address _sgaHolder) internal {\n        uint256 allowance = sgaToken.allowance(_sgaHolder, address(this));\n        require(allowance > 0, \"SGA allowance must be greater than zero\");\n        uint256 balance = sgaToken.balanceOf(_sgaHolder);\n        require(balance > 0, \"SGA balance must be greater than zero\");\n        uint256 amountToExchange = allowance.min(balance);\n\n        sgaToken.transferFrom(_sgaHolder, SGA_TARGET_ADDRESS, amountToExchange);\n        sgrToken.transfer(_sgaHolder, amountToExchange);\n        emit ExchangeSgaForSgrCompleted(_sgaHolder, amountToExchange);\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"sgaToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangeSGAtoSGR\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SGA_TARGET_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sgrToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sgaHolder\",\"type\":\"address\"}],\"name\":\"exchangeSGAtoSGRFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_sgaTokenAddress\",\"type\":\"address\"},{\"name\":\"_sgrTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sgaHolder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_exchangedAmount\",\"type\":\"uint256\"}],\"name\":\"ExchangeSgaForSgrCompleted\",\"type\":\"event\"}]","ContractName":"SGAToSGRTokenExchange","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"6000","ConstructorArguments":"000000000000000000000000ed0849bf46cfb9845a2d900a0a4e593f2dd3673c000000000000000000000000aea8e1b6cb5c05d1dac618551c76bcd578ea3524","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}