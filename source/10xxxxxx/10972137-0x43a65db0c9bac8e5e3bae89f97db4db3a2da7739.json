{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\ninterface CrTokenInterface {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n}\r\n\r\ninterface CrETHInterface {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n}\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata CrTokens) external returns (uint[] memory);\r\n    function exitMarket(address CrTokenAddress) external returns (uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n}\r\n\r\ninterface InstaCreamMapping {\r\n    function CrTokenMapping(address) external view returns (address);\r\n}\r\n\r\ninterface MemoryInterface {\r\n    function getUint(uint _id) external returns (uint _num);\r\n    function setUint(uint _id, uint _val) external;\r\n}\r\n\r\ninterface EventInterface {\r\n    function emitEvent(uint _connectorType, uint _connectorID, bytes32 _eventCode, bytes calldata _eventData) external;\r\n}\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helpers is DSMath {\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getAddressETH() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Memory Variable Address\r\n     */\r\n    function getMemoryAddr() internal pure returns (address) {\r\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaEvent Address.\r\n     */\r\n    function getEventAddr() internal pure returns (address) {\r\n        return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\r\n    }\r\n\r\n    /**\r\n     * @dev Get Uint value from InstaMemory Contract.\r\n    */\r\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\r\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set Uint value in InstaMemory Contract.\r\n    */\r\n    function setUint(uint setId, uint val) internal {\r\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\r\n    }\r\n\r\n    /**\r\n     * @dev Connector Details\r\n    */\r\n    function connectorID() public pure returns(uint _type, uint _id) {\r\n        (_type, _id) = (1, 50);\r\n    }\r\n}\r\n\r\n\r\ncontract CreamHelpers is Helpers {\r\n    /**\r\n     * @dev Return Cream Comptroller Address\r\n     */\r\n    function getComptrollerAddress() internal pure returns (address) {\r\n        return 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaDApp Mapping Addresses\r\n     */\r\n    function getMappingAddr() internal pure returns (address) {\r\n        return 0x0a9b8a5D1A5FbF939CFD766bC22a018c5595faFe; // InstaCreamMapping Address\r\n    }\r\n\r\n    /**\r\n     * @dev enter cream market\r\n     */\r\n    function enterMarket(address CrToken) internal {\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        address[] memory markets = troller.getAssetsIn(address(this));\r\n        bool isEntered = false;\r\n        for (uint i = 0; i < markets.length; i++) {\r\n            if (markets[i] == CrToken) {\r\n                isEntered = true;\r\n            }\r\n        }\r\n        if (!isEntered) {\r\n            address[] memory toEnter = new address[](1);\r\n            toEnter[0] = CrToken;\r\n            troller.enterMarkets(toEnter);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract BasicResolver is CreamHelpers {\r\n    event LogDeposit(address indexed token, address CrToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogWithdraw(address indexed token, address CrToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogBorrow(address indexed token, address CrToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogPayback(address indexed token, address CrToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20_Token.\r\n     * @param token token address to deposit.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to deposit.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function deposit(address token, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        address CrToken = InstaCreamMapping(getMappingAddr()).CrTokenMapping(token);\r\n        enterMarket(CrToken);\r\n        if (token == getAddressETH()) {\r\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\r\n            CrETHInterface(CrToken).mint.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\r\n            tokenContract.approve(CrToken, _amt);\r\n            require(CrTokenInterface(CrToken).mint(_amt) == 0, \"minting-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogDeposit(token, CrToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogDeposit(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, CrToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw ETH/ERC20_Token.\r\n     * @param token token address to withdraw.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to withdraw.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function withdraw(address token, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        address CrToken = InstaCreamMapping(getMappingAddr()).CrTokenMapping(token);\r\n        CrTokenInterface CrTokenContract = CrTokenInterface(CrToken);\r\n        if (_amt == uint(-1)) {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            uint initialBal = token == getAddressETH() ? address(this).balance : tokenContract.balanceOf(address(this));\r\n            require(CrTokenContract.redeem(CrTokenContract.balanceOf(address(this))) == 0, \"full-withdraw-failed\");\r\n            uint finalBal = token == getAddressETH() ? address(this).balance : tokenContract.balanceOf(address(this));\r\n            _amt = finalBal - initialBal;\r\n        } else {\r\n            require(CrTokenContract.redeemUnderlying(_amt) == 0, \"withdraw-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogWithdraw(token, CrToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogWithdraw(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, CrToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Borrow ETH/ERC20_Token.\r\n     * @param token token address to borrow.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to borrow.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function borrow(address token, uint amt, uint getId, uint setId) external payable {\r\n        uint _amt = getUint(getId, amt);\r\n        address CrToken = InstaCreamMapping(getMappingAddr()).CrTokenMapping(token);\r\n        enterMarket(CrToken);\r\n        require(CrTokenInterface(CrToken).borrow(_amt) == 0, \"borrow-failed\");\r\n        setUint(setId, _amt);\r\n\r\n        emit LogBorrow(token, CrToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogBorrow(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, CrToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Payback borrowed ETH/ERC20_Token.\r\n     * @param token token address to payback.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to payback.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function payback(address token, uint amt, uint getId, uint setId) external payable {\r\n        uint _amt = getUint(getId, amt);\r\n        address CrToken = InstaCreamMapping(getMappingAddr()).CrTokenMapping(token);\r\n        CrTokenInterface CrTokenContract = CrTokenInterface(CrToken);\r\n        _amt = _amt == uint(-1) ? CrTokenContract.borrowBalanceCurrent(address(this)) : _amt;\r\n\r\n        if (token == getAddressETH()) {\r\n            require(address(this).balance >= _amt, \"not-enough-eth\");\r\n            CrETHInterface(CrToken).repayBorrow.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            require(tokenContract.balanceOf(address(this)) >= _amt, \"not-enough-token\");\r\n            tokenContract.approve(CrToken, _amt);\r\n            require(CrTokenContract.repayBorrow(_amt) == 0, \"repay-failed.\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogPayback(token, CrToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogPayback(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, CrToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n}\r\n\r\ncontract ExtraResolver is BasicResolver {\r\n    event LogDepositCrToken(address indexed token, address CrToken, uint256 tokenAmt, uint256 CrTokenAmt,uint256 getId, uint256 setId);\r\n    event LogWithdrawCrToken(address indexed token, address CrToken, uint256 CrTokenAmt, uint256 getId, uint256 setId);\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20_Token.\r\n     * @param token token address to depositCrToken.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to depositCrToken.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set CrToken amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function depositCrToken(address token, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        address CrToken = InstaCreamMapping(getMappingAddr()).CrTokenMapping(token);\r\n        enterMarket(CrToken);\r\n\r\n        CrTokenInterface CrTokenContract = CrTokenInterface(CrToken);\r\n        uint initialBal = CrTokenContract.balanceOf(address(this));\r\n\r\n        if (token == getAddressETH()) {\r\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\r\n            CrETHInterface(CrToken).mint.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\r\n            tokenContract.approve(CrToken, _amt);\r\n            require(CrTokenContract.mint(_amt) == 0, \"deposit-CrToken-failed.\");\r\n        }\r\n\r\n        uint finalBal = CrTokenContract.balanceOf(address(this));\r\n        uint _cAmt = finalBal - initialBal;\r\n        setUint(setId, _cAmt);\r\n\r\n        emit LogDepositCrToken(token, CrToken, _amt, _cAmt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogDepositCrToken(address,address,uint256,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, CrToken, _amt, _cAmt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw CrETH/CrERC20_Token using CrToken Amt.\r\n     * @param token token address to withdraw CrToken.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param CrTokenAmt CrToken amount to withdrawCrToken.\r\n     * @param getId Get CrToken amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set CrToken amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function withdrawCrToken(address token, uint CrTokenAmt, uint getId, uint setId) external payable {\r\n        uint _amt = getUint(getId, CrTokenAmt);\r\n        address CrToken = InstaCreamMapping(getMappingAddr()).CrTokenMapping(token);\r\n        CrTokenInterface CrTokenContract = CrTokenInterface(CrToken);\r\n        _amt = _amt == uint(-1) ? CrTokenContract.balanceOf(address(this)) : _amt;\r\n        require(CrTokenContract.redeem(_amt) == 0, \"redeem-failed\");\r\n        setUint(setId, _amt);\r\n\r\n        emit LogWithdrawCrToken(token, CrToken, _amt, getId, setId);\r\n        bytes32 _eventCode = keccak256(\"LogWithdrawCrToken(address,address,uint256,uint256,uint256)\");\r\n        bytes memory _eventParam = abi.encode(token, CrToken, _amt, getId, setId);\r\n        (uint _type, uint _id) = connectorID();\r\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n\r\n    }\r\n}\r\n\r\n\r\ncontract ConnectCreamFinance is ExtraResolver {\r\n    string constant public name = \"Cream-finance-v1.0\";\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"CrToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"CrToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"CrToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"CrTokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogDepositCrToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"CrToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogPayback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"CrToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"CrToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"CrTokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawCrToken\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectorID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"depositCrToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"payback\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"CrTokenAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"withdrawCrToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ConnectCreamFinance","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c20758329bc86b91e158deefbafb53795149945731709175a45d9678636ddb52"}]}