{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: solidity/contracts/utility/interfaces/IOwned.sol\n\npragma solidity 0.4.26;\n\n/*\n    Owned contract interface\n*/\ncontract IOwned {\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n    function owner() public view returns (address) {this;}\n\n    function transferOwnership(address _newOwner) public;\n    function acceptOwnership() public;\n}\n\n// File: solidity/contracts/token/interfaces/IERC20Token.sol\n\npragma solidity 0.4.26;\n\n/*\n    ERC20 Standard Token interface\n*/\ncontract IERC20Token {\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n    function name() public view returns (string) {this;}\n    function symbol() public view returns (string) {this;}\n    function decimals() public view returns (uint8) {this;}\n    function totalSupply() public view returns (uint256) {this;}\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n// File: solidity/contracts/utility/interfaces/ITokenHolder.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Token Holder interface\n*/\ncontract ITokenHolder is IOwned {\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterAnchor.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Converter Anchor interface\n*/\ncontract IConverterAnchor is IOwned, ITokenHolder {\n}\n\n// File: solidity/contracts/token/interfaces/ISmartToken.sol\n\npragma solidity 0.4.26;\n\n\n\n\n/*\n    Smart Token interface\n*/\ncontract ISmartToken is IConverterAnchor, IERC20Token {\n    function disableTransfers(bool _disable) public;\n    function issue(address _to, uint256 _amount) public;\n    function destroy(address _from, uint256 _amount) public;\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/interfaces/IPoolTokensContainer.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Pool Tokens Container interface\n*/\ncontract IPoolTokensContainer is IConverterAnchor {\n    function poolTokens() public view returns (ISmartToken[]);\n    function createToken() public returns (ISmartToken);\n    function mint(ISmartToken _token, address _to, uint256 _amount) public;\n    function burn(ISmartToken _token, address _from, uint256 _amount) public;\n}\n\n// File: solidity/contracts/utility/Owned.sol\n\npragma solidity 0.4.26;\r\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/Utils.sol\n\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\n\n// File: solidity/contracts/utility/TokenHandler.sol\n\npragma solidity 0.4.26;\n\n\ncontract TokenHandler {\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n    /**\n      * @dev executes the ERC20 token's `approve` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _spender approved address\n      * @param _value   allowance amount\n    */\n    function safeApprove(IERC20Token _token, address _spender, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransfer(IERC20Token _token, address _to, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _from    source address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n    }\n\n    /**\n      * @dev executes a function on the ERC20 token and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _data    data to pass in to the token's contract for execution\n    */\n    function execute(IERC20Token _token, bytes memory _data) private {\n        uint256[1] memory ret = [uint256(1)];\n\n        assembly {\n            let success := call(\n                gas,            // gas remaining\n                _token,         // destination address\n                0,              // no ether\n                add(_data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\n                mload(_data),   // input length (loaded from the first 32 bytes in the `data` array)\n                ret,            // output buffer\n                32              // output length\n            )\n            if iszero(success) {\n                revert(0, 0)\n            }\n        }\n\n        require(ret[0] != 0, \"ERR_TRANSFER_FAILED\");\n    }\n}\n\n// File: solidity/contracts/utility/TokenHolder.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\r\n\r\n/**\r\n  * @dev We consider every contract to be a 'token holder' since it's currently not possible\r\n  * for a contract to deny receiving tokens.\r\n  *\r\n  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n  * the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n  *\r\n  * Note that we use the non standard ERC-20 interface which has no return value for transfer\r\n  * in order to support both non standard as well as standard token contracts.\r\n  * see https://github.com/ethereum/solidity/issues/4116\r\n*/\r\ncontract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\r\n    /**\r\n      * @dev withdraws tokens held by the contract and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        safeTransfer(_token, _to, _amount);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/SafeMath.sol\n\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   value 1\r\n      * @param _y   value 2\r\n      *\r\n      * @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n      *\r\n      * @param _x   minuend\r\n      * @param _y   subtrahend\r\n      *\r\n      * @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   factor 1\r\n      * @param _y   factor 2\r\n      *\r\n      * @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n      *\r\n      * @param _x   dividend\r\n      * @param _y   divisor\r\n      *\r\n      * @return quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\n\n// File: solidity/contracts/token/ERC20Token.sol\n\npragma solidity 0.4.26;\r\r\r\r\n\r\n/**\r\n  * @dev ERC20 Standard Token implementation\r\n*/\r\ncontract ERC20Token is IERC20Token, Utils {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /**\r\n      * @dev triggered when tokens are transferred between wallets\r\n      *\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n      * @dev triggered when a wallet allows another wallet to transfer tokens from on its behalf\r\n      *\r\n      * @param _owner   wallet that approves the allowance\r\n      * @param _spender wallet that receives the allowance\r\n      * @param _value   allowance amount\r\n    */\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /**\r\n      * @dev initializes a new ERC20Token instance\r\n      *\r\n      * @param _name        token name\r\n      * @param _symbol      token symbol\r\n      * @param _decimals    decimal points, for display purposes\r\n      * @param _totalSupply total supply of token units\r\n    */\r\n    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {\r\n        // validate input\r\n        require(bytes(_name).length > 0, \"ERR_INVALID_NAME\");\r\n        require(bytes(_symbol).length > 0, \"ERR_INVALID_SYMBOL\");\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalSupply;\r\n        balanceOf[msg.sender] = _totalSupply;\r\n    }\r\n\r\n    /**\r\n      * @dev transfers tokens to a given address\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      *\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev transfers tokens to a given address on behalf of another address\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      *\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        validAddress(_from)\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev allows another account/contract to transfers tokens on behalf of the caller\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      *\r\n      * also, to minimize the risk of the approve/transferFrom attack vector\r\n      * (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\r\n      * in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\r\n      *\r\n      * @param _spender approved address\r\n      * @param _value   allowance amount\r\n      *\r\n      * @return true if the approval was successful, false if it wasn't\r\n    */\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        validAddress(_spender)\r\n        returns (bool success)\r\n    {\r\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0, \"ERR_INVALID_AMOUNT\");\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}\n\n// File: solidity/contracts/token/SmartToken.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\n\r\n/**\r\n  * @dev Smart Token\r\n  *\r\n  * 'Owned' is specified here for readability reasons\r\n*/\r\ncontract SmartToken is ISmartToken, Owned, ERC20Token, TokenHolder {\r\n    using SafeMath for uint256;\r\n\r\n    uint16 public constant version = 4;\r\n\r\n    bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false otherwise\r\n\r\n    /**\r\n      * @dev triggered when the total supply is increased\r\n      *\r\n      * @param _amount  amount that gets added to the supply\r\n    */\r\n    event Issuance(uint256 _amount);\r\n\r\n    /**\r\n      * @dev triggered when the total supply is decreased\r\n      *\r\n      * @param _amount  amount that gets removed from the supply\r\n    */\r\n    event Destruction(uint256 _amount);\r\n\r\n    /**\r\n      * @dev initializes a new SmartToken instance\r\n      *\r\n      * @param _name       token name\r\n      * @param _symbol     token short symbol, minimum 1 character\r\n      * @param _decimals   for display purposes only\r\n    */\r\n    constructor(string _name, string _symbol, uint8 _decimals)\r\n        public\r\n        ERC20Token(_name, _symbol, _decimals, 0)\r\n    {\r\n    }\r\n\r\n    // allows execution only when transfers are enabled\r\n    modifier transfersAllowed {\r\n        _transfersAllowed();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _transfersAllowed() internal view {\r\n        require(transfersEnabled, \"ERR_TRANSFERS_DISABLED\");\r\n    }\r\n\r\n    /**\r\n      * @dev disables/enables transfers\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _disable    true to disable transfers, false to enable them\r\n    */\r\n    function disableTransfers(bool _disable) public ownerOnly {\r\n        transfersEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n      * @dev increases the token supply and sends the new tokens to the given account\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to increase the supply by\r\n    */\r\n    function issue(address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balanceOf[_to] = balanceOf[_to].add(_amount);\r\n\r\n        emit Issuance(_amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev removes tokens from the given account and decreases the token supply\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _from    account to remove the amount from\r\n      * @param _amount  amount to decrease the supply by\r\n    */\r\n    function destroy(address _from, uint256 _amount) public ownerOnly {\r\n        balanceOf[_from] = balanceOf[_from].sub(_amount);\r\n        totalSupply = totalSupply.sub(_amount);\r\n\r\n        emit Transfer(_from, address(0), _amount);\r\n        emit Destruction(_amount);\r\n    }\r\n\r\n    // ERC20 standard method overrides with some extra functionality\r\n\r\n    /**\r\n      * @dev send coins\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      * in addition to the standard checks, the function throws if transfers are disabled\r\n      *\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transfer(_to, _value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev an account/contract attempts to get the coins\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      * in addition to the standard checks, the function throws if transfers are disabled\r\n      *\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transferFrom(_from, _to, _value));\r\n        return true;\r\n    }\r\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/PoolTokensContainer.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\n\r\n/**\r\n  * @dev The PoolTokensContainer contract serves as a container for multiple pool tokens.\r\n  * It is used by specific liquidity pool types that require more than a single pool token,\r\n  * while still maintaining the single converter / anchor relationship.\r\n  *\r\n  * It maintains and provides a list of the underlying pool tokens.\r\n */\r\ncontract PoolTokensContainer is IPoolTokensContainer, Owned, TokenHolder {\r\n    uint8 internal constant MAX_POOL_TOKENS = 5;    // maximum pool tokens in the container\r\n\r\n    string public name;                 // pool name\r\n    string public symbol;               // pool symbol\r\n    uint8 public decimals;              // underlying pool tokens decimals\r\n    ISmartToken[] private _poolTokens;  // underlying pool tokens\r\n\r\n    /**\r\n      * @dev initializes a new PoolTokensContainer instance\r\n      *\r\n      * @param  _name       pool name, also used as a prefix for the underlying pool token names\r\n      * @param  _symbol     pool symbol, also used as a prefix for the underlying pool token symbols\r\n      * @param  _decimals   used for the underlying pool token decimals\r\n    */\r\n    constructor(string _name, string _symbol, uint8 _decimals) public {\r\n         // validate input\r\n        require(bytes(_name).length > 0, \"ERR_INVALID_NAME\");\r\n        require(bytes(_symbol).length > 0, \"ERR_INVALID_SYMBOL\");\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the list of pool tokens\r\n      *\r\n      * @return list of pool tokens\r\n    */\r\n    function poolTokens() public view returns (ISmartToken[] memory) {\r\n        return _poolTokens;\r\n    }\r\n\r\n    /**\r\n      * @dev creates a new pool token and adds it to the list\r\n      *\r\n      * @return new pool token address\r\n    */\r\n    function createToken() public ownerOnly returns (ISmartToken) {\r\n        // verify that the max limit wasn't reached\r\n        require(_poolTokens.length < MAX_POOL_TOKENS, \"ERR_MAX_LIMIT_REACHED\");\r\n\r\n        string memory poolName = concatStrDigit(name, uint8(_poolTokens.length + 1));\r\n        string memory poolSymbol = concatStrDigit(symbol, uint8(_poolTokens.length + 1));\r\n\r\n        SmartToken token = new SmartToken(poolName, poolSymbol, decimals);\r\n        _poolTokens.push(token);\r\n        return token;\r\n    }\r\n\r\n    /**\r\n      * @dev increases the pool token supply and sends the new tokens to the given account\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _token   pool token address\r\n      * @param _to      account to receive the newly minted tokens\r\n      * @param _amount  amount to mint\r\n    */\r\n    function mint(ISmartToken _token, address _to, uint256 _amount) public ownerOnly {\r\n        _token.issue(_to, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev removes tokens from the given account and decreases the pool token supply\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _token   pool token address\r\n      * @param _from    account to remove the tokens from\r\n      * @param _amount  amount to burn\r\n    */\r\n    function burn(ISmartToken _token, address _from, uint256 _amount) public ownerOnly {\r\n        _token.destroy(_from, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev concatenates a string and a digit (single only) and returns the result string\r\n      *\r\n      * @param _str     string\r\n      * @param _digit   digit\r\n      * @return concatenated string\r\n    */\r\n    function concatStrDigit(string _str, uint8 _digit) private pure returns (string) {\r\n        return string(abi.encodePacked(_str, uint8(bytes1('0')) + _digit));\r\n    }\r\n}\n\n// File: solidity/contracts/converter/interfaces/ITypedConverterAnchorFactory.sol\n\npragma solidity 0.4.26;\n\n\n/*\n    Typed Converter Anchor Factory interface\n*/\ncontract ITypedConverterAnchorFactory {\n    function converterType() public pure returns (uint16);\n    function createAnchor(string _name, string _symbol, uint8 _decimals) public returns (IConverterAnchor);\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v2/LiquidityPoolV2ConverterAnchorFactory.sol\n\npragma solidity 0.4.26;\r\r\r\n\r\n/*\r\n    LiquidityPoolV2ConverterAnchorFactory Factory\r\n*/\r\ncontract LiquidityPoolV2ConverterAnchorFactory is ITypedConverterAnchorFactory {\r\n    /**\r\n      * @dev returns the converter type the factory is associated with\r\n      *\r\n      * @return converter type\r\n    */\r\n    function converterType() public pure returns (uint16) {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n      * @dev creates a new converter anchor with the given arguments and transfers\r\n      * the ownership to the caller\r\n      *\r\n      * @param _name        pool name\r\n      * @param _symbol      pool symbol\r\n      * @param _decimals    pool decimals\r\n      *\r\n      * @return new anchor\r\n    */\r\n    function createAnchor(string _name, string _symbol, uint8 _decimals) public returns (IConverterAnchor) {\r\n        IPoolTokensContainer container = new PoolTokensContainer(_name, _symbol, _decimals);\r\n        container.transferOwnership(msg.sender);\r\n        return container;\r\n    }\r\n}\n","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"converterType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"createAnchor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidityPoolV2ConverterAnchorFactory","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}