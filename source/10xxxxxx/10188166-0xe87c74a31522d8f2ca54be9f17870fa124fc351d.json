{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/ValSafeMath.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n/**\r\n * Forked subset of Openzeppelin SafeMath allowing custom underflow/overflow messages\r\n * Useful for debugging, replaceable with standard SafeMath\r\n */\r\nlibrary ValSafeMath {\r\n    function add(uint256 a, uint256 b, string memory overflowMessage) internal pure returns (uint256 result) {\r\n        result = a + b;\r\n        require(result >= a, overflowMessage);\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory underflowMessage) internal pure returns (uint256 result) {\r\n        require(b <= a, underflowMessage);\r\n        result = a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b, string memory overflowMessage) internal pure returns (uint256 result) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        result = a * b;\r\n        require(result / a == b, overflowMessage);\r\n    }\r\n    function div(uint256 a, uint256 b, string memory divideByZeroMessage) internal pure returns (uint256 result) {\r\n        require(b > 0, divideByZeroMessage);\r\n        result = a / b;\r\n    }\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/ILiquidator.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\n/**\r\n * @title Liquidator Interface\r\n * @dev Liquidate stake token for reward token\r\n */\r\ncontract ILiquidator {\r\n\r\n    /** @dev Get output token (token to get from liquidation exchange). */\r\n    function outputToken() internal view returns (IERC20);\r\n\r\n    /** @dev Get stake token (token to be liquidated). */\r\n    function stakeToken() internal view returns (IERC20);\r\n\r\n    /** @dev Address of staking pool. */\r\n    function pool() internal view returns (address);\r\n\r\n    /**\r\n     * @dev Transfer stake without liquidation\r\n     */\r\n    function reclaimStake(address _destination, uint256 _stake) external;\r\n\r\n    /**\r\n     * @dev Award stake tokens to stakers\r\n     * Transfer to the pool without creating a staking position\r\n     * Allows us to reward as staking or reward token\r\n     */\r\n    function returnStake(address _from, uint256 balance) external;\r\n\r\n    /**\r\n     * @dev Sells stake for underlying asset and pays to destination.\r\n     */\r\n    function reclaim(address _destination, int256 _debt) external;\r\n}\r\n\r\n// File: @trusttoken/registry/contracts/Registry.sol\r\n\r\npragma solidity ^0.5.13;\r\n\r\n\r\ninterface RegistryClone {\r\n    function syncAttributeValue(address _who, bytes32 _attribute, uint256 _value) external;\r\n}\r\n\r\ncontract Registry {\r\n    struct AttributeData {\r\n        uint256 value;\r\n        bytes32 notes;\r\n        address adminAddr;\r\n        uint256 timestamp;\r\n    }\r\n    \r\n    // never remove any storage variables\r\n    address public owner;\r\n    address public pendingOwner;\r\n    bool initialized;\r\n\r\n    // Stores arbitrary attributes for users. An example use case is an IERC20\r\n    // token that requires its users to go through a KYC/AML check - in this case\r\n    // a validator can set an account's \"hasPassedKYC/AML\" attribute to 1 to indicate\r\n    // that account can use the token. This mapping stores that value (1, in the\r\n    // example) as well as which validator last set the value and at what time,\r\n    // so that e.g. the check can be renewed at appropriate intervals.\r\n    mapping(address => mapping(bytes32 => AttributeData)) attributes;\r\n    // The logic governing who is allowed to set what attributes is abstracted as\r\n    // this accessManager, so that it may be replaced by the owner as needed\r\n    bytes32 constant WRITE_PERMISSION = keccak256(\"canWriteTo-\");\r\n    mapping(bytes32 => RegistryClone[]) subscribers;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    event SetAttribute(address indexed who, bytes32 attribute, uint256 value, bytes32 notes, address indexed adminAddr);\r\n    event SetManager(address indexed oldManager, address indexed newManager);\r\n    event StartSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);\r\n    event StopSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);\r\n\r\n    // Allows a write if either a) the writer is that Registry's owner, or\r\n    // b) the writer is writing to attribute foo and that writer already has\r\n    // the canWriteTo-foo attribute set (in that same Registry)\r\n    function confirmWrite(bytes32 _attribute, address _admin) internal view returns (bool) {\r\n        return (_admin == owner || hasAttribute(_admin, keccak256(abi.encodePacked(WRITE_PERMISSION ^ _attribute))));\r\n    }\r\n\r\n    // Writes are allowed only if the accessManager approves\r\n    function setAttribute(address _who, bytes32 _attribute, uint256 _value, bytes32 _notes) public {\r\n        require(confirmWrite(_attribute, msg.sender));\r\n        attributes[_who][_attribute] = AttributeData(_value, _notes, msg.sender, block.timestamp);\r\n        emit SetAttribute(_who, _attribute, _value, _notes, msg.sender);\r\n\r\n        RegistryClone[] storage targets = subscribers[_attribute];\r\n        uint256 index = targets.length;\r\n        while (index --> 0) {\r\n            targets[index].syncAttributeValue(_who, _attribute, _value);\r\n        }\r\n    }\r\n\r\n    function subscribe(bytes32 _attribute, RegistryClone _syncer) external onlyOwner {\r\n        subscribers[_attribute].push(_syncer);\r\n        emit StartSubscription(_attribute, _syncer);\r\n    }\r\n\r\n    function unsubscribe(bytes32 _attribute, uint256 _index) external onlyOwner {\r\n        uint256 length = subscribers[_attribute].length;\r\n        require(_index < length);\r\n        emit StopSubscription(_attribute, subscribers[_attribute][_index]);\r\n        subscribers[_attribute][_index] = subscribers[_attribute][length - 1];\r\n        subscribers[_attribute].length = length - 1;\r\n    }\r\n\r\n    function subscriberCount(bytes32 _attribute) public view returns (uint256) {\r\n        return subscribers[_attribute].length;\r\n    }\r\n\r\n    function setAttributeValue(address _who, bytes32 _attribute, uint256 _value) public {\r\n        require(confirmWrite(_attribute, msg.sender));\r\n        attributes[_who][_attribute] = AttributeData(_value, \"\", msg.sender, block.timestamp);\r\n        emit SetAttribute(_who, _attribute, _value, \"\", msg.sender);\r\n        RegistryClone[] storage targets = subscribers[_attribute];\r\n        uint256 index = targets.length;\r\n        while (index --> 0) {\r\n            targets[index].syncAttributeValue(_who, _attribute, _value);\r\n        }\r\n    }\r\n\r\n    // Returns true if the uint256 value stored for this attribute is non-zero\r\n    function hasAttribute(address _who, bytes32 _attribute) public view returns (bool) {\r\n        return attributes[_who][_attribute].value != 0;\r\n    }\r\n\r\n\r\n    // Returns the exact value of the attribute, as well as its metadata\r\n    function getAttribute(address _who, bytes32 _attribute) public view returns (uint256, bytes32, address, uint256) {\r\n        AttributeData memory data = attributes[_who][_attribute];\r\n        return (data.value, data.notes, data.adminAddr, data.timestamp);\r\n    }\r\n\r\n    function getAttributeValue(address _who, bytes32 _attribute) public view returns (uint256) {\r\n        return attributes[_who][_attribute].value;\r\n    }\r\n\r\n    function getAttributeAdminAddr(address _who, bytes32 _attribute) public view returns (address) {\r\n        return attributes[_who][_attribute].adminAddr;\r\n    }\r\n\r\n    function getAttributeTimestamp(address _who, bytes32 _attribute) public view returns (uint256) {\r\n        return attributes[_who][_attribute].timestamp;\r\n    }\r\n\r\n    function syncAttribute(bytes32 _attribute, uint256 _startIndex, address[] calldata _addresses) external {\r\n        RegistryClone[] storage targets = subscribers[_attribute];\r\n        uint256 index = targets.length;\r\n        while (index --> _startIndex) {\r\n            RegistryClone target = targets[index];\r\n            for (uint256 i = _addresses.length; i --> 0; ) {\r\n                address who = _addresses[i];\r\n                target.syncAttributeValue(who, _attribute, attributes[who][_attribute].value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function reclaimEther(address payable _to) external onlyOwner {\r\n        _to.transfer(address(this).balance);\r\n    }\r\n\r\n    function reclaimToken(IERC20 token, address _to) external onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        token.transfer(_to, balance);\r\n    }\r\n\r\n   /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier throws if called by any account other than the pendingOwner.\r\n    */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to set the pendingOwner address.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the pendingOwner address to finalize the transfer.\r\n    */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/ALiquidatorUniswap.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n//pragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Uniswap\r\n * This is nessesary since Uniswap is written in vyper.\r\n */\r\ninterface UniswapV1 {\r\n    function tokenToExchangeSwapInput(uint256 tokensSold, uint256 minTokensBought, uint256 minEthBought, uint256 deadline, UniswapV1 exchangeAddress) external returns (uint256 tokensBought);\r\n    function tokenToExchangeTransferInput(uint256 tokensSold, uint256 minTokensBought, uint256 minEthBought, uint256 deadline, address recipient, UniswapV1 exchangeAddress) external returns (uint256 tokensBought);\r\n    function tokenToExchangeSwapOutput(uint256 tokensBought, uint256 maxTokensSold, uint256 maxEthSold, uint256 deadline, UniswapV1 exchangeAddress) external returns (uint256 tokensSold);\r\n    function tokenToExchangeTransferOutput(uint256 tokensBought, uint256 maxTokensSold, uint256 maxEthSold, uint256 deadline, address recipient, UniswapV1 exchangeAddress) external returns (uint256 tokensSold);\r\n}\r\n\r\n/**\r\n * @dev Uniswap Factory\r\n * This is nessesary since Uniswap is written in vyper.\r\n */\r\ninterface UniswapV1Factory {\r\n    function getExchange(IERC20 token) external returns (UniswapV1);\r\n}\r\n\r\n/**\r\n * @title Abstract Uniswap Liquidator\r\n * @dev Liquidate staked tokenns on uniswap.\r\n * This is because there are multiple instances of AirswapV2.\r\n * StakingOpportunityFactory does not create a Liquidator, rather this must be created\r\n * Outside of the factory.\r\n */\r\ncontract ALiquidatorUniswap is ILiquidator {\r\n    using ValSafeMath for uint256;\r\n\r\n    // owner, registry attributes\r\n    address public owner;\r\n    address public pendingOwner;\r\n    mapping (address => uint256) attributes;\r\n\r\n\r\n    // constants\r\n    bytes32 constant APPROVED_BENEFICIARY = \"approvedBeneficiary\";\r\n    uint256 constant LIQUIDATOR_CAN_RECEIVE     = 0xff00000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 constant LIQUIDATOR_CAN_RECEIVE_INV = 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    // part of signature so that signing for airswap doesn't sign for all airswap instances\r\n    uint256 constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant MAX_UINT128 = 0xffffffffffffffffffffffffffffffff;\r\n    bytes2 EIP191_HEADER = 0x1901;\r\n\r\n    // internal variables implemented as storage by Liquidator\r\n    // these variables must be known at construction time\r\n    // Liquidator is the actual implementation of ALiquidator\r\n\r\n    /** @dev Get output token (token to get from liqudiation exchange). */\r\n    function outputToken() internal view returns (IERC20);\r\n    /** @dev Get stake token (token to be liquidated). */\r\n    function stakeToken() internal view returns (IERC20);\r\n    /** @dev Output token on uniswap. */\r\n    function outputUniswapV1() internal view returns (UniswapV1);\r\n    /** @dev Stake token on uniswap. */\r\n    function stakeUniswapV1() internal view returns (UniswapV1);\r\n    /** @dev Contract registry. */\r\n    function registry() internal view returns (Registry);\r\n    /** @dev Address of staking pool. */\r\n    function pool() internal view returns (address);\r\n\r\n    /**\r\n     * @dev implementation constructor needs to call initialize\r\n     * Here we approve transfers to uniswap for the staking and output token\r\n     */\r\n    function initialize() internal {\r\n        outputToken().approve(address(outputUniswapV1()), MAX_UINT);\r\n        stakeToken().approve(address(stakeUniswapV1()), MAX_UINT);\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Liquidated(uint256 indexed stakeAmount, uint256 indexed debtAmount);\r\n\r\n    modifier onlyRegistry {\r\n        require(msg.sender == address(registry()), \"only registry\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"only pending owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Two flags are supported by this function:\r\n     * Supports APPROVED_BENEFICIARY\r\n     * Can sync by saying this contract is the registry or sync from registry directly.\r\n     */\r\n    function syncAttributeValue(address _account, bytes32 _attribute, uint256 _value) external onlyRegistry {\r\n        if (_attribute == APPROVED_BENEFICIARY) {\r\n            // approved beneficiary flag defines whether someone can receive\r\n            if (_value > 0) {\r\n                attributes[_account] |= LIQUIDATOR_CAN_RECEIVE;\r\n            } else {\r\n                attributes[_account] &= LIQUIDATOR_CAN_RECEIVE_INV;\r\n            }\r\n        }\r\n    }\r\n\r\n    struct UniswapState {\r\n        UniswapV1 uniswap;\r\n        uint256 etherBalance;\r\n        uint256 tokenBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate how much output we get for a stake input amount\r\n     * Much cheaper to do this logic ourselves locally than an external call\r\n     * Allows us to do this multiple times in one transaction\r\n     * See ./uniswap/uniswap_exchange.vy\r\n     */\r\n    function outputForUniswapV1Input(uint256 stakeInputAmount, UniswapState memory outputUniswapV1State, UniswapState memory stakeUniswapV1State) internal pure returns (uint256 outputAmount) {\r\n        uint256 inputAmountWithFee = 997 * stakeInputAmount;\r\n        inputAmountWithFee = 997 * (inputAmountWithFee * stakeUniswapV1State.etherBalance) / (stakeUniswapV1State.tokenBalance * 1000 + inputAmountWithFee);\r\n        outputAmount = (inputAmountWithFee * outputUniswapV1State.tokenBalance) / (outputUniswapV1State.etherBalance * 1000 + inputAmountWithFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Calcualte how much input we need to get a desired output\r\n     * Is able to let us know if there is slippage in uniswap exchange rate\r\n     * and continue with Airswap\r\n     * See./uniswap/uniswap_exchange.vy\r\n     */\r\n    function inputForUniswapV1Output(uint256 outputAmount, UniswapState memory outputUniswapV1State, UniswapState memory stakeUniswapV1State) internal pure returns (uint256 inputAmount) {\r\n        if (outputAmount >= outputUniswapV1State.tokenBalance) {\r\n            return MAX_UINT128;\r\n        }\r\n        uint256 ethNeeded = (outputUniswapV1State.etherBalance * outputAmount * 1000) / (997 * (outputUniswapV1State.tokenBalance - outputAmount)) + 1;\r\n        if (ethNeeded >= stakeUniswapV1State.etherBalance) {\r\n            return MAX_UINT128;\r\n        }\r\n        inputAmount = (stakeUniswapV1State.tokenBalance * ethNeeded * 1000) / (997 * (stakeUniswapV1State.etherBalance - ethNeeded)) + 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer stake without liquidation\r\n     * requires LIQUIDATOR_CAN_RECEIVE flag (recipient must be registered)\r\n     */\r\n    function reclaimStake(address _destination, uint256 _stake) external onlyOwner {\r\n        require(attributes[_destination] & LIQUIDATOR_CAN_RECEIVE != 0, \"unregistered recipient\");\r\n        stakeToken().transferFrom(pool(), _destination, _stake);\r\n    }\r\n\r\n    /**\r\n     * @dev Award stake tokens to stakers.\r\n     * Transfer to the pool without creating a staking position.\r\n     * Allows us to reward as staking or reward token.\r\n     */\r\n    function returnStake(address _from, uint256 balance) external {\r\n        stakeToken().transferFrom(_from, pool(), balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Sells stake for underlying asset and pays to destination.\r\n     * Use airswap trades as long as they're better than uniswap.\r\n     * Contract won't slip Uniswap this way.\r\n     * If we reclaim more than we actually owe we award to stakers.\r\n     * Not possible to convert back into TrustTokens here.\r\n     */\r\n    function reclaim(address _destination, int256 _debt) external onlyOwner {\r\n        require(_debt > 0, \"Must reclaim positive amount\");\r\n        require(_debt < int256(MAX_UINT128), \"reclaim amount too large\");\r\n        require(attributes[_destination] & LIQUIDATOR_CAN_RECEIVE != 0, \"unregistered recipient\");\r\n\r\n        // get balance of stake pool\r\n        address stakePool = pool();\r\n        uint256 remainingStake = stakeToken().balanceOf(stakePool);\r\n\r\n        // withdraw to liquidator\r\n        require(stakeToken().transferFrom(stakePool, address(this), remainingStake),\r\n            \"liquidator not approved to transferFrom stakeToken\");\r\n\r\n        // load uniswap state for output and staked token\r\n        UniswapState memory outputUniswapV1State;\r\n        UniswapState memory stakeUniswapV1State;\r\n        outputUniswapV1State.uniswap = outputUniswapV1();\r\n        outputUniswapV1State.etherBalance = address(outputUniswapV1State.uniswap).balance;\r\n        outputUniswapV1State.tokenBalance = outputToken().balanceOf(address(outputUniswapV1State.uniswap));\r\n        stakeUniswapV1State.uniswap = stakeUniswapV1();\r\n        stakeUniswapV1State.etherBalance = address(stakeUniswapV1State.uniswap).balance;\r\n        stakeUniswapV1State.tokenBalance = stakeToken().balanceOf(address(stakeUniswapV1State.uniswap));\r\n\r\n        // calculate remaining debt\r\n        int256 remainingDebt = _debt;\r\n\r\n        // if we have remaining debt and stake, we use Uniswap\r\n        // we can use uniswap by specifying desired output or input\r\n        if (remainingDebt > 0) {\r\n            if (remainingStake > 0) {\r\n                if (outputForUniswapV1Input(remainingStake, outputUniswapV1State, stakeUniswapV1State) < uint256(remainingDebt)) {\r\n                    // liquidate all remaining stake :(\r\n                    uint256 outputAmount = stakeUniswapV1State.uniswap.tokenToExchangeSwapInput(remainingStake, 1, 1, block.timestamp, outputUniswapV1State.uniswap);\r\n                    emit Liquidated(remainingStake, outputAmount);\r\n\r\n                    // update remaining stake and debt\r\n                    remainingDebt -= int256(outputAmount);\r\n                    remainingStake = 0;\r\n\r\n                    // send output token to destination\r\n                    outputToken().transfer(_destination, uint256(_debt - remainingDebt));\r\n                } else {\r\n                    // finish liquidation via uniswap\r\n                    uint256 stakeSold = stakeUniswapV1State.uniswap.tokenToExchangeSwapOutput(uint256(remainingDebt), remainingStake, MAX_UINT, block.timestamp, outputUniswapV1State.uniswap);\r\n                    emit Liquidated(stakeSold, uint256(remainingDebt));\r\n                    remainingDebt = 0;\r\n                    remainingStake -= stakeSold;\r\n                    //\r\n                    outputToken().transfer(_destination, uint256(_debt));\r\n                }\r\n            }\r\n        } else {\r\n            // if we end up with a tiny amount of delta, transfer to the pool\r\n            if (remainingDebt < 0) {\r\n                outputToken().transfer(stakePool, uint256(-remainingDebt));\r\n            }\r\n\r\n            // transfer output token to destination\r\n            outputToken().transfer(_destination, uint256(_debt));\r\n        }\r\n\r\n        // if there is remaining stake, return remainder to pool\r\n        if (remainingStake > 0) {\r\n            stakeToken().transfer(stakePool, remainingStake);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/Liquidator.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n//pragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title Liquidator\r\n * @dev Implementation of ALiquidator\r\n**/\r\ncontract Liquidator is ALiquidatorUniswap {\r\n    address pool_;\r\n    Registry registry_;\r\n    IERC20 outputToken_;\r\n    IERC20 stakeToken_;\r\n    UniswapV1 outputUniswap_;\r\n    UniswapV1 stakeUniswap_;\r\n    bool initialized;\r\n\r\n    function configure(\r\n        address registryAddress,\r\n        address outputTokenAddress,\r\n        address stakeTokenAddress,\r\n        address outputUniswapAddress,\r\n        address stakeUniswapAddress\r\n    ) external {\r\n        require(!initialized, \"already initialized\");\r\n        registry_ = Registry(registryAddress);\r\n        outputToken_ = IERC20(outputTokenAddress);\r\n        stakeToken_ = IERC20(stakeTokenAddress);\r\n        outputUniswap_ = UniswapV1(outputUniswapAddress);\r\n        stakeUniswap_ = UniswapV1(stakeUniswapAddress);\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n        initialized = true;\r\n        initialize();\r\n    }\r\n    function setPool(address _pool) external onlyOwner {\r\n        pool_ = _pool;\r\n    }\r\n    function pool() internal view returns (address) {\r\n        return pool_;\r\n    }\r\n    function outputToken() internal view returns (IERC20) {\r\n        return outputToken_;\r\n    }\r\n    function stakeToken() internal view returns (IERC20) {\r\n        return stakeToken_;\r\n    }\r\n    function registry() internal view returns (Registry) {\r\n        return registry_;\r\n    }\r\n    function outputUniswapV1() internal view returns (UniswapV1) {\r\n        return outputUniswap_;\r\n    }\r\n    function stakeUniswapV1() internal view returns (UniswapV1) {\r\n        return stakeUniswap_;\r\n    }\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/StakingAsset.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\ncontract StakingAsset is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/ProxyStorage.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\n/**\r\n * All storage must be declared here\r\n * New storage must be appended to the end\r\n * Never remove items from this list\r\n */\r\ncontract ProxyStorage {\r\n    bool initalized;\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    mapping (uint144 => uint256) attributes; // see RegistrySubscriber\r\n\r\n    address owner_;\r\n    address pendingOwner_;\r\n\r\n    /* Additionally, we have several keccak-based storage locations.\r\n     * If you add more keccak-based storage mappings, such as mappings, you must document them here.\r\n     * If the length of the keccak input is the same as an existing mapping, it is possible there could be a preimage collision.\r\n     * A preimage collision can be used to attack the contract by treating one storage location as another,\r\n     * which would always be a critical issue.\r\n     * Carefully examine future keccak-based storage to ensure there can be no preimage collisions.\r\n     *******************************************************************************************************\r\n     ** length     input                                                         usage\r\n     *******************************************************************************************************\r\n     ** 19         \"trueXXX.proxy.owner\"                                         Proxy Owner\r\n     ** 27         \"trueXXX.pending.proxy.owner\"                                 Pending Proxy Owner\r\n     ** 28         \"trueXXX.proxy.implementation\"                                Proxy Implementation\r\n     ** 64         uint256(address),uint256(1)                                   balanceOf\r\n     ** 64         uint256(address),keccak256(uint256(address),uint256(2))       allowance\r\n     ** 64         uint256(address),keccak256(bytes32,uint256(3))                attributes\r\n    **/\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/ERC20.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\n\r\n\r\n// Fork of OpenZeppelin's BasicToken\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract ModularBasicToken is ProxyStorage {\r\n    using ValSafeMath for uint256;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function _addBalance(address _who, uint256 _value) internal returns (uint256 priorBalance) {\r\n        priorBalance = balanceOf[_who];\r\n        balanceOf[_who] = priorBalance.add(_value, \"balance overflow\");\r\n    }\r\n\r\n    function _subBalance(address _who, uint256 _value) internal returns (uint256 result) {\r\n        result = balanceOf[_who].sub(_value, \"insufficient balance\");\r\n        balanceOf[_who] = result;\r\n    }\r\n\r\n    function _setBalance(address _who, uint256 _value) internal {\r\n        balanceOf[_who] = _value;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract ModularStandardToken is ModularBasicToken {\r\n    using ValSafeMath for uint256;\r\n    uint256 constant INFINITE_ALLOWANCE = 0xfe00000000000000000000000000000000000000000000000000000000000000;\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    \r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        _approveAllArgs(_spender, _value, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    function _approveAllArgs(address _spender, uint256 _value, address _tokenHolder) internal {\r\n        _setAllowance(_tokenHolder, _spender, _value);\r\n        emit Approval(_tokenHolder, _spender, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        _increaseApprovalAllArgs(_spender, _addedValue, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    function _increaseApprovalAllArgs(address _spender, uint256 _addedValue, address _tokenHolder) internal {\r\n        _addAllowance(_tokenHolder, _spender, _addedValue);\r\n        emit Approval(_tokenHolder, _spender, allowance[_tokenHolder][_spender]);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        _decreaseApprovalAllArgs(_spender, _subtractedValue, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    function _decreaseApprovalAllArgs(address _spender, uint256 _subtractedValue, address _tokenHolder) internal {\r\n        uint256 oldValue = allowance[_tokenHolder][_spender];\r\n        uint256 newValue;\r\n        if (_subtractedValue > oldValue) {\r\n            newValue = 0;\r\n        } else {\r\n            newValue = oldValue - _subtractedValue;\r\n        }\r\n        _setAllowance(_tokenHolder, _spender, newValue);\r\n        emit Approval(_tokenHolder,_spender, newValue);\r\n    }\r\n\r\n    function _addAllowance(address _who, address _spender, uint256 _value) internal {\r\n        allowance[_who][_spender] = allowance[_who][_spender].add(_value, \"allowance overflow\");\r\n    }\r\n\r\n    function _subAllowance(address _who, address _spender, uint256 _value) internal returns (uint256 newAllowance){\r\n        newAllowance = allowance[_who][_spender].sub(_value, \"insufficient allowance\");\r\n        if (newAllowance < INFINITE_ALLOWANCE) {\r\n            allowance[_who][_spender] = newAllowance;\r\n        }\r\n    }\r\n\r\n    function _setAllowance(address _who, address _spender, uint256 _value) internal {\r\n        allowance[_who][_spender] = _value;\r\n    }\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/RegistrySubscriber.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\ncontract RegistrySubscriber is ProxyStorage {\r\n    // Registry Attributes\r\n    bytes32 constant PASSED_KYCAML = \"hasPassedKYC/AML\";\r\n    bytes32 constant IS_DEPOSIT_ADDRESS = \"isDepositAddress\";\r\n    bytes32 constant BLACKLISTED = 0x6973426c61636b6c697374656400000000000000000000000000000000000000;\r\n    bytes32 constant REGISTERED_CONTRACT = 0x697352656769737465726564436f6e7472616374000000000000000000000000;\r\n\r\n    // attributes Bitmasks\r\n    uint256 constant ACCOUNT_BLACKLISTED     = 0xff00000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 constant ACCOUNT_BLACKLISTED_INV = 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant ACCOUNT_KYC             = 0x00ff000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 constant ACCOUNT_KYC_INV         = 0xff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant ACCOUNT_ADDRESS         = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant ACCOUNT_ADDRESS_INV     = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\r\n    uint256 constant ACCOUNT_HOOK            = 0x0000ff0000000000000000000000000000000000000000000000000000000000;\r\n    uint256 constant ACCOUNT_HOOK_INV        = 0xffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    function registry() internal view returns (Registry);\r\n\r\n    modifier onlyRegistry {\r\n        require(msg.sender == address(registry()));\r\n        _;\r\n    }\r\n\r\n    /**\r\n        Attributes are set per autosweep account\r\n        The layout of attributes is detailed here\r\n        lower bytes -> upper bytes\r\n        [0, 20)  recipient address\r\n        [29, 30) REGISTERED_CONTRACT\r\n        [30, 31) PASSED_KYCAML\r\n        [31, 32) BLACKLISTED\r\n    */\r\n    function syncAttributeValue(address _who, bytes32 _attribute, uint256 _value) public onlyRegistry {\r\n        uint144 who = uint144(uint160(_who) >> 20);\r\n        uint256 prior = attributes[who];\r\n        if (prior == 0) {\r\n            prior = uint256(_who);\r\n        }\r\n        if (_attribute == IS_DEPOSIT_ADDRESS) {\r\n            if (address(prior) != address(_value)) {\r\n                // TODO sweep balance from address(prior) to address(_value)\r\n            }\r\n            attributes[who] = (prior & ACCOUNT_ADDRESS_INV) | uint256(address(_value));\r\n        } else if (_attribute == BLACKLISTED) {\r\n            if (_value != 0) {\r\n                attributes[who] = prior | ACCOUNT_BLACKLISTED;\r\n            } else  {\r\n                attributes[who] = prior & ACCOUNT_BLACKLISTED_INV;\r\n            }\r\n        } else if (_attribute == PASSED_KYCAML) {\r\n            if (_value != 0) {\r\n                attributes[who] = prior | ACCOUNT_KYC;\r\n            } else {\r\n                attributes[who] = prior & ACCOUNT_KYC_INV;\r\n            }\r\n        } else if (_attribute == REGISTERED_CONTRACT) {\r\n            if (_value != 0) {\r\n                attributes[who] = prior | ACCOUNT_HOOK;\r\n            } else {\r\n                attributes[who] = prior & ACCOUNT_HOOK_INV;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/TrueCoinReceiver.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\ncontract TrueCoinReceiver {\r\n    function tokenFallback( address from, uint256 value ) external;\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/ValTokenWithHook.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\n\r\n\r\ncontract ValTokenWithHook is IERC20, ModularStandardToken, RegistrySubscriber {\r\n\r\n    event Burn(address indexed from, uint256 indexed amount);\r\n    event Mint(address indexed to, uint256 indexed amount);\r\n\r\n    function _resolveRecipient(address _to) internal view returns (address to, bool hook) {\r\n        uint256 flags = (attributes[uint144(uint160(_to) >> 20)]);\r\n        if (flags == 0) {\r\n            to = _to;\r\n            // attributes[uint144(uint160(to) >> 20)] = uint256(to);\r\n            hook = false;\r\n        } else {\r\n            to = address(flags);\r\n            hook = (flags & ACCOUNT_HOOK) != 0;\r\n        }\r\n    }\r\n\r\n    modifier resolveSender(address _from) {\r\n        uint256 flags = (attributes[uint144(uint160(_from) >> 20)]);\r\n        address from = address(flags);\r\n        if (from != address(0)) {\r\n            require(from == _from, \"account collision\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function _transferFromAllArgs(address _from, address _to, uint256 _value, address _spender) internal {\r\n        _subAllowance(_from, _spender, _value);\r\n        _transferAllArgs(_from, _to, _value);\r\n    }\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\r\n        _transferFromAllArgs(_from, _to, _value, msg.sender);\r\n        return true;\r\n    }\r\n    function transfer(address _to, uint256 _value) external returns (bool) {\r\n        _transferAllArgs(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    function _transferAllArgs(address _from, address _to, uint256 _value) internal resolveSender(_from) {\r\n        _subBalance(_from, _value);\r\n        emit Transfer(_from, _to, _value);\r\n        bool hasHook;\r\n        address to;\r\n        (to, hasHook) = _resolveRecipient(_to);\r\n        _addBalance(to, _value);\r\n        if (_to != to) {\r\n            emit Transfer(_to, to, _value);\r\n        }\r\n        if (hasHook) {\r\n            TrueCoinReceiver(to).tokenFallback(_from, _value);\r\n        }\r\n    }\r\n\r\n    function _burn(address _from, uint256 _value) internal returns (uint256 resultBalance_, uint256 resultSupply_) {\r\n        emit Transfer(_from, address(0), _value);\r\n        emit Burn(_from, _value);\r\n        resultBalance_ = _subBalance(_from, _value);\r\n        resultSupply_ = totalSupply.sub(_value, \"removing more stake than in supply\");\r\n        totalSupply = resultSupply_;\r\n    }\r\n\r\n    function _mint(address _to, uint256 _value) internal {\r\n        emit Transfer(address(0), _to, _value);\r\n        emit Mint(_to, _value);\r\n        (address to, bool hook) = _resolveRecipient(_to);\r\n        if (_to != to) {\r\n            emit Transfer(_to, to, _value);\r\n        }\r\n        _addBalance(to, _value);\r\n        totalSupply = totalSupply.add(_value, \"totalSupply overflow\");\r\n        if (hook) {\r\n            TrueCoinReceiver(to).tokenFallback(address(0x0), _value);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/AStakedToken.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Abstract StakedToken\r\n * @dev Single token staking model for ERC-20\r\n * StakedToken represents a share in an Assurace Pool.\r\n * Accounts stake ERC-20 staking asset and recieve ERC-20 reward asset.\r\n * StakingOpportunityFactory creates instances of StakedToken\r\n */\r\ncontract AStakedToken is ValTokenWithHook {\r\n    using ValSafeMath for uint256;\r\n\r\n    // current representation of rewards per stake\r\n    // this number only goes up\r\n    uint256 cumulativeRewardsPerStake;\r\n\r\n    // amount each account has claimed up to cumulativeRewardsPerStake\r\n    // claiming rewards sets claimedRewardsPerStake to cumulativeRewardsPerStake\r\n    mapping (address => uint256) claimedRewardsPerStake;\r\n\r\n    // amount that has been awarded to the pool but not pool holders\r\n    // tracks leftovers for when stake gets very large\r\n    // strictly less than total supply, usually ever less than $1\r\n    // rolls over the next time we award\r\n    uint256 rewardsRemainder;\r\n\r\n    // total value of stake not currently in supply and not currrently withdrawn\r\n    // need this to calculate how many new staked tokens to awarn when depositing\r\n    uint256 public stakePendingWithdrawal;\r\n\r\n    // map accounts => timestamp => money\r\n    // have to reference timestamp to access previous withdrawal\r\n    // multiple withdrawals in the same block increase amount for that timestamp\r\n    // same acconut that initiates withdrawal needs to complete withdrawal\r\n    mapping (address => mapping (uint256 => uint256)) pendingWithdrawals;\r\n\r\n    // unstake period in days\r\n    uint256 constant UNSTAKE_PERIOD = 14 days;\r\n\r\n    // PendingWithdrawal event is initiated when finalizing stake\r\n    // used to help user interfaces\r\n    event PendingWithdrawal(address indexed staker, uint256 indexed timestamp, uint256 indexed amount);\r\n\r\n    /**\r\n     * @dev Get unclaimed reward balance for staker\r\n     * @param _staker address of staker\r\n     * @return claimedRewards_ withdrawable amount of rewards belonging to this staker\r\n    **/\r\n    function unclaimedRewards(address _staker) public view returns (uint256 unclaimedRewards_) {\r\n        uint256 stake = balanceOf[_staker];\r\n        if (stake == 0) {\r\n            return 0;\r\n        }\r\n        unclaimedRewards_ = stake.mul(cumulativeRewardsPerStake.sub(claimedRewardsPerStake[_staker], \"underflow\"), \"unclaimed rewards overflow\");\r\n    }\r\n\r\n    /// @return ERC-20 stake asset\r\n    function stakeAsset() internal view returns (StakingAsset);\r\n\r\n    /// @return ERC-20 reward asset\r\n    function rewardAsset() internal view returns (StakingAsset);\r\n\r\n    /// @return liquidator address\r\n    function liquidator() internal view returns (address);\r\n\r\n    // max int size to prevent overflow\r\n    uint256 constant MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    // default ratio is how much we multiply trusttokens by to calculate stake\r\n    // helps achieve precision when dividing\r\n    uint256 constant DEFAULT_RATIO = 1000;\r\n\r\n    /**\r\n     * @dev Initialize function called by constructor\r\n     * Approves liqudiator for maximum amount\r\n    */\r\n    function initialize() internal {\r\n        stakeAsset().approve(liquidator(), MAX_UINT256);\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides from ValTokenWithHook to track rewards remainder\r\n     * If account is zero, we consider this value for gas refund\r\n     * When you transfer your stake you transfer your unclaimed rewards\r\n     * Contracts that have this staking token don't know they have rewards\r\n     * This way we an exchange on uniswap or other exchanges\r\n     */\r\n    function _transferAllArgs(address _from, address _to, uint256 _value) internal resolveSender(_from) {\r\n        uint256 fromRewards = claimedRewardsPerStake[_from];\r\n        if (_subBalance(_from, _value) == 0) {\r\n            claimedRewardsPerStake[_from] = 0;\r\n        }\r\n        emit Transfer(_from, _to, _value);\r\n        (address to, bool hasHook) = _resolveRecipient(_to);\r\n        if (_to != to) {\r\n            emit Transfer(_to, to, _value);\r\n        }\r\n        // here we track rewards remainder and claimed rewards per stake\r\n        // claimed rewards per stake of _to is the weighted average of the\r\n        // prior value and added value according to their unclaimedrewards\r\n        uint256 priorBalance = _addBalance(to, _value);\r\n        uint256 numerator = (_value * fromRewards + priorBalance * claimedRewardsPerStake[to]);\r\n        uint256 denominator = (_value + priorBalance);\r\n        uint256 result = numerator / denominator;\r\n        uint256 remainder = numerator % denominator;\r\n        if (remainder > 0) {\r\n            // remainder always less than denominator\r\n            rewardsRemainder = rewardsRemainder.add(denominator - remainder, \"remainder overflow\");\r\n            result += 1;\r\n        }\r\n        claimedRewardsPerStake[to] = result;\r\n        if (hasHook) {\r\n            TrueCoinReceiver(to).tokenFallback(_from, _value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides from ValTokenWithHook\r\n     * At award time, award is not distributed to pending withdrawals\r\n     * At deposit time, pending withdrawals are remembered to calculate stake per deposit\r\n     * At slash time, pending withdrawals are slashed\r\n     * So, pending withdrawals are quantified in stake\r\n     * Pending withdrawals reduce both\r\n     * Only KYC approved accounts can claim rewards\r\n     * Called by initUnstake to burn and modify total supply\r\n     * We use totalSupply to calculate rewards\r\n     */\r\n    function _burn(address _from, uint256 _value) internal returns (uint256 resultBalance_, uint256 resultSupply_) {\r\n        (resultBalance_, resultSupply_) = super._burn(_from, _value);\r\n        uint256 userClaimedRewardsPerStake = claimedRewardsPerStake[_from];\r\n        uint256 totalRewardsPerStake = cumulativeRewardsPerStake;\r\n        uint256 pendingRewards = (totalRewardsPerStake - userClaimedRewardsPerStake) * _value;\r\n        if (resultBalance_ == 0) {\r\n            // pay out the unclaimed rewards to the pool\r\n            _award(pendingRewards);\r\n        } else {\r\n            // merge unclaimed rewards with remaining balance\r\n            // in the case this goes negative, award remainder to pool\r\n            uint256 pendingRewardsPerStake = pendingRewards / resultBalance_;\r\n            uint256 award_ = pendingRewards % resultBalance_;\r\n            if (pendingRewardsPerStake > userClaimedRewardsPerStake) {\r\n                claimedRewardsPerStake[_from] = 0;\r\n                _award(award_.add((pendingRewardsPerStake - userClaimedRewardsPerStake).mul(resultBalance_, \"award overflow\"), \"award overflow?\"));\r\n            } else {\r\n                claimedRewardsPerStake[_from] = userClaimedRewardsPerStake - pendingRewardsPerStake;\r\n                _award(award_);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides from ValTokenWithHook\r\n     * Checks rewards remainder of recipient of mint\r\n     */\r\n    function _mint(address _to, uint256 _value) internal {\r\n        emit Transfer(address(0), _to, _value);\r\n        emit Mint(_to, _value);\r\n        (address to, bool hook) = _resolveRecipient(_to);\r\n        if (_to != to) {\r\n            emit Transfer(_to, to, _value);\r\n        }\r\n        uint256 priorBalance = _addBalance(to, _value);\r\n        uint256 numerator = (cumulativeRewardsPerStake * _value + claimedRewardsPerStake[_to] * priorBalance);\r\n        uint256 denominator = (priorBalance + _value);\r\n        uint256 result = numerator / denominator;\r\n        uint256 remainder = numerator % denominator;\r\n        if (remainder > 0) {\r\n            rewardsRemainder = rewardsRemainder.add(denominator - remainder, \"remainder overflow\");\r\n            result += 1;\r\n        }\r\n        claimedRewardsPerStake[_to] = result;\r\n        totalSupply = totalSupply.add(_value, \"totalSupply overflow\");\r\n        if (hook) {\r\n            TrueCoinReceiver(to).tokenFallback(address(0x0), _value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when this contract recieves stake. Called by token fallback.\r\n     * Issue stake to _staker according to _amount\r\n     * Invoked after _amount is deposited in this contract\r\n    */\r\n    function _deposit(address _staker, uint256 _amount) internal {\r\n        uint256 balance = stakeAsset().balanceOf(address(this));\r\n        uint256 stakeAmount;\r\n        if (_amount < balance) {\r\n            stakeAmount = _amount.mul(totalSupply.add(stakePendingWithdrawal, \"stakePendingWithdrawal > totalSupply\"), \"overflow\").div(balance - _amount, \"insufficient deposit\");\r\n        } else {\r\n            // first staker\r\n            require(totalSupply == 0, \"pool drained\");\r\n            stakeAmount = _amount * DEFAULT_RATIO;\r\n        }\r\n        _mint(_staker, stakeAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev If is reward asset, reward pool.\r\n     * If stake asset, deposit.\r\n     * Single staking token model. Can't stake TUSD for TUSD.\r\n     */\r\n    function tokenFallback(address _originalSender, uint256 _amount) external {\r\n        if (msg.sender == address(stakeAsset())) {\r\n            if (_originalSender == liquidator()) {\r\n                // do not credit the liquidator\r\n                return;\r\n            }\r\n            _deposit(_originalSender, _amount);\r\n        } else if (msg.sender == address(rewardAsset())) {\r\n            _award(_amount);\r\n        } else {\r\n            revert(\"Wrong token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit stake into the pool.\r\n     * @param _amount amount to deposit.\r\n     */\r\n    function deposit(uint256 _amount) external {\r\n        require(stakeAsset().transferFrom(msg.sender, address(this), _amount));\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize unstake. Can specify a portion of your balance to unstake.\r\n     * @param _maxAmount max amount caller wishes to unstake (in this.balanceOf units)\r\n     * @return unstake_\r\n    */\r\n    function initUnstake(uint256 _maxAmount) external returns (uint256 unstake_) {\r\n        unstake_ = balanceOf[msg.sender];\r\n        if (unstake_ > _maxAmount) {\r\n            unstake_ = _maxAmount;\r\n        }\r\n        _burn(msg.sender, unstake_); // burn tokens\r\n\r\n        // add to stake pending withdrawals and account pending withdrawals\r\n        stakePendingWithdrawal = stakePendingWithdrawal.add(unstake_, \"stakePendingWithdrawal overflow\");\r\n        pendingWithdrawals[msg.sender][now] = pendingWithdrawals[msg.sender][now].add(unstake_, \"pendingWithdrawals overflow\");\r\n        emit PendingWithdrawal(msg.sender, now, unstake_);\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize unstake after 2 weeks.\r\n     * Loop over timestamps\r\n     * Checks if unstake perioud has passed, if yes, calculate how much stake account get\r\n     * @param recipient recipient of\r\n     * @param _timestamps timestamps to\r\n     */\r\n    function finalizeUnstake(address recipient, uint256[] calldata _timestamps) external {\r\n        uint256 totalUnstake = 0;\r\n        // loop through timestamps and calculate total unstake\r\n        for (uint256 i = _timestamps.length; i --> 0;) {\r\n            uint256 timestamp = _timestamps[i];\r\n            require(timestamp + UNSTAKE_PERIOD <= now, \"must wait 2 weeks to unstake\");\r\n            // add to total unstake amount\r\n            totalUnstake = totalUnstake.add(pendingWithdrawals[msg.sender][timestamp], \"stake overflow\");\r\n\r\n            pendingWithdrawals[msg.sender][timestamp] = 0;\r\n        }\r\n        IERC20 stake = stakeAsset(); // get stake asset\r\n        uint256 totalStake = stake.balanceOf(address(this)); // get total stake\r\n\r\n        // calulate correstponding stake\r\n        // consider stake pending withdrawal and total supply of stake token\r\n        // totalUnstake / totalSupply = correspondingStake / totalStake\r\n        // totalUnstake * totalStake / totalSupply = correspondingStake\r\n        uint256 correspondingStake = totalStake.mul(totalUnstake, \"totalStake*totalUnstake overflow\").div(totalSupply.add(stakePendingWithdrawal, \"overflow totalSupply+stakePendingWithdrawal\"), \"zero totals\");\r\n        stakePendingWithdrawal = stakePendingWithdrawal.sub(totalUnstake, \"stakePendingWithdrawal underflow\");\r\n        stake.transfer(recipient, correspondingStake);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer awards to the staking pool\r\n     * @param _amount of rewardAsset to award\r\n     */\r\n    function award(uint256 _amount) external {\r\n        require(rewardAsset().transferFrom(msg.sender, address(this), _amount));\r\n    }\r\n\r\n    /**\r\n     * @dev Award stakig pool.\r\n     * @param _amount amount of rewardAsset to reward\r\n     */\r\n    function _award(uint256 _amount) internal {\r\n        uint256 remainder = rewardsRemainder.add(_amount, \"rewards overflow\");\r\n        uint256 totalStake = totalSupply;\r\n        if (totalStake > 0) {\r\n            uint256 rewardsAdded = remainder / totalStake;\r\n            rewardsRemainder = remainder % totalStake;\r\n            cumulativeRewardsPerStake = cumulativeRewardsPerStake.add(rewardsAdded, \"cumulative rewards overflow\");\r\n        } else {\r\n            rewardsRemainder = remainder;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Claim rewards and send to a destination.\r\n     * Fails if sender account is not KYC.\r\n     * KYC flag doesn't have to be synced to the registry.\r\n     * @param _destination withdraw destination\r\n     */\r\n    function claimRewards(address _destination) external {\r\n        // check KYC attribte\r\n        require(attributes[uint144(uint160(msg.sender) >> 20)] & ACCOUNT_KYC != 0 || registry().getAttributeValue(msg.sender, PASSED_KYCAML) != 0, \"please register at app.trusttoken.com\");\r\n\r\n        // calculate how much stake and rewards account has\r\n        uint256 stake = balanceOf[msg.sender];\r\n        if (stake == 0) {\r\n            return;\r\n        }\r\n        uint256 dueRewards = stake.mul(cumulativeRewardsPerStake.sub(claimedRewardsPerStake[msg.sender], \"underflow\"), \"dueRewards overflow\");\r\n        if (dueRewards == 0) {\r\n            return;\r\n        }\r\n        claimedRewardsPerStake[msg.sender] = cumulativeRewardsPerStake;\r\n\r\n        // decimals are 3 more than stake asset decimals\r\n        require(rewardAsset().transfer(_destination, dueRewards));\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return stakeAsset().decimals() + 3;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return string(abi.encodePacked(stakeAsset().name(), \" staked for \", rewardAsset().name()));\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return string(abi.encodePacked(stakeAsset().symbol(), \":\", rewardAsset().symbol()));\r\n    }\r\n}\r\n\r\n// File: @trusttoken/trusttokens/contracts/StakedToken.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title StakedToken\r\n * @dev Implementation of AStakedToken\r\n**/\r\ncontract StakedToken is AStakedToken {\r\n    StakingAsset stakeAsset_;\r\n    StakingAsset rewardAsset_;\r\n    Registry registry_;\r\n    address liquidator_;\r\n\r\n    /**\r\n     * @dev configure this contract\r\n     */\r\n    function configure(\r\n        StakingAsset _stakeAsset,\r\n        StakingAsset _rewardAsset,\r\n        Registry _registry,\r\n        address _liquidator\r\n    ) external {\r\n        require(!initalized, \"already initalized StakedToken\");\r\n        stakeAsset_ = _stakeAsset;\r\n        rewardAsset_ = _rewardAsset;\r\n        registry_ = _registry;\r\n        liquidator_ = _liquidator;\r\n        initialize();\r\n        initalized = true;\r\n    }\r\n\r\n    function stakeAsset() internal view returns (StakingAsset) {\r\n        return stakeAsset_;\r\n    }\r\n\r\n    function rewardAsset() internal view returns (StakingAsset) {\r\n        return rewardAsset_;\r\n    }\r\n\r\n    function registry() internal view returns (Registry) {\r\n        return registry_;\r\n    }\r\n\r\n    function liquidator() internal view returns (address) {\r\n        return liquidator_;\r\n    }\r\n}\r\n\r\n// File: contracts/TrueCurrencies/AssuredFinancialOpportunityStorage.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n/*\r\nDefines the storage layout of the token implementaiton contract. Any newly declared\r\nstate variables in future upgrades should be appened to the bottom. Never remove state variables\r\nfrom this list\r\n */\r\ncontract AssuredFinancialOpportunityStorage {\r\n\r\n    // how much zTUSD we've issued (total supply)\r\n    uint zTUSDIssued;\r\n\r\n    // percentage of interest for staking pool\r\n    // 1% = 10\r\n    uint32 rewardBasis;\r\n\r\n    // adjustment factor used when changing reward basis\r\n    // we change the adjustment factor\r\n    uint adjustmentFactor;\r\n\r\n    // mintokenValue can never decrease\r\n    uint minTokenValue;\r\n\r\n\r\n    /* Additionally, we have several keccak-based storage locations.\r\n     * If you add more keccak-based storage mappings, such as mappings, you must document them here.\r\n     * If the length of the keccak input is the same as an existing mapping, it is possible there could be a preimage collision.\r\n     * A preimage collision can be used to attack the contract by treating one storage location as another,\r\n     * which would always be a critical issue.\r\n     * Carefully examine future keccak-based storage to ensure there can be no preimage collisions.\r\n     *******************************************************************************************************\r\n     ** length     input                                                         usage\r\n     *******************************************************************************************************\r\n     ** 19         \"trueXXX.proxy.owner\"                                         Proxy Owner\r\n     ** 27         \"trueXXX.pending.proxy.owner\"                                 Pending Proxy Owner\r\n     ** 28         \"trueXXX.proxy.implementation\"                                Proxy Implementation\r\n     ** 32         uint256(11)                                                   gasRefundPool_Deprecated\r\n     ** 64         uint256(address),uint256(14)                                  balanceOf\r\n     ** 64         uint256(address),keccak256(uint256(address),uint256(15))      allowance\r\n     ** 64         uint256(address),keccak256(bytes32,uint256(16))               attributes\r\n    **/\r\n}\r\n\r\n// File: contracts/TrueCurrencies/modularERC20/InitializableOwnable.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\n/**\r\n * @title InitializableOwnable\r\n * @dev The InitializableOwnable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract InitializableOwnable {\r\n    address public owner;\r\n    bool configured = false;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The InitializableOwnable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function _configure() internal {\r\n        require(!configured);\r\n        owner = msg.sender;\r\n        configured = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/TrueCurrencies/modularERC20/InitializableClaimable.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\n\r\n/**\r\n * @title InitializableOwnable\r\n * @dev Extension for the InstantiatableOwnable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract InitializableClaimable is InitializableOwnable {\r\n    address public pendingOwner;\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner address to finalize the transfer.\r\n     */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/TrueReward/utilities/FractionalExponents.sol\r\n\r\n/**\r\n * FractionalExponents\r\n * Copied and modified from:\r\n *  https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/converter/BancorFormula.sol#L289\r\n * Redistributed Under Apache License 2.0:\r\n *  https://github.com/bancorprotocol/contracts/blob/master/LICENSE\r\n * Provided as an answer to:\r\n *  https://ethereum.stackexchange.com/questions/50527/is-there-any-efficient-way-to-compute-the-exponentiation-of-an-fractional-base-a\r\n */\r\n\r\npragma solidity 0.5.13;\r\n\r\ncontract FractionalExponents  {\r\n\r\n    uint256 private constant ONE = 1;\r\n    uint32 private constant MAX_WEIGHT = 1000000;\r\n    uint8 private constant MIN_PRECISION = 32;\r\n    uint8 private constant MAX_PRECISION = 127;\r\n\r\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\r\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\r\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\r\n\r\n    uint256 private constant LN2_NUMERATOR   = 0x3f80fe03f80fe03f80fe03f80fe03f8;\r\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\r\n\r\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\r\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\r\n\r\n    uint256[128] private maxExpArray;\r\n    function BancorFormula() public {\r\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\r\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\r\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\r\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\r\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\r\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\r\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\r\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\r\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\r\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\r\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\r\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\r\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\r\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\r\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\r\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\r\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\r\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\r\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\r\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\r\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\r\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\r\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\r\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\r\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\r\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\r\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\r\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\r\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\r\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\r\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\r\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\r\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\r\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\r\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\r\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\r\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\r\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\r\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\r\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\r\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\r\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\r\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\r\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\r\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\r\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\r\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\r\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\r\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\r\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\r\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\r\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\r\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\r\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\r\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\r\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\r\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\r\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\r\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\r\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\r\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\r\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\r\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\r\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\r\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\r\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\r\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\r\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\r\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\r\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\r\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\r\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\r\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\r\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\r\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\r\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\r\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\r\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\r\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\r\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\r\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\r\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\r\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\r\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\r\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\r\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\r\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\r\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\r\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\r\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\r\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\r\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\r\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\r\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\r\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\r\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n        General Description:\r\n            Determine a value of precision.\r\n            Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\r\n            Return the result along with the precision used.\r\n\r\n        Detailed Description:\r\n            Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\r\n            The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\r\n            The larger \"precision\" is, the more accurately this value represents the real value.\r\n            However, the larger \"precision\" is, the more bits are required in order to store this value.\r\n            And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\r\n            This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\r\n            Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\r\n            This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\r\n            This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\r\n    */\r\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) public view returns (uint256, uint8) {\r\n        assert(_baseN < MAX_NUM);\r\n\r\n        uint256 baseLog;\r\n        uint256 base = _baseN * FIXED_1 / _baseD;\r\n        if (base < OPT_LOG_MAX_VAL) {\r\n            baseLog = optimalLog(base);\r\n        }\r\n        else {\r\n            baseLog = generalLog(base);\r\n        }\r\n\r\n        uint256 baseLogTimesExp = baseLog * _expN / _expD;\r\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\r\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\r\n        }\r\n        else {\r\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\r\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\r\n        }\r\n    }\r\n\r\n    /**\r\n        Compute log(x / FIXED_1) * FIXED_1.\r\n        This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\r\n    */\r\n    function generalLog(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\r\n        if (x >= FIXED_2) {\r\n            uint8 count = floorLog2(x / FIXED_1);\r\n            x >>= count; // now x < 2\r\n            res = count * FIXED_1;\r\n        }\r\n\r\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\r\n        if (x > FIXED_1) {\r\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\r\n                x = (x * x) / FIXED_1; // now 1 < x < 4\r\n                if (x >= FIXED_2) {\r\n                    x >>= 1; // now 1 < x < 2\r\n                    res += ONE << (i - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return res * LN2_NUMERATOR / LN2_DENOMINATOR;\r\n    }\r\n\r\n    /**\r\n        Compute the largest integer smaller than or equal to the binary logarithm of the input.\r\n    */\r\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\r\n        uint8 res = 0;\r\n\r\n        if (_n < 256) {\r\n            // At most 8 iterations\r\n            while (_n > 1) {\r\n                _n >>= 1;\r\n                res += 1;\r\n            }\r\n        }\r\n        else {\r\n            // Exactly 8 iterations\r\n            for (uint8 s = 128; s > 0; s >>= 1) {\r\n                if (_n >= (ONE << s)) {\r\n                    _n >>= s;\r\n                    res |= s;\r\n                }\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n        The global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\r\n        - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\r\n        - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\r\n    */\r\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\r\n        uint8 lo = MIN_PRECISION;\r\n        uint8 hi = MAX_PRECISION;\r\n\r\n        while (lo + 1 < hi) {\r\n            uint8 mid = (lo + hi) / 2;\r\n            if (maxExpArray[mid] >= _x)\r\n                lo = mid;\r\n            else\r\n                hi = mid;\r\n        }\r\n\r\n        if (maxExpArray[hi] >= _x)\r\n            return hi;\r\n        if (maxExpArray[lo] >= _x)\r\n            return lo;\r\n\r\n        assert(false);\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n        This function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\r\n        It approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\r\n        It returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\r\n        The global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\r\n        The maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\r\n    */\r\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\r\n        uint256 xi = _x;\r\n        uint256 res = 0;\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\r\n\r\n\r\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\r\n    }\r\n\r\n    /**\r\n        Return log(x / FIXED_1) * FIXED_1\r\n        Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\r\n    */\r\n    function optimalLog(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        uint256 y;\r\n        uint256 z;\r\n        uint256 w;\r\n\r\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\r\n            res += 0x40000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\r\n        }\r\n\r\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\r\n            res += 0x20000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0xa45af1e1f40c333b3de1db4dd55f29a7;\r\n        }\r\n\r\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\r\n            res += 0x10000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x910b022db7ae67ce76b441c27035c6a1;\r\n        }\r\n\r\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\r\n            res += 0x08000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x88415abbe9a76bead8d00cf112e4d4a8;\r\n        }\r\n\r\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\r\n            res += 0x04000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x84102b00893f64c705e841d5d4064bd3;\r\n        }\r\n\r\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\r\n            res += 0x02000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x8204055aaef1c8bd5c3259f4822735a2;\r\n        }\r\n\r\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\r\n            res += 0x01000000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x810100ab00222d861931c15e39b44e99;\r\n        }\r\n\r\n        if (x >= 0x808040155aabbbe9451521693554f733) {\r\n            res += 0x00800000000000000000000000000000;\r\n            x = x * FIXED_1 / 0x808040155aabbbe9451521693554f733;\r\n        }\r\n\r\n        z = y = x - FIXED_1;\r\n        w = y * y / FIXED_1;\r\n\r\n        res += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n\r\n        res += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n\r\n        res += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n\r\n        res += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n\r\n        res += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n\r\n        res += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n\r\n        res += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000;\r\n        z = z * w / FIXED_1;\r\n\r\n        res += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n        Return e ^ (x / FIXED_1) * FIXED_1\r\n        Input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\r\n    */\r\n    function optimalExp(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        uint256 y;\r\n        uint256 z;\r\n\r\n        z = y = x % 0x10000000000000000000000000000000;\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\r\n\r\n        z = z * y / FIXED_1;\r\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\r\n\r\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\r\n\r\n        if ((x & 0x010000000000000000000000000000000) != 0) {\r\n            res = res * 0x1c3d6a24ed82218787d624d3e5eba95f9 / 0x18ebef9eac820ae8682b9793ac6d1e776;\r\n        }\r\n\r\n        if ((x & 0x020000000000000000000000000000000) != 0) {\r\n            res = res * 0x18ebef9eac820ae8682b9793ac6d1e778 / 0x1368b2fc6f9609fe7aceb46aa619baed4;\r\n        }\r\n\r\n        if ((x & 0x040000000000000000000000000000000) != 0) {\r\n            res = res * 0x1368b2fc6f9609fe7aceb46aa619baed5 / 0x0bc5ab1b16779be3575bd8f0520a9f21f;\r\n        }\r\n\r\n        if ((x & 0x080000000000000000000000000000000) != 0) {\r\n            res = res * 0x0bc5ab1b16779be3575bd8f0520a9f21e / 0x0454aaa8efe072e7f6ddbab84b40a55c9;\r\n        }\r\n\r\n        if ((x & 0x100000000000000000000000000000000) != 0) {\r\n            res = res * 0x0454aaa8efe072e7f6ddbab84b40a55c5 / 0x00960aadc109e7a3bf4578099615711ea;\r\n        }\r\n\r\n        if ((x & 0x200000000000000000000000000000000) != 0) {\r\n            res = res * 0x00960aadc109e7a3bf4578099615711d7 / 0x0002bf84208204f5977f9a8cf01fdce3d;\r\n        }\r\n\r\n        if ((x & 0x400000000000000000000000000000000) != 0) {\r\n            res = res * 0x0002bf84208204f5977f9a8cf01fdc307 / 0x0000003c6ab775dd0b95b4cbee7e65d11;\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n\r\n// File: contracts/TrueReward/FinancialOpportunity.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n/**\r\n * @title FinancialOpportunity\r\n * @dev Interface for third parties to implement financial opportunities\r\n *\r\n * -- Overview --\r\n * The goal of this contract is to allow anyone to create an opportunity\r\n * to earn interest on TUSD. deposit() \"mints\" yTUSD whcih is redeemable\r\n * for some amount of TUSD. TrueUSD wraps this contractwith TrustToken\r\n * Assurance, which provides protection from bugs and system design flaws\r\n * TUSD is a compliant stablecoin, therefore we do not allow transfers of\r\n * yTUSD, thus there are no transfer functions\r\n *\r\n * -- tokenValue() --\r\n * This function returns the value in TUSD of 1 yTUSD\r\n * This value should never decrease\r\n *\r\n * -- TUSD vs yTUSD --\r\n * yTUSD represents a fixed value which is redeemable for some amount of TUSD\r\n * Think of yTUSD like cTUSD, where cTokens are minted and increase in value versus\r\n * the underlying asset as interest is accrued\r\n *\r\n * -- totalSupply() --\r\n * This function returns the total supply of yTUSD issued by this contract\r\n * It is important to track this value accuratley and add/deduct the correct\r\n * amount on deposit/redemptions\r\n *\r\n * -- Assumptions --\r\n * - tokenValue can never decrease\r\n * - total TUSD owed to depositors = tokenValue() * totalSupply()\r\n */\r\ninterface FinancialOpportunity {\r\n\r\n    /**\r\n     * @dev Returns total supply of yTUSD in this contract\r\n     *\r\n     * @return total supply of yTUSD in this contract\r\n    **/\r\n    function totalSupply() external view returns (uint);\r\n\r\n    /**\r\n     * @dev Exchange rate between TUSD and yTUSD\r\n     *\r\n     * tokenValue should never decrease\r\n     *\r\n     * @return TUSD / yTUSD price ratio\r\n     */\r\n    function tokenValue() external view returns(uint);\r\n\r\n    /**\r\n     * @dev deposits TrueUSD and returns yTUSD minted\r\n     *\r\n     * We can think of deposit as a minting function which\r\n     * will increase totalSupply of yTUSD based on the deposit\r\n     *\r\n     * @param from account to transferFrom\r\n     * @param amount amount in TUSD to deposit\r\n     * @return yTUSD minted from this deposit\r\n     */\r\n    function deposit(address from, uint amount) external returns(uint);\r\n\r\n    /**\r\n     * @dev Redeem yTUSD for TUSD and withdraw to account\r\n     *\r\n     * This function should use tokenValue to calculate\r\n     * how much TUSD is owed. This function should burn yTUSD\r\n     * after redemption\r\n     *\r\n     * This function must return value in TUSD\r\n     *\r\n     * @param to account to transfer TUSD for\r\n     * @param amount amount in TUSD to withdraw from finOp\r\n     * @return TUSD amount returned from this transaction\r\n     */\r\n    function redeem(address to, uint amount) external returns(uint);\r\n}\r\n\r\n// File: contracts/TrueReward/AssuredFinancialOpportunity.sol\r\n\r\npragma solidity 0.5.13;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AssuredFinancialOpportunity\r\n * @dev Wrap financial opportunity with Assurance\r\n *\r\n * -- Overview --\r\n * Rewards are earned as tokenValue() increases in the underlying opportunity\r\n * TUSD is never held in this contract - zTUSD represents value we owe to depositors\r\n *\r\n * -- zTUSD vs yTUSD --\r\n * zTUSD represents an amount of ASSURED TUSD owed to the zTUSD holder (depositors)\r\n * 1 zTUSD = (yTUSD ^ assurance ratio)\r\n * yTUSD represents an amount of NON-ASSURED TUSD owed to this contract\r\n * TUSD value = yTUSD * finOp.tokenValue()\r\n *\r\n * -- Awarding the Assurance Pool\r\n * The difference increases when depositors withdraw\r\n * Pool award is calculated as follows\r\n * (finOpValue * finOpBalance) - (assuredOpportunityBalance * assuredOpportunityTokenValue)\r\n *\r\n * -- Flash Assurance --\r\n * If a transfer fails, stake is sold from the assurance pool for TUSD\r\n * When stake is liquidated, the TUSD is sent out in the same transaction\r\n * Can attempt to sell bad debt at a later date and return value to the pool\r\n *\r\n * -- Assumptions --\r\n * tokenValue can never decrease for this contract. We want to guarantee\r\n * the awards earned on deposited TUSD and liquidate trusttokens for this amount\r\n * We allow the rewardBasis to be adjusted, but since we still need to maintain\r\n * the tokenValue, we calculate an adjustment factor and set minTokenValue\r\n *\r\n**/\r\ncontract AssuredFinancialOpportunity is FinancialOpportunity, AssuredFinancialOpportunityStorage, InitializableClaimable {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    // total basis points for pool awards\r\n    uint32 constant TOTAL_BASIS = 1000;\r\n\r\n    // external contracts\r\n    address finOpAddress;\r\n    address assuranceAddress;\r\n    address liquidatorAddress;\r\n    address exponentContractAddress;\r\n    address trueRewardBackedTokenAddress;\r\n\r\n    // address allowed to withdraw/deposit, usually set to address of TUSD smart contract\r\n    address fundsManager;\r\n\r\n    event Deposit(address account, uint256 tusd, uint256 ztusd);\r\n    event Redemption(address to, uint256 ztusd, uint256 tusd);\r\n    event Liquidation(address receiver, int256 debt);\r\n    event AwardPool(uint256 amount);\r\n    event AwardFailure(uint256 amount);\r\n\r\n    /// funds manager can deposit/withdraw from this opportunity\r\n    modifier onlyFundsManager() {\r\n        require(msg.sender == fundsManager, \"only funds manager\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev configure assured opportunity\r\n     */\r\n    function configure(\r\n        address _finOpAddress,                  // finOp to assure\r\n        address _assuranceAddress,              // assurance pool\r\n        address _liquidatorAddress,             // trusttoken liqudiator\r\n        address _exponentContractAddress,       // exponent contract\r\n        address _trueRewardBackedTokenAddress,  // token\r\n        address _fundsManager                   // funds manager\r\n    ) external {\r\n        require(_finOpAddress != address(0), \"finOp cannot be address(0)\");\r\n        require(_assuranceAddress != address(0), \"assurance pool cannot be address(0)\");\r\n        require(_liquidatorAddress != address(0), \"liquidator cannot be address(0)\");\r\n        require(_exponentContractAddress != address(0), \"exponent cannot be address(0)\");\r\n        require(_trueRewardBackedTokenAddress != address(0), \"token cannot be address(0)\");\r\n        require(_fundsManager != address(0), \"findsManager cannot be address(0)\");\r\n        super._configure(); // sender claims ownership here\r\n        finOpAddress = _finOpAddress;\r\n        assuranceAddress = _assuranceAddress;\r\n        liquidatorAddress = _liquidatorAddress;\r\n        exponentContractAddress = _exponentContractAddress;\r\n        trueRewardBackedTokenAddress = _trueRewardBackedTokenAddress;\r\n        fundsManager = _fundsManager;\r\n        // only update factors if they are zero (default)\r\n        if (adjustmentFactor == 0) {\r\n            adjustmentFactor = 1*10**18;\r\n        }\r\n        if (rewardBasis == 0) {\r\n            rewardBasis = TOTAL_BASIS; // set to 100% by default\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev total supply of zTUSD\r\n     * inherited from FinancialOpportunity.sol\r\n     */\r\n    function totalSupply() external view returns (uint256) {\r\n        return zTUSDIssued;\r\n    }\r\n\r\n    /**\r\n     * @dev value of TUSD per zTUSD\r\n     * inherited from FinancialOpportunity.sol\r\n     *\r\n     * @return TUSD value of zTUSD\r\n     */\r\n    function tokenValue() external view returns(uint256) {\r\n        return _tokenValue();\r\n    }\r\n\r\n    /**\r\n     * @dev deposit TUSD for zTUSD\r\n     * inherited from FinancialOpportunity.sol\r\n     *\r\n     * @param from address to deposit from\r\n     * @param amount TUSD amount to deposit\r\n     * @return zTUSD amount\r\n     */\r\n    function deposit(address from, uint256 amount) external onlyFundsManager returns(uint256) {\r\n        return _deposit(from, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev redeem zTUSD for TUSD\r\n     * inherited from FinancialOpportunity.sol\r\n     *\r\n     * @param to address to send tusd to\r\n     * @param amount amount of zTUSD to redeem\r\n     * @return amount of TUSD returned by finOp\r\n     */\r\n    function redeem(address to, uint256 amount) external onlyFundsManager returns(uint256) {\r\n        return _redeem(to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Get TUSD to be awarded to staking pool\r\n     * Calculated as the difference in value of total zTUSD and yTUSD\r\n     * (finOpTotalSupply * finOpTokenValue) - (zTUSDIssued * zTUSDTokenValue)\r\n     *\r\n     * @return pool balance in TUSD\r\n     */\r\n    function poolAwardBalance() public view returns (uint256) {\r\n        uint256 zTUSDValue = finOp().tokenValue().mul(finOp().totalSupply()).div(10**18);\r\n        uint256 yTUSDValue = _totalSupply().mul(_tokenValue()).div(10**18);\r\n        return zTUSDValue.sub(yTUSDValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Sell yTUSD for TUSD and deposit into staking pool.\r\n     * Award amount is the difference between zTUSD issued an\r\n     * yTUSD in the underlying financial opportunity\r\n     */\r\n    function awardPool() external {\r\n        uint256 amount = poolAwardBalance();\r\n        uint256 ytusd = _yTUSD(amount);\r\n\r\n        // sell pool debt and award TUSD to pool\r\n        (bool success, uint256 returnedAmount) = _attemptRedeem(address(this), ytusd);\r\n\r\n        if (success) {\r\n            token().transfer(address(pool()), returnedAmount);\r\n            emit AwardPool(returnedAmount);\r\n        }\r\n        else {\r\n            emit AwardFailure(returnedAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev set new reward basis for opportunity\r\n     * recalculate tokenValue and ensure tokenValue never decreases\r\n     *\r\n     * @param newBasis new reward basis\r\n     */\r\n    function setRewardBasis(uint32 newBasis) external onlyOwner {\r\n        minTokenValue = _tokenValue();\r\n\r\n        adjustmentFactor = adjustmentFactor\r\n            .mul(_calculateTokenValue(rewardBasis))\r\n            .div(_calculateTokenValue(newBasis));\r\n        rewardBasis = newBasis;\r\n    }\r\n\r\n    /**\r\n     * @dev Get supply amount of zTUSD issued\r\n     * @return zTUSD issued\r\n    **/\r\n    function _totalSupply() internal view returns (uint256) {\r\n        return zTUSDIssued;\r\n    }\r\n\r\n    /**\r\n     * Calculate yTUSD / zTUSD (opportunity value minus pool award)\r\n     * We assume opportunity tokenValue always goes up\r\n     *\r\n     * @return value of zTUSD\r\n     */\r\n    function _tokenValue() internal view returns(uint256) {\r\n        // if no assurance, use  opportunity tokenValue\r\n        if (rewardBasis == TOTAL_BASIS) {\r\n            return finOp().tokenValue();\r\n        }\r\n        uint256 calculatedValue = _calculateTokenValue(rewardBasis).mul(adjustmentFactor).div(10**18);\r\n        if(calculatedValue < minTokenValue) {\r\n            return minTokenValue;\r\n        } else {\r\n            return calculatedValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calculate TUSD value of zTUSD\r\n     * zTUSD = yTUSD ^ (rewardBasis / totalBasis)\r\n     * reward ratio = _rewardBasis / TOTAL_BASIS\r\n     *\r\n     * @param _rewardBasis reward basis (max TOTAL_BASIS)\r\n     * @return zTUSD token value\r\n     */\r\n    function _calculateTokenValue(uint32 _rewardBasis) internal view returns(uint256) {\r\n        (uint256 result, uint8 precision) = exponents().power(\r\n            finOp().tokenValue(), 10**18,\r\n            _rewardBasis, TOTAL_BASIS);\r\n        return result.mul(10**18).div(2 ** uint256(precision));\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit TUSD into wrapped opportunity.\r\n     * Calculate zTUSD value and add to issuance value.\r\n     *\r\n     * @param _account account to deposit tusd from\r\n     * @param _amount amount of tusd to deposit\r\n     */\r\n    function _deposit(address _account, uint256 _amount) internal returns(uint256) {\r\n        token().transferFrom(_account, address(this), _amount);\r\n\r\n        // deposit TUSD into opportunity\r\n        token().approve(finOpAddress, _amount);\r\n        finOp().deposit(address(this), _amount);\r\n\r\n        // calculate zTUSD value of deposit\r\n        uint256 ztusd = _amount.mul(10 ** 18).div(_tokenValue());\r\n\r\n        // update zTUSDIssued\r\n        zTUSDIssued = zTUSDIssued.add(ztusd);\r\n        emit Deposit(_account, _amount, ztusd);\r\n        return ztusd;\r\n    }\r\n\r\n    /**\r\n     * @dev Redeem zTUSD for TUSD\r\n     * Liquidate if opportunity fails to return TUSD.\r\n     *\r\n     * @param _to address to withdraw to\r\n     * @param ztusd amount in ytusd to redeem\r\n     * @return TUSD amount redeemed for zTUSD\r\n     */\r\n    function _redeem(address _to, uint256 ztusd) internal returns(uint256) {\r\n\r\n        // attempt withdraw to this contract\r\n        // here we redeem ztusd amount which leaves\r\n        // a small amount of yTUSD left in the finOp\r\n        // which can be redeemed by the assurance pool\r\n        (bool success, uint256 returnedAmount) = _attemptRedeem(address(this), ztusd);\r\n\r\n        // calculate reward amount\r\n        // todo feewet: check if expected amount is correct\r\n        // possible use precision threshold or smart rounding\r\n        // to eliminate micro liquidations\r\n        uint256 expectedAmount = _tokenValue().mul(ztusd).div(10**18);\r\n        uint256 liquidated = 0;\r\n\r\n        if (!success || (success && returnedAmount < expectedAmount)) {\r\n            liquidated = _liquidate(address(this), int256(expectedAmount.sub(returnedAmount)));\r\n        }\r\n\r\n        zTUSDIssued = zTUSDIssued.sub(ztusd, \"not enough supply\");\r\n\r\n        // transfer token to redeemer\r\n        require(token().transfer(_to, returnedAmount.add(liquidated)), \"transfer failed\");\r\n\r\n        emit Redemption(_to, ztusd, returnedAmount);\r\n        return returnedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Try to redeem and return success and amount\r\n     *\r\n     * @param _to redeemer address\r\n     * @param ztusd amount in ztusd\r\n    **/\r\n    function _attemptRedeem(address _to, uint256 ztusd) internal returns (bool, uint) {\r\n        uint256 returnedAmount;\r\n\r\n        // attempt to withdraw from opportunity\r\n        (bool success, bytes memory returnData) = address(finOp()).call(\r\n            abi.encodePacked(finOp().redeem.selector, abi.encode(_to, ztusd))\r\n        );\r\n\r\n        if (success) { // successfully got TUSD :)\r\n            returnedAmount = abi.decode(returnData, (uint256));\r\n        }\r\n        else { // failed get TUSD :(\r\n            returnedAmount = 0;\r\n        }\r\n        return (success, returnedAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Liquidate tokens in staking pool to cover debt\r\n     * Sends tusd to receiver\r\n     *\r\n     * @param _receiver address to recieve tusd\r\n     * @param _debt tusd debt to be liquidated\r\n     * @return amount liquidated\r\n    **/\r\n    function _liquidate(address _receiver, int256 _debt) internal returns (uint256) {\r\n        liquidator().reclaim(_receiver, _debt);\r\n        emit Liquidation(_receiver, _debt);\r\n        return uint(_debt);\r\n    }\r\n\r\n    /**\r\n     * @dev convert tusd value into yTUSD value\r\n     * @param _tusd TUSD to convert\r\n     * @return yTUSD value of TUSD\r\n     */\r\n    function _yTUSD(uint256 _tusd) internal view returns (uint256) {\r\n        return _tusd.mul(10**18).div(finOp().tokenValue());\r\n    }\r\n\r\n    /**\r\n     * @dev convert tusd value into zTUSD value\r\n     * @param _tusd TUSD to convert\r\n     * @return zTUSD value of TUSD\r\n     */\r\n    function _zTUSD(uint256 _tusd) internal view returns (uint256) {\r\n        return _tusd.mul(10**18).div(_tokenValue());\r\n    }\r\n\r\n    /// @dev claim ownership of liquidator\r\n    function claimLiquidatorOwnership() external onlyOwner {\r\n        liquidator().claimOwnership();\r\n    }\r\n\r\n    /// @dev transfer ownership of liquidator\r\n    function transferLiquidatorOwnership(address newOwner) external onlyOwner {\r\n        liquidator().transferOwnership(newOwner);\r\n    }\r\n\r\n    /// @dev getter for financial opportuniry\r\n    /// @return financial opportunity\r\n    function finOp() public view returns(FinancialOpportunity) {\r\n        return FinancialOpportunity(finOpAddress);\r\n    }\r\n\r\n    /// @dev getter for staking pool\r\n    /// @return staking pool\r\n    function pool() public view returns(StakedToken) {\r\n        return StakedToken(assuranceAddress); // StakedToken is assurance staking pool\r\n    }\r\n\r\n    /// @dev getter for liquidator\r\n    function liquidator() public view returns (Liquidator) {\r\n        return Liquidator(liquidatorAddress);\r\n    }\r\n\r\n    /// @dev getter for exponents contract\r\n    function exponents() public view returns (FractionalExponents){\r\n        return FractionalExponents(exponentContractAddress);\r\n    }\r\n\r\n    /// @dev deposit token (TrueUSD)\r\n    function token() public view returns (IERC20){\r\n        return IERC20(trueRewardBackedTokenAddress);\r\n    }\r\n\r\n    /// @dev default payable\r\n    function() external payable {}\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AwardFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AwardPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tusd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ztusd\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"debt\",\"type\":\"int256\"}],\"name\":\"Liquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ztusd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tusd\",\"type\":\"uint256\"}],\"name\":\"Redemption\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"awardPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimLiquidatorOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_finOpAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assuranceAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exponentContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trueRewardBackedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fundsManager\",\"type\":\"address\"}],\"name\":\"configure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exponents\",\"outputs\":[{\"internalType\":\"contract FractionalExponents\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finOp\",\"outputs\":[{\"internalType\":\"contract FinancialOpportunity\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidator\",\"outputs\":[{\"internalType\":\"contract Liquidator\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract StakedToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolAwardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newBasis\",\"type\":\"uint32\"}],\"name\":\"setRewardBasis\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferLiquidatorOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AssuredFinancialOpportunity","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2472241e2e6b37ec8d2dea7f19c62dd7cfa7dcb20ce0ab8080d9ecb9b60e2bf1"}]}