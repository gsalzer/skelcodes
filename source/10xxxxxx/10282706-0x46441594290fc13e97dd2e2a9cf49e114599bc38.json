{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IAaveLendingPool.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract IAaveLendingPool {\r\n  function deposit(\r\n    address _reserve,\r\n    uint256 _amount,\r\n    uint16 _referralCode\r\n  ) public virtual;\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract IERC20 {\r\n  function balanceOf(address user) external virtual view returns (uint256);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external virtual returns (bool);\r\n\r\n  function transfer(address recipient, uint256 amount)\r\n    external\r\n    virtual\r\n    returns (bool);\r\n\r\n  function allowance(address owner, address spender)\r\n    external\r\n    virtual\r\n    view\r\n    returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount)\r\n    external\r\n    virtual\r\n    returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IADai.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\nabstract contract IADai is IERC20 {\r\n  function redeem(uint256 _amount) public virtual;\r\n  // function redirectInterestStream(address _to) public virtual;\r\n}\r\n\r\n// File: contracts/interfaces/INoLossDao.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract INoLossDao {\r\n  function userHasNotVotedThisIterationAndIsNotProposal(address userAddress)\r\n    external\r\n    virtual\r\n    view\r\n    returns (bool);\r\n\r\n  function noLossDeposit(address userAddress) external virtual returns (bool);\r\n\r\n  function noLossWithdraw(address userAddress) external virtual returns (bool);\r\n\r\n  function noLossCreateProposal(\r\n    string calldata proposalHash,\r\n    address benefactorAddress\r\n  ) external virtual returns (uint256 newProposalId);\r\n\r\n  function noLossWithdrawProposal(address benefactorAddress)\r\n    external\r\n    virtual\r\n    returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/ILendingPoolAddressesProvider.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract ILendingPoolAddressesProvider {\r\n  function getLendingPool() public virtual view returns (address);\r\n\r\n  function getLendingPoolCore() public virtual view returns (address);\r\n}\r\n\r\n// INSERT LATER INTO NOLOSSDAO\r\n// Therefore, whenever it's required to access the LendingPool contract\r\n// it is recommended to fetch the correct address from the LendingPoolAddressesProvider smart contract.\r\n\r\n// Just want to get it to compile. coIo'lll suese this terminal ::DD\r\n// LendingPoolAddressesProvider provider = LendingPoolAddressesProvider(\r\n//     0x24a42fD28C976A61Df5D00D0599C34c4f90748c8\r\n// );\r\n// LendingPool lendingPool = LendingPool(provider.getLendingPool());\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/PoolDeposits.sol\r\n\r\npragma solidity 0.6.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import '@nomiclabs/buidler/console.sol';\r\n\r\n/** @title Pooled Deposits Contract*/\r\ncontract PoolDeposits {\r\n  using SafeMath for uint256;\r\n\r\n  address public admin;\r\n  uint256 public totalDepositedDai;\r\n  mapping(address => uint256) public depositedDai;\r\n\r\n  uint256 public proposalAmount; // Stake required to submit a proposal\r\n\r\n  ///////// DEFI Contrcats ///////////\r\n  IERC20 public daiContract;\r\n  IAaveLendingPool public aaveLendingContract;\r\n  IADai public adaiContract;\r\n  INoLossDao public noLossDaoContract;\r\n  ILendingPoolAddressesProvider public provider;\r\n  address public aaveLendingContractCore;\r\n\r\n  //////// EMERGENCY MODULE ONLY ///////\r\n  uint256 public emergencyVoteAmount;\r\n  mapping(address => bool) public emergencyVoted;\r\n  mapping(address => uint256) public timeJoined;\r\n  bool public isEmergencyState;\r\n\r\n  ///////// Events ///////////\r\n  event DepositAdded(address indexed user, uint256 amount);\r\n  event ProposalAdded(\r\n    address indexed benefactor,\r\n    uint256 indexed proposalId,\r\n    string proposalIdentifier\r\n  );\r\n  event DepositWithdrawn(address indexed user);\r\n  event PartialDepositWithdrawn(address indexed user, uint256 amount);\r\n  event ProposalWithdrawn(address indexed benefactor);\r\n  event InterestSent(address indexed user, uint256 amount);\r\n  event WinnerPayout(\r\n    address indexed user,\r\n    uint256 indexed iteration,\r\n    uint256 amount\r\n  );\r\n\r\n  ///////// Emergency Events ///////////\r\n  event EmergencyStateReached(\r\n    address indexed user,\r\n    uint256 timeStamp,\r\n    uint256 totalDaiInContract,\r\n    uint256 totalEmergencyVotes\r\n  );\r\n  event EmergencyVote(address indexed user, uint256 emergencyVoteAmount);\r\n  event RemoveEmergencyVote(address indexed user, uint256 emergencyVoteAmount);\r\n  event ADaiRedeemFailed();\r\n  event EmergencyWithdrawl(address indexed user);\r\n\r\n  ///////////////////////////////////////////////////////////////////\r\n  //////// EMERGENCY MODIFIERS //////////////////////////////////////\r\n  ///////////////////////////////////////////////////////////////////\r\n  modifier emergencyEnacted() {\r\n    require(\r\n      totalDepositedDai < emergencyVoteAmount.mul(2), //safe 50%\r\n      '50% of total pool needs to have voted for emergency state'\r\n    );\r\n    require(\r\n      totalDepositedDai > 200000000000000000000000, //200 000 DAI needed in contract\r\n      '200 000DAI required in pool before emergency state can be declared'\r\n    );\r\n    _;\r\n  }\r\n  modifier noEmergencyVoteYet() {\r\n    require(emergencyVoted[msg.sender] == false, 'Already voted for emergency');\r\n    _;\r\n  }\r\n  modifier stableState() {\r\n    require(isEmergencyState == false, 'State of emergency declared');\r\n    _;\r\n  }\r\n  modifier emergencyState() {\r\n    require(isEmergencyState == true, 'State of emergency not declared');\r\n    _;\r\n  }\r\n  // Required to be part of the pool for 100 days. Make it costly to borrow and put into state of emergency.\r\n  modifier eligibleToEmergencyVote() {\r\n    require(\r\n      timeJoined[msg.sender].add(8640000) < now,\r\n      'Need to have joined for 100days to vote an emergency'\r\n    );\r\n    _;\r\n  }\r\n  ////////////////////////////////////////////////////////////////////////\r\n\r\n  ////////////////////////////////////\r\n  //////// Modifiers /////////////////\r\n  ////////////////////////////////////\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, 'Not admin');\r\n    _;\r\n  }\r\n\r\n  modifier noLossDaoContractOnly() {\r\n    require(\r\n      address(noLossDaoContract) == msg.sender, // Is this a valid way of getting the address?\r\n      'function can only be called by no Loss Dao contract'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier allowanceAvailable(uint256 amount) {\r\n    require(\r\n      amount <= daiContract.allowance(msg.sender, address(this)), // checking the pool deposits contract\r\n      'amount not available'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier requiredDai(uint256 amount) {\r\n    require(\r\n      daiContract.balanceOf(msg.sender) >= amount,\r\n      'User does not have enough DAI'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier blankUser() {\r\n    require(depositedDai[msg.sender] == 0, 'Person is already a user');\r\n    _;\r\n  }\r\n\r\n  modifier userStaked() {\r\n    require(depositedDai[msg.sender] > 0, 'User has no stake');\r\n    _;\r\n  }\r\n\r\n  modifier hasNotEmergencyVoted() {\r\n    require(!emergencyVoted[msg.sender], 'User has emergency voted');\r\n    _;\r\n  }\r\n\r\n  modifier validAmountToWithdraw(uint256 amount) {\r\n    // NOTE: if you want to withdraw 100% of your balance use the `exit` function. The `exit` function does the correct update in the noLossDao.\r\n    require(amount < depositedDai[msg.sender], 'Cannot withdraw full balance');\r\n    _;\r\n  }\r\n\r\n  modifier userHasNotVotedThisIterationAndIsNotProposal() {\r\n    require(\r\n      noLossDaoContract.userHasNotVotedThisIterationAndIsNotProposal(\r\n        msg.sender\r\n      ),\r\n      'User already voted this iteration or is a proposal'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier validInterestSplitInput(\r\n    address[] memory addresses,\r\n    uint256[] memory percentages\r\n  ) {\r\n    require(addresses.length == percentages.length, 'Input length not equal');\r\n    _;\r\n  }\r\n\r\n  /***************\r\n    Contract set-up: Not Upgradaable\r\n    ***************/\r\n  constructor(\r\n    address daiAddress,\r\n    address aDaiAddress,\r\n    // lendingPoolAddressProvider should be one of below depending on deployment\r\n    // kovan 0x506B0B2CF20FAA8f38a4E2B524EE43e1f4458Cc5\r\n    // mainnet 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8\r\n    address lendingPoolAddressProvider,\r\n    address noLossDaoAddress,\r\n    uint256 _proposalAmount\r\n  ) public {\r\n    daiContract = IERC20(daiAddress);\r\n    provider = ILendingPoolAddressesProvider(lendingPoolAddressProvider);\r\n    adaiContract = IADai(aDaiAddress);\r\n    noLossDaoContract = INoLossDao(noLossDaoAddress);\r\n    admin = msg.sender;\r\n    proposalAmount = _proposalAmount; // if we want this configurable put in other contract\r\n    isEmergencyState = false;\r\n  }\r\n\r\n  /// @dev allows the proposalAmount (amount proposal has to stake to enter the pool) to be configurable\r\n  /// @param amount new proposalAmount\r\n  function changeProposalAmount(uint256 amount) external noLossDaoContractOnly {\r\n    proposalAmount = amount;\r\n  }\r\n\r\n  /// @dev allows the admin to be chanded. Note admin can only declare an emergency\r\n  /// @param newAdmin address of the new admin\r\n  function changeAdmin(address newAdmin) external onlyAdmin {\r\n    admin = newAdmin;\r\n  }\r\n\r\n  /// @dev Internal function completing the actual deposit to Aave and crediting users account\r\n  /// @param amount amount being deosited into pool\r\n  function _depositFunds(uint256 amount) internal {\r\n    aaveLendingContract = IAaveLendingPool(provider.getLendingPool());\r\n    aaveLendingContractCore = provider.getLendingPoolCore();\r\n\r\n    daiContract.transferFrom(msg.sender, address(this), amount);\r\n    daiContract.approve(aaveLendingContractCore, amount);\r\n    aaveLendingContract.deposit(address(daiContract), amount, 30);\r\n\r\n    timeJoined[msg.sender] = now;\r\n    depositedDai[msg.sender] = depositedDai[msg.sender].add(amount);\r\n    totalDepositedDai = totalDepositedDai.add(amount);\r\n  }\r\n\r\n  /// @dev Internal function completing the actual redemption from Aave and sendinding funds back to user\r\n  /// @param amount the user wants to withdraw from the DAOcare pool\r\n  function _withdrawFunds(uint256 amount) internal {\r\n    depositedDai[msg.sender] = depositedDai[msg.sender].sub(amount);\r\n    totalDepositedDai = totalDepositedDai.sub(amount);\r\n\r\n    try adaiContract.redeem(amount)  {\r\n      daiContract.transfer(msg.sender, amount);\r\n    } catch {\r\n      emit ADaiRedeemFailed();\r\n      adaiContract.transfer(msg.sender, amount);\r\n    }\r\n  }\r\n\r\n  /// @dev Lets a user join DAOcare through depositing\r\n  /// @param amount the user wants to deposit into the DAOcare pool\r\n  function deposit(uint256 amount)\r\n    external\r\n    hasNotEmergencyVoted\r\n    allowanceAvailable(amount)\r\n    requiredDai(amount)\r\n    stableState\r\n  {\r\n    // NOTE: if the user adds a deposit they won't be able to vote in that iteration\r\n    _depositFunds(amount);\r\n    noLossDaoContract.noLossDeposit(msg.sender);\r\n    emit DepositAdded(msg.sender, amount);\r\n  }\r\n\r\n  /// @dev Lets a user withdraw their original amount sent to DAOcare\r\n  /// Calls the NoLossDao conrrtact to determine eligibility to withdraw\r\n  function exit() external userStaked {\r\n    uint256 amount = depositedDai[msg.sender];\r\n    // NOTE: it is critical that _removeEmergancyVote happens before _withdrawFunds.\r\n    _removeEmergencyVote();\r\n    _withdrawFunds(amount);\r\n    noLossDaoContract.noLossWithdraw(msg.sender);\r\n    emit DepositWithdrawn(msg.sender);\r\n  }\r\n\r\n  /// @dev Lets a user withdraw some of their amount\r\n  /// Checks they have not voted\r\n  function withdrawDeposit(uint256 amount)\r\n    external\r\n    // If this user has voted to call an emergancy, they cannot do a partial withdrawal\r\n    hasNotEmergencyVoted\r\n    validAmountToWithdraw(amount) // not trying to withdraw full amount (eg. amount is less than the total)\r\n    userHasNotVotedThisIterationAndIsNotProposal // checks they have not voted\r\n  {\r\n    _withdrawFunds(amount);\r\n    emit PartialDepositWithdrawn(msg.sender, amount);\r\n  }\r\n\r\n  /// @dev Lets user create proposal\r\n  /// @param proposalIdentifier hash of the users new proposal\r\n  function createProposal(string calldata proposalIdentifier)\r\n    external\r\n    blankUser\r\n    allowanceAvailable(proposalAmount)\r\n    requiredDai(proposalAmount)\r\n    stableState\r\n    returns (uint256 newProposalId)\r\n  {\r\n    _depositFunds(proposalAmount);\r\n    uint256 proposalId = noLossDaoContract.noLossCreateProposal(\r\n      proposalIdentifier,\r\n      msg.sender\r\n    );\r\n    emit ProposalAdded(msg.sender, proposalId, proposalIdentifier);\r\n    return proposalId;\r\n  }\r\n\r\n  /// @dev Lets user withdraw proposal\r\n  function withdrawProposal() external {\r\n    _withdrawFunds(depositedDai[msg.sender]);\r\n    noLossDaoContract.noLossWithdrawProposal(msg.sender);\r\n    emit ProposalWithdrawn(msg.sender);\r\n  }\r\n\r\n  /// @dev Internal function splitting and sending the accrued interest between winners.\r\n  /// @param receivers An array of the addresses to split between\r\n  /// @param percentages the respective percentage to split\r\n  /// @param winner The person who will recieve this distribution\r\n  /// @param iteration the iteration of the dao\r\n  /// @param totalInterestFromIteration Total interest that should be split to relevant parties\r\n  /// @param tokenContract will be aDai or Dai (depending on try catch in distributeInterst - `redeem`)\r\n  function _distribute(\r\n    address[] calldata receivers,\r\n    uint256[] calldata percentages,\r\n    address winner,\r\n    uint256 iteration,\r\n    uint256 totalInterestFromIteration,\r\n    address tokenContract\r\n  ) internal {\r\n    IERC20 payoutToken = IERC20(tokenContract);\r\n\r\n    uint256 winnerPayout = totalInterestFromIteration;\r\n    for (uint256 i = 0; i < receivers.length; i++) {\r\n      uint256 amountToSend = totalInterestFromIteration.mul(percentages[i]).div(\r\n        1000\r\n      );\r\n      payoutToken.transfer(receivers[i], amountToSend);\r\n      winnerPayout = winnerPayout.sub(amountToSend); //SafeMath prevents this going below 0\r\n      emit InterestSent(receivers[i], amountToSend);\r\n    }\r\n\r\n    payoutToken.transfer(winner, winnerPayout);\r\n    emit WinnerPayout(winner, winnerPayout, iteration);\r\n  }\r\n\r\n  /// @dev Tries to redeem aDai and send acrrued interest to winners. Falls back to Dai.\r\n  /// @param receivers An array of the addresses to split between\r\n  /// @param percentages the respective percentage to split\r\n  /// @param winner address of the winning proposal\r\n  /// @param iteration the iteration of the dao\r\n  function distributeInterest(\r\n    address[] calldata receivers,\r\n    uint256[] calldata percentages,\r\n    address winner,\r\n    uint256 iteration\r\n  )\r\n    external\r\n    validInterestSplitInput(receivers, percentages)\r\n    noLossDaoContractOnly\r\n  {\r\n    uint256 amountToRedeem = adaiContract.balanceOf(address(this)).sub(\r\n      totalDepositedDai\r\n    );\r\n    try adaiContract.redeem(amountToRedeem)  {\r\n      _distribute(\r\n        receivers,\r\n        percentages,\r\n        winner,\r\n        iteration,\r\n        amountToRedeem,\r\n        address(daiContract)\r\n      );\r\n    } catch {\r\n      _distribute(\r\n        receivers,\r\n        percentages,\r\n        winner,\r\n        iteration,\r\n        amountToRedeem,\r\n        address(adaiContract)\r\n      );\r\n    }\r\n  }\r\n\r\n  //////////////////////////////////////////////////\r\n  //////// EMERGENCY MODULE FUNCTIONS  //////////////\r\n  ///////////////////////////////////////////////////\r\n\r\n  /// @dev Internal function setting the emergency state of contract to true.\r\n  function _declareStateOfEmergency() internal {\r\n    isEmergencyState = true;\r\n    emit EmergencyStateReached(\r\n      msg.sender,\r\n      now,\r\n      totalDepositedDai,\r\n      emergencyVoteAmount\r\n    );\r\n  }\r\n\r\n  /// @dev Allows admin to activate emergency state\r\n  function adminActivateEmergency() external onlyAdmin {\r\n    _declareStateOfEmergency();\r\n  }\r\n\r\n  /// @dev Declares a state of emergency and enables emergency withdrawls that are not dependant on any external smart contracts\r\n  function declareStateOfEmergency() external emergencyEnacted {\r\n    _declareStateOfEmergency();\r\n  }\r\n\r\n  /// @dev Immediately lets yoou withdraw your funds in an state of emergency\r\n  function emergencyWithdraw() external userStaked emergencyState {\r\n    _withdrawFunds(depositedDai[msg.sender]);\r\n    emit EmergencyWithdrawl(msg.sender);\r\n  }\r\n\r\n  /// @dev lets users vote that the a state of emergency should be decalred\r\n  /// Requires time lock here to defeat flash loan punks\r\n  function voteEmergency()\r\n    external\r\n    userStaked\r\n    noEmergencyVoteYet\r\n    eligibleToEmergencyVote\r\n  {\r\n    emergencyVoted[msg.sender] = true;\r\n    emergencyVoteAmount = emergencyVoteAmount.add(depositedDai[msg.sender]);\r\n    emit EmergencyVote(msg.sender, depositedDai[msg.sender]);\r\n  }\r\n\r\n  /// @dev Internal function removing a users emergency vote if they leave the pool\r\n  function _removeEmergencyVote() internal {\r\n    if (emergencyVoted[msg.sender] == true) {\r\n      emergencyVoted[msg.sender] = false;\r\n      emergencyVoteAmount = emergencyVoteAmount.sub(depositedDai[msg.sender]);\r\n      emit RemoveEmergencyVote(msg.sender, depositedDai[msg.sender]);\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"daiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aDaiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lendingPoolAddressProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"noLossDaoAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_proposalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ADaiRedeemFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"DepositWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDaiInContract\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalEmergencyVotes\",\"type\":\"uint256\"}],\"name\":\"EmergencyStateReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"emergencyVoteAmount\",\"type\":\"uint256\"}],\"name\":\"EmergencyVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"EmergencyWithdrawl\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InterestSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PartialDepositWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"benefactor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"proposalIdentifier\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"benefactor\",\"type\":\"address\"}],\"name\":\"ProposalWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"emergencyVoteAmount\",\"type\":\"uint256\"}],\"name\":\"RemoveEmergencyVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WinnerPayout\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aaveLendingContract\",\"outputs\":[{\"internalType\":\"contract IAaveLendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aaveLendingContractCore\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adaiContract\",\"outputs\":[{\"internalType\":\"contract IADai\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminActivateEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"changeProposalAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"proposalIdentifier\",\"type\":\"string\"}],\"name\":\"createProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newProposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"declareStateOfEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositedDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"percentages\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"iteration\",\"type\":\"uint256\"}],\"name\":\"distributeInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyVoteAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"emergencyVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEmergencyState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noLossDaoContract\",\"outputs\":[{\"internalType\":\"contract INoLossDao\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"provider\",\"outputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timeJoined\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDepositedDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PoolDeposits","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000fc1e690f61efd961294b3e1ce3313fbd8aa4f85d00000000000000000000000024a42fd28c976a61df5d00d0599c34c4f90748c8000000000000000000000000ac523606b34240a1d6c90cf1223f1b75136a14d1000000000000000000000000000000000000000000000002b5e3af16b1880000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1f69527375087dc01a07789c2bbfaab9705abc6129ae2d6051af69051f92ba4b"}]}