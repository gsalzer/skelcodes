{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// submitted by @dev-xu\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n// @title SafeMath: overflow/underflow checks\r\n// @notice Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n\r\n  // @notice Multiplies two numbers, throws on overflow.\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  // @notice Integer division of two numbers, truncating the quotient.\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  // @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  // @notice Adds two numbers, throws on overflow.\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  // @notice Returns fractional amount\r\n  function getFractionalAmount(uint256 _amount, uint256 _percentage)\r\n  internal\r\n  pure\r\n  returns (uint256) {\r\n    return div(mul(_amount, _percentage), 100);\r\n  }\r\n\r\n}\r\n\r\n// Database interface\r\ninterface DBInterface {\r\n\r\n  function setContractManager(address _contractManager)\r\n  external;\r\n\r\n    // --------------------Set Functions------------------------\r\n\r\n    function setAddress(bytes32 _key, address _value)\r\n    external;\r\n\r\n    function setUint(bytes32 _key, uint _value)\r\n    external;\r\n\r\n    function setString(bytes32 _key, string _value)\r\n    external;\r\n\r\n    function setBytes(bytes32 _key, bytes _value)\r\n    external;\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _value)\r\n    external;\r\n\r\n    function setBool(bytes32 _key, bool _value)\r\n    external;\r\n\r\n    function setInt(bytes32 _key, int _value)\r\n    external;\r\n\r\n\r\n     // -------------- Deletion Functions ------------------\r\n\r\n    function deleteAddress(bytes32 _key)\r\n    external;\r\n\r\n    function deleteUint(bytes32 _key)\r\n    external;\r\n\r\n    function deleteString(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBytes(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBytes32(bytes32 _key)\r\n    external;\r\n\r\n    function deleteBool(bytes32 _key)\r\n    external;\r\n\r\n    function deleteInt(bytes32 _key)\r\n    external;\r\n\r\n    // ----------------Variable Getters---------------------\r\n\r\n    function uintStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (uint);\r\n\r\n    function stringStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (string);\r\n\r\n    function addressStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n    function bytesStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bytes);\r\n\r\n    function bytes32Storage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bytes32);\r\n\r\n    function boolStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n    function intStorage(bytes32 _key)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\ncontract Events {\r\n  DBInterface public database;\r\n\r\n  constructor(address _database) public{\r\n    database = DBInterface(_database);\r\n  }\r\n\r\n  function message(string _message)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogEvent(_message, keccak256(abi.encodePacked(_message)), tx.origin);\r\n  }\r\n\r\n  function transaction(string _message, address _from, address _to, uint _amount, address _token)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogTransaction(_message, keccak256(abi.encodePacked(_message)), _from, _to, _amount, _token, tx.origin);\r\n  }\r\n\r\n  function registration(string _message, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogAddress(_message, keccak256(abi.encodePacked(_message)), _account, tx.origin);\r\n  }\r\n\r\n  function contractChange(string _message, address _account, string _name)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogContractChange(_message, keccak256(abi.encodePacked(_message)), _account, _name, tx.origin);\r\n  }\r\n\r\n  function asset(string _message, string _uri, address _assetAddress, address _manager)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogAsset(_message, keccak256(abi.encodePacked(_message)), _uri, keccak256(abi.encodePacked(_uri)), _assetAddress, _manager, tx.origin);\r\n  }\r\n\r\n  function escrow(string _message, address _assetAddress, bytes32 _escrowID, address _manager, uint _amount)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogEscrow(_message, keccak256(abi.encodePacked(_message)), _assetAddress, _escrowID, _manager, _amount, tx.origin);\r\n  }\r\n\r\n  function order(string _message, bytes32 _orderID, uint _amount, uint _price)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogOrder(_message, keccak256(abi.encodePacked(_message)), _orderID, _amount, _price, tx.origin);\r\n  }\r\n\r\n  function exchange(string _message, bytes32 _orderID, address _assetAddress, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogExchange(_message, keccak256(abi.encodePacked(_message)), _orderID, _assetAddress, _account, tx.origin);\r\n  }\r\n\r\n  function operator(string _message, bytes32 _id, string _name, string _ipfs, address _account)\r\n  external\r\n  onlyApprovedContract {\r\n      emit LogOperator(_message, keccak256(abi.encodePacked(_message)), _id, _name, _ipfs, _account, tx.origin);\r\n  }\r\n\r\n  function consensus(string _message, bytes32 _executionID, bytes32 _votesID, uint _votes, uint _tokens, uint _quorum)\r\n  external\r\n  onlyApprovedContract {\r\n    emit LogConsensus(_message, keccak256(abi.encodePacked(_message)), _executionID, _votesID, _votes, _tokens, _quorum, tx.origin);\r\n  }\r\n\r\n  //Generalized events\r\n  event LogEvent(string message, bytes32 indexed messageID, address indexed origin);\r\n  event LogTransaction(string message, bytes32 indexed messageID, address indexed from, address indexed to, uint amount, address token, address origin); //amount and token will be empty on some events\r\n  event LogAddress(string message, bytes32 indexed messageID, address indexed account, address indexed origin);\r\n  event LogContractChange(string message, bytes32 indexed messageID, address indexed account, string name, address indexed origin);\r\n  event LogAsset(string message, bytes32 indexed messageID, string uri, bytes32 indexed assetID, address asset, address manager, address indexed origin);\r\n  event LogEscrow(string message, bytes32 indexed messageID, address asset, bytes32  escrowID, address indexed manager, uint amount, address indexed origin);\r\n  event LogOrder(string message, bytes32 indexed messageID, bytes32 indexed orderID, uint amount, uint price, address indexed origin);\r\n  event LogExchange(string message, bytes32 indexed messageID, bytes32 orderID, address indexed asset, address account, address indexed origin);\r\n  event LogOperator(string message, bytes32 indexed messageID, bytes32 id, string name, string ipfs, address indexed account, address indexed origin);\r\n  event LogConsensus(string message, bytes32 indexed messageID, bytes32 executionID, bytes32 votesID, uint votes, uint tokens, uint quorum, address indexed origin);\r\n\r\n\r\n  // --------------------------------------------------------------------------------------\r\n  // Caller must be registered as a contract through ContractManager.sol\r\n  // --------------------------------------------------------------------------------------\r\n  modifier onlyApprovedContract() {\r\n      require(database.boolStorage(keccak256(abi.encodePacked(\"contract\", msg.sender))));\r\n      _;\r\n  }\r\n\r\n}\r\n\r\n// @notice Trade via the Kyber Proxy Contract\r\ninterface KyberInterface {\r\n  function getExpectedRate(address src, address dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\r\n  function trade(address src, uint srcAmount, address dest, address destAddress, uint maxDestAmount,uint minConversionRate, address walletId) external payable returns(uint);\r\n}\r\n\r\ninterface MinterInterface {\r\n  function cloneToken(string _uri, address _erc20Address) external returns (address asset);\r\n\r\n  function mintAssetTokens(address _assetAddress, address _receiver, uint256 _amount) external returns (bool);\r\n\r\n  function changeTokenController(address _assetAddress, address _newController) external returns (bool);\r\n}\r\n\r\ninterface CrowdsaleGeneratorETH_ERC20 {\r\n  function balanceOf(address _who) external view returns (uint256);\r\n  function allowance(address _owner, address _spender) external view returns (uint256);\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\n// @title A crowdsale generator contract\r\n// @author Kyle Dewhurst & Roy Xu, MyBit Foundation\r\n// @notice AssetManagers can initiate a crowdsale that accepts Ether as payment here\r\ncontract CrowdsaleGeneratorETH {\r\n  using SafeMath for uint256;\r\n\r\n  DBInterface public database;\r\n  Events public events;\r\n  KyberInterface private kyber;\r\n  MinterInterface private minter;\r\n\r\n  //uint constant scalingFactor = 1e32;   // Used to avoid rounding errors\r\n\r\n  // @notice This contract\r\n  // @param: The address for the database contract used by this platform\r\n  constructor(address _database, address _events, address _kyber)\r\n  public{\r\n      database = DBInterface(_database);\r\n      events = Events(_events);\r\n      kyber = KyberInterface(_kyber);\r\n      minter = MinterInterface(database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"Minter\"))));\r\n  }\r\n\r\n  // @notice Do not send ether to this contract, this is for kyber exchange to get return\r\n  // @dev After collecting listing fee in token, remaining ether gets refunded from kyber\r\n  function() public payable {\r\n    \r\n  }\r\n\r\n  // @notice AssetManagers can initiate a crowdfund for a new asset here\r\n  // @dev the crowdsaleETH contract is granted rights to mint asset-tokens as it receives funding\r\n  // @param (string) _assetURI = The location where information about the asset can be found\r\n  // @param (uint) _fundingLength = The number of seconds this crowdsale is to go on for until it fails\r\n  // @param (uint) _amountToRaise = The amount of WEI required to raise for the crowdsale to be a success\r\n  // @param (uint) _assetManagerPerc = The percentage of the total revenue which is to go to the AssetManager if asset is a success\r\n  function createAssetOrderETH(string _assetURI, string _ipfs, uint _fundingLength, uint _amountToRaise, uint _assetManagerPerc, uint _escrowAndFee, address _paymentToken)\r\n  external\r\n  payable {\r\n    if(_paymentToken == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\r\n      require(msg.value == _escrowAndFee);\r\n    } else {\r\n      require(msg.value == 0);\r\n      CrowdsaleGeneratorETH_ERC20(_paymentToken).transferFrom(msg.sender, address(this), _escrowAndFee);\r\n    }\r\n\r\n    require(_amountToRaise >= 100, \"Crowdsale goal is too small\");\r\n    require((_assetManagerPerc + database.uintStorage(keccak256(abi.encodePacked(\"platform.percentage\")))) < 100, \"Manager percent need to be less than 100\");\r\n    require(!database.boolStorage(keccak256(abi.encodePacked(\"asset.uri\", _assetURI))), \"Asset URI is not unique\"); //Check that asset URI is unique\r\n    uint escrow = processListingFee(_paymentToken, _escrowAndFee);\r\n    address assetAddress = minter.cloneToken(_assetURI, address(0));\r\n    require(setCrowdsaleValues(assetAddress, _fundingLength, _amountToRaise));\r\n    require(setAssetValues(assetAddress, _assetURI, _ipfs, msg.sender, _assetManagerPerc, _amountToRaise));\r\n\r\n    //Lock escrow\r\n    if(escrow > 0) {\r\n      require(lockEscrowETH(msg.sender, assetAddress, _paymentToken, escrow));\r\n    }\r\n    events.asset('Asset funding started', _assetURI, assetAddress, msg.sender);\r\n    events.asset('New asset ipfs', _ipfs, assetAddress, msg.sender);\r\n  }\r\n\r\n  function updateIPFS(address _assetAddress, string _ipfs)\r\n  external {\r\n    require(msg.sender == database.addressStorage(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress))));\r\n    database.setString(keccak256(abi.encodePacked(\"asset.ipfs\", _assetAddress)), _ipfs);\r\n    events.asset('New asset ipfs', _ipfs, _assetAddress, msg.sender);\r\n  }\r\n\r\n\r\n  // @notice platform owners can destroy contract here\r\n  function destroy()\r\n  onlyOwner\r\n  external {\r\n    events.transaction('CrowdsaleGeneratorETH destroyed', address(this), msg.sender, address(this).balance, address(0));\r\n    selfdestruct(msg.sender);\r\n  }\r\n\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  //                                            Internal/ Private Functions\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n  function setCrowdsaleValues(address _assetAddress, uint _fundingLength, uint _amountToRaise)\r\n  private\r\n  returns (bool){\r\n    database.setUint(keccak256(abi.encodePacked(\"crowdsale.start\", _assetAddress)), now);\r\n    database.setUint(keccak256(abi.encodePacked(\"crowdsale.deadline\", _assetAddress)), now.add(_fundingLength));\r\n    database.setUint(keccak256(abi.encodePacked(\"crowdsale.goal\", _assetAddress)), _amountToRaise);\r\n    database.setUint(keccak256(abi.encodePacked(\"crowdsale.remaining\", _assetAddress)), _amountToRaise.mul(uint(100).add(database.uintStorage(keccak256(abi.encodePacked(\"platform.fee\"))))).div(100));\r\n    return true;\r\n  }\r\n\r\n  function setAssetValues(address _assetAddress, string _assetURI, string _ipfs, address _assetManager, uint _assetManagerPerc, uint _amountToRaise)\r\n  private\r\n  returns (bool){\r\n    uint totalTokens = _amountToRaise.mul(100).div(uint(100).sub(_assetManagerPerc).sub(database.uintStorage(keccak256(abi.encodePacked(\"platform.percentage\")))));\r\n    //database.setUint(keccak256(abi.encodePacked(\"asset.managerTokens\", assetAddress)), _amountToRaise.mul(uint(100).mul(scalingFactor).div(uint(100).sub(_assetManagerPerc)).sub(scalingFactor)).div(scalingFactor));\r\n    database.setUint(keccak256(abi.encodePacked(\"asset.managerTokens\", _assetAddress)), totalTokens.getFractionalAmount(_assetManagerPerc));\r\n    database.setUint(keccak256(abi.encodePacked(\"asset.platformTokens\", _assetAddress)), totalTokens.getFractionalAmount(database.uintStorage(keccak256(abi.encodePacked(\"platform.percentage\")))));\r\n    database.setAddress(keccak256(abi.encodePacked(\"asset.manager\", _assetAddress)), _assetManager);\r\n    database.setString(keccak256(abi.encodePacked(\"asset.ipfs\", _assetAddress)), _ipfs);\r\n    \r\n    database.setBool(keccak256(abi.encodePacked(\"asset.uri\", _assetURI)), true); //Set to ensure a unique asset URI\r\n    return true;\r\n  }\r\n\r\n  function processListingFee(address _paymentTokenAddress, uint _fromAmount)\r\n  private\r\n  returns (uint) { // returns left amount\r\n    uint listingFee = database.uintStorage(keccak256(abi.encodePacked(\"platform.listingFee\")));\r\n    address listingFeeTokenAddress = database.addressStorage(keccak256(abi.encodePacked(\"platform.listingFeeToken\")));\r\n    address platformFundsWallet = database.addressStorage(keccak256(abi.encodePacked(\"platform.wallet.funds\")));\r\n    uint usedAmount;\r\n    uint balanceBefore;\r\n    uint listingFeePaid;\r\n    uint expectedRate;\r\n    uint estimation;\r\n    CrowdsaleGeneratorETH_ERC20 paymentToken;\r\n\r\n    if (_paymentTokenAddress != listingFeeTokenAddress) {\r\n      //Convert the payment token into the listing fee token\r\n      ( expectedRate, ) = kyber.getExpectedRate(listingFeeTokenAddress, _paymentTokenAddress, listingFee);\r\n      estimation = expectedRate * listingFee / 0.8 ether; // giving slippage rate of 0.8\r\n\r\n      if(_paymentTokenAddress == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\r\n        balanceBefore = address(this).balance;\r\n        listingFeePaid = kyber.trade.value(estimation)(_paymentTokenAddress, estimation, listingFeeTokenAddress, platformFundsWallet, listingFee, 0, 0);\r\n\r\n        usedAmount = balanceBefore - address(this).balance; // used eth by kyber for swapping with token\r\n      } else {\r\n        paymentToken = CrowdsaleGeneratorETH_ERC20(_paymentTokenAddress);\r\n        balanceBefore = paymentToken.balanceOf(address(this));\r\n\r\n        require(paymentToken.approve(address(kyber), estimation));\r\n        listingFeePaid = kyber.trade(_paymentTokenAddress, estimation, listingFeeTokenAddress, platformFundsWallet, listingFee, 0, 0); //Currently no minimum rate is set, so watch out for slippage!\r\n        paymentToken.approve(address(kyber), 0);\r\n        usedAmount = balanceBefore - paymentToken.balanceOf(address(this));\r\n      }\r\n    } else {\r\n      paymentToken = CrowdsaleGeneratorETH_ERC20(_paymentTokenAddress);\r\n      require(paymentToken.transfer(platformFundsWallet, listingFee), \"Listing fee not paid\");\r\n      usedAmount = listingFee;\r\n      listingFeePaid = listingFee;\r\n    }\r\n\r\n    require(_fromAmount >= usedAmount && listingFeePaid >= listingFee, \"Listing fee not paid\");\r\n    return _fromAmount - usedAmount;\r\n  }\r\n\r\n  function lockEscrowETH(address _assetManager, address _assetAddress, address _paymentTokenAddress, uint _amount)\r\n  private\r\n  returns (bool) {\r\n    uint amount;\r\n    bytes32 assetManagerEscrowID = keccak256(abi.encodePacked(_assetAddress, _assetManager));\r\n    address platformTokenAddress = database.addressStorage(keccak256(abi.encodePacked(\"platform.token\")));\r\n    if(_paymentTokenAddress != platformTokenAddress){\r\n      //Convert the payment token into the platform token\r\n      if(_paymentTokenAddress == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\r\n        amount = kyber.trade.value(_amount)(_paymentTokenAddress, _amount, platformTokenAddress, address(this), 2**255, 0, 0); //Currently no minimum rate is set, so watch out for slippage!\r\n      } else {\r\n        CrowdsaleGeneratorETH_ERC20 paymentToken = CrowdsaleGeneratorETH_ERC20(_paymentTokenAddress);\r\n        require(paymentToken.approve(address(kyber), _amount));\r\n        amount = kyber.trade(_paymentTokenAddress, _amount, platformTokenAddress, address(this), 2**255, 0, 0); //Currently no minimum rate is set, so watch out for slippage!\r\n      }\r\n    } else {\r\n      amount = _amount;\r\n    }\r\n    require(CrowdsaleGeneratorETH_ERC20(platformTokenAddress).transfer(database.addressStorage(keccak256(abi.encodePacked(\"contract\", \"EscrowReserve\"))), amount));\r\n    database.setUint(keccak256(abi.encodePacked(\"asset.escrow\", assetManagerEscrowID)), amount);\r\n    events.escrow('Escrow locked', _assetAddress, assetManagerEscrowID, _assetManager, amount);\r\n    return true;\r\n  }\r\n\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  //                                            Modifiers\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n  // // @notice reverts if asset manager is unable to burn pp\r\n  // modifier burnRequired {\r\n  //   //emit LogSig(msg.sig);\r\n  //   require(burner.burn(msg.sender, database.uintStorage(keccak256(abi.encodePacked(msg.sig, address(this))))));\r\n  //   _;\r\n  // }\r\n\r\n  // @notice Sender must be a registered owner\r\n  modifier onlyOwner {\r\n    require(database.boolStorage(keccak256(abi.encodePacked(\"owner\", msg.sender))), \"Not owner\");\r\n    _;\r\n  }\r\n\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  //                                            Events\r\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n  //event LogAssetFundingStarted(address indexed _assetManager, string _assetURI, address indexed _tokenAddress);\r\n  //event LogSig(bytes4 _sig);\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"database\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"events\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetURI\",\"type\":\"string\"},{\"name\":\"_ipfs\",\"type\":\"string\"},{\"name\":\"_fundingLength\",\"type\":\"uint256\"},{\"name\":\"_amountToRaise\",\"type\":\"uint256\"},{\"name\":\"_assetManagerPerc\",\"type\":\"uint256\"},{\"name\":\"_escrowAndFee\",\"type\":\"uint256\"},{\"name\":\"_paymentToken\",\"type\":\"address\"}],\"name\":\"createAssetOrderETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"},{\"name\":\"_ipfs\",\"type\":\"string\"}],\"name\":\"updateIPFS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_database\",\"type\":\"address\"},{\"name\":\"_events\",\"type\":\"address\"},{\"name\":\"_kyber\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"CrowdsaleGeneratorETH","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000055d3c0b3ad6943ed3c58750f790dfc107b23aa70000000000000000000000000457cb5402fe83554b569cb74b28b4a44509b612f000000000000000000000000818e6fecd516ecc3849daf6845e3ec868087b755","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d98e000be0e912f93c466a087554c34a7afbd03649bc2942f5ce4c90ad92065b"}]}