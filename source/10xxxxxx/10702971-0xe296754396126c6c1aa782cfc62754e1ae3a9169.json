{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract AOENetwork is IERC20 {\r\n    uint256 private constant FLOAT_SCALAR = 2**64;\r\n    uint256 private constant INITIAL_SUPPLY = 1e27; // 1B\r\n    uint256 private constant BURN_RATE = 5; // 5% per tx\r\n    uint256 private constant SUPPLY_FLOOR = 10; // 10% of 1B = 100M\r\n    uint256 private constant MIN_FREEZE_AMOUNT = 1e20; // 100\r\n\r\n    string public constant name = \"AOE Network\";\r\n    string public constant symbol = \"AOE\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    struct User {\r\n        bool whitelisted;\r\n        uint256 balance;\r\n        uint256 frozen;\r\n        mapping(address => uint256) allowance;\r\n        int256 scaledPayout;\r\n    }\r\n\r\n    struct Info {\r\n        uint256 totalSupply;\r\n        uint256 totalFrozen;\r\n        mapping(address => User) users;\r\n        uint256 scaledPayoutPerToken;\r\n        address admin;\r\n    }\r\n    Info private info;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 tokens\r\n    );\r\n    event Whitelist(address indexed user, bool status);\r\n    event Freeze(address indexed owner, uint256 tokens);\r\n    event Unfreeze(address indexed owner, uint256 tokens);\r\n    event Collect(address indexed owner, uint256 tokens);\r\n    event Burn(uint256 tokens);\r\n\r\n    constructor() public {\r\n        info.admin = msg.sender;\r\n        info.totalSupply = INITIAL_SUPPLY;\r\n        info.users[msg.sender].balance = INITIAL_SUPPLY;\r\n        emit Transfer(address(0x0), msg.sender, INITIAL_SUPPLY);\r\n        whitelist(msg.sender, true);\r\n    }\r\n\r\n    function freeze(uint256 _tokens) external {\r\n        _freeze(_tokens);\r\n    }\r\n\r\n    function unfreeze(uint256 _tokens) external {\r\n        _unfreeze(_tokens);\r\n    }\r\n\r\n    function collect() external returns (uint256) {\r\n        uint256 _dividends = dividendsOf(msg.sender);\r\n        require(_dividends >= 0);\r\n        info.users[msg.sender].scaledPayout += int256(\r\n            _dividends * FLOAT_SCALAR\r\n        );\r\n        info.users[msg.sender].balance += _dividends;\r\n        emit Transfer(address(this), msg.sender, _dividends);\r\n        emit Collect(msg.sender, _dividends);\r\n        return _dividends;\r\n    }\r\n\r\n    function burn(uint256 _tokens) external {\r\n        require(balanceOf(msg.sender) >= _tokens);\r\n        info.users[msg.sender].balance -= _tokens;\r\n        uint256 _burnedAmount = _tokens;\r\n        if (info.totalFrozen > 0) {\r\n            _burnedAmount /= 2;\r\n            info.scaledPayoutPerToken +=\r\n                (_burnedAmount * FLOAT_SCALAR) /\r\n                info.totalFrozen;\r\n            emit Transfer(msg.sender, address(this), _burnedAmount);\r\n        }\r\n        info.totalSupply -= _burnedAmount;\r\n        emit Transfer(msg.sender, address(0x0), _burnedAmount);\r\n        emit Burn(_burnedAmount);\r\n    }\r\n\r\n    function distribute(uint256 _tokens) external {\r\n        require(info.totalFrozen > 0);\r\n        require(balanceOf(msg.sender) >= _tokens);\r\n        info.users[msg.sender].balance -= _tokens;\r\n        info.scaledPayoutPerToken +=\r\n            (_tokens * FLOAT_SCALAR) /\r\n            info.totalFrozen;\r\n        emit Transfer(msg.sender, address(this), _tokens);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokens) external returns (bool) {\r\n        _transfer(msg.sender, _to, _tokens);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _tokens)\r\n        external\r\n        returns (bool)\r\n    {\r\n        info.users[msg.sender].allowance[_spender] = _tokens;\r\n        emit Approval(msg.sender, _spender, _tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokens\r\n    ) external returns (bool) {\r\n        require(info.users[_from].allowance[msg.sender] >= _tokens);\r\n        info.users[_from].allowance[msg.sender] -= _tokens;\r\n        _transfer(_from, _to, _tokens);\r\n        return true;\r\n    }\r\n\r\n    function whitelist(address _user, bool _status) public {\r\n        require(msg.sender == info.admin);\r\n        info.users[_user].whitelisted = _status;\r\n        emit Whitelist(_user, _status);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return info.totalSupply;\r\n    }\r\n\r\n    function totalFrozen() public view returns (uint256) {\r\n        return info.totalFrozen;\r\n    }\r\n\r\n    function balanceOf(address _user) public view returns (uint256) {\r\n        return info.users[_user].balance - frozenOf(_user);\r\n    }\r\n\r\n    function frozenOf(address _user) public view returns (uint256) {\r\n        return info.users[_user].frozen;\r\n    }\r\n\r\n    function dividendsOf(address _user) public view returns (uint256) {\r\n        return\r\n            uint256(\r\n                int256(info.scaledPayoutPerToken * info.users[_user].frozen) -\r\n                    info.users[_user].scaledPayout\r\n            ) / FLOAT_SCALAR;\r\n    }\r\n\r\n    function allowance(address _user, address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return info.users[_user].allowance[_spender];\r\n    }\r\n\r\n    function isWhitelisted(address _user) public view returns (bool) {\r\n        return info.users[_user].whitelisted;\r\n    }\r\n\r\n    function allInfoFor(address _user)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 totalTokenSupply,\r\n            uint256 totalTokensFrozen,\r\n            uint256 userBalance,\r\n            uint256 userFrozen,\r\n            uint256 userDividends\r\n        )\r\n    {\r\n        return (\r\n            totalSupply(),\r\n            totalFrozen(),\r\n            balanceOf(_user),\r\n            frozenOf(_user),\r\n            dividendsOf(_user)\r\n        );\r\n    }\r\n\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokens\r\n    ) internal returns (uint256) {\r\n        require(balanceOf(_from) >= _tokens);\r\n        info.users[_from].balance -= _tokens;\r\n        uint256 _burnedAmount = (_tokens * BURN_RATE) / 100;\r\n        if (\r\n            totalSupply() - _burnedAmount <\r\n            (INITIAL_SUPPLY * SUPPLY_FLOOR) / 100 ||\r\n            isWhitelisted(_from)\r\n        ) {\r\n            _burnedAmount = 0;\r\n        }\r\n        uint256 _transferred = _tokens - _burnedAmount;\r\n        info.users[_to].balance += _transferred;\r\n        emit Transfer(_from, _to, _transferred);\r\n        if (_burnedAmount > 0) {\r\n            if (info.totalFrozen > 0) {\r\n                _burnedAmount /= 2;\r\n                info.scaledPayoutPerToken +=\r\n                    (_burnedAmount * FLOAT_SCALAR) /\r\n                    info.totalFrozen;\r\n                emit Transfer(_from, address(this), _burnedAmount);\r\n            }\r\n            info.totalSupply -= _burnedAmount;\r\n            emit Transfer(_from, address(0x0), _burnedAmount);\r\n            emit Burn(_burnedAmount);\r\n        }\r\n        return _transferred;\r\n    }\r\n\r\n    function _freeze(uint256 _amount) internal {\r\n        require(balanceOf(msg.sender) >= _amount);\r\n        require(frozenOf(msg.sender) + _amount >= MIN_FREEZE_AMOUNT);\r\n        info.totalFrozen += _amount;\r\n        info.users[msg.sender].frozen += _amount;\r\n        info.users[msg.sender].scaledPayout += int256(\r\n            _amount * info.scaledPayoutPerToken\r\n        );\r\n        emit Transfer(msg.sender, address(this), _amount);\r\n        emit Freeze(msg.sender, _amount);\r\n    }\r\n\r\n    function _unfreeze(uint256 _amount) internal {\r\n        require(frozenOf(msg.sender) >= _amount);\r\n        uint256 _burnedAmount = (_amount * BURN_RATE) / 100;\r\n        info.scaledPayoutPerToken +=\r\n            (_burnedAmount * FLOAT_SCALAR) /\r\n            info.totalFrozen;\r\n        info.totalFrozen -= _amount;\r\n        info.users[msg.sender].balance -= _burnedAmount;\r\n        info.users[msg.sender].frozen -= _amount;\r\n        info.users[msg.sender].scaledPayout -= int256(\r\n            _amount * info.scaledPayoutPerToken\r\n        );\r\n        emit Transfer(address(this), msg.sender, _amount - _burnedAmount);\r\n        emit Unfreeze(msg.sender, _amount);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Collect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Unfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Whitelist\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"allInfoFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokensFrozen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userFrozen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userDividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"frozenOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFrozen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"whitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AOENetwork","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b4389ffc01e2591b426ce160b9adb87a70142385b477138d4f30cc1a4058d55b"}]}