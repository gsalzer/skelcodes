{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function claimComp(address holder) external;\r\n    function claimComp(address holder, address[] calldata) external;\r\n    function claimComp(address[] calldata holders, address[] calldata cTokens, bool borrowers, bool suppliers) external;\r\n}\r\n\r\ninterface COMPInterface {\r\n    function delegate(address delegatee) external;\r\n    function delegates(address) external view returns(address);\r\n}\r\n\r\ninterface InstaMapping {\r\n    function cTokenMapping(address) external view returns (address);\r\n}\r\n\r\ninterface MemoryInterface {\r\n    function getUint(uint _id) external returns (uint _num);\r\n    function setUint(uint _id, uint _val) external;\r\n}\r\n\r\ninterface EventInterface {\r\n    function emitEvent(uint _connectorType, uint _connectorID, bytes32 _eventCode, bytes calldata _eventData) external;\r\n}\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helpers is DSMath {\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getAddressETH() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Memory Variable Address\r\n     */\r\n    function getMemoryAddr() internal pure returns (address) {\r\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaEvent Address.\r\n     */\r\n    function getEventAddr() internal pure returns (address) {\r\n        return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\r\n    }\r\n\r\n    /**\r\n     * @dev Get Uint value from InstaMemory Contract.\r\n    */\r\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\r\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set Uint value in InstaMemory Contract.\r\n    */\r\n    function setUint(uint setId, uint val) internal {\r\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\r\n    }\r\n\r\n    /**\r\n     * @dev Connector Details\r\n    */\r\n    function connectorID() public pure returns(uint _type, uint _id) {\r\n        (_type, _id) = (1, 24);\r\n    }\r\n}\r\n\r\n\r\ncontract COMPHelpers is Helpers {\r\n    /**\r\n     * @dev Return Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() internal pure returns (address) {\r\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev Return COMP Token Address.\r\n     */\r\n    function getCompTokenAddress() internal pure returns (address) {\r\n        return 0xc00e94Cb662C3520282E6f5717214004A7f26888;\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaDApp Mapping Addresses\r\n     */\r\n    function getMappingAddr() internal pure returns (address) {\r\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\r\n    }\r\n}\r\n\r\n\r\ncontract BasicResolver is COMPHelpers {\r\n    event LogClaimedComp(uint256 compAmt, uint256 setId);\r\n    event LogDelegate(address delegatee);\r\n\r\n    /**\r\n     * @dev Claim Accrued COMP Token.\r\n     * @param setId Set ctoken amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function ClaimComp(address user, uint setId) external payable {\r\n        TokenInterface compToken = TokenInterface(getCompTokenAddress());\r\n        uint intialBal = compToken.balanceOf(user);\r\n        ComptrollerInterface(getComptrollerAddress()).claimComp(user);\r\n        uint finalBal = compToken.balanceOf(user);\r\n        uint amt = sub(finalBal, intialBal);\r\n\r\n        setUint(setId, amt);\r\n\r\n        emit LogClaimedComp(amt, setId);\r\n        // bytes32 _eventCode = keccak256(\"LogClaimedComp(uint256,uint256)\");\r\n        // bytes memory _eventParam = abi.encode(amt, setId);\r\n        // (uint _type, uint _id) = connectorID();\r\n        // EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim Accrued COMP Token.\r\n     * @param setId Set ctoken amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function ClaimCompTwo(address user, address[] calldata tokens, uint setId) external payable {\r\n        uint _len = tokens.length;\r\n        address[] memory ctokens = new address[](_len);\r\n        for (uint i = 0; i < _len; i++) {\r\n            ctokens[i] = InstaMapping(getMappingAddr()).cTokenMapping(tokens[i]);\r\n        }\r\n\r\n        TokenInterface compToken = TokenInterface(getCompTokenAddress());\r\n        uint intialBal = compToken.balanceOf(user);\r\n        ComptrollerInterface(getComptrollerAddress()).claimComp(user, ctokens);\r\n        uint finalBal = compToken.balanceOf(user);\r\n        uint amt = sub(finalBal, intialBal);\r\n\r\n        setUint(setId, amt);\r\n\r\n        emit LogClaimedComp(amt, setId);\r\n        // bytes32 _eventCode = keccak256(\"LogClaimedComp(uint256,uint256)\");\r\n        // bytes memory _eventParam = abi.encode(amt, setId);\r\n        // (uint _type, uint _id) = connectorID();\r\n        // EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim Accrued COMP Token.\r\n     * @param setId Set ctoken amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function ClaimCompThree(address user, address[] calldata supplyTokens, address[] calldata borrowTokens, uint setId) external payable {\r\n        (\r\n            address[] memory ctokens,\r\n            bool isBorrow,\r\n            bool isSupply\r\n        ) = mergeCtokenArr(supplyTokens, borrowTokens);\r\n\r\n        address[] memory holders = new address[](1);\r\n        holders[0] = user;\r\n\r\n        TokenInterface compToken = TokenInterface(getCompTokenAddress());\r\n        uint intialBal = compToken.balanceOf(user);\r\n        ComptrollerInterface(getComptrollerAddress()).claimComp(holders, ctokens, isBorrow, isSupply);\r\n        uint finalBal = compToken.balanceOf(user);\r\n        uint amt = sub(finalBal, intialBal);\r\n\r\n        setUint(setId, amt);\r\n\r\n        emit LogClaimedComp(amt, setId);\r\n        // bytes32 _eventCode = keccak256(\"LogClaimedComp(uint256,uint256)\");\r\n        // bytes memory _eventParam = abi.encode(amt, setId);\r\n        // (uint _type, uint _id) = connectorID();\r\n        // EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n\r\n    function mergeCtokenArr(address[] memory supplyTokens, address[] memory borrowTokens) internal view\r\n    returns (\r\n        address[] memory ctokens,\r\n        bool isBorrow,\r\n        bool isSupply\r\n    )\r\n    {\r\n         uint _supplyLen = supplyTokens.length;\r\n        uint _borrowLen = borrowTokens.length;\r\n        uint _totalLen = add(_supplyLen, _borrowLen);\r\n        ctokens = new address[](_totalLen);\r\n        isBorrow;\r\n        isSupply;\r\n        if(_supplyLen > 0) {\r\n            for (uint i = 0; i < _supplyLen; i++) {\r\n                ctokens[i] = InstaMapping(getMappingAddr()).cTokenMapping(supplyTokens[i]);\r\n            }\r\n            isSupply = true;\r\n        }\r\n\r\n        if(_borrowLen > 0) {\r\n            for (uint i = 0; i < _borrowLen; i++) {\r\n                ctokens[_supplyLen + i] = InstaMapping(getMappingAddr()).cTokenMapping(borrowTokens[i]);\r\n            }\r\n            isBorrow = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Delegate votes.\r\n     * @param delegatee The address to delegate votes to.\r\n    */\r\n    function delegate(address user, address delegatee) external payable {\r\n        COMPInterface compToken = COMPInterface(getCompTokenAddress());\r\n        require(compToken.delegates(user) != delegatee, \"Already delegated to same delegatee.\");\r\n\r\n        compToken.delegate(delegatee);\r\n\r\n        emit LogDelegate(delegatee);\r\n        // bytes32 _eventCode = keccak256(\"LogDelegate(address)\");\r\n        // bytes memory _eventParam = abi.encode(delegatee);\r\n        // (uint _type, uint _id) = connectorID();\r\n        // EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\r\n    }\r\n}\r\n\r\n\r\ncontract ConnectCOMP is BasicResolver {\r\n    string public name = \"COMP-v1\";\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"compAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"LogClaimedComp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"LogDelegate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"ClaimComp\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"supplyTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"borrowTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"ClaimCompThree\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"ClaimCompTwo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectorID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConnectCOMP","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0c85f15f47b1638278152f7c98f807a7b2bc76d947aeb905cf91a82ee5bc8763"}]}