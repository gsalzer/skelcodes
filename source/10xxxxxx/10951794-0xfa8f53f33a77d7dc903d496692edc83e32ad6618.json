{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\n/**\r\n * @title DTokenInterface\r\n * @author 0age\r\n * @notice Interface for dTokens (in addition to the standard ERC20 interface).\r\n */\r\ninterface DTokenInterface {\r\n  // Events bear similarity to Compound's supply-related events.\r\n  event Mint(address minter, uint256 mintAmount, uint256 mintDTokens);\r\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemDTokens);\r\n  event Accrue(uint256 dTokenExchangeRate, uint256 cTokenExchangeRate);\r\n  event CollectSurplus(uint256 surplusAmount, uint256 surplusCTokens);\r\n\r\n  // The block number and cToken + dToken exchange rates are updated on accrual.\r\n  struct AccrualIndex {\r\n    uint112 dTokenExchangeRate;\r\n    uint112 cTokenExchangeRate;\r\n    uint32 block;\r\n  }\r\n\r\n  // These external functions trigger accrual on the dToken and backing cToken.\r\n  function mint(uint256 underlyingToSupply) external returns (uint256 dTokensMinted);\r\n  function redeem(uint256 dTokensToBurn) external returns (uint256 underlyingReceived);\r\n  function redeemUnderlying(uint256 underelyingToReceive) external returns (uint256 dTokensBurned);\r\n  function pullSurplus() external returns (uint256 cTokenSurplus);\r\n\r\n  // These external functions only trigger accrual on the dToken.\r\n  function mintViaCToken(uint256 cTokensToSupply) external returns (uint256 dTokensMinted);\r\n  function redeemToCToken(uint256 dTokensToBurn) external returns (uint256 cTokensReceived);\r\n  function redeemUnderlyingToCToken(uint256 underlyingToReceive) external returns (uint256 dTokensBurned);\r\n  function accrueInterest() external;\r\n  function transferUnderlying(\r\n    address recipient, uint256 underlyingEquivalentAmount\r\n  ) external returns (bool success);\r\n  function transferUnderlyingFrom(\r\n    address sender, address recipient, uint256 underlyingEquivalentAmount\r\n  ) external returns (bool success);\r\n\r\n  // This function provides basic meta-tx support and does not trigger accrual.\r\n  function modifyAllowanceViaMetaTransaction(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    bool increase,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external returns (bool success);\r\n\r\n  // View and pure functions do not trigger accrual on the dToken or the cToken.\r\n  function getMetaTransactionMessageHash(\r\n    bytes4 functionSelector, bytes calldata arguments, uint256 expiration, bytes32 salt\r\n  ) external view returns (bytes32 digest, bool valid);\r\n  function totalSupplyUnderlying() external view returns (uint256);\r\n  function balanceOfUnderlying(address account) external view returns (uint256 underlyingBalance);\r\n  function exchangeRateCurrent() external view returns (uint256 dTokenExchangeRate);\r\n  function supplyRatePerBlock() external view returns (uint256 dTokenInterestRate);\r\n  function accrualBlockNumber() external view returns (uint256 blockNumber);\r\n  function getSurplus() external view returns (uint256 cTokenSurplus);\r\n  function getSurplusUnderlying() external view returns (uint256 underlyingSurplus);\r\n  function getSpreadPerBlock() external view returns (uint256 rateSpread);\r\n  function getVersion() external pure returns (uint256 version);\r\n  function getCToken() external pure returns (address cToken);\r\n  function getUnderlying() external pure returns (address underlying);\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface ERC1271Interface {\r\n  function isValidSignature(\r\n    bytes calldata data, bytes calldata signature\r\n  ) external view returns (bytes4 magicValue);\r\n}\r\n\r\n\r\ninterface CTokenInterface {\r\n  function mint(uint256 mintAmount) external returns (uint256 err);\r\n  function redeem(uint256 redeemAmount) external returns (uint256 err);\r\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256 err);\r\n  function accrueInterest() external returns (uint256 err);\r\n  function transfer(address recipient, uint256 value) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function balanceOfUnderlying(address account) external returns (uint256 balance);\r\n  function exchangeRateCurrent() external returns (uint256 exchangeRate);\r\n\r\n  function getCash() external view returns (uint256);\r\n  function totalSupply() external view returns (uint256 supply);\r\n  function totalBorrows() external view returns (uint256 borrows);\r\n  function totalReserves() external view returns (uint256 reserves);\r\n  function interestRateModel() external view returns (address model);\r\n  function reserveFactorMantissa() external view returns (uint256 factor);\r\n  function supplyRatePerBlock() external view returns (uint256 rate);\r\n  function exchangeRateStored() external view returns (uint256 rate);\r\n  function accrualBlockNumber() external view returns (uint256 blockNumber);\r\n  function balanceOf(address account) external view returns (uint256 balance);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface CUSDCInterestRateModelInterface {\r\n  function getBorrowRate(\r\n    uint256 cash, uint256 borrows, uint256 reserves\r\n  ) external view returns (uint256 err, uint256 borrowRate);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaTokenOverrides\r\n * @author 0age\r\n * @notice A collection of internal view and pure functions that should be\r\n * overridden by the ultimate Dharma Token implementation.\r\n */\r\ncontract DharmaTokenOverrides {\r\n  /**\r\n   * @notice Internal view function to get the current cToken exchange rate and\r\n   * supply rate per block. This function is meant to be overridden by the\r\n   * dToken that inherits this contract.\r\n   * @return The current cToken exchange rate, or amount of underlying tokens\r\n   * that are redeemable for each cToken, and the cToken supply rate per block\r\n   * (with 18 decimal places added to each returned rate).\r\n   */\r\n  function _getCurrentCTokenRates() internal view returns (\r\n    uint256 exchangeRate, uint256 supplyRate\r\n  );\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the name of the underlying token.\r\n   * @return The name of the underlying token.\r\n   */\r\n  function _getUnderlyingName() internal pure returns (string memory underlyingName);\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the address of the underlying\r\n   * token.\r\n   * @return The address of the underlying token.\r\n   */\r\n  function _getUnderlying() internal pure returns (address underlying);\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the symbol of the backing cToken.\r\n   * @return The symbol of the backing cToken.\r\n   */\r\n  function _getCTokenSymbol() internal pure returns (string memory cTokenSymbol);\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the address of the backing cToken.\r\n   * @return The address of the backing cToken.\r\n   */\r\n  function _getCToken() internal pure returns (address cToken);\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the name of the dToken.\r\n   * @return The name of the dToken.\r\n   */\r\n  function _getDTokenName() internal pure returns (string memory dTokenName);\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the symbol of the dToken.\r\n   * @return The symbol of the dToken.\r\n   */\r\n  function _getDTokenSymbol() internal pure returns (string memory dTokenSymbol);\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the address of the vault that\r\n   * receives surplus cTokens whenever the surplus is pulled.\r\n   * @return The address of the vault.\r\n   */\r\n  function _getVault() internal pure returns (address vault);\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaTokenHelpers\r\n * @author 0age\r\n * @notice A collection of constants and internal pure functions used by Dharma\r\n * Tokens.\r\n */\r\ncontract DharmaTokenHelpers is DharmaTokenOverrides {\r\n  using SafeMath for uint256;\r\n\r\n  uint8 internal constant _DECIMALS = 8; // matches cToken decimals\r\n  uint256 internal constant _SCALING_FACTOR = 1e18;\r\n  uint256 internal constant _SCALING_FACTOR_MINUS_ONE = 999999999999999999;\r\n  uint256 internal constant _HALF_OF_SCALING_FACTOR = 5e17;\r\n  uint256 internal constant _COMPOUND_SUCCESS = 0;\r\n  uint256 internal constant _MAX_UINT_112 = 5192296858534827628530496329220095;\r\n  /* solhint-disable separate-by-one-line-in-contract */\r\n  uint256 internal constant _MAX_UNMALLEABLE_S = (\r\n    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n  );\r\n  /* solhint-enable separate-by-one-line-in-contract */\r\n\r\n  /**\r\n   * @notice Internal pure function to determine if a call to Compound succeeded\r\n   * and to revert, supplying the reason, if it failed. Failure can be caused by\r\n   * a call that reverts, or by a call that does not revert but returns a\r\n   * non-zero error code.\r\n   * @param functionSelector bytes4 The function selector that was called.\r\n   * @param ok bool A boolean representing whether the call returned or\r\n   * reverted.\r\n   * @param data bytes The data provided by the returned or reverted call.\r\n   */\r\n  function _checkCompoundInteraction(\r\n    bytes4 functionSelector, bool ok, bytes memory data\r\n  ) internal pure {\r\n    CTokenInterface cToken;\r\n    if (ok) {\r\n      if (\r\n        functionSelector == cToken.transfer.selector ||\r\n        functionSelector == cToken.transferFrom.selector\r\n      ) {\r\n        require(\r\n          abi.decode(data, (bool)), string(\r\n            abi.encodePacked(\r\n              \"Compound \",\r\n              _getCTokenSymbol(),\r\n              \" contract returned false on calling \",\r\n              _getFunctionName(functionSelector),\r\n              \".\"\r\n            )\r\n          )\r\n        );\r\n      } else {\r\n        uint256 compoundError = abi.decode(data, (uint256)); // throw on no data\r\n        if (compoundError != _COMPOUND_SUCCESS) {\r\n          revert(\r\n            string(\r\n              abi.encodePacked(\r\n                \"Compound \",\r\n                _getCTokenSymbol(),\r\n                \" contract returned error code \",\r\n                uint8((compoundError / 10) + 48),\r\n                uint8((compoundError % 10) + 48),\r\n                \" on calling \",\r\n                _getFunctionName(functionSelector),\r\n                \".\"\r\n              )\r\n            )\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      revert(\r\n        string(\r\n          abi.encodePacked(\r\n            \"Compound \",\r\n            _getCTokenSymbol(),\r\n            \" contract reverted while attempting to call \",\r\n            _getFunctionName(functionSelector),\r\n            \": \",\r\n            _decodeRevertReason(data)\r\n          )\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to get a Compound function name based on the\r\n   * selector.\r\n   * @param functionSelector bytes4 The function selector.\r\n   * @return The name of the function as a string.\r\n   */\r\n  function _getFunctionName(\r\n    bytes4 functionSelector\r\n  ) internal pure returns (string memory functionName) {\r\n    CTokenInterface cToken;\r\n    if (functionSelector == cToken.mint.selector) {\r\n      functionName = \"mint\";\r\n    } else if (functionSelector == cToken.redeem.selector) {\r\n      functionName = \"redeem\";\r\n    } else if (functionSelector == cToken.redeemUnderlying.selector) {\r\n      functionName = \"redeemUnderlying\";\r\n    } else if (functionSelector == cToken.transferFrom.selector) {\r\n      functionName = \"transferFrom\";\r\n    } else if (functionSelector == cToken.transfer.selector) {\r\n      functionName = \"transfer\";\r\n    } else if (functionSelector == cToken.accrueInterest.selector) {\r\n      functionName = \"accrueInterest\";\r\n    } else {\r\n      functionName = \"an unknown function\";\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to decode revert reasons. The revert reason\r\n   * prefix is removed and the remaining string argument is decoded.\r\n   * @param revertData bytes The raw data supplied alongside the revert.\r\n   * @return The decoded revert reason string.\r\n   */\r\n  function _decodeRevertReason(\r\n    bytes memory revertData\r\n  ) internal pure returns (string memory revertReason) {\r\n    // Solidity prefixes revert reason with 0x08c379a0 -> Error(string) selector\r\n    if (\r\n      revertData.length > 68 && // prefix (4) + position (32) + length (32)\r\n      revertData[0] == byte(0x08) &&\r\n      revertData[1] == byte(0xc3) &&\r\n      revertData[2] == byte(0x79) &&\r\n      revertData[3] == byte(0xa0)\r\n    ) {\r\n      // Get the revert reason without the prefix from the revert data.\r\n      bytes memory revertReasonBytes = new bytes(revertData.length - 4);\r\n      for (uint256 i = 4; i < revertData.length; i++) {\r\n        revertReasonBytes[i - 4] = revertData[i];\r\n      }\r\n\r\n      // Decode the resultant revert reason as a string.\r\n      revertReason = abi.decode(revertReasonBytes, (string));\r\n    } else {\r\n      // Simply return the default, with no revert reason.\r\n      revertReason = \"(no revert reason)\";\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to construct a failure message string for\r\n   * the revert reason on transfers of underlying tokens that do not succeed.\r\n   * @return The failure message.\r\n   */\r\n  function _getTransferFailureMessage() internal pure returns (\r\n    string memory message\r\n  ) {\r\n    message = string(\r\n      abi.encodePacked(_getUnderlyingName(), \" transfer failed.\")\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to convert a uint256 to a uint112, reverting\r\n   * if the conversion would cause an overflow.\r\n   * @param input uint256 The unsigned integer to convert.\r\n   * @return The converted unsigned integer.\r\n   */\r\n  function _safeUint112(uint256 input) internal pure returns (uint112 output) {\r\n    require(input <= _MAX_UINT_112, \"Overflow on conversion to uint112.\");\r\n    output = uint112(input);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to convert an underlying amount to a dToken\r\n   * or cToken amount using an exchange rate and fixed-point arithmetic.\r\n   * @param underlying uint256 The underlying amount to convert.\r\n   * @param exchangeRate uint256 The exchange rate (multiplied by 10^18).\r\n   * @param roundUp bool Whether the final amount should be rounded up - it will\r\n   * instead be truncated (rounded down) if this value is false.\r\n   * @return The cToken or dToken amount.\r\n   */\r\n  function _fromUnderlying(\r\n    uint256 underlying, uint256 exchangeRate, bool roundUp\r\n  ) internal pure returns (uint256 amount) {\r\n    if (roundUp) {\r\n      amount = (\r\n        (underlying.mul(_SCALING_FACTOR)).add(exchangeRate.sub(1))\r\n      ).div(exchangeRate);\r\n    } else {\r\n      amount = (underlying.mul(_SCALING_FACTOR)).div(exchangeRate);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to convert a dToken or cToken amount to the\r\n   * underlying amount using an exchange rate and fixed-point arithmetic.\r\n   * @param amount uint256 The cToken or dToken amount to convert.\r\n   * @param exchangeRate uint256 The exchange rate (multiplied by 10^18).\r\n   * @param roundUp bool Whether the final amount should be rounded up - it will\r\n   * instead be truncated (rounded down) if this value is false.\r\n   * @return The underlying amount.\r\n   */\r\n  function _toUnderlying(\r\n    uint256 amount, uint256 exchangeRate, bool roundUp\r\n  ) internal pure returns (uint256 underlying) {\r\n    if (roundUp) {\r\n      underlying = (\r\n        (amount.mul(exchangeRate).add(_SCALING_FACTOR_MINUS_ONE)\r\n      ) / _SCALING_FACTOR);\r\n    } else {\r\n      underlying = amount.mul(exchangeRate) / _SCALING_FACTOR;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to convert an underlying amount to a dToken\r\n   * or cToken amount and back to the underlying, so as to properly capture\r\n   * rounding errors, by using an exchange rate and fixed-point arithmetic.\r\n   * @param underlying uint256 The underlying amount to convert.\r\n   * @param exchangeRate uint256 The exchange rate (multiplied by 10^18).\r\n   * @param roundUpOne bool Whether the intermediate dToken or cToken amount\r\n   * should be rounded up - it will instead be truncated (rounded down) if this\r\n   * value is false.\r\n   * @param roundUpTwo bool Whether the final underlying amount should be\r\n   * rounded up - it will instead be truncated (rounded down) if this value is\r\n   * false.\r\n   * @return The intermediate cToken or dToken amount and the final underlying\r\n   * amount.\r\n   */\r\n  function _fromUnderlyingAndBack(\r\n    uint256 underlying, uint256 exchangeRate, bool roundUpOne, bool roundUpTwo\r\n  ) internal pure returns (uint256 amount, uint256 adjustedUnderlying) {\r\n    amount = _fromUnderlying(underlying, exchangeRate, roundUpOne);\r\n    adjustedUnderlying = _toUnderlying(amount, exchangeRate, roundUpTwo);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaTokenV2\r\n * @author 0age (dToken mechanics derived from Compound cTokens, ERC20 mechanics\r\n * derived from Open Zeppelin's ERC20 contract)\r\n * @notice DharmaTokenV2 deprecates the interest-bearing component and prevents\r\n * minting of new tokens or redeeming to cTokens. It also returns COMP in\r\n * proportion to the respective dToken balance in relation to total supply.\r\n */\r\ncontract DharmaTokenV2 is ERC20Interface, DTokenInterface, DharmaTokenHelpers {\r\n  // Set the version of the Dharma Token as a constant.\r\n  uint256 private constant _DTOKEN_VERSION = 2;\r\n\r\n  ERC20Interface internal constant _COMP = ERC20Interface(\r\n    0xc00e94Cb662C3520282E6f5717214004A7f26888 // mainnet\r\n  );\r\n\r\n  // Set block number and dToken + cToken exchange rate in slot zero on accrual.\r\n  AccrualIndex private _accrualIndex;\r\n\r\n  // Slot one tracks the total issued dTokens.\r\n  uint256 private _totalSupply;\r\n\r\n  // Slots two and three are entrypoints into balance and allowance mappings.\r\n  mapping (address => uint256) private _balances;\r\n  mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n  // Slot four is an entrypoint into a mapping for used meta-transaction hashes.\r\n  mapping (bytes32 => bool) private _executedMetaTxs;\r\n  \r\n  bool exchangeRateFrozen; // initially false\r\n\r\n  /**\r\n   * @notice Deprecated.\r\n   */\r\n  function mint(\r\n    uint256 underlyingToSupply\r\n  ) external returns (uint256 dTokensMinted) {\r\n    revert(\"Minting is no longer supported.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Deprecated.\r\n   */\r\n  function mintViaCToken(\r\n    uint256 cTokensToSupply\r\n  ) external returns (uint256 dTokensMinted) {\r\n    revert(\"Minting is no longer supported.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Redeem `dTokensToBurn` dTokens from `msg.sender`, use the\r\n   * corresponding cTokens to redeem the required underlying, and transfer the\r\n   * redeemed underlying tokens to `msg.sender`.\r\n   * @param dTokensToBurn uint256 The amount of dTokens to provide in exchange\r\n   * for underlying tokens.\r\n   * @return The amount of underlying received in return for the provided\r\n   * dTokens.\r\n   */\r\n  function redeem(\r\n    uint256 dTokensToBurn\r\n  ) external returns (uint256 underlyingReceived) {\r\n    require(exchangeRateFrozen, \"Call `pullSurplus()` to freeze exchange rate first.\");\r\n\r\n    // Instantiate interface for the underlying token.\r\n    ERC20Interface underlying = ERC20Interface(_getUnderlying());\r\n\r\n    require(dTokensToBurn > 0, \"No funds specified to redeem.\");\r\n    \r\n    // Get the total supply, as well as current underlying and COMP balances.\r\n    uint256 originalSupply = _totalSupply;\r\n    uint256 underlyingBalance = underlying.balanceOf(address(this));\r\n    uint256 compBalance = _COMP.balanceOf(address(this));\r\n\r\n     // Apply dToken ratio to balances to determine amount to transfer out.\r\n    underlyingReceived = underlyingBalance.mul(dTokensToBurn) / originalSupply;\r\n    uint256 compReceived = compBalance.mul(dTokensToBurn) / originalSupply;\r\n    require(\r\n      underlyingReceived.add(compReceived) > 0,\r\n      \"Supplied dTokens are insufficient to redeem.\"\r\n    );\r\n    \r\n    // Burn the dTokens.\r\n    _burn(msg.sender, underlyingReceived, dTokensToBurn);\r\n    \r\n    // Transfer out the proportion of each associated with the burned tokens.\r\n    if (underlyingReceived > 0) {\r\n      require(\r\n        underlying.transfer(msg.sender, underlyingReceived),\r\n        _getTransferFailureMessage()\r\n      );\r\n    }\r\n\r\n    if (compReceived > 0) {\r\n      require(\r\n        _COMP.transfer(msg.sender, compReceived),\r\n        \"COMP transfer out failed.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Deprecated.\r\n   */\r\n  function redeemToCToken(\r\n    uint256 dTokensToBurn\r\n  ) external returns (uint256 cTokensReceived) {\r\n    revert(\"Redeeming to cTokens is no longer supported.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Redeem the dToken equivalent value of the underlying token amount\r\n   * `underlyingToReceive` from `msg.sender`, use the corresponding cTokens to\r\n   * redeem the underlying, and transfer the underlying to `msg.sender`.\r\n   * @param underlyingToReceive uint256 The amount, denominated in the\r\n   * underlying token, of the cToken to redeem in exchange for the received\r\n   * underlying token.\r\n   * @return The amount of dTokens burned in exchange for the returned\r\n   * underlying tokens.\r\n   */\r\n  function redeemUnderlying(\r\n    uint256 underlyingToReceive\r\n  ) external returns (uint256 dTokensBurned) {\r\n    require(exchangeRateFrozen, \"Call `pullSurplus()` to freeze exchange rate first.\");\r\n\r\n    // Instantiate interface for the underlying token.\r\n    ERC20Interface underlying = ERC20Interface(_getUnderlying());\r\n\r\n    // Get the dToken exchange rate.\r\n    (uint256 dTokenExchangeRate, ) = _accrue(false);\r\n\r\n    // Determine dToken amount to burn using the exchange rate, rounded up.\r\n    dTokensBurned = _fromUnderlying(\r\n      underlyingToReceive, dTokenExchangeRate, true\r\n    );\r\n\r\n    // Determine dToken amount for returning COMP by rounding down.\r\n    uint256 dTokensForCOMP = _fromUnderlying(\r\n      underlyingToReceive, dTokenExchangeRate, false\r\n    );\r\n    \r\n    // Get the total supply and current COMP balance.\r\n    uint256 originalSupply = _totalSupply;\r\n    uint256 compBalance = _COMP.balanceOf(address(this));\r\n\r\n     // Apply dToken ratio to COMP balance to determine amount to transfer out.\r\n    uint256 compReceived = compBalance.mul(dTokensForCOMP) / originalSupply;\r\n    require(\r\n      underlyingToReceive.add(compReceived) > 0,\r\n      \"Supplied amount is insufficient to redeem.\"\r\n    );\r\n    \r\n    // Burn the dTokens.\r\n    _burn(msg.sender, underlyingToReceive, dTokensBurned);\r\n    \r\n    // Transfer out the proportion of each associated with the burned tokens.\r\n    if (underlyingToReceive > 0) {\r\n      require(\r\n        underlying.transfer(msg.sender, underlyingToReceive),\r\n        _getTransferFailureMessage()\r\n      );\r\n    }\r\n\r\n    if (compReceived > 0) {\r\n      require(\r\n        _COMP.transfer(msg.sender, compReceived),\r\n        \"COMP transfer out failed.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Deprecated.\r\n   */\r\n  function redeemUnderlyingToCToken(\r\n    uint256 underlyingToReceive\r\n  ) external returns (uint256 dTokensBurned) {\r\n    revert(\"Redeeming to cTokens is no longer supported.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer cTokens with underlying value in excess of the total\r\n   * underlying dToken value to a dedicated \"vault\" account. A \"hard\" accrual\r\n   * will first be performed, triggering an accrual on both the cToken and the\r\n   * dToken.\r\n   * @return The amount of cTokens transferred to the vault account.\r\n   */\r\n  function pullSurplus() external returns (uint256 cTokenSurplus) {\r\n    require(!exchangeRateFrozen, \"No surplus left to pull.\");\r\n\r\n    // Instantiate the interface for the backing cToken.\r\n    CTokenInterface cToken = CTokenInterface(_getCToken());\r\n\r\n    // Accrue interest on the cToken and ensure that the operation succeeds.\r\n    (bool ok, bytes memory data) = address(cToken).call(abi.encodeWithSelector(\r\n      cToken.accrueInterest.selector\r\n    ));\r\n    _checkCompoundInteraction(cToken.accrueInterest.selector, ok, data);\r\n\r\n    // Accrue interest on the dToken, reusing the stored cToken exchange rate.\r\n    _accrue(false);\r\n\r\n    // Determine cToken surplus in underlying (cToken value - dToken value).\r\n    uint256 underlyingSurplus;\r\n    (underlyingSurplus, cTokenSurplus) = _getSurplus();\r\n\r\n    // Transfer cToken surplus to vault and ensure that the operation succeeds.\r\n    (ok, data) = address(cToken).call(abi.encodeWithSelector(\r\n      cToken.transfer.selector, _getVault(), cTokenSurplus\r\n    ));\r\n    _checkCompoundInteraction(cToken.transfer.selector, ok, data);\r\n\r\n    emit CollectSurplus(underlyingSurplus, cTokenSurplus);\r\n    \r\n    exchangeRateFrozen = true;\r\n    \r\n    // Redeem all cTokens for underlying and ensure that the operation succeeds.\r\n    (ok, data) = address(cToken).call(abi.encodeWithSelector(\r\n      cToken.redeem.selector, cToken.balanceOf(address(this))\r\n    ));\r\n    _checkCompoundInteraction(cToken.redeem.selector, ok, data);\r\n  }\r\n\r\n  /**\r\n   * @notice Deprecated.\r\n   */\r\n  function accrueInterest() external {\r\n    revert(\"Interest accrual is longer supported.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `amount` dTokens from `msg.sender` to `recipient`.\r\n   * @param recipient address The account to transfer the dTokens to.\r\n   * @param amount uint256 The amount of dTokens to transfer.\r\n   * @return A boolean indicating whether the transfer was successful.\r\n   */\r\n  function transfer(\r\n    address recipient, uint256 amount\r\n  ) external returns (bool success) {\r\n    _transfer(msg.sender, recipient, amount);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer dTokens equivalent to `underlyingEquivalentAmount`\r\n   * underlying from `msg.sender` to `recipient`.\r\n   * @param recipient address The account to transfer the dTokens to.\r\n   * @param underlyingEquivalentAmount uint256 The underlying equivalent amount\r\n   * of dTokens to transfer.\r\n   * @return A boolean indicating whether the transfer was successful.\r\n   */\r\n  function transferUnderlying(\r\n    address recipient, uint256 underlyingEquivalentAmount\r\n  ) external returns (bool success) {\r\n    // Accrue interest and retrieve the current dToken exchange rate.\r\n    (uint256 dTokenExchangeRate, ) = _accrue(true);\r\n\r\n    // Determine dToken amount to transfer using the exchange rate, rounded up.\r\n    uint256 dTokenAmount = _fromUnderlying(\r\n      underlyingEquivalentAmount, dTokenExchangeRate, true\r\n    );\r\n\r\n    // Transfer the dTokens.\r\n    _transfer(msg.sender, recipient, dTokenAmount);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Approve `spender` to transfer up to `value` dTokens on behalf of\r\n   * `msg.sender`.\r\n   * @param spender address The account to grant the allowance.\r\n   * @param value uint256 The size of the allowance to grant.\r\n   * @return A boolean indicating whether the approval was successful.\r\n   */\r\n  function approve(\r\n    address spender, uint256 value\r\n  ) external returns (bool success) {\r\n    _approve(msg.sender, spender, value);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `amount` dTokens from `sender` to `recipient` as long as\r\n   * `msg.sender` has sufficient allowance.\r\n   * @param sender address The account to transfer the dTokens from.\r\n   * @param recipient address The account to transfer the dTokens to.\r\n   * @param amount uint256 The amount of dTokens to transfer.\r\n   * @return A boolean indicating whether the transfer was successful.\r\n   */\r\n  function transferFrom(\r\n    address sender, address recipient, uint256 amount\r\n  ) external returns (bool success) {\r\n    _transferFrom(sender, recipient, amount);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer dTokens eqivalent to `underlyingEquivalentAmount`\r\n   * underlying from `sender` to `recipient` as long as `msg.sender` has\r\n   * sufficient allowance.\r\n   * @param sender address The account to transfer the dTokens from.\r\n   * @param recipient address The account to transfer the dTokens to.\r\n   * @param underlyingEquivalentAmount uint256 The underlying equivalent amount\r\n   * of dTokens to transfer.\r\n   * @return A boolean indicating whether the transfer was successful.\r\n   */\r\n  function transferUnderlyingFrom(\r\n    address sender, address recipient, uint256 underlyingEquivalentAmount\r\n  ) external returns (bool success) {\r\n    // Accrue interest and retrieve the current dToken exchange rate.\r\n    (uint256 dTokenExchangeRate, ) = _accrue(true);\r\n\r\n    // Determine dToken amount to transfer using the exchange rate, rounded up.\r\n    uint256 dTokenAmount = _fromUnderlying(\r\n      underlyingEquivalentAmount, dTokenExchangeRate, true\r\n    );\r\n\r\n    // Transfer the dTokens and adjust allowance accordingly.\r\n    _transferFrom(sender, recipient, dTokenAmount);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Increase the current allowance of `spender` by `value` dTokens.\r\n   * @param spender address The account to grant the additional allowance.\r\n   * @param addedValue uint256 The amount to increase the allowance by.\r\n   * @return A boolean indicating whether the modification was successful.\r\n   */\r\n  function increaseAllowance(\r\n    address spender, uint256 addedValue\r\n  ) external returns (bool success) {\r\n    _approve(\r\n      msg.sender, spender, _allowances[msg.sender][spender].add(addedValue)\r\n    );\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Decrease the current allowance of `spender` by `value` dTokens.\r\n   * @param spender address The account to decrease the allowance for.\r\n   * @param subtractedValue uint256 The amount to subtract from the allowance.\r\n   * @return A boolean indicating whether the modification was successful.\r\n   */\r\n  function decreaseAllowance(\r\n    address spender, uint256 subtractedValue\r\n  ) external returns (bool success) {\r\n    _approve(\r\n      msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue)\r\n    );\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Modify the current allowance of `spender` for `owner` by `value`\r\n   * dTokens, increasing it if `increase` is true otherwise decreasing it, via a\r\n   * meta-transaction that expires at `expiration` (or does not expire if the\r\n   * value is zero) and uses `salt` as an additional input, validated using\r\n   * `signatures`.\r\n   * @param owner address The account granting the modified allowance.\r\n   * @param spender address The account to modify the allowance for.\r\n   * @param value uint256 The amount to modify the allowance by.\r\n   * @param increase bool A flag that indicates whether the allowance will be\r\n   * increased by the specified value (if true) or decreased by it (if false).\r\n   * @param expiration uint256 A timestamp indicating how long the modification\r\n   * meta-transaction is valid for - a value of zero will signify no expiration.\r\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\r\n   * to the hash digest used to validate the signatures.\r\n   * @param signatures bytes A signature, or collection of signatures, that the\r\n   * owner must provide in order to authorize the meta-transaction. If the\r\n   * account of the owner does not have any runtime code deployed to it, the\r\n   * signature will be verified using ecrecover; otherwise, it will be supplied\r\n   * to the owner along with the message digest and context via ERC-1271 for\r\n   * validation.\r\n   * @return A boolean indicating whether the modification was successful.\r\n   */\r\n  function modifyAllowanceViaMetaTransaction(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    bool increase,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external returns (bool success) {\r\n    require(expiration == 0 || now <= expiration, \"Meta-transaction expired.\");\r\n\r\n    // Construct the meta-transaction's message hash based on relevant context.\r\n    bytes memory context = abi.encodePacked(\r\n      address(this),\r\n      // _DTOKEN_VERSION,\r\n      this.modifyAllowanceViaMetaTransaction.selector,\r\n      expiration,\r\n      salt,\r\n      abi.encode(owner, spender, value, increase)\r\n    );\r\n    bytes32 messageHash = keccak256(context);\r\n\r\n    // Ensure message hash has never been used before and register it as used.\r\n    require(!_executedMetaTxs[messageHash], \"Meta-transaction already used.\");\r\n    _executedMetaTxs[messageHash] = true;\r\n\r\n    // Construct the digest to compare signatures against using EIP-191 0x45.\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\r\n    );\r\n\r\n    // Calculate new allowance by applying modification to current allowance.\r\n    uint256 currentAllowance = _allowances[owner][spender];\r\n    uint256 newAllowance = (\r\n      increase ? currentAllowance.add(value) : currentAllowance.sub(value)\r\n    );\r\n\r\n    // Use EIP-1271 if owner is a contract - otherwise, use ecrecover.\r\n    if (_isContract(owner)) {\r\n      // Validate via ERC-1271 against the owner account.\r\n      bytes memory data = abi.encode(digest, context);\r\n      bytes4 magic = ERC1271Interface(owner).isValidSignature(data, signatures);\r\n      require(magic == bytes4(0x20c13b0b), \"Invalid signatures.\");\r\n    } else {\r\n      // Validate via ecrecover against the owner account.\r\n      _verifyRecover(owner, digest, signatures);\r\n    }\r\n\r\n    // Modify the allowance.\r\n    _approve(owner, spender, newAllowance);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to determine a meta-transaction message hash, and to\r\n   * determine if it is still valid (i.e. it has not yet been used and is not\r\n   * expired). The returned message hash will need to be prefixed using EIP-191\r\n   * 0x45 and hashed again in order to generate a final digest for the required\r\n   * signature - in other words, the same procedure utilized by `eth_Sign`.\r\n   * @param functionSelector bytes4 The function selector for the given\r\n   * meta-transaction. There is only one function selector available for V1:\r\n   * `0x2d657fa5` (the selector for `modifyAllowanceViaMetaTransaction`).\r\n   * @param arguments bytes The abi-encoded function arguments (aside from the\r\n   * `expiration`, `salt`, and `signatures` arguments) that should be supplied\r\n   * to the given function.\r\n   * @param expiration uint256 A timestamp indicating how long the given\r\n   * meta-transaction is valid for - a value of zero will signify no expiration.\r\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\r\n   * to the hash digest used to validate the signatures.\r\n   * @return The total supply.\r\n   */\r\n  function getMetaTransactionMessageHash(\r\n    bytes4 functionSelector,\r\n    bytes calldata arguments,\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external view returns (bytes32 messageHash, bool valid) {\r\n    // Construct the meta-transaction's message hash based on relevant context.\r\n    messageHash = keccak256(\r\n      abi.encodePacked(\r\n        address(this), functionSelector, expiration, salt, arguments\r\n      )\r\n    );\r\n\r\n    // The meta-transaction is valid if it has not been used and is not expired.\r\n    valid = (\r\n      !_executedMetaTxs[messageHash] && (expiration == 0 || now <= expiration)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the total dToken supply.\r\n   * @return The total supply.\r\n   */\r\n  function totalSupply() external view returns (uint256 dTokenTotalSupply) {\r\n    dTokenTotalSupply = _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the total dToken supply, denominated in the\r\n   * underlying token.\r\n   * @return The total supply.\r\n   */\r\n  function totalSupplyUnderlying() external view returns (\r\n    uint256 dTokenTotalSupplyInUnderlying\r\n  ) {\r\n    (uint256 dTokenExchangeRate, ,) = _getExchangeRates(true);\r\n\r\n    // Determine total value of all issued dTokens, denominated as underlying.\r\n    dTokenTotalSupplyInUnderlying = _toUnderlying(\r\n      _totalSupply, dTokenExchangeRate, false\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the total dToken balance of an account.\r\n   * @param account address The account to check the dToken balance for.\r\n   * @return The balance of the given account.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256 dTokens) {\r\n    dTokens = _balances[account];\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the dToken balance of an account, denominated\r\n   * in the underlying equivalent value.\r\n   * @param account address The account to check the balance for.\r\n   * @return The total underlying-equivalent dToken balance.\r\n   */\r\n  function balanceOfUnderlying(\r\n    address account\r\n  ) external view returns (uint256 underlyingBalance) {\r\n    // Get most recent dToken exchange rate by determining accrued interest.\r\n    (uint256 dTokenExchangeRate, ,) = _getExchangeRates(true);\r\n\r\n    // Convert account balance to underlying equivalent using the exchange rate.\r\n    underlyingBalance = _toUnderlying(\r\n      _balances[account], dTokenExchangeRate, false\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the total allowance that `spender` has to\r\n   * transfer dTokens from the `owner` account using `transferFrom`.\r\n   * @param owner address The account that is granting the allowance.\r\n   * @param spender address The account that has been granted the allowance.\r\n   * @return The allowance of the given spender for the given owner.\r\n   */\r\n  function allowance(\r\n    address owner, address spender\r\n  ) external view returns (uint256 dTokenAllowance) {\r\n    dTokenAllowance = _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the current dToken exchange rate (multiplied\r\n   * by 10^18).\r\n   * @return The current exchange rate.\r\n   */\r\n  function exchangeRateCurrent() external view returns (\r\n    uint256 dTokenExchangeRate\r\n  ) {\r\n    // Get most recent dToken exchange rate by determining accrued interest.\r\n    (dTokenExchangeRate, ,) = _getExchangeRates(true);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the current dToken interest earned per block\r\n   * (multiplied by 10^18).\r\n   * @return The current interest rate.\r\n   */\r\n  function supplyRatePerBlock() external view returns (\r\n    uint256 dTokenInterestRate\r\n  ) {\r\n    (dTokenInterestRate,) = _getRatePerBlock();\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the block number where accrual was last\r\n   * performed.\r\n   * @return The block number where accrual was last performed.\r\n   */\r\n  function accrualBlockNumber() external view returns (uint256 blockNumber) {\r\n    blockNumber = _accrualIndex.block;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the total surplus, or the cToken balance that\r\n   * exceeds the aggregate underlying value of the total dToken supply.\r\n   * @return The total surplus in cTokens.\r\n   */\r\n  function getSurplus() external view returns (uint256 cTokenSurplus) {\r\n    // Determine the cToken (cToken underlying value - dToken underlying value).\r\n    (, cTokenSurplus) = _getSurplus();\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the total surplus in the underlying, or the\r\n   * underlying equivalent of the cToken balance that exceeds the aggregate\r\n   * underlying value of the total dToken supply.\r\n   * @return The total surplus, denominated in the underlying.\r\n   */\r\n  function getSurplusUnderlying() external view returns (\r\n    uint256 underlyingSurplus\r\n  ) {\r\n    // Determine cToken surplus in underlying (cToken value - dToken value).\r\n    (underlyingSurplus, ) = _getSurplus();\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the interest rate spread taken by the dToken\r\n   * from the current cToken supply rate per block (multiplied by 10^18).\r\n   * @return The current interest rate spread.\r\n   */\r\n  function getSpreadPerBlock() external view returns (uint256 rateSpread) {\r\n    (\r\n      uint256 dTokenInterestRate, uint256 cTokenInterestRate\r\n    ) = _getRatePerBlock();\r\n    rateSpread = cTokenInterestRate.sub(dTokenInterestRate);\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function to get the name of the dToken.\r\n   * @return The name of the dToken.\r\n   */\r\n  function name() external pure returns (string memory dTokenName) {\r\n    dTokenName = _getDTokenName();\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function to get the symbol of the dToken.\r\n   * @return The symbol of the dToken.\r\n   */\r\n  function symbol() external pure returns (string memory dTokenSymbol) {\r\n    dTokenSymbol = _getDTokenSymbol();\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function to get the number of decimals of the dToken.\r\n   * @return The number of decimals of the dToken.\r\n   */\r\n  function decimals() external pure returns (uint8 dTokenDecimals) {\r\n    dTokenDecimals = _DECIMALS;\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function to get the dToken version.\r\n   * @return The version of the dToken.\r\n   */\r\n  function getVersion() external pure returns (uint256 version) {\r\n    version = _DTOKEN_VERSION;\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function to get the address of the cToken backing this dToken.\r\n   * @return The address of the cToken backing this dToken.\r\n   */\r\n  function getCToken() external pure returns (address cToken) {\r\n    cToken = _getCToken();\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function to get the address of the underlying token of this\r\n   * dToken.\r\n   * @return The address of the underlying token for this dToken.\r\n   */\r\n  function getUnderlying() external pure returns (address underlying) {\r\n    underlying = _getUnderlying();\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to trigger accrual and to update the dToken and\r\n   * cToken exchange rates in storage if necessary. The `compute` argument can\r\n   * be set to false if an accrual has already taken place on the cToken before\r\n   * calling this function.\r\n   * @param compute bool A flag to indicate whether the cToken exchange rate\r\n   * needs to be computed - if false, it will simply be read from storage on the\r\n   * cToken in question.\r\n   * @return The current dToken and cToken exchange rates.\r\n   */\r\n  function _accrue(bool compute) private returns (\r\n    uint256 dTokenExchangeRate, uint256 cTokenExchangeRate\r\n  ) {\r\n    bool alreadyAccrued;\r\n    (\r\n      dTokenExchangeRate, cTokenExchangeRate, alreadyAccrued\r\n    ) = _getExchangeRates(compute);\r\n\r\n    if (!alreadyAccrued) {\r\n      // Update storage with dToken + cToken exchange rates as of current block.\r\n      AccrualIndex storage accrualIndex = _accrualIndex;\r\n      accrualIndex.dTokenExchangeRate = _safeUint112(dTokenExchangeRate);\r\n      accrualIndex.cTokenExchangeRate = _safeUint112(cTokenExchangeRate);\r\n      accrualIndex.block = uint32(block.number);\r\n      emit Accrue(dTokenExchangeRate, cTokenExchangeRate);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to burn `amount` tokens by exchanging `exchanged`\r\n   * tokens from `account` and emit corresponding `Redeeem` & `Transfer` events.\r\n   * @param account address The account to burn tokens from.\r\n   * @param exchanged uint256 The amount of underlying tokens given for burning.\r\n   * @param amount uint256 The amount of tokens to burn.\r\n   */\r\n  function _burn(address account, uint256 exchanged, uint256 amount) private {\r\n    require(\r\n      exchanged > 0 && amount > 0, \"Redeem failed: insufficient funds supplied.\"\r\n    );\r\n\r\n    uint256 balancePriorToBurn = _balances[account];\r\n    require(\r\n      balancePriorToBurn >= amount, \"Supplied amount exceeds account balance.\"\r\n    );\r\n\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    _balances[account] = balancePriorToBurn - amount; // overflow checked above\r\n\r\n    emit Transfer(account, address(0), amount);\r\n    emit Redeem(account, exchanged, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to move `amount` tokens from `sender` to\r\n   * `recipient` and emit a corresponding `Transfer` event.\r\n   * @param sender address The account to transfer tokens from.\r\n   * @param recipient address The account to transfer tokens to.\r\n   * @param amount uint256 The amount of tokens to transfer.\r\n   */\r\n  function _transfer(\r\n    address sender, address recipient, uint256 amount\r\n  ) private {\r\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n    uint256 senderBalance = _balances[sender];\r\n    require(senderBalance >= amount, \"Insufficient funds.\");\r\n\r\n    _balances[sender] = senderBalance - amount; // overflow checked above.\r\n    _balances[recipient] = _balances[recipient].add(amount);\r\n\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to transfer `amount` tokens from `sender` to\r\n   * `recipient` and to deduct the transferred amount from the allowance of the\r\n   * caller unless the allowance is set to the maximum amount.\r\n   * @param sender address The account to transfer tokens from.\r\n   * @param recipient address The account to transfer tokens to.\r\n   * @param amount uint256 The amount of tokens to transfer.\r\n   */\r\n  function _transferFrom(\r\n    address sender, address recipient, uint256 amount\r\n  ) private {\r\n    _transfer(sender, recipient, amount);\r\n    uint256 callerAllowance = _allowances[sender][msg.sender];\r\n    if (callerAllowance != uint256(-1)) {\r\n      require(callerAllowance >= amount, \"Insufficient allowance.\");\r\n      _approve(sender, msg.sender, callerAllowance - amount); // overflow safe.\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to set the allowance for `spender` to transfer up\r\n   * to `value` tokens on behalf of `owner`.\r\n   * @param owner address The account that has granted the allowance.\r\n   * @param spender address The account to grant the allowance.\r\n   * @param value uint256 The size of the allowance to grant.\r\n   */\r\n  function _approve(address owner, address spender, uint256 value) private {\r\n    require(owner != address(0), \"ERC20: approve for the zero address\");\r\n    require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    _allowances[owner][spender] = value;\r\n    emit Approval(owner, spender, value);\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to get the latest dToken and cToken exchange\r\n   * rates and provide the value for each. The `compute` argument can be set to\r\n   * false if an accrual has already taken place on the cToken before calling\r\n   * this function.\r\n   * @param compute bool A flag to indicate whether the cToken exchange rate\r\n   * needs to be computed - if false, it will simply be read from storage on the\r\n   * cToken in question.\r\n   * @return The dToken and cToken exchange rate, as well as a boolean\r\n   * indicating if interest accrual has been processed already or needs to be\r\n   * calculated and placed in storage.\r\n   */\r\n  function _getExchangeRates(bool compute) private view returns (\r\n    uint256 dTokenExchangeRate, uint256 cTokenExchangeRate, bool fullyAccrued\r\n  ) {\r\n    // Get the stored accrual block and dToken + cToken exhange rates.\r\n    AccrualIndex memory accrualIndex = _accrualIndex;\r\n    uint256 storedDTokenExchangeRate = uint256(accrualIndex.dTokenExchangeRate);\r\n    uint256 storedCTokenExchangeRate = uint256(accrualIndex.cTokenExchangeRate);\r\n    uint256 accrualBlock = uint256(accrualIndex.block);\r\n\r\n    // Use stored exchange rates if an accrual has already occurred this block.\r\n    fullyAccrued = (accrualBlock == block.number);\r\n    if (fullyAccrued) {\r\n      dTokenExchangeRate = storedDTokenExchangeRate;\r\n      cTokenExchangeRate = storedCTokenExchangeRate;\r\n    } else {\r\n      // Only compute cToken exchange rate if it has not accrued this block.\r\n      if (compute) {\r\n        // Get current cToken exchange rate; inheriting contract overrides this.\r\n        (cTokenExchangeRate,) = _getCurrentCTokenRates();\r\n      } else {\r\n        // Otherwise, get the stored cToken exchange rate.\r\n        cTokenExchangeRate = CTokenInterface(_getCToken()).exchangeRateStored();\r\n      }\r\n\r\n      if (exchangeRateFrozen) {\r\n         dTokenExchangeRate = storedDTokenExchangeRate;\r\n      } else {\r\n        // Determine the cToken interest earned during the period.\r\n        uint256 cTokenInterest = (\r\n          (cTokenExchangeRate.mul(_SCALING_FACTOR)).div(storedCTokenExchangeRate)\r\n        ).sub(_SCALING_FACTOR);\r\n    \r\n        // Calculate dToken exchange rate by applying 90% of the cToken interest.\r\n        dTokenExchangeRate = storedDTokenExchangeRate.mul(\r\n          _SCALING_FACTOR.add(cTokenInterest.mul(9) / 10)\r\n        ) / _SCALING_FACTOR;          \r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to get the total surplus, or cToken\r\n   * balance that exceeds the total dToken balance.\r\n   * @return The total surplus, denominated in both the underlying and in the\r\n   * cToken.\r\n   */\r\n  function _getSurplus() private view returns (\r\n    uint256 underlyingSurplus, uint256 cTokenSurplus\r\n  ) {\r\n    if (exchangeRateFrozen) {\r\n        underlyingSurplus = 0;\r\n        cTokenSurplus = 0;\r\n    } else {\r\n      // Instantiate the interface for the backing cToken.\r\n      CTokenInterface cToken = CTokenInterface(_getCToken());\r\n\r\n      (\r\n        uint256 dTokenExchangeRate, uint256 cTokenExchangeRate,\r\n      ) = _getExchangeRates(true);\r\n\r\n      // Determine value of all issued dTokens in the underlying, rounded up.\r\n      uint256 dTokenUnderlying = _toUnderlying(\r\n        _totalSupply, dTokenExchangeRate, true\r\n      );\r\n\r\n      // Determine value of all retained cTokens in the underlying, rounded down.\r\n      uint256 cTokenUnderlying = _toUnderlying(\r\n        cToken.balanceOf(address(this)), cTokenExchangeRate, false\r\n      );\r\n\r\n      // Determine the size of the surplus in terms of underlying amount.\r\n      underlyingSurplus = cTokenUnderlying > dTokenUnderlying\r\n        ? cTokenUnderlying - dTokenUnderlying // overflow checked above\r\n        : 0;\r\n\r\n      // Determine the cToken equivalent of this surplus amount.\r\n      cTokenSurplus = underlyingSurplus == 0\r\n        ? 0\r\n        : _fromUnderlying(underlyingSurplus, cTokenExchangeRate, false);\r\n        \r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to get the current dToken and cToken interest\r\n   * supply rate per block (multiplied by 10^18).\r\n   * @return The current dToken and cToken interest rates.\r\n   */\r\n  function _getRatePerBlock() private view returns (\r\n    uint256 dTokenSupplyRate, uint256 cTokenSupplyRate\r\n  ) {\r\n    (, cTokenSupplyRate) = _getCurrentCTokenRates();\r\n    if (exchangeRateFrozen) {\r\n      dTokenSupplyRate = 0;\r\n    } else {\r\n      dTokenSupplyRate = cTokenSupplyRate.mul(9) / 10;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to determine if a given account has runtime\r\n   * code or not - in other words, whether or not a contract is deployed to the\r\n   * account in question. Note that contracts that are in the process of being\r\n   * deployed will return false on this check.\r\n   * @param account address The account to check for contract runtime code.\r\n   * @return Whether or not there is contract runtime code at the account.\r\n   */\r\n  function _isContract(address account) private view returns (bool isContract) {\r\n    uint256 size;\r\n    assembly { size := extcodesize(account) }\r\n    isContract = size > 0;\r\n  }\r\n\r\n  /**\r\n   * @notice Private pure function to verify that a given signature of a digest\r\n   * resolves to the supplied account. Any error, including incorrect length,\r\n   * malleable signature types, or unsupported `v` values, will cause a revert.\r\n   * @param account address The account to validate against.\r\n   * @param digest bytes32 The digest to use.\r\n   * @param signature bytes The signature to verify.\r\n   */\r\n  function _verifyRecover(\r\n    address account, bytes32 digest, bytes memory signature\r\n  ) private pure {\r\n    // Ensure the signature length is correct.\r\n    require(\r\n      signature.length == 65,\r\n      \"Must supply a single 65-byte signature when owner is not a contract.\"\r\n    );\r\n\r\n    // Divide the signature in r, s and v variables.\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    assembly {\r\n      r := mload(add(signature, 0x20))\r\n      s := mload(add(signature, 0x40))\r\n      v := byte(0, mload(add(signature, 0x60)))\r\n    }\r\n\r\n    require(\r\n      uint256(s) <= _MAX_UNMALLEABLE_S,\r\n      \"Signature `s` value cannot be potentially malleable.\"\r\n    );\r\n\r\n    require(v == 27 || v == 28, \"Signature `v` value not permitted.\");\r\n\r\n    require(account == ecrecover(digest, v, r, s), \"Invalid signature.\");\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaUSDCImplementationV2\r\n * @author 0age (dToken mechanics derived from Compound cTokens, ERC20 methods\r\n * derived from Open Zeppelin's ERC20 contract)\r\n * @notice This contract provides the V2 implementation of Dharma USD Coin (or\r\n * dUSDC), which effectively deprecates Dharma USD Coin.\r\n */\r\ncontract DharmaUSDCImplementationV2 is DharmaTokenV2 {\r\n  string internal constant _NAME = \"Dharma USD Coin\";\r\n  string internal constant _SYMBOL = \"dUSDC\";\r\n  string internal constant _UNDERLYING_NAME = \"USD Coin\";\r\n  string internal constant _CTOKEN_SYMBOL = \"cUSDC\";\r\n\r\n  CTokenInterface internal constant _CUSDC = CTokenInterface(\r\n    0x39AA39c021dfbaE8faC545936693aC917d5E7563 // mainnet\r\n  );\r\n\r\n  ERC20Interface internal constant _USDC = ERC20Interface(\r\n    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 // mainnet\r\n  );\r\n\r\n  address internal constant _VAULT = 0x7e4A8391C728fEd9069B2962699AB416628B19Fa;\r\n\r\n  uint256 internal constant _SCALING_FACTOR_SQUARED = 1e36;\r\n\r\n  /**\r\n   * @notice Internal view function to get the current cUSDC exchange rate and\r\n   * supply rate per block.\r\n   * @return The current cUSDC exchange rate, or amount of USDC that is\r\n   * redeemable for each cUSDC, and the cUSDC supply rate per block (with 18\r\n   * decimal places added to each returned rate).\r\n   */\r\n  function _getCurrentCTokenRates() internal view returns (\r\n    uint256 exchangeRate, uint256 supplyRate\r\n  ) {\r\n    // Determine number of blocks that have elapsed since last cUSDC accrual.\r\n    uint256 blockDelta = block.number.sub(_CUSDC.accrualBlockNumber());\r\n\r\n    // Return stored values if accrual has already been performed this block.\r\n    if (blockDelta == 0) return (\r\n      _CUSDC.exchangeRateStored(), _CUSDC.supplyRatePerBlock()\r\n    );\r\n\r\n    // Determine total \"cash\" held by cUSDC contract.\r\n    uint256 cash = _USDC.balanceOf(address(_CUSDC));\r\n\r\n    // Get the latest interest rate model from the cUSDC contract.\r\n    CUSDCInterestRateModelInterface interestRateModel = (\r\n      CUSDCInterestRateModelInterface(_CUSDC.interestRateModel())\r\n    );\r\n\r\n    // Get the current stored total borrows, reserves, and reserve factor.\r\n    uint256 borrows = _CUSDC.totalBorrows();\r\n    uint256 reserves = _CUSDC.totalReserves();\r\n    uint256 reserveFactor = _CUSDC.reserveFactorMantissa();\r\n\r\n    // Get the current borrow rate from the latest cUSDC interest rate model.\r\n    (uint256 err, uint256 borrowRate) = interestRateModel.getBorrowRate(\r\n      cash, borrows, reserves\r\n    );\r\n    require(\r\n      err == _COMPOUND_SUCCESS, \"Interest Rate Model borrow rate check failed.\"\r\n    );\r\n\r\n    // Get accumulated borrow interest via borrows, borrow rate, & block delta.\r\n    uint256 interest = borrowRate.mul(blockDelta).mul(borrows) / _SCALING_FACTOR;\r\n\r\n    // Update total borrows and reserves using calculated accumulated interest.\r\n    borrows = borrows.add(interest);\r\n    reserves = reserves.add(reserveFactor.mul(interest) / _SCALING_FACTOR);\r\n\r\n    // Get \"underlying\" via (cash + borrows - reserves).\r\n    uint256 underlying = (cash.add(borrows)).sub(reserves);\r\n\r\n    // Determine cUSDC exchange rate via underlying / total supply.\r\n    exchangeRate = (underlying.mul(_SCALING_FACTOR)).div(_CUSDC.totalSupply());\r\n\r\n    // Get \"borrows per\" by dividing total borrows by underlying and scaling up.\r\n    uint256 borrowsPer = (borrows.mul(_SCALING_FACTOR)).div(underlying);\r\n\r\n    // Supply rate is borrow rate * (1 - reserveFactor) * borrowsPer.\r\n    supplyRate = (\r\n      borrowRate.mul(_SCALING_FACTOR.sub(reserveFactor)).mul(borrowsPer)\r\n    ) / _SCALING_FACTOR_SQUARED;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the name of the underlying token.\r\n   * @return The name of the underlying token.\r\n   */\r\n  function _getUnderlyingName() internal pure returns (string memory underlyingName) {\r\n    underlyingName = _UNDERLYING_NAME;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the address of the underlying\r\n   * token.\r\n   * @return The address of the underlying token.\r\n   */\r\n  function _getUnderlying() internal pure returns (address underlying) {\r\n    underlying = address(_USDC);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the symbol of the backing cToken.\r\n   * @return The symbol of the backing cToken.\r\n   */\r\n  function _getCTokenSymbol() internal pure returns (string memory cTokenSymbol) {\r\n    cTokenSymbol = _CTOKEN_SYMBOL;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the address of the backing cToken.\r\n   * @return The address of the backing cToken.\r\n   */\r\n  function _getCToken() internal pure returns (address cToken) {\r\n    cToken = address(_CUSDC);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the name of the dToken.\r\n   * @return The name of the dToken.\r\n   */\r\n  function _getDTokenName() internal pure returns (string memory dTokenName) {\r\n    dTokenName = _NAME;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the symbol of the dToken.\r\n   * @return The symbol of the dToken.\r\n   */\r\n  function _getDTokenSymbol() internal pure returns (string memory dTokenSymbol) {\r\n    dTokenSymbol = _SYMBOL;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function to supply the address of the vault that\r\n   * receives surplus cTokens whenever the surplus is pulled.\r\n   * @return The address of the vault.\r\n   */\r\n  function _getVault() internal pure returns (address vault) {\r\n    vault = _VAULT;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"dTokenName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingToReceive\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlyingToCToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokensBurned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokenTotalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pullSurplus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenSurplus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSurplus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenSurplus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokensToBurn\",\"type\":\"uint256\"}],\"name\":\"redeemToCToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokensReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"increase\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"modifyAllowanceViaMetaTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"dTokenDecimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingEquivalentAmount\",\"type\":\"uint256\"}],\"name\":\"transferUnderlying\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSpreadPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rateSpread\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSurplusUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingSurplus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"arguments\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getMetaTransactionMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingEquivalentAmount\",\"type\":\"uint256\"}],\"name\":\"transferUnderlyingFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingToReceive\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokensBurned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"dTokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUnderlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingToSupply\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokensMinted\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"accrueInterest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokenInterestRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRateCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokenExchangeRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokensToSupply\",\"type\":\"uint256\"}],\"name\":\"mintViaCToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokensMinted\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokensToBurn\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokenAllowance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dTokenTotalSupplyInUnderlying\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintDTokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemDTokens\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dTokenExchangeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cTokenExchangeRate\",\"type\":\"uint256\"}],\"name\":\"Accrue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"surplusAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"surplusCTokens\",\"type\":\"uint256\"}],\"name\":\"CollectSurplus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"DharmaUSDCImplementationV2","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://824b4e83310c26070d7401238ded77c378ff305f2a4d9846be94e8c321d4c4ca"}]}