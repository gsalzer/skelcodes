{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.26;\r\n\r\n\r\ninterface ERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function approveAndCall(address spender, uint tokens, bytes data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function burn(uint256 amount) external;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n    uint256 c = add(a,m);\r\n    uint256 d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n        /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) external;\r\n}\r\n\r\ncontract WishInterface is ERC20{\r\n  function owner() external returns(address);\r\n}\r\n\r\ncontract WishStaking is ApproveAndCallFallBack{\r\n  using SafeMath for uint;\r\n  using SignedSafeMath for int;\r\n  WishInterface public WishToken;\r\n  mapping(address => uint256) public amountStaked;\r\n  mapping(address => int256) public payoutsTo;//only represents the portion of payouts from collective dividends\r\n  mapping(address => uint256) public payoutsToTime;//over time related payouts\r\n  mapping(address => uint256) public unclaimedDividends;//dividends over time before the last user checkpoint\r\n  mapping(address => uint256) public dividendCheckpoints;//the time from which to calculate new dividends\r\n  mapping(address => uint256) public dividendRateUsed;\r\n  uint256 public stakedTotalSum;\r\n  uint256 public divsPerShare;\r\n  uint256 constant internal magnitude = 2 ** 64;\r\n  uint256 constant internal STAKING_MINIMUM = 10 * (10 ** 18); //token is 18 decimals\r\n  uint256 public STAKING_PERIOD = 1 days; //time period to which the dividend rate refers to\r\n  uint256 public BURN_RATE = 50; //5% transaction burns, unstaking burns, div withdraw burns\r\n  uint public STAKE_DIV_FEE = 50; //5% stake div fee\r\n  uint256 public DIVIDEND_RATE = 10;//1.0%\r\n  bool public activated = true;\r\n  uint256 public contractEndTime=0;\r\n\r\n  uint256 public nowTest=now;\r\n\r\n  event Stake(address indexed user, uint256 amount);\r\n\tevent UnStake(address indexed user, uint256 amount);\r\n  event WithdrawDivs(address indexed user, uint256 amount);\r\n  event ReStakeDivs(address indexed user, uint256 amount);\r\n\r\n  modifier isAdmin() {\r\n      require(msg.sender==WishToken.owner(),\"user is not admin\");\r\n      _;\r\n  }\r\n  modifier isActive() {\r\n      require(activated,\"staking is not yet active\");\r\n      _;\r\n  }\r\n\r\n  constructor(address token) public{\r\n    WishToken=WishInterface(token);\r\n  }\r\n  function setRates(uint burn,uint div,uint unstake) public isAdmin{\r\n    BURN_RATE=burn;\r\n    DIVIDEND_RATE=div;\r\n    STAKE_DIV_FEE=unstake;\r\n  }\r\n  function activateContract() public isAdmin{\r\n    activated=true;\r\n  }\r\n  function burnAfterContractEnd() public isAdmin{\r\n    WishToken.burn(WishToken.balanceOf(address(this)));\r\n  }\r\n  function disableDividendAccumulation() public isAdmin{\r\n    contractEndTime=now;\r\n  }\r\n\r\n  /*\r\n    Used for staking, must send an approveAndCall to the token which will then call this function\r\n  */\r\n  function receiveApproval(address fromAddr, uint256 tokens, address token, bytes data) external{\r\n    require(msg.sender==address(WishToken));\r\n    require(WishToken.transferFrom(fromAddr,address(this),tokens),\"transfer failed\");\r\n    _stake(tokens,fromAddr);\r\n  }\r\n  function _stake(uint256 amount,address fromAddr) private isActive{\r\n    require(amountStaked[fromAddr].add(amount) >= STAKING_MINIMUM,\"amount below staking minimum\");\r\n    updateCheckpoint(fromAddr,true);\r\n    stakedTotalSum = stakedTotalSum.add(amount);\r\n    amountStaked[fromAddr] = amountStaked[fromAddr].add(amount);\r\n    payoutsTo[fromAddr] = payoutsTo[fromAddr].add(int256(amount.mul(divsPerShare)));\r\n    emit Stake(fromAddr, amount);\r\n  }\r\n  function unstake(uint256 amount) public isActive{\r\n    require(amountStaked[msg.sender] >= amount);\r\n    updateCheckpoint(msg.sender,true);\r\n\r\n    uint256 divPortion=amount.mul(STAKE_DIV_FEE).div(1000);// dividends to be redistributed to users\r\n    uint256 burnPortion=amount.mul(BURN_RATE).div(1000);// tokens to be burned\r\n    uint256 unstakeFee = divPortion.add(burnPortion);\r\n    divsPerShare = divsPerShare.add(divPortion.mul(magnitude).div(stakedTotalSum)); //portion of fee redistributed as divs, the rest to be burned\r\n    stakedTotalSum = stakedTotalSum.sub(amount);\r\n    uint256 taxedAmount = amount.sub(unstakeFee);\r\n    amountStaked[msg.sender] = amountStaked[msg.sender].sub(amount);\r\n    payoutsTo[msg.sender] = payoutsTo[msg.sender].sub(int256(amount.mul(divsPerShare)));\r\n    WishToken.burn(burnPortion);//burn a portion of the fee\r\n    WishToken.transfer(msg.sender,taxedAmount);\r\n    emit UnStake(msg.sender, amount);\r\n  }\r\n  function withdrawDivs() public isActive{\r\n    updateCheckpoint(msg.sender,false);\r\n    uint256 burnedDivs = getBurnedDivs(msg.sender);\r\n    payoutsTo[msg.sender] = payoutsTo[msg.sender].add(int256(burnedDivs.mul(magnitude)));\r\n    uint256 timeDivs=getTotalDivsOverTime(msg.sender);\r\n    payoutsToTime[msg.sender] = payoutsToTime[msg.sender].add(timeDivs);\r\n    uint256 baseDivs=burnedDivs.add(timeDivs);\r\n\r\n    uint256 burnFee=baseDivs.mul(BURN_RATE).div(1000);\r\n    uint256 divs=baseDivs.sub(burnFee);\r\n\r\n    WishToken.burn(burnFee);\r\n    WishToken.transfer(msg.sender,divs);\r\n    emit WithdrawDivs(msg.sender, divs);\r\n  }\r\n  function reinvestDivs() public isActive{\r\n    updateCheckpoint(msg.sender,false);\r\n    uint256 burnedDivs = getBurnedDivs(msg.sender);\r\n    payoutsTo[msg.sender] = payoutsTo[msg.sender].add(int256(burnedDivs.mul(magnitude)));\r\n    uint256 timeDivs=getTotalDivsOverTime(msg.sender);\r\n    payoutsToTime[msg.sender] = payoutsToTime[msg.sender].add(timeDivs);\r\n    uint256 divs=burnedDivs.add(timeDivs);\r\n    _stake(divs,msg.sender);\r\n    emit ReStakeDivs(msg.sender, divs);\r\n  }\r\n\r\n  function getDividends(address user) public view returns(uint256){\r\n    return getBurnedDivs(user).add(getTotalDivsOverTime(user));\r\n  }\r\n  function getBurnedDivs(address user) public view returns(uint256){\r\n    if(int256(divsPerShare.mul(amountStaked[user])) < payoutsTo[user]){\r\n      return 0;\r\n    }\r\n    else{\r\n      return uint256(int256(divsPerShare.mul(amountStaked[user])).sub(payoutsTo[user])).div(magnitude);\r\n    }\r\n  }\r\n  function updateCheckpoint(address user,bool updateRate) private{\r\n    unclaimedDividends[user]=unclaimedDividends[user].add(getNewDivsOverTime(user));\r\n    dividendCheckpoints[user]=getNow();\r\n    if(updateRate){\r\n      dividendRateUsed[user]=DIVIDEND_RATE;//locks in latest div rate. Done after unclaimedDividends updated, so divs from before this operation will be at the old rate.\r\n    }\r\n  }\r\n  function getTotalDivsSubWithdrawFee(address user) external view returns(uint256){\r\n    uint256 baseDivs=getDividends(user);\r\n    uint256 fee=baseDivs.mul(BURN_RATE).div(1000).add(baseDivs.mul(STAKE_DIV_FEE).div(1000));\r\n    return baseDivs.sub(fee);\r\n  }\r\n  //recent divs over time plus previously recorded divs over time\r\n  function getTotalDivsOverTime(address user) public view returns(uint256){\r\n    return unclaimedDividends[user].add(getNewDivsOverTime(user)).sub(payoutsToTime[user]);\r\n  }\r\n  //Formula for dividends over time is (time_passed/staking_period)*staked_tokens*dividend_rate\r\n  //All divided by 1000 to convert dividend rate to the appropriate units\r\n  function getNewDivsOverTime(address user) public view returns(uint256){\r\n    return getNow().sub(dividendCheckpoints[user]).mul(amountStaked[user]).mul(dividendRateUsed[user]).div(STAKING_PERIOD.mul(1000));\r\n  }\r\n  function getNow() public view returns(uint256){\r\n      //have 'now' be assumed to be the contract end time, if the current time is later than that. This is to prevent accumulation of dividends after this point.\r\n      if(contractEndTime>0 && now>contractEndTime){\r\n        return contractEndTime;\r\n      }\r\n      else{\r\n        return now;\r\n      }\r\n\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"STAKING_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unclaimedDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payoutsTo\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payoutsToTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"dividendRateUsed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"dividendCheckpoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divsPerShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvestDivs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nowTest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTotalDivsSubWithdrawFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNewDivsOverTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromAddr\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDivs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAKE_DIV_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVIDEND_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WishToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTotalDivsOverTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"burn\",\"type\":\"uint256\"},{\"name\":\"div\",\"type\":\"uint256\"},{\"name\":\"unstake\",\"type\":\"uint256\"}],\"name\":\"setRates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakedTotalSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableDividendAccumulation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnAfterContractEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBurnedDivs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BURN_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawDivs\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReStakeDivs\",\"type\":\"event\"}]","ContractName":"WishStaking","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009d9200af83ad0cc3c95ce553a135602ac1aa5919","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5ae2b13367160eabbeb2e0832ac74aad1af5c82a1e5cf0f72519741a3f988bf3"}]}