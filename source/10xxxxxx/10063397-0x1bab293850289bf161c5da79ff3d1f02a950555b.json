{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\ninterface IERC20Metadata {\\n  function name() external view returns (string memory);\\n  function symbol() external view returns (string memory);\\n  function decimals() external view returns (uint8);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExtendedAggregator.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\ninterface IExtendedAggregator {\\n    function getToken() external view returns (address);\\n    function getTokenType() external view returns (uint256);\\n    function getPlatformId() external view returns (uint256);\\n    function getSubTokens() external view returns(address[] memory);\\n    function latestAnswer() external view returns (int256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILatestAnswerGetter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\ninterface ILatestAnswerGetter {\\n  function latestAnswer() external view returns (int256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPriceGetterCpm.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\ninterface IPriceGetterCpm {\\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPriceOracleGetter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\ninterface IPriceOracleGetter {\\n    function getAssetPrice(address _asset) external view returns (uint256);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/EthAddressLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\nlibrary EthAddressLib {\\n\\n    /**\\n    * @dev returns the address used within the protocol to identify ETH\\n    * @return the address assigned to ETH\\n     */\\n    function ethAddress() internal pure returns(address) {\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    }\\n}\"\r\n    },\r\n    \"contracts/misc/MathUtils.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\nlibrary MathUtils {\\n\\n    /**\\n     * @notice Returns the square root of an uint256 x\\n     * - Uses the Babylonian method, but using (x + 1) / 2 as initial guess in order to have decreasing guessing iterations\\n     * which allow to do z < y instead of checking that z*z is within a range of precision respect to x\\n     * @param x The number to calculate the sqrt from\\n     * @return The root\\n     */\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        uint z = (x + 1) / 2;\\n        uint256 y = x;\\n        while (z < y) {\\n            y = z;\\n            z = (x / z + z) / 2;\\n        }\\n        return y;\\n    }\\n}\"\r\n    },\r\n    \"contracts/proxies/CpmPriceProvider.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IExtendedAggregator.sol\\\";\\nimport \\\"../interfaces/ILatestAnswerGetter.sol\\\";\\nimport \\\"../interfaces/IPriceOracleGetter.sol\\\";\\nimport \\\"../interfaces/IERC20Metadata.sol\\\";\\nimport \\\"../interfaces/IPriceGetterCpm.sol\\\";\\nimport \\\"../misc/EthAddressLib.sol\\\";\\nimport \\\"../misc/MathUtils.sol\\\";\\n\\n/** @title CpmPriceProvider\\n * @author Aave\\n * @notice Constant Product Market price provider for a token/ETH pair , represented by a CPM token\\n * - Using an external price source for the token side of the pair and an extra oracle as fallback\\n * - IMPORTANT. It's as assumption that the last calculation on latestAnswer() doesn't overflow because\\n *   the token/ETH balances and prices are validated before creating the corresponding CpmPriceProvider\\n *   for them.\\n */\\ncontract CpmPriceProvider is IExtendedAggregator {\\n    using SafeMath for uint256;\\n    \\n    uint256 public immutable PRICE_DEVIATION; // 10 represents a 1% deviation\\n    IERC20 internal immutable CPM_TOKEN;\\n    IERC20 public immutable TOKEN;\\n    bool public immutable PEGGED_TO_ETH;\\n    ILatestAnswerGetter public immutable TOKEN_PRICE_PROVIDER;\\n    IPriceOracleGetter public immutable FALLBACK_ORACLE;\\n    uint256 public immutable TOKEN_DECIMALS;\\n    uint256 internal immutable CPM_TOKEN_TYPE;\\n    uint256 internal immutable PLATFORM_ID;\\n    address[] internal subTokens;\\n\\n    event Setup(\\n        address indexed creator,\\n        IERC20 indexed cpmToken,\\n        IERC20 indexed token,\\n        bool peggedToEth,\\n        uint256 priceDeviation,\\n        ILatestAnswerGetter tokenPriceProvider,\\n        IPriceOracleGetter fallbackOracle,\\n        uint256 cpmTokenType,\\n        uint256 platformId\\n    );\\n    \\n    constructor(\\n        IERC20 _cpmToken,\\n        IERC20 _token,\\n        bool _peggedToEth,\\n        uint256 _priceDeviation,\\n        ILatestAnswerGetter _tokenPriceProvider,\\n        IPriceOracleGetter _fallbackOracle,\\n        uint256 _cpmTokenType,\\n        uint256 _platformId\\n    ) public {\\n        CPM_TOKEN = _cpmToken;\\n        TOKEN = _token;\\n        PEGGED_TO_ETH = _peggedToEth;\\n        PRICE_DEVIATION = _priceDeviation;\\n        TOKEN_PRICE_PROVIDER = _tokenPriceProvider;\\n        FALLBACK_ORACLE = _fallbackOracle;\\n        TOKEN_DECIMALS = (_peggedToEth) ? 18 : uint256(IERC20Metadata(address(_token)).decimals());\\n        CPM_TOKEN_TYPE = _cpmTokenType;\\n        PLATFORM_ID = _platformId;\\n        subTokens.push(EthAddressLib.ethAddress());\\n        subTokens.push(address(_token));\\n        emit Setup(\\n            msg.sender,\\n            _cpmToken,\\n            _token,\\n            _peggedToEth,\\n            _priceDeviation,\\n            _tokenPriceProvider,\\n            _fallbackOracle,\\n            _cpmTokenType,\\n            _platformId\\n        );\\n    }\\n\\n    /** \\n     * @notice Returns the price in ETH wei of 1 big unit of CPM_TOKEN, taking into account the different ETH prices of the underlyings\\n     * - If a big deviation between the price token -> ETH within the CPM compared with the price in the TOKEN_PRICE_PROVIDER is detected,\\n     * it does the calculations using as ETH and token balances, normalized ones with a price within the CPM close to the external\\n     * @return The price\\n     */\\n    function latestAnswer() external view override returns (int256) {\\n        uint256 _cpmTokenSupply = CPM_TOKEN.totalSupply();\\n        int256 _signedPrice = (PEGGED_TO_ETH) ? 1 ether : TOKEN_PRICE_PROVIDER.latestAnswer();\\n        uint256 _externalPriceOfTokenBigUnitsInWei = (_signedPrice > 0) ? uint256(_signedPrice) : FALLBACK_ORACLE.getAssetPrice(address(TOKEN));\\n        if (_externalPriceOfTokenBigUnitsInWei == 0) {\\n            return 0;\\n        }\\n        uint256 _cpmPriceOfTokenBigUnitsInWei = IPriceGetterCpm(address(CPM_TOKEN)).getTokenToEthInputPrice(10**TOKEN_DECIMALS);\\n\\n        uint256 _normalizedEthBalanceInWei = address(CPM_TOKEN).balance;\\n        uint256 _normalizedTokenBalanceInDecimalUnits = TOKEN.balanceOf(address(CPM_TOKEN));\\n        uint256 _priceDeviation = _cpmPriceOfTokenBigUnitsInWei.mul(1000).div(_externalPriceOfTokenBigUnitsInWei);\\n        \\n        // Case of high deviation. \\n        // Both sub-cases of token overpriced (> 1010) and ETH overpriced (> 990) can be calculated with common logic, based on the K property of the CPM\\n        if (_priceDeviation > (1000 + PRICE_DEVIATION) || _priceDeviation < (1000 - PRICE_DEVIATION)) {\\n            uint256 _K = _normalizedEthBalanceInWei.mul(_normalizedTokenBalanceInDecimalUnits);\\n            // The 10**TOKEN_DECIMALS is needed to not lose the magnitude of the token decimals\\n            _normalizedTokenBalanceInDecimalUnits = MathUtils.sqrt(_K.div(_externalPriceOfTokenBigUnitsInWei).mul(10**TOKEN_DECIMALS));\\n            _normalizedEthBalanceInWei = _K.div(_normalizedTokenBalanceInDecimalUnits);\\n        }\\n\\n        return int256(\\n            (_normalizedEthBalanceInWei  + _normalizedTokenBalanceInDecimalUnits.mul(_externalPriceOfTokenBigUnitsInWei).div(10**TOKEN_DECIMALS))\\n                .mul(1 ether)\\n                .div(_cpmTokenSupply)\\n            );\\n    }\\n\\n    /** \\n     * @notice Return the address of the CPM token\\n     * @return address\\n     */\\n    function getToken() external view override returns(address) {\\n        return address(CPM_TOKEN);\\n    }\\n\\n    /** \\n     * @notice Return the list of tokens' addresses composing the CPM token\\n     * - Using EthAddressLib.ethAddress() as mock address for ETH.\\n     * - The reference token is first on the list\\n     * @return addresses\\n     */\\n    function getSubTokens() external view override returns(address[] memory) {\\n        return subTokens;\\n    }\\n\\n    /** \\n     * @notice Return the numeric type of the CPM token\\n     * @return type\\n     */\\n    function getTokenType() external view override returns(uint256) {\\n        return CPM_TOKEN_TYPE;\\n    }\\n\\n    /** \\n     * @notice Return the numeric platform id\\n     * @return platform id\\n     */\\n    function getPlatformId() external view override returns (uint256) {\\n        return PLATFORM_ID;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"istanbul\"\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_cpmToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_peggedToEth\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_priceDeviation\",\"type\":\"uint256\"},{\"internalType\":\"contract ILatestAnswerGetter\",\"name\":\"_tokenPriceProvider\",\"type\":\"address\"},{\"internalType\":\"contract IPriceOracleGetter\",\"name\":\"_fallbackOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cpmTokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_platformId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"cpmToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"peggedToEth\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceDeviation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract ILatestAnswerGetter\",\"name\":\"tokenPriceProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IPriceOracleGetter\",\"name\":\"fallbackOracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cpmTokenType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"platformId\",\"type\":\"uint256\"}],\"name\":\"Setup\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FALLBACK_ORACLE\",\"outputs\":[{\"internalType\":\"contract IPriceOracleGetter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PEGGED_TO_ETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_DEVIATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_PRICE_PROVIDER\",\"outputs\":[{\"internalType\":\"contract ILatestAnswerGetter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSubTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CpmPriceProvider","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002a1530c4c41db0b0b2bb646cb5eb1a67b71586670000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000037e8f2125bf532f3e228991e051c8a7253b642c000000000000000000000000d6d88f2eba3d9a27b24bf77932fdeb547b93df5800000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"istanbul","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://29ef4a0b58a07b7431c7af9d3fc261b5374972ed8d8134b64b51af5b5ddbc8d3"}]}