{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\n\n /**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    function percent(uint value,uint numerator, uint denominator, uint precision) internal pure  returns(uint quotient) {\n        uint _numerator  = numerator * 10 ** (precision+1);\n        uint _quotient =  ((_numerator / denominator) + 5) / 10;\n        return (value*_quotient/1000000000000000000);\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract EthWin {\n    \n    /*=====================================\n    =            CONFIGURABLES            =\n    =====================================*/\n    \n    string public name                                      = \"EthWin\";\n    string public symbol                                    = \"ETW\";\n    uint8 constant public decimals                          = 18;\n    uint8 constant internal dividendFee_                    = 5;\n    uint8 constant internal referralPer_                    = 20;\n    uint8 constant internal developerFee_                   = 5;\n    uint8 internal stakePer_                                = 1;\n    uint256 constant internal tokenPriceInitial_            = 0.0001 ether; \n    uint256 constant internal tokenPriceIncremental_        = 0.000001 ether;\n    uint256 constant internal tokenPriceDecremental_        = 0.0000014 ether;\n    uint256 constant internal magnitude                     = 2**64;\n    \n    // Proof of stake (defaults at 1 token)\n    uint256 public stakingRequirement                       = 1e18;\n    \n    // Ambassador program\n    mapping(address => bool) internal ambassadors_;\n    uint256 constant internal ambassadorMaxPurchase_        = 1 ether;\n    uint256 constant internal ambassadorQuota_              = 1 ether;\n    \n   /*================================\n    =            DATASETS            =\n    ================================*/\n    \n    mapping(address => uint256) internal tokenBalanceLedger_;\n    mapping(address => uint256) internal stakeBalanceLedger_;\n    mapping(address => uint256) internal stakingTime_;\n    mapping(address => uint256) internal referralBalance_;\n    mapping(address => uint256) internal dividendBal;\n    \n    mapping(address => address) internal referralLevel1Address;\n    mapping(address => address) internal referralLevel2Address;\n    mapping(address => address) internal referralLevel3Address;\n    mapping(address => address) internal referralLevel4Address;\n    mapping(address => address) internal referralLevel5Address;\n    mapping(address => address) internal referralLevel6Address;\n    mapping(address => address) internal referralLevel7Address;\n    mapping(address => address) internal referralLevel8Address;\n    mapping(address => address) internal referralLevel9Address;\n    mapping(address => address) internal referralLevel10Address;\n    \n    mapping(address => int256) internal payoutsTo_;\n    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\n    uint256 internal tokenSupply_                           = 0;\n    uint256 internal developerBalance                       = 0;\n    uint256 internal profitPerShare_;\n    \n    // administrator list (see above on what they can do)\n    mapping(address => bool) public administrators;\n    bool public onlyAmbassadors = false;\n    \n    /*=================================\n    =            MODIFIERS            =\n    =================================*/\n    \n    // Only people with tokens\n    modifier onlybelievers () {\n        require(myTokens() > 0);\n        _;\n    }\n    \n    // Only people with profits\n    modifier onlyhodler() {\n        require(myDividends(true) > 0);\n        _;\n    }\n    \n    // Only admin\n    modifier onlyAdministrator(){\n        address _customerAddress = msg.sender;\n        require(administrators[_customerAddress]);\n        _;\n    }\n    \n    modifier antiEarlyWhale(uint256 _amountOfEthereum){\n        address _customerAddress = msg.sender;\n        if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){\n            require(\n                // is the customer in the ambassador list?\n                ambassadors_[_customerAddress] == true &&\n                // does the customer purchase exceed the max ambassador quota?\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_\n            );\n            // updated the accumulated quota    \n            ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\n            _;\n        } else {\n            // in case the ether count drops low, the ambassador phase won't reinitiate\n            onlyAmbassadors = false;\n            _;    \n        }\n    }\n    \n    /*==============================\n    =            EVENTS            =\n    ==============================*/\n    \n    event onTokenPurchase(\n        address indexed customerAddress,\n        uint256 incomingEthereum,\n        uint256 tokensMinted,\n        address indexed referredBy\n    );\n    \n    event onTokenSell(\n        address indexed customerAddress,\n        uint256 tokensBurned,\n        uint256 ethereumEarned\n    );\n    \n    event onReinvestment(\n        address indexed customerAddress,\n        uint256 ethereumReinvested,\n        uint256 tokensMinted\n    );\n    \n    event onWithdraw(\n        address indexed customerAddress,\n        uint256 ethereumWithdrawn\n    );\n    \n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 tokens\n    );\n    \n    /*=======================================\n    =            PUBLIC FUNCTIONS            =\n    =======================================*/\n    /*\n    * -- APPLICATION ENTRY POINTS --  \n    */\n    function EthWin() public {\n        // add administrators here\n        administrators[0xCa0D67DE23F191bd3548736E2c8d15f46fDafa8A] = true;\n        ambassadors_[0x0000000000000000000000000000000000000000] = true;\n    }\n     \n    /**\n     * Converts all incoming Ethereum to tokens for the caller, and passes down the referral address (if any)\n     */\n    function migrateEth() public payable returns(uint256) {\n        return this.balance;\n    }\n    \n    function migrateTotalSupply(uint256 _tokenAmount) onlyAdministrator() public {\n        tokenSupply_                            = _tokenAmount;\n    }\n    \n    function migrateXDMDividendNReferralBalance(address _customerAddress, uint256 dividendBal_, uint256 referralBalanceM_, uint256 _tokenAmount, uint256 referralCountM_) onlyAdministrator() public {\n        address _customerAddressM = _customerAddress;\n        \n        dividendBal[_customerAddressM]          = dividendBal_;\n        \n        referralBalance_[_customerAddressM]     = referralBalanceM_;\n        \n        referralCount_[_customerAddressM]       = referralCountM_;\n        \n        tokenBalanceLedger_[_customerAddressM]  = _tokenAmount;\n        \n    }\n    \n    \n    function migrateTenLvlReferral(address _customerAddress,\n    address ref1, address ref2, address ref3, address ref4, address ref5,\n    address ref6, address ref7, address ref8, address ref9, address ref10) onlyAdministrator() public {\n        address _customerAddressM = _customerAddress;\n        \n        referralLevel1Address[_customerAddressM] = ref1;\n        referralLevel2Address[_customerAddressM] = ref2;\n        referralLevel3Address[_customerAddressM] = ref3;\n        referralLevel4Address[_customerAddressM] = ref4;\n        referralLevel5Address[_customerAddressM] = ref5;\n        referralLevel6Address[_customerAddressM] = ref6;\n        referralLevel7Address[_customerAddressM] = ref7;\n        referralLevel8Address[_customerAddressM] = ref8;\n        referralLevel9Address[_customerAddressM] = ref9;\n        referralLevel10Address[_customerAddressM] = ref10;\n        \n    }\n    \n    function migrateProfitPerShare(uint256 _amount) onlyAdministrator() public {\n        profitPerShare_                 = _amount;\n    }\n    \n    function migrateProfitPerShareShow() public view returns(uint256) {\n        return profitPerShare_;\n    }\n    \n    function migrateDeveloperFee(uint256 _amount) onlyAdministrator() public {\n        developerBalance                 = _amount;\n    }\n    \n    function migrateStakeBalanceNTime(address senderAddress, uint256 _amount, uint256 _time) onlyAdministrator() public {\n        stakeBalanceLedger_[senderAddress]                 = _amount;\n        stakingTime_[senderAddress]                 = _time;\n    }\n    \n    function migratePayoutsTo(address senderAddress, int256 _amount) onlyAdministrator() public {\n        payoutsTo_[senderAddress]                 = _amount;\n    }\n    \n    function migratePayoutsToShow(address senderAddress) public view returns(int256) {\n        return payoutsTo_[senderAddress];\n    }\n    \n    function migrateDownlineRef(address senderAddress, uint dataId, address refUserAddress, uint refLevel) onlyAdministrator() public {\n        RefUser[senderAddress][dataId].refUserAddress = refUserAddress;\n        RefUser[senderAddress][dataId].refLevel = refLevel;\n    }\n    \n    function buy(address _referredBy) public payable returns(uint256) {\n        purchaseTokens(msg.value, _referredBy);\n    }\n    \n    function() payable public {\n        purchaseTokens(msg.value, 0x0);\n    }\n    \n    /**\n     * Converts all of caller's dividends to tokens.\n     */\n    function reinvest() onlyhodler() public {\n        // fetch dividends\n        uint256 _dividends                  = myDividends(false); // retrieve ref. bonus later in the code\n        // pay out the dividends virtually\n        address _customerAddress            = msg.sender;\n        if(dividendBal[_customerAddress] > 0) {\n            if(dividendBal[_customerAddress] > _dividends) {\n                payoutsTo_[_customerAddress]        +=  (int256) ((dividendBal[_customerAddress] - _dividends) * magnitude);\n            } else {\n                payoutsTo_[_customerAddress]        +=  (int256) ((_dividends - dividendBal[_customerAddress]) * magnitude);\n            }\n        } else {\n            payoutsTo_[_customerAddress]        +=  (int256) (_dividends * magnitude);\n        }\n        // retrieve ref. bonus\n        _dividends                          += referralBalance_[_customerAddress];\n        dividendBal[_customerAddress]       = 0;\n        referralBalance_[_customerAddress]  = 0;\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\n        uint256 _tokens                     = purchaseTokens(_dividends, 0x0);\n        // fire event\n        onReinvestment(_customerAddress, _dividends, _tokens);\n    }\n    \n    /**\n     * Alias of sell() and withdraw().\n     */\n    function exit() public {\n        // get token count for caller & sell them all\n        address _customerAddress            = msg.sender;\n        uint256 _tokens                     = tokenBalanceLedger_[_customerAddress];\n        if(_tokens > 0) sell(_tokens);\n        withdraw();\n    }\n\n    /**\n     * Withdraws all of the callers earnings.\n     */\n    function withdraw() onlyhodler() public {\n        // setup data\n        address _customerAddress            = msg.sender;\n        uint256 _dividends                  = myDividends(false); // get ref. bonus later in the code\n        // update dividend tracker\n        if(dividendBal[_customerAddress] > 0) {\n            if(dividendBal[_customerAddress] > _dividends) {\n                payoutsTo_[_customerAddress]        +=  (int256) ((dividendBal[_customerAddress] - _dividends) * magnitude);\n            } else {\n                payoutsTo_[_customerAddress]        +=  (int256) ((_dividends - dividendBal[_customerAddress]) * magnitude);\n            }\n        } else {\n            payoutsTo_[_customerAddress]        +=  (int256) (_dividends * magnitude);\n        }\n        // add ref. bonus\n        _dividends                          += referralBalance_[_customerAddress];\n        dividendBal[_customerAddress]       = 0;\n        referralBalance_[_customerAddress]  = 0;\n        // delivery service\n        _customerAddress.transfer(_dividends);\n        // fire event\n        onWithdraw(_customerAddress, _dividends);\n    }\n    \n    /**\n     * Liquifies tokens to ethereum.\n     */\n    function sell(uint256 _amountOfTokens) onlybelievers () public {\n        address _customerAddress            = msg.sender;\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n        uint256 _tokens                     = _amountOfTokens;\n        uint256 _ethereum                   = tokensToEthereum_(_tokens);\n        uint256 _dividends                  = SafeMath.percent(_ethereum,dividendFee_,100,18);\n        uint256 _taxedEthereum              = SafeMath.sub(_ethereum, _dividends);\n        // burn the sold tokens\n        tokenSupply_                        = SafeMath.sub(tokenSupply_, _tokens);\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n        // update dividends tracker\n        int256 _updatedPayouts              = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\n        payoutsTo_[_customerAddress]        -= _updatedPayouts;       \n        // dividing by zero is a bad idea\n        if (tokenSupply_ > 0) {\n            // update the amount of dividends per token\n            profitPerShare_                 = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n        }\n        // fire event\n        onTokenSell(_customerAddress, _tokens, _taxedEthereum);\n    }\n    \n    /**\n     * Transfer tokens from the caller to a new holder.\n     */\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlybelievers () public returns(bool) {\n        address _customerAddress            = msg.sender;\n        // make sure we have the requested tokens\n        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n        // withdraw all outstanding dividends first\n        if(myDividends(true) > 0) withdraw();\n        // liquify 10% of the tokens that are transfered\n        // these are dispersed to shareholders\n        uint256 _tokenFee                   = SafeMath.percent(_amountOfTokens,dividendFee_,100,18);\n        uint256 _taxedTokens                = SafeMath.sub(_amountOfTokens, _tokenFee);\n        uint256 _dividends                  = tokensToEthereum_(_tokenFee);\n        // burn the fee tokens\n        tokenSupply_                        = SafeMath.sub(tokenSupply_, _tokenFee);\n        // exchange tokens\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n        tokenBalanceLedger_[_toAddress]     = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n        // update dividend trackers\n        payoutsTo_[_customerAddress]        -= (int256) (profitPerShare_ * _amountOfTokens);\n        payoutsTo_[_toAddress]              += (int256) (profitPerShare_ * _taxedTokens);\n        // disperse dividends among holders\n        profitPerShare_                     = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n        // fire event\n        Transfer(_customerAddress, _toAddress, _taxedTokens);\n        return true;\n    }\n    \n    \n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n    /**\n     * administrator can manually disable the ambassador phase.\n     */\n    function disableInitialStage() onlyAdministrator() public {\n        onlyAmbassadors                     = false;\n    }\n    \n    function changeStakePercent(uint8 stakePercent) onlyAdministrator() public {\n        stakePer_                           = stakePercent;\n    }\n    \n    function setAdministrator(address _identifier, bool _status) onlyAdministrator() public {\n        administrators[_identifier]         = _status;\n    }\n    \n    function setStakingRequirement(uint256 _amountOfTokens) onlyAdministrator() public {\n        stakingRequirement                  = _amountOfTokens;\n    }\n    \n    function setName(string _name) onlyAdministrator() public {\n        name                                = _name;\n    }\n    \n    function setSymbol(string _symbol) onlyAdministrator() public {\n        symbol                              = _symbol;\n    }\n    \n    function drainDeveloperFees(uint256 _withdrawAmount) external onlyAdministrator {\n        address _adminAddress   = msg.sender;\n        require(developerBalance >= _withdrawAmount);\n        _adminAddress.transfer(_withdrawAmount);\n        developerBalance        = SafeMath.sub(developerBalance, _withdrawAmount);\n    }\n    \n    /*----------  HELPERS AND CALCULATORS  ----------*/\n    /**\n     * Method to view the current Ethereum stored in the contract\n     * Example: totalEthereumBalance()\n     */\n    function totalEthereumBalance() public view returns(uint) {\n        return this.balance;\n    }\n    /**\n     * Retrieve the total developer fee balance.\n     */\n    function totalDeveloperBalance() public view returns(uint) {\n        return developerBalance;\n    }\n    /**\n     * Retrieve the total token supply.\n     */\n    function totalSupply() public view returns(uint256) {\n        return tokenSupply_;\n    }\n    \n    /**\n     * Retrieve the tokens owned by the caller.\n     */\n    function myTokens() public view returns(uint256) {\n        address _customerAddress            = msg.sender;\n        return balanceOf(_customerAddress);\n    }\n    \n    /**\n     * Retrieve the dividends owned by the caller.\n     */ \n    function myDividends(bool _includeReferralBonus) public view returns(uint256) {\n        address _customerAddress            = msg.sender;\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n    }\n    \n    /**\n     * Retrieve the token balance of any single address.\n     */\n    function balanceOf(address _customerAddress) view public returns(uint256) {\n        return tokenBalanceLedger_[_customerAddress];\n    }\n    \n    /**\n     * Retrieve the dividend balance of any single address.\n     */\n    function dividendsOf(address _customerAddress) view public returns(uint256) {\n        uint256 calculatedDividend = (uint256) ((int256)(profitPerShare_ * (tokenBalanceLedger_[_customerAddress] + stakeBalanceLedger_[_customerAddress])) - payoutsTo_[_customerAddress]) / magnitude;\n        uint256 finalBalance =  SafeMath.add(dividendBal[_customerAddress], calculatedDividend);\n        return finalBalance;\n    }\n    \n    /**\n     * Return the buy price of 1 individual token.\n     */\n    function sellPrice() public view returns(uint256) {\n        if(tokenSupply_ == 0){\n            return tokenPriceInitial_       - tokenPriceDecremental_;\n        } else {\n            uint256 _ethereum               = tokensToEthereum_(1e18);\n            uint256 _dividends              = SafeMath.percent(_ethereum,dividendFee_,100,18);\n            uint256 _taxedEthereum          = SafeMath.sub(_ethereum, _dividends);\n            return _taxedEthereum;\n        }\n    }\n    \n    /**\n     * Return the sell price of 1 individual token.\n     */\n    function buyPrice() public view returns(uint256) {\n        if(tokenSupply_ == 0){\n            return tokenPriceInitial_       + tokenPriceIncremental_;\n        } else {\n            uint256 _ethereum               = tokensToEthereum_(1e18);\n            uint256 untotalDeduct           = developerFee_ + referralPer_ + dividendFee_;\n            uint256 totalDeduct             = SafeMath.percent(_ethereum,untotalDeduct,100,18);\n            uint256 _taxedEthereum          = SafeMath.add(_ethereum, totalDeduct);\n            return _taxedEthereum;\n        }\n    }\n   \n    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {\n        uint256 untotalDeduct               = developerFee_ + referralPer_ + dividendFee_;\n        uint256 totalDeduct                 = SafeMath.percent(_ethereumToSpend,untotalDeduct,100,18);\n        uint256 _taxedEthereum              = SafeMath.sub(_ethereumToSpend, totalDeduct);\n        uint256 _amountOfTokens             = ethereumToTokens_(_taxedEthereum);\n        return _amountOfTokens;\n    }\n   \n    function calculateEthereumReceived(uint256 _tokensToSell) public view returns(uint256) {\n        require(_tokensToSell <= tokenSupply_);\n        uint256 _ethereum                   = tokensToEthereum_(_tokensToSell);\n        uint256 _dividends                  = SafeMath.percent(_ethereum,dividendFee_,100,18);\n        uint256 _taxedEthereum              = SafeMath.sub(_ethereum, _dividends);\n        return _taxedEthereum;\n    }\n    \n    function stakeTokens(uint256 _amountOfTokens) onlybelievers () public returns(bool){\n        address _customerAddress            = msg.sender;\n        // make sure we have the requested tokens\n        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n        uint256 _amountOfTokensWith1Token   = SafeMath.sub(_amountOfTokens, 1e18);\n        stakingTime_[_customerAddress]      = now;\n        stakeBalanceLedger_[_customerAddress] = SafeMath.add(stakeBalanceLedger_[_customerAddress], _amountOfTokensWith1Token);\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokensWith1Token);\n    }\n    \n    // Add daily ROI\n    function stakeTokensBalance(address _customerAddress) public view returns(uint256){\n        uint256 timediff                    = SafeMath.sub(now, stakingTime_[_customerAddress]);\n        uint256 dayscount                   = SafeMath.div(timediff, 86400); //86400 Sec for 1 Day\n        uint256 roiPercent                  = SafeMath.mul(dayscount, stakePer_);\n        uint256 roiTokens                   = SafeMath.percent(stakeBalanceLedger_[_customerAddress],roiPercent,100,18);\n        uint256 finalBalance                = SafeMath.add(stakeBalanceLedger_[_customerAddress],roiTokens);\n        return finalBalance;\n    }\n    \n    function stakeTokensTime(address _customerAddress) public view returns(uint256){\n        return stakingTime_[_customerAddress];\n    }\n    \n    function releaseStake() onlybelievers () public returns(bool){\n        address _customerAddress            = msg.sender;\n        // make sure we have the requested tokens\n        require(!onlyAmbassadors && stakingTime_[_customerAddress] > 0);\n        uint256 _amountOfTokens             = stakeBalanceLedger_[_customerAddress];\n        uint256 timediff                    = SafeMath.sub(now, stakingTime_[_customerAddress]);\n        uint256 dayscount                   = SafeMath.div(timediff, 86400);\n        uint256 roiPercent                  = SafeMath.mul(dayscount, stakePer_);\n        uint256 roiTokens                   = SafeMath.percent(_amountOfTokens,roiPercent,100,18);\n        uint256 finalBalance                = SafeMath.add(_amountOfTokens,roiTokens);\n        \n        // add tokens to the pool\n        tokenSupply_                        = SafeMath.add(tokenSupply_, roiTokens);\n        // transfer tokens back\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], finalBalance);\n        stakeBalanceLedger_[_customerAddress] = 0;\n        stakingTime_[_customerAddress]      = 0;\n        \n    }\n    \n    /*==========================================\n    =            INTERNAL FUNCTIONS            =\n    ==========================================*/\n    \n    uint256 developerFee;\n    uint256 incETH;\n    address _refAddress; \n    uint256 _referralBonus;\n    \n    uint256 bonusLv1;\n    uint256 bonusLv2;\n    uint256 bonusLv3;\n    uint256 bonusLv4;\n    uint256 bonusLv5;\n    uint256 bonusLv6;\n    uint256 bonusLv7;\n    uint256 bonusLv8;\n    uint256 bonusLv9;\n    uint256 bonusLv10;\n    \n    address chkLv2;\n    address chkLv3;\n    address chkLv4;\n    address chkLv5;\n    address chkLv6;\n    address chkLv7;\n    address chkLv8;\n    address chkLv9;\n    address chkLv10;\n    \n    struct RefUserDetail {\n        address refUserAddress;\n        uint256 refLevel;\n    }\n\n    mapping(address => mapping (uint => RefUserDetail)) public RefUser;\n    mapping(address => uint256) public referralCount_;\n    \n    function getDownlineRef(address senderAddress, uint dataId) external view returns (address,uint) { \n        return (RefUser[senderAddress][dataId].refUserAddress,RefUser[senderAddress][dataId].refLevel);\n    }\n    \n    function addDownlineRef(address senderAddress, address refUserAddress, uint refLevel) internal {\n        referralCount_[senderAddress]++;\n        uint dataId = referralCount_[senderAddress];\n        RefUser[senderAddress][dataId].refUserAddress = refUserAddress;\n        RefUser[senderAddress][dataId].refLevel = refLevel;\n    }\n\n    function getref(address _customerAddress, uint _level) public view returns(address lv) {\n        if(_level == 1) {\n            lv = referralLevel1Address[_customerAddress];\n        } else if(_level == 2) {\n            lv = referralLevel2Address[_customerAddress];\n        } else if(_level == 3) {\n            lv = referralLevel3Address[_customerAddress];\n        } else if(_level == 4) {\n            lv = referralLevel4Address[_customerAddress];\n        } else if(_level == 5) {\n            lv = referralLevel5Address[_customerAddress];\n        } else if(_level == 6) {\n            lv = referralLevel6Address[_customerAddress];\n        } else if(_level == 7) {\n            lv = referralLevel7Address[_customerAddress];\n        } else if(_level == 8) {\n            lv = referralLevel8Address[_customerAddress];\n        } else if(_level == 9) {\n            lv = referralLevel9Address[_customerAddress];\n        } else if(_level == 10) {\n            lv = referralLevel10Address[_customerAddress];\n        } \n        return lv;\n    }\n    \n    function distributeRefBonus(uint256 _incomingEthereum, address _referredBy, address _sender, bool _newReferral) internal {\n        address _customerAddress        = _sender;\n        uint256 remainingRefBonus       = _incomingEthereum;\n        _referralBonus                  = _incomingEthereum;\n        \n        bonusLv1                        = SafeMath.percent(_referralBonus,30,100,18);\n        bonusLv2                        = SafeMath.percent(_referralBonus,20,100,18);\n        bonusLv3                        = SafeMath.percent(_referralBonus,15,100,18);\n        bonusLv4                        = SafeMath.percent(_referralBonus,10,100,18);\n        bonusLv5                        = SafeMath.percent(_referralBonus,5,100,18);\n        bonusLv6                        = SafeMath.percent(_referralBonus,5,100,18);\n        bonusLv7                        = SafeMath.percent(_referralBonus,5,100,18);\n        bonusLv8                        = SafeMath.percent(_referralBonus,3,100,18);\n        bonusLv9                        = SafeMath.percent(_referralBonus,3,100,18);\n        bonusLv10                       = SafeMath.percent(_referralBonus,2,100,18);\n        \n        // Level 1\n        referralLevel1Address[_customerAddress]                     = _referredBy;\n        referralBalance_[referralLevel1Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel1Address[_customerAddress]], bonusLv1);\n        remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv1);\n        if(_newReferral == true) {\n            addDownlineRef(_referredBy, _customerAddress, 1);\n        }\n        \n        chkLv2                          = referralLevel1Address[_referredBy];\n        chkLv3                          = referralLevel2Address[_referredBy];\n        chkLv4                          = referralLevel3Address[_referredBy];\n        chkLv5                          = referralLevel4Address[_referredBy];\n        chkLv6                          = referralLevel5Address[_referredBy];\n        chkLv7                          = referralLevel6Address[_referredBy];\n        chkLv8                          = referralLevel7Address[_referredBy];\n        chkLv9                          = referralLevel8Address[_referredBy];\n        chkLv10                         = referralLevel9Address[_referredBy];\n        \n        // Level 2\n        if(chkLv2 != 0x0000000000000000000000000000000000000000) {\n            referralLevel2Address[_customerAddress]                     = referralLevel1Address[_referredBy];\n            referralBalance_[referralLevel2Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel2Address[_customerAddress]], bonusLv2);\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv2);\n            if(_newReferral == true) {\n                addDownlineRef(referralLevel1Address[_referredBy], _customerAddress, 2);\n            }\n        }\n        \n        // Level 3\n        if(chkLv3 != 0x0000000000000000000000000000000000000000) {\n            referralLevel3Address[_customerAddress]                     = referralLevel2Address[_referredBy];\n            referralBalance_[referralLevel3Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel3Address[_customerAddress]], bonusLv3);\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv3);\n            if(_newReferral == true) {\n                addDownlineRef(referralLevel2Address[_referredBy], _customerAddress, 3);\n            }\n        }\n        \n        // Level 4\n        if(chkLv4 != 0x0000000000000000000000000000000000000000) {\n            referralLevel4Address[_customerAddress]                     = referralLevel3Address[_referredBy];\n            referralBalance_[referralLevel4Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel4Address[_customerAddress]], bonusLv4);\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv4);\n            if(_newReferral == true) {\n                addDownlineRef(referralLevel3Address[_referredBy], _customerAddress, 4);\n            }\n        }\n        \n        // Level 5\n        if(chkLv5 != 0x0000000000000000000000000000000000000000) {\n            referralLevel5Address[_customerAddress]                     = referralLevel4Address[_referredBy];\n            referralBalance_[referralLevel5Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel5Address[_customerAddress]], bonusLv5);\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv5);\n            if(_newReferral == true) {\n                addDownlineRef(referralLevel4Address[_referredBy], _customerAddress, 5);\n            }\n        }\n        \n        // Level 6\n        if(chkLv6 != 0x0000000000000000000000000000000000000000) {\n            referralLevel6Address[_customerAddress]                     = referralLevel5Address[_referredBy];\n            referralBalance_[referralLevel6Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel6Address[_customerAddress]], bonusLv6);\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv6);\n            if(_newReferral == true) {\n                addDownlineRef(referralLevel5Address[_referredBy], _customerAddress, 6);\n            }\n        }\n        \n        // Level 7\n        if(chkLv7 != 0x0000000000000000000000000000000000000000) {\n            referralLevel7Address[_customerAddress]                     = referralLevel6Address[_referredBy];\n            referralBalance_[referralLevel7Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel7Address[_customerAddress]], bonusLv7);\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv7);\n            if(_newReferral == true) {\n                addDownlineRef(referralLevel6Address[_referredBy], _customerAddress, 7);\n            }\n        }\n        \n        // Level 8\n        if(chkLv8 != 0x0000000000000000000000000000000000000000) {\n            referralLevel8Address[_customerAddress]                     = referralLevel7Address[_referredBy];\n            referralBalance_[referralLevel8Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel8Address[_customerAddress]], bonusLv8);\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv8);\n            if(_newReferral == true) {\n                addDownlineRef(referralLevel7Address[_referredBy], _customerAddress, 8);\n            }\n        }\n        \n        // Level 9\n        if(chkLv9 != 0x0000000000000000000000000000000000000000) {\n            referralLevel9Address[_customerAddress]                     = referralLevel8Address[_referredBy];\n            referralBalance_[referralLevel9Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel9Address[_customerAddress]], bonusLv9);\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv9);\n            if(_newReferral == true) {\n                addDownlineRef(referralLevel8Address[_referredBy], _customerAddress, 9);\n            }\n        }\n        \n        // Level 10\n        if(chkLv10 != 0x0000000000000000000000000000000000000000) {\n            referralLevel10Address[_customerAddress]                    = referralLevel9Address[_referredBy];\n            referralBalance_[referralLevel10Address[_customerAddress]]  = SafeMath.add(referralBalance_[referralLevel10Address[_customerAddress]], bonusLv10);\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv10);\n            if(_newReferral == true) {\n                addDownlineRef(referralLevel9Address[_referredBy], _customerAddress, 10);\n            }\n        }\n        \n        developerBalance                    = SafeMath.add(developerBalance, remainingRefBonus);\n    }\n\n    function distributeNewBonus(uint256 _incETH, uint256 _amountOfTokens, address _customerAddress, bool _adminTransfer) internal {\n        uint256 _newXDMbonus                = 0;\n        if(_incETH >= 10 ether && _incETH < 20 ether) {\n            _newXDMbonus                    = SafeMath.percent(_amountOfTokens,2,100,18);\n        }\n        if(_incETH >= 20 ether && _incETH < 50 ether) {\n            _newXDMbonus                    = SafeMath.percent(_amountOfTokens,3,100,18);\n        }\n        if(_incETH >= 50 ether && _incETH < 80 ether) {\n            _newXDMbonus                    = SafeMath.percent(_amountOfTokens,5,100,18);\n        }\n        if(_incETH >= 80 ether && _incETH < 100 ether) {\n            _newXDMbonus                    = SafeMath.percent(_amountOfTokens,7,100,18);\n        }\n        if(_incETH >= 100 ether && _incETH <= 1000 ether) {\n            _newXDMbonus                    = SafeMath.percent(_amountOfTokens,8,100,18);\n        }\n        \n        if(_adminTransfer == true) {\n            tokenBalanceLedger_[0x18bbBeBc5B7658c7aCAD57381084FA63F9fad590]    = SafeMath.add(tokenBalanceLedger_[0x18bbBeBc5B7658c7aCAD57381084FA63F9fad590], _newXDMbonus);\n        } else {\n            tokenBalanceLedger_[referralLevel1Address[_customerAddress]]    = SafeMath.add(tokenBalanceLedger_[referralLevel1Address[_customerAddress]], _newXDMbonus);\n        }\n        tokenSupply_                    = SafeMath.add(tokenSupply_, _newXDMbonus);\n    }\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) antiEarlyWhale(_incomingEthereum) internal returns(uint256) {\n        // data setup\n        address _customerAddress            = msg.sender;\n        incETH                              = _incomingEthereum;\n        \n        developerFee                        = SafeMath.percent(incETH,developerFee_,100,18);\n        developerBalance                    = SafeMath.add(developerBalance, developerFee);\n        \n        _referralBonus                      = SafeMath.percent(incETH,referralPer_,100,18);\n        \n        uint256 _dividends                  = SafeMath.percent(incETH,dividendFee_,100,18);\n        \n        uint256 untotalDeduct               = developerFee_ + referralPer_ + dividendFee_;\n        uint256 totalDeduct                 = SafeMath.percent(incETH,untotalDeduct,100,18);\n        \n        uint256 _taxedEthereum              = SafeMath.sub(incETH, totalDeduct);\n        uint256 _amountOfTokens             = ethereumToTokens_(_taxedEthereum);\n        uint256 _fee                        = _dividends * magnitude;\n        bool    _newReferral                = true;\n        \n        \n        if(referralLevel1Address[_customerAddress] != 0x0000000000000000000000000000000000000000) {\n            _referredBy                     = referralLevel1Address[_customerAddress];\n            _newReferral                    = false;\n        }\n        \n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\n        // is the user referred by a link?\n        if(\n            // is this a referred purchase?\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\n            // no cheating!\n            _referredBy != _customerAddress &&\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n        ){\n            // wealth redistribution\n            distributeRefBonus(_referralBonus,_referredBy,_customerAddress,_newReferral);\n            if(incETH >= 10 ether && incETH <= 1000 ether) {\n                distributeNewBonus(incETH,_amountOfTokens,_customerAddress,false);\n            }\n        } else {\n            // no ref purchase\n            // send referral bonus back to admin\n            developerBalance                = SafeMath.add(developerBalance, _referralBonus);\n            if(incETH >= 10 ether && incETH <= 1000 ether) {\n                distributeNewBonus(incETH,_amountOfTokens,_customerAddress,true);\n            }\n        }\n        // we can't give people infinite ethereum\n        if(tokenSupply_ > 0){\n            // add tokens to the pool\n            tokenSupply_                    = SafeMath.add(tokenSupply_, _amountOfTokens);\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n            profitPerShare_                 += (_dividends * magnitude / (tokenSupply_));\n            // calculate the amount of tokens the customer receives over his purchase \n            _fee                            = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\n        } else {\n            // add tokens to the pool\n            tokenSupply_                    = _amountOfTokens;\n        }\n        // update circulating supply & the ledger address for the customer\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n        int256 _updatedPayouts              = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\n        payoutsTo_[_customerAddress]        += _updatedPayouts;\n        // fire event\n        onTokenPurchase(_customerAddress, incETH, _amountOfTokens, _referredBy);\n        return _amountOfTokens;\n    }\n\n    /**\n     * Calculate Token price based on an amount of incoming ethereum\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n     */\n    function ethereumToTokens_(uint256 _ethereum) internal view returns(uint256) {\n        uint256 _tokenPriceInitial          = tokenPriceInitial_ * 1e18;\n        uint256 _tokensReceived             = \n         (\n            (\n                SafeMath.sub(\n                    (sqrt\n                        (\n                            (_tokenPriceInitial**2)\n                            +\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\n                            +\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\n                            +\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\n                        )\n                    ), _tokenPriceInitial\n                )\n            )/(tokenPriceIncremental_)\n        )-(tokenSupply_)\n        ;\n\n        return _tokensReceived;\n    }\n    \n    /**\n     * Calculate token sell value.\n     */\n     function tokensToEthereum_(uint256 _tokens) internal view returns(uint256) {\n        uint256 tokens_                     = (_tokens + 2e18);\n        uint256 _tokenSupply                = (tokenSupply_ + 2e18);\n        uint256 _etherReceived              =\n        (\n            SafeMath.sub(\n                (\n                    (\n                        (\n                            tokenPriceInitial_ +(tokenPriceDecremental_ * (_tokenSupply/2e18))\n                        )-tokenPriceDecremental_\n                    )*(tokens_ - 2e18)\n                ),(tokenPriceDecremental_*((tokens_**2-tokens_)/2e18))/2\n            )\n        /2e18);\n        return _etherReceived;\n    }\n    \n    function sqrt(uint x) internal pure returns (uint y) {\n        uint z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n    \n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"senderAddress\",\"type\":\"address\"}],\"name\":\"migratePayoutsToShow\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"migrateDeveloperFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stakePercent\",\"type\":\"uint8\"}],\"name\":\"changeStakePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyAmbassadors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"dataId\",\"type\":\"uint256\"}],\"name\":\"getDownlineRef\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"dataId\",\"type\":\"uint256\"},{\"name\":\"refUserAddress\",\"type\":\"address\"},{\"name\":\"refLevel\",\"type\":\"uint256\"}],\"name\":\"migrateDownlineRef\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"stakeTokensBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefUser\",\"outputs\":[{\"name\":\"refUserAddress\",\"type\":\"address\"},{\"name\":\"refLevel\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"int256\"}],\"name\":\"migratePayoutsTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseStake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeveloperBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"migrateStakeBalanceNTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"stakeTokensTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"migrateTotalSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"setStakingRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableInitialStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"drainDeveloperFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"ref1\",\"type\":\"address\"},{\"name\":\"ref2\",\"type\":\"address\"},{\"name\":\"ref3\",\"type\":\"address\"},{\"name\":\"ref4\",\"type\":\"address\"},{\"name\":\"ref5\",\"type\":\"address\"},{\"name\":\"ref6\",\"type\":\"address\"},{\"name\":\"ref7\",\"type\":\"address\"},{\"name\":\"ref8\",\"type\":\"address\"},{\"name\":\"ref9\",\"type\":\"address\"},{\"name\":\"ref10\",\"type\":\"address\"}],\"name\":\"migrateTenLvlReferral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"dividendBal_\",\"type\":\"uint256\"},{\"name\":\"referralBalanceM_\",\"type\":\"uint256\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"referralCountM_\",\"type\":\"uint256\"}],\"name\":\"migrateXDMDividendNReferralBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getref\",\"outputs\":[{\"name\":\"lv\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCount_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrateProfitPerShareShow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"migrateProfitPerShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"EthWin","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}