{"status":"1","message":"OK","result":[{"SourceCode":"{\"BAEXOptions.sol\":{\"content\":\"pragma solidity 0.6.11; // 5ef660b1\\nimport \\\"BAEXToken.sol\\\";\\n/* BAEX - Binary Options Smart-Contract v.1.0.1 (Â© 2020 - baex.com)\\n    \\nA smart contract source code of an open binary options platform BAEX.\\n\\nThis open-source code confirms the open binary options model used on the baex.com platform, where any user\\n\\tof the Ethereum can participate as a liquidity provider or a trader.\\n\\nThe BAEX mathematical model of binary options provides:\\n\\n1) Automatically calculated profit ratios for traders from transactions that allow\\n\\tyou to get an honestly balanced profit from trading.\\n\\n2) The opportunity to receive 10% profit for liquidity providers from held in liquidity pool BAEX tokens.\\n\\n3) Oracles of BAEX uses Yahoo Finance as a source of reliable market quotes, which are stored on the blockchain\\n\\tand always can be verified by 3d party.\\n\\nUsing this smart contract, you can earn from providing liquidity or trading on the baex.com platform\\n*/\\n\\n/* BAEX - smart-contract of BAEX options */\\ncontract BAEXOptions is OptionsContract {\\n    // Fixed point math factor is 10^10\\n    uint256 constant public fmk = 10**10;\\n    address constant private super_owner = 0x2B2fD898888Fa3A97c7560B5ebEeA959E1Ca161A;\\n    address private owner;\\n    \\n    string public name;\\n    \\n    // Divider of trades period in seconds 300 is 5 minutes\\n    uint32 public period_divider;\\n    // Current max num of periods for trade\\n    uint32 public max_period;\\n    // Current min periods of trade\\n    uint32 public min_period;\\n    \\n    /* ALL STORED IN THIS CONTRACT BALANCES AND AMOUNTS HAVE PRECISION * 10 */\\n    \\n    // Min trade volume\\n    uint256 public min_trade_vol;\\n    // Max trade volume\\n    uint256 public max_trade_vol;\\n    // Flag of automatic recalc trade volume \\n    bool public recalc_max_trade_vol;\\n    \\n    // Size of liquidity pool\\n    uint256 public liquidity_pool;\\n    // Blocked amount of liquidity pool\\n    uint256 public liquidity_pool_blocked;\\n    \\n    // Current ratio of trades\\n    uint256 public liquidity_perc;\\n    \\n    // Balancing factors\\n    uint256 public liquidity_balancing_mul;\\n    uint256 public liquidity_perc_normal;\\n    uint256 public liquidity_in;\\n    uint256 public liquidity_ratio;\\n    \\n    // 5% is processing fee:\\n\\t//\\t 2.5% to the liquidity pool \\u0026 2.5% as fees for oracles\\n    uint256 constant public processing_fees_percent = 5 * fmk / 100;\\n    // Collected fees for oracles\\n    uint256 public oracle_fees;    \\n    uint32  public num_of_trades;\\n    \\n    uint256 public gas_for_process;\\n    \\n    mapping (address =\\u003e bool) oracles;\\n    \\n    address payable baex;\\n    \\n    struct TTrade {\\n        uint256 vol;\\n        uint256 fees;\\n        uint256 params;\\n        // bits of params:\\n        // 0x0001       0020        5F4B5235            5F4B5535            000000000000000000000000000007001ED00044\\n        // direction    period      place_time_stamp    result_time_stamp                                 result_vol\\n        uint256 result_vol;\\n        int256 result;\\n    }\\n    \\n    mapping(uint256 =\\u003e TTrade) public trades;\\n    mapping(uint16 =\\u003e bytes16) public valid_instruments;\\n    mapping(address =\\u003e uint256 ) public liquidity;\\n    \\n    // Stored rates of instruments in blockchain\\n    // bits:\\n    // 0x0001          5F4B5535   -\\u003e    0x000000F049EBDC05\\n    // instrument id   timestamp  -\\u003e    instrument rate * 10^8\\n    mapping(uint48 =\\u003e uint64) public instrumentRates;\\n\\n    constructor() public {\\n\\t\\tname = \\\"BAEX - Options Smart-Contract\\\";\\n\\t\\t\\n\\t\\tperiod_divider = 300;   // 5 minutes\\n\\t\\tmax_period = 288;       // 288 * 5 minutes = 24 hours\\n\\t\\tmin_period = 1;\\n\\t\\t\\n\\t\\t// Assets for trades list, can be extend later\\n\\t\\t//--------------------------------------------\\n\\t\\t// Crypto\\n\\t\\tvalid_instruments[1] = \\\"BTC-USD\\\";\\n\\t\\tvalid_instruments[2] = \\\"ETH-USD\\\";\\n\\t\\n\\t\\t// Forex\\n\\t\\tvalid_instruments[3] = \\\"EUR-USD\\\";\\n\\t\\tvalid_instruments[4] = \\\"GBP-USD\\\";\\n\\t\\tvalid_instruments[47] = \\\"USD-JPY\\\";\\n\\t\\tvalid_instruments[53] = \\\"AUD-USD\\\";\\n\\t\\tvalid_instruments[59] = \\\"EUR-JPY\\\";\\n\\t\\tvalid_instruments[62] = \\\"GBP-JPY\\\";\\n\\t\\t\\n\\t\\t// S\\u0026P 500 Index\\n\\t\\tvalid_instruments[32] = \\\"SNP\\\"; \\n\\t\\t// Dow Jones Industrial Average Index\\n\\t\\tvalid_instruments[35] = \\\"^DJI\\\";\\n\\t\\t// NASDAQ Composite Index\\n\\t\\tvalid_instruments[38] = \\\"^IXIC\\\";\\n\\t\\t// NYSE COMPOSITE (DJ) Index\\n\\t\\tvalid_instruments[41] = \\\"^NYA\\\";\\n\\t\\t\\n\\t\\t// Tesla, Inc.\\n\\t\\tvalid_instruments[5] = \\\"TSLA\\\";\\n\\t\\t// Nordstrom, Inc.\\n\\t\\tvalid_instruments[71] = \\\"JWN\\\";\\n\\t\\t// Microsoft Corporation\\n\\t\\tvalid_instruments[74] = \\\"MSFT\\\";\\n\\t\\t// Apple, Inc.\\n\\t\\tvalid_instruments[77] = \\\"AAPL\\\";\\n\\t\\t// Uber Technologies, Inc.\\n\\t\\tvalid_instruments[80] = \\\"UBER\\\";\\n\\t\\t// Advanced Micro Devices, Inc.\\n\\t\\tvalid_instruments[83] = \\\"AMD\\\";\\n\\t\\t// Bank of America Corporation\\n\\t\\tvalid_instruments[86] = \\\"BAC\\\";\\n\\t\\t// Intel Corporation\\n\\t\\tvalid_instruments[89] = \\\"INTC\\\";\\n\\t\\t// Pfizer, Inc.\\n\\t\\tvalid_instruments[95] = \\\"PFE\\\";\\n\\t\\t// Exxon Mobil Corporation\\n\\t\\tvalid_instruments[98] = \\\"XOM\\\";\\n\\t\\t// Johnson \\u0026 Johnson\\n\\t\\tvalid_instruments[101] = \\\"JNJ\\\";\\n\\t\\t// Delta Air Lines, Inc.\\n\\t\\tvalid_instruments[104] = \\\"DAL\\\";\\n\\t\\t// The Walt Disney Company\\n\\t\\tvalid_instruments[107] = \\\"DIS\\\";\\n\\t\\t// Citigroup, Inc.\\n\\t\\tvalid_instruments[110] = \\\"C\\\";\\n\\t\\t// The British Petroleum Company\\n\\t\\tvalid_instruments[113] = \\\"BP\\\";\\n\\t\\t// Amazon.com, Inc.\\n\\t\\tvalid_instruments[119] = \\\"AMZN\\\";\\n\\t\\t// Lockheed Martin Corporation\\n\\t\\tvalid_instruments[122] = \\\"LMT\\\";\\n\\t\\t//--------------------------------------------\\n\\t\\t\\n\\t\\tliquidity_balancing_mul = 100 * fmk / 100;\\n\\t\\tliquidity_perc = 95 * fmk / 100;\\n\\t\\tliquidity_perc_normal = 95 * fmk / 100;\\n\\t\\tliquidity_in = 0;\\n\\t\\tliquidity_pool = 0;\\n\\t\\tliquidity_pool_blocked = 0;\\n\\t\\tliquidity_ratio = 1 * fmk;\\n\\t\\t\\n\\t\\tmin_trade_vol = 1 * (10 ** 9);\\n\\t\\tmax_trade_vol = 50 * (10 ** 9);\\n\\t\\trecalc_max_trade_vol = true;\\n\\t\\tgas_for_process = 90000;\\n\\t\\t\\n\\t\\toracles[address(0xa6cF40A509F9847451A7ed7FeEa97F889A750490)] = true;\\n        \\n\\t\\towner = msg.sender;\\n\\t\\tnum_of_trades = 0;\\n\\t}\\n\\t\\n\\tmodifier onlyOwner() {\\n\\t\\trequire( (msg.sender == owner) || (msg.sender == super_owner), \\\"You don\\u0027t have permissions to call it\\\" );\\n\\t\\t_;\\n\\t}\\n\\t\\n\\tmodifier onlyOracle {\\n\\t\\trequire( oracles[msg.sender], \\\"Only oracles can call it\\\" );\\n\\t\\t_;\\n\\t}\\n\\t\\n\\tfunction afterChangeLiquidityPool() private {\\n\\t    if ( recalc_max_trade_vol ) {\\n            max_trade_vol = (liquidity_pool-liquidity_pool_blocked) / 50;\\n\\t    }\\n\\t    liquidity_balancing_mul = (liquidity_pool-liquidity_pool_blocked) * fmk / liquidity_in;\\n\\t    liquidity_perc = liquidity_perc_normal * liquidity_balancing_mul / fmk;\\n\\t    liquidity_ratio = liquidity_in * fmk / liquidity_pool;\\n\\t    log3(bytes20(address(this)),bytes4(\\\"LPC\\\"),bytes32(liquidity_pool\\u003c\\u003c128 | liquidity_pool_blocked),bytes32(liquidity_perc));\\n\\t}\\n    \\n    function placeLiquidity(uint256 _vol) public {\\n        _placeLiquidity( msg.sender, _vol, true );\\n    }\\n\\tfunction _placeLiquidity(address _sender, uint256 _vol, bool _need_transfer) private {\\n\\t    require( _vol \\u003e 0, \\\"Vol must be greater than zero\\\" );\\n\\t    require( _vol \\u003c 10**21, \\\"Too big volume\\\" );\\n\\t    if ( _need_transfer ) {\\n\\t        BAEX(baex).transferOptions(_sender,address(this),_vol,false);\\n\\t    }\\n\\t    _vol = _vol * 10;\\n        uint256 in_vol = _vol;\\n        if ( liquidity_pool != 0 ) {\\n            in_vol = _vol * liquidity_ratio / fmk;\\n        }\\n        liquidity_in = liquidity_in + in_vol;\\n        liquidity_pool = liquidity_pool + _vol;\\n        liquidity[_sender] = liquidity[_sender] + in_vol;\\n        afterChangeLiquidityPool();\\n\\t}\\n\\t\\n\\tfunction balanceOf(address _sender) public view returns (uint256) {\\n        return liquidityBalanceOf(_sender);\\n    }\\n    \\n    function getMinMaxTradeVol() public view returns (uint256, uint256) {\\n        return (min_trade_vol/10, max_trade_vol/10);\\n    }\\n    \\n    function liquidityBalanceOf(address _sender) public view returns (uint256) {\\n\\t    return liquidity[_sender] * fmk / liquidity_ratio / 10;\\n\\t}\\n\\t\\n\\tfunction withdrawLiquidity(uint256 _vol, bool _burn_to_eth) public {\\n\\t    _withdrawLiquidity( msg.sender, _vol, _burn_to_eth );\\n\\t}\\n\\tfunction _withdrawLiquidity(address _sender, uint256 _vol, bool _burn_to_eth) private {\\n\\t    require( _vol \\u003e 0, \\\"Vol must be greater than zero\\\" );\\n\\t    require( _vol \\u003c 10**21, \\\"Too big volume\\\" );\\n\\t    _vol = _vol * 10;\\n\\t    require( _vol \\u003c= (liquidity_pool-liquidity_pool_blocked), \\\"Not enought volume for withdrawal, please decrease volume to withdraw (1)\\\" );\\n\\t    uint256 in_vol = _vol * liquidity_ratio / fmk;\\n\\t    uint256 in_bal = liquidity[_sender];\\n\\t    require( in_vol \\u003c= in_bal, \\\"Not enought volume for withdrawal, please decrease volume to withdraw (2)\\\" );\\n\\t    BAEX(baex).transferOptions(address(this),_sender,_vol/10,_burn_to_eth);\\n\\t    if ( liquidity_pool - _vol \\u003c 3 ) {\\n            liquidity[_sender] = 0;\\n            liquidity_pool = 0;\\n            liquidity_in = 0;\\n            liquidity_ratio = fmk;\\n        } else {\\n            if ( in_bal - in_vol \\u003c 3 ) {\\n\\t            in_vol = in_bal;\\n\\t        }\\n            liquidity[_sender] = in_bal - in_vol;\\n            liquidity_pool = liquidity_pool - _vol;\\n            liquidity_in = liquidity_in - in_vol;\\n        }\\n        afterChangeLiquidityPool();\\n\\t}\\n\\t\\n\\t\\n\\tfunction placeTrade(uint16 _instrument, uint256 _vol, uint8 _direction, uint32 _trade_timestamp, uint16 _period) public {\\n\\t    _placeTrade(msg.sender, _instrument, _vol, _direction, _trade_timestamp, _period );\\n\\t}\\n\\tfunction _placeTrade(address _sender, uint16 _instrument, uint256 _vol, uint8 _direction, uint32 _timestamp, uint16 _period) private {\\n\\t    require( _vol \\u003e 0, \\\"Vol must be greater than zero\\\" );\\n\\t    require( _vol \\u003c 10**21, \\\"Too big volume\\\" );\\n\\t    _vol = _vol * 10;\\n        require( _period \\u003c= max_period, \\\"Too long period\\\" );\\n        require( _period \\u003e= min_period, \\\"Too short period\\\" );\\n        require( _direction \\u003c 2, \\\"Direction can be 0 (down) or 1 (up)\\\" );\\n        require( valid_instruments[_instrument][0] != 0, \\\"This instrument is unavailable now\\\" );\\n\\t    require( _vol \\u003e= min_trade_vol, \\\"Your trade volume less than minimal trade volume\\\" );\\n\\t    require( _vol \\u003c= max_trade_vol, \\\"Your trade volume greater than maximum trade volume\\\" );\\n\\t    require( (block.timestamp-240) \\u003c= _timestamp, \\\"Timestamp param should be not early than 4 min before timestamp of the block\\\" );\\n\\t    uint time_stamp = block.timestamp / 60 * 60;\\n\\t    uint result_time_stamp = time_stamp + _period*period_divider;\\n\\t    BAEX(baex).transferOptions(_sender,address(this),_vol/10,false);\\n\\t    uint256 fees = _vol * processing_fees_percent / fmk;\\n\\t    liquidity_pool = liquidity_pool + (fees - fees / 2);\\n\\t    // Recalc cost of transaction ( BAEX amount in this contract stored as amount * 10 )\\n\\t    uint256 cost_of_processing = tx.gasprice * gas_for_process / BAEX(baex).burnPrice() / 10;\\n\\t    if ( (fees/2) \\u003c cost_of_processing ) {\\n\\t        oracle_fees = oracle_fees + cost_of_processing;\\n\\t        fees = (fees - fees / 2) + cost_of_processing;\\n\\t    } else {\\n\\t        oracle_fees = oracle_fees + fees / 2;\\n\\t    }\\n\\t    require( _vol \\u003e fees * 2, \\\"Your trade volume is too low, please increase the trade volume\\\" );\\n\\t    _vol = _vol - fees;\\n\\t    liquidity_ratio = liquidity_in * fmk / liquidity_pool;\\n\\t    uint256 trade_id = ( uint256(_sender) \\u003c\\u003c 96 ) | ( (uint256( _instrument ) \\u003c\\u003c 64) | block.number );\\n\\t    require( trades[trade_id].vol == 0, \\\"Other your trade in this Ethereum block was detected. You can do only one trade on each instrument in one Ethereum block\\\" );\\n\\t    uint256 result_vol = _vol * liquidity_perc / fmk;\\n\\t    require( result_vol \\u003c= (liquidity_pool-liquidity_pool_blocked), \\\"Not enought liquidity for your trade\\\" );\\n\\t    uint256 trade_params = ( uint256(_direction) \\u003c\\u003c 240 ) | ( uint256(_period) \\u003c\\u003c 224 )\\n\\t                            | ( uint256(time_stamp) \\u003c\\u003c 192 ) | ( uint256(result_time_stamp) \\u003c\\u003c 160 ) | ( uint256(_instrument) \\u003c\\u003c 144 );\\n\\t    if ((result_vol/10) \\u003c (1\\u003c\\u003c144)) {\\n\\t        trade_params = trade_params | (result_vol/10);\\n\\t    }\\n\\t    trades[trade_id] = TTrade( _vol, (cost_of_processing\\u003c\\u003c128) | fees, trade_params, result_vol, 0 );\\n\\t    liquidity_pool_blocked = liquidity_pool_blocked + result_vol;\\n\\t    afterChangeLiquidityPool();\\n\\t    log4(bytes20(address(this)),bytes8(\\\"TRADE\\\"),bytes32(trade_id),bytes32(trades[trade_id].params),bytes32((uint256((fees+_vol)/10)\\u003c\\u003c128) | (fees/10)));\\n\\t    num_of_trades++;\\n\\t}\\n\\t\\n\\t// Process the trade\\n\\tfunction processTrade(uint16 _instrument, uint64 _block_number) public {\\n\\t    _processTrade(msg.sender, _instrument, _block_number);\\n\\t}\\n\\tfunction _processTrade(address _sender, uint16 _instrument, uint64 _block_number) public {\\n\\t    uint256 trade_id = ( uint256(_sender) \\u003c\\u003c 96 ) | ( (uint256( _instrument ) \\u003c\\u003c 64) | _block_number );\\n\\t    TTrade storage trade = trades[trade_id];\\n\\t    require( trade.vol \\u003e 0, \\\"Trade in this block for this addr is not found\\\");\\t    \\n\\t    require( trade.result == 0, \\\"This trade is already has been processed\\\");\\n\\t    uint32 time_stamp = uint32( ( trade.params \\u003c\\u003c 32 ) \\u003e\\u003e 224 );\\n\\t    uint32 result_time_stamp = uint32( ( trade.params \\u003c\\u003c 64 ) \\u003e\\u003e 224 );\\n\\t    uint48 its1 = uint48( uint48(_instrument) \\u003c\\u003c 32 ) | time_stamp;\\n\\t    uint48 its2 = uint48( uint48(_instrument) \\u003c\\u003c 32 ) | result_time_stamp;\\n\\t\\t// If the trade was not processed in 2000 blocks, return the trade volume to the sender\\n\\t    if ( ( trade.result == 0 ) \\u0026\\u0026 ( block.timestamp \\u003e result_time_stamp ) \\u0026\\u0026 ( (block.timestamp-result_time_stamp) \\u003e= 3600 \\u0026\\u0026 (instrumentRates[its1]==0 || instrumentRates[its2]==0) ) ) {\\n\\t        uint256 trade_fees = (trade.fees\\u003c\\u003c128) \\u003e\\u003e 128;\\n\\t        uint256 cost_of_processing = trade.fees \\u003e\\u003e 128;\\n\\t        if ( cost_of_processing \\u003e (trade_fees/2) ) {\\n\\t            if ( oracle_fees \\u003e cost_of_processing ) {\\n\\t                oracle_fees = oracle_fees - cost_of_processing;\\n\\t            } else {\\n\\t                oracle_fees = 0;\\n\\t            }\\n\\t        } else {\\n\\t            if ( oracle_fees \\u003e trade_fees/2 ) {\\n\\t                oracle_fees = oracle_fees - trade_fees/2;\\n\\t            } else {\\n\\t                oracle_fees = 0;\\n\\t            }\\n\\t        }\\n\\t        liquidity_pool_blocked = liquidity_pool_blocked - trade.result_vol;\\n\\t        trade.result_vol = trade.vol;\\n\\t\\t\\tBAEX(baex).transferOptions(address(this),_sender,(trade.vol+trade_fees)/10,false);\\n\\t        trade.vol = 0;\\n\\t\\t\\tlog3(bytes20(address(this)),bytes8(\\\"CANCEL\\\"),bytes32(trade_id),bytes32(trade.params));\\n\\t        return;\\n\\t    }\\n\\t    __processTrade( trade_id, instrumentRates[its1], instrumentRates[its2] );\\n\\t}\\n\\t\\n\\tfunction __processTrade( uint256 trade_id, uint64 begin_rate, uint64 end_rate ) private {\\n\\t    require( begin_rate \\u003e 0, \\\"Begin rate is not saved yet in blockhain\\\");\\n\\t    require( end_rate \\u003e 0, \\\"End rate is not saved yet in blockhain\\\");\\n\\t    \\n\\t    address _addr = address( trade_id \\u003e\\u003e 96 );\\n\\t    \\n\\t    TTrade storage trade = trades[trade_id];\\n\\t    require( trade.vol \\u003e 0, \\\"Trade in this block for this addr is not found\\\");\\n\\t    require( trade.result == 0, \\\"This trade has been processed\\\");\\n\\t    require( begin_rate \\u003e 0 || end_rate \\u003e 0, \\\"Not found rates of this instrument for this timestamps\\\");\\n\\t    bool dir = ( (( 1 \\u003c\\u003c 240 ) \\u0026 trade.params) \\u003e 0 );\\n\\t    uint256 trade_fees = (trade.fees\\u003c\\u003c128) \\u003e\\u003e 128;\\n\\t    if ( ( dir \\u0026\\u0026 begin_rate \\u003c end_rate ) || ( (!dir) \\u0026\\u0026 begin_rate \\u003e= end_rate ) ) {\\n\\t        trade.result = int256( trade.result_vol );\\n\\t        log4(bytes20(address(this)),bytes4(\\\"P\\\"),bytes32(trade_id),bytes32(trade.params),bytes32((uint256((trade.vol+trade.result_vol)/10)\\u003c\\u003c128) | (trade_fees/10)));\\n\\t    } else {\\n\\t        trade.result = -int256( trade.result_vol );\\n\\t        log4(bytes20(address(this)),bytes4(\\\"L\\\"),bytes32(trade_id),bytes32(trade.params),bytes32((uint256((trade_fees+trade.vol)/10)\\u003c\\u003c128) | (trade_fees/10)));\\n\\t    }\\n\\t    liquidity_pool_blocked = liquidity_pool_blocked - trade.result_vol;\\n\\t    if ( trade.result \\u003e 0 ) {\\n\\t        BAEX(baex).transferOptions(address(this),_addr,(trade.result_vol + trade.vol)/10,false);\\n\\t        liquidity_pool = liquidity_pool - trade.result_vol;\\n\\t    } else {\\n\\t        liquidity_pool = liquidity_pool + trade.vol;\\n\\t    }\\n\\t    afterChangeLiquidityPool();\\n\\t}\\n\\t\\n\\t/*\\n\\t    Oracle functions\\n\\t*/\\n\\tfunction oracleStoreRatesAndProcessTrade( uint256 trade_id, uint256 _instrument_ts_rates ) public onlyOracle {\\n\\t    uint256 startGas = gasleft();\\n\\t    uint48 its1 = uint48( _instrument_ts_rates \\u003e\\u003e 192 );\\n\\t    uint48 its2 = uint48( (_instrument_ts_rates \\u003c\\u003c 128) \\u003e\\u003e 192 );\\n\\t    uint64 begin_rate = uint64( (_instrument_ts_rates \\u003c\\u003c 64) \\u003e\\u003e 192 );\\n\\t    uint64 end_rate = uint64( (_instrument_ts_rates \\u003c\\u003c 192) \\u003e\\u003e 192 );\\n\\t    \\n\\t    if ( instrumentRates[its1] == 0 ) instrumentRates[its1] = begin_rate;\\n\\t    if ( instrumentRates[its2] == 0 ) instrumentRates[its2] = end_rate;\\n\\t    \\n\\t    __processTrade( trade_id, begin_rate, end_rate );\\n\\t    // Calc new gas amount for process the trade, 30200 is the constant cost to call\\n\\t    gas_for_process = startGas - gasleft() + 30200;\\n\\t}\\n\\t\\n\\tfunction oracleStoreRates4( uint256 _instrument_and_ts, uint256 _rates ) public onlyOracle {\\n\\t    uint48 its1 = uint48( _instrument_and_ts \\u003e\\u003e 192 );\\n\\t    uint48 its2 = uint48( (_instrument_and_ts \\u003c\\u003c 64) \\u003e\\u003e 192 );\\n\\t    uint48 its3 = uint48( (_instrument_and_ts \\u003c\\u003c 128) \\u003e\\u003e 192 );\\n\\t    uint48 its4 = uint48( (_instrument_and_ts \\u003c\\u003c 192) \\u003e\\u003e 192 );\\n\\t    \\n\\t    if ( instrumentRates[its1] == 0 ) instrumentRates[its1] = uint64( _rates \\u003e\\u003e 192 );\\n\\t    if ( instrumentRates[its2] == 0 ) instrumentRates[its2] = uint64( (_rates \\u003c\\u003c 64) \\u003e\\u003e 192 );\\n\\t    if ( instrumentRates[its3] == 0 ) instrumentRates[its3] = uint64( (_rates \\u003c\\u003c 128) \\u003e\\u003e 192 );\\n\\t    if ( instrumentRates[its4] == 0 ) instrumentRates[its4] = uint64( (_rates \\u003c\\u003c 192) \\u003e\\u003e 192 );\\n\\t}\\n\\t\\n\\tfunction oracleStoreRates2( uint256 _instrument_ts_rates ) public onlyOracle {\\n\\t    uint48 its1 = uint48( _instrument_ts_rates \\u003e\\u003e 192 );\\n\\t    uint48 its2 = uint48( (_instrument_ts_rates \\u003c\\u003c 128) \\u003e\\u003e 192 );\\n\\t    \\n\\t    if ( instrumentRates[its1] == 0 ) instrumentRates[its1] = uint64( (_instrument_ts_rates \\u003c\\u003c 64) \\u003e\\u003e 192 );\\n\\t    if ( instrumentRates[its2] == 0 ) instrumentRates[its2] = uint64( (_instrument_ts_rates \\u003c\\u003c 192) \\u003e\\u003e 192 );\\n\\t}\\n\\t\\n\\t\\n\\t/* Admin functions */\\n\\tfunction transferOwnership(address newOwner) public onlyOwner {\\n\\t\\trequire(newOwner != address(0));\\n\\t\\towner = newOwner;\\n\\t}\\n\\t\\n\\tfunction setTokenAddress(address _token_address) public onlyOwner {\\n\\t    baex = payable(_token_address);\\n\\t}\\n\\t\\n\\tfunction setValidInstrument(uint16 _instrument_id, bytes16 _ticker) public onlyOwner {\\n\\t    valid_instruments[_instrument_id] = _ticker;\\n\\t}\\n\\t\\n\\tfunction setPeriodParams(uint32 _period_divider, uint32 _min_period, uint32 _max_period) public onlyOwner {\\n\\t    period_divider = _period_divider;\\n\\t    min_period = _min_period;\\n\\t    max_period = _max_period;\\n\\t}\\n\\t\\n\\tfunction setTradeVol(uint256 _min_trade_vol, uint256 _max_trade_vol, bool _recalc_max_trade_vol) public onlyOwner {\\n\\t    min_trade_vol = _min_trade_vol;\\n\\t    max_trade_vol = _max_trade_vol;\\n\\t    recalc_max_trade_vol = _recalc_max_trade_vol;\\n\\t}\\n\\t\\n\\tfunction setOracle(address _oracle_address, bool _enabled) public onlyOwner {\\n\\t    oracles[_oracle_address] = _enabled;\\n\\t}\\n\\t\\n\\tfunction onTransferTokens(address _from, address _to, uint256 _value) override public returns (bool) {\\n\\t    require( msg.sender == address(baex), \\\"You don\\u0027t have permission to call it\\\" );\\n\\t    if ( _to == address(this) ) {\\n\\t        _placeLiquidity( _from, _value, false );\\n\\t    }\\n\\t}\\n\\t\\n\\tfunction withdrawOracleFees(uint256 _vol) public onlyOwner {\\n\\t    // + 10 * 10**9 because need to leave some amount of fees for the cancelled trades\\n\\t    require( oracle_fees \\u003e= (_vol * 10 + 10 * 10**9), \\\"Not enought fee on the contract\\\");\\n\\t    BAEX(baex).transferOptions(address(this),msg.sender,_vol,false);\\n\\t    oracle_fees = oracle_fees - _vol * 10;\\n\\t}\\n\\t\\n\\t// This function can transfer any of wrong sended ERC20 tokens to the contract exclude BAEX tokens,\\n\\t// because sendeding of the BAEX tokens to this contract is the valid operation\\n\\tfunction transferWrongSendedERC20FromContract(address _contract) public {\\n\\t    require( _contract != address(baex), \\\"Transfer of BAEX token is fortradeen\\\");\\n\\t    require( msg.sender == super_owner, \\\"Your are not super owner\\\");\\n\\t    ERC20(_contract).transfer( super_owner, ERC20(_contract).balanceOf(address(this)) );\\n\\t}\\n\\t\\n\\t// If someone send ETH to this contract it will send it back\\n\\treceive() external payable  {\\n        msg.sender.transfer(msg.value);\\n\\t}\\n\\t/*------------------*/\\n\\t\\n}\\n/* END of: BAEX - smart-contract of BAEX options */\\n\\n// SPDX-License-Identifier: UNLICENSED\"},\"BAEXToken.sol\":{\"content\":\"pragma solidity 0.6.11; // 5ef660b1\\n/**\\n * @title BAEX - Binary Assets EXchange DeFi token v.1.0.1 (Â© 2020 - baex.com)\\n *\\n * The source code of the BAEX token, which provides liquidity for the open binary options platform https://baex.com\\n * \\n * THIS SOURCE CODE CONFIRMS THE \\\"NEVER FALL\\\" MATHEMATICAL MODEL USED IN THE BAEX TOKEN.\\n * \\n * 9 facts about the BAEX token:\\n * \\n * 1) Locked on the BAEX smart-contract, Ethereum is always collateral of the tokens value and can be transferred\\n *  from it only when the user burns his BAEX tokens.\\n * \\n * 2) The total supply of BAEX increases only when Ethereum is sent on hold on the BAEX smart-contract\\n * \\tand decreases when the BAEX holder burns his tokens to get ETH.\\n * \\n * 3) Any BAEX tokens holder at any time can burn them and receive a part of the Ethereum held\\n * \\ton BAEX smart-contract based on the formula tokens_to_burn * current_burn_price - (5% burning_fee).\\n * \\n * 4) current_burn_price is calculated by the formula (amount_of_holded_eth / total_supply) * 0.9\\n * \\n * 5) Based on the facts above, the value of the BAEX tokens remaining after the burning increases every time\\n * \\tsomeone burns their BAEX tokens and receives Ethereum for them.\\n * \\n * 6) BAEX tokens issuance price calculated as (amount_of_holded_eth / total_supply) + (amount_of_holded_eth / total_supply) * 14%\\n *  that previously purchased BAEX tokens are always increased in their price.\\n * \\n * 7) BAEX token holders can participate as liquidity providers or traders on the baex.com hence, any withdrawal of\\n *  profit in ETH will increase the value of previously purchased BAEX tokens.\\n * \\n * 8) There is a referral program, running on the blockchain, in the BAEX token that allows you to receive up to 80% of the system\\u0027s \\n *  commissions as a reward, you can find out more details and get your referral link at https://baex.com/#referral\\n *\\n * 9) There is an integrated automatic bonus pool distribution system in the BAEX token https://baex.com/#bonus\\n * \\n * Read more about all the possible ways of earning and using the BAEX token on https://baex.com/#token\\n */\\n\\n/* Abstract contracts */\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003e 0);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n}\\n\\n/**\\n * @title ERC20 interface with allowance\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\nabstract contract ERC20 {\\n    uint public _totalSupply;\\n    function totalSupply() public view virtual returns (uint);\\n    function balanceOf(address who) public view virtual returns (uint);\\n    function transfer(address to, uint value) virtual public returns (bool);\\n    function allowance(address owner, address spender) public view virtual returns (uint);\\n    function transferFrom(address from, address to, uint value) virtual public returns (bool);\\n    function approve(address spender, uint value) virtual public;\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\n/**\\n * @title Implementation of the basic standard ERC20 token.\\n * @dev ERC20 with allowance\\n */\\nabstract contract StandardToken is ERC20 {\\n    using SafeMath for uint;\\n    mapping(address =\\u003e uint) public balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) public allowed;\\n    uint private constant MAX_UINT = 2**256 - 1;\\n\\n    /**\\n    * @dev Fix for the ERC20 short address attack.\\n    */\\n    modifier onlyPayloadSize(uint size) {\\n        require(!(msg.data.length \\u003c size + 4));\\n        _;\\n    }\\n    \\n    /**\\n    * @dev Fix for the ERC20 short address attack.\\n    */\\n    function totalSupply() public view override virtual returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n    * @dev transfer token for a specified address\\n    * @param _to The address to transfer to.\\n    * @param _value The amount to be transferred.\\n    */\\n    function transfer(address _to, uint _value) override virtual public onlyPayloadSize(2 * 32) returns (bool) {\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Get the balance of the specified address.\\n    * @param _owner The address to query the balance of.\\n    * @return balance An uint representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address _owner) view override public returns (uint balance) {\\n        return balances[_owner];\\n    }\\n\\n    /**\\n    * @dev Transfer tokens from one address to another\\n    * @param _from address The address which you want to send tokens from\\n    * @param _to address The address which you want to transfer to\\n    * @param _value uint the amount of tokens to be transferred\\n    */\\n    function transferFrom(address _from, address _to, uint _value) override virtual public onlyPayloadSize(3 * 32) returns (bool) {\\n        uint _allowance = allowed[_from][msg.sender];\\n        require(_allowance\\u003e=_value,\\\"Not enought allowed amount\\\");\\n        require(_allowance\\u003cMAX_UINT);\\n        allowed[_from][msg.sender] = _allowance.sub(_value);\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n    * @param _spender The address which will spend the funds.\\n    * @param _value The amount of tokens to be spent.\\n    */\\n    function approve(address _spender, uint _value) override public onlyPayloadSize(2 * 32) {\\n        // To change the approve amount you first have to reduce the addresses`\\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\\n        //  already 0 to mitigate the race condition described here:\\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n        require(!((_value != 0) \\u0026\\u0026 (allowed[msg.sender][_spender] != 0)));\\n\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n    }\\n\\n    /**\\n    * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n    * @param _owner address The address which owns the funds.\\n    * @param _spender address The address which will spend the funds.\\n    * @return remaining A uint specifying the amount of tokens still available for the spender.\\n    */\\n    function allowance(address _owner, address _spender) override public view returns (uint remaining) {\\n        return allowed[_owner][_spender];\\n    }\\n\\n}\\n\\n/**\\n * @title OptionsContract\\n * @dev Abstract contract of BAEX options\\n */\\nabstract contract OptionsContract {\\n    function onTransferTokens(address _from, address _to, uint256 _value) public virtual returns (bool);\\n}\\n/* END of: Abstract contracts */\\n\\n/**\\n * @title BAEX\\n * @dev BAEX token contract\\n */\\ncontract BAEX is StandardToken {\\n    address constant internal super_owner = 0x2B2fD898888Fa3A97c7560B5ebEeA959E1Ca161A;\\n    // Fixed point math factor is 10^8\\n    uint256 constant public fmkd = 8;\\n    uint256 constant public fmk = 10**fmkd;\\n    // Burn price ratio is 0.9\\n    uint256 constant burn_ratio = 9 * fmk / 10;\\n    // Burning fee is 5%\\n    uint256 constant burn_fee = 5 * fmk / 100;\\n    // Minimum amount of issue tokens transacion is 0.1 ETH\\n    uint256 constant min_eth_to_send = 10**17;\\n    // Issuing price increase ratio vs locked_amount/supply is 14 %\\n    uint256 public issue_increase_ratio = 140 * fmk / 1000;\\n    \\n\\tstring public name;\\n\\tstring public symbol;\\n\\tuint public decimals;\\n\\t\\n\\tuint256 public issue_price;\\n\\tuint256 public burn_price;\\n\\t\\n\\t// Counters of transactions\\n\\tuint256 public issue_counter;\\n\\tuint256 public burn_counter;\\n\\t\\n\\t// Issued \\u0026 burned volumes\\n\\tuint256 public issued_volume;\\n\\tuint256 public burned_volume;\\n\\t\\n\\t// Bonus pool is 1% from income\\n    uint256 public bonus_pool_perc;\\n    // Bonus pool\\n    uint256 public bonus_pool_eth;\\n    // Bonus sharing start block\\n    uint256 public bonus_sharing_block;\\n    // Share bonus game from min_bonus_pool_eth_amount \\n    uint256 public min_bonus_pool_eth_amount;\\n\\t\\n\\tmapping (address =\\u003e bool) optionsContracts;\\n\\taddress payable referral_program_contract;\\n\\t\\n\\taddress private owner;\\n\\n    /**\\n    * @dev constructor, initialization of starting values\\n    */\\n\\tconstructor() public {\\n\\t\\tname = \\\"Binary Assets EXchange\\\";\\n\\t\\tsymbol = \\\"BAEX\\\";\\n\\t\\tdecimals = 8;\\n\\t\\t\\n\\t\\towner = msg.sender;\\t\\t\\n\\n\\t\\t// Initial Supply of BAEX is ZERO\\n\\t\\t_totalSupply = 0;\\n\\t\\tbalances[address(this)] = _totalSupply;\\n\\t\\t\\n\\t\\t// Initial issue price of BAEX is 0.1 ETH per 1.0 BAEX\\n\\t\\tissue_price = 1 * fmk / 10;\\n\\t\\t\\n\\t\\t// 1% from income to the bonus pool\\n\\t\\tbonus_pool_perc = 1 * fmk / 100;\\n\\t\\t// 2 ETH is the minimum amount to share the bonus pool\\n\\t\\tmin_bonus_pool_eth_amount = 2 * 10**18;\\n\\t\\tbonus_pool_eth = 0;\\n\\t}\\n\\t\\n\\tfunction issuePrice() public view returns (uint256) {\\n\\t\\treturn issue_price;\\n\\t}\\n\\t\\n\\tfunction burnPrice() public view returns (uint256) {\\n\\t\\treturn burn_price;\\n\\t}\\n\\n\\tfunction ethAmountInBonusPool() public view returns (uint256) {\\n\\t\\treturn bonus_pool_eth;\\n\\t}\\n\\t\\n\\t/**\\n    * @dev ERC20 transfer with burning of BAEX when it will be sent to the BAEX smart-contract\\n    * @dev and with the placing liquidity to the binary options when tokens will be sent to the BAEXOptions contracts.\\n    */\\n\\tfunction transfer(address _to, uint256 _value) public override returns (bool) {\\n\\t    require(_to != address(0),\\\"Destination address can\\u0027t be empty\\\");\\n\\t    require(_value \\u003e 0,\\\"Value for transfer should be more than zero\\\");\\n\\t\\tif ( super.transfer(_to, _value) ) {\\n\\t\\t    if ( _to == address(this) ) {\\n    \\t\\t    return burnBAEX( msg.sender, _value );\\n    \\t\\t} else if ( optionsContracts[_to] ) {\\n    \\t\\t    OptionsContract(_to).onTransferTokens( msg.sender, _to, _value );\\n    \\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n    /**\\n    * @dev ERC20 transferFrom with burning of BAEX when it will be sent to the BAEX smart-contract\\n    * @dev and with the placing liquidity to the binary options when tokens will be sent to the BAEXOptions contracts.\\n\\t*/\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {\\n\\t    require(_to != address(0),\\\"Destination address can\\u0027t be empty\\\");\\n\\t    require(_value \\u003e 0,\\\"Value for transfer should be more than zero\\\");\\n\\t\\tif ( super.transferFrom(_from, _to, _value) ) {\\n\\t\\t    if ( _to == address(this) ) {\\n    \\t\\t    return burnBAEX( _from, _value );\\n    \\t\\t} else if ( optionsContracts[_to] ) {\\n    \\t\\t    OptionsContract(_to).onTransferTokens( _from, _to, _value );\\n    \\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n    /**\\n    * @dev This helper function is used by BAEXOptions smart-contracts to operate with the liquidity pool of options.\\n\\t*/\\n\\tfunction transferOptions(address _from, address _to, uint256 _value, bool _burn_to_eth) public returns (bool) {\\n\\t    require( optionsContracts[msg.sender], \\\"Only options contracts can call it\\\" );\\n\\t    require(_to != address(0),\\\"Destination address can\\u0027t be empty\\\");\\n\\t\\trequire(_value \\u003c= balances[_from], \\\"Not enought balance to transfer\\\");\\n\\n\\t\\tif (_burn_to_eth) {\\n\\t\\t    balances[_from] = balances[_from].sub(_value);\\n\\t\\t    balances[address(this)] = balances[address(this)].add(_value);\\n\\t\\t    emit Transfer( _from, _to, _value );\\n\\t\\t    emit Transfer( _to, address(this), _value );\\n\\t\\t    return burnBAEX( _to, _value );\\n\\t\\t} else {\\n\\t\\t    balances[_from] = balances[_from].sub(_value);\\n\\t\\t    balances[_to] = balances[_to].add(_value);\\n\\t\\t    emit Transfer( _from, _to, _value );\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t/**\\n    * @dev Try to share the bonus with the address which is issuing or burning the tokens.\\n\\t*/\\n\\tfunction tryToGetBonus(address _to_address, uint256 _eth_amount) private returns (bool) {\\n\\t    if ( bonus_sharing_block == 0 ) {\\n\\t        if ( bonus_pool_eth \\u003e= min_bonus_pool_eth_amount ) {\\n\\t            bonus_sharing_block = block.number + 10;\\n\\t            log2(bytes20(address(this)),bytes16(\\\"BONUS AVAILABLE\\\"),bytes32(bonus_sharing_block));\\n\\t        }\\n\\t        return false;\\n\\t    }\\n\\t    if ( block.number \\u003c bonus_sharing_block ) return false;\\n\\t    if ( block.number \\u003c bonus_sharing_block+10 ) {\\n            if ( _eth_amount \\u003c bonus_pool_eth / 5 ) return false;\\n\\t    } else _to_address = owner;\\n\\t    payable(_to_address).transfer(bonus_pool_eth);\\n        log3(bytes20(address(this)),bytes16(\\\"BONUS\\\"),bytes20(_to_address),bytes32(bonus_pool_eth));\\n\\t    bonus_sharing_block = 0;\\n\\t    bonus_pool_eth = 0;\\n\\t    return true;\\n\\t}\\n\\t\\n\\t/**\\n    * @dev Recalc issuing and burning prices\\n\\t*/\\n    function recalcPrices() private {\\n        issue_price = ( (address(this).balance-bonus_pool_eth) / 10**(18-fmkd) * fmk ) / _totalSupply;\\n\\t    burn_price = issue_price * burn_ratio / fmk;\\n\\t    issue_price = issue_price + issue_price * issue_increase_ratio / fmk;\\n    }\\n\\t\\n\\t/**\\n    * @dev Issue the BAEX tokens when someone sends Ethereum to hold on smart-contract.\\n\\t*/\\n\\tfunction issueBAEX(address _to_address, uint256 _eth_amount, address _partner) private returns (bool){\\n\\t    uint256 tokens_to_issue = ( _eth_amount / 10**(18-fmkd) ) * fmk / issue_price;\\n\\t    // Increase the total supply\\n\\t    _totalSupply = _totalSupply.add( tokens_to_issue );\\n\\t    balances[_to_address] = balances[_to_address].add( tokens_to_issue );\\n\\t    // Add bonus_pool_perc from eth_amount to bonus_pool_eth\\n\\t    bonus_pool_eth = bonus_pool_eth + _eth_amount * bonus_pool_perc / fmk;\\n\\t    tryToGetBonus( _to_address, _eth_amount );\\n\\t    // Recalculate issuing \\u0026 burning prices after tokens issue\\n\\t    recalcPrices();\\n\\t    //---------------------------------\\n\\t    emit Transfer(address(0x0), address(this), tokens_to_issue);\\n\\t    emit Transfer(address(this), _to_address, tokens_to_issue);\\n\\t    if (address(referral_program_contract) != address(0) \\u0026\\u0026 _partner != address(0)) {\\n\\t        BAEXReferral(referral_program_contract).onIssueTokens( _to_address, _partner, _eth_amount);\\n\\t    }\\n\\t    issue_counter++;\\n\\t    issued_volume = issued_volume + tokens_to_issue;\\n\\t    log3(bytes20(address(this)),bytes8(\\\"ISSUE\\\"),bytes32(_totalSupply),bytes32( (issue_price\\u003c\\u003c128) | burn_price ));\\n\\t    return true;\\n\\t}\\n\\t\\n\\t/**\\n    * @dev Burn the BAEX tokens when someone sends BAEX to the BAEX token smart-contract.\\n\\t*/\\n\\tfunction burnBAEX(address _from_address, uint256 tokens_to_burn) private returns (bool){\\n\\t    require( _totalSupply \\u003e= tokens_to_burn, \\\"Not enought supply to burn\\\");\\n\\t    uint256 contract_balance = address(this).balance-bonus_pool_eth;\\n\\t    uint256 eth_to_send = tokens_to_burn * burn_price / fmk * 10**(18-decimals);\\n\\t    require( eth_to_send \\u003e= 10**17, \\\"Minimum ETH equity to burn is 0.1 ETH\\\" );\\n\\t    require( ( contract_balance + 10**13 ) \\u003e= eth_to_send, \\\"Not enought ETH on the contract to burn tokens\\\" );\\n\\t    if ( eth_to_send \\u003e contract_balance ) {\\n\\t        eth_to_send = contract_balance;\\n\\t    }\\n\\t    uint256 fees_eth = eth_to_send * burn_fee / fmk;\\n\\t    // Decrease the total supply\\n\\t    _totalSupply = _totalSupply.sub(tokens_to_burn);\\n\\t    payable(_from_address).transfer(eth_to_send-fees_eth);\\n\\t    payable(owner).transfer(fees_eth);\\n\\t    tryToGetBonus(_from_address,eth_to_send);\\n\\t    contract_balance = contract_balance.sub( eth_to_send );\\n\\t    balances[address(this)] = balances[address(this)] - tokens_to_burn;\\n\\t    if ( _totalSupply == 0 ) {\\n\\t        // When all tokens were burned ðŸ™‚ it\\u0027s unreal, but we are good coders\\n\\t        burn_price = 0;\\n\\t        payable(super_owner).transfer(address(this).balance);\\n\\t    } else {\\n\\t        // Recalculate issuing \\u0026 burning prices after the burning\\n\\t        recalcPrices();\\n\\t    }\\n\\t    emit Transfer(address(this), address(0x0), tokens_to_burn);\\n\\t    burn_counter++;\\n\\t    burned_volume = burned_volume + tokens_to_burn;\\n\\t    log3(bytes20(address(this)),bytes4(\\\"BURN\\\"),bytes32(_totalSupply),bytes32( (issue_price\\u003c\\u003c128) | burn_price ));\\n\\t    return true;\\n\\t}\\n\\t\\n\\t/**\\n    * @dev Payable function to issue tokens with referral partner param\\n\\t*/\\n\\tfunction issueTokens(address _partner) external payable {\\n\\t    require(msg.value \\u003e= min_eth_to_send,\\\"This contract have minimum amount to send (0.1 ETH)\\\");\\n\\t    if (!optionsContracts[msg.sender]) issueBAEX( msg.sender, msg.value, _partner );\\n\\t}\\n\\t\\n    /**\\n    * @dev Default payable function to issue tokens\\n\\t*/\\n    receive() external payable  {\\n\\t    require(msg.value \\u003e= min_eth_to_send,\\\"This contract have minimum amount to send (0.1 ETH)\\\");\\n\\t    if (!optionsContracts[msg.sender]) issueBAEX( msg.sender, msg.value, address(0) );\\n\\t}\\n\\t\\n\\t/**\\n    * @dev This function can transfer any of the wrongs sent ERC20 tokens to the contract\\n\\t*/\\n\\tfunction transferWrongSendedERC20FromContract(address _contract) public {\\n\\t    require( _contract != address(this), \\\"Transfer of BAEX token is forbiden\\\");\\n\\t    require( msg.sender == super_owner, \\\"Your are not super owner\\\");\\n\\t    ERC20(_contract).transfer( super_owner, ERC20(_contract).balanceOf(address(this)) );\\n\\t}\\n\\t\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\tmodifier onlyOwner() {\\n\\t\\trequire( (msg.sender == owner) || (msg.sender == super_owner), \\\"You don\\u0027t have permissions to call it\\\" );\\n\\t\\t_;\\n\\t}\\n\\t\\n\\tfunction setOptionsContract(address _optionsContract, bool _enabled) public onlyOwner() {\\n\\t\\toptionsContracts[_optionsContract] = _enabled;\\n\\t}\\n\\t\\n\\tfunction setBonusParams(uint256 _bonus_pool_perc, uint256 _min_bonus_pool_eth_amount) public onlyOwner() {\\n\\t    bonus_pool_perc = _bonus_pool_perc;\\n\\t    min_bonus_pool_eth_amount = _min_bonus_pool_eth_amount;\\n\\t}\\n\\t\\n\\tfunction setreferralProgramContract(address _referral_program_contract) public onlyOwner() {\\n\\t\\treferral_program_contract = payable(_referral_program_contract);\\n\\t}\\n\\t\\n\\tfunction transferOwnership(address newOwner) public onlyOwner {\\n\\t\\trequire(newOwner != address(0));\\n\\t\\temit OwnershipTransferred(owner, newOwner);\\n\\t\\towner = newOwner;\\n\\t}\\t\\n}\\n\\n/**\\n * @title BAEXReferral\\n * @dev BAEX referral program smart-contract\\n */\\ncontract BAEXReferral {\\n    address constant internal super_owner = 0x2B2fD898888Fa3A97c7560B5ebEeA959E1Ca161A;\\n    uint256 constant public fmkd = 8;\\n    uint256 constant public fmk = 10**fmkd;\\n    \\n    address private owner;\\n    address payable baex;\\n    \\n    string public name;\\n    uint256 public referral_percent;\\n    \\n    mapping (address =\\u003e address) partners;\\n    mapping (address =\\u003e uint256) referral_balance;\\n    \\n    constructor() public {\\n\\t\\tname = \\\"BAEX Partners Program\\\";\\n\\t\\t// Default referral percent is 4%\\n\\t\\treferral_percent = 4 * fmk / 100;\\n\\t\\towner = msg.sender;\\n    }\\n    \\n    function balanceOf(address _sender) public view returns (uint256 balance) {\\n\\t\\treturn referral_balance[_sender];\\n\\t}\\n    \\n    /**\\n    * @dev When someone issues BAEX tokens, 4% from the ETH amount will be transferred from\\n\\t* @dev the BAEXReferral smart-contract to his referral partner.\\n    * @dev Read more about referral program at https://baex.com/#referral\\n    */\\n    function onIssueTokens(address _issuer, address _partner, uint256 _eth_amount) public {\\n        require( msg.sender == baex, \\\"Only token contract can call it\\\" );\\n        address partner = partners[_issuer];\\n        if ( partner == address(0) ) {\\n            if ( _partner == address(0) ) return;\\n            partners[_issuer] = _partner;\\n            partner = _partner;\\n        }\\n        uint256 eth_to_trans = _eth_amount * referral_percent / fmk;\\n        if (eth_to_trans == 0) return;\\n        if ( address(this).balance \\u003e= eth_to_trans ) {\\n            payable(_partner).transfer(eth_to_trans);\\n        } else {\\n            referral_balance[_partner] = referral_balance[_partner] + eth_to_trans;\\n        }\\n        uint256 log_record = ( _eth_amount \\u003c\\u003c 128 ) | eth_to_trans;\\n        log4(bytes32(uint256(address(baex))),bytes16(\\\"referral PAYMENT\\\"),bytes32(uint256(_issuer)),bytes32(uint256(_partner)),bytes32(log_record));\\n    }\\n    \\n    function setreferralPercent(uint256 _referral_percent) public onlyOwner() {\\n\\t\\treferral_percent = _referral_percent;\\n\\t}\\n    \\n    modifier onlyOwner() {\\n\\t\\trequire( (msg.sender == owner) || (msg.sender == super_owner) );\\n\\t\\t_;\\n\\t}\\n    \\n    function setTokenAddress(address _token_address) public onlyOwner {\\n\\t    baex = payable(_token_address);\\n\\t}\\n\\t\\n\\tfunction transferOwnership(address newOwner) public onlyOwner {\\n\\t\\trequire(newOwner != address(0));\\n\\t\\towner = newOwner;\\n\\t}\\n\\t\\n\\t/**\\n    * @dev If the referral partner sends any amount of ETH to the contract, he/she will receive ETH back\\n\\t* @dev and receive earned balance in the BAEX referral program.\\n    * @dev Read more about referral program at https://baex.com/#referral\\n    */\\n\\treceive() external payable  {\\n\\t    if ( (msg.sender == owner) || (msg.sender == super_owner) ) {\\n\\t        if ( msg.value == 10**16) {\\n\\t            payable(super_owner).transfer(address(this).balance);\\n\\t        }\\n\\t        return;\\n\\t    }\\n\\t    uint256 eth_to_send = msg.value;\\n\\t    if (referral_balance[msg.sender]\\u003e0) {\\n\\t        uint256 ref_eth_to_trans = referral_balance[msg.sender];\\n\\t        if ( (address(this).balance-msg.value) \\u003e= ref_eth_to_trans ) {\\n\\t            eth_to_send = eth_to_send + ref_eth_to_trans;\\n\\t        }\\n\\t    }\\n\\t    msg.sender.transfer(eth_to_send);\\n\\t}\\n\\t\\n\\t/**\\n    * @dev This function can transfer any of the wrongs sent ERC20 tokens to the contract\\n\\t*/\\n\\tfunction transferWrongSendedERC20FromContract(address _contract) public {\\n\\t    require( _contract != address(this), \\\"Transfer of BAEX token is forbiden\\\");\\n\\t    require( msg.sender == super_owner, \\\"Your are not super owner\\\");\\n\\t    ERC20(_contract).transfer( super_owner, ERC20(_contract).balanceOf(address(this)) );\\n\\t}\\n}\\n/* END of: BAEXReferral - referral program smart-contract */\\n\\n// SPDX-License-Identifier: UNLICENSED\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_instrument\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"_block_number\",\"type\":\"uint64\"}],\"name\":\"_processTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fmk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gas_for_process\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinMaxTradeVol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"name\":\"instrumentRates\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"liquidityBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_balancing_mul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_in\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_perc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_perc_normal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_pool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_pool_blocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_ratio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_period\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_trade_vol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"min_period\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"min_trade_vol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"num_of_trades\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"onTransferTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_instrument_ts_rates\",\"type\":\"uint256\"}],\"name\":\"oracleStoreRates2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_instrument_and_ts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rates\",\"type\":\"uint256\"}],\"name\":\"oracleStoreRates4\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"trade_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_instrument_ts_rates\",\"type\":\"uint256\"}],\"name\":\"oracleStoreRatesAndProcessTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle_fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"period_divider\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vol\",\"type\":\"uint256\"}],\"name\":\"placeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_instrument\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_vol\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_direction\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_trade_timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"_period\",\"type\":\"uint16\"}],\"name\":\"placeTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_instrument\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"_block_number\",\"type\":\"uint64\"}],\"name\":\"processTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processing_fees_percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recalc_max_trade_vol\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_period_divider\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_min_period\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_max_period\",\"type\":\"uint32\"}],\"name\":\"setPeriodParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_address\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min_trade_vol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_trade_vol\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_recalc_max_trade_vol\",\"type\":\"bool\"}],\"name\":\"setTradeVol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_instrument_id\",\"type\":\"uint16\"},{\"internalType\":\"bytes16\",\"name\":\"_ticker\",\"type\":\"bytes16\"}],\"name\":\"setValidInstrument\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"trades\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"params\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"result_vol\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"result\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"transferWrongSendedERC20FromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"valid_instruments\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vol\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_burn_to_eth\",\"type\":\"bool\"}],\"name\":\"withdrawLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vol\",\"type\":\"uint256\"}],\"name\":\"withdrawOracleFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BAEXOptions","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e1d9d04abee1939d1c636f6511b291c16639bd3dffff5fe507b6464917ed5814"}]}