{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/sol6/IERC20.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function decimals() external view returns (uint8 digits);\r\n\r\n    function totalSupply() external view returns (uint256 supply);\r\n}\r\n\r\n\r\n// to support backward compatible contract name -- so function signature remains same\r\nabstract contract ERC20 is IERC20 {\r\n\r\n}\r\n\r\n// File: contracts/sol6/utils/Utils5.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n/**\r\n * @title Kyber utility file\r\n * mostly shared constants and rate calculation helpers\r\n * inherited by most of kyber contracts.\r\n * previous utils implementations are for previous solidity versions.\r\n */\r\ncontract Utils5 {\r\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n    );\r\n    uint256 internal constant PRECISION = (10**18);\r\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\r\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\r\n    uint256 internal constant MAX_DECIMALS = 18;\r\n    uint256 internal constant ETH_DECIMALS = 18;\r\n    uint256 constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\r\n    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\r\n\r\n    mapping(IERC20 => uint256) internal decimals;\r\n\r\n    function getUpdateDecimals(IERC20 token) internal returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) {\r\n            tokenDecimals = token.decimals();\r\n            decimals[token] = tokenDecimals;\r\n        }\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function setDecimals(IERC20 token) internal {\r\n        if (decimals[token] != 0) return; //already set\r\n\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            decimals[token] = ETH_DECIMALS;\r\n        } else {\r\n            decimals[token] = token.decimals();\r\n        }\r\n    }\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(IERC20 token, address user) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            return user.balance;\r\n        } else {\r\n            return token.balanceOf(user);\r\n        }\r\n    }\r\n\r\n    function getDecimals(IERC20 token) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDestAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 destAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcDstQty(\r\n        uint256 srcQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(srcQty <= MAX_QTY, \"srcQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(\r\n        uint256 dstQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(dstQty <= MAX_QTY, \"dstQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint256 numerator;\r\n        uint256 denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcRateFromQty(\r\n        uint256 srcAmount,\r\n        uint256 destAmount,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals\r\n    ) internal pure returns (uint256) {\r\n        require(srcAmount <= MAX_QTY, \"srcAmount > MAX_QTY\");\r\n        require(destAmount <= MAX_QTY, \"destAmount > MAX_QTY\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\r\n        }\r\n    }\r\n\r\n    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/utils/zeppelin/ReentrancyGuard.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/Dao/IEpochUtils.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface IEpochUtils {\r\n    function epochPeriodInSeconds() external view returns (uint256);\r\n\r\n    function firstEpochStartTimestamp() external view returns (uint256);\r\n\r\n    function getCurrentEpochNumber() external view returns (uint256);\r\n\r\n    function getEpochNumber(uint256 timestamp) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/IKyberDao.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberDao is IEpochUtils {\r\n    event Voted(address indexed staker, uint indexed epoch, uint indexed campaignID, uint option);\r\n\r\n    function getLatestNetworkFeeDataWithCache()\r\n        external\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\r\n\r\n    function getLatestBRRDataWithCache()\r\n        external\r\n        returns (\r\n            uint256 burnInBps,\r\n            uint256 rewardInBps,\r\n            uint256 rebateInBps,\r\n            uint256 epoch,\r\n            uint256 expiryTimestamp\r\n        );\r\n\r\n    function handleWithdrawal(address staker, uint256 penaltyAmount) external;\r\n\r\n    function vote(uint256 campaignID, uint256 option) external;\r\n\r\n    function getLatestNetworkFeeData()\r\n        external\r\n        view\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\r\n\r\n    function shouldBurnRewardForEpoch(uint256 epoch) external view returns (bool);\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for a past epoch only\r\n     *       fee handler should call this function when a staker wants to claim reward\r\n     *       return 0 if staker has no votes or stakes\r\n     */\r\n    function getPastEpochRewardPercentageInPrecision(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for the current epoch\r\n     *       reward percentage is not finalized until the current epoch is ended\r\n     */\r\n    function getCurrentEpochRewardPercentageInPrecision(address staker)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/IKyberFeeHandler.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberFeeHandler {\r\n    event RewardPaid(address indexed staker, uint256 indexed epoch, IERC20 indexed token, uint256 amount);\r\n    event RebatePaid(address indexed rebateWallet, IERC20 indexed token, uint256 amount);\r\n    event PlatformFeePaid(address indexed platformWallet, IERC20 indexed token, uint256 amount);\r\n    event KncBurned(uint256 kncTWei, IERC20 indexed token, uint256 amount);\r\n\r\n    function handleFees(\r\n        IERC20 token,\r\n        address[] calldata eligibleWallets,\r\n        uint256[] calldata rebatePercentages,\r\n        address platformWallet,\r\n        uint256 platformFee,\r\n        uint256 networkFee\r\n    ) external payable;\r\n\r\n    function claimReserveRebate(address rebateWallet) external returns (uint256);\r\n\r\n    function claimPlatformFee(address platformWallet) external returns (uint256);\r\n\r\n    function claimStakerReward(\r\n        address staker,\r\n        uint256 epoch\r\n    ) external returns(uint amount);\r\n}\r\n\r\n// File: contracts/sol6/IKyberNetworkProxy.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberNetworkProxy {\r\n\r\n    event ExecuteTrade(\r\n        address indexed trader,\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        address destAddress,\r\n        uint256 actualSrcAmount,\r\n        uint256 actualDestAmount,\r\n        address platformWallet,\r\n        uint256 platformFeeBps\r\n    );\r\n\r\n    /// @notice backward compatible\r\n    function tradeWithHint(\r\n        ERC20 src,\r\n        uint256 srcAmount,\r\n        ERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable walletId,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256);\r\n\r\n    function tradeWithHintAndFee(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256 destAmount);\r\n\r\n    function trade(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet\r\n    ) external payable returns (uint256);\r\n\r\n    /// @notice backward compatible\r\n    /// @notice Rate units (10 ** 18) => destQty (twei) / srcQty (twei) * 10 ** 18\r\n    function getExpectedRate(\r\n        ERC20 src,\r\n        ERC20 dest,\r\n        uint256 srcQty\r\n    ) external view returns (uint256 expectedRate, uint256 worstRate);\r\n\r\n    function getExpectedRateAfterFee(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external view returns (uint256 expectedRate);\r\n}\r\n\r\n// File: contracts/sol6/ISimpleKyberProxy.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n/*\r\n * @title simple Kyber Network proxy interface\r\n * add convenient functions to help with kyber proxy API\r\n */\r\ninterface ISimpleKyberProxy {\r\n    function swapTokenToEther(\r\n        IERC20 token,\r\n        uint256 srcAmount,\r\n        uint256 minConversionRate\r\n    ) external returns (uint256 destAmount);\r\n\r\n    function swapEtherToToken(IERC20 token, uint256 minConversionRate)\r\n        external\r\n        payable\r\n        returns (uint256 destAmount);\r\n\r\n    function swapTokenToToken(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        uint256 minConversionRate\r\n    ) external returns (uint256 destAmount);\r\n}\r\n\r\n// File: contracts/sol6/IBurnableToken.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IBurnableToken {\r\n    function burn(uint256 _value) external returns (bool);\r\n}\r\n\r\n// File: contracts/sol6/Dao/ISanityRate.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n/// @title Sanity Rate check to prevent burning knc with too expensive or cheap price\r\n/// @dev Using ChainLink as the provider for current knc/eth price\r\ninterface ISanityRate {\r\n    // return latest rate of knc/eth\r\n    function latestAnswer() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/utils/zeppelin/SafeMath.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/Dao/DaoOperator.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract DaoOperator {\r\n    address public daoOperator;\r\n\r\n    constructor(address _daoOperator) public {\r\n        require(_daoOperator != address(0), \"daoOperator is 0\");\r\n        daoOperator = _daoOperator;\r\n    }\r\n\r\n    modifier onlyDaoOperator() {\r\n        require(msg.sender == daoOperator, \"only daoOperator\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/Dao/KyberFeeHandler.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title IKyberProxy\r\n *  This interface combines two interfaces.\r\n *  It is needed since we use one function from each of the interfaces.\r\n *\r\n */\r\ninterface IKyberProxy is IKyberNetworkProxy, ISimpleKyberProxy {\r\n    // empty block\r\n}\r\n\r\n\r\n/**\r\n * @title kyberFeeHandler\r\n *\r\n * @dev kyberFeeHandler works tightly with contracts kyberNetwork and kyberDao.\r\n *      Some events are moved to interface, for easier usage\r\n * @dev Terminology:\r\n *          Epoch - Voting campaign time frame in kyberDao.\r\n *              kyberDao voting campaigns are in the scope of epochs.\r\n *          BRR - Burn / Reward / Rebate. kyberNetwork fee is used for 3 purposes:\r\n *              Burning KNC\r\n *              Reward an address that staked knc in kyberStaking contract. AKA - stakers\r\n *              Rebate reserves for supporting trades.\r\n * @dev Code flow:\r\n *      1. Accumulating && claiming Fees. Per trade on kyberNetwork, it calls handleFees() function which\r\n *          internally accounts for network & platform fees from the trade. Fee distribution:\r\n *              rewards: accumulated per epoch. can be claimed by the kyberDao after epoch is concluded.\r\n *              rebates: accumulated per rebate wallet, can be claimed any time.\r\n *              Burn: accumulated in the contract. Burned value and interval limited with safe check using\r\n                    sanity rate.\r\n *              Platfrom fee: accumulated per platform wallet, can be claimed any time.\r\n *      2. Network Fee distribution: Per epoch kyberFeeHandler contract reads BRR distribution percentage \r\n *          from kyberDao. When the data expires, kyberFeeHandler reads updated values.\r\n */\r\ncontract KyberFeeHandler is IKyberFeeHandler, Utils5, DaoOperator, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant DEFAULT_REWARD_BPS = 3000;\r\n    uint256 internal constant DEFAULT_REBATE_BPS = 3000;\r\n    uint256 internal constant SANITY_RATE_DIFF_BPS = 1000; // 10%\r\n\r\n    struct BRRData {\r\n        uint64 expiryTimestamp;\r\n        uint32 epoch;\r\n        uint16 rewardBps;\r\n        uint16 rebateBps;\r\n    }\r\n\r\n    struct BRRWei {\r\n        uint256 rewardWei;\r\n        uint256 fullRebateWei;\r\n        uint256 paidRebateWei;\r\n        uint256 burnWei;\r\n    }\r\n\r\n    IKyberDao public kyberDao;\r\n    IKyberProxy public kyberProxy;\r\n    address public kyberNetwork;\r\n    IERC20 public immutable knc;\r\n\r\n    uint256 public immutable burnBlockInterval;\r\n    uint256 public lastBurnBlock;\r\n\r\n    BRRData public brrAndEpochData;\r\n    address public daoSetter;\r\n\r\n    /// @dev amount of eth to burn for each burn knc call\r\n    uint256 public weiToBurn = 2 ether;\r\n\r\n    mapping(address => uint256) public feePerPlatformWallet;\r\n    mapping(address => uint256) public rebatePerWallet;\r\n    mapping(uint256 => uint256) public rewardsPerEpoch;\r\n    mapping(uint256 => uint256) public rewardsPaidPerEpoch;\r\n    // hasClaimedReward[staker][epoch]: true/false if the staker has/hasn't claimed the reward for an epoch\r\n    mapping(address => mapping (uint256 => bool)) public hasClaimedReward;\r\n    uint256 public totalPayoutBalance; // total balance in the contract that is for rebate, reward, platform fee\r\n\r\n    /// @dev use to get rate of KNC/ETH to check if rate to burn knc is normal\r\n    /// @dev index 0 is currently used contract address, indexes > 0 are older versions\r\n    ISanityRate[] internal sanityRateContract;\r\n\r\n    event FeeDistributed(\r\n        IERC20 indexed token,\r\n        address indexed platformWallet,\r\n        uint256 platformFeeWei,\r\n        uint256 rewardWei,\r\n        uint256 rebateWei,\r\n        address[] rebateWallets,\r\n        uint256[] rebatePercentBpsPerWallet,\r\n        uint256 burnAmtWei\r\n    );\r\n\r\n    event BRRUpdated(\r\n        uint256 rewardBps,\r\n        uint256 rebateBps,\r\n        uint256 burnBps,\r\n        uint256 expiryTimestamp,\r\n        uint256 indexed epoch\r\n    );\r\n\r\n    event EthReceived(uint256 amount);\r\n    event KyberDaoAddressSet(IKyberDao kyberDao);\r\n    event BurnConfigSet(ISanityRate sanityRate, uint256 weiToBurn);\r\n    event RewardsRemovedToBurn(uint256 indexed epoch, uint256 rewardsWei);\r\n    event KyberNetworkUpdated(address kyberNetwork);\r\n    event KyberProxyUpdated(IKyberProxy kyberProxy);\r\n\r\n    constructor(\r\n        address _daoSetter,\r\n        IKyberProxy _kyberProxy,\r\n        address _kyberNetwork,\r\n        IERC20 _knc,\r\n        uint256 _burnBlockInterval,\r\n        address _daoOperator\r\n    ) public DaoOperator(_daoOperator) {\r\n        require(_daoSetter != address(0), \"daoSetter 0\");\r\n        require(_kyberProxy != IKyberProxy(0), \"kyberNetworkProxy 0\");\r\n        require(_kyberNetwork != address(0), \"kyberNetwork 0\");\r\n        require(_knc != IERC20(0), \"knc 0\");\r\n        require(_burnBlockInterval != 0, \"_burnBlockInterval 0\");\r\n\r\n        daoSetter = _daoSetter;\r\n        kyberProxy = _kyberProxy;\r\n        kyberNetwork = _kyberNetwork;\r\n        knc = _knc;\r\n        burnBlockInterval = _burnBlockInterval;\r\n\r\n        //start with epoch 0\r\n        updateBRRData(DEFAULT_REWARD_BPS, DEFAULT_REBATE_BPS, now, 0);\r\n    }\r\n\r\n    modifier onlyKyberDao {\r\n        require(msg.sender == address(kyberDao), \"only kyberDao\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyKyberNetwork {\r\n        require(msg.sender == address(kyberNetwork), \"only kyberNetwork\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyNonContract {\r\n        require(tx.origin == msg.sender, \"only non-contract\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit EthReceived(msg.value);\r\n    }\r\n\r\n    /// @dev handleFees function is called per trade on kyberNetwork. unless the trade is not involving any fees.\r\n    /// @param token Token currency of fees\r\n    /// @param rebateWallets a list of rebate wallets that will get rebate for this trade.\r\n    /// @param rebateBpsPerWallet percentage of rebate for each wallet, out of total rebate.\r\n    /// @param platformWallet Wallet address that will receive the platfrom fee.\r\n    /// @param platformFee Fee amount (in wei) the platfrom wallet is entitled to.\r\n    /// @param networkFee Fee amount (in wei) to be allocated for BRR\r\n    function handleFees(\r\n        IERC20 token,\r\n        address[] calldata rebateWallets,\r\n        uint256[] calldata rebateBpsPerWallet,\r\n        address platformWallet,\r\n        uint256 platformFee,\r\n        uint256 networkFee\r\n    ) external payable override onlyKyberNetwork nonReentrant {\r\n        require(token == ETH_TOKEN_ADDRESS, \"token not eth\");\r\n        require(msg.value == platformFee.add(networkFee), \"msg.value not equal to total fees\");\r\n\r\n        // handle platform fee\r\n        feePerPlatformWallet[platformWallet] = feePerPlatformWallet[platformWallet].add(\r\n            platformFee\r\n        );\r\n\r\n        if (networkFee == 0) {\r\n            // only platform fee paid\r\n            totalPayoutBalance = totalPayoutBalance.add(platformFee);\r\n            emit FeeDistributed(\r\n                ETH_TOKEN_ADDRESS,\r\n                platformWallet,\r\n                platformFee,\r\n                0,\r\n                0,\r\n                rebateWallets,\r\n                rebateBpsPerWallet,\r\n                0\r\n            );\r\n            return;\r\n        }\r\n\r\n        BRRWei memory brrAmounts;\r\n        uint256 epoch;\r\n\r\n        // Decoding BRR data\r\n        (brrAmounts.rewardWei, brrAmounts.fullRebateWei, epoch) = getRRWeiValues(networkFee);\r\n\r\n        brrAmounts.paidRebateWei = updateRebateValues(\r\n            brrAmounts.fullRebateWei, rebateWallets, rebateBpsPerWallet\r\n        );\r\n        brrAmounts.rewardWei = brrAmounts.rewardWei.add(\r\n            brrAmounts.fullRebateWei.sub(brrAmounts.paidRebateWei)\r\n        );\r\n\r\n        rewardsPerEpoch[epoch] = rewardsPerEpoch[epoch].add(brrAmounts.rewardWei);\r\n\r\n        // update total balance of rewards, rebates, fee\r\n        totalPayoutBalance = totalPayoutBalance.add(\r\n            platformFee).add(brrAmounts.rewardWei).add(brrAmounts.paidRebateWei\r\n        );\r\n\r\n        brrAmounts.burnWei = networkFee.sub(brrAmounts.rewardWei).sub(brrAmounts.paidRebateWei);\r\n        emit FeeDistributed(\r\n            ETH_TOKEN_ADDRESS,\r\n            platformWallet,\r\n            platformFee,\r\n            brrAmounts.rewardWei,\r\n            brrAmounts.paidRebateWei,\r\n            rebateWallets,\r\n            rebateBpsPerWallet,\r\n            brrAmounts.burnWei\r\n        );\r\n    }\r\n\r\n    /// @notice  WARNING When staker address is a contract,\r\n    ///          it should be able to receive claimed reward in ETH whenever anyone calls this function.\r\n    /// @dev not revert if already claimed or reward percentage is 0\r\n    ///      allow writing a wrapper to claim for multiple epochs\r\n    /// @param staker address.\r\n    /// @param epoch for which epoch the staker is claiming the reward\r\n    function claimStakerReward(\r\n        address staker,\r\n        uint256 epoch\r\n    ) external override nonReentrant returns(uint256 amountWei) {\r\n        if (hasClaimedReward[staker][epoch]) {\r\n            // staker has already claimed reward for the epoch\r\n            return 0;\r\n        }\r\n\r\n        // the relative part of the reward the staker is entitled to for the epoch.\r\n        // units Precision: 10 ** 18 = 100%\r\n        // if the epoch is current or in the future, kyberDao will return 0 as result\r\n        uint256 percentageInPrecision = kyberDao.getPastEpochRewardPercentageInPrecision(staker, epoch);\r\n        if (percentageInPrecision == 0) {\r\n            return 0; // not revert, in case a wrapper wants to claim reward for multiple epochs\r\n        }\r\n        require(percentageInPrecision <= PRECISION, \"percentage too high\");\r\n\r\n        // Amount of reward to be sent to staker\r\n        amountWei = rewardsPerEpoch[epoch].mul(percentageInPrecision).div(PRECISION);\r\n\r\n        // redundant check, can't happen\r\n        assert(totalPayoutBalance >= amountWei);\r\n        assert(rewardsPaidPerEpoch[epoch].add(amountWei) <= rewardsPerEpoch[epoch]);\r\n        \r\n        rewardsPaidPerEpoch[epoch] = rewardsPaidPerEpoch[epoch].add(amountWei);\r\n        totalPayoutBalance = totalPayoutBalance.sub(amountWei);\r\n\r\n        hasClaimedReward[staker][epoch] = true;\r\n\r\n        // send reward to staker\r\n        (bool success, ) = staker.call{value: amountWei}(\"\");\r\n        require(success, \"staker rewards transfer failed\");\r\n\r\n        emit RewardPaid(staker, epoch, ETH_TOKEN_ADDRESS, amountWei);\r\n    }\r\n\r\n    /// @dev claim rebate per reserve wallet. called by any address\r\n    /// @param rebateWallet the wallet to claim rebates for. Total accumulated rebate sent to this wallet.\r\n    /// @return amountWei amount of rebate claimed\r\n    function claimReserveRebate(address rebateWallet) \r\n        external \r\n        override \r\n        nonReentrant \r\n        returns (uint256 amountWei) \r\n    {\r\n        require(rebatePerWallet[rebateWallet] > 1, \"no rebate to claim\");\r\n        // Get total amount of rebate accumulated\r\n        amountWei = rebatePerWallet[rebateWallet].sub(1);\r\n\r\n        // redundant check, can't happen\r\n        assert(totalPayoutBalance >= amountWei);\r\n        totalPayoutBalance = totalPayoutBalance.sub(amountWei);\r\n\r\n        rebatePerWallet[rebateWallet] = 1; // avoid zero to non zero storage cost\r\n\r\n        // send rebate to rebate wallet\r\n        (bool success, ) = rebateWallet.call{value: amountWei}(\"\");\r\n        require(success, \"rebate transfer failed\");\r\n\r\n        emit RebatePaid(rebateWallet, ETH_TOKEN_ADDRESS, amountWei);\r\n\r\n        return amountWei;\r\n    }\r\n\r\n    /// @dev claim accumulated fee per platform wallet. Called by any address\r\n    /// @param platformWallet the wallet to claim fee for. Total accumulated fee sent to this wallet.\r\n    /// @return amountWei amount of fee claimed\r\n    function claimPlatformFee(address platformWallet)\r\n        external\r\n        override\r\n        nonReentrant\r\n        returns (uint256 amountWei)\r\n    {\r\n        require(feePerPlatformWallet[platformWallet] > 1, \"no fee to claim\");\r\n        // Get total amount of fees accumulated\r\n        amountWei = feePerPlatformWallet[platformWallet].sub(1);\r\n\r\n        // redundant check, can't happen\r\n        assert(totalPayoutBalance >= amountWei);\r\n        totalPayoutBalance = totalPayoutBalance.sub(amountWei);\r\n\r\n        feePerPlatformWallet[platformWallet] = 1; // avoid zero to non zero storage cost\r\n\r\n        (bool success, ) = platformWallet.call{value: amountWei}(\"\");\r\n        require(success, \"platform fee transfer failed\");\r\n\r\n        emit PlatformFeePaid(platformWallet, ETH_TOKEN_ADDRESS, amountWei);\r\n        return amountWei;\r\n    }\r\n\r\n    /// @dev set kyberDao contract address once and set setter address to zero.\r\n    /// @param _kyberDao kyberDao address.\r\n    function setDaoContract(IKyberDao _kyberDao) external {\r\n        require(msg.sender == daoSetter, \"only daoSetter\");\r\n        require(_kyberDao != IKyberDao(0));\r\n        kyberDao = _kyberDao;\r\n        emit KyberDaoAddressSet(kyberDao);\r\n\r\n        daoSetter = address(0);\r\n    }\r\n\r\n    /// @dev set new kyberNetwork address by daoOperator\r\n    /// @param _kyberNetwork new kyberNetwork contract\r\n    function setNetworkContract(address _kyberNetwork) external onlyDaoOperator {\r\n        require(_kyberNetwork != address(0), \"kyberNetwork 0\");\r\n        if (_kyberNetwork != kyberNetwork) {\r\n            kyberNetwork = _kyberNetwork;\r\n            emit KyberNetworkUpdated(kyberNetwork);\r\n        }\r\n    }\r\n\r\n    /// @dev Allow to set kyberNetworkProxy address by daoOperator\r\n    /// @param _newProxy new kyberNetworkProxy contract\r\n    function setKyberProxy(IKyberProxy _newProxy) external onlyDaoOperator {\r\n        require(_newProxy != IKyberProxy(0), \"kyberNetworkProxy 0\");\r\n        if (_newProxy != kyberProxy) {\r\n            kyberProxy = _newProxy;\r\n            emit KyberProxyUpdated(_newProxy);\r\n        }\r\n    }\r\n\r\n    /// @dev set knc sanity rate contract and amount wei to burn\r\n    /// @param _sanityRate new sanity rate contract\r\n    /// @param _weiToBurn new amount of wei to burn\r\n    function setBurnConfigParams(ISanityRate _sanityRate, uint256 _weiToBurn)\r\n        external\r\n        onlyDaoOperator\r\n    {\r\n        require(_weiToBurn > 0, \"_weiToBurn is 0\");\r\n\r\n        if (sanityRateContract.length == 0 || (_sanityRate != sanityRateContract[0])) {\r\n            // it is a new sanity rate contract\r\n            if (sanityRateContract.length == 0) {\r\n                sanityRateContract.push(_sanityRate);\r\n            } else {\r\n                sanityRateContract.push(sanityRateContract[0]);\r\n                sanityRateContract[0] = _sanityRate;\r\n            }\r\n        }\r\n\r\n        weiToBurn = _weiToBurn;\r\n\r\n        emit BurnConfigSet(_sanityRate, _weiToBurn);\r\n    }\r\n\r\n\r\n    /// @dev Burn knc. The burn amount is limited. Forces block delay between burn calls.\r\n    /// @dev only none ontract can call this function\r\n    /// @return kncBurnAmount amount of knc burned\r\n    function burnKnc() external onlyNonContract returns (uint256 kncBurnAmount) {\r\n        // check if current block > last burn block number + num block interval\r\n        require(block.number > lastBurnBlock + burnBlockInterval, \"wait more blocks to burn\");\r\n\r\n        // update last burn block number\r\n        lastBurnBlock = block.number;\r\n\r\n        // Get amount to burn, if greater than weiToBurn, burn only weiToBurn per function call.\r\n        uint256 balance = address(this).balance;\r\n\r\n        // redundant check, can't happen\r\n        assert(balance >= totalPayoutBalance);\r\n        uint256 srcAmount = balance.sub(totalPayoutBalance);\r\n        srcAmount = srcAmount > weiToBurn ? weiToBurn : srcAmount;\r\n\r\n        // Get rate\r\n        uint256 kyberEthKncRate = kyberProxy.getExpectedRateAfterFee(\r\n            ETH_TOKEN_ADDRESS,\r\n            knc,\r\n            srcAmount,\r\n            0,\r\n            \"\"\r\n        );\r\n        validateEthToKncRateToBurn(kyberEthKncRate);\r\n\r\n        // Buy some knc and burn\r\n        kncBurnAmount = kyberProxy.swapEtherToToken{value: srcAmount}(\r\n            knc,\r\n            kyberEthKncRate\r\n        );\r\n\r\n        require(IBurnableToken(address(knc)).burn(kncBurnAmount), \"knc burn failed\");\r\n\r\n        emit KncBurned(kncBurnAmount, ETH_TOKEN_ADDRESS, srcAmount);\r\n        return kncBurnAmount;\r\n    }\r\n\r\n    /// @dev if no one voted for an epoch (like epoch 0), no one gets rewards - should burn it.\r\n    ///         Will move the epoch reward amount to burn amount. So can later be burned.\r\n    ///         calls kyberDao contract to check if there were any votes for this epoch.\r\n    /// @param epoch epoch number to check.\r\n    function makeEpochRewardBurnable(uint256 epoch) external {\r\n        require(kyberDao != IKyberDao(0), \"kyberDao not set\");\r\n\r\n        require(kyberDao.shouldBurnRewardForEpoch(epoch), \"should not burn reward\");\r\n\r\n        uint256 rewardAmount = rewardsPerEpoch[epoch];\r\n        require(rewardAmount > 0, \"reward is 0\");\r\n\r\n        // redundant check, can't happen\r\n        require(totalPayoutBalance >= rewardAmount, \"total reward less than epoch reward\");\r\n        totalPayoutBalance = totalPayoutBalance.sub(rewardAmount);\r\n\r\n        rewardsPerEpoch[epoch] = 0;\r\n\r\n        emit RewardsRemovedToBurn(epoch, rewardAmount);\r\n    }\r\n\r\n    /// @notice should be called off chain\r\n    /// @dev returns list of sanity rate contracts\r\n    /// @dev index 0 is currently used contract address, indexes > 0 are older versions\r\n    function getSanityRateContracts() external view returns (ISanityRate[] memory sanityRates) {\r\n        sanityRates = sanityRateContract;\r\n    }\r\n\r\n    /// @dev return latest knc/eth rate from sanity rate contract\r\n    function getLatestSanityRate() external view returns (uint256 kncToEthSanityRate) {\r\n        if (sanityRateContract.length > 0 && sanityRateContract[0] != ISanityRate(0)) {\r\n            kncToEthSanityRate = sanityRateContract[0].latestAnswer();\r\n        } else {\r\n            kncToEthSanityRate = 0; \r\n        }\r\n    }\r\n\r\n    function getBRR()\r\n        public\r\n        returns (\r\n            uint256 rewardBps,\r\n            uint256 rebateBps,\r\n            uint256 epoch\r\n        )\r\n    {\r\n        uint256 expiryTimestamp;\r\n        (rewardBps, rebateBps, expiryTimestamp, epoch) = readBRRData();\r\n\r\n        // Check current timestamp\r\n        if (now > expiryTimestamp && kyberDao != IKyberDao(0)) {\r\n            uint256 burnBps;\r\n\r\n            (burnBps, rewardBps, rebateBps, epoch, expiryTimestamp) = kyberDao\r\n                .getLatestBRRDataWithCache();\r\n            require(burnBps.add(rewardBps).add(rebateBps) == BPS, \"Bad BRR values\");\r\n            \r\n            emit BRRUpdated(rewardBps, rebateBps, burnBps, expiryTimestamp, epoch);\r\n\r\n            // Update brrAndEpochData\r\n            updateBRRData(rewardBps, rebateBps, expiryTimestamp, epoch);\r\n        }\r\n    }\r\n\r\n    function readBRRData()\r\n        public\r\n        view\r\n        returns (\r\n            uint256 rewardBps,\r\n            uint256 rebateBps,\r\n            uint256 expiryTimestamp,\r\n            uint256 epoch\r\n        )\r\n    {\r\n        rewardBps = uint256(brrAndEpochData.rewardBps);\r\n        rebateBps = uint256(brrAndEpochData.rebateBps);\r\n        epoch = uint256(brrAndEpochData.epoch);\r\n        expiryTimestamp = uint256(brrAndEpochData.expiryTimestamp);\r\n    }\r\n\r\n    function updateBRRData(\r\n        uint256 reward,\r\n        uint256 rebate,\r\n        uint256 expiryTimestamp,\r\n        uint256 epoch\r\n    ) internal {\r\n        // reward and rebate combined values <= BPS. Tested in getBRR.\r\n        require(expiryTimestamp < 2**64, \"expiry timestamp overflow\");\r\n        require(epoch < 2**32, \"epoch overflow\");\r\n\r\n        brrAndEpochData.rewardBps = uint16(reward);\r\n        brrAndEpochData.rebateBps = uint16(rebate);\r\n        brrAndEpochData.expiryTimestamp = uint64(expiryTimestamp);\r\n        brrAndEpochData.epoch = uint32(epoch);\r\n    }\r\n\r\n    function getRRWeiValues(uint256 RRAmountWei)\r\n        internal\r\n        returns (\r\n            uint256 rewardWei,\r\n            uint256 rebateWei,\r\n            uint256 epoch\r\n        )\r\n    {\r\n        // Decoding BRR data\r\n        uint256 rewardInBps;\r\n        uint256 rebateInBps;\r\n        (rewardInBps, rebateInBps, epoch) = getBRR();\r\n\r\n        rebateWei = RRAmountWei.mul(rebateInBps).div(BPS);\r\n        rewardWei = RRAmountWei.mul(rewardInBps).div(BPS);\r\n    }\r\n\r\n    function updateRebateValues(\r\n        uint256 rebateWei,\r\n        address[] memory rebateWallets,\r\n        uint256[] memory rebateBpsPerWallet\r\n    ) internal returns (uint256 totalRebatePaidWei) {\r\n        uint256 totalRebateBps;\r\n        uint256 walletRebateWei;\r\n\r\n        for (uint256 i = 0; i < rebateWallets.length; i++) {\r\n            require(rebateWallets[i] != address(0), \"rebate wallet address 0\");\r\n\r\n            walletRebateWei = rebateWei.mul(rebateBpsPerWallet[i]).div(BPS);\r\n            rebatePerWallet[rebateWallets[i]] = rebatePerWallet[rebateWallets[i]].add(\r\n                walletRebateWei\r\n            );\r\n\r\n            // a few wei could be left out due to rounding down. so count only paid wei\r\n            totalRebatePaidWei = totalRebatePaidWei.add(walletRebateWei);\r\n            totalRebateBps = totalRebateBps.add(rebateBpsPerWallet[i]);\r\n        }\r\n\r\n        require(totalRebateBps <= BPS, \"rebates more then 100%\");\r\n    }\r\n\r\n    function validateEthToKncRateToBurn(uint256 rateEthToKnc) internal view {\r\n        require(rateEthToKnc <= MAX_RATE, \"ethToKnc rate out of bounds\");\r\n        require(rateEthToKnc > 0, \"ethToKnc rate is 0\");\r\n        require(sanityRateContract.length > 0, \"no sanity rate contract\");\r\n        require(sanityRateContract[0] != ISanityRate(0), \"sanity rate is 0x0, burning is blocked\");\r\n\r\n        // get latest knc/eth rate from sanity contract\r\n        uint256 kncToEthRate = sanityRateContract[0].latestAnswer();\r\n        require(kncToEthRate > 0, \"sanity rate is 0\");\r\n        require(kncToEthRate <= MAX_RATE, \"sanity rate out of bounds\");\r\n\r\n        uint256 sanityEthToKncRate = PRECISION.mul(PRECISION).div(kncToEthRate);\r\n\r\n        // rate shouldn't be SANITY_RATE_DIFF_BPS lower than sanity rate\r\n        require(\r\n            rateEthToKnc.mul(BPS) >= sanityEthToKncRate.mul(BPS.sub(SANITY_RATE_DIFF_BPS)),\r\n            \"kyberNetwork eth to knc rate too low\"\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_daoSetter\",\"type\":\"address\"},{\"internalType\":\"contract IKyberProxy\",\"name\":\"_kyberProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_kyberNetwork\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_knc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_burnBlockInterval\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_daoOperator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardBps\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rebateBps\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnBps\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"BRRUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ISanityRate\",\"name\":\"sanityRate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weiToBurn\",\"type\":\"uint256\"}],\"name\":\"BurnConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"platformWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"platformFeeWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rebateWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"rebateWallets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"rebatePercentBpsPerWallet\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnAmtWei\",\"type\":\"uint256\"}],\"name\":\"FeeDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kncTWei\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"KncBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IKyberDao\",\"name\":\"kyberDao\",\"type\":\"address\"}],\"name\":\"KyberDaoAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"kyberNetwork\",\"type\":\"address\"}],\"name\":\"KyberNetworkUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IKyberProxy\",\"name\":\"kyberProxy\",\"type\":\"address\"}],\"name\":\"KyberProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"platformWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PlatformFeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rebateWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RebatePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardsWei\",\"type\":\"uint256\"}],\"name\":\"RewardsRemovedToBurn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"brrAndEpochData\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"expiryTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"rewardBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rebateBps\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnBlockInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnKnc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"kncBurnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"platformWallet\",\"type\":\"address\"}],\"name\":\"claimPlatformFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rebateWallet\",\"type\":\"address\"}],\"name\":\"claimReserveRebate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"claimStakerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feePerPlatformWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBRR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebateBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestSanityRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"kncToEthSanityRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSanityRateContracts\",\"outputs\":[{\"internalType\":\"contract ISanityRate[]\",\"name\":\"sanityRates\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"rebateWallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rebateBpsPerWallet\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"platformWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"platformFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"networkFee\",\"type\":\"uint256\"}],\"name\":\"handleFees\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hasClaimedReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"knc\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberDao\",\"outputs\":[{\"internalType\":\"contract IKyberDao\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberNetwork\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberProxy\",\"outputs\":[{\"internalType\":\"contract IKyberProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBurnBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"makeEpochRewardBurnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"readBRRData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebateBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rebatePerWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsPaidPerEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsPerEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISanityRate\",\"name\":\"_sanityRate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_weiToBurn\",\"type\":\"uint256\"}],\"name\":\"setBurnConfigParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberDao\",\"name\":\"_kyberDao\",\"type\":\"address\"}],\"name\":\"setDaoContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberProxy\",\"name\":\"_newProxy\",\"type\":\"address\"}],\"name\":\"setKyberProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kyberNetwork\",\"type\":\"address\"}],\"name\":\"setNetworkContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayoutBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weiToBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"KyberFeeHandler","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"430","ConstructorArguments":"000000000000000000000000bdd33f411da0b40018922a3bc69001b458227f5c000000000000000000000000c153eead19e0dbbdb3462dcc2b703cc6d738a37c0000000000000000000000009cb7bb6d4795a281860b9bfb7b1441361cc9a7940000000000000000000000007b2810576aa1cce68f2b118cef1f36467c648f92000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000fdb39391184481df0f8e7d57c029f9bf8dbdaca8","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e81f6257c07c9d67858765ef1d407ac99535cf484fe5220cd6b76aae54a8610e"}]}