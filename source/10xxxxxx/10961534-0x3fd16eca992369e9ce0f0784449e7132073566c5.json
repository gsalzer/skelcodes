{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/modules/Ownable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/modules/Managerable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ncontract Managerable is Ownable {\r\n\r\n    address private _managerAddress;\r\n    /**\r\n     * @dev modifier, Only manager can be granted exclusive access to specific functions.\r\n     *\r\n     */\r\n    modifier onlyManager() {\r\n        require(_managerAddress == msg.sender,\"Managerable: caller is not the Manager\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev set manager by owner.\r\n     *\r\n     */\r\n    function setManager(address managerAddress)\r\n    public\r\n    onlyOwner\r\n    {\r\n        _managerAddress = managerAddress;\r\n    }\r\n    /**\r\n     * @dev get manager address.\r\n     *\r\n     */\r\n    function getManager()public view returns (address) {\r\n        return _managerAddress;\r\n    }\r\n}\r\n\r\n// File: contracts/modules/Halt.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\ncontract Halt is Ownable {\r\n\r\n    bool private halted = false;\r\n\r\n    modifier notHalted() {\r\n        require(!halted,\"This contract is halted\");\r\n        _;\r\n    }\r\n\r\n    modifier isHalted() {\r\n        require(halted,\"This contract is not halted\");\r\n        _;\r\n    }\r\n\r\n    /// @notice function Emergency situation that requires\r\n    /// @notice contribution period to stop or not.\r\n    function setHalt(bool halt)\r\n        public\r\n        onlyOwner\r\n    {\r\n        halted = halt;\r\n    }\r\n}\r\n\r\n// File: contracts/modules/whiteList.sol\r\n\r\npragma solidity =0.5.16;\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint32.\r\n     */\r\nlibrary whiteListUint32 {\r\n    /**\r\n     * @dev add uint32 into white list.\r\n     * @param whiteList the storage whiteList.\r\n     * @param temp input value\r\n     */\r\n\r\n    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\r\n        if (!isEligibleUint32(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    /**\r\n     * @dev remove uint32 from whitelist.\r\n     */\r\n    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint256.\r\n     */\r\nlibrary whiteListUint256 {\r\n    // add whiteList\r\n    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\r\n        if (!isEligibleUint256(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible address.\r\n     */\r\nlibrary whiteListAddress {\r\n    // add whiteList\r\n    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\r\n        if (!isEligibleAddress(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n\r\n// File: contracts/modules/AddressWhiteList.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n    /**\r\n     * @dev Implementation of a whitelist filters a eligible address.\r\n     */\r\ncontract AddressWhiteList is Halt {\r\n\r\n    using whiteListAddress for address[];\r\n    uint256 constant internal allPermission = 0xffffffff;\r\n    uint256 constant internal allowBuyOptions = 1;\r\n    uint256 constant internal allowSellOptions = 1<<1;\r\n    uint256 constant internal allowExerciseOptions = 1<<2;\r\n    uint256 constant internal allowAddCollateral = 1<<3;\r\n    uint256 constant internal allowRedeemCollateral = 1<<4;\r\n    // The eligible adress list\r\n    address[] internal whiteList;\r\n    mapping(address => uint256) internal addressPermission;\r\n    /**\r\n     * @dev Implementation of add an eligible address into the whitelist.\r\n     * @param addAddress new eligible address.\r\n     */\r\n    function addWhiteList(address addAddress)public onlyOwner{\r\n        whiteList.addWhiteListAddress(addAddress);\r\n        addressPermission[addAddress] = allPermission;\r\n    }\r\n    function modifyPermission(address addAddress,uint256 permission)public onlyOwner{\r\n        addressPermission[addAddress] = permission;\r\n    }\r\n    /**\r\n     * @dev Implementation of revoke an invalid address from the whitelist.\r\n     * @param removeAddress revoked address.\r\n     */\r\n    function removeWhiteList(address removeAddress)public onlyOwner returns (bool){\r\n        addressPermission[removeAddress] = 0;\r\n        return whiteList.removeWhiteListAddress(removeAddress);\r\n    }\r\n    /**\r\n     * @dev Implementation of getting the eligible whitelist.\r\n     */\r\n    function getWhiteList()public view returns (address[] memory){\r\n        return whiteList;\r\n    }\r\n    /**\r\n     * @dev Implementation of testing whether the input address is eligible.\r\n     * @param tmpAddress input address for testing.\r\n     */\r\n    function isEligibleAddress(address tmpAddress) public view returns (bool){\r\n        return whiteList.isEligibleAddress(tmpAddress);\r\n    }\r\n    function checkAddressPermission(address tmpAddress,uint256 state) public view returns (bool){\r\n        return  (addressPermission[tmpAddress]&state) == state;\r\n    }\r\n}\r\n\r\n// File: contracts/modules/ReentrancyGuard.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancyLock = false;\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancyLock);\r\n    reentrancyLock = true;\r\n    _;\r\n    reentrancyLock = false;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/FNXMinePool/MinePoolData.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n/**\r\n * @title FPTCoin mine pool, which manager contract is FPTCoin.\r\n * @dev A smart-contract which distribute some mine coins by FPTCoin balance.\r\n *\r\n */\r\ncontract MinePoolData is Managerable,AddressWhiteList,ReentrancyGuard {\r\n    //Special decimals for calculation\r\n    uint256 constant calDecimals = 1e18;\r\n    // miner's balance\r\n    // map mineCoin => user => balance\r\n    mapping(address=>mapping(address=>uint256)) internal minerBalances;\r\n    // miner's origins, specially used for mine distribution\r\n    // map mineCoin => user => balance\r\n    mapping(address=>mapping(address=>uint256)) internal minerOrigins;\r\n\r\n    // mine coins total worth, specially used for mine distribution\r\n    mapping(address=>uint256) internal totalMinedWorth;\r\n    // total distributed mine coin amount\r\n    mapping(address=>uint256) internal totalMinedCoin;\r\n    // latest time to settlement\r\n    mapping(address=>uint256) internal latestSettleTime;\r\n    //distributed mine amount\r\n    mapping(address=>uint256) internal mineAmount;\r\n    //distributed time interval\r\n    mapping(address=>uint256) internal mineInterval;\r\n    //distributed mine coin amount for buy options user.\r\n    mapping(address=>uint256) internal buyingMineMap;\r\n    // user's Opterator indicator\r\n    uint256 constant internal opBurnCoin = 1;\r\n    uint256 constant internal opMintCoin = 2;\r\n    uint256 constant internal opTransferCoin = 3;\r\n    /**\r\n     * @dev Emitted when `account` mint `amount` miner shares.\r\n     */\r\n    event MintMiner(address indexed account,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `account` burn `amount` miner shares.\r\n     */\r\n    event BurnMiner(address indexed account,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `from` redeem `value` mineCoins.\r\n     */\r\n    event RedeemMineCoin(address indexed from, address indexed mineCoin, uint256 value);\r\n    /**\r\n     * @dev Emitted when `from` transfer to `to` `amount` mineCoins.\r\n     */\r\n    event TranserMiner(address indexed from, address indexed to, uint256 amount);\r\n    /**\r\n     * @dev Emitted when `account` buying options get `amount` mineCoins.\r\n     */\r\n    event BuyingMiner(address indexed account,address indexed mineCoin,uint256 amount);\r\n}\r\n\r\n// File: contracts/Proxy/baseProxy.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @title  baseProxy Contract\r\n\r\n */\r\ncontract baseProxy is Ownable {\r\n    address public implementation;\r\n    constructor(address implementation_) public {\r\n        // Creator of the contract is admin during initialization\r\n        implementation = implementation_;\r\n        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature(\"initialize()\"));\r\n        require(success);\r\n    }\r\n    function getImplementation()public view returns(address){\r\n        return implementation;\r\n    }\r\n    function setImplementation(address implementation_)public onlyOwner{\r\n        implementation = implementation_;\r\n        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature(\"update()\"));\r\n        require(success);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to the implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = implementation.delegatecall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to an implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return abi.decode(returnData, (bytes));\r\n    }\r\n\r\n    function delegateToViewAndReturn() internal view returns (bytes memory) {\r\n        (bool success, ) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", msg.data));\r\n\r\n        assembly {\r\n            let free_mem_ptr := mload(0x40)\r\n            returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n            switch success\r\n            case 0 { revert(free_mem_ptr, returndatasize) }\r\n            default { return(add(free_mem_ptr, 0x40), returndatasize) }\r\n        }\r\n    }\r\n\r\n    function delegateAndReturn() internal returns (bytes memory) {\r\n        (bool success, ) = implementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n            let free_mem_ptr := mload(0x40)\r\n            returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n            switch success\r\n            case 0 { revert(free_mem_ptr, returndatasize) }\r\n            default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/FNXMinePool/MinePoolProxy.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @title FPTCoin mine pool, which manager contract is FPTCoin.\r\n * @dev A smart-contract which distribute some mine coins by FPTCoin balance.\r\n *\r\n */\r\ncontract MinePoolProxy is MinePoolData,baseProxy {\r\n    constructor (address implementation_) baseProxy(implementation_) public{\r\n    }\r\n    /**\r\n     * @dev default function for foundation input miner coins.\r\n     */\r\n    function()external payable{\r\n    }\r\n    /**\r\n     * @dev foundation redeem out mine coins.\r\n     *  mineCoin mineCoin address\r\n     *  amount redeem amount.\r\n     */\r\n    function redeemOut(address /*mineCoin*/,uint256 /*amount*/)public{\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev retrieve total distributed mine coins.\r\n     *  mineCoin mineCoin address\r\n     */\r\n    function getTotalMined(address /*mineCoin*/)public view returns(uint256){\r\n        delegateToViewAndReturn();\r\n    }\r\n    /**\r\n     * @dev retrieve minecoin distributed informations.\r\n     *  mineCoin mineCoin address\r\n     * @return distributed amount and distributed time interval.\r\n     */\r\n    function getMineInfo(address /*mineCoin*/)public view returns(uint256,uint256){\r\n        delegateToViewAndReturn();\r\n    }\r\n    /**\r\n     * @dev retrieve user's mine balance.\r\n     *  account user's account\r\n     *  mineCoin mineCoin address\r\n     */\r\n    function getMinerBalance(address /*account*/,address /*mineCoin*/)public view returns(uint256){\r\n        delegateToViewAndReturn();\r\n    }\r\n    /**\r\n     * @dev Set mineCoin mine info, only foundation owner can invoked.\r\n     *  mineCoin mineCoin address\r\n     *  _mineAmount mineCoin distributed amount\r\n     *  _mineInterval mineCoin distributied time interval\r\n     */\r\n    function setMineCoinInfo(address /*mineCoin*/,uint256 /*_mineAmount*/,uint256 /*_mineInterval*/)public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev Set the reward for buying options.\r\n     *  mineCoin mineCoin address\r\n     *  _mineAmount mineCoin reward amount\r\n     */\r\n    function setBuyingMineInfo(address /*mineCoin*/,uint256 /*_mineAmount*/)public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev Get the reward for buying options.\r\n     *  mineCoin mineCoin address\r\n     */\r\n    function getBuyingMineInfo(address /*mineCoin*/)public view returns(uint256){\r\n        delegateToViewAndReturn();\r\n    }\r\n    /**\r\n     * @dev Get the all rewards for buying options.\r\n     */\r\n    function getBuyingMineInfoAll()public view returns(address[] memory,uint256[] memory){\r\n        delegateToViewAndReturn();\r\n    }\r\n    /**\r\n     * @dev transfer mineCoin to recieptor when account transfer amount FPTCoin to recieptor, only manager contract can modify database.\r\n     *  account the account transfer from\r\n     *  recieptor the account transfer to\r\n     *  amount the mine shared amount\r\n     */\r\n    function transferMinerCoin(address /*account*/,address /*recieptor*/,uint256 /*amount*/) public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev mint mineCoin to account when account add collateral to collateral pool, only manager contract can modify database.\r\n     *  account user's account\r\n     *  amount the mine shared amount\r\n     */\r\n    function mintMinerCoin(address /*account*/,uint256 /*amount*/) public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev Burn mineCoin to account when account redeem collateral to collateral pool, only manager contract can modify database.\r\n     *  account user's account\r\n     *  amount the mine shared amount\r\n     */\r\n    function burnMinerCoin(address /*account*/,uint256 /*amount*/) public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev give amount buying reward to account, only manager contract can modify database.\r\n     *  account user's account\r\n     *  amount the buying shared amount\r\n     */\r\n    function addMinerBalance(address /*account*/,uint256 /*amount*/) public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev changer mine coin distributed amount , only foundation owner can modify database.\r\n     *  mineCoin mine coin address\r\n     *  _mineAmount the distributed amount.\r\n     */\r\n    function setMineAmount(address /*mineCoin*/,uint256 /*_mineAmount*/)public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev changer mine coin distributed time interval , only foundation owner can modify database.\r\n     *  mineCoin mine coin address\r\n     *  _mineInterval the distributed time interval.\r\n     */\r\n    function setMineInterval(address /*mineCoin*/,uint256 /*_mineInterval*/)public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev user redeem mine rewards.\r\n     *  mineCoin mine coin address\r\n     *  amount redeem amount.\r\n     */\r\n    function redeemMinerCoin(address /*mineCoin*/,uint256 /*amount*/)public{\r\n        delegateAndReturn();\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurnMiner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuyingMiner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MintMiner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RedeemMineCoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TranserMiner\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addMinerBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burnMinerCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tmpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"}],\"name\":\"checkAddressPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToViewImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getBuyingMineInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBuyingMineInfoAll\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getMineInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getMinerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getTotalMined\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWhiteList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tmpAddress\",\"type\":\"address\"}],\"name\":\"isEligibleAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintMinerCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"permission\",\"type\":\"uint256\"}],\"name\":\"modifyPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"redeemMinerCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"redeemOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeAddress\",\"type\":\"address\"}],\"name\":\"removeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"setBuyingMineInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"halt\",\"type\":\"bool\"}],\"name\":\"setHalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"managerAddress\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"setMineAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"setMineCoinInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"setMineInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferMinerCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MinePoolProxy","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000babf02ff4d487d2cd482582875f12b6b5952a67e","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://67d2e67c1109790eae241fafc224460986f5a388628d849b2290f8b19fd5222f"}]}