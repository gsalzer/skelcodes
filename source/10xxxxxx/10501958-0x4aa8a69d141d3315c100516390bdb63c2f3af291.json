{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/sol6/IERC20.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function decimals() external view returns (uint8 digits);\r\n\r\n    function totalSupply() external view returns (uint256 supply);\r\n}\r\n\r\n\r\n// to support backward compatible contract name -- so function signature remains same\r\nabstract contract ERC20 is IERC20 {\r\n\r\n}\r\n\r\n// File: contracts/sol6/IKyberReserve.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberReserve {\r\n    function trade(\r\n        IERC20 srcToken,\r\n        uint256 srcAmount,\r\n        IERC20 destToken,\r\n        address payable destAddress,\r\n        uint256 conversionRate,\r\n        bool validate\r\n    ) external payable returns (bool);\r\n\r\n    function getConversionRate(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 blockNumber\r\n    ) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/IKyberNetwork.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberNetwork {\r\n    event KyberTrade(\r\n        IERC20 indexed src,\r\n        IERC20 indexed dest,\r\n        uint256 ethWeiValue,\r\n        uint256 networkFeeWei,\r\n        uint256 customPlatformFeeWei,\r\n        bytes32[] t2eIds,\r\n        bytes32[] e2tIds,\r\n        uint256[] t2eSrcAmounts,\r\n        uint256[] e2tSrcAmounts,\r\n        uint256[] t2eRates,\r\n        uint256[] e2tRates\r\n    );\r\n\r\n    function tradeWithHintAndFee(\r\n        address payable trader,\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256 destAmount);\r\n\r\n    function listTokenForReserve(\r\n        address reserve,\r\n        IERC20 token,\r\n        bool add\r\n    ) external;\r\n\r\n    function enabled() external view returns (bool);\r\n\r\n    function getExpectedRateWithHintAndFee(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 expectedRateAfterNetworkFee,\r\n            uint256 expectedRateAfterAllFees\r\n        );\r\n\r\n    function getNetworkData()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 negligibleDiffBps,\r\n            uint256 networkFeeBps,\r\n            uint256 expiryTimestamp\r\n        );\r\n\r\n    function maxGasPrice() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/IKyberNetworkProxy.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberNetworkProxy {\r\n\r\n    event ExecuteTrade(\r\n        address indexed trader,\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        address destAddress,\r\n        uint256 actualSrcAmount,\r\n        uint256 actualDestAmount,\r\n        address platformWallet,\r\n        uint256 platformFeeBps\r\n    );\r\n\r\n    /// @notice backward compatible\r\n    function tradeWithHint(\r\n        ERC20 src,\r\n        uint256 srcAmount,\r\n        ERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable walletId,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256);\r\n\r\n    function tradeWithHintAndFee(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256 destAmount);\r\n\r\n    function trade(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet\r\n    ) external payable returns (uint256);\r\n\r\n    /// @notice backward compatible\r\n    /// @notice Rate units (10 ** 18) => destQty (twei) / srcQty (twei) * 10 ** 18\r\n    function getExpectedRate(\r\n        ERC20 src,\r\n        ERC20 dest,\r\n        uint256 srcQty\r\n    ) external view returns (uint256 expectedRate, uint256 worstRate);\r\n\r\n    function getExpectedRateAfterFee(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external view returns (uint256 expectedRate);\r\n}\r\n\r\n// File: contracts/sol6/IKyberStorage.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\ninterface IKyberStorage {\r\n    enum ReserveType {NONE, FPR, APR, BRIDGE, UTILITY, CUSTOM, ORDERBOOK, LAST}\r\n\r\n    function addKyberProxy(address kyberProxy, uint256 maxApprovedProxies)\r\n        external;\r\n\r\n    function removeKyberProxy(address kyberProxy) external;\r\n\r\n    function setContracts(address _kyberFeeHandler, address _kyberMatchingEngine) external;\r\n\r\n    function setKyberDaoContract(address _kyberDao) external;\r\n\r\n    function getReserveId(address reserve) external view returns (bytes32 reserveId);\r\n\r\n    function getReserveIdsFromAddresses(address[] calldata reserveAddresses)\r\n        external\r\n        view\r\n        returns (bytes32[] memory reserveIds);\r\n\r\n    function getReserveAddressesFromIds(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (address[] memory reserveAddresses);\r\n\r\n    function getReserveIdsPerTokenSrc(IERC20 token)\r\n        external\r\n        view\r\n        returns (bytes32[] memory reserveIds);\r\n\r\n    function getReserveAddressesPerTokenSrc(IERC20 token, uint256 startIndex, uint256 endIndex)\r\n        external\r\n        view\r\n        returns (address[] memory reserveAddresses);\r\n\r\n    function getReserveIdsPerTokenDest(IERC20 token)\r\n        external\r\n        view\r\n        returns (bytes32[] memory reserveIds);\r\n\r\n    function getReserveAddressesByReserveId(bytes32 reserveId)\r\n        external\r\n        view\r\n        returns (address[] memory reserveAddresses);\r\n\r\n    function getRebateWalletsFromIds(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (address[] memory rebateWallets);\r\n\r\n    function getKyberProxies() external view returns (IKyberNetworkProxy[] memory);\r\n\r\n    function getReserveDetailsByAddress(address reserve)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 reserveId,\r\n            address rebateWallet,\r\n            ReserveType resType,\r\n            bool isFeeAccountedFlag,\r\n            bool isEntitledRebateFlag\r\n        );\r\n\r\n    function getReserveDetailsById(bytes32 reserveId)\r\n        external\r\n        view\r\n        returns (\r\n            address reserveAddress,\r\n            address rebateWallet,\r\n            ReserveType resType,\r\n            bool isFeeAccountedFlag,\r\n            bool isEntitledRebateFlag\r\n        );\r\n\r\n    function getFeeAccountedData(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (bool[] memory feeAccountedArr);\r\n\r\n    function getEntitledRebateData(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (bool[] memory entitledRebateArr);\r\n\r\n    function getReservesData(bytes32[] calldata reserveIds, IERC20 src, IERC20 dest)\r\n        external\r\n        view\r\n        returns (\r\n            bool areAllReservesListed,\r\n            bool[] memory feeAccountedArr,\r\n            bool[] memory entitledRebateArr,\r\n            IKyberReserve[] memory reserveAddresses);\r\n\r\n    function isKyberProxyAdded() external view returns (bool);\r\n}\r\n\r\n// File: contracts/sol6/IKyberMatchingEngine.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\ninterface IKyberMatchingEngine {\r\n    enum ProcessWithRate {NotRequired, Required}\r\n\r\n    function setNegligibleRateDiffBps(uint256 _negligibleRateDiffBps) external;\r\n\r\n    function setKyberStorage(IKyberStorage _kyberStorage) external;\r\n\r\n    function getNegligibleRateDiffBps() external view returns (uint256);\r\n\r\n    function getTradingReserves(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        bool isTokenToToken,\r\n        bytes calldata hint\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32[] memory reserveIds,\r\n            uint256[] memory splitValuesBps,\r\n            ProcessWithRate processWithRate\r\n        );\r\n\r\n    function doMatch(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256[] calldata srcAmounts,\r\n        uint256[] calldata feesAccountedDestBps,\r\n        uint256[] calldata rates\r\n    ) external view returns (uint256[] memory reserveIndexes);\r\n}\r\n\r\n// File: contracts/sol6/wrappers/IKyberRateHelper.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberRateHelper {\r\n    function getRatesForToken(\r\n        IERC20 token,\r\n        uint256 optionalBuyAmountWei,\r\n        uint256 optionalSellAmountTwei\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32[] memory buyReserves,\r\n            uint256[] memory buyRates,\r\n            bytes32[] memory sellReserves,\r\n            uint256[] memory sellRates\r\n        );\r\n\r\n    function getPricesForToken(\r\n        IERC20 token,\r\n        uint256 optionalBuyAmountWei,\r\n        uint256 optionalSellAmountTwei\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32[] memory buyReserves,\r\n            uint256[] memory buyRates,\r\n            bytes32[] memory sellReserves,\r\n            uint256[] memory sellRates\r\n        );\r\n\r\n    function getRatesForTokenWithCustomFee(\r\n        IERC20 token,\r\n        uint256 optionalBuyAmountWei,\r\n        uint256 optionalSellAmountTwei,\r\n        uint256 networkFeeBps\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32[] memory buyReserves,\r\n            uint256[] memory buyRates,\r\n            bytes32[] memory sellReserves,\r\n            uint256[] memory sellRates\r\n        );\r\n\r\n    function getReservesRates(IERC20 token, uint256 optionalAmountWei)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32[] memory buyReserves,\r\n            uint256[] memory buyRates,\r\n            bytes32[] memory sellReserves,\r\n            uint256[] memory sellRates\r\n        );\r\n\r\n    function getSpreadInfo(IERC20 token, uint256 optionalAmountWei)\r\n        external\r\n        view\r\n        returns (bytes32[] memory reserves, int256[] memory spreads);\r\n\r\n    function getSlippageRateInfo(\r\n        IERC20 token,\r\n        uint256 optionalAmountWei,\r\n        uint256 optionalSlippageAmountWei\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32[] memory buyReserves,\r\n            int256[] memory buySlippageRateBps,\r\n            bytes32[] memory sellReserves,\r\n            int256[] memory sellSlippageRateBps\r\n        );\r\n}\r\n\r\n// File: contracts/sol6/Dao/IEpochUtils.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface IEpochUtils {\r\n    function epochPeriodInSeconds() external view returns (uint256);\r\n\r\n    function firstEpochStartTimestamp() external view returns (uint256);\r\n\r\n    function getCurrentEpochNumber() external view returns (uint256);\r\n\r\n    function getEpochNumber(uint256 timestamp) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/IKyberDao.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberDao is IEpochUtils {\r\n    event Voted(address indexed staker, uint indexed epoch, uint indexed campaignID, uint option);\r\n\r\n    function getLatestNetworkFeeDataWithCache()\r\n        external\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\r\n\r\n    function getLatestBRRDataWithCache()\r\n        external\r\n        returns (\r\n            uint256 burnInBps,\r\n            uint256 rewardInBps,\r\n            uint256 rebateInBps,\r\n            uint256 epoch,\r\n            uint256 expiryTimestamp\r\n        );\r\n\r\n    function handleWithdrawal(address staker, uint256 penaltyAmount) external;\r\n\r\n    function vote(uint256 campaignID, uint256 option) external;\r\n\r\n    function getLatestNetworkFeeData()\r\n        external\r\n        view\r\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\r\n\r\n    function shouldBurnRewardForEpoch(uint256 epoch) external view returns (bool);\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for a past epoch only\r\n     *       fee handler should call this function when a staker wants to claim reward\r\n     *       return 0 if staker has no votes or stakes\r\n     */\r\n    function getPastEpochRewardPercentageInPrecision(address staker, uint256 epoch)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev  return staker's reward percentage in precision for the current epoch\r\n     *       reward percentage is not finalized until the current epoch is ended\r\n     */\r\n    function getCurrentEpochRewardPercentageInPrecision(address staker)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/utils/Utils5.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n/**\r\n * @title Kyber utility file\r\n * mostly shared constants and rate calculation helpers\r\n * inherited by most of kyber contracts.\r\n * previous utils implementations are for previous solidity versions.\r\n */\r\ncontract Utils5 {\r\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n    );\r\n    uint256 internal constant PRECISION = (10**18);\r\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\r\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\r\n    uint256 internal constant MAX_DECIMALS = 18;\r\n    uint256 internal constant ETH_DECIMALS = 18;\r\n    uint256 constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\r\n    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\r\n\r\n    mapping(IERC20 => uint256) internal decimals;\r\n\r\n    function getUpdateDecimals(IERC20 token) internal returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) {\r\n            tokenDecimals = token.decimals();\r\n            decimals[token] = tokenDecimals;\r\n        }\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function setDecimals(IERC20 token) internal {\r\n        if (decimals[token] != 0) return; //already set\r\n\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            decimals[token] = ETH_DECIMALS;\r\n        } else {\r\n            decimals[token] = token.decimals();\r\n        }\r\n    }\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(IERC20 token, address user) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            return user.balance;\r\n        } else {\r\n            return token.balanceOf(user);\r\n        }\r\n    }\r\n\r\n    function getDecimals(IERC20 token) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDestAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 destAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcDstQty(\r\n        uint256 srcQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(srcQty <= MAX_QTY, \"srcQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(\r\n        uint256 dstQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(dstQty <= MAX_QTY, \"dstQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint256 numerator;\r\n        uint256 denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcRateFromQty(\r\n        uint256 srcAmount,\r\n        uint256 destAmount,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals\r\n    ) internal pure returns (uint256) {\r\n        require(srcAmount <= MAX_QTY, \"srcAmount > MAX_QTY\");\r\n        require(destAmount <= MAX_QTY, \"destAmount > MAX_QTY\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\r\n        }\r\n    }\r\n\r\n    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/utils/PermissionGroupsNoModifiers.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract PermissionGroupsNoModifiers {\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address => bool) internal operators;\r\n    mapping(address => bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint256 internal constant MAX_GROUP_SIZE = 50;\r\n\r\n    event AdminClaimed(address newAdmin, address previousAdmin);\r\n    event AlerterAdded(address newAlerter, bool isAdd);\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    constructor(address _admin) public {\r\n        require(_admin != address(0), \"admin 0\");\r\n        admin = _admin;\r\n    }\r\n\r\n    function getOperators() external view returns (address[] memory) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters() external view returns (address[] memory) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    function addAlerter(address newAlerter) public {\r\n        onlyAdmin();\r\n        require(!alerters[newAlerter], \"alerter exists\"); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE, \"max alerters\");\r\n\r\n        emit AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function addOperator(address newOperator) public {\r\n        onlyAdmin();\r\n        require(!operators[newOperator], \"operator exists\"); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE, \"max operators\");\r\n\r\n        emit OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    /// @dev Allows the pendingAdmin address to finalize the change admin process.\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender, \"not pending\");\r\n        emit AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    function removeAlerter(address alerter) public {\r\n        onlyAdmin();\r\n        require(alerters[alerter], \"not alerter\");\r\n        delete alerters[alerter];\r\n\r\n        for (uint256 i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.pop();\r\n                emit AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeOperator(address operator) public {\r\n        onlyAdmin();\r\n        require(operators[operator], \"not operator\");\r\n        delete operators[operator];\r\n\r\n        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.pop();\r\n                emit OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Allows the current admin to set the pendingAdmin address\r\n    /// @param newAdmin The address to transfer ownership to\r\n    function transferAdmin(address newAdmin) public {\r\n        onlyAdmin();\r\n        require(newAdmin != address(0), \"new admin 0\");\r\n        emit TransferAdminPending(newAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /// @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n    /// @param newAdmin The address to transfer ownership to.\r\n    function transferAdminQuickly(address newAdmin) public {\r\n        onlyAdmin();\r\n        require(newAdmin != address(0), \"admin 0\");\r\n        emit TransferAdminPending(newAdmin);\r\n        emit AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    function onlyAdmin() internal view {\r\n        require(msg.sender == admin, \"only admin\");\r\n    }\r\n\r\n    function onlyAlerter() internal view {\r\n        require(alerters[msg.sender], \"only alerter\");\r\n    }\r\n\r\n    function onlyOperator() internal view {\r\n        require(operators[msg.sender], \"only operator\");\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/utils/WithdrawableNoModifiers.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\ncontract WithdrawableNoModifiers is PermissionGroupsNoModifiers {\r\n    constructor(address _admin) public PermissionGroupsNoModifiers(_admin) {}\r\n\r\n    event EtherWithdraw(uint256 amount, address sendTo);\r\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\r\n\r\n    /// @dev Withdraw Ethers\r\n    function withdrawEther(uint256 amount, address payable sendTo) external {\r\n        onlyAdmin();\r\n        (bool success, ) = sendTo.call{value: amount}(\"\");\r\n        require(success);\r\n        emit EtherWithdraw(amount, sendTo);\r\n    }\r\n\r\n    /// @dev Withdraw all IERC20 compatible tokens\r\n    /// @param token IERC20 The address of the token contract\r\n    function withdrawToken(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address sendTo\r\n    ) external {\r\n        onlyAdmin();\r\n        token.transfer(sendTo, amount);\r\n        emit TokenWithdraw(token, amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/wrappers/KyberRateHelper.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract KyberRateHelper is IKyberRateHelper, WithdrawableNoModifiers, Utils5 {\r\n    uint256 public constant DEFAULT_SPREAD_QUERY_AMOUNT_WEI = 10 ether;\r\n    uint256 public constant DEFAULT_SLIPPAGE_QUERY_BASE_AMOUNT_WEI = 0.01 ether;\r\n    uint256 public constant DEFAULT_SLIPPAGE_QUERY_AMOUNT_WEI = 10 ether;\r\n    uint256 public constant DEFAULT_RATE_QUERY_AMOUNT_WEI = 1 ether;\r\n\r\n    IKyberDao public kyberDao;\r\n    IKyberStorage public kyberStorage;\r\n    //reserves are queried directly\r\n    bytes32[] public reserveIds;\r\n\r\n    constructor(address _admin) public WithdrawableNoModifiers(_admin) {\r\n        /* empty body */\r\n    }\r\n\r\n    event KyberDaoContractSet(IKyberDao kyberDao);\r\n    event KyberStorageSet(IKyberStorage kyberStorage);\r\n    event AddKyberReserve(bytes32 reserveId, bool add);\r\n\r\n    function setContracts(\r\n        IKyberDao _kyberDao,\r\n        IKyberStorage _kyberStorage\r\n    ) public {\r\n        onlyAdmin();\r\n        require(_kyberDao != IKyberDao(0), \"kyberDao 0\");\r\n        require(_kyberStorage != IKyberStorage(0), \"kyberStorage 0\");\r\n\r\n        if (kyberDao != _kyberDao) {\r\n            kyberDao = _kyberDao;\r\n            emit KyberDaoContractSet(_kyberDao);\r\n        }\r\n\r\n        if (kyberStorage != _kyberStorage) {\r\n            kyberStorage = _kyberStorage;\r\n            emit KyberStorageSet(_kyberStorage);\r\n        }\r\n    }\r\n\r\n    function addReserve(bytes32 reserveId) public {\r\n        onlyAdmin();\r\n        require(reserveId != bytes32(0), \"reserve 0\");\r\n        reserveIds.push(reserveId);\r\n\r\n        emit AddKyberReserve(reserveId, true);\r\n    }\r\n\r\n    function removeReserve(bytes32 reserveId) public {\r\n        onlyAdmin();\r\n        for (uint256 i = 0; i < reserveIds.length; i++) {\r\n            if (reserveIds[i] == reserveId) {\r\n                reserveIds[i] = reserveIds[reserveIds.length - 1];\r\n                reserveIds.pop();\r\n\r\n                emit AddKyberReserve(reserveId, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getPricesForToken(\r\n        IERC20 token,\r\n        uint256 optionalBuyAmountWei,\r\n        uint256 optionalSellAmountTwei\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            bytes32[] memory buyReserves,\r\n            uint256[] memory buyRates,\r\n            bytes32[] memory sellReserves,\r\n            uint256[] memory sellRates\r\n        )\r\n    {\r\n        return getRatesForTokenWithCustomFee(token, optionalBuyAmountWei, optionalSellAmountTwei, 0);\r\n    }\r\n\r\n    /// @dev function to cover backward compatible with old network interface\r\n    /// @dev get rate from eth to token, use the best token amount to get rate from token to eth\r\n    /// @param token Token to get rate\r\n    /// @param optionalAmountWei Eth amount to get rate (default: 0)\r\n    function getReservesRates(IERC20 token, uint256 optionalAmountWei)\r\n        public\r\n        override\r\n        view\r\n        returns (\r\n            bytes32[] memory buyReserves,\r\n            uint256[] memory buyRates,\r\n            bytes32[] memory sellReserves,\r\n            uint256[] memory sellRates\r\n        )\r\n    {\r\n        (uint256 networkFeeBps, ) = kyberDao.getLatestNetworkFeeData();\r\n        uint256 buyAmountWei = optionalAmountWei > 0 ? optionalAmountWei : DEFAULT_RATE_QUERY_AMOUNT_WEI;\r\n\r\n        (buyReserves, buyRates) = getBuyInfo(token, buyAmountWei, networkFeeBps);\r\n\r\n        uint256 bestRate = 0;\r\n        for (uint256 i = 0; i < buyRates.length; i++) {\r\n            if (buyRates[i] > bestRate) {\r\n                bestRate = buyRates[i];\r\n            }\r\n        }\r\n\r\n        if (bestRate == 0) {\r\n            return (buyReserves, buyRates, sellReserves, sellRates);\r\n        }\r\n        uint256 sellAmountTwei = calcDstQty(buyAmountWei, ETH_DECIMALS, getDecimals(token), bestRate);\r\n        (sellReserves, sellRates) = getSellInfo(token, sellAmountTwei, networkFeeBps);\r\n    }\r\n\r\n    function getReservesRatesWithConfigReserves(IERC20 token, uint256 optionalAmountWei)\r\n        public\r\n        view\r\n        returns (\r\n            bytes32[] memory reserves,\r\n            uint256[] memory buyRates,\r\n            uint256[] memory sellRates\r\n        )\r\n    {\r\n        (uint256 networkFeeBps, ) = kyberDao.getLatestNetworkFeeData();\r\n        uint256 buyAmountWei = optionalAmountWei > 0 ? optionalAmountWei : DEFAULT_RATE_QUERY_AMOUNT_WEI;\r\n        reserves = reserveIds;\r\n        buyRates = getBuyRate(token, buyAmountWei, networkFeeBps, reserves);\r\n\r\n        uint256 bestRate = 0;\r\n        for (uint256 i = 0; i < buyRates.length; i++) {\r\n            if (buyRates[i] > bestRate) {\r\n                bestRate = buyRates[i];\r\n            }\r\n        }\r\n\r\n        if (bestRate == 0) {\r\n            sellRates = new uint256[](reserves.length);\r\n            return (reserves, buyRates, sellRates);\r\n        }\r\n        uint256 sellAmountTwei = calcDstQty(buyAmountWei, ETH_DECIMALS, getDecimals(token), bestRate);\r\n        sellRates = getSellRate(token, sellAmountTwei, networkFeeBps, reserves);\r\n    }\r\n\r\n    function getRatesForToken(\r\n        IERC20 token,\r\n        uint256 optionalBuyAmountWei,\r\n        uint256 optionalSellAmountTwei\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            bytes32[] memory buyReserves,\r\n            uint256[] memory buyRates,\r\n            bytes32[] memory sellReserves,\r\n            uint256[] memory sellRates\r\n        )\r\n    {\r\n        (uint256 feeBps, ) = kyberDao.getLatestNetworkFeeData();\r\n        return getRatesForTokenWithCustomFee(token, optionalBuyAmountWei, optionalSellAmountTwei, feeBps);\r\n    }\r\n\r\n    function getRatesForTokenWithCustomFee(\r\n        IERC20 token,\r\n        uint256 optionalBuyAmountWei,\r\n        uint256 optionalSellAmountTwei,\r\n        uint256 networkFeeBps\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            bytes32[] memory buyReserves,\r\n            uint256[] memory buyRates,\r\n            bytes32[] memory sellReserves,\r\n            uint256[] memory sellRates\r\n        )\r\n    {\r\n        uint256 buyAmountWei = optionalBuyAmountWei > 0 ? optionalBuyAmountWei : DEFAULT_RATE_QUERY_AMOUNT_WEI;\r\n        (buyReserves, buyRates) = getBuyInfo(token, buyAmountWei, networkFeeBps);\r\n        uint256 sellAmountTwei = optionalSellAmountTwei;\r\n        if (sellAmountTwei == 0) {\r\n            uint256 bestRate = 0;\r\n            for (uint256 i = 0; i < buyRates.length; i++) {\r\n                if (buyRates[i] > bestRate) {\r\n                    bestRate = buyRates[i];\r\n                }\r\n            }\r\n            if (bestRate != 0) {\r\n                sellAmountTwei = calcDstQty(buyAmountWei, ETH_DECIMALS, getDecimals(token), bestRate);\r\n            }\r\n        }\r\n        (sellReserves, sellRates) = getSellInfo(token, sellAmountTwei, networkFeeBps);\r\n    }\r\n\r\n    function getBuyInfo(\r\n        IERC20 token,\r\n        uint256 buyAmountWei,\r\n        uint256 networkFeeBps\r\n    ) internal view returns (bytes32[] memory buyReserves, uint256[] memory buyRates) {\r\n        buyReserves = kyberStorage.getReserveIdsPerTokenDest(token);\r\n        buyRates = getBuyRate(token, buyAmountWei, networkFeeBps, buyReserves);\r\n    }\r\n\r\n    function getBuyRate(\r\n        IERC20 token,\r\n        uint256 buyAmountWei,\r\n        uint256 networkFeeBps,\r\n        bytes32[] memory buyReserves\r\n    ) internal view returns (uint256[] memory buyRates) {\r\n        bool[] memory isFeeAccountedFlags = kyberStorage.getFeeAccountedData(buyReserves);\r\n        address[] memory buyReserveAddresses = kyberStorage.getReserveAddressesFromIds(\r\n            buyReserves\r\n        );\r\n        buyRates = new uint256[](buyReserves.length);\r\n        uint256 buyAmountWithFee = buyAmountWei - ((buyAmountWei * networkFeeBps) / BPS);\r\n        for (uint256 i = 0; i < buyReserves.length; i++) {\r\n            if (networkFeeBps == 0 || !isFeeAccountedFlags[i]) {\r\n                buyRates[i] = IKyberReserve(buyReserveAddresses[i]).getConversionRate(\r\n                    ETH_TOKEN_ADDRESS,\r\n                    token,\r\n                    buyAmountWei,\r\n                    block.number\r\n                );\r\n                continue;\r\n            }\r\n            buyRates[i] = IKyberReserve(buyReserveAddresses[i]).getConversionRate(\r\n                ETH_TOKEN_ADDRESS,\r\n                token,\r\n                buyAmountWithFee,\r\n                block.number\r\n            );\r\n            uint256 destAmount = calcDstQty(\r\n                buyAmountWithFee,\r\n                ETH_DECIMALS,\r\n                getDecimals(token),\r\n                buyRates[i]\r\n            );\r\n            //use amount instead of ethSrcAmount to account for network fee\r\n            buyRates[i] = calcRateFromQty(buyAmountWei, destAmount, ETH_DECIMALS, getDecimals(token));\r\n        }\r\n    }\r\n\r\n    function getSellInfo(\r\n        IERC20 token,\r\n        uint256 sellAmountTwei,\r\n        uint256 networkFeeBps\r\n    ) internal view returns (bytes32[] memory sellReserves, uint256[] memory sellRates) {\r\n        sellReserves = kyberStorage.getReserveIdsPerTokenSrc(token);\r\n        sellRates = getSellRate(token, sellAmountTwei, networkFeeBps, sellReserves);\r\n    }\r\n\r\n    function getSellRate(\r\n        IERC20 token,\r\n        uint256 sellAmountTwei,\r\n        uint256 networkFeeBps,\r\n        bytes32[] memory sellReserves\r\n    ) internal view returns (uint256[] memory sellRates) {\r\n        bool[] memory isFeeAccountedFlags = kyberStorage.getFeeAccountedData(sellReserves);\r\n        address[] memory sellReserveAddresses = kyberStorage.getReserveAddressesFromIds(\r\n            sellReserves\r\n        );\r\n        sellRates = new uint256[](sellReserves.length);\r\n        for (uint256 i = 0; i < sellReserves.length; i++) {\r\n            sellRates[i] = IKyberReserve(sellReserveAddresses[i]).getConversionRate(\r\n                token,\r\n                ETH_TOKEN_ADDRESS,\r\n                sellAmountTwei,\r\n                block.number\r\n            );\r\n            if (networkFeeBps == 0 || !isFeeAccountedFlags[i]) {\r\n                continue;\r\n            }\r\n            uint256 destAmount = calcDstQty(\r\n                sellAmountTwei,\r\n                getDecimals(token),\r\n                ETH_DECIMALS,\r\n                sellRates[i]\r\n            );\r\n            destAmount -= (networkFeeBps * destAmount) / BPS;\r\n            sellRates[i] = calcRateFromQty(\r\n                sellAmountTwei,\r\n                destAmount,\r\n                getDecimals(token),\r\n                ETH_DECIMALS\r\n            );\r\n        }\r\n    }\r\n\r\n    function getSpreadInfo(IERC20 token, uint256 optionalAmountWei)\r\n        public\r\n        view\r\n        override\r\n        returns (bytes32[] memory reserves, int256[] memory spreads)\r\n    {\r\n        uint256 amountWei = optionalAmountWei > 0 ? optionalAmountWei : DEFAULT_SPREAD_QUERY_AMOUNT_WEI;\r\n        (\r\n            bytes32[] memory buyReserves,\r\n            uint256[] memory buyRates,\r\n            bytes32[] memory sellReserves,\r\n            uint256[] memory sellRates\r\n        ) = getReservesRates(token, amountWei);\r\n        // map pair of buyRate and sellRate from the same Reserve\r\n        uint256[] memory validReserves = new uint256[](buyReserves.length);\r\n        uint256[] memory revertReserveIndex = new uint256[](buyReserves.length);\r\n        uint256 validReserveSize = 0;\r\n        for (uint256 i = 0; i < buyRates.length; i++) {\r\n            for (uint256 j = 0; j < sellRates.length; j++) {\r\n                if (sellReserves[j] == buyReserves[i]) {\r\n                    revertReserveIndex[i] = j;\r\n                    validReserves[validReserveSize] = i;\r\n                    validReserveSize++;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        reserves = new bytes32[](validReserveSize);\r\n        spreads = new int256[](validReserveSize);\r\n        for (uint256 i = 0; i < validReserveSize; i++) {\r\n            uint256 reserveIndex = validReserves[i];\r\n            reserves[i] = buyReserves[reserveIndex];\r\n            spreads[i] = calcSpreadInBps(\r\n                buyRates[reserveIndex],\r\n                sellRates[revertReserveIndex[reserveIndex]]\r\n            );\r\n        }\r\n    }\r\n\r\n    function getSpreadInfoWithConfigReserves(IERC20 token, uint256 optionalAmountWei)\r\n        public\r\n        view\r\n        returns (bytes32[] memory reserves, int256[] memory spreads)\r\n    {\r\n        uint256[] memory buyRates;\r\n        uint256[] memory sellRates;\r\n        uint256 amountWei = optionalAmountWei > 0 ? optionalAmountWei : DEFAULT_SPREAD_QUERY_AMOUNT_WEI;\r\n        (reserves, buyRates, sellRates) = getReservesRatesWithConfigReserves(token, amountWei);\r\n\r\n        spreads = new int256[](reserves.length);\r\n        for (uint256 i = 0; i < buyRates.length; i++) {\r\n            spreads[i] = calcSpreadInBps(buyRates[i], sellRates[i]);\r\n        }\r\n    }\r\n\r\n    function getSlippageRateInfo(\r\n        IERC20 token,\r\n        uint256 optionalAmountWei,\r\n        uint256 optionalSlippageAmount\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            bytes32[] memory buyReserves,\r\n            int256[] memory buySlippageRateBps,\r\n            bytes32[] memory sellReserves,\r\n            int256[] memory sellSlippageRateBps\r\n        )\r\n    {\r\n        uint256 baseAmount = optionalAmountWei > 0 ? optionalAmountWei : DEFAULT_SLIPPAGE_QUERY_BASE_AMOUNT_WEI;\r\n        uint256[] memory baseBuyRates;\r\n        uint256[] memory baseSellRates;\r\n        (buyReserves, baseBuyRates, sellReserves, baseSellRates) = getReservesRates(\r\n            token,\r\n            baseAmount\r\n        );\r\n        uint256 slippageAmount = optionalSlippageAmount > 0\r\n            ? optionalSlippageAmount\r\n            : DEFAULT_SLIPPAGE_QUERY_AMOUNT_WEI;\r\n        uint256[] memory slippageBuyRates;\r\n        uint256[] memory slippageSellRates;\r\n        (, slippageBuyRates, , slippageSellRates) = getReservesRates(token, slippageAmount);\r\n        // no rate exists for slippageAmount but rate exists for baseAmount\r\n        if (slippageSellRates.length == 0 && baseSellRates.length != 0) {\r\n            slippageSellRates = new uint256[](baseSellRates.length);\r\n        }\r\n\r\n        assert(slippageSellRates.length == baseSellRates.length);\r\n        assert(slippageBuyRates.length == baseBuyRates.length);\r\n\r\n        buySlippageRateBps = new int256[](buyReserves.length);\r\n        for (uint256 i = 0; i < buyReserves.length; i++) {\r\n            buySlippageRateBps[i] = calcSlippageRateInBps(baseBuyRates[i], slippageBuyRates[i], true);\r\n        }\r\n\r\n        sellSlippageRateBps = new int256[](sellReserves.length);\r\n        for (uint256 i = 0; i < sellReserves.length; i++) {\r\n            sellSlippageRateBps[i] = calcSlippageRateInBps(baseSellRates[i], slippageSellRates[i], false);\r\n        }\r\n    }\r\n\r\n    function getSlippageRateInfoWithConfigReserves(\r\n        IERC20 token,\r\n        uint256 optionalAmountWei,\r\n        uint256 optionalSlippageAmount\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            bytes32[] memory reserves,\r\n            int256[] memory buySlippageRateBps,\r\n            int256[] memory sellSlippageRateBps\r\n        )\r\n    {\r\n        uint256 baseAmount = optionalAmountWei > 0 ? optionalAmountWei : DEFAULT_SLIPPAGE_QUERY_BASE_AMOUNT_WEI;\r\n        uint256[] memory baseBuyRates;\r\n        uint256[] memory baseSellRates;\r\n        (reserves, baseBuyRates, baseSellRates) = getReservesRatesWithConfigReserves(\r\n            token,\r\n            baseAmount\r\n        );\r\n        uint256 slippageAmount = optionalSlippageAmount > 0\r\n            ? optionalSlippageAmount\r\n            : DEFAULT_SLIPPAGE_QUERY_AMOUNT_WEI;\r\n        uint256[] memory slippageBuyRates;\r\n        uint256[] memory slippageSellRates;\r\n        (, slippageBuyRates, slippageSellRates) = getReservesRatesWithConfigReserves(\r\n            token,\r\n            slippageAmount\r\n        );\r\n\r\n        assert(slippageSellRates.length == baseSellRates.length);\r\n        assert(slippageBuyRates.length == baseBuyRates.length);\r\n\r\n        buySlippageRateBps = new int256[](baseBuyRates.length);\r\n        for (uint256 i = 0; i < baseBuyRates.length; i++) {\r\n            buySlippageRateBps[i] = calcSlippageRateInBps(baseBuyRates[i], slippageBuyRates[i], true);\r\n        }\r\n\r\n        sellSlippageRateBps = new int256[](baseSellRates.length);\r\n        for (uint256 i = 0; i < baseSellRates.length; i++) {\r\n            sellSlippageRateBps[i] = calcSlippageRateInBps(baseSellRates[i], slippageSellRates[i], false);\r\n        }\r\n    }\r\n\r\n    /// @dev if sellRate == 0 return 2 * BPS (max value of spread)\r\n    /// @dev if buyRate ** sellRate >= 10 ** 36 (negative spread) return 0\r\n    /// @dev spread can be from -2 * BPS to 2 * BPS\r\n    function calcSpreadInBps(uint256 buyRate, uint256 sellRate) internal pure returns (int256) {\r\n        if (buyRate == 0) {\r\n            return 2 * int256(BPS);\r\n        }\r\n        int256 reversedBuyRate = int256(PRECISION**2 / buyRate);\r\n        int256 sellRateInt256 = int256(sellRate);\r\n        return (2 * int256(BPS) * (reversedBuyRate - sellRateInt256)) / (reversedBuyRate + sellRateInt256);\r\n    }\r\n\r\n    /// @dev if baseRate == 0 return -1\r\n    /// @dev if slippageRate == 0 return BPS\r\n    /// @dev if baseRate < slippageRate return 0\r\n    function calcSlippageRateInBps(\r\n        uint256 baseRate,\r\n        uint256 slippageRate,\r\n        bool isBuy\r\n    ) internal pure returns (int256) {\r\n        if (baseRate == 0) {\r\n            return -1;\r\n        }\r\n        if (slippageRate == 0) {\r\n            return int256(BPS);\r\n        }\r\n        if (slippageRate > baseRate) {\r\n            return 0;\r\n        }\r\n        if (isBuy) {\r\n            uint256 reversedBaseRate = PRECISION**2 / baseRate;\r\n            uint256 reversedSlippageRate = PRECISION**2 / slippageRate;\r\n            return int256((BPS * (reversedSlippageRate - reversedBaseRate)) / reversedBaseRate);\r\n        } else {\r\n            return int256((BPS * (baseRate - slippageRate)) / baseRate);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"AddKyberReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IKyberDao\",\"name\":\"kyberDao\",\"type\":\"address\"}],\"name\":\"KyberDaoContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IKyberStorage\",\"name\":\"kyberStorage\",\"type\":\"address\"}],\"name\":\"KyberStorageSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_RATE_QUERY_AMOUNT_WEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_SLIPPAGE_QUERY_AMOUNT_WEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_SLIPPAGE_QUERY_BASE_AMOUNT_WEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_SPREAD_QUERY_AMOUNT_WEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"}],\"name\":\"addReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionalBuyAmountWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionalSellAmountTwei\",\"type\":\"uint256\"}],\"name\":\"getPricesForToken\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"buyReserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"buyRates\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"sellReserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellRates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionalBuyAmountWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionalSellAmountTwei\",\"type\":\"uint256\"}],\"name\":\"getRatesForToken\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"buyReserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"buyRates\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"sellReserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellRates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionalBuyAmountWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionalSellAmountTwei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"networkFeeBps\",\"type\":\"uint256\"}],\"name\":\"getRatesForTokenWithCustomFee\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"buyReserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"buyRates\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"sellReserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellRates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionalAmountWei\",\"type\":\"uint256\"}],\"name\":\"getReservesRates\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"buyReserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"buyRates\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"sellReserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellRates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionalAmountWei\",\"type\":\"uint256\"}],\"name\":\"getReservesRatesWithConfigReserves\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"buyRates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellRates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionalAmountWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionalSlippageAmount\",\"type\":\"uint256\"}],\"name\":\"getSlippageRateInfo\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"buyReserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"int256[]\",\"name\":\"buySlippageRateBps\",\"type\":\"int256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"sellReserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"int256[]\",\"name\":\"sellSlippageRateBps\",\"type\":\"int256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionalAmountWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionalSlippageAmount\",\"type\":\"uint256\"}],\"name\":\"getSlippageRateInfoWithConfigReserves\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"int256[]\",\"name\":\"buySlippageRateBps\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"sellSlippageRateBps\",\"type\":\"int256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionalAmountWei\",\"type\":\"uint256\"}],\"name\":\"getSpreadInfo\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"int256[]\",\"name\":\"spreads\",\"type\":\"int256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionalAmountWei\",\"type\":\"uint256\"}],\"name\":\"getSpreadInfoWithConfigReserves\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserves\",\"type\":\"bytes32[]\"},{\"internalType\":\"int256[]\",\"name\":\"spreads\",\"type\":\"int256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberDao\",\"outputs\":[{\"internalType\":\"contract IKyberDao\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberStorage\",\"outputs\":[{\"internalType\":\"contract IKyberStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reserveId\",\"type\":\"bytes32\"}],\"name\":\"removeReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserveIds\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberDao\",\"name\":\"_kyberDao\",\"type\":\"address\"},{\"internalType\":\"contract IKyberStorage\",\"name\":\"_kyberStorage\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KyberRateHelper","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000052f46feb45822e7f117536386c51b6bd3125157","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://31d7f14687736db09f6b81ff91bd2017d223449414dbd25218df55a6944d087f"}]}