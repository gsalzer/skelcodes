{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath8 {\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n    uint8 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n    }\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a / b;\r\n        return c;\r\n    }\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        uint8 c = a - b;\r\n        return c;\r\n    }\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    function mod(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract gameContract {\r\n    function game(uint betMask, uint8 modulo, bytes32 entropy, uint betAmount) public pure returns(uint winAmount, uint256[10] result);\r\n    function getMaxWin(uint betMask, uint8 modulo, uint betAmount) public pure returns(uint maxWin);\r\n}\r\n\r\ncontract CoinAndRoulette is gameContract {\r\n    uint constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\r\n    uint constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\r\n    uint constant POPCNT_MODULO = 0x3F;\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath8 for uint8;\r\n\r\n    function game(uint betMask, uint8 modulo, bytes32 entropy, uint betAmount) public pure returns(uint winAmount, uint256[10] result) {\r\n        uint dice = uint(entropy).mod(modulo);\r\n        result[0] = dice;\r\n\r\n        uint rollUnder;\r\n        uint expectWin;\r\n        rollUnder = getRollUnder(betMask, modulo);\r\n        expectWin = betAmount.mul(uint(modulo)).div(rollUnder);\r\n\r\n        if ((2 ** dice) & betMask != 0) {\r\n            winAmount = expectWin;\r\n        }\r\n\r\n    }\r\n\r\n    function getMaxWin(uint betMask, uint8 modulo, uint betAmount) public pure returns(uint maxWin) {\r\n        uint rollUnder;\r\n        rollUnder = ((betMask.mul(POPCNT_MULT)) & POPCNT_MASK) % POPCNT_MODULO;\r\n        maxWin = betAmount * modulo / rollUnder;\r\n    }\r\n    function getRollUnder(uint betMask, uint8 modulo) public pure returns(uint rollUnder) {\r\n        rollUnder = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"getMaxWin\",\"outputs\":[{\"name\":\"maxWin\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"entropy\",\"type\":\"bytes32\"},{\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"game\",\"outputs\":[{\"name\":\"winAmount\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"}],\"name\":\"getRollUnder\",\"outputs\":[{\"name\":\"rollUnder\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"CoinAndRoulette","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://04b057bd87fc2356ec699e927a96c676729f6f1b4983db47b7e2d24adce2a6f8"}]}