{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-05-18\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2020-01-23\r\n*/\r\n\r\n// File: github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a); // dev: overflow\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a); // dev: underflow\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b); // dev: overflow\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0); // dev: divide by zero\r\n        c = a / b;\r\n    }\r\n}\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract BasicMetaTransaction {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event MetaTransactionExecuted(address userAddress, address payable relayerAddress, bytes functionSignature);\r\n    mapping(address => uint256) nonces;\r\n    \r\n    function getChainID() public pure returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Main function to be called when user wants to execute meta transaction.\r\n     * The actual function to be called should be passed as param with name functionSignature\r\n     * Here the basic signature recovery is being used. Signature is expected to be generated using\r\n     * personal_sign method.\r\n     * @param userAddress Address of user trying to do meta transaction\r\n     * @param functionSignature Signature of the actual function to be called via meta transaction\r\n     * @param message Message to be signed by the user\r\n     * @param length Length of complete message that was signed\r\n     * @param sigR R part of the signature\r\n     * @param sigS S part of the signature\r\n     * @param sigV V part of the signature\r\n     */\r\n    function executeMetaTransaction(address userAddress,\r\n        bytes memory functionSignature, string memory message, string memory length,\r\n        bytes32 sigR, bytes32 sigS, uint8 sigV) public payable returns(bytes memory) {\r\n\r\n        require(verify(userAddress, message, length, nonces[userAddress], getChainID(), sigR, sigS, sigV), \"Signer and signature do not match\");\r\n        // Append userAddress and relayer address at the end to extract it from calling context\r\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, userAddress));\r\n\r\n        require(success, \"Function call not successfull\");\r\n        nonces[userAddress] = nonces[userAddress].add(1);\r\n        emit MetaTransactionExecuted(userAddress, msg.sender, functionSignature);\r\n        return returnData;\r\n    }\r\n\r\n    function getNonce(address user) public view returns(uint256 nonce) {\r\n        nonce = nonces[user];\r\n    }\r\n\r\n\r\n\r\n    function verify(address owner, string memory message, string memory length, uint256 nonce, uint256 chainID,\r\n        bytes32 sigR, bytes32 sigS, uint8 sigV) public pure returns (bool) {\r\n\r\n        string memory nonceStr = uint2str(nonce);\r\n        string memory chainIDStr = uint2str(chainID);\r\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", length, message, nonceStr, chainIDStr));\r\n\t\treturn (owner == ecrecover(hash, sigV, sigR, sigS));\r\n    }\r\n\r\n    /**\r\n     * Internal utility function used to convert an int to string.\r\n     * @param _i integer to be converted into a string\r\n     */\r\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        uint256 temp = _i;\r\n        while (temp != 0) {\r\n            bstr[k--] = byte(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function msgSender() internal view returns(address sender) {\r\n        if(msg.sender == address(this)) {\r\n            bytes memory array = msg.data;\r\n            uint256 index = msg.data.length;\r\n            assembly {\r\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\r\n                sender := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            }\r\n        } else {\r\n            sender = msg.sender;\r\n        }\r\n        return sender;\r\n    }\r\n\r\n    // To recieve ether in contract\r\n    receive() external payable { }\r\n    fallback() external payable { }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\n\r\n\r\n// File: browser/dex-adapter-simple.sol\r\n\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n}\r\n\r\ninterface IGateway {\r\n    function mint(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) external returns (uint256);\r\n    function burn(bytes calldata _to, uint256 _amount) external returns (uint256);\r\n}\r\n\r\ninterface IGatewayRegistry {\r\n    function getGatewayBySymbol(string calldata _tokenSymbol) external view returns (IGateway);\r\n    function getGatewayByToken(address  _tokenAddress) external view returns (IGateway);\r\n    function getTokenBySymbol(string calldata _tokenSymbol) external view returns (IERC20);\r\n}\r\n\r\ninterface ICurveExchange {\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\r\n\r\n    function get_dy(int128, int128 j, uint256 dx) external view returns (uint256);\r\n\r\n    function calc_token_amount(uint256[2] calldata amounts, bool deposit) external returns (uint256 amount);\r\n\r\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external;\r\n\r\n    function remove_liquidity(\r\n        uint256 _amount,\r\n        uint256[2] calldata min_amounts\r\n    ) external;\r\n\r\n    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 max_burn_amount) external;\r\n\r\n    function remove_liquidity_one_coin(uint256 _token_amounts, int128 i, uint256 min_amount) external;\r\n}\r\n\r\ninterface IFreeFromUpTo {\r\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract CurveExchangeAdapter is BasicMetaTransaction {\r\n    using SafeMath for uint256;\r\n\r\n    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n\r\n    modifier discountCHI {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 *\r\n                           msg.data.length;\r\n        if(chi.balanceOf(address(this)) > 0) {\r\n            chi.freeFromUpTo(address(this), (gasSpent + 14154) / 41947);\r\n        }\r\n        else {\r\n            chi.freeFromUpTo(msgSender(), (gasSpent + 14154) / 41947);\r\n        }\r\n    }\r\n\r\n    \r\n    IERC20 RENBTC;\r\n    IERC20 WBTC;\r\n    IERC20 curveToken;\r\n\r\n    ICurveExchange public exchange;  \r\n    IGatewayRegistry public registry;\r\n\r\n    event SwapReceived(uint256 mintedAmount, uint256 wbtcAmount);\r\n    event DepositMintedCurve(uint256 mintedAmount, uint256 curveAmount);\r\n    event ReceiveRen(uint256 renAmount);\r\n    event Burn(uint256 burnAmount);\r\n\r\n    constructor(ICurveExchange _exchange, IGatewayRegistry _registry, IERC20 _wbtc) public {\r\n        exchange = _exchange;\r\n        registry = _registry;\r\n        RENBTC = registry.getTokenBySymbol(\"BTC\");\r\n        WBTC = _wbtc;\r\n        address curveTokenAddress = 0x49849C98ae39Fff122806C06791Fa73784FB3675;\r\n        curveToken = IERC20(curveTokenAddress);\r\n        \r\n        // Approve exchange.\r\n        require(RENBTC.approve(address(exchange), uint256(-1)));\r\n        require(WBTC.approve(address(exchange), uint256(-1)));\r\n        require(chi.approve(address(this), uint256(-1)));\r\n    }\r\n\r\n    function recoverStuck(\r\n        bytes calldata encoded,\r\n        uint256 _amount,\r\n        bytes32 _nHash,\r\n        bytes calldata _sig\r\n    ) external {\r\n        uint256 start = encoded.length - 32;\r\n        address sender = abi.decode(encoded[start:], (address));\r\n        require(sender == msgSender());\r\n        bytes32 pHash = keccak256(encoded);\r\n        uint256 mintedAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\r\n        require(RENBTC.transfer(msgSender(), mintedAmount));\r\n    }\r\n    \r\n    function mintThenSwap(\r\n        uint256 _minExchangeRate,\r\n        uint256 _newMinExchangeRate,\r\n        uint256 _slippage,\r\n        address payable _wbtcDestination,\r\n        uint256 _amount,\r\n        bytes32 _nHash,\r\n        bytes calldata _sig\r\n    ) external discountCHI {\r\n        // Mint renBTC tokens\r\n        bytes32 pHash = keccak256(abi.encode(_minExchangeRate, _slippage, _wbtcDestination, msgSender()));\r\n        uint256 mintedAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\r\n        \r\n        // Get price\r\n        uint256 dy = exchange.get_dy(0, 1, mintedAmount);\r\n        uint256 rate = dy.mul(1e8).div(mintedAmount);\r\n        _slippage = uint256(1e4).sub(_slippage);\r\n        uint256 min_dy = dy.mul(_slippage).div(1e4);\r\n        \r\n        // Price is OK\r\n        if (rate >= _newMinExchangeRate) {\r\n            uint256 startWbtcBalance = WBTC.balanceOf(address(this));\r\n            exchange.exchange(0, 1, mintedAmount, min_dy);\r\n\r\n            uint256 endWbtcBalance = WBTC.balanceOf(address(this));\r\n            uint256 wbtcBought = endWbtcBalance.sub(startWbtcBalance);\r\n        \r\n            //Send proceeds to the User\r\n            require(WBTC.transfer(_wbtcDestination, wbtcBought));\r\n            emit SwapReceived(mintedAmount, wbtcBought);\r\n        } else {\r\n            //Send renBTC to the User instead\r\n            require(RENBTC.transfer(_wbtcDestination, mintedAmount));\r\n            emit ReceiveRen(mintedAmount);\r\n        }\r\n    }\r\n\r\n    function mintThenDeposit(\r\n        address payable _wbtcDestination, \r\n        uint256 _amount, \r\n        uint256[2] calldata _amounts, \r\n        uint256 _min_mint_amount, \r\n        uint256 _new_min_mint_amount, \r\n        bytes32 _nHash, \r\n        bytes calldata _sig\r\n    ) external discountCHI {\r\n        // Mint renBTC tokens\r\n        bytes32 pHash = keccak256(abi.encode(_wbtcDestination, _amounts, _min_mint_amount, msgSender()));\r\n        //use actual _amount the user sent\r\n        uint256 mintedAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\r\n\r\n        //set renBTC to actual minted amount in case the user sent less BTC to Ren\r\n        uint256[2] memory receivedAmounts = _amounts;\r\n        receivedAmounts[0] = mintedAmount;\r\n        uint256 calc_token_amount = exchange.calc_token_amount(_amounts, true);\r\n        if(calc_token_amount >= _new_min_mint_amount) {\r\n            require(WBTC.transferFrom(msgSender(), address(this), receivedAmounts[1]));\r\n            uint256 curveBalanceBefore = curveToken.balanceOf(address(this));\r\n            exchange.add_liquidity(receivedAmounts, 0);\r\n            uint256 curveBalanceAfter = curveToken.balanceOf(address(this));\r\n            uint256 curveAmount = curveBalanceAfter.sub(curveBalanceBefore);\r\n            require(curveAmount >= _new_min_mint_amount);\r\n            require(curveToken.transfer(msgSender(), curveAmount));\r\n            emit DepositMintedCurve(mintedAmount, curveAmount);\r\n        }\r\n        else {\r\n            require(RENBTC.transfer(_wbtcDestination, mintedAmount));\r\n            emit ReceiveRen(mintedAmount);\r\n        }\r\n    }\r\n\r\n    function mintNoSwap(\r\n        uint256 _minExchangeRate,\r\n        uint256 _newMinExchangeRate,\r\n        uint256 _slippage,\r\n        address payable _wbtcDestination,\r\n        uint256 _amount,\r\n        bytes32 _nHash,\r\n        bytes calldata _sig\r\n    ) external discountCHI {\r\n        bytes32 pHash = keccak256(abi.encode(_minExchangeRate, _slippage, _wbtcDestination, msgSender()));\r\n        uint256 mintedAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\r\n        \r\n        require(RENBTC.transfer(_wbtcDestination, mintedAmount));\r\n        emit ReceiveRen(mintedAmount);\r\n    }\r\n\r\n    function mintNoDeposit(\r\n        address payable _wbtcDestination, \r\n        uint256 _amount, \r\n        uint256[2] calldata _amounts, \r\n        uint256 _min_mint_amount, \r\n        uint256 _new_min_mint_amount, \r\n        bytes32 _nHash, \r\n        bytes calldata _sig\r\n    ) external discountCHI {\r\n         // Mint renBTC tokens\r\n        bytes32 pHash = keccak256(abi.encode(_wbtcDestination, _amounts, _min_mint_amount, msgSender()));\r\n        //use actual _amount the user sent\r\n        uint256 mintedAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\r\n\r\n        require(RENBTC.transfer(_wbtcDestination, mintedAmount));\r\n        emit ReceiveRen(mintedAmount);\r\n    }\r\n\r\n    function removeLiquidityThenBurn(bytes calldata _btcDestination, uint256 amount, uint256[2] calldata min_amounts) external discountCHI {\r\n        uint256 startRenbtcBalance = RENBTC.balanceOf(address(this));\r\n        uint256 startWbtcBalance = WBTC.balanceOf(address(this));\r\n        require(curveToken.transferFrom(msgSender(), address(this), amount));\r\n        exchange.remove_liquidity(amount, min_amounts);\r\n        uint256 endRenbtcBalance = RENBTC.balanceOf(address(this));\r\n        uint256 endWbtcBalance = WBTC.balanceOf(address(this));\r\n        uint256 wbtcWithdrawn = endWbtcBalance.sub(startWbtcBalance);\r\n        require(WBTC.transfer(msgSender(), wbtcWithdrawn));\r\n        uint256 renbtcWithdrawn = endRenbtcBalance.sub(startRenbtcBalance);\r\n\r\n        // Burn and send proceeds to the User\r\n        uint256 burnAmount = registry.getGatewayBySymbol(\"BTC\").burn(_btcDestination, renbtcWithdrawn);\r\n        emit Burn(burnAmount);\r\n    }\r\n\r\n    function removeLiquidityImbalanceThenBurn(bytes calldata _btcDestination, uint256[2] calldata amounts, uint256 max_burn_amount) external discountCHI {\r\n        uint256 startRenbtcBalance = RENBTC.balanceOf(address(this));\r\n        uint256 startWbtcBalance = WBTC.balanceOf(address(this));\r\n        uint256 _tokens = curveToken.balanceOf(msgSender());\r\n        if(_tokens > max_burn_amount) { \r\n            _tokens = max_burn_amount;\r\n        }\r\n        require(curveToken.transferFrom(msgSender(), address(this), _tokens));\r\n        exchange.remove_liquidity_imbalance(amounts, max_burn_amount.mul(101).div(100));\r\n        _tokens = curveToken.balanceOf(address(this));\r\n        require(curveToken.transfer(msgSender(), _tokens));\r\n        uint256 endRenbtcBalance = RENBTC.balanceOf(address(this));\r\n        uint256 endWbtcBalance = WBTC.balanceOf(address(this));\r\n        uint256 renbtcWithdrawn = endRenbtcBalance.sub(startRenbtcBalance);\r\n        uint256 wbtcWithdrawn = endWbtcBalance.sub(startWbtcBalance);\r\n        require(WBTC.transfer(msgSender(), wbtcWithdrawn));\r\n\r\n        // Burn and send proceeds to the User\r\n        uint256 burnAmount = registry.getGatewayBySymbol(\"BTC\").burn(_btcDestination, renbtcWithdrawn);\r\n        emit Burn(burnAmount);\r\n    }\r\n\r\n    //always removing in renBTC, else use normal method\r\n    function removeLiquidityOneCoinThenBurn(bytes calldata _btcDestination, uint256 _token_amounts, uint256 min_amount) external discountCHI {\r\n        uint256 startRenbtcBalance = RENBTC.balanceOf(address(this));\r\n        require(curveToken.transferFrom(msgSender(), address(this), _token_amounts));\r\n        exchange.remove_liquidity_one_coin(_token_amounts, 0, min_amount);\r\n        uint256 endRenbtcBalance = RENBTC.balanceOf(address(this));\r\n        uint256 renbtcWithdrawn = endRenbtcBalance.sub(startRenbtcBalance);\r\n\r\n        // Burn and send proceeds to the User\r\n        uint256 burnAmount = registry.getGatewayBySymbol(\"BTC\").burn(_btcDestination, renbtcWithdrawn);\r\n        emit Burn(burnAmount);\r\n    }\r\n    \r\n    function swapThenBurn(bytes calldata _btcDestination, uint256 _amount, uint256 _minRenbtcAmount) external discountCHI {\r\n        require(WBTC.transferFrom(msgSender(), address(this), _amount));\r\n        uint256 startRenbtcBalance = RENBTC.balanceOf(address(this));\r\n        exchange.exchange(1, 0, _amount, _minRenbtcAmount);\r\n        uint256 endRenbtcBalance = RENBTC.balanceOf(address(this));\r\n        uint256 renbtcBought = endRenbtcBalance.sub(startRenbtcBalance);\r\n        \r\n        // Burn and send proceeds to the User\r\n        uint256 burnAmount = registry.getGatewayBySymbol(\"BTC\").burn(_btcDestination, renbtcBought);\r\n        emit Burn(burnAmount);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ICurveExchange\",\"name\":\"_exchange\",\"type\":\"address\"},{\"internalType\":\"contract IGatewayRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_wbtc\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"curveAmount\",\"type\":\"uint256\"}],\"name\":\"DepositMintedCurve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"renAmount\",\"type\":\"uint256\"}],\"name\":\"ReceiveRen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wbtcAmount\",\"type\":\"uint256\"}],\"name\":\"SwapReceived\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"chi\",\"outputs\":[{\"internalType\":\"contract IFreeFromUpTo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"contract ICurveExchange\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"length\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wbtcDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"_amounts\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_new_min_mint_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"mintNoDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newMinExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_wbtcDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"mintNoSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wbtcDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"_amounts\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_new_min_mint_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"mintThenDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newMinExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_wbtcDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"mintThenSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"recoverStuck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IGatewayRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_btcDestination\",\"type\":\"bytes\"},{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"max_burn_amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityImbalanceThenBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_btcDestination\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_token_amounts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityOneCoinThenBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_btcDestination\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"min_amounts\",\"type\":\"uint256[2]\"}],\"name\":\"removeLiquidityThenBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_btcDestination\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minRenbtcAmount\",\"type\":\"uint256\"}],\"name\":\"swapThenBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"length\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainID\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CurveExchangeAdapter","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000093054188d876f558f4a66b2ef1d97d16edf0895b000000000000000000000000e80d347df1209a76dd9d2319d62912ba98c54ddd0000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7921e2cd127e659663abf96d01071d8562ff2d3a9c7d1d995a9e639e52ffea78"}]}