{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/sol6/IERC20.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function decimals() external view returns (uint8 digits);\r\n\r\n    function totalSupply() external view returns (uint256 supply);\r\n}\r\n\r\n\r\n// to support backward compatible contract name -- so function signature remains same\r\nabstract contract ERC20 is IERC20 {\r\n\r\n}\r\n\r\n// File: contracts/sol6/utils/PermissionGroupsNoModifiers.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract PermissionGroupsNoModifiers {\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address => bool) internal operators;\r\n    mapping(address => bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint256 internal constant MAX_GROUP_SIZE = 50;\r\n\r\n    event AdminClaimed(address newAdmin, address previousAdmin);\r\n    event AlerterAdded(address newAlerter, bool isAdd);\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    constructor(address _admin) public {\r\n        require(_admin != address(0), \"admin 0\");\r\n        admin = _admin;\r\n    }\r\n\r\n    function getOperators() external view returns (address[] memory) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters() external view returns (address[] memory) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    function addAlerter(address newAlerter) public {\r\n        onlyAdmin();\r\n        require(!alerters[newAlerter], \"alerter exists\"); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE, \"max alerters\");\r\n\r\n        emit AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function addOperator(address newOperator) public {\r\n        onlyAdmin();\r\n        require(!operators[newOperator], \"operator exists\"); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE, \"max operators\");\r\n\r\n        emit OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    /// @dev Allows the pendingAdmin address to finalize the change admin process.\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender, \"not pending\");\r\n        emit AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    function removeAlerter(address alerter) public {\r\n        onlyAdmin();\r\n        require(alerters[alerter], \"not alerter\");\r\n        delete alerters[alerter];\r\n\r\n        for (uint256 i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.pop();\r\n                emit AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeOperator(address operator) public {\r\n        onlyAdmin();\r\n        require(operators[operator], \"not operator\");\r\n        delete operators[operator];\r\n\r\n        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.pop();\r\n                emit OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Allows the current admin to set the pendingAdmin address\r\n    /// @param newAdmin The address to transfer ownership to\r\n    function transferAdmin(address newAdmin) public {\r\n        onlyAdmin();\r\n        require(newAdmin != address(0), \"new admin 0\");\r\n        emit TransferAdminPending(newAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /// @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n    /// @param newAdmin The address to transfer ownership to.\r\n    function transferAdminQuickly(address newAdmin) public {\r\n        onlyAdmin();\r\n        require(newAdmin != address(0), \"admin 0\");\r\n        emit TransferAdminPending(newAdmin);\r\n        emit AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    function onlyAdmin() internal view {\r\n        require(msg.sender == admin, \"only admin\");\r\n    }\r\n\r\n    function onlyAlerter() internal view {\r\n        require(alerters[msg.sender], \"only alerter\");\r\n    }\r\n\r\n    function onlyOperator() internal view {\r\n        require(operators[msg.sender], \"only operator\");\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/utils/WithdrawableNoModifiers.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\ncontract WithdrawableNoModifiers is PermissionGroupsNoModifiers {\r\n    constructor(address _admin) public PermissionGroupsNoModifiers(_admin) {}\r\n\r\n    event EtherWithdraw(uint256 amount, address sendTo);\r\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\r\n\r\n    /// @dev Withdraw Ethers\r\n    function withdrawEther(uint256 amount, address payable sendTo) external {\r\n        onlyAdmin();\r\n        (bool success, ) = sendTo.call{value: amount}(\"\");\r\n        require(success);\r\n        emit EtherWithdraw(amount, sendTo);\r\n    }\r\n\r\n    /// @dev Withdraw all IERC20 compatible tokens\r\n    /// @param token IERC20 The address of the token contract\r\n    function withdrawToken(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address sendTo\r\n    ) external {\r\n        onlyAdmin();\r\n        token.transfer(sendTo, amount);\r\n        emit TokenWithdraw(token, amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/IKyberReserve.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberReserve {\r\n    function trade(\r\n        IERC20 srcToken,\r\n        uint256 srcAmount,\r\n        IERC20 destToken,\r\n        address payable destAddress,\r\n        uint256 conversionRate,\r\n        bool validate\r\n    ) external payable returns (bool);\r\n\r\n    function getConversionRate(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 blockNumber\r\n    ) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/IKyberNetwork.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberNetwork {\r\n    event KyberTrade(\r\n        IERC20 indexed src,\r\n        IERC20 indexed dest,\r\n        uint256 ethWeiValue,\r\n        uint256 networkFeeWei,\r\n        uint256 customPlatformFeeWei,\r\n        bytes32[] t2eIds,\r\n        bytes32[] e2tIds,\r\n        uint256[] t2eSrcAmounts,\r\n        uint256[] e2tSrcAmounts,\r\n        uint256[] t2eRates,\r\n        uint256[] e2tRates\r\n    );\r\n\r\n    function tradeWithHintAndFee(\r\n        address payable trader,\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256 destAmount);\r\n\r\n    function listTokenForReserve(\r\n        address reserve,\r\n        IERC20 token,\r\n        bool add\r\n    ) external;\r\n\r\n    function enabled() external view returns (bool);\r\n\r\n    function getExpectedRateWithHintAndFee(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 expectedRateAfterNetworkFee,\r\n            uint256 expectedRateAfterAllFees\r\n        );\r\n\r\n    function getNetworkData()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 negligibleDiffBps,\r\n            uint256 networkFeeBps,\r\n            uint256 expiryTimestamp\r\n        );\r\n\r\n    function maxGasPrice() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/IKyberNetworkProxy.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberNetworkProxy {\r\n\r\n    event ExecuteTrade(\r\n        address indexed trader,\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        address destAddress,\r\n        uint256 actualSrcAmount,\r\n        uint256 actualDestAmount,\r\n        address platformWallet,\r\n        uint256 platformFeeBps\r\n    );\r\n\r\n    /// @notice backward compatible\r\n    function tradeWithHint(\r\n        ERC20 src,\r\n        uint256 srcAmount,\r\n        ERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable walletId,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256);\r\n\r\n    function tradeWithHintAndFee(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256 destAmount);\r\n\r\n    function trade(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet\r\n    ) external payable returns (uint256);\r\n\r\n    /// @notice backward compatible\r\n    /// @notice Rate units (10 ** 18) => destQty (twei) / srcQty (twei) * 10 ** 18\r\n    function getExpectedRate(\r\n        ERC20 src,\r\n        ERC20 dest,\r\n        uint256 srcQty\r\n    ) external view returns (uint256 expectedRate, uint256 worstRate);\r\n\r\n    function getExpectedRateAfterFee(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external view returns (uint256 expectedRate);\r\n}\r\n\r\n// File: contracts/sol6/IKyberStorage.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\ninterface IKyberStorage {\r\n    enum ReserveType {NONE, FPR, APR, BRIDGE, UTILITY, CUSTOM, ORDERBOOK, LAST}\r\n\r\n    function addKyberProxy(address kyberProxy, uint256 maxApprovedProxies)\r\n        external;\r\n\r\n    function removeKyberProxy(address kyberProxy) external;\r\n\r\n    function setContracts(address _kyberFeeHandler, address _kyberMatchingEngine) external;\r\n\r\n    function setKyberDaoContract(address _kyberDao) external;\r\n\r\n    function getReserveId(address reserve) external view returns (bytes32 reserveId);\r\n\r\n    function getReserveIdsFromAddresses(address[] calldata reserveAddresses)\r\n        external\r\n        view\r\n        returns (bytes32[] memory reserveIds);\r\n\r\n    function getReserveAddressesFromIds(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (address[] memory reserveAddresses);\r\n\r\n    function getReserveIdsPerTokenSrc(IERC20 token)\r\n        external\r\n        view\r\n        returns (bytes32[] memory reserveIds);\r\n\r\n    function getReserveAddressesPerTokenSrc(IERC20 token, uint256 startIndex, uint256 endIndex)\r\n        external\r\n        view\r\n        returns (address[] memory reserveAddresses);\r\n\r\n    function getReserveIdsPerTokenDest(IERC20 token)\r\n        external\r\n        view\r\n        returns (bytes32[] memory reserveIds);\r\n\r\n    function getReserveAddressesByReserveId(bytes32 reserveId)\r\n        external\r\n        view\r\n        returns (address[] memory reserveAddresses);\r\n\r\n    function getRebateWalletsFromIds(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (address[] memory rebateWallets);\r\n\r\n    function getKyberProxies() external view returns (IKyberNetworkProxy[] memory);\r\n\r\n    function getReserveDetailsByAddress(address reserve)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 reserveId,\r\n            address rebateWallet,\r\n            ReserveType resType,\r\n            bool isFeeAccountedFlag,\r\n            bool isEntitledRebateFlag\r\n        );\r\n\r\n    function getReserveDetailsById(bytes32 reserveId)\r\n        external\r\n        view\r\n        returns (\r\n            address reserveAddress,\r\n            address rebateWallet,\r\n            ReserveType resType,\r\n            bool isFeeAccountedFlag,\r\n            bool isEntitledRebateFlag\r\n        );\r\n\r\n    function getFeeAccountedData(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (bool[] memory feeAccountedArr);\r\n\r\n    function getEntitledRebateData(bytes32[] calldata reserveIds)\r\n        external\r\n        view\r\n        returns (bool[] memory entitledRebateArr);\r\n\r\n    function getReservesData(bytes32[] calldata reserveIds, IERC20 src, IERC20 dest)\r\n        external\r\n        view\r\n        returns (\r\n            bool areAllReservesListed,\r\n            bool[] memory feeAccountedArr,\r\n            bool[] memory entitledRebateArr,\r\n            IKyberReserve[] memory reserveAddresses);\r\n\r\n    function isKyberProxyAdded() external view returns (bool);\r\n}\r\n\r\n// File: contracts/sol6/IKyberMatchingEngine.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\ninterface IKyberMatchingEngine {\r\n    enum ProcessWithRate {NotRequired, Required}\r\n\r\n    function setNegligibleRateDiffBps(uint256 _negligibleRateDiffBps) external;\r\n\r\n    function setKyberStorage(IKyberStorage _kyberStorage) external;\r\n\r\n    function getNegligibleRateDiffBps() external view returns (uint256);\r\n\r\n    function getTradingReserves(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        bool isTokenToToken,\r\n        bytes calldata hint\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32[] memory reserveIds,\r\n            uint256[] memory splitValuesBps,\r\n            ProcessWithRate processWithRate\r\n        );\r\n\r\n    function doMatch(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256[] calldata srcAmounts,\r\n        uint256[] calldata feesAccountedDestBps,\r\n        uint256[] calldata rates\r\n    ) external view returns (uint256[] memory reserveIndexes);\r\n}\r\n\r\n// File: contracts/sol6/utils/Utils5.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n/**\r\n * @title Kyber utility file\r\n * mostly shared constants and rate calculation helpers\r\n * inherited by most of kyber contracts.\r\n * previous utils implementations are for previous solidity versions.\r\n */\r\ncontract Utils5 {\r\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n    );\r\n    uint256 internal constant PRECISION = (10**18);\r\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\r\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\r\n    uint256 internal constant MAX_DECIMALS = 18;\r\n    uint256 internal constant ETH_DECIMALS = 18;\r\n    uint256 constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\r\n    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\r\n\r\n    mapping(IERC20 => uint256) internal decimals;\r\n\r\n    function getUpdateDecimals(IERC20 token) internal returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) {\r\n            tokenDecimals = token.decimals();\r\n            decimals[token] = tokenDecimals;\r\n        }\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function setDecimals(IERC20 token) internal {\r\n        if (decimals[token] != 0) return; //already set\r\n\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            decimals[token] = ETH_DECIMALS;\r\n        } else {\r\n            decimals[token] = token.decimals();\r\n        }\r\n    }\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(IERC20 token, address user) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            return user.balance;\r\n        } else {\r\n            return token.balanceOf(user);\r\n        }\r\n    }\r\n\r\n    function getDecimals(IERC20 token) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDestAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 destAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcDstQty(\r\n        uint256 srcQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(srcQty <= MAX_QTY, \"srcQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(\r\n        uint256 dstQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(dstQty <= MAX_QTY, \"dstQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint256 numerator;\r\n        uint256 denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcRateFromQty(\r\n        uint256 srcAmount,\r\n        uint256 destAmount,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals\r\n    ) internal pure returns (uint256) {\r\n        require(srcAmount <= MAX_QTY, \"srcAmount > MAX_QTY\");\r\n        require(destAmount <= MAX_QTY, \"destAmount > MAX_QTY\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\r\n        }\r\n    }\r\n\r\n    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/IKyberHint.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberHint {\r\n    enum TradeType {BestOfAll, MaskIn, MaskOut, Split}\r\n    enum HintErrors {\r\n        NoError, // Hint is valid\r\n        NonEmptyDataError, // reserveIDs and splits must be empty for BestOfAll hint\r\n        ReserveIdDupError, // duplicate reserveID found\r\n        ReserveIdEmptyError, // reserveIDs array is empty for MaskIn and Split trade type\r\n        ReserveIdSplitsError, // reserveIDs and splitBpsValues arrays do not have the same length\r\n        ReserveIdSequenceError, // reserveID sequence in array is not in increasing order\r\n        ReserveIdNotFound, // reserveID isn't registered or doesn't exist\r\n        SplitsNotEmptyError, // splitBpsValues is not empty for MaskIn or MaskOut trade type\r\n        TokenListedError, // reserveID not listed for the token\r\n        TotalBPSError // total BPS for Split trade type is not 10000 (100%)\r\n    }\r\n\r\n    function buildTokenToEthHint(\r\n        IERC20 tokenSrc,\r\n        TradeType tokenToEthType,\r\n        bytes32[] calldata tokenToEthReserveIds,\r\n        uint256[] calldata tokenToEthSplits\r\n    ) external view returns (bytes memory hint);\r\n\r\n    function buildEthToTokenHint(\r\n        IERC20 tokenDest,\r\n        TradeType ethToTokenType,\r\n        bytes32[] calldata ethToTokenReserveIds,\r\n        uint256[] calldata ethToTokenSplits\r\n    ) external view returns (bytes memory hint);\r\n\r\n    function buildTokenToTokenHint(\r\n        IERC20 tokenSrc,\r\n        TradeType tokenToEthType,\r\n        bytes32[] calldata tokenToEthReserveIds,\r\n        uint256[] calldata tokenToEthSplits,\r\n        IERC20 tokenDest,\r\n        TradeType ethToTokenType,\r\n        bytes32[] calldata ethToTokenReserveIds,\r\n        uint256[] calldata ethToTokenSplits\r\n    ) external view returns (bytes memory hint);\r\n\r\n    function parseTokenToEthHint(IERC20 tokenSrc, bytes calldata hint)\r\n        external\r\n        view\r\n        returns (\r\n            TradeType tokenToEthType,\r\n            bytes32[] memory tokenToEthReserveIds,\r\n            IKyberReserve[] memory tokenToEthAddresses,\r\n            uint256[] memory tokenToEthSplits\r\n        );\r\n\r\n    function parseEthToTokenHint(IERC20 tokenDest, bytes calldata hint)\r\n        external\r\n        view\r\n        returns (\r\n            TradeType ethToTokenType,\r\n            bytes32[] memory ethToTokenReserveIds,\r\n            IKyberReserve[] memory ethToTokenAddresses,\r\n            uint256[] memory ethToTokenSplits\r\n        );\r\n\r\n    function parseTokenToTokenHint(IERC20 tokenSrc, IERC20 tokenDest, bytes calldata hint)\r\n        external\r\n        view\r\n        returns (\r\n            TradeType tokenToEthType,\r\n            bytes32[] memory tokenToEthReserveIds,\r\n            IKyberReserve[] memory tokenToEthAddresses,\r\n            uint256[] memory tokenToEthSplits,\r\n            TradeType ethToTokenType,\r\n            bytes32[] memory ethToTokenReserveIds,\r\n            IKyberReserve[] memory ethToTokenAddresses,\r\n            uint256[] memory ethToTokenSplits\r\n        );\r\n}\r\n\r\n// File: contracts/sol6/KyberHintHandler.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n/**\r\n *   @title kyberHintHandler contract\r\n *   The contract provides the following functionality:\r\n *       - building hints\r\n *       - parsing hints\r\n *\r\n *       All external functions, build*Hint() and parse*Hint:\r\n *           - Will revert with error message if an error is found\r\n *           - parse*Hint() returns both reserveIds and reserveAddresses\r\n *       Internal functions unpackT2THint() and parseHint():\r\n *           - Are part of get rate && trade flow\r\n *           - Don't revert if an error is found\r\n *           - If an error is found, return no data such that the trade flow\r\n *             returns 0 rate for bad hint values\r\n */\r\nabstract contract KyberHintHandler is IKyberHint, Utils5 {\r\n    /// @notice Parses the hint for a token -> eth trade\r\n    /// @param tokenSrc source token to trade\r\n    /// @param hint The ABI encoded hint, built using the build*Hint functions\r\n    /// @return tokenToEthType Decoded hint type\r\n    /// @return tokenToEthReserveIds Decoded reserve IDs\r\n    /// @return tokenToEthAddresses Reserve addresses corresponding to reserve IDs\r\n    /// @return tokenToEthSplits Decoded splits\r\n    function parseTokenToEthHint(IERC20 tokenSrc, bytes memory hint)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            TradeType tokenToEthType,\r\n            bytes32[] memory tokenToEthReserveIds,\r\n            IKyberReserve[] memory tokenToEthAddresses,\r\n            uint256[] memory tokenToEthSplits\r\n        )\r\n    {\r\n        HintErrors error;\r\n\r\n        (tokenToEthType, tokenToEthReserveIds, tokenToEthSplits, error) = parseHint(hint);\r\n        if (error != HintErrors.NoError) throwHintError(error);\r\n\r\n        if (tokenToEthType == TradeType.MaskIn || tokenToEthType == TradeType.Split) {\r\n            checkTokenListedForReserve(tokenSrc, tokenToEthReserveIds, true);\r\n        }\r\n\r\n        tokenToEthAddresses = new IKyberReserve[](tokenToEthReserveIds.length);\r\n\r\n        for (uint256 i = 0; i < tokenToEthReserveIds.length; i++) {\r\n            checkReserveIdsExists(tokenToEthReserveIds[i]);\r\n            checkDuplicateReserveIds(tokenToEthReserveIds, i);\r\n\r\n            if (i > 0 && tokenToEthType == TradeType.Split) {\r\n                checkSplitReserveIdSeq(tokenToEthReserveIds[i], tokenToEthReserveIds[i - 1]);\r\n            }\r\n\r\n            tokenToEthAddresses[i] = IKyberReserve(\r\n                getReserveAddress(tokenToEthReserveIds[i])\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Parses the hint for a eth -> token trade\r\n    /// @param tokenDest destination token to trade\r\n    /// @param hint The ABI encoded hint, built using the build*Hint functions\r\n    /// @return ethToTokenType Decoded hint type\r\n    /// @return ethToTokenReserveIds Decoded reserve IDs\r\n    /// @return ethToTokenAddresses Reserve addresses corresponding to reserve IDs\r\n    /// @return ethToTokenSplits Decoded splits\r\n    function parseEthToTokenHint(IERC20 tokenDest, bytes memory hint)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            TradeType ethToTokenType,\r\n            bytes32[] memory ethToTokenReserveIds,\r\n            IKyberReserve[] memory ethToTokenAddresses,\r\n            uint256[] memory ethToTokenSplits\r\n        )\r\n    {\r\n        HintErrors error;\r\n\r\n        (ethToTokenType, ethToTokenReserveIds, ethToTokenSplits, error) = parseHint(hint);\r\n        if (error != HintErrors.NoError) throwHintError(error);\r\n\r\n        if (ethToTokenType == TradeType.MaskIn || ethToTokenType == TradeType.Split) {\r\n            checkTokenListedForReserve(tokenDest, ethToTokenReserveIds, false);\r\n        }\r\n\r\n        ethToTokenAddresses = new IKyberReserve[](ethToTokenReserveIds.length);\r\n\r\n        for (uint256 i = 0; i < ethToTokenReserveIds.length; i++) {\r\n            checkReserveIdsExists(ethToTokenReserveIds[i]);\r\n            checkDuplicateReserveIds(ethToTokenReserveIds, i);\r\n\r\n            if (i > 0 && ethToTokenType == TradeType.Split) {\r\n                checkSplitReserveIdSeq(ethToTokenReserveIds[i], ethToTokenReserveIds[i - 1]);\r\n            }\r\n\r\n            ethToTokenAddresses[i] = IKyberReserve(\r\n                getReserveAddress(ethToTokenReserveIds[i])\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Parses the hint for a token to token trade\r\n    /// @param tokenSrc source token to trade\r\n    /// @param tokenDest destination token to trade\r\n    /// @param hint The ABI encoded hint, built using the build*Hint functions\r\n    /// @return tokenToEthType Decoded hint type\r\n    /// @return tokenToEthReserveIds Decoded reserve IDs\r\n    /// @return tokenToEthAddresses Reserve addresses corresponding to reserve IDs\r\n    /// @return tokenToEthSplits Decoded splits\r\n    /// @return ethToTokenType Decoded hint type\r\n    /// @return ethToTokenReserveIds Decoded reserve IDs\r\n    /// @return ethToTokenAddresses Reserve addresses corresponding to reserve IDs\r\n    /// @return ethToTokenSplits Decoded splits\r\n    function parseTokenToTokenHint(IERC20 tokenSrc, IERC20 tokenDest, bytes memory hint)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            TradeType tokenToEthType,\r\n            bytes32[] memory tokenToEthReserveIds,\r\n            IKyberReserve[] memory tokenToEthAddresses,\r\n            uint256[] memory tokenToEthSplits,\r\n            TradeType ethToTokenType,\r\n            bytes32[] memory ethToTokenReserveIds,\r\n            IKyberReserve[] memory ethToTokenAddresses,\r\n            uint256[] memory ethToTokenSplits\r\n        )\r\n    {\r\n        bytes memory t2eHint;\r\n        bytes memory e2tHint;\r\n\r\n        (t2eHint, e2tHint) = unpackT2THint(hint);\r\n\r\n        (\r\n            tokenToEthType,\r\n            tokenToEthReserveIds,\r\n            tokenToEthAddresses,\r\n            tokenToEthSplits\r\n        ) = parseTokenToEthHint(tokenSrc, t2eHint);\r\n\r\n        (\r\n            ethToTokenType,\r\n            ethToTokenReserveIds,\r\n            ethToTokenAddresses,\r\n            ethToTokenSplits\r\n        ) = parseEthToTokenHint(tokenDest, e2tHint);\r\n    }\r\n\r\n    /// @notice Builds the hint for a token -> eth trade\r\n    /// @param tokenSrc source token to trade\r\n    /// @param tokenToEthType token -> eth trade hint type\r\n    /// @param tokenToEthReserveIds token -> eth reserve IDs\r\n    /// @param tokenToEthSplits token -> eth reserve splits\r\n    /// @return hint The ABI encoded hint\r\n    function buildTokenToEthHint(\r\n        IERC20 tokenSrc,\r\n        TradeType tokenToEthType,\r\n        bytes32[] memory tokenToEthReserveIds,\r\n        uint256[] memory tokenToEthSplits\r\n    ) public view override returns (bytes memory hint) {\r\n        for (uint256 i = 0; i < tokenToEthReserveIds.length; i++) {\r\n            checkReserveIdsExists(tokenToEthReserveIds[i]);\r\n        }\r\n\r\n        HintErrors valid = verifyData(\r\n            tokenToEthType,\r\n            tokenToEthReserveIds,\r\n            tokenToEthSplits\r\n        );\r\n        if (valid != HintErrors.NoError) throwHintError(valid);\r\n\r\n        if (tokenToEthType == TradeType.MaskIn || tokenToEthType == TradeType.Split) {\r\n            checkTokenListedForReserve(tokenSrc, tokenToEthReserveIds, true);\r\n        }\r\n\r\n        if (tokenToEthType == TradeType.Split) {\r\n            bytes32[] memory seqT2EReserveIds;\r\n            uint256[] memory seqT2ESplits;\r\n\r\n            (seqT2EReserveIds, seqT2ESplits) = ensureSplitSeq(\r\n                tokenToEthReserveIds,\r\n                tokenToEthSplits\r\n            );\r\n\r\n            hint = abi.encode(tokenToEthType, seqT2EReserveIds, seqT2ESplits);\r\n        } else {\r\n            hint = abi.encode(tokenToEthType, tokenToEthReserveIds, tokenToEthSplits);\r\n        }\r\n    }\r\n\r\n    /// @notice Builds the hint for a eth -> token trade\r\n    /// @param tokenDest destination token to trade\r\n    /// @param ethToTokenType eth -> token trade hint type\r\n    /// @param ethToTokenReserveIds eth -> token reserve IDs\r\n    /// @param ethToTokenSplits eth -> token reserve splits\r\n    /// @return hint The ABI encoded hint\r\n    function buildEthToTokenHint(\r\n        IERC20 tokenDest,\r\n        TradeType ethToTokenType,\r\n        bytes32[] memory ethToTokenReserveIds,\r\n        uint256[] memory ethToTokenSplits\r\n    ) public view override returns (bytes memory hint) {\r\n        for (uint256 i = 0; i < ethToTokenReserveIds.length; i++) {\r\n            checkReserveIdsExists(ethToTokenReserveIds[i]);\r\n        }\r\n\r\n        HintErrors valid = verifyData(\r\n            ethToTokenType,\r\n            ethToTokenReserveIds,\r\n            ethToTokenSplits\r\n        );\r\n        if (valid != HintErrors.NoError) throwHintError(valid);\r\n\r\n        if (ethToTokenType == TradeType.MaskIn || ethToTokenType == TradeType.Split) {\r\n            checkTokenListedForReserve(tokenDest, ethToTokenReserveIds, false);\r\n        }\r\n\r\n        if (ethToTokenType == TradeType.Split) {\r\n            bytes32[] memory seqE2TReserveIds;\r\n            uint256[] memory seqE2TSplits;\r\n\r\n            (seqE2TReserveIds, seqE2TSplits) = ensureSplitSeq(\r\n                ethToTokenReserveIds,\r\n                ethToTokenSplits\r\n            );\r\n\r\n            hint = abi.encode(ethToTokenType, seqE2TReserveIds, seqE2TSplits);\r\n        } else {\r\n            hint = abi.encode(ethToTokenType, ethToTokenReserveIds, ethToTokenSplits);\r\n        }\r\n    }\r\n\r\n    /// @notice Builds the hint for a token to token trade\r\n    /// @param tokenSrc source token to trade\r\n    /// @param tokenToEthType token -> eth trade hint type\r\n    /// @param tokenToEthReserveIds token -> eth reserve IDs\r\n    /// @param tokenToEthSplits token -> eth reserve splits\r\n    /// @param tokenDest destination token to trade\r\n    /// @param ethToTokenType eth -> token trade hint type\r\n    /// @param ethToTokenReserveIds eth -> token reserve IDs\r\n    /// @param ethToTokenSplits eth -> token reserve splits\r\n    /// @return hint The ABI encoded hint\r\n    function buildTokenToTokenHint(\r\n        IERC20 tokenSrc,\r\n        TradeType tokenToEthType,\r\n        bytes32[] memory tokenToEthReserveIds,\r\n        uint256[] memory tokenToEthSplits,\r\n        IERC20 tokenDest,\r\n        TradeType ethToTokenType,\r\n        bytes32[] memory ethToTokenReserveIds,\r\n        uint256[] memory ethToTokenSplits\r\n    ) public view override returns (bytes memory hint) {\r\n        bytes memory t2eHint = buildTokenToEthHint(\r\n            tokenSrc,\r\n            tokenToEthType,\r\n            tokenToEthReserveIds,\r\n            tokenToEthSplits\r\n        );\r\n\r\n        bytes memory e2tHint = buildEthToTokenHint(\r\n            tokenDest,\r\n            ethToTokenType,\r\n            ethToTokenReserveIds,\r\n            ethToTokenSplits\r\n        );\r\n\r\n        hint = abi.encode(t2eHint, e2tHint);\r\n    }\r\n\r\n    /// @notice Parses or decodes the token -> eth or eth -> token bytes hint\r\n    /// @param hint token -> eth or eth -> token trade hint\r\n    /// @return tradeType Decoded hint type\r\n    /// @return reserveIds Decoded reserve IDs\r\n    /// @return splits Reserve addresses corresponding to reserve IDs\r\n    /// @return valid Whether the decoded is valid\r\n    function parseHint(bytes memory hint)\r\n        internal\r\n        pure\r\n        returns (\r\n            TradeType tradeType,\r\n            bytes32[] memory reserveIds,\r\n            uint256[] memory splits,\r\n            HintErrors valid\r\n        )\r\n    {\r\n        (tradeType, reserveIds, splits) = abi.decode(hint, (TradeType, bytes32[], uint256[])); // solhint-disable\r\n        valid = verifyData(tradeType, reserveIds, splits);\r\n\r\n        if (valid != HintErrors.NoError) {\r\n            reserveIds = new bytes32[](0);\r\n            splits = new uint256[](0);\r\n        }\r\n    }\r\n\r\n    /// @notice Unpacks the token to token hint to token -> eth and eth -> token hints\r\n    /// @param hint token to token trade hint\r\n    /// @return t2eHint The ABI encoded token -> eth hint\r\n    /// @return e2tHint The ABI encoded eth -> token hint\r\n    function unpackT2THint(bytes memory hint)\r\n        internal\r\n        pure\r\n        returns (bytes memory t2eHint, bytes memory e2tHint)\r\n    {\r\n        (t2eHint, e2tHint) = abi.decode(hint, (bytes, bytes));\r\n    }\r\n\r\n    /// @notice Checks if the reserveId exists\r\n    /// @param reserveId Reserve ID to check\r\n    function checkReserveIdsExists(bytes32 reserveId)\r\n        internal\r\n        view\r\n    {\r\n        if (getReserveAddress(reserveId) == address(0))\r\n            throwHintError(HintErrors.ReserveIdNotFound);\r\n    }\r\n\r\n    /// @notice Checks that the token is listed for the reserves\r\n    /// @param token ERC20 token\r\n    /// @param reserveIds Reserve IDs\r\n    /// @param isTokenToEth Flag to indicate token -> eth or eth -> token\r\n    function checkTokenListedForReserve(\r\n        IERC20 token,\r\n        bytes32[] memory reserveIds,\r\n        bool isTokenToEth\r\n    ) internal view {\r\n        IERC20 src = (isTokenToEth) ? token : ETH_TOKEN_ADDRESS;\r\n        IERC20 dest = (isTokenToEth) ? ETH_TOKEN_ADDRESS : token;\r\n\r\n        if (!areAllReservesListed(reserveIds, src, dest))\r\n            throwHintError(HintErrors.TokenListedError);\r\n    }\r\n\r\n    /// @notice Ensures that the reserveIds in the hint to be parsed has no duplicates\r\n    /// and applies to all trade types\r\n    /// @param reserveIds Array of reserve IDs\r\n    /// @param i Starting index from outer loop\r\n    function checkDuplicateReserveIds(bytes32[] memory reserveIds, uint256 i)\r\n        internal\r\n        pure\r\n    {\r\n        for (uint256 j = i + 1; j < reserveIds.length; j++) {\r\n            if (uint256(reserveIds[i]) == uint256(reserveIds[j])) {\r\n                throwHintError(HintErrors.ReserveIdDupError);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Ensures that the reserveIds in the hint to be parsed is in\r\n    /// sequence for and applies to only Split trade type\r\n    /// @param reserveId Current index Reserve ID in array\r\n    /// @param prevReserveId Previous index Reserve ID in array\r\n    function checkSplitReserveIdSeq(bytes32 reserveId, bytes32 prevReserveId)\r\n        internal\r\n        pure\r\n    {\r\n        if (uint256(reserveId) <= uint256(prevReserveId)) {\r\n            throwHintError(HintErrors.ReserveIdSequenceError);\r\n        }\r\n    }\r\n\r\n    /// @notice Ensures that the reserveIds and splits passed when building Split hints are in increasing sequence\r\n    /// @param reserveIds Reserve IDs\r\n    /// @param splits Reserve splits\r\n    /// @return Returns a bytes32[] with reserveIds in increasing sequence and respective arranged splits\r\n    function ensureSplitSeq(\r\n        bytes32[] memory reserveIds,\r\n        uint256[] memory splits\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32[] memory, uint256[] memory)\r\n    {\r\n        for (uint256 i = 0; i < reserveIds.length; i++) {\r\n            for (uint256 j = i + 1; j < reserveIds.length; j++) {\r\n                if (uint256(reserveIds[i]) > (uint256(reserveIds[j]))) {\r\n                    bytes32 tempId = reserveIds[i];\r\n                    uint256 tempSplit = splits[i];\r\n\r\n                    reserveIds[i] = reserveIds[j];\r\n                    reserveIds[j] = tempId;\r\n                    splits[i] = splits[j];\r\n                    splits[j] = tempSplit;\r\n                } else if (reserveIds[i] == reserveIds[j]) {\r\n                    throwHintError(HintErrors.ReserveIdDupError);\r\n                }\r\n            }\r\n        }\r\n\r\n        return (reserveIds, splits);\r\n    }\r\n\r\n    /// @notice Ensures that the data passed when building/parsing hints is valid\r\n    /// @param tradeType Trade hint type\r\n    /// @param reserveIds Reserve IDs\r\n    /// @param splits Reserve splits\r\n    /// @return Returns a HintError enum to indicate valid or invalid hint data\r\n    function verifyData(\r\n        TradeType tradeType,\r\n        bytes32[] memory reserveIds,\r\n        uint256[] memory splits\r\n    ) internal pure returns (HintErrors) {\r\n        if (tradeType == TradeType.BestOfAll) {\r\n            if (reserveIds.length != 0 || splits.length != 0) return HintErrors.NonEmptyDataError;\r\n        }\r\n\r\n        if (\r\n            (tradeType == TradeType.MaskIn || tradeType == TradeType.Split) &&\r\n            reserveIds.length == 0\r\n        ) return HintErrors.ReserveIdEmptyError;\r\n\r\n        if (tradeType == TradeType.Split) {\r\n            if (reserveIds.length != splits.length) return HintErrors.ReserveIdSplitsError;\r\n\r\n            uint256 bpsSoFar;\r\n            for (uint256 i = 0; i < splits.length; i++) {\r\n                bpsSoFar += splits[i];\r\n            }\r\n\r\n            if (bpsSoFar != BPS) return HintErrors.TotalBPSError;\r\n        } else {\r\n            if (splits.length != 0) return HintErrors.SplitsNotEmptyError;\r\n        }\r\n\r\n        return HintErrors.NoError;\r\n    }\r\n\r\n    /// @notice Throws error message to user to indicate error on hint\r\n    /// @param error Error type from HintErrors enum\r\n    function throwHintError(HintErrors error) internal pure {\r\n        if (error == HintErrors.NonEmptyDataError) revert(\"reserveIds and splits must be empty\");\r\n        if (error == HintErrors.ReserveIdDupError) revert(\"duplicate reserveId\");\r\n        if (error == HintErrors.ReserveIdEmptyError) revert(\"reserveIds cannot be empty\");\r\n        if (error == HintErrors.ReserveIdSplitsError) revert(\"reserveIds.length != splits.length\");\r\n        if (error == HintErrors.ReserveIdSequenceError) revert(\"reserveIds not in increasing order\");\r\n        if (error == HintErrors.ReserveIdNotFound) revert(\"reserveId not found\");\r\n        if (error == HintErrors.SplitsNotEmptyError) revert(\"splits must be empty\");\r\n        if (error == HintErrors.TokenListedError) revert(\"token is not listed for reserveId\");\r\n        if (error == HintErrors.TotalBPSError) revert(\"total BPS != 10000\");\r\n    }\r\n\r\n    function getReserveAddress(bytes32 reserveId) internal view virtual returns (address);\r\n\r\n    function areAllReservesListed(\r\n        bytes32[] memory reserveIds,\r\n        IERC20 src,\r\n        IERC20 dest\r\n    ) internal virtual view returns (bool);\r\n}\r\n\r\n// File: contracts/sol6/KyberMatchingEngine.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n *   @title kyberMatchingEngine contract\r\n *   During getExpectedRate flow and trade flow this contract is called for:\r\n *       - parsing hint and returning reserve list (function getTradingReserves)\r\n *       - matching best reserves to trade with (function doMatch)\r\n */\r\ncontract KyberMatchingEngine is KyberHintHandler, IKyberMatchingEngine, WithdrawableNoModifiers {\r\n    struct BestReserveInfo {\r\n        uint256 index;\r\n        uint256 destAmount;\r\n        uint256 numRelevantReserves;\r\n    }\r\n    IKyberNetwork public kyberNetwork;\r\n    IKyberStorage public kyberStorage;\r\n\r\n    uint256 negligibleRateDiffBps = 5; // 1 bps is 0.01%\r\n\r\n    event KyberStorageUpdated(IKyberStorage newKyberStorage);\r\n    event KyberNetworkUpdated(IKyberNetwork newKyberNetwork);\r\n\r\n    constructor(address _admin) public WithdrawableNoModifiers(_admin) {\r\n        /* empty body */\r\n    }\r\n\r\n    function setKyberStorage(IKyberStorage _kyberStorage) external virtual override {\r\n        onlyAdmin();\r\n        emit KyberStorageUpdated(_kyberStorage);\r\n        kyberStorage = _kyberStorage;\r\n    }\r\n\r\n    function setNegligibleRateDiffBps(uint256 _negligibleRateDiffBps)\r\n        external\r\n        virtual\r\n        override\r\n    {\r\n        onlyNetwork();\r\n        require(_negligibleRateDiffBps <= BPS, \"rateDiffBps exceed BPS\"); // at most 100%\r\n        negligibleRateDiffBps = _negligibleRateDiffBps;\r\n    }\r\n\r\n    function setNetworkContract(IKyberNetwork _kyberNetwork) external {\r\n        onlyAdmin();\r\n        require(_kyberNetwork != IKyberNetwork(0), \"kyberNetwork 0\");\r\n        emit KyberNetworkUpdated(_kyberNetwork);\r\n        kyberNetwork = _kyberNetwork;\r\n    }\r\n\r\n    /// @dev Returns trading reserves info for a trade\r\n    /// @param src Source token\r\n    /// @param dest Destination token\r\n    /// @param isTokenToToken Whether the trade is token -> token\r\n    /// @param hint Advanced instructions for running the trade\r\n    /// @return reserveIds Array of reserve IDs for the trade, each being 32 bytes\r\n    /// @return splitValuesBps Array of split values (in basis points) for the trade\r\n    /// @return processWithRate Enum ProcessWithRate, whether extra processing is required or not\r\n    function getTradingReserves(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        bool isTokenToToken,\r\n        bytes calldata hint\r\n    )\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            bytes32[] memory reserveIds,\r\n            uint256[] memory splitValuesBps,\r\n            ProcessWithRate processWithRate\r\n        )\r\n    {\r\n        HintErrors error;\r\n        if (hint.length == 0 || hint.length == 4) {\r\n            reserveIds = (dest == ETH_TOKEN_ADDRESS)\r\n                ? kyberStorage.getReserveIdsPerTokenSrc(src)\r\n                : kyberStorage.getReserveIdsPerTokenDest(dest);\r\n\r\n            splitValuesBps = populateSplitValuesBps(reserveIds.length);\r\n            processWithRate = ProcessWithRate.Required;\r\n            return (reserveIds, splitValuesBps, processWithRate);\r\n        }\r\n\r\n        TradeType tradeType;\r\n\r\n        if (isTokenToToken) {\r\n            bytes memory unpackedHint;\r\n            if (src == ETH_TOKEN_ADDRESS) {\r\n                (, unpackedHint) = unpackT2THint(hint);\r\n                (tradeType, reserveIds, splitValuesBps, error) = parseHint(unpackedHint);\r\n            }\r\n            if (dest == ETH_TOKEN_ADDRESS) {\r\n                (unpackedHint, ) = unpackT2THint(hint);\r\n                (tradeType, reserveIds, splitValuesBps, error) = parseHint(unpackedHint);\r\n            }\r\n        } else {\r\n            (tradeType, reserveIds, splitValuesBps, error) = parseHint(hint);\r\n        }\r\n\r\n        if (error != HintErrors.NoError)\r\n            return (new bytes32[](0), new uint256[](0), ProcessWithRate.NotRequired);\r\n\r\n        if (tradeType == TradeType.MaskIn) {\r\n            splitValuesBps = populateSplitValuesBps(reserveIds.length);\r\n        } else if (tradeType == TradeType.BestOfAll || tradeType == TradeType.MaskOut) {\r\n            bytes32[] memory allReserves = (dest == ETH_TOKEN_ADDRESS)\r\n                ? kyberStorage.getReserveIdsPerTokenSrc(src)\r\n                : kyberStorage.getReserveIdsPerTokenDest(dest);\r\n\r\n            // if bestOfAll, reserveIds = allReserves\r\n            // if mask out, apply masking out logic\r\n            reserveIds = (tradeType == TradeType.BestOfAll) ?\r\n                allReserves :\r\n                maskOutReserves(allReserves, reserveIds);\r\n            splitValuesBps = populateSplitValuesBps(reserveIds.length);\r\n        }\r\n\r\n        // for split no need to search for best rate. User defines full trade details in advance.\r\n        processWithRate = (tradeType == TradeType.Split)\r\n            ? ProcessWithRate.NotRequired\r\n            : ProcessWithRate.Required;\r\n    }\r\n\r\n    function getNegligibleRateDiffBps() external view override returns (uint256) {\r\n        return negligibleRateDiffBps;\r\n    }\r\n\r\n    /// @dev Returns the indexes of the best rate from the rates array\r\n    ///     for token -> eth or eth -> token side of trade\r\n    /// @param src Source token (not needed in this kyberMatchingEngine version)\r\n    /// @param dest Destination token (not needed in this kyberMatchingEngine version)\r\n    /// @param srcAmounts Array of srcAmounts after deducting fees.\r\n    /// @param feesAccountedDestBps Fees charged in BPS, to be deducted from calculated destAmount\r\n    /// @param rates Rates queried from reserves\r\n    /// @return reserveIndexes An array of the indexes most suited for the trade\r\n    function doMatch(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256[] calldata srcAmounts,\r\n        uint256[] calldata feesAccountedDestBps, // 0 for no fee, networkFeeBps when has fee\r\n        uint256[] calldata rates\r\n    ) external view override returns (uint256[] memory reserveIndexes) {\r\n        src;\r\n        dest;\r\n        reserveIndexes = new uint256[](1);\r\n\r\n        // use destAmounts for comparison, but return the best rate\r\n        BestReserveInfo memory bestReserve;\r\n        bestReserve.numRelevantReserves = 1; // assume always best reserve will be relevant\r\n\r\n        // return empty array for unlisted tokens\r\n        if (rates.length == 0) {\r\n            reserveIndexes = new uint256[](0);\r\n            return reserveIndexes;\r\n        }\r\n\r\n        uint256[] memory reserveCandidates = new uint256[](rates.length);\r\n        uint256[] memory destAmounts = new uint256[](rates.length);\r\n        uint256 destAmount;\r\n\r\n        for (uint256 i = 0; i < rates.length; i++) {\r\n            // if fee is accounted on dest amount of this reserve, should deduct it\r\n            destAmount = (srcAmounts[i] * rates[i] * (BPS - feesAccountedDestBps[i])) / BPS;\r\n            if (destAmount > bestReserve.destAmount) {\r\n                // best rate is highest rate\r\n                bestReserve.destAmount = destAmount;\r\n                bestReserve.index = i;\r\n            }\r\n\r\n            destAmounts[i] = destAmount;\r\n        }\r\n\r\n        if (bestReserve.destAmount == 0) {\r\n            reserveIndexes[0] = bestReserve.index;\r\n            return reserveIndexes;\r\n        }\r\n\r\n        reserveCandidates[0] = bestReserve.index;\r\n\r\n        // update best reserve destAmount to be its destAmount after deducting negligible diff.\r\n        // if any reserve has better or equal dest amount it can be considred to be chosen as best\r\n        bestReserve.destAmount = (bestReserve.destAmount * BPS) / (BPS + negligibleRateDiffBps);\r\n\r\n        for (uint256 i = 0; i < rates.length; i++) {\r\n            if (i == bestReserve.index) continue;\r\n            if (destAmounts[i] > bestReserve.destAmount) {\r\n                reserveCandidates[bestReserve.numRelevantReserves++] = i;\r\n            }\r\n        }\r\n\r\n        if (bestReserve.numRelevantReserves > 1) {\r\n            // when encountering small rate diff from bestRate. draw from relevant reserves\r\n            bestReserve.index = reserveCandidates[uint256(blockhash(block.number - 1)) %\r\n                bestReserve.numRelevantReserves];\r\n        } else {\r\n            bestReserve.index = reserveCandidates[0];\r\n        }\r\n\r\n        reserveIndexes[0] = bestReserve.index;\r\n    }\r\n\r\n    function getReserveAddress(bytes32 reserveId) internal view override returns (address reserveAddress) {\r\n        (reserveAddress, , , ,) = kyberStorage.getReserveDetailsById(reserveId);\r\n    }\r\n\r\n    function areAllReservesListed(\r\n        bytes32[] memory reserveIds,\r\n        IERC20 src,\r\n        IERC20 dest\r\n    ) internal override view returns (bool allReservesListed) {\r\n        (allReservesListed, , ,) = kyberStorage.getReservesData(reserveIds, src, dest);\r\n    }\r\n\r\n    /// @notice Logic for masking out reserves\r\n    /// @param allReservesPerToken Array of reserveIds that support\r\n    ///     the token -> eth or eth -> token side of the trade\r\n    /// @param maskedOutReserves Array of reserveIds to be excluded from allReservesPerToken\r\n    /// @return filteredReserves An array of reserveIds that can be used for the trade\r\n    function maskOutReserves(\r\n        bytes32[] memory allReservesPerToken,\r\n        bytes32[] memory maskedOutReserves\r\n    ) internal pure returns (bytes32[] memory filteredReserves) {\r\n        require(\r\n            allReservesPerToken.length >= maskedOutReserves.length,\r\n            \"mask out exceeds available reserves\"\r\n        );\r\n        filteredReserves = new bytes32[](allReservesPerToken.length - maskedOutReserves.length);\r\n        uint256 currentResultIndex = 0;\r\n\r\n        for (uint256 i = 0; i < allReservesPerToken.length; i++) {\r\n            bytes32 reserveId = allReservesPerToken[i];\r\n            bool notMaskedOut = true;\r\n\r\n            for (uint256 j = 0; j < maskedOutReserves.length; j++) {\r\n                bytes32 maskedOutReserveId = maskedOutReserves[j];\r\n                if (reserveId == maskedOutReserveId) {\r\n                    notMaskedOut = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (notMaskedOut) filteredReserves[currentResultIndex++] = reserveId;\r\n        }\r\n    }\r\n\r\n    function onlyNetwork() internal view {\r\n        require(msg.sender == address(kyberNetwork), \"only kyberNetwork\");\r\n    }\r\n\r\n    function populateSplitValuesBps(uint256 length)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory splitValuesBps)\r\n    {\r\n        splitValuesBps = new uint256[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            splitValuesBps[i] = BPS;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IKyberNetwork\",\"name\":\"newKyberNetwork\",\"type\":\"address\"}],\"name\":\"KyberNetworkUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IKyberStorage\",\"name\":\"newKyberStorage\",\"type\":\"address\"}],\"name\":\"KyberStorageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenDest\",\"type\":\"address\"},{\"internalType\":\"enum IKyberHint.TradeType\",\"name\":\"ethToTokenType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"ethToTokenReserveIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ethToTokenSplits\",\"type\":\"uint256[]\"}],\"name\":\"buildEthToTokenHint\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenSrc\",\"type\":\"address\"},{\"internalType\":\"enum IKyberHint.TradeType\",\"name\":\"tokenToEthType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"tokenToEthReserveIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenToEthSplits\",\"type\":\"uint256[]\"}],\"name\":\"buildTokenToEthHint\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenSrc\",\"type\":\"address\"},{\"internalType\":\"enum IKyberHint.TradeType\",\"name\":\"tokenToEthType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"tokenToEthReserveIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenToEthSplits\",\"type\":\"uint256[]\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenDest\",\"type\":\"address\"},{\"internalType\":\"enum IKyberHint.TradeType\",\"name\":\"ethToTokenType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"ethToTokenReserveIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ethToTokenSplits\",\"type\":\"uint256[]\"}],\"name\":\"buildTokenToTokenHint\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"srcAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"feesAccountedDestBps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"}],\"name\":\"doMatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"reserveIndexes\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNegligibleRateDiffBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isTokenToToken\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"name\":\"getTradingReserves\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reserveIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"splitValuesBps\",\"type\":\"uint256[]\"},{\"internalType\":\"enum IKyberMatchingEngine.ProcessWithRate\",\"name\":\"processWithRate\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberNetwork\",\"outputs\":[{\"internalType\":\"contract IKyberNetwork\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kyberStorage\",\"outputs\":[{\"internalType\":\"contract IKyberStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenDest\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"name\":\"parseEthToTokenHint\",\"outputs\":[{\"internalType\":\"enum IKyberHint.TradeType\",\"name\":\"ethToTokenType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"ethToTokenReserveIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"contract IKyberReserve[]\",\"name\":\"ethToTokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ethToTokenSplits\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenSrc\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"name\":\"parseTokenToEthHint\",\"outputs\":[{\"internalType\":\"enum IKyberHint.TradeType\",\"name\":\"tokenToEthType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"tokenToEthReserveIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"contract IKyberReserve[]\",\"name\":\"tokenToEthAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenToEthSplits\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenSrc\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenDest\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"name\":\"parseTokenToTokenHint\",\"outputs\":[{\"internalType\":\"enum IKyberHint.TradeType\",\"name\":\"tokenToEthType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"tokenToEthReserveIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"contract IKyberReserve[]\",\"name\":\"tokenToEthAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenToEthSplits\",\"type\":\"uint256[]\"},{\"internalType\":\"enum IKyberHint.TradeType\",\"name\":\"ethToTokenType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"ethToTokenReserveIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"contract IKyberReserve[]\",\"name\":\"ethToTokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ethToTokenSplits\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberStorage\",\"name\":\"_kyberStorage\",\"type\":\"address\"}],\"name\":\"setKyberStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_negligibleRateDiffBps\",\"type\":\"uint256\"}],\"name\":\"setNegligibleRateDiffBps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKyberNetwork\",\"name\":\"_kyberNetwork\",\"type\":\"address\"}],\"name\":\"setNetworkContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KyberMatchingEngine","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"430","ConstructorArguments":"000000000000000000000000bdd33f411da0b40018922a3bc69001b458227f5c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://118f0c99470624910eee73a9020ab78db82f13dc029e459851c25246871a811b"}]}