{"status":"1","message":"OK","result":[{"SourceCode":"{\"airdrop.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract Airdrop{\\n  using SafeMath for uint;\\n  function airdrop(address[] memory toAirdrop,uint[] memory ethFromEach,uint totalEth,uint tokensRewarded,address tokenAddress) public{\\n    uint totalEth2=0;\\n    uint totalRewards=0;\\n    for(uint i=0;i\\u003ctoAirdrop.length;i++){\\n      totalEth2+=ethFromEach[i];\\n      uint tokensToSend=(tokensRewarded.mul(ethFromEach[i])).div(totalEth);\\n      totalRewards+=tokensToSend;\\n      ERC20(tokenAddress).transferFrom(msg.sender,toAirdrop[i],tokensToSend);\\n\\n    }\\n    require(totalRewards\\u003c=tokensRewarded,\\\"tokens sent must add up to nearly the total\\\");\\n    require(totalRewards\\u003etokensRewarded.sub(tokensRewarded.div(200)),\\\"tokens sent must add up to nearly the total\\\");\\n    require(totalEth2==totalEth,\\\"inputs must add up to the total\\\");\\n  }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"interface ERC20 {\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address who) external view returns (uint256);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function transfer(address to, uint256 value) external returns (bool);\\n  function approve(address spender, uint256 value) external returns (bool);\\n  function approveAndCall(address spender, uint tokens, bytes calldata data) external returns (bool success);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\\n  function burn(uint256 amount) external;\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"library SafeMath {\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    require(c / a == b);\\n    return c;\\n  }\\n  function mult(uint256 x, uint256 y) internal pure returns (uint256) {\\n      if (x == 0) {\\n          return 0;\\n      }\\n\\n      uint256 z = x * y;\\n      require(z / x == y, \\\"Mult overflow\\\");\\n      return z;\\n  }\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a / b;\\n    return c;\\n  }\\n  function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\\n      require(y != 0, \\\"Div by zero\\\");\\n      uint256 r = x / y;\\n      if (x % y != 0) {\\n          r = r + 1;\\n      }\\n\\n      return r;\\n  }\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a);\\n    return c;\\n  }\\n\\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\\n    uint256 c = add(a,m);\\n    uint256 d = sub(c,1);\\n    return mul(div(d,m),m);\\n  }\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"toAirdrop\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ethFromEach\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensRewarded\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"airdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Airdrop","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9c0846e7376d9fece5074530cee211c1bf83abfd5b0cefc62a07794f818f7202"}]}