{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IOneSwapToken.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IOneSwapBlackList {\r\n    event OwnerChanged(address);\r\n    event AddedBlackLists(address[]);\r\n    event RemovedBlackLists(address[]);\r\n\r\n    function owner()external view returns (address);\r\n    function newOwner()external view returns (address);\r\n    function isBlackListed(address)external view returns (bool);\r\n\r\n    function changeOwner(address ownerToSet) external;\r\n    function updateOwner() external;\r\n    function addBlackLists(address[] calldata  accounts)external;\r\n    function removeBlackLists(address[] calldata  accounts)external;\r\n}\r\n\r\ninterface IOneSwapToken is IERC20, IOneSwapBlackList{\r\n    function burn(uint256 amount) external;\r\n    function burnFrom(address account, uint256 amount) external;\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    function multiTransfer(uint256[] calldata mixedAddrVal) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IOneSwapFactory.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IOneSwapFactory {\r\n    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\r\n\r\n    function createPair(address stock, address money, bool isOnlySwap) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setFeeBPS(uint32 bps) external;\r\n    function setPairLogic(address implLogic) external;\r\n\r\n    function allPairsLength() external view returns (uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function feeBPS() external view returns (uint32);\r\n    function pairLogic() external returns (address);\r\n    function getTokensFromPair(address pair) external view returns (address stock, address money);\r\n    function tokensToPair(address stock, address money, bool isOnlySwap) external view returns (address pair);\r\n}\r\n\r\n// File: contracts/interfaces/IOneSwapRouter.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IOneSwapRouter {\r\n    event AddLiquidity(uint stockAmount, uint moneyAmount, uint liquidity);\r\n    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    // liquidity\r\n    function addLiquidity(\r\n        address stock,\r\n        address money,\r\n        bool isOnlySwap,\r\n        uint amountStockDesired,\r\n        uint amountMoneyDesired,\r\n        uint amountStockMin,\r\n        uint amountMoneyMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountStock, uint amountMoney, uint liquidity);\r\n    function removeLiquidity(\r\n        address pair,\r\n        uint liquidity,\r\n        uint amountStockMin,\r\n        uint amountMoneyMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountStock, uint amountMoney);\r\n\r\n    // swap token\r\n    function swapToken(\r\n        address token,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    // limit order\r\n    function limitOrder(\r\n        bool isBuy,\r\n        address pair,\r\n        uint prevKey,\r\n        uint price,\r\n        uint32 id,\r\n        uint stockAmount,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\n// File: contracts/interfaces/IOneSwapBuyback.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IOneSwapBuyback {\r\n    event BurnOnes(uint256 burntAmt);\r\n\r\n    function ones() external pure returns (address);\r\n    function router() external pure returns (address);\r\n    function factory() external pure returns (address);\r\n\r\n    function addMainToken(address token) external;\r\n    function removeMainToken(address token) external;\r\n    function isMainToken(address token) external view returns (bool);\r\n    function mainTokens() external view returns (address[] memory list);\r\n\r\n    function removeLiquidity(address[] calldata pairs) external;\r\n    function swapForMainToken(address[] calldata pairs) external;\r\n    function swapForOnesAndBurn(address[] calldata pairs) external;\r\n}\r\n\r\n// File: contracts/OneSwapBuyback.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\ncontract OneSwapBuyback is IOneSwapBuyback {\r\n\r\n    uint256 private constant _MAX_UINT256 = uint256(-1); \r\n    address private constant _ETH = address(0);\r\n\r\n    address public immutable override ones;\r\n    address public immutable override router;\r\n    address public immutable override factory;\r\n\r\n    mapping (address => bool) private _mainTokens;\r\n    address[] private _mainTokenArr;\r\n\r\n    constructor(address _ones, address _router, address _factory) public {\r\n        ones = _ones;\r\n        router = _router;\r\n        factory = _factory;\r\n\r\n        // add ETH & ONES to main token list\r\n        _mainTokens[_ETH] = true;\r\n        _mainTokenArr.push(_ETH);\r\n        _mainTokens[_ones] = true;\r\n        _mainTokenArr.push(_ones);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    // add token into main token list\r\n    function addMainToken(address token) external override {\r\n        require(msg.sender == IOneSwapToken(ones).owner(), \"OneSwapBuyback: NOT_ONES_OWNER\");\r\n        if (!_mainTokens[token]) {\r\n            _mainTokens[token] = true;\r\n            _mainTokenArr.push(token);\r\n        }\r\n    }\r\n    // remove token from main token list\r\n    function removeMainToken(address token) external override {\r\n        require(msg.sender == IOneSwapToken(ones).owner(), \"OneSwapBuyback: NOT_ONES_OWNER\");\r\n        require(token != _ETH, \"OneSwapBuyback: REMOVE_ETH_FROM_MAIN\");\r\n        require(token != ones, \"OneSwapBuyback: REMOVE_ONES_FROM_MAIN\");\r\n        if (_mainTokens[token]) {\r\n            _mainTokens[token] = false;\r\n            uint256 lastIdx = _mainTokenArr.length - 1;\r\n            for (uint256 i = 2; i < lastIdx; i++) { // skip ETH & ONES\r\n                if (_mainTokenArr[i] == token) {\r\n                    _mainTokenArr[i] = _mainTokenArr[lastIdx];\r\n                    break;\r\n                }\r\n            }\r\n            _mainTokenArr.pop();\r\n        }\r\n    }\r\n    // check if token is in main token list\r\n    function isMainToken(address token) external view override returns (bool) {\r\n        return _mainTokens[token];\r\n    }\r\n    // query main token list\r\n    function mainTokens() external view override returns (address[] memory list) {\r\n        list = _mainTokenArr;\r\n    }\r\n\r\n    // remove Buyback's liquidity from all pairs\r\n    // swap got minor tokens for main tokens if possible\r\n    function removeLiquidity(address[] calldata pairs) external override {\r\n        for (uint256 i = 0; i < pairs.length; i++) {\r\n            _removeLiquidity(pairs[i]);\r\n        }\r\n    }\r\n    function _removeLiquidity(address pair) private {\r\n        (address a, address b) = IOneSwapFactory(factory).getTokensFromPair(pair);\r\n        require(a != address(0) || b != address(0), \"OneSwapBuyback: INVALID_PAIR\");\r\n\r\n        uint256 amt = IERC20(pair).balanceOf(address(this));\r\n        // require(amt > 0, \"OneSwapBuyback: NO_LIQUIDITY\");\r\n        if (amt == 0) { return; }\r\n\r\n        IERC20(pair).approve(router, 0);\r\n        IERC20(pair).approve(router, amt);\r\n        IOneSwapRouter(router).removeLiquidity(\r\n            pair, amt, 0, 0, address(this), _MAX_UINT256);\r\n\r\n        // minor -> main\r\n        bool aIsMain = _mainTokens[a];\r\n        bool bIsMain = _mainTokens[b];\r\n        if ((aIsMain && !bIsMain) || (!aIsMain && bIsMain)) {\r\n            _swapForMainToken(pair);\r\n        }\r\n    }\r\n\r\n    // swap minor tokens for main tokens\r\n    function swapForMainToken(address[] calldata pairs) external override {\r\n        for (uint256 i = 0; i < pairs.length; i++) {\r\n            _swapForMainToken(pairs[i]);\r\n        }\r\n    }\r\n    function _swapForMainToken(address pair) private {\r\n        (address a, address b) = IOneSwapFactory(factory).getTokensFromPair(pair);\r\n        require(a != address(0) || b != address(0), \"OneSwapBuyback: INVALID_PAIR\");\r\n\r\n        address mainToken;\r\n        address minorToken;\r\n        if (_mainTokens[a]) {\r\n            require(!_mainTokens[b], \"OneSwapBuyback: SWAP_TWO_MAIN_TOKENS\");\r\n            (mainToken, minorToken) = (a, b);\r\n        } else {\r\n            require(_mainTokens[b], \"OneSwapBuyback: SWAP_TWO_MINOR_TOKENS\");\r\n            (mainToken, minorToken) = (b, a);\r\n        }\r\n\r\n        uint256 minorTokenAmt = IERC20(minorToken).balanceOf(address(this));\r\n        // require(minorTokenAmt > 0, \"OneSwapBuyback: NO_MINOR_TOKENS\");\r\n        if (minorTokenAmt == 0) { return; }\r\n\r\n        address[] memory path = new address[](1);\r\n        path[0] = pair;\r\n\r\n        // minor -> main\r\n        IERC20(minorToken).approve(router, 0);\r\n        IERC20(minorToken).approve(router, minorTokenAmt);\r\n        IOneSwapRouter(router).swapToken(\r\n            minorToken, minorTokenAmt, 0, path, address(this), _MAX_UINT256);\r\n    }\r\n\r\n    // swap main tokens for ones, then burn all ones\r\n    function swapForOnesAndBurn(address[] calldata pairs) external override {\r\n        for (uint256 i = 0; i < pairs.length; i++) {\r\n            _swapForOnes(pairs[i]);\r\n        }\r\n\r\n        // burn all ones\r\n        uint256 allOnes = IERC20(ones).balanceOf(address(this));\r\n        if (allOnes == 0) { return; }\r\n        IOneSwapToken(ones).burn(allOnes);\r\n        emit BurnOnes(allOnes);\r\n    }\r\n    function _swapForOnes(address pair) private {\r\n        (address a, address b) = IOneSwapFactory(factory).getTokensFromPair(pair);\r\n        require(a != address(0) || b != address(0), \"OneSwapBuyback: INVALID_PAIR\");\r\n        require(a == ones || b == ones, \"OneSwapBuyback: ONES_NOT_IN_PAIR\");\r\n\r\n        address token = (a == ones) ? b : a;\r\n        require(_mainTokens[token], \"OneSwapBuyback: MAIN_TOKEN_NOT_IN_PAIR\");\r\n\r\n        address[] memory path = new address[](1);\r\n        path[0] = pair;\r\n\r\n        if (token == _ETH) { // eth -> ones\r\n            uint256 ethAmt = address(this).balance;\r\n            // require(ethAmt > 0, \"OneSwapBuyback: NO_ETH\");\r\n            if (ethAmt == 0) { return; }\r\n\r\n            IOneSwapRouter(router).swapToken{value: ethAmt}(\r\n                _ETH, ethAmt, 0, path, address(this), _MAX_UINT256);\r\n        } else { // main token -> ones\r\n            uint256 tokenAmt = IERC20(token).balanceOf(address(this));\r\n            // require(tokenAmt > 0, \"OneSwapBuyback: NO_MAIN_TOKENS\");\r\n            if (tokenAmt == 0) { return; }\r\n\r\n            IERC20(token).approve(router, 0);\r\n            IERC20(token).approve(router, tokenAmt);\r\n            IOneSwapRouter(router).swapToken(\r\n                token, tokenAmt, 0, path, address(this), _MAX_UINT256);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ones\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burntAmt\",\"type\":\"uint256\"}],\"name\":\"BurnOnes\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addMainToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isMainToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ones\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeMainToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"swapForMainToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"swapForOnesAndBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"OneSwapBuyback","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000b342c51d1592c41068d5d4b4da4a68c0a04d5a4000000000000000000000000eee21cf8762a87817868039f119e57a7fec650740000000000000000000000005ed3c9089ed0355bc77cf439dc2ed28c4054c8c4","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c5317415049fa7cc2e349cbca7460057c1b361d4feea09fb68a0ea121fa820b7"}]}