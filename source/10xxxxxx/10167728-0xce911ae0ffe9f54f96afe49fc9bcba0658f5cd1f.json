{"status":"1","message":"OK","result":[{"SourceCode":"/**\nMatic network contracts\n*/\n\npragma solidity ^0.5.2;\n\n\ninterface IGovernance {\n    function update(address target, bytes calldata data) external;\n}\n\ncontract Governable {\n    IGovernance public governance;\n\n    constructor(address _governance) public {\n        governance = IGovernance(_governance);\n    }\n\n    modifier onlyGovernance() {\n        require(\n            msg.sender == address(governance),\n            \"Only governance contract is authorized\"\n        );\n        _;\n    }\n}\n\ncontract IWithdrawManager {\n    function createExitQueue(address token) external;\n\n    function verifyInclusion(\n        bytes calldata data,\n        uint8 offset,\n        bool verifyTxInclusion\n    ) external view returns (uint256 age);\n\n    function addExitToQueue(\n        address exitor,\n        address childToken,\n        address rootToken,\n        uint256 exitAmountOrTokenId,\n        bytes32 txHash,\n        bool isRegularExit,\n        uint256 priority\n    ) external;\n\n    function addInput(\n        uint256 exitId,\n        uint256 age,\n        address utxoOwner,\n        address token\n    ) external;\n\n    function challengeExit(\n        uint256 exitId,\n        uint256 inputId,\n        bytes calldata challengeData,\n        address adjudicatorPredicate\n    ) external;\n}\n\ncontract Registry is Governable {\n    // @todo hardcode constants\n    bytes32 private constant WETH_TOKEN = keccak256(\"wethToken\");\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\"depositManager\");\n    bytes32 private constant STAKE_MANAGER = keccak256(\"stakeManager\");\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\"validatorShare\");\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\"withdrawManager\");\n    bytes32 private constant CHILD_CHAIN = keccak256(\"childChain\");\n    bytes32 private constant STATE_SENDER = keccak256(\"stateSender\");\n    bytes32 private constant SLASHING_MANAGER = keccak256(\"slashingManager\");\n\n    address public erc20Predicate;\n    address public erc721Predicate;\n\n    mapping(bytes32 => address) public contractMap;\n    mapping(address => address) public rootToChildToken;\n    mapping(address => address) public childToRootToken;\n    mapping(address => bool) public proofValidatorContracts;\n    mapping(address => bool) public isERC721;\n\n    enum Type {Invalid, ERC20, ERC721, Custom}\n    struct Predicate {\n        Type _type;\n    }\n    mapping(address => Predicate) public predicates;\n\n    event TokenMapped(address indexed rootToken, address indexed childToken);\n    event ProofValidatorAdded(address indexed validator, address indexed from);\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\n    event PredicateAdded(address indexed predicate, address indexed from);\n    event PredicateRemoved(address indexed predicate, address indexed from);\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\n\n    constructor(address _governance) public Governable(_governance) {}\n\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\n        contractMap[_key] = _address;\n    }\n\n    /**\n     * @dev Map root token to child token\n     * @param _rootToken Token address on the root chain\n     * @param _childToken Token address on the child chain\n     * @param _isERC721 Is the token being mapped ERC721\n     */\n    function mapToken(\n        address _rootToken,\n        address _childToken,\n        bool _isERC721\n    ) external onlyGovernance {\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \"INVALID_TOKEN_ADDRESS\");\n        rootToChildToken[_rootToken] = _childToken;\n        childToRootToken[_childToken] = _rootToken;\n        isERC721[_rootToken] = _isERC721;\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\n        emit TokenMapped(_rootToken, _childToken);\n    }\n\n    function addErc20Predicate(address predicate) public onlyGovernance {\n        require(predicate != address(0x0), \"Can not add null address as predicate\");\n        erc20Predicate = predicate;\n        addPredicate(predicate, Type.ERC20);\n    }\n\n    function addErc721Predicate(address predicate) public onlyGovernance {\n        erc721Predicate = predicate;\n        addPredicate(predicate, Type.ERC721);\n    }\n\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\n        require(predicates[predicate]._type == Type.Invalid, \"Predicate already added\");\n        predicates[predicate]._type = _type;\n        emit PredicateAdded(predicate, msg.sender);\n    }\n\n    function removePredicate(address predicate) public onlyGovernance {\n        require(predicates[predicate]._type != Type.Invalid, \"Predicate does not exist\");\n        delete predicates[predicate];\n        emit PredicateRemoved(predicate, msg.sender);\n    }\n\n    function getValidatorShareAddress() public view returns (address) {\n        return contractMap[VALIDATOR_SHARE];\n    }\n\n    function getWethTokenAddress() public view returns (address) {\n        return contractMap[WETH_TOKEN];\n    }\n\n    function getDepositManagerAddress() public view returns (address) {\n        return contractMap[DEPOSIT_MANAGER];\n    }\n\n    function getStakeManagerAddress() public view returns (address) {\n        return contractMap[STAKE_MANAGER];\n    }\n\n    function getSlashingManagerAddress() public view returns (address) {\n        return contractMap[SLASHING_MANAGER];\n    }\n\n    function getWithdrawManagerAddress() public view returns (address) {\n        return contractMap[WITHDRAW_MANAGER];\n    }\n\n    function getChildChainAndStateSender() public view returns (address, address) {\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\n    }\n\n    function isTokenMapped(address _token) public view returns (bool) {\n        return rootToChildToken[_token] != address(0x0);\n    }\n\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\n        require(isTokenMapped(_token), \"TOKEN_NOT_MAPPED\");\n        return isERC721[_token];\n    }\n\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\n        if (isTokenMappedAndIsErc721(_token)) {\n            return erc721Predicate;\n        }\n        return erc20Predicate;\n    }\n\n    function isChildTokenErc721(address childToken) public view returns (bool) {\n        address rootToken = childToRootToken[childToken];\n        require(rootToken != address(0x0), \"Child token is not mapped\");\n        return isERC721[rootToken];\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n        return tempBytes;\n    }\n\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length));\n        bytes memory tempBytes;\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(\n                        add(tempBytes, lengthmod),\n                        mul(0x20, iszero(lengthmod))\n                    )\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(\n                            add(\n                                add(_bytes, lengthmod),\n                                mul(0x20, iszero(lengthmod))\n                            ),\n                            _start\n                        )\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    // Pad a bytes array to 32 bytes\n    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {\n        // may underflow if bytes.length < 32. Hence using SafeMath.sub\n        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));\n        return concat(newBytes, _bytes);\n    }\n\n    function toBytes32(bytes memory b) internal pure returns (bytes32) {\n        require(b.length >= 32, \"Bytes array should atleast be 32 bytes\");\n        bytes32 out;\n        for (uint256 i = 0; i < 32; i++) {\n            out |= bytes32(b[i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {\n        assembly {\n            result := mload(add(b, 32))\n        }\n    }\n\n    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {\n        bytes memory b = new bytes(32);\n        for (uint256 i = 0; i < 32; i++) {\n            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));\n        }\n        return b;\n    }\n\n    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {\n        _ret = new bytes(32);\n        assembly {\n            mstore(add(_ret, 32), _num)\n        }\n    }\n\n    function toUint(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(_bytes.length >= (_start + 32));\n        uint256 tempUint;\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n        return tempUint;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (address)\n    {\n        require(_bytes.length >= (_start + 20));\n        address tempAddress;\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n}\n\nlibrary ECVerify {\n    function ecrecovery(bytes32 hash, bytes memory sig)\n        public\n        pure\n        returns (address)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (sig.length != 65) {\n            return address(0x0);\n        }\n\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := and(mload(add(sig, 65)), 255)\n        }\n\n        // https://github.com/ethereum/go-ethereum/issues/2053\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0x0);\n        }\n\n        // get address out of hash and signature\n        address result = ecrecover(hash, v, r, s);\n\n        // ecrecover returns zero on error\n        require(result != address(0x0));\n\n        return result;\n    }\n\n    function ecrecovery(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        public\n        pure\n        returns (address)\n    {\n        // get address out of hash and signature\n        address result = ecrecover(hash, v, r, s);\n\n        // ecrecover returns zero on error\n        require(result != address(0x0), \"signature verification failed\");\n\n        return result;\n    }\n\n    function ecverify(bytes32 hash, bytes memory sig, address signer)\n        public\n        pure\n        returns (bool)\n    {\n        return signer == ecrecovery(hash, sig);\n    }\n}\n\n// dummy interface to avoid cyclic dependency\ncontract IStakeManager {\n    enum Status {Inactive, Active, Locked, Unstaked}\n\n    struct Validator {\n        uint256 amount;\n        uint256 reward;\n        uint256 activationEpoch;\n        uint256 deactivationEpoch;\n        uint256 jailTime;\n        address signer;\n        address contractAddress;\n        Status status;\n    }\n\n    mapping(uint256 => Validator) public validators;\n    bytes32 public accountStateRoot;\n    uint256 public activeAmount; // delegation amount from validator contract\n    uint256 public validatorRewards;\n\n    function currentValidatorSetTotalStake() public view returns (uint256);\n\n    // signer to Validator mapping\n    function signerToValidator(address validatorAddress)\n        public\n        view\n        returns (uint256);\n\n    function isValidator(uint256 validatorId) public view returns (bool);\n}\n\ncontract StakingInfo {\n    using SafeMath for uint256;\n    mapping(uint256 => uint256) public validatorNonce;\n\n    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.\n    /// @param signer validator address.\n    /// @param validatorId unique integer to identify a validator.\n    /// @param nonce to synchronize the events in heimdal.\n    /// @param activationEpoch validator's first epoch as proposer.\n    /// @param amount staking amount.\n    /// @param total total staking amount.\n    /// @param signerPubkey public key of the validator\n    event Staked(\n        address indexed signer,\n        uint256 indexed validatorId,\n        uint256 nonce,\n        uint256 indexed activationEpoch,\n        uint256 amount,\n        uint256 total,\n        bytes signerPubkey\n    );\n\n    /// @dev Emitted when validator unstakes in 'unstakeClaim()'\n    /// @param user address of the validator.\n    /// @param validatorId unique integer to identify a validator.\n    /// @param amount staking amount.\n    /// @param total total staking amount.\n    event Unstaked(\n        address indexed user,\n        uint256 indexed validatorId,\n        uint256 amount,\n        uint256 total\n    );\n\n    /// @dev Emitted when validator unstakes in '_unstake()'.\n    /// @param user address of the validator.\n    /// @param validatorId unique integer to identify a validator.\n    /// @param nonce to synchronize the events in heimdal.\n    /// @param deactivationEpoch last epoch for validator.\n    /// @param amount staking amount.\n    event UnstakeInit(\n        address indexed user,\n        uint256 indexed validatorId,\n        uint256 nonce,\n        uint256 deactivationEpoch,\n        uint256 indexed amount\n    );\n\n    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.\n    /// @param validatorId unique integer to identify a validator.\n    /// @param nonce to synchronize the events in heimdal.\n    /// @param oldSigner old address of the validator.\n    /// @param newSigner new address of the validator.\n    /// @param signerPubkey public key of the validator.\n    event SignerChange(\n        uint256 indexed validatorId,\n        uint256 nonce,\n        address indexed oldSigner,\n        address indexed newSigner,\n        bytes signerPubkey\n    );\n    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);\n    event Jailed(\n        uint256 indexed validatorId,\n        uint256 indexed exitEpoch,\n        address indexed signer\n    );\n    event UnJailed(uint256 indexed validatorId, address indexed signer);\n    event Slashed(uint256 indexed nonce, uint256 indexed amount);\n    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);\n    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);\n    event ProposerBonusChange(\n        uint256 newProposerBonus,\n        uint256 oldProposerBonus\n    );\n\n    event RewardUpdate(uint256 newReward, uint256 oldReward);\n\n    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().\n    /// @param validatorId unique integer to identify a validator.\n    /// @param nonce to synchronize the events in heimdal.\n    /// @param newAmount the updated stake amount.\n    event StakeUpdate(\n        uint256 indexed validatorId,\n        uint256 indexed nonce,\n        uint256 indexed newAmount\n    );\n    event ClaimRewards(\n        uint256 indexed validatorId,\n        uint256 indexed amount,\n        uint256 indexed totalAmount\n    );\n    event StartAuction(\n        uint256 indexed validatorId,\n        uint256 indexed amount,\n        uint256 indexed auctionAmount\n    );\n    event ConfirmAuction(\n        uint256 indexed newValidatorId,\n        uint256 indexed oldValidatorId,\n        uint256 indexed amount\n    );\n    event TopUpFee(address indexed user, uint256 indexed fee);\n    event ClaimFee(address indexed user, uint256 indexed fee);\n    // Delegator events\n    event ShareMinted(\n        uint256 indexed validatorId,\n        address indexed user,\n        uint256 indexed amount,\n        uint256 tokens\n    );\n    event ShareBurned(\n        uint256 indexed validatorId,\n        address indexed user,\n        uint256 indexed amount,\n        uint256 tokens\n    );\n    event DelegatorClaimedRewards(\n        uint256 indexed validatorId,\n        address indexed user,\n        uint256 indexed rewards,\n        uint256 tokens\n    );\n    event DelegatorRestaked(\n        uint256 indexed validatorId,\n        address indexed user,\n        uint256 indexed totalStaked\n    );\n    event DelegatorUnstaked(\n        uint256 indexed validatorId,\n        address indexed user,\n        uint256 amount\n    );\n    event UpdateCommissionRate(\n        uint256 indexed validatorId,\n        uint256 indexed newCommissionRate,\n        uint256 indexed oldCommissionRate\n    );\n\n    Registry public registry;\n\n    modifier onlyValidatorContract(uint256 validatorId) {\n        address _contract;\n        (, , , , , , _contract, ) = IStakeManager(\n            registry.getStakeManagerAddress()\n        )\n            .validators(validatorId);\n        require(_contract == msg.sender,\n        \"Invalid sender, not validator\");\n        _;\n    }\n\n    modifier StakeManagerOrValidatorContract(uint256 validatorId) {\n        address _contract;\n        address _stakeManager = registry.getStakeManagerAddress();\n        (, , , , , , _contract, ) = IStakeManager(_stakeManager).validators(\n            validatorId\n        );\n        require(_contract == msg.sender || _stakeManager == msg.sender,\n        \"Invalid sender, not stake manager or validator contract\");\n        _;\n    }\n\n    modifier onlyStakeManager() {\n        require(registry.getStakeManagerAddress() == msg.sender,\n        \"Invalid sender, not stake manager\");\n        _;\n    }\n    modifier onlySlashingManager() {\n        require(registry.getSlashingManagerAddress() == msg.sender,\n        \"Invalid sender, not slashing manager\");\n        _;\n    }\n\n    constructor(address _registry) public {\n        registry = Registry(_registry);\n    }\n\n    function logStaked(\n        address signer,\n        bytes memory signerPubkey,\n        uint256 validatorId,\n        uint256 activationEpoch,\n        uint256 amount,\n        uint256 total\n    ) public onlyStakeManager {\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n        emit Staked(\n            signer,\n            validatorId,\n            validatorNonce[validatorId],\n            activationEpoch,\n            amount,\n            total,\n            signerPubkey\n        );\n    }\n\n    function logUnstaked(\n        address user,\n        uint256 validatorId,\n        uint256 amount,\n        uint256 total\n    ) public onlyStakeManager {\n        emit Unstaked(user, validatorId, amount, total);\n    }\n\n    function logUnstakeInit(\n        address user,\n        uint256 validatorId,\n        uint256 deactivationEpoch,\n        uint256 amount\n    ) public onlyStakeManager {\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n        emit UnstakeInit(\n            user,\n            validatorId,\n            validatorNonce[validatorId],\n            deactivationEpoch,\n            amount\n        );\n    }\n\n    function logSignerChange(\n        uint256 validatorId,\n        address oldSigner,\n        address newSigner,\n        bytes memory signerPubkey\n    ) public onlyStakeManager {\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n        emit SignerChange(\n            validatorId,\n            validatorNonce[validatorId],\n            oldSigner,\n            newSigner,\n            signerPubkey\n        );\n    }\n\n    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)\n        public\n        onlyStakeManager\n    {\n        emit Restaked(validatorId, amount, total);\n    }\n\n    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)\n        public\n        onlyStakeManager\n    {\n        emit Jailed(validatorId, exitEpoch, signer);\n    }\n\n    function logUnjailed(uint256 validatorId, address signer)\n        public\n        onlyStakeManager\n    {\n        emit UnJailed(validatorId, signer);\n    }\n\n    function logSlashed(uint256 nonce, uint256 amount)\n        public\n        onlySlashingManager\n    {\n        emit Slashed(nonce, amount);\n    }\n\n    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)\n        public\n        onlyStakeManager\n    {\n        emit ThresholdChange(newThreshold, oldThreshold);\n    }\n\n    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)\n        public\n        onlyStakeManager\n    {\n        emit DynastyValueChange(newDynasty, oldDynasty);\n    }\n\n    function logProposerBonusChange(\n        uint256 newProposerBonus,\n        uint256 oldProposerBonus\n    ) public onlyStakeManager {\n        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);\n    }\n\n    function logRewardUpdate(uint256 newReward, uint256 oldReward)\n        public\n        onlyStakeManager\n    {\n        emit RewardUpdate(newReward, oldReward);\n    }\n\n    function logStakeUpdate(uint256 validatorId)\n        public\n        StakeManagerOrValidatorContract(validatorId)\n    {\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n        emit StakeUpdate(\n            validatorId,\n            validatorNonce[validatorId],\n            totalValidatorStake(validatorId)\n        );\n    }\n\n    function logClaimRewards(\n        uint256 validatorId,\n        uint256 amount,\n        uint256 totalAmount\n    ) public onlyStakeManager {\n        emit ClaimRewards(validatorId, amount, totalAmount);\n    }\n\n    function logStartAuction(\n        uint256 validatorId,\n        uint256 amount,\n        uint256 auctionAmount\n    ) public onlyStakeManager {\n        emit StartAuction(validatorId, amount, auctionAmount);\n    }\n\n    function logConfirmAuction(\n        uint256 newValidatorId,\n        uint256 oldValidatorId,\n        uint256 amount\n    ) public onlyStakeManager {\n        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);\n    }\n\n    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {\n        emit TopUpFee(user, fee);\n    }\n\n    function logClaimFee(address user, uint256 fee) public onlyStakeManager {\n        emit ClaimFee(user, fee);\n    }\n\n    function getStakerDetails(uint256 validatorId)\n        public\n        view\n        returns (\n            uint256 amount,\n            uint256 reward,\n            uint256 activationEpoch,\n            uint256 deactivationEpoch,\n            address signer,\n            uint256 _status\n        )\n    {\n        IStakeManager stakeManager = IStakeManager(\n            registry.getStakeManagerAddress()\n        );\n        address _contract;\n        IStakeManager.Status status;\n        (\n            amount,\n            reward,\n            activationEpoch,\n            deactivationEpoch,\n            ,\n            signer,\n            _contract,\n            status\n        ) = stakeManager.validators(validatorId);\n        reward += IStakeManager(_contract).validatorRewards();\n        _status = uint256(status);\n    }\n\n    function totalValidatorStake(uint256 validatorId)\n        public\n        view\n        returns (uint256 validatorStake)\n    {\n        address contractAddress;\n        (validatorStake, , , , , , contractAddress, ) = IStakeManager(\n            registry.getStakeManagerAddress()\n        )\n            .validators(validatorId);\n        if (contractAddress != address(0x0)) {\n            validatorStake += IStakeManager(contractAddress).activeAmount();\n        }\n    }\n\n    function getAccountStateRoot()\n        public\n        view\n        returns (bytes32 accountStateRoot)\n    {\n        accountStateRoot = IStakeManager(registry.getStakeManagerAddress())\n            .accountStateRoot();\n    }\n\n    function getValidatorContractAddress(uint256 validatorId)\n        public\n        view\n        returns (address ValidatorContract)\n    {\n        (, , , , , , ValidatorContract, ) = IStakeManager(\n            registry.getStakeManagerAddress()\n        )\n            .validators(validatorId);\n    }\n\n    // validator Share contract logging func\n    function logShareMinted(\n        uint256 validatorId,\n        address user,\n        uint256 amount,\n        uint256 tokens\n    ) public onlyValidatorContract(validatorId) {\n        emit ShareMinted(validatorId, user, amount, tokens);\n    }\n\n    function logShareBurned(\n        uint256 validatorId,\n        address user,\n        uint256 amount,\n        uint256 tokens\n    ) public onlyValidatorContract(validatorId) {\n        emit ShareBurned(validatorId, user, amount, tokens);\n    }\n\n    function logDelegatorClaimRewards(\n        uint256 validatorId,\n        address user,\n        uint256 rewards,\n        uint256 tokens\n    ) public onlyValidatorContract(validatorId) {\n        emit DelegatorClaimedRewards(validatorId, user, rewards, tokens);\n    }\n\n    function logDelegatorRestaked(\n        uint256 validatorId,\n        address user,\n        uint256 totalStaked\n    ) public onlyValidatorContract(validatorId) {\n        emit DelegatorRestaked(validatorId, user, totalStaked);\n    }\n\n    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)\n        public\n        onlyValidatorContract(validatorId)\n    {\n        emit DelegatorUnstaked(validatorId, user, amount);\n    }\n\n    function logUpdateCommissionRate(\n        uint256 validatorId,\n        uint256 newCommissionRate,\n        uint256 oldCommissionRate\n    ) public onlyValidatorContract(validatorId) {\n        emit UpdateCommissionRate(\n            validatorId,\n            newCommissionRate,\n            oldCommissionRate\n        );\n    }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionAmount\",\"type\":\"uint256\"}],\"name\":\"logStartAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"logClaimFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"getValidatorContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ValidatorContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signerPubkey\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activationEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"logStaked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccountStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"accountStateRoot\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"logStakeUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"logRestaked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deactivationEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"logUnstakeInit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"logDelegatorUnstaked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"logDelegatorClaimRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"getStakerDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activationEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deactivationEpoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_status\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract Registry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"}],\"name\":\"logDelegatorRestaked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exitEpoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"logJailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDynasty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldDynasty\",\"type\":\"uint256\"}],\"name\":\"logDynastyValueChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newProposerBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldProposerBonus\",\"type\":\"uint256\"}],\"name\":\"logProposerBonusChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"logTopUpFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"logUnstaked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"logClaimRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldReward\",\"type\":\"uint256\"}],\"name\":\"logRewardUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oldSigner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signerPubkey\",\"type\":\"bytes\"}],\"name\":\"logSignerChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"logShareMinted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCommissionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldCommissionRate\",\"type\":\"uint256\"}],\"name\":\"logUpdateCommissionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"totalValidatorStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorStake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValidatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldValidatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"logConfirmAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validatorNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"logShareBurned\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldThreshold\",\"type\":\"uint256\"}],\"name\":\"logThresholdChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"logUnjailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"logSlashed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"activationEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signerPubkey\",\"type\":\"bytes\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deactivationEpoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldSigner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signerPubkey\",\"type\":\"bytes\"}],\"name\":\"SignerChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"Restaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exitEpoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"Jailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"UnJailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Slashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldThreshold\",\"type\":\"uint256\"}],\"name\":\"ThresholdChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDynasty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDynasty\",\"type\":\"uint256\"}],\"name\":\"DynastyValueChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProposerBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldProposerBonus\",\"type\":\"uint256\"}],\"name\":\"ProposerBonusChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldReward\",\"type\":\"uint256\"}],\"name\":\"RewardUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"StakeUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionAmount\",\"type\":\"uint256\"}],\"name\":\"StartAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValidatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValidatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConfirmAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"TopUpFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ClaimFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ShareMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ShareBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"DelegatorClaimedRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"}],\"name\":\"DelegatorRestaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelegatorUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newCommissionRate\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldCommissionRate\",\"type\":\"uint256\"}],\"name\":\"UpdateCommissionRate\",\"type\":\"event\"}]","ContractName":"StakingInfo","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000033a02e6cc863d393d6bf231b697b82f6e499ca71","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}