{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * SPDX-License-Identifier: MIT\r\n *\r\n * Copyright (c) 2018-2020 CENTRE SECZ\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.6.12;\r\n\r\ncontract FiatTokenUtil {\r\n    // (address,address,uint256,uint256,uint256,bytes32) = 20*2 + 32*4 = 168\r\n    uint256 private constant _TRANSFER_PARAM_SIZE = 168;\r\n    // (uint8,bytes32,bytes32) = 1 + 32*2 = 65\r\n    uint256 private constant _SIGNATURE_SIZE = 65;\r\n    // keccak256(\"transferWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)\")[0:4]\r\n    bytes4 private constant _TRANSFER_WITH_AUTHORIZATION_SELECTOR = 0xe3ee160e;\r\n\r\n    address private _fiatToken;\r\n\r\n    event TransferFailed(address indexed authorizer, bytes32 indexed nonce);\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @dev If FiatTokenProxy is used to hold state and delegate calls, the\r\n     * proxy's address should be provided, not the implementation address\r\n     * @param fiatToken Address of the FiatToken contract\r\n     */\r\n    constructor(address fiatToken) public {\r\n        _fiatToken = fiatToken;\r\n    }\r\n\r\n    /**\r\n     * @notice Execute multiple authorized ERC20 Transfers\r\n     * @dev The length of params must be multiples of 168, each representing\r\n     * encode-packed data containing from[20] + to[20] + value[32] +\r\n     * validAfter[32] + validBefore[32] + nonce[32], and the length of\r\n     * signatures must be multiples of 65, each representing encode-packed data\r\n     * containing v[1] + r[32] + s[32].\r\n     * @param params      Concatenated, encode-packed parameters\r\n     * @param signatures  Concatenated, encode-packed signatures\r\n     * @param atomic      If true, revert if any of the transfers fail\r\n     * @return            True if every transfer was successful\r\n     */\r\n    function transferWithMultipleAuthorizations(\r\n        bytes calldata params,\r\n        bytes calldata signatures,\r\n        bool atomic\r\n    ) external returns (bool) {\r\n        uint256 num = params.length / _TRANSFER_PARAM_SIZE;\r\n        require(num > 0, \"FiatTokenUtil: no transfer provided\");\r\n        require(\r\n            num * _TRANSFER_PARAM_SIZE == params.length,\r\n            \"FiatTokenUtil: length of params is invalid\"\r\n        );\r\n        require(\r\n            signatures.length / _SIGNATURE_SIZE == num &&\r\n                num * _SIGNATURE_SIZE == signatures.length,\r\n            \"FiatTokenUtil: length of signatures is invalid\"\r\n        );\r\n\r\n        uint256 numSuccessful = 0;\r\n\r\n        for (uint256 i = 0; i < num; i++) {\r\n            uint256 paramsOffset = i * _TRANSFER_PARAM_SIZE;\r\n            uint256 sigOffset = i * _SIGNATURE_SIZE;\r\n\r\n            // extract from and to\r\n            bytes memory fromTo = _unpackAddresses(\r\n                abi.encodePacked(params[paramsOffset:paramsOffset + 40])\r\n            );\r\n            // extract value, validAfter, validBefore, and nonce\r\n            bytes memory other4 = abi.encodePacked(\r\n                params[paramsOffset + 40:paramsOffset + _TRANSFER_PARAM_SIZE]\r\n            );\r\n            // extract v\r\n            uint8 v = uint8(signatures[sigOffset]);\r\n            // extract r and s\r\n            bytes memory rs = abi.encodePacked(\r\n                signatures[sigOffset + 1:sigOffset + _SIGNATURE_SIZE]\r\n            );\r\n\r\n            // Call transferWithAuthorization with the extracted parameters\r\n            // solhint-disable-next-line avoid-low-level-calls\r\n            (bool success, bytes memory returnData) = _fiatToken.call(\r\n                abi.encodePacked(\r\n                    _TRANSFER_WITH_AUTHORIZATION_SELECTOR,\r\n                    fromTo,\r\n                    other4,\r\n                    abi.encode(v),\r\n                    rs\r\n                )\r\n            );\r\n\r\n            // Revert if atomic is true, and the call was not successful\r\n            if (atomic && !success) {\r\n                _revertWithReasonFromReturnData(returnData);\r\n            }\r\n\r\n            // Increment the number of successful transfers\r\n            if (success) {\r\n                numSuccessful++;\r\n            } else {\r\n                // extract from\r\n                (address from, ) = abi.decode(fromTo, (address, address));\r\n                // extract nonce\r\n                (, , , bytes32 nonce) = abi.decode(\r\n                    other4,\r\n                    (uint256, uint256, uint256, bytes32)\r\n                );\r\n                emit TransferFailed(from, nonce);\r\n            }\r\n        }\r\n\r\n        // Return true if all transfers were successful\r\n        return numSuccessful == num;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts encodePacked pair of addresses (20bytes + 20 bytes) to\r\n     * regular ABI-encoded pair of addresses (32bytes + 32bytes)\r\n     * @param packed Packed data (40 bytes)\r\n     * @return Unpacked data (64 bytes)\r\n     */\r\n    function _unpackAddresses(bytes memory packed)\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        address addr1;\r\n        address addr2;\r\n        assembly {\r\n            addr1 := mload(add(packed, 20))\r\n            addr2 := mload(add(packed, 40))\r\n        }\r\n        return abi.encode(addr1, addr2);\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with reason string extracted from the return data\r\n     * @param returnData    Return data from a call\r\n     */\r\n    function _revertWithReasonFromReturnData(bytes memory returnData)\r\n        private\r\n        pure\r\n    {\r\n        // Return data will be at least 100 bytes if it contains the reason\r\n        // string: Error(string) selector[4] + string offset[32] + string\r\n        // length[32] + string data[32] = 100\r\n        if (returnData.length < 100) {\r\n            revert(\"FiatTokenUtil: call failed\");\r\n        }\r\n\r\n        // If the reason string exists, extract it, and bubble it up\r\n        string memory reason;\r\n        assembly {\r\n            // Skip over the bytes length[32] + Error(string) selector[4] +\r\n            // string offset[32] = 68 (0x44)\r\n            reason := add(returnData, 0x44)\r\n        }\r\n\r\n        revert(reason);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fiatToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"TransferFailed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"atomic\",\"type\":\"bool\"}],\"name\":\"transferWithMultipleAuthorizations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FiatTokenUtil","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"10000000","ConstructorArguments":"000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://337d862a6921acf7b1ff18a17fe496755c71c4041111ebf79c078caecdec36f4"}]}