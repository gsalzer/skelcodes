{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.26;\r\n\r\n/// @title uniquely identifies deployable (non-abstract) platform contract\r\n/// @notice cheap way of assigning implementations to knownInterfaces which represent system services\r\n///         unfortunatelly ERC165 does not include full public interface (ABI) and does not provide way to list implemented interfaces\r\n///         EIP820 still in the making\r\n/// @dev ids are generated as follows keccak256(\"neufund-platform:<contract name>\")\r\n///      ids roughly correspond to ABIs\r\ncontract IContractId {\r\n    /// @param id defined as above\r\n    /// @param version implementation version\r\n    function contractId() public pure returns (bytes32 id, uint256 version);\r\n}\r\n\r\n/// @title access to snapshots of a token\r\n/// @notice allows to implement complex token holder rights like revenue disbursal or voting\r\n/// @notice snapshots are series of values with assigned ids. ids increase strictly. particular id mechanism is not assumed\r\ncontract ITokenSnapshots {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice Total amount of tokens at a specific `snapshotId`.\r\n    /// @param snapshotId of snapshot at which totalSupply is queried\r\n    /// @return The total amount of tokens at `snapshotId`\r\n    /// @dev reverts on snapshotIds greater than currentSnapshotId()\r\n    /// @dev returns 0 for snapshotIds less than snapshotId of first value\r\n    function totalSupplyAt(uint256 snapshotId)\r\n        public\r\n        constant\r\n        returns(uint256);\r\n\r\n    /// @dev Queries the balance of `owner` at a specific `snapshotId`\r\n    /// @param owner The address from which the balance will be retrieved\r\n    /// @param snapshotId of snapshot at which the balance is queried\r\n    /// @return The balance at `snapshotId`\r\n    function balanceOfAt(address owner, uint256 snapshotId)\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n    /// @notice upper bound of series of snapshotIds for which there's a value in series\r\n    /// @return snapshotId\r\n    function currentSnapshotId()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n}\r\n\r\n// standard methods of VotingCenter contract that governs voting procedures on the whole platform\r\ncontract IVotingCenter is IContractId {\r\n\r\n    /// @dev Creates a proposal, uniquely identifiable by its assigned proposalId\r\n    /// @param proposalId unique identifier of the proposal, e.g. ipfs-hash of info\r\n    /// @param token a token where balances give voting power to holders\r\n    /// @param campaignDuration duration (s) in which proposal has to gather enough votes to be made public (see campaignQuorum)\r\n    /// @param campaignQuorumFraction fraction (10**18 = 1) of token holders who have to support a proposal in order for it to be trigger an event\r\n    /// @param votingPeriod total duration (s) in which the proposal can be voted on by tokenholders after it was created\r\n    /// @param votingLegalRep a legal representative for the vote, which may provide off-chain voting results\r\n    /// @param offchainVotePeriod duration (s) after voting is ended when voting legal rep may provide results\r\n    /// @param totalVotingPower combined voting power of on-chain (token total supply) and held off-chain (ie. shares) expressed in tokens\r\n    /// @param action initiator defined action code on which voting happens\r\n    /// @param actionPayload initiator defined action payload on which voting happens\r\n    function addProposal(\r\n        bytes32 proposalId,\r\n        ITokenSnapshots token,\r\n        uint32 campaignDuration,\r\n        uint256 campaignQuorumFraction,\r\n        uint32 votingPeriod,\r\n        address votingLegalRep,\r\n        uint32 offchainVotePeriod,\r\n        uint256 totalVotingPower,\r\n        uint256 action,\r\n        bytes actionPayload,\r\n        bool enableObserver\r\n    )\r\n        public;\r\n\r\n    /// @dev increase the voting power on a given proposal by the token balance of the sender\r\n    ///   throws if proposal does not exist or the vote on it has ended already. Votes are final,\r\n    ///   changing the vote is not allowed\r\n    /// @dev reverts if proposal does not exist\r\n    /// @param proposalId of the proposal to be voted on\r\n    /// @param voteInFavor if true, voting power goes for proposal, if false - against\r\n    function vote(bytes32 proposalId, bool voteInFavor)\r\n        public;\r\n\r\n    /// @notice add off-chain votes, inFavor + against may not cross the offchainVotingPower, but may be less\r\n    ///         to reflect abstaining from vote\r\n    /// @param inFavor voting power (expressed in tokens) being in favor of the proposal\r\n    /// @param against voting power (expressed in tokens) being against the proposal\r\n    /// @param documentUri official document with final voting results\r\n    function addOffchainVote(bytes32 proposalId, uint256 inFavor, uint256 against, string documentUri)\r\n        public;\r\n\r\n\r\n    /// @notice Returns the current tally of a proposal. Only Final proposal have immutable tally\r\n    /// @return the voting power on a finished proposal and the total voting power\r\n    /// @dev please again note that VotingCenter does not say if voting passed in favor or against. it just carries on\r\n    ///      the voting and it's up to initiator to say what is the outcome, see IProposalObserver\r\n    function tally(bytes32 proposalId)\r\n        public\r\n        constant\r\n        returns(\r\n            uint8 s,\r\n            uint256 inFavor,\r\n            uint256 against,\r\n            uint256 offchainInFavor,\r\n            uint256 offchainAgainst,\r\n            uint256 tokenVotingPower,\r\n            uint256 totalVotingPower,\r\n            uint256 campaignQuorumTokenAmount,\r\n            address initiator,\r\n            bool hasObserverInterface\r\n        );\r\n\r\n    /// @notice returns official document with off-chain vote result/statement\r\n    /// @dev meaningful only in final state\r\n    function offchainVoteDocumentUri(bytes32 proposalId)\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    /// @notice obtains proposal after internal state is updated due to time\r\n    /// @dev    this is the getter you should use\r\n    /// @dev reverts if proposal does not exist\r\n    function timedProposal(bytes32 proposalId)\r\n        public\r\n        constant\r\n        returns (\r\n            uint8 s,\r\n            address token,\r\n            uint256 snapshotId,\r\n            address initiator,\r\n            address votingLegalRep,\r\n            uint256 campaignQuorumTokenAmount,\r\n            uint256 offchainVotingPower,\r\n            uint256 action,\r\n            bytes actionPayload,\r\n            bool enableObserver,\r\n            uint32[5] deadlines\r\n        );\r\n\r\n    /// @notice obtains proposal state without time transitions\r\n    /// @dev    used mostly to detect propositions requiring timed transitions\r\n    /// @dev reverts if proposal does not exist\r\n    function proposal(bytes32 proposalId)\r\n        public\r\n        constant\r\n        returns (\r\n            uint8 s,\r\n            address token,\r\n            uint256 snapshotId,\r\n            address initiator,\r\n            address votingLegalRep,\r\n            uint256 campaignQuorumTokenAmount,\r\n            uint256 offchainVotingPower,\r\n            uint256 action,\r\n            bytes actionPayload,\r\n            bool enableObserver,\r\n            uint32[5] deadlines\r\n        );\r\n\r\n    /// @notice tells if voter cast a for/against vote or abstained\r\n    /// @dev reverts if proposal does not exist\r\n    /// @return see TriState in VotingProposal\r\n    function getVote(bytes32 proposalId, address voter)\r\n        public\r\n        constant\r\n        returns (uint8);\r\n\r\n    /// @notice tells if proposal with given id was opened\r\n    function hasProposal(bytes32 proposalId)\r\n        public\r\n        constant\r\n        returns (bool);\r\n\r\n    /// @notice returns voting power for given proposal / voter\r\n    /// @dev voters with zero voting power cannot participate in voting\r\n    function getVotingPower(bytes32 proposalId, address voter)\r\n        public\r\n        constant\r\n        returns (uint256);\r\n}\r\n\r\ncontract IVotingController is IContractId {\r\n    // token must be NEU or equity token\r\n    // if initiator is not equity token then proposals start in campaign mode\r\n    // if token is NEU then default values must apply\r\n    function onAddProposal(bytes32 proposalId, address initiator, address token)\r\n        public\r\n        constant\r\n        returns (bool);\r\n\r\n    /// @notice check wether the disbursal controller may be changed\r\n    function onChangeVotingController(address sender, IVotingController newController)\r\n        public\r\n        constant\r\n        returns (bool);\r\n}\r\n\r\nlibrary Math {\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    // absolute difference: |v1 - v2|\r\n    function absDiff(uint256 v1, uint256 v2)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return v1 > v2 ? v1 - v2 : v2 - v1;\r\n    }\r\n\r\n    // divide v by d, round up if remainder is 0.5 or more\r\n    function divRound(uint256 v, uint256 d)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return add(v, d/2) / d;\r\n    }\r\n\r\n    // computes decimal decimalFraction 'frac' of 'amount' with maximum precision (multiplication first)\r\n    // both amount and decimalFraction must have 18 decimals precision, frac 10**18 represents a whole (100% of) amount\r\n    // mind loss of precision as decimal fractions do not have finite binary expansion\r\n    // do not use instead of division\r\n    function decimalFraction(uint256 amount, uint256 frac)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // it's like 1 ether is 100% proportion\r\n        return proportion(amount, frac, 10**18);\r\n    }\r\n\r\n    // computes part/total of amount with maximum precision (multiplication first)\r\n    // part and total must have the same units\r\n    function proportion(uint256 amount, uint256 part, uint256 total)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return divRound(mul(amount, part), total);\r\n    }\r\n\r\n    //\r\n    // Open Zeppelin Math library below\r\n    //\r\n\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n/// @notice should be implemented by all contracts that initate the voting center procedure\r\n///         must be implemented by all contracts that initate voting procedure AND request observer callbacks\r\ncontract IVotingObserver {\r\n    /// @notice if requested, voting center will pass state transitions of proposal to observer\r\n    /// @dev refer to VotingProposal for state variable values\r\n    function onProposalStateTransition(\r\n        bytes32 proposalId,\r\n        uint8 oldState,\r\n        uint8 newState)\r\n        public;\r\n\r\n    /// @notice only observer may tell if vote was in favor or not, voting center only carries on voting procedure\r\n    ///         example is equity token controller as observer which will count outcome as passed depending on company bylaws\r\n    /// @param votingCenter at which voting center to look for the results\r\n    /// @param proposalId for which proposalId to deliver results\r\n    /// @return true means inFavor, false means agains, revert means that procedure is not yet final or any other problem\r\n    /// @dev please note the revert/false distinction above, do not returns false in case voting is unknown or not yet final\r\n    function votingResult(address votingCenter, bytes32 proposalId)\r\n        public\r\n        constant\r\n        returns (bool inFavor);\r\n}\r\n\r\nlibrary VotingProposal {\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    uint256 private constant STATES_COUNT = 5;\r\n\r\n    ////////////////////////\r\n    // Types\r\n    ////////////////////////\r\n\r\n    enum State {\r\n        // Initial state where voting owner can build quorum for public visibility\r\n        Campaigning,\r\n        // has passed campaign-quorum in time, voting publicly announced\r\n        Public,\r\n        // reveal state where meta-transactions are gathered\r\n        Reveal,\r\n        // For votings that have off-chain counterpart, this is the time to upload the tally\r\n        Tally,\r\n        // Vote count will not change and tally is available, terminal state\r\n        Final\r\n    }\r\n\r\n    // Łukasiewicz logic values for state of a vote of particular voter\r\n    /// @dev note that Abstain is meaningful only in Final/Tally state\r\n    enum TriState {\r\n        Abstain,\r\n        InFavor,\r\n        Against\r\n    }\r\n\r\n    /// @dev note that voting power is always expressed in tokens of the associated snapshot token\r\n    ///     and reflect decimals of the token. voting power of 1 token with 18 decimals is Q18\r\n    struct Proposal {\r\n        // voting power comes from here\r\n        ITokenSnapshots token;\r\n        // balances at this snapshot count\r\n        uint256 snapshotId;\r\n        // on-chain tally\r\n        uint256 inFavor;\r\n        uint256 against;\r\n        // off-chain tally\r\n        uint256 offchainInFavor;\r\n        uint256 offchainAgainst;\r\n\r\n        // quorum needed to reach public phase\r\n        uint256 campaignQuorumTokenAmount;\r\n\r\n        // off-chain voting power\r\n        uint256 offchainVotingPower;\r\n\r\n        // voting initiator\r\n        IVotingObserver initiator;\r\n        // voting legal representative\r\n        address votingLegalRep;\r\n\r\n        // proposal action as set by initiator\r\n        uint256 action;\r\n        // on chain proposal action payload\r\n        bytes actionPayload;\r\n        // off-chain official results\r\n        string offchainVoteDocumentUri;\r\n\r\n        // when states end, indexed by state, keep it word aligned\r\n        uint32[STATES_COUNT] deadlines;\r\n\r\n        // current state of the voting\r\n        State state;\r\n\r\n        // observer function requested to owner?\r\n        bool observing;\r\n\r\n        // you can vote only once\r\n        mapping (address => TriState) hasVoted;\r\n    }\r\n\r\n    /////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogProposalStateTransition(\r\n        bytes32 indexed proposalId,\r\n        address initiator,\r\n        address votingLegalRep,\r\n        address token,\r\n        State oldState,\r\n        State newState\r\n    );\r\n\r\n    /////////////////////////\r\n    // Internal Lib Functions\r\n    ////////////////////////\r\n\r\n    function isVotingOpen(VotingProposal.Proposal storage p)\r\n        internal\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return p.state == State.Campaigning || p.state == State.Public;\r\n    }\r\n\r\n    function isRelayOpen(VotingProposal.Proposal storage p)\r\n        internal\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return isVotingOpen(p) || p.state == State.Reveal;\r\n    }\r\n\r\n    function initialize(\r\n        Proposal storage p,\r\n        bytes32 proposalId,\r\n        ITokenSnapshots token,\r\n        uint256 snapshotId,\r\n        uint32 campaignDuration,\r\n        uint256 campaignQuorumFraction,\r\n        uint32 votingPeriod,\r\n        address votingLegalRep,\r\n        uint32 offchainVotePeriod,\r\n        uint256 totalVotingPower,\r\n        uint256 action,\r\n        bool enableObserver\r\n    )\r\n        internal\r\n    {\r\n        uint256 totalTokenVotes = token.totalSupplyAt(snapshotId);\r\n        require(totalTokenVotes > 0, \"NF_VC_EMPTY_TOKEN\");\r\n        require(totalVotingPower == 0 || totalVotingPower >= totalTokenVotes, \"NF_VC_TOTPOWER_LT_TOKEN\");\r\n\r\n        // set initial deadlines\r\n        uint32[STATES_COUNT] memory deadlines;\r\n        uint32 t = uint32(now);\r\n        deadlines[0] = t;\r\n        deadlines[1] = t + campaignDuration;\r\n        // no reveal now\r\n        deadlines[2] = deadlines[3] = t + votingPeriod;\r\n        // offchain voting deadline\r\n        // if all voting power belongs to token holders then off-chain tally must be skipped\r\n        deadlines[4] = deadlines[3] + (totalVotingPower == totalTokenVotes ? 0 : offchainVotePeriod);\r\n\r\n        // can't use struct constructor because it goes through memory\r\n        // p is already allocated storage slot\r\n        p.token = token;\r\n        p.snapshotId = snapshotId;\r\n        p.observing = enableObserver;\r\n\r\n        p.votingLegalRep = votingLegalRep;\r\n        p.offchainVotingPower = totalVotingPower > 0 ? Math.sub(totalVotingPower, totalTokenVotes) : 0;\r\n\r\n        // campaign must cross total voting power\r\n        p.campaignQuorumTokenAmount = Math.decimalFraction(totalTokenVotes + p.offchainVotingPower, campaignQuorumFraction);\r\n        require(p.campaignQuorumTokenAmount <= totalTokenVotes, \"NF_VC_NO_CAMP_VOTING_POWER\");\r\n\r\n        p.initiator = IVotingObserver(msg.sender);\r\n        p.deadlines = deadlines;\r\n        p.state = State.Campaigning;\r\n        p.action = action;\r\n\r\n        // advance campaigning state to public if quorum not specified\r\n        // that will also emit event if such transition happen\r\n        advanceLogicState(p, proposalId);\r\n    }\r\n\r\n    // @dev don't use `else if` and keep sorted by time and call `state()`\r\n    //     or else multiple transitions won't cascade properly.\r\n    function advanceTimedState(Proposal storage p, bytes32 proposalId)\r\n        internal\r\n    {\r\n        uint32 t = uint32(now);\r\n        // campaign timeout to final\r\n        if (p.state == State.Campaigning && t >= p.deadlines[uint32(State.Public)]) {\r\n            transitionTo(p, proposalId, State.Final);\r\n        }\r\n        // other states go one by one, terminal state stops\r\n        while(p.state != State.Final && t >= p.deadlines[uint32(p.state) + 1]) {\r\n            transitionTo(p, proposalId, State(uint8(p.state) + 1));\r\n        }\r\n    }\r\n\r\n    // @notice transitions due to business logic\r\n    // @dev called after logic\r\n    function advanceLogicState(Proposal storage p, bytes32 proposalId)\r\n        internal\r\n    {\r\n        // State state = p.state;\r\n        // if crossed campaign quorum\r\n        if (p.state == State.Campaigning && p.inFavor + p.against >= p.campaignQuorumTokenAmount) {\r\n            // go to public state\r\n            transitionTo(p, proposalId, State.Public);\r\n        }\r\n        // if off-chain tally done\r\n        if (p.state == State.Tally && p.offchainAgainst + p.offchainInFavor > 0) {\r\n            // finalize\r\n            transitionTo(p, proposalId, State.Final);\r\n        }\r\n    }\r\n\r\n    /// @notice executes transition state function\r\n    function transitionTo(Proposal storage p, bytes32 proposalId, State newState)\r\n        private\r\n    {\r\n        State oldState = p.state;\r\n        // get deadline for old state and check the delta for other states\r\n        uint32 delta;\r\n        uint32 deadline = p.deadlines[uint256(oldState) + 1];\r\n        // if transition came before deadline, count time from timestamp, if after always count from deadline\r\n        if (uint32(now) < deadline) {\r\n            delta = deadline - uint32(now);\r\n        }\r\n        if (delta > 0) {\r\n            // shift dealines for other states\r\n            uint32[STATES_COUNT] memory newDeadlines = p.deadlines;\r\n            for (uint256 ii = uint256(oldState) + 1; ii < STATES_COUNT; ii += 1) {\r\n                newDeadlines[ii] -= delta;\r\n            }\r\n            p.deadlines = newDeadlines;\r\n        }\r\n        // write storage\r\n        p.state = newState;\r\n\r\n        // do not emit events and observer if campaigning failed\r\n        if (oldState == State.Campaigning && newState == State.Final) {\r\n            return;\r\n        }\r\n\r\n        emit LogProposalStateTransition(proposalId, p.initiator, p.votingLegalRep, p.token, oldState, newState);\r\n        if (p.observing) {\r\n            // call observer on best-effort. ignore errors\r\n            bytes4 sel = p.initiator.onProposalStateTransition.selector;\r\n            (address(p.initiator)).call(\r\n                abi.encodeWithSelector(sel, proposalId, oldState, newState)\r\n                );\r\n        }\r\n    }\r\n}\r\n\r\n/// Contract to allow voting based on a snapshotable token (with relayed, batched voting)\r\ncontract VotingCenter is IVotingCenter {\r\n\r\n    using VotingProposal for VotingProposal.Proposal;\r\n\r\n    /////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    // @dev This modifier needs to be applied to all external non-constant functions.\r\n    //  this modifier goes _before_ other state modifiers like `onlyState`.\r\n    //  after function body execution state may transition again in `advanceLogicState`\r\n    modifier withStateTransition(bytes32 proposalId) {\r\n        VotingProposal.Proposal storage p = ensureExistingProposal(proposalId);\r\n        // switch state due to time\r\n        VotingProposal.advanceTimedState(p, proposalId);\r\n        // execute function body\r\n        _;\r\n        // switch state due to business logic\r\n        VotingProposal.advanceLogicState(p, proposalId);\r\n    }\r\n\r\n    // @dev This modifier needs to be applied to all external non-constant functions.\r\n    //  this modifier goes _before_ other state modifiers like `onlyState`.\r\n    //  note that this function actually modifies state so it will generate warnings\r\n    //  and is incompatible with STATICCALL\r\n    modifier withTimedTransition(bytes32 proposalId) {\r\n        VotingProposal.Proposal storage p = ensureExistingProposal(proposalId);\r\n        // switch state due to time\r\n        VotingProposal.advanceTimedState(p, proposalId);\r\n        // execute function body\r\n        _;\r\n    }\r\n\r\n    modifier withVotingOpen(bytes32 proposalId) {\r\n        VotingProposal.Proposal storage p = _proposals[proposalId];\r\n        require(VotingProposal.isVotingOpen(p), \"NV_VC_VOTING_CLOSED\");\r\n        _;\r\n    }\r\n\r\n    modifier withRelayingOpen(bytes32 proposalId) {\r\n        VotingProposal.Proposal storage p = _proposals[proposalId];\r\n        require(VotingProposal.isRelayOpen(p), \"NV_VC_VOTING_CLOSED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTally(bytes32 proposalId) {\r\n        VotingProposal.Proposal storage p = _proposals[proposalId];\r\n        require(p.state == VotingProposal.State.Tally, \"NV_VC_NOT_TALLYING\");\r\n        _;\r\n    }\r\n\r\n    /////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    mapping (bytes32 => VotingProposal.Proposal) private _proposals;\r\n    IVotingController private _votingController;\r\n\r\n\r\n    /////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    // must be in sync with library event, events cannot be shared\r\n    event LogProposalStateTransition(\r\n        bytes32 indexed proposalId,\r\n        address initiator,\r\n        address votingLegalRep,\r\n        address token,\r\n        VotingProposal.State oldState,\r\n        VotingProposal.State newState\r\n    );\r\n\r\n    // logged when voter casts a vote\r\n    event LogVoteCast(\r\n        bytes32 indexed proposalId,\r\n        address initiator,\r\n        address token,\r\n        address voter,\r\n        bool voteInFavor,\r\n        uint256 power\r\n    );\r\n\r\n    // logged when proposal legal rep provides off-chain voting results\r\n    event LogOffChainProposalResult(\r\n        bytes32 indexed proposalId,\r\n        address initiator,\r\n        address token,\r\n        address votingLegalRep,\r\n        uint256 inFavor,\r\n        uint256 against,\r\n        string documentUri\r\n    );\r\n\r\n    // logged when controller changed\r\n    event LogChangeVotingController(\r\n        address oldController,\r\n        address newController,\r\n        address by\r\n    );\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(IVotingController controller) public {\r\n        _votingController = controller;\r\n    }\r\n\r\n    /////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // IVotingCenter implementation\r\n    //\r\n\r\n    function addProposal(\r\n        bytes32 proposalId,\r\n        ITokenSnapshots token,\r\n        uint32 campaignDuration,\r\n        uint256 campaignQuorumFraction,\r\n        uint32 votingPeriod,\r\n        address votingLegalRep,\r\n        uint32 offchainVotePeriod,\r\n        uint256 totalVotingPower,\r\n        uint256 action,\r\n        bytes actionPayload,\r\n        bool enableObserver\r\n    )\r\n        public\r\n    {\r\n        require(token != address(0));\r\n        VotingProposal.Proposal storage p = _proposals[proposalId];\r\n\r\n        require(p.token == address(0), \"NF_VC_P_ID_NON_UNIQ\");\r\n        // campaign duration must be less or eq total voting period\r\n        require(campaignDuration <= votingPeriod, \"NF_VC_CAMPAIGN_OVR_TOTAL\");\r\n        require(campaignQuorumFraction <= 10**18, \"NF_VC_INVALID_CAMPAIGN_Q\");\r\n        require(\r\n            campaignQuorumFraction == 0 && campaignDuration == 0 ||\r\n            campaignQuorumFraction > 0 && campaignDuration > 0,\r\n            \"NF_VC_CAMP_INCONSISTENT\"\r\n        );\r\n        require(\r\n            offchainVotePeriod > 0 && totalVotingPower > 0 && votingLegalRep != address(0) ||\r\n            offchainVotePeriod == 0 && totalVotingPower == 0 && votingLegalRep == address(0),\r\n            \"NF_VC_TALLY_INCONSISTENT\"\r\n        );\r\n\r\n        // take sealed snapshot\r\n        uint256 sId = token.currentSnapshotId() - 1;\r\n\r\n        p.initialize(\r\n            proposalId,\r\n            token,\r\n            sId,\r\n            campaignDuration,\r\n            campaignQuorumFraction,\r\n            votingPeriod,\r\n            votingLegalRep,\r\n            offchainVotePeriod,\r\n            totalVotingPower,\r\n            action,\r\n            enableObserver\r\n        );\r\n        // we should do it in initialize bo stack is too small\r\n        p.actionPayload = actionPayload;\r\n        // call controller now when proposal is available via proposal method\r\n        require(_votingController.onAddProposal(proposalId, msg.sender, token), \"NF_VC_CTR_ADD_REJECTED\");\r\n    }\r\n\r\n    function vote(bytes32 proposalId, bool voteInFavor)\r\n        public\r\n        withStateTransition(proposalId)\r\n        withVotingOpen(proposalId)\r\n    {\r\n        VotingProposal.Proposal storage p = _proposals[proposalId];\r\n        require(p.hasVoted[msg.sender] == VotingProposal.TriState.Abstain, \"NF_VC_ALREADY_VOTED\");\r\n        castVote(p, proposalId, voteInFavor, msg.sender);\r\n    }\r\n\r\n    function addOffchainVote(bytes32 proposalId, uint256 inFavor, uint256 against, string documentUri)\r\n        public\r\n        withStateTransition(proposalId)\r\n        onlyTally(proposalId)\r\n    {\r\n        VotingProposal.Proposal storage p = _proposals[proposalId];\r\n        require(msg.sender == p.votingLegalRep, \"NF_VC_ONLY_VOTING_LEGAL_REP\");\r\n        // may not cross offchainVotingPower\r\n        require(inFavor + against <= p.offchainVotingPower, \"NF_VC_EXCEEDS_OFFLINE_V_POWER\");\r\n        require(inFavor + against > 0, \"NF_VC_NO_OFF_EMPTY_VOTE\");\r\n\r\n        p.offchainInFavor = inFavor;\r\n        p.offchainAgainst = against;\r\n        p.offchainVoteDocumentUri = documentUri;\r\n\r\n        emit LogOffChainProposalResult(proposalId, p.initiator, p.token, msg.sender, inFavor, against, documentUri);\r\n    }\r\n\r\n    function tally(bytes32 proposalId)\r\n        public\r\n        constant\r\n        withTimedTransition(proposalId)\r\n        returns(\r\n            uint8 s,\r\n            uint256 inFavor,\r\n            uint256 against,\r\n            uint256 offchainInFavor,\r\n            uint256 offchainAgainst,\r\n            uint256 tokenVotingPower,\r\n            uint256 totalVotingPower,\r\n            uint256 campaignQuorumTokenAmount,\r\n            address initiator,\r\n            bool hasObserverInterface\r\n        )\r\n    {\r\n        VotingProposal.Proposal storage p = ensureExistingProposal(proposalId);\r\n\r\n        s = uint8(p.state);\r\n        inFavor = p.inFavor;\r\n        against = p.against;\r\n        offchainInFavor = p.offchainInFavor;\r\n        offchainAgainst = p.offchainAgainst;\r\n        initiator = p.initiator;\r\n        hasObserverInterface = p.observing;\r\n        tokenVotingPower = p.token.totalSupplyAt(p.snapshotId);\r\n        totalVotingPower = tokenVotingPower + p.offchainVotingPower;\r\n        campaignQuorumTokenAmount = p.campaignQuorumTokenAmount;\r\n    }\r\n\r\n    function offchainVoteDocumentUri(bytes32 proposalId)\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        VotingProposal.Proposal storage p = ensureExistingProposal(proposalId);\r\n        return p.offchainVoteDocumentUri;\r\n    }\r\n\r\n    function timedProposal(bytes32 proposalId)\r\n        public\r\n        withTimedTransition(proposalId)\r\n        constant\r\n        returns (\r\n            uint8 s,\r\n            address token,\r\n            uint256 snapshotId,\r\n            address initiator,\r\n            address votingLegalRep,\r\n            uint256 campaignQuorumTokenAmount,\r\n            uint256 offchainVotingPower,\r\n            uint256 action,\r\n            bytes actionPayload,\r\n            bool enableObserver,\r\n            uint32[5] deadlines\r\n        )\r\n    {\r\n        VotingProposal.Proposal storage p = ensureExistingProposal(proposalId);\r\n\r\n        s = uint8(p.state);\r\n        token = p.token;\r\n        snapshotId = p.snapshotId;\r\n        enableObserver = p.observing;\r\n        campaignQuorumTokenAmount = p.campaignQuorumTokenAmount;\r\n        initiator = p.initiator;\r\n        votingLegalRep = p.votingLegalRep;\r\n        offchainVotingPower = p.offchainVotingPower;\r\n        deadlines = p.deadlines;\r\n        action = p.action;\r\n        actionPayload = p.actionPayload;\r\n    }\r\n\r\n    function proposal(bytes32 proposalId)\r\n        public\r\n        constant\r\n        returns (\r\n            uint8 s,\r\n            address token,\r\n            uint256 snapshotId,\r\n            address initiator,\r\n            address votingLegalRep,\r\n            uint256 campaignQuorumTokenAmount,\r\n            uint256 offchainVotingPower,\r\n            uint256 action,\r\n            bytes actionPayload,\r\n            bool enableObserver,\r\n            uint32[5] deadlines\r\n            )\r\n    {\r\n        VotingProposal.Proposal storage p = ensureExistingProposal(proposalId);\r\n\r\n        s = uint8(p.state);\r\n        token = p.token;\r\n        snapshotId = p.snapshotId;\r\n        enableObserver = p.observing;\r\n        campaignQuorumTokenAmount = p.campaignQuorumTokenAmount;\r\n        initiator = p.initiator;\r\n        votingLegalRep = p.votingLegalRep;\r\n        offchainVotingPower = p.offchainVotingPower;\r\n        deadlines = p.deadlines;\r\n        action = p.action;\r\n        actionPayload = p.actionPayload;\r\n    }\r\n\r\n    function getVote(bytes32 proposalId, address voter)\r\n        public\r\n        constant\r\n        returns (uint8)\r\n    {\r\n        VotingProposal.Proposal storage p = ensureExistingProposal(proposalId);\r\n        return uint8(p.hasVoted[voter]);\r\n    }\r\n\r\n    function hasProposal(bytes32 proposalId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        VotingProposal.Proposal storage p = _proposals[proposalId];\r\n        return p.token != address(0);\r\n    }\r\n\r\n    function getVotingPower(bytes32 proposalId, address voter)\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        VotingProposal.Proposal storage p = ensureExistingProposal(proposalId);\r\n        return p.token.balanceOfAt(voter, p.snapshotId);\r\n    }\r\n\r\n    //\r\n    // IContractId Implementation\r\n    //\r\n\r\n    function contractId()\r\n        public\r\n        pure\r\n        returns (bytes32 id, uint256 version)\r\n    {\r\n        return (0xbbf540c4111754f6dbce914d5e55e1c0cb26515adbc288b5ea8baa544adfbfa4, 0);\r\n    }\r\n\r\n    //\r\n    // IVotingController hook\r\n    //\r\n\r\n    /// @notice get current controller\r\n    function votingController()\r\n        public\r\n        constant\r\n        returns (IVotingController)\r\n    {\r\n        return _votingController;\r\n    }\r\n\r\n    /// @notice update current controller\r\n    function changeVotingController(IVotingController newController)\r\n        public\r\n    {\r\n        require(_votingController.onChangeVotingController(msg.sender, newController), \"NF_VC_CHANGING_CTR_REJECTED\");\r\n        address oldController = address(_votingController);\r\n        _votingController = newController;\r\n        emit LogChangeVotingController(oldController, address(newController), msg.sender);\r\n    }\r\n\r\n    //\r\n    // Other methods\r\n    //\r\n\r\n    /// @dev same as vote, only for a relayed vote. Will throw if provided signature (v,r,s) does not match\r\n    ///  the address of the voter\r\n    /// @param voter address whose token balance should be used as voting power\r\n    function relayedVote(\r\n        bytes32 proposalId,\r\n        bool voteInFavor,\r\n        address voter,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v\r\n    )\r\n        public\r\n        withStateTransition(proposalId)\r\n        withRelayingOpen(proposalId)\r\n    {\r\n        // check that message signature matches the voter address\r\n        assert(isValidSignature(proposalId, voteInFavor, voter, r, s, v));\r\n        // solium-enable indentation\r\n        VotingProposal.Proposal storage p = _proposals[proposalId];\r\n        require(p.hasVoted[voter] == VotingProposal.TriState.Abstain, \"NF_VC_ALREADY_VOTED\");\r\n        castVote(p, proposalId, voteInFavor, voter);\r\n    }\r\n\r\n    // batches should be grouped by proposal, that allows to tally in place and write to storage once\r\n    function batchRelayedVotes(\r\n        bytes32 proposalId,\r\n        bool[] votePreferences,\r\n        bytes32[] r,\r\n        bytes32[] s,\r\n        uint8[] v\r\n    )\r\n        public\r\n        withStateTransition(proposalId)\r\n        withRelayingOpen(proposalId)\r\n    {\r\n        assert(\r\n            votePreferences.length == r.length && r.length == s.length && s.length == v.length\r\n        );\r\n        relayBatchInternal(\r\n            proposalId,\r\n            votePreferences,\r\n            r, s, v\r\n        );\r\n    }\r\n\r\n    function handleStateTransitions(bytes32 proposalId)\r\n        public\r\n        withTimedTransition(proposalId)\r\n    {}\r\n\r\n    //\r\n    // Utility public functions\r\n    //\r\n\r\n    function isValidSignature(\r\n        bytes32 proposalId,\r\n        bool voteInFavor,\r\n        address voter,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v\r\n    )\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        // solium-disable indentation\r\n        return ecrecoverVoterAddress(proposalId, voteInFavor, r, s, v) == voter;\r\n    }\r\n\r\n    function ecrecoverVoterAddress(\r\n        bytes32 proposalId,\r\n        bool voteInFavor,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v\r\n    )\r\n        public\r\n        constant\r\n        returns (address)\r\n    {\r\n        // solium-disable indentation\r\n        return ecrecover(\r\n            keccak256(abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                keccak256(abi.encodePacked(byte(0), address(this), proposalId, voteInFavor)))),\r\n            v, r, s);\r\n    }\r\n\r\n    /////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    function ensureExistingProposal(bytes32 proposalId)\r\n        internal\r\n        constant\r\n        returns (VotingProposal.Proposal storage p)\r\n    {\r\n        p = _proposals[proposalId];\r\n        require(p.token != address(0), \"NF_VC_PROP_NOT_EXIST\");\r\n        return p;\r\n    }\r\n\r\n    /////////////////////////\r\n    // Private functions\r\n    ////////////////////////\r\n\r\n    /// @dev increase the votecount on a given proposal by the token balance of a given address,\r\n    ///   throws if proposal does not exist or the vote on it has ended already. Votes are final,\r\n    ///   changing the vote is not allowed\r\n    /// @param p proposal storage pointer\r\n    /// @param proposalId of the proposal to be voted on\r\n    /// @param voteInFavor of the desired proposal\r\n    /// @param voter address whose tokenBalance is to be used as voting-power\r\n    function castVote(VotingProposal.Proposal storage p, bytes32 proposalId, bool voteInFavor, address voter)\r\n        private\r\n    {\r\n        uint256 power = p.token.balanceOfAt(voter, p.snapshotId);\r\n        if (voteInFavor) {\r\n            p.inFavor = Math.add(p.inFavor, power);\r\n        } else {\r\n            p.against = Math.add(p.against, power);\r\n        }\r\n        markVoteCast(p, proposalId, voter, voteInFavor, power);\r\n    }\r\n\r\n    function relayBatchInternal(\r\n        bytes32 proposalId,\r\n        bool[] votePreferences,\r\n        bytes32[] r,\r\n        bytes32[] s,\r\n        uint8[] v\r\n    )\r\n        private\r\n    {\r\n        uint256 inFavor;\r\n        uint256 against;\r\n        VotingProposal.Proposal storage p = _proposals[proposalId];\r\n        for (uint256 i = 0; i < votePreferences.length; i++) {\r\n            uint256 power = relayBatchElement(\r\n                p,\r\n                proposalId,\r\n                votePreferences[i],\r\n                r[i], s[i], v[i]);\r\n            if (votePreferences[i]) {\r\n                inFavor = Math.add(inFavor, power);\r\n            } else {\r\n                against = Math.add(against, power);\r\n            }\r\n        }\r\n        // write votes to storage\r\n        p.inFavor = Math.add(p.inFavor, inFavor);\r\n        p.against = Math.add(p.against, against);\r\n    }\r\n\r\n    function relayBatchElement(\r\n        VotingProposal.Proposal storage p,\r\n        bytes32 proposalId,\r\n        bool voteInFavor,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v\r\n    )\r\n        private\r\n        returns (uint256 power)\r\n    {\r\n        // recover voter from signature, mangled data produces mangeld voter address, which will be\r\n        // eliminated later\r\n        address voter = ecrecoverVoterAddress(\r\n            proposalId,\r\n            voteInFavor,\r\n            r, s, v\r\n        );\r\n        // cast vote if not cast before\r\n        if (p.hasVoted[voter] == VotingProposal.TriState.Abstain) {\r\n            power = p.token.balanceOfAt(voter, p.snapshotId);\r\n            // if not holding token, power is 0\r\n            markVoteCast(p, proposalId, voter, voteInFavor, power);\r\n        }\r\n        // returns voting power which is zero in case of failed vote\r\n    }\r\n\r\n    function markVoteCast(VotingProposal.Proposal storage p, bytes32 proposalId, address voter, bool voteInFavor, uint256 power)\r\n        private\r\n    {\r\n        if (power > 0) {\r\n            p.hasVoted[voter] = voteInFavor ? VotingProposal.TriState.InFavor : VotingProposal.TriState.Against;\r\n            emit LogVoteCast(proposalId, p.initiator, p.token, voter, voteInFavor, power);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"name\":\"handleStateTransitions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"name\":\"voteInFavor\",\"type\":\"bool\"},{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"relayedVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"name\":\"voteInFavor\",\"type\":\"bool\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"ecrecoverVoterAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"campaignDuration\",\"type\":\"uint32\"},{\"name\":\"campaignQuorumFraction\",\"type\":\"uint256\"},{\"name\":\"votingPeriod\",\"type\":\"uint32\"},{\"name\":\"votingLegalRep\",\"type\":\"address\"},{\"name\":\"offchainVotePeriod\",\"type\":\"uint32\"},{\"name\":\"totalVotingPower\",\"type\":\"uint256\"},{\"name\":\"action\",\"type\":\"uint256\"},{\"name\":\"actionPayload\",\"type\":\"bytes\"},{\"name\":\"enableObserver\",\"type\":\"bool\"}],\"name\":\"addProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"name\":\"offchainVoteDocumentUri\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"name\":\"voteInFavor\",\"type\":\"bool\"},{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"name\":\"timedProposal\",\"outputs\":[{\"name\":\"s\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"snapshotId\",\"type\":\"uint256\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"votingLegalRep\",\"type\":\"address\"},{\"name\":\"campaignQuorumTokenAmount\",\"type\":\"uint256\"},{\"name\":\"offchainVotingPower\",\"type\":\"uint256\"},{\"name\":\"action\",\"type\":\"uint256\"},{\"name\":\"actionPayload\",\"type\":\"bytes\"},{\"name\":\"enableObserver\",\"type\":\"bool\"},{\"name\":\"deadlines\",\"type\":\"uint32[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"name\":\"proposal\",\"outputs\":[{\"name\":\"s\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"snapshotId\",\"type\":\"uint256\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"votingLegalRep\",\"type\":\"address\"},{\"name\":\"campaignQuorumTokenAmount\",\"type\":\"uint256\"},{\"name\":\"offchainVotingPower\",\"type\":\"uint256\"},{\"name\":\"action\",\"type\":\"uint256\"},{\"name\":\"actionPayload\",\"type\":\"bytes\"},{\"name\":\"enableObserver\",\"type\":\"bool\"},{\"name\":\"deadlines\",\"type\":\"uint32[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"name\":\"inFavor\",\"type\":\"uint256\"},{\"name\":\"against\",\"type\":\"uint256\"},{\"name\":\"documentUri\",\"type\":\"string\"}],\"name\":\"addOffchainVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractId\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"name\":\"votePreferences\",\"type\":\"bool[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"},{\"name\":\"v\",\"type\":\"uint8[]\"}],\"name\":\"batchRelayedVotes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"name\":\"voteInFavor\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getVotingPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getVote\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"changeVotingController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"name\":\"tally\",\"outputs\":[{\"name\":\"s\",\"type\":\"uint8\"},{\"name\":\"inFavor\",\"type\":\"uint256\"},{\"name\":\"against\",\"type\":\"uint256\"},{\"name\":\"offchainInFavor\",\"type\":\"uint256\"},{\"name\":\"offchainAgainst\",\"type\":\"uint256\"},{\"name\":\"tokenVotingPower\",\"type\":\"uint256\"},{\"name\":\"totalVotingPower\",\"type\":\"uint256\"},{\"name\":\"campaignQuorumTokenAmount\",\"type\":\"uint256\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"hasObserverInterface\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"name\":\"hasProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"controller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"votingLegalRep\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldState\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"LogProposalStateTransition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"voteInFavor\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"power\",\"type\":\"uint256\"}],\"name\":\"LogVoteCast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"votingLegalRep\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"inFavor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"against\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"documentUri\",\"type\":\"string\"}],\"name\":\"LogOffChainProposalResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldController\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newController\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"LogChangeVotingController\",\"type\":\"event\"}]","ContractName":"VotingCenter","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000698ee61515a02f46124341e8ed25b1bb417db27c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://cc7171c5b324ce3ec1cb8f0a8e5306236b6990c6d46a48d73535e508b5f12ccd"}]}