{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/src/common/lifecycle/Killable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * A module that allows contracts to self-destruct.\r\n */\r\ncontract Killable {\r\n\taddress payable public _owner;\r\n\r\n\t/**\r\n\t * Initialized with the deployer as the owner.\r\n\t */\r\n\tconstructor() internal {\r\n\t\t_owner = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * Self-destruct the contract.\r\n\t * This function can only be executed by the owner.\r\n\t */\r\n\tfunction kill() public {\r\n\t\trequire(msg.sender == _owner, \"only owner method\");\r\n\t\tselfdestruct(_owner);\r\n\t}\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n\t// Empty internal constructor, to prevent people from mistakenly deploying\r\n\t// an instance of this contract, which should be used via inheritance.\r\n\tconstructor() internal {}\r\n\r\n\t// solhint-disable-previous-line no-empty-blocks\r\n\r\n\tfunction _msgSender() internal view returns (address payable) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view returns (bytes memory) {\r\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(\r\n\t\taddress indexed previousOwner,\r\n\t\taddress indexed newOwner\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor() internal {\r\n\t\taddress msgSender = _msgSender();\r\n\t\t_owner = msgSender;\r\n\t\temit OwnershipTransferred(address(0), msgSender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(isOwner(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the caller is the current owner.\r\n\t */\r\n\tfunction isOwner() public view returns (bool) {\r\n\t\treturn _msgSender() == _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public onlyOwner {\r\n\t\temit OwnershipTransferred(_owner, address(0));\r\n\t\t_owner = address(0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\t_transferOwnership(newOwner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t */\r\n\tfunction _transferOwnership(address newOwner) internal {\r\n\t\trequire(\r\n\t\t\tnewOwner != address(0),\r\n\t\t\t\"Ownable: new owner is the zero address\"\r\n\t\t);\r\n\t\temit OwnershipTransferred(_owner, newOwner);\r\n\t\t_owner = newOwner;\r\n\t}\r\n}\r\n\r\n// File: contracts/src/common/interface/IGroup.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IGroup {\r\n\tfunction isGroup(address _addr) public view returns (bool);\r\n\r\n\tfunction addGroup(address _addr) external;\r\n\r\n\tfunction getGroupKey(address _addr) internal pure returns (bytes32) {\r\n\t\treturn keccak256(abi.encodePacked(\"_group\", _addr));\r\n\t}\r\n}\r\n\r\n// File: contracts/src/common/validate/AddressValidator.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * A module that provides common validations patterns.\r\n */\r\ncontract AddressValidator {\r\n\tstring constant errorMessage = \"this is illegal address\";\r\n\r\n\t/**\r\n\t * Validates passed address is not a zero address.\r\n\t */\r\n\tfunction validateIllegalAddress(address _addr) external pure {\r\n\t\trequire(_addr != address(0), errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * Validates passed address is included in an address set.\r\n\t */\r\n\tfunction validateGroup(address _addr, address _groupAddr) external view {\r\n\t\trequire(IGroup(_groupAddr).isGroup(_addr), errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * Validates passed address is included in two address sets.\r\n\t */\r\n\tfunction validateGroups(\r\n\t\taddress _addr,\r\n\t\taddress _groupAddr1,\r\n\t\taddress _groupAddr2\r\n\t) external view {\r\n\t\tif (IGroup(_groupAddr1).isGroup(_addr)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trequire(IGroup(_groupAddr2).isGroup(_addr), errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * Validates that the address of the first argument is equal to the address of the second argument.\r\n\t */\r\n\tfunction validateAddress(address _addr, address _target) external pure {\r\n\t\trequire(_addr == _target, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * Validates passed address equals to the two addresses.\r\n\t */\r\n\tfunction validateAddresses(\r\n\t\taddress _addr,\r\n\t\taddress _target1,\r\n\t\taddress _target2\r\n\t) external pure {\r\n\t\tif (_addr == _target1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trequire(_addr == _target2, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * Validates passed address equals to the three addresses.\r\n\t */\r\n\tfunction validate3Addresses(\r\n\t\taddress _addr,\r\n\t\taddress _target1,\r\n\t\taddress _target2,\r\n\t\taddress _target3\r\n\t) external pure {\r\n\t\tif (_addr == _target1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (_addr == _target2) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trequire(_addr == _target3, errorMessage);\r\n\t}\r\n}\r\n\r\n// File: contracts/src/common/validate/UsingValidator.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// prettier-ignore\r\n\r\n/**\r\n * Module for contrast handling AddressValidator.\r\n */\r\ncontract UsingValidator {\r\n\tAddressValidator private _validator;\r\n\r\n\t/**\r\n\t * Create a new AddressValidator contract when initialize.\r\n\t */\r\n\tconstructor() public {\r\n\t\t_validator = new AddressValidator();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the set AddressValidator address.\r\n\t */\r\n\tfunction addressValidator() internal view returns (AddressValidator) {\r\n\t\treturn _validator;\r\n\t}\r\n}\r\n\r\n// File: contracts/src/common/config/AddressConfig.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * A registry contract to hold the latest contract addresses.\r\n * Dev Protocol will be upgradeable by this contract.\r\n */\r\ncontract AddressConfig is Ownable, UsingValidator, Killable {\r\n\taddress public token = 0x98626E2C9231f03504273d55f397409deFD4a093;\r\n\taddress public allocator;\r\n\taddress public allocatorStorage;\r\n\taddress public withdraw;\r\n\taddress public withdrawStorage;\r\n\taddress public marketFactory;\r\n\taddress public marketGroup;\r\n\taddress public propertyFactory;\r\n\taddress public propertyGroup;\r\n\taddress public metricsGroup;\r\n\taddress public metricsFactory;\r\n\taddress public policy;\r\n\taddress public policyFactory;\r\n\taddress public policySet;\r\n\taddress public policyGroup;\r\n\taddress public lockup;\r\n\taddress public lockupStorage;\r\n\taddress public voteTimes;\r\n\taddress public voteTimesStorage;\r\n\taddress public voteCounter;\r\n\taddress public voteCounterStorage;\r\n\r\n\t/**\r\n\t * Set the latest Allocator contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setAllocator(address _addr) external onlyOwner {\r\n\t\tallocator = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest AllocatorStorage contract address.\r\n\t * Only the owner can execute this function.\r\n\t * NOTE: But currently, the AllocatorStorage contract is not used.\r\n\t */\r\n\tfunction setAllocatorStorage(address _addr) external onlyOwner {\r\n\t\tallocatorStorage = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest Withdraw contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setWithdraw(address _addr) external onlyOwner {\r\n\t\twithdraw = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest WithdrawStorage contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setWithdrawStorage(address _addr) external onlyOwner {\r\n\t\twithdrawStorage = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest MarketFactory contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setMarketFactory(address _addr) external onlyOwner {\r\n\t\tmarketFactory = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest MarketGroup contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setMarketGroup(address _addr) external onlyOwner {\r\n\t\tmarketGroup = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest PropertyFactory contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setPropertyFactory(address _addr) external onlyOwner {\r\n\t\tpropertyFactory = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest PropertyGroup contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setPropertyGroup(address _addr) external onlyOwner {\r\n\t\tpropertyGroup = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest MetricsFactory contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setMetricsFactory(address _addr) external onlyOwner {\r\n\t\tmetricsFactory = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest MetricsGroup contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setMetricsGroup(address _addr) external onlyOwner {\r\n\t\tmetricsGroup = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest PolicyFactory contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setPolicyFactory(address _addr) external onlyOwner {\r\n\t\tpolicyFactory = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest PolicyGroup contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setPolicyGroup(address _addr) external onlyOwner {\r\n\t\tpolicyGroup = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest PolicySet contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setPolicySet(address _addr) external onlyOwner {\r\n\t\tpolicySet = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest Policy contract address.\r\n\t * Only the latest PolicyFactory contract can execute this function.\r\n\t */\r\n\tfunction setPolicy(address _addr) external {\r\n\t\taddressValidator().validateAddress(msg.sender, policyFactory);\r\n\t\tpolicy = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest Dev contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setToken(address _addr) external onlyOwner {\r\n\t\ttoken = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest Lockup contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setLockup(address _addr) external onlyOwner {\r\n\t\tlockup = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest LockupStorage contract address.\r\n\t * Only the owner can execute this function.\r\n\t * NOTE: But currently, the LockupStorage contract is not used as a stand-alone because it is inherited from the Lockup contract.\r\n\t */\r\n\tfunction setLockupStorage(address _addr) external onlyOwner {\r\n\t\tlockupStorage = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest VoteTimes contract address.\r\n\t * Only the owner can execute this function.\r\n\t * NOTE: But currently, the VoteTimes contract is not used.\r\n\t */\r\n\tfunction setVoteTimes(address _addr) external onlyOwner {\r\n\t\tvoteTimes = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest VoteTimesStorage contract address.\r\n\t * Only the owner can execute this function.\r\n\t * NOTE: But currently, the VoteTimesStorage contract is not used.\r\n\t */\r\n\tfunction setVoteTimesStorage(address _addr) external onlyOwner {\r\n\t\tvoteTimesStorage = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest VoteCounter contract address.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setVoteCounter(address _addr) external onlyOwner {\r\n\t\tvoteCounter = _addr;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the latest VoteCounterStorage contract address.\r\n\t * Only the owner can execute this function.\r\n\t * NOTE: But currently, the VoteCounterStorage contract is not used as a stand-alone because it is inherited from the VoteCounter contract.\r\n\t */\r\n\tfunction setVoteCounterStorage(address _addr) external onlyOwner {\r\n\t\tvoteCounterStorage = _addr;\r\n\t}\r\n}\r\n\r\n// File: contracts/src/common/config/UsingConfig.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * Module for using AddressConfig contracts.\r\n */\r\ncontract UsingConfig {\r\n\tAddressConfig private _config;\r\n\r\n\t/**\r\n\t * Initialize the argument as AddressConfig address.\r\n\t */\r\n\tconstructor(address _addressConfig) public {\r\n\t\t_config = AddressConfig(_addressConfig);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the latest AddressConfig instance.\r\n\t */\r\n\tfunction config() internal view returns (AddressConfig) {\r\n\t\treturn _config;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the latest AddressConfig address.\r\n\t */\r\n\tfunction configAddress() external view returns (address) {\r\n\t\treturn address(_config);\r\n\t}\r\n}\r\n\r\n// File: contracts/src/market/IMarketFactory.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IMarketFactory {\r\n\tfunction create(address _addr) external returns (address);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `+` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Addition cannot overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Subtraction cannot overflow.\r\n\t *\r\n\t * _Available since v2.4.0._\r\n\t */\r\n\tfunction sub(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\trequire(b <= a, errorMessage);\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `*` operator.\r\n\t *\r\n\t * Requirements:\r\n\t * - Multiplication cannot overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn div(a, b, \"SafeMath: division by zero\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t *\r\n\t * _Available since v2.4.0._\r\n\t */\r\n\tfunction div(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\t// Solidity only automatically asserts when dividing by 0\r\n\t\trequire(b > 0, errorMessage);\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * Reverts when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * Reverts with custom message when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t * - The divisor cannot be zero.\r\n\t *\r\n\t * _Available since v2.4.0._\r\n\t */\r\n\tfunction mod(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\trequire(b != 0, errorMessage);\r\n\t\treturn a % b;\r\n\t}\r\n}\r\n\r\n// File: contracts/src/property/IProperty.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IProperty {\r\n\tfunction author() external view returns (address);\r\n\r\n\tfunction withdraw(address _sender, uint256 _value) external;\r\n}\r\n\r\n// File: contracts/src/market/IMarket.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface IMarket {\r\n\tfunction authenticate(\r\n\t\taddress _prop,\r\n\t\tstring calldata _args1,\r\n\t\tstring calldata _args2,\r\n\t\tstring calldata _args3,\r\n\t\tstring calldata _args4,\r\n\t\tstring calldata _args5\r\n\t)\r\n\t\texternal\r\n\t\treturns (\r\n\t\t\t// solium-disable-next-line indentation\r\n\t\t\tbool\r\n\t\t);\r\n\r\n\tfunction authenticatedCallback(address _property, bytes32 _idHash)\r\n\t\texternal\r\n\t\treturns (address);\r\n\r\n\tfunction deauthenticate(address _metrics) external;\r\n\r\n\tfunction schema() external view returns (string memory);\r\n\r\n\tfunction behavior() external view returns (address);\r\n\r\n\tfunction enabled() external view returns (bool);\r\n\r\n\tfunction votingEndBlockNumber() external view returns (uint256);\r\n\r\n\tfunction toEnable() external;\r\n}\r\n\r\n// File: contracts/src/market/IMarketBehavior.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface IMarketBehavior {\r\n\tfunction authenticate(\r\n\t\taddress _prop,\r\n\t\tstring calldata _args1,\r\n\t\tstring calldata _args2,\r\n\t\tstring calldata _args3,\r\n\t\tstring calldata _args4,\r\n\t\tstring calldata _args5,\r\n\t\taddress market,\r\n\t\taddress account\r\n\t)\r\n\t\texternal\r\n\t\treturns (\r\n\t\t\t// solium-disable-next-line indentation\r\n\t\t\tbool\r\n\t\t);\r\n\r\n\tfunction schema() external view returns (string memory);\r\n\r\n\tfunction getId(address _metrics) external view returns (string memory);\r\n\r\n\tfunction getMetrics(string calldata _id) external view returns (address);\r\n}\r\n\r\n// File: contracts/src/policy/IPolicy.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IPolicy {\r\n\tfunction rewards(uint256 _lockups, uint256 _assets)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction holdersShare(uint256 _amount, uint256 _lockups)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction assetValue(uint256 _value, uint256 _lockups)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction authenticationFee(uint256 _assets, uint256 _propertyAssets)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction marketApproval(uint256 _agree, uint256 _opposite)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bool);\r\n\r\n\tfunction policyApproval(uint256 _agree, uint256 _opposite)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bool);\r\n\r\n\tfunction marketVotingBlocks() external view returns (uint256);\r\n\r\n\tfunction policyVotingBlocks() external view returns (uint256);\r\n\r\n\tfunction abstentionPenalty(uint256 _count) external view returns (uint256);\r\n\r\n\tfunction lockUpBlocks() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/src/metrics/IMetrics.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IMetrics {\r\n\taddress public market;\r\n\taddress public property;\r\n}\r\n\r\n// File: contracts/src/metrics/Metrics.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * A contract for associating a Property and an asset authenticated by a Market.\r\n */\r\ncontract Metrics is IMetrics {\r\n\taddress public market;\r\n\taddress public property;\r\n\r\n\tconstructor(address _market, address _property) public {\r\n\t\t//Do not validate because there is no AddressConfig\r\n\t\tmarket = _market;\r\n\t\tproperty = _property;\r\n\t}\r\n}\r\n\r\n// File: contracts/src/metrics/IMetricsFactory.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IMetricsFactory {\r\n\tfunction create(address _property) external returns (address);\r\n\r\n\tfunction destroy(address _metrics) external;\r\n}\r\n\r\n// File: contracts/src/metrics/IMetricsGroup.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IMetricsGroup is IGroup {\r\n\tfunction removeGroup(address _addr) external;\r\n\r\n\tfunction totalIssuedMetrics() external view returns (uint256);\r\n\r\n\tfunction getMetricsCountPerProperty(address _property)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction hasAssets(address _property) public view returns (bool);\r\n}\r\n\r\n// File: contracts/src/lockup/ILockup.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract ILockup {\r\n\tfunction lockup(\r\n\t\taddress _from,\r\n\t\taddress _property,\r\n\t\tuint256 _value\r\n\t\t// solium-disable-next-line indentation\r\n\t) external;\r\n\r\n\tfunction update() public;\r\n\r\n\tfunction cancel(address _property) external;\r\n\r\n\tfunction withdraw(address _property) external;\r\n\r\n\tfunction difference(address _property, uint256 _lastReward)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256 _reward,\r\n\t\t\tuint256 _holdersAmount,\r\n\t\t\tuint256 _holdersPrice,\r\n\t\t\tuint256 _interestAmount,\r\n\t\t\tuint256 _interestPrice\r\n\t\t);\r\n\r\n\tfunction getPropertyValue(address _property)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction getAllValue() external view returns (uint256);\r\n\r\n\tfunction getValue(address _property, address _sender)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction calculateWithdrawableInterestAmount(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\t// solium-disable-next-line indentation\r\n\t\t\tuint256\r\n\t\t);\r\n\r\n\tfunction withdrawInterest(address _property) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n\t/**\r\n\t * @dev Returns the amount of tokens in existence.\r\n\t */\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the amount of tokens owned by `account`.\r\n\t */\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transfer(address recipient, uint256 amount)\r\n\t\texternal\r\n\t\treturns (bool);\r\n\r\n\t/**\r\n\t * @dev Returns the remaining number of tokens that `spender` will be\r\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n\t * zero by default.\r\n\t *\r\n\t * This value changes when {approve} or {transferFrom} are called.\r\n\t */\r\n\tfunction allowance(address owner, address spender)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\t/**\r\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n\t * that someone may use both the old and the new allowance by unfortunate\r\n\t * transaction ordering. One possible solution to mitigate this race\r\n\t * condition is to first reduce the spender's allowance to 0 and set the\r\n\t * desired value afterwards:\r\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t *\r\n\t * Emits an {Approval} event.\r\n\t */\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n\t * allowance mechanism. `amount` is then deducted from the caller's\r\n\t * allowance.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n\t * another (`to`).\r\n\t *\r\n\t * Note that `value` may be zero.\r\n\t */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n\t * a call to {approve}. `value` is the new allowance.\r\n\t */\r\n\tevent Approval(\r\n\t\taddress indexed owner,\r\n\t\taddress indexed spender,\r\n\t\tuint256 value\r\n\t);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n\tstring private _name;\r\n\tstring private _symbol;\r\n\tuint8 private _decimals;\r\n\r\n\t/**\r\n\t * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n\t * these values are immutable: they can only be set once during\r\n\t * construction.\r\n\t */\r\n\tconstructor(\r\n\t\tstring memory name,\r\n\t\tstring memory symbol,\r\n\t\tuint8 decimals\r\n\t) public {\r\n\t\t_name = name;\r\n\t\t_symbol = symbol;\r\n\t\t_decimals = decimals;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the name of the token.\r\n\t */\r\n\tfunction name() public view returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the symbol of the token, usually a shorter version of the\r\n\t * name.\r\n\t */\r\n\tfunction symbol() public view returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the number of decimals used to get its user representation.\r\n\t * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n\t * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n\t *\r\n\t * Tokens usually opt for a value of 18, imitating the relationship between\r\n\t * Ether and Wei.\r\n\t *\r\n\t * NOTE: This information is only used for _display_ purposes: it in\r\n\t * no way affects any of the arithmetic of the contract, including\r\n\t * {IERC20-balanceOf} and {IERC20-transfer}.\r\n\t */\r\n\tfunction decimals() public view returns (uint8) {\r\n\t\treturn _decimals;\r\n\t}\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping(address => uint256) private _balances;\r\n\r\n\tmapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n\tuint256 private _totalSupply;\r\n\r\n\t/**\r\n\t * @dev See {IERC20-totalSupply}.\r\n\t */\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-balanceOf}.\r\n\t */\r\n\tfunction balanceOf(address account) public view returns (uint256) {\r\n\t\treturn _balances[account];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-transfer}.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `recipient` cannot be the zero address.\r\n\t * - the caller must have a balance of at least `amount`.\r\n\t */\r\n\tfunction transfer(address recipient, uint256 amount) public returns (bool) {\r\n\t\t_transfer(_msgSender(), recipient, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-allowance}.\r\n\t */\r\n\tfunction allowance(address owner, address spender)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn _allowances[owner][spender];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-approve}.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `spender` cannot be the zero address.\r\n\t */\r\n\tfunction approve(address spender, uint256 amount) public returns (bool) {\r\n\t\t_approve(_msgSender(), spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC20-transferFrom}.\r\n\t *\r\n\t * Emits an {Approval} event indicating the updated allowance. This is not\r\n\t * required by the EIP. See the note at the beginning of {ERC20};\r\n\t *\r\n\t * Requirements:\r\n\t * - `sender` and `recipient` cannot be the zero address.\r\n\t * - `sender` must have a balance of at least `amount`.\r\n\t * - the caller must have allowance for `sender`'s tokens of at least\r\n\t * `amount`.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) public returns (bool) {\r\n\t\t_transfer(sender, recipient, amount);\r\n\t\t_approve(\r\n\t\t\tsender,\r\n\t\t\t_msgSender(),\r\n\t\t\t_allowances[sender][_msgSender()].sub(\r\n\t\t\t\tamount,\r\n\t\t\t\t\"ERC20: transfer amount exceeds allowance\"\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n\t *\r\n\t * This is an alternative to {approve} that can be used as a mitigation for\r\n\t * problems described in {IERC20-approve}.\r\n\t *\r\n\t * Emits an {Approval} event indicating the updated allowance.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `spender` cannot be the zero address.\r\n\t */\r\n\tfunction increaseAllowance(address spender, uint256 addedValue)\r\n\t\tpublic\r\n\t\treturns (bool)\r\n\t{\r\n\t\t_approve(\r\n\t\t\t_msgSender(),\r\n\t\t\tspender,\r\n\t\t\t_allowances[_msgSender()][spender].add(addedValue)\r\n\t\t);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n\t *\r\n\t * This is an alternative to {approve} that can be used as a mitigation for\r\n\t * problems described in {IERC20-approve}.\r\n\t *\r\n\t * Emits an {Approval} event indicating the updated allowance.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `spender` cannot be the zero address.\r\n\t * - `spender` must have allowance for the caller of at least\r\n\t * `subtractedValue`.\r\n\t */\r\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue)\r\n\t\tpublic\r\n\t\treturns (bool)\r\n\t{\r\n\t\t_approve(\r\n\t\t\t_msgSender(),\r\n\t\t\tspender,\r\n\t\t\t_allowances[_msgSender()][spender].sub(\r\n\t\t\t\tsubtractedValue,\r\n\t\t\t\t\"ERC20: decreased allowance below zero\"\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n\t *\r\n\t * This is internal function is equivalent to {transfer}, and can be used to\r\n\t * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `sender` cannot be the zero address.\r\n\t * - `recipient` cannot be the zero address.\r\n\t * - `sender` must have a balance of at least `amount`.\r\n\t */\r\n\tfunction _transfer(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) internal {\r\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\r\n\t\trequire(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n\t\t_balances[sender] = _balances[sender].sub(\r\n\t\t\tamount,\r\n\t\t\t\"ERC20: transfer amount exceeds balance\"\r\n\t\t);\r\n\t\t_balances[recipient] = _balances[recipient].add(amount);\r\n\t\temit Transfer(sender, recipient, amount);\r\n\t}\r\n\r\n\t/** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n\t * the total supply.\r\n\t *\r\n\t * Emits a {Transfer} event with `from` set to the zero address.\r\n\t *\r\n\t * Requirements\r\n\t *\r\n\t * - `to` cannot be the zero address.\r\n\t */\r\n\tfunction _mint(address account, uint256 amount) internal {\r\n\t\trequire(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n\t\t_totalSupply = _totalSupply.add(amount);\r\n\t\t_balances[account] = _balances[account].add(amount);\r\n\t\temit Transfer(address(0), account, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Destroys `amount` tokens from `account`, reducing the\r\n\t * total supply.\r\n\t *\r\n\t * Emits a {Transfer} event with `to` set to the zero address.\r\n\t *\r\n\t * Requirements\r\n\t *\r\n\t * - `account` cannot be the zero address.\r\n\t * - `account` must have at least `amount` tokens.\r\n\t */\r\n\tfunction _burn(address account, uint256 amount) internal {\r\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n\t\t_balances[account] = _balances[account].sub(\r\n\t\t\tamount,\r\n\t\t\t\"ERC20: burn amount exceeds balance\"\r\n\t\t);\r\n\t\t_totalSupply = _totalSupply.sub(amount);\r\n\t\temit Transfer(account, address(0), amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n\t *\r\n\t * This is internal function is equivalent to `approve`, and can be used to\r\n\t * e.g. set automatic allowances for certain subsystems, etc.\r\n\t *\r\n\t * Emits an {Approval} event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `owner` cannot be the zero address.\r\n\t * - `spender` cannot be the zero address.\r\n\t */\r\n\tfunction _approve(\r\n\t\taddress owner,\r\n\t\taddress spender,\r\n\t\tuint256 amount\r\n\t) internal {\r\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\r\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n\t\t_allowances[owner][spender] = amount;\r\n\t\temit Approval(owner, spender, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n\t * from the caller's allowance.\r\n\t *\r\n\t * See {_burn} and {_approve}.\r\n\t */\r\n\tfunction _burnFrom(address account, uint256 amount) internal {\r\n\t\t_burn(account, amount);\r\n\t\t_approve(\r\n\t\t\taccount,\r\n\t\t\t_msgSender(),\r\n\t\t\t_allowances[account][_msgSender()].sub(\r\n\t\t\t\tamount,\r\n\t\t\t\t\"ERC20: burn amount exceeds allowance\"\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n\tstruct Role {\r\n\t\tmapping(address => bool) bearer;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Give an account access to this role.\r\n\t */\r\n\tfunction add(Role storage role, address account) internal {\r\n\t\trequire(!has(role, account), \"Roles: account already has role\");\r\n\t\trole.bearer[account] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove an account's access to this role.\r\n\t */\r\n\tfunction remove(Role storage role, address account) internal {\r\n\t\trequire(has(role, account), \"Roles: account does not have role\");\r\n\t\trole.bearer[account] = false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if an account has this role.\r\n\t * @return bool\r\n\t */\r\n\tfunction has(Role storage role, address account)\r\n\t\tinternal\r\n\t\tview\r\n\t\treturns (bool)\r\n\t{\r\n\t\trequire(account != address(0), \"Roles: account is the zero address\");\r\n\t\treturn role.bearer[account];\r\n\t}\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/roles/MinterRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract MinterRole is Context {\r\n\tusing Roles for Roles.Role;\r\n\r\n\tevent MinterAdded(address indexed account);\r\n\tevent MinterRemoved(address indexed account);\r\n\r\n\tRoles.Role private _minters;\r\n\r\n\tconstructor() internal {\r\n\t\t_addMinter(_msgSender());\r\n\t}\r\n\r\n\tmodifier onlyMinter() {\r\n\t\trequire(\r\n\t\t\tisMinter(_msgSender()),\r\n\t\t\t\"MinterRole: caller does not have the Minter role\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction isMinter(address account) public view returns (bool) {\r\n\t\treturn _minters.has(account);\r\n\t}\r\n\r\n\tfunction addMinter(address account) public onlyMinter {\r\n\t\t_addMinter(account);\r\n\t}\r\n\r\n\tfunction renounceMinter() public {\r\n\t\t_removeMinter(_msgSender());\r\n\t}\r\n\r\n\tfunction _addMinter(address account) internal {\r\n\t\t_minters.add(account);\r\n\t\temit MinterAdded(account);\r\n\t}\r\n\r\n\tfunction _removeMinter(address account) internal {\r\n\t\t_minters.remove(account);\r\n\t\temit MinterRemoved(account);\r\n\t}\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Mintable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\r\n * which have permission to mint (create) new tokens as they see fit.\r\n *\r\n * At construction, the deployer of the contract is the only minter.\r\n */\r\ncontract ERC20Mintable is ERC20, MinterRole {\r\n\t/**\r\n\t * @dev See {ERC20-_mint}.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the caller must have the {MinterRole}.\r\n\t */\r\n\tfunction mint(address account, uint256 amount)\r\n\t\tpublic\r\n\t\tonlyMinter\r\n\t\treturns (bool)\r\n\t{\r\n\t\t_mint(account, amount);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\ncontract ERC20Burnable is Context, ERC20 {\r\n\t/**\r\n\t * @dev Destroys `amount` tokens from the caller.\r\n\t *\r\n\t * See {ERC20-_burn}.\r\n\t */\r\n\tfunction burn(uint256 amount) public {\r\n\t\t_burn(_msgSender(), amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {ERC20-_burnFrom}.\r\n\t */\r\n\tfunction burnFrom(address account, uint256 amount) public {\r\n\t\t_burnFrom(account, amount);\r\n\t}\r\n}\r\n\r\n// File: contracts/src/common/libs/Decimals.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * Library for emulating calculations involving decimals.\r\n */\r\nlibrary Decimals {\r\n\tusing SafeMath for uint256;\r\n\tuint120 private constant basisValue = 1000000000000000000;\r\n\r\n\t/**\r\n\t * Returns the ratio of the first argument to the second argument.\r\n\t */\r\n\tfunction outOf(uint256 _a, uint256 _b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (uint256 result)\r\n\t{\r\n\t\tif (_a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 a = _a.mul(basisValue);\r\n\t\tif (a < _b) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn (a.div(_b));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns multiplied the number by 10^18.\r\n\t * This is used when there is a very large difference between the two numbers passed to the `outOf` function.\r\n\t */\r\n\tfunction mulBasis(uint256 _a) internal pure returns (uint256) {\r\n\t\treturn _a.mul(basisValue);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns by changing the numerical value being emulated to the original number of digits.\r\n\t */\r\n\tfunction divBasis(uint256 _a) internal pure returns (uint256) {\r\n\t\treturn _a.div(basisValue);\r\n\t}\r\n}\r\n\r\n// File: contracts/src/common/storage/EternalStorage.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * Module for persisting states.\r\n * Stores a map for `uint256`, `string`, `address`, `bytes32`, `bool`, and `int256` type with `bytes32` type as a key.\r\n */\r\ncontract EternalStorage {\r\n\taddress private currentOwner = msg.sender;\r\n\r\n\tmapping(bytes32 => uint256) private uIntStorage;\r\n\tmapping(bytes32 => string) private stringStorage;\r\n\tmapping(bytes32 => address) private addressStorage;\r\n\tmapping(bytes32 => bytes32) private bytesStorage;\r\n\tmapping(bytes32 => bool) private boolStorage;\r\n\tmapping(bytes32 => int256) private intStorage;\r\n\r\n\t/**\r\n\t * Modifiers to validate that only the owner can execute.\r\n\t */\r\n\tmodifier onlyCurrentOwner() {\r\n\t\trequire(msg.sender == currentOwner, \"not current owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer the owner.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction changeOwner(address _newOwner) external {\r\n\t\trequire(msg.sender == currentOwner, \"not current owner\");\r\n\t\tcurrentOwner = _newOwner;\r\n\t}\r\n\r\n\t// *** Getter Methods ***\r\n\r\n\t/**\r\n\t * Returns the value of the `uint256` type that mapped to the given key.\r\n\t */\r\n\tfunction getUint(bytes32 _key) external view returns (uint256) {\r\n\t\treturn uIntStorage[_key];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the value of the `string` type that mapped to the given key.\r\n\t */\r\n\tfunction getString(bytes32 _key) external view returns (string memory) {\r\n\t\treturn stringStorage[_key];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the value of the `address` type that mapped to the given key.\r\n\t */\r\n\tfunction getAddress(bytes32 _key) external view returns (address) {\r\n\t\treturn addressStorage[_key];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the value of the `bytes32` type that mapped to the given key.\r\n\t */\r\n\tfunction getBytes(bytes32 _key) external view returns (bytes32) {\r\n\t\treturn bytesStorage[_key];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the value of the `bool` type that mapped to the given key.\r\n\t */\r\n\tfunction getBool(bytes32 _key) external view returns (bool) {\r\n\t\treturn boolStorage[_key];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the value of the `int256` type that mapped to the given key.\r\n\t */\r\n\tfunction getInt(bytes32 _key) external view returns (int256) {\r\n\t\treturn intStorage[_key];\r\n\t}\r\n\r\n\t// *** Setter Methods ***\r\n\r\n\t/**\r\n\t * Maps a value of `uint256` type to a given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setUint(bytes32 _key, uint256 _value) external onlyCurrentOwner {\r\n\t\tuIntStorage[_key] = _value;\r\n\t}\r\n\r\n\t/**\r\n\t * Maps a value of `string` type to a given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setString(bytes32 _key, string calldata _value)\r\n\t\texternal\r\n\t\tonlyCurrentOwner\r\n\t{\r\n\t\tstringStorage[_key] = _value;\r\n\t}\r\n\r\n\t/**\r\n\t * Maps a value of `address` type to a given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setAddress(bytes32 _key, address _value)\r\n\t\texternal\r\n\t\tonlyCurrentOwner\r\n\t{\r\n\t\taddressStorage[_key] = _value;\r\n\t}\r\n\r\n\t/**\r\n\t * Maps a value of `bytes32` type to a given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setBytes(bytes32 _key, bytes32 _value) external onlyCurrentOwner {\r\n\t\tbytesStorage[_key] = _value;\r\n\t}\r\n\r\n\t/**\r\n\t * Maps a value of `bool` type to a given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setBool(bytes32 _key, bool _value) external onlyCurrentOwner {\r\n\t\tboolStorage[_key] = _value;\r\n\t}\r\n\r\n\t/**\r\n\t * Maps a value of `int256` type to a given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setInt(bytes32 _key, int256 _value) external onlyCurrentOwner {\r\n\t\tintStorage[_key] = _value;\r\n\t}\r\n\r\n\t// *** Delete Methods ***\r\n\r\n\t/**\r\n\t * Deletes the value of the `uint256` type that mapped to the given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction deleteUint(bytes32 _key) external onlyCurrentOwner {\r\n\t\tdelete uIntStorage[_key];\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes the value of the `string` type that mapped to the given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction deleteString(bytes32 _key) external onlyCurrentOwner {\r\n\t\tdelete stringStorage[_key];\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes the value of the `address` type that mapped to the given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction deleteAddress(bytes32 _key) external onlyCurrentOwner {\r\n\t\tdelete addressStorage[_key];\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes the value of the `bytes32` type that mapped to the given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction deleteBytes(bytes32 _key) external onlyCurrentOwner {\r\n\t\tdelete bytesStorage[_key];\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes the value of the `bool` type that mapped to the given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction deleteBool(bytes32 _key) external onlyCurrentOwner {\r\n\t\tdelete boolStorage[_key];\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes the value of the `int256` type that mapped to the given key.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction deleteInt(bytes32 _key) external onlyCurrentOwner {\r\n\t\tdelete intStorage[_key];\r\n\t}\r\n}\r\n\r\n// File: contracts/src/common/storage/UsingStorage.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * Module for contrast handling EternalStorage.\r\n */\r\ncontract UsingStorage is Ownable {\r\n\taddress private _storage;\r\n\r\n\t/**\r\n\t * Modifier to verify that EternalStorage is set.\r\n\t */\r\n\tmodifier hasStorage() {\r\n\t\trequire(_storage != address(0), \"storage is not set\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the set EternalStorage instance.\r\n\t */\r\n\tfunction eternalStorage()\r\n\t\tinternal\r\n\t\tview\r\n\t\thasStorage\r\n\t\treturns (EternalStorage)\r\n\t{\r\n\t\treturn EternalStorage(_storage);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the set EternalStorage address.\r\n\t */\r\n\tfunction getStorageAddress() external view hasStorage returns (address) {\r\n\t\treturn _storage;\r\n\t}\r\n\r\n\t/**\r\n\t * Create a new EternalStorage contract.\r\n\t * This function call will fail if the EternalStorage contract is already set.\r\n\t * Also, only the owner can execute it.\r\n\t */\r\n\tfunction createStorage() external onlyOwner {\r\n\t\trequire(_storage == address(0), \"storage is set\");\r\n\t\tEternalStorage tmp = new EternalStorage();\r\n\t\t_storage = address(tmp);\r\n\t}\r\n\r\n\t/**\r\n\t * Assigns the EternalStorage contract that has already been created.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction setStorage(address _storageAddress) external onlyOwner {\r\n\t\t_storage = _storageAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * Delegates the owner of the current EternalStorage contract.\r\n\t * Only the owner can execute this function.\r\n\t */\r\n\tfunction changeOwner(address newOwner) external onlyOwner {\r\n\t\tEternalStorage(_storage).changeOwner(newOwner);\r\n\t}\r\n}\r\n\r\n// File: contracts/src/lockup/LockupStorage.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract LockupStorage is UsingStorage {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 public constant basis = 100000000000000000000000000000000;\r\n\r\n\t//AllValue\r\n\tfunction setStorageAllValue(uint256 _value) internal {\r\n\t\tbytes32 key = getStorageAllValueKey();\r\n\t\teternalStorage().setUint(key, _value);\r\n\t}\r\n\r\n\tfunction getStorageAllValue() public view returns (uint256) {\r\n\t\tbytes32 key = getStorageAllValueKey();\r\n\t\treturn eternalStorage().getUint(key);\r\n\t}\r\n\r\n\tfunction getStorageAllValueKey() private pure returns (bytes32) {\r\n\t\treturn keccak256(abi.encodePacked(\"_allValue\"));\r\n\t}\r\n\r\n\t//Value\r\n\tfunction setStorageValue(\r\n\t\taddress _property,\r\n\t\taddress _sender,\r\n\t\tuint256 _value\r\n\t) internal {\r\n\t\tbytes32 key = getStorageValueKey(_property, _sender);\r\n\t\teternalStorage().setUint(key, _value);\r\n\t}\r\n\r\n\tfunction getStorageValue(address _property, address _sender)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\tbytes32 key = getStorageValueKey(_property, _sender);\r\n\t\treturn eternalStorage().getUint(key);\r\n\t}\r\n\r\n\tfunction getStorageValueKey(address _property, address _sender)\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(\"_value\", _property, _sender));\r\n\t}\r\n\r\n\t//PropertyValue\r\n\tfunction setStoragePropertyValue(address _property, uint256 _value)\r\n\t\tinternal\r\n\t{\r\n\t\tbytes32 key = getStoragePropertyValueKey(_property);\r\n\t\teternalStorage().setUint(key, _value);\r\n\t}\r\n\r\n\tfunction getStoragePropertyValue(address _property)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\tbytes32 key = getStoragePropertyValueKey(_property);\r\n\t\treturn eternalStorage().getUint(key);\r\n\t}\r\n\r\n\tfunction getStoragePropertyValueKey(address _property)\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(\"_propertyValue\", _property));\r\n\t}\r\n\r\n\t//WithdrawalStatus\r\n\tfunction setStorageWithdrawalStatus(\r\n\t\taddress _property,\r\n\t\taddress _from,\r\n\t\tuint256 _value\r\n\t) internal {\r\n\t\tbytes32 key = getStorageWithdrawalStatusKey(_property, _from);\r\n\t\teternalStorage().setUint(key, _value);\r\n\t}\r\n\r\n\tfunction getStorageWithdrawalStatus(address _property, address _from)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\tbytes32 key = getStorageWithdrawalStatusKey(_property, _from);\r\n\t\treturn eternalStorage().getUint(key);\r\n\t}\r\n\r\n\tfunction getStorageWithdrawalStatusKey(address _property, address _sender)\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn\r\n\t\t\tkeccak256(\r\n\t\t\t\tabi.encodePacked(\"_withdrawalStatus\", _property, _sender)\r\n\t\t\t);\r\n\t}\r\n\r\n\t//InterestPrice\r\n\tfunction setStorageInterestPrice(address _property, uint256 _value)\r\n\t\tinternal\r\n\t{\r\n\t\t// The previously used function\r\n\t\t// This function is only used in testing\r\n\t\teternalStorage().setUint(getStorageInterestPriceKey(_property), _value);\r\n\t}\r\n\r\n\tfunction getStorageInterestPrice(address _property)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn eternalStorage().getUint(getStorageInterestPriceKey(_property));\r\n\t}\r\n\r\n\tfunction getStorageInterestPriceKey(address _property)\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(\"_interestTotals\", _property));\r\n\t}\r\n\r\n\t//LastInterestPrice\r\n\tfunction setStorageLastInterestPrice(\r\n\t\taddress _property,\r\n\t\taddress _user,\r\n\t\tuint256 _value\r\n\t) internal {\r\n\t\teternalStorage().setUint(\r\n\t\t\tgetStorageLastInterestPriceKey(_property, _user),\r\n\t\t\t_value\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getStorageLastInterestPrice(address _property, address _user)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn\r\n\t\t\teternalStorage().getUint(\r\n\t\t\t\tgetStorageLastInterestPriceKey(_property, _user)\r\n\t\t\t);\r\n\t}\r\n\r\n\tfunction getStorageLastInterestPriceKey(address _property, address _user)\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn\r\n\t\t\tkeccak256(\r\n\t\t\t\tabi.encodePacked(\"_lastLastInterestPrice\", _property, _user)\r\n\t\t\t);\r\n\t}\r\n\r\n\t//LastSameRewardsAmountAndBlock\r\n\tfunction setStorageLastSameRewardsAmountAndBlock(\r\n\t\tuint256 _amount,\r\n\t\tuint256 _block\r\n\t) internal {\r\n\t\tuint256 record = _amount.mul(basis).add(_block);\r\n\t\teternalStorage().setUint(\r\n\t\t\tgetStorageLastSameRewardsAmountAndBlockKey(),\r\n\t\t\trecord\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getStorageLastSameRewardsAmountAndBlock()\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 _amount, uint256 _block)\r\n\t{\r\n\t\tuint256 record = eternalStorage().getUint(\r\n\t\t\tgetStorageLastSameRewardsAmountAndBlockKey()\r\n\t\t);\r\n\t\tuint256 amount = record.div(basis);\r\n\t\tuint256 blockNumber = record.sub(amount.mul(basis));\r\n\t\treturn (amount, blockNumber);\r\n\t}\r\n\r\n\tfunction getStorageLastSameRewardsAmountAndBlockKey()\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(\"_LastSameRewardsAmountAndBlock\"));\r\n\t}\r\n\r\n\t//CumulativeGlobalRewards\r\n\tfunction setStorageCumulativeGlobalRewards(uint256 _value) internal {\r\n\t\teternalStorage().setUint(\r\n\t\t\tgetStorageCumulativeGlobalRewardsKey(),\r\n\t\t\t_value\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getStorageCumulativeGlobalRewards() public view returns (uint256) {\r\n\t\treturn eternalStorage().getUint(getStorageCumulativeGlobalRewardsKey());\r\n\t}\r\n\r\n\tfunction getStorageCumulativeGlobalRewardsKey()\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(\"_cumulativeGlobalRewards\"));\r\n\t}\r\n\r\n\t//LastCumulativeGlobalReward\r\n\tfunction setStorageLastCumulativeGlobalReward(\r\n\t\taddress _property,\r\n\t\taddress _user,\r\n\t\tuint256 _value\r\n\t) internal {\r\n\t\teternalStorage().setUint(\r\n\t\t\tgetStorageLastCumulativeGlobalRewardKey(_property, _user),\r\n\t\t\t_value\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getStorageLastCumulativeGlobalReward(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) public view returns (uint256) {\r\n\t\treturn\r\n\t\t\teternalStorage().getUint(\r\n\t\t\t\tgetStorageLastCumulativeGlobalRewardKey(_property, _user)\r\n\t\t\t);\r\n\t}\r\n\r\n\tfunction getStorageLastCumulativeGlobalRewardKey(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) private pure returns (bytes32) {\r\n\t\treturn\r\n\t\t\tkeccak256(\r\n\t\t\t\tabi.encodePacked(\r\n\t\t\t\t\t\"_LastCumulativeGlobalReward\",\r\n\t\t\t\t\t_property,\r\n\t\t\t\t\t_user\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t}\r\n\r\n\t//LastCumulativePropertyInterest\r\n\tfunction setStorageLastCumulativePropertyInterest(\r\n\t\taddress _property,\r\n\t\taddress _user,\r\n\t\tuint256 _value\r\n\t) internal {\r\n\t\teternalStorage().setUint(\r\n\t\t\tgetStorageLastCumulativePropertyInterestKey(_property, _user),\r\n\t\t\t_value\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getStorageLastCumulativePropertyInterest(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) public view returns (uint256) {\r\n\t\treturn\r\n\t\t\teternalStorage().getUint(\r\n\t\t\t\tgetStorageLastCumulativePropertyInterestKey(_property, _user)\r\n\t\t\t);\r\n\t}\r\n\r\n\tfunction getStorageLastCumulativePropertyInterestKey(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) private pure returns (bytes32) {\r\n\t\treturn\r\n\t\t\tkeccak256(\r\n\t\t\t\tabi.encodePacked(\r\n\t\t\t\t\t\"_lastCumulativePropertyInterest\",\r\n\t\t\t\t\t_property,\r\n\t\t\t\t\t_user\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t}\r\n\r\n\t//CumulativeLockedUpUnitAndBlock\r\n\tfunction setStorageCumulativeLockedUpUnitAndBlock(\r\n\t\taddress _addr,\r\n\t\tuint256 _unit,\r\n\t\tuint256 _block\r\n\t) internal {\r\n\t\tuint256 record = _unit.mul(basis).add(_block);\r\n\t\teternalStorage().setUint(\r\n\t\t\tgetStorageCumulativeLockedUpUnitAndBlockKey(_addr),\r\n\t\t\trecord\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getStorageCumulativeLockedUpUnitAndBlock(address _addr)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 _unit, uint256 _block)\r\n\t{\r\n\t\tuint256 record = eternalStorage().getUint(\r\n\t\t\tgetStorageCumulativeLockedUpUnitAndBlockKey(_addr)\r\n\t\t);\r\n\t\tuint256 unit = record.div(basis);\r\n\t\tuint256 blockNumber = record.sub(unit.mul(basis));\r\n\t\treturn (unit, blockNumber);\r\n\t}\r\n\r\n\tfunction getStorageCumulativeLockedUpUnitAndBlockKey(address _addr)\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn\r\n\t\t\tkeccak256(\r\n\t\t\t\tabi.encodePacked(\"_cumulativeLockedUpUnitAndBlock\", _addr)\r\n\t\t\t);\r\n\t}\r\n\r\n\t//CumulativeLockedUpValue\r\n\tfunction setStorageCumulativeLockedUpValue(address _addr, uint256 _value)\r\n\t\tinternal\r\n\t{\r\n\t\teternalStorage().setUint(\r\n\t\t\tgetStorageCumulativeLockedUpValueKey(_addr),\r\n\t\t\t_value\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getStorageCumulativeLockedUpValue(address _addr)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn\r\n\t\t\teternalStorage().getUint(\r\n\t\t\t\tgetStorageCumulativeLockedUpValueKey(_addr)\r\n\t\t\t);\r\n\t}\r\n\r\n\tfunction getStorageCumulativeLockedUpValueKey(address _addr)\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(\"_cumulativeLockedUpValue\", _addr));\r\n\t}\r\n\r\n\t//PendingWithdrawal\r\n\tfunction setStoragePendingInterestWithdrawal(\r\n\t\taddress _property,\r\n\t\taddress _user,\r\n\t\tuint256 _value\r\n\t) internal {\r\n\t\teternalStorage().setUint(\r\n\t\t\tgetStoragePendingInterestWithdrawalKey(_property, _user),\r\n\t\t\t_value\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getStoragePendingInterestWithdrawal(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) public view returns (uint256) {\r\n\t\treturn\r\n\t\t\teternalStorage().getUint(\r\n\t\t\t\tgetStoragePendingInterestWithdrawalKey(_property, _user)\r\n\t\t\t);\r\n\t}\r\n\r\n\tfunction getStoragePendingInterestWithdrawalKey(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) private pure returns (bytes32) {\r\n\t\treturn\r\n\t\t\tkeccak256(\r\n\t\t\t\tabi.encodePacked(\"_pendingInterestWithdrawal\", _property, _user)\r\n\t\t\t);\r\n\t}\r\n\r\n\t//DIP4GenesisBlock\r\n\tfunction setStorageDIP4GenesisBlock(uint256 _block) internal {\r\n\t\teternalStorage().setUint(getStorageDIP4GenesisBlockKey(), _block);\r\n\t}\r\n\r\n\tfunction getStorageDIP4GenesisBlock() public view returns (uint256) {\r\n\t\treturn eternalStorage().getUint(getStorageDIP4GenesisBlockKey());\r\n\t}\r\n\r\n\tfunction getStorageDIP4GenesisBlockKey() private pure returns (bytes32) {\r\n\t\treturn keccak256(abi.encodePacked(\"_dip4GenesisBlock\"));\r\n\t}\r\n\r\n\t//LastCumulativeLockedUpAndBlock\r\n\tfunction setStorageLastCumulativeLockedUpAndBlock(\r\n\t\taddress _property,\r\n\t\taddress _user,\r\n\t\tuint256 _cLocked,\r\n\t\tuint256 _block\r\n\t) internal {\r\n\t\tuint256 record = _cLocked.mul(basis).add(_block);\r\n\t\teternalStorage().setUint(\r\n\t\t\tgetStorageLastCumulativeLockedUpAndBlockKey(_property, _user),\r\n\t\t\trecord\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getStorageLastCumulativeLockedUpAndBlock(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) public view returns (uint256 _cLocked, uint256 _block) {\r\n\t\tuint256 record = eternalStorage().getUint(\r\n\t\t\tgetStorageLastCumulativeLockedUpAndBlockKey(_property, _user)\r\n\t\t);\r\n\t\tuint256 cLocked = record.div(basis);\r\n\t\tuint256 blockNumber = record.sub(cLocked.mul(basis));\r\n\r\n\t\treturn (cLocked, blockNumber);\r\n\t}\r\n\r\n\tfunction getStorageLastCumulativeLockedUpAndBlockKey(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) private pure returns (bytes32) {\r\n\t\treturn\r\n\t\t\tkeccak256(\r\n\t\t\t\tabi.encodePacked(\r\n\t\t\t\t\t\"_lastCumulativeLockedUpAndBlock\",\r\n\t\t\t\t\t_property,\r\n\t\t\t\t\t_user\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t}\r\n}\r\n\r\n// File: contracts/src/allocator/IAllocator.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IAllocator {\r\n\tfunction calculateMaxRewardsPerBlock() public view returns (uint256);\r\n\r\n\tfunction beforeBalanceChange(\r\n\t\taddress _property,\r\n\t\taddress _from,\r\n\t\taddress _to\r\n\t\t// solium-disable-next-line indentation\r\n\t) external;\r\n}\r\n\r\n// File: contracts/src/lockup/Lockup.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// prettier-ignore\r\n\r\n/**\r\n * A contract that manages the staking of DEV tokens and calculates rewards.\r\n * Staking and the following mechanism determines that reward calculation.\r\n *\r\n * Variables:\r\n * -`M`: Maximum mint amount per block determined by Allocator contract\r\n * -`B`: Number of blocks during staking\r\n * -`P`: Total number of staking locked up in a Property contract\r\n * -`S`: Total number of staking locked up in all Property contracts\r\n * -`U`: Number of staking per account locked up in a Property contract\r\n *\r\n * Formula:\r\n * Staking Rewards = M * B * (P / S) * (U / P)\r\n *\r\n * Note:\r\n * -`M`, `P` and `S` vary from block to block, and the variation cannot be predicted.\r\n * -`B` is added every time the Ethereum block is created.\r\n * - Only `U` and `B` are predictable variables.\r\n * - As `M`, `P` and `S` cannot be observed from a staker, the \"cumulative sum\" is often used to calculate ratio variation with history.\r\n * - Reward withdrawal always withdraws the total withdrawable amount.\r\n *\r\n * Scenario:\r\n * - Assume `M` is fixed at 500\r\n * - Alice stakes 100 DEV on Property-A (Alice's staking state on Property-A: `M`=500, `B`=0, `P`=100, `S`=100, `U`=100)\r\n * - After 10 blocks, Bob stakes 60 DEV on Property-B (Alice's staking state on Property-A: `M`=500, `B`=10, `P`=100, `S`=160, `U`=100)\r\n * - After 10 blocks, Carol stakes 40 DEV on Property-A (Alice's staking state on Property-A: `M`=500, `B`=20, `P`=140, `S`=200, `U`=100)\r\n * - After 10 blocks, Alice withdraws Property-A staking reward. The reward at this time is 5000 DEV (10 blocks * 500 DEV) + 3125 DEV (10 blocks * 62.5% * 500 DEV) + 2500 DEV (10 blocks * 50% * 500 DEV).\r\n */\r\ncontract Lockup is ILockup, UsingConfig, UsingValidator, LockupStorage {\r\n\tusing SafeMath for uint256;\r\n\tusing Decimals for uint256;\r\n\tevent Lockedup(address _from, address _property, uint256 _value);\r\n\r\n\t/**\r\n\t * Initialize the passed address as AddressConfig address.\r\n\t */\r\n\t// solium-disable-next-line no-empty-blocks\r\n\tconstructor(address _config) public UsingConfig(_config) {}\r\n\r\n\t/**\r\n\t * Adds staking.\r\n\t * Only the Dev contract can execute this function.\r\n\t */\r\n\tfunction lockup(\r\n\t\taddress _from,\r\n\t\taddress _property,\r\n\t\tuint256 _value\r\n\t) external {\r\n\t\t/**\r\n\t\t * Validates the sender is Dev contract.\r\n\t\t */\r\n\t\taddressValidator().validateAddress(msg.sender, config().token());\r\n\r\n\t\t/**\r\n\t\t * Validates the target of staking is included Property set.\r\n\t\t */\r\n\t\taddressValidator().validateGroup(_property, config().propertyGroup());\r\n\t\trequire(_value != 0, \"illegal lockup value\");\r\n\r\n\t\t/**\r\n\t\t * Validates the passed Property has greater than 1 asset.\r\n\t\t */\r\n\t\trequire(\r\n\t\t\tIMetricsGroup(config().metricsGroup()).hasAssets(_property),\r\n\t\t\t\"unable to stake to unauthenticated property\"\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Refuses new staking when after cancel staking and until release it.\r\n\t\t */\r\n\t\tbool isWaiting = getStorageWithdrawalStatus(_property, _from) != 0;\r\n\t\trequire(isWaiting == false, \"lockup is already canceled\");\r\n\r\n\t\t/**\r\n\t\t * Since the reward per block that can be withdrawn will change with the addition of staking,\r\n\t\t * saves the undrawn withdrawable reward before addition it.\r\n\t\t */\r\n\t\tupdatePendingInterestWithdrawal(_property, _from);\r\n\r\n\t\t/**\r\n\t\t * Saves the variables at the time of staking to prepare for reward calculation.\r\n\t\t */\r\n\t\t(, , , uint256 interest, ) = difference(_property, 0);\r\n\t\tupdateStatesAtLockup(_property, _from, interest);\r\n\r\n\t\t/**\r\n\t\t * Saves variables that should change due to the addition of staking.\r\n\t\t */\r\n\t\tupdateValues(true, _from, _property, _value);\r\n\t\temit Lockedup(_from, _property, _value);\r\n\t}\r\n\r\n\t/**\r\n\t * Cancel staking.\r\n\t * The staking amount can be withdrawn after the blocks specified by `Policy.lockUpBlocks` have passed.\r\n\t */\r\n\tfunction cancel(address _property) external {\r\n\t\t/**\r\n\t\t * Validates the target of staked is included Property set.\r\n\t\t */\r\n\t\taddressValidator().validateGroup(_property, config().propertyGroup());\r\n\r\n\t\t/**\r\n\t\t * Validates the sender is staking to the target Property.\r\n\t\t */\r\n\t\trequire(hasValue(_property, msg.sender), \"dev token is not locked\");\r\n\r\n\t\t/**\r\n\t\t * Validates not already been canceled.\r\n\t\t */\r\n\t\tbool isWaiting = getStorageWithdrawalStatus(_property, msg.sender) != 0;\r\n\t\trequire(isWaiting == false, \"lockup is already canceled\");\r\n\r\n\t\t/**\r\n\t\t * Get `Policy.lockUpBlocks`, add it to the current block number, and saves that block number in `WithdrawalStatus`.\r\n\t\t * Staking is cannot release until the block number saved in `WithdrawalStatus` is reached.\r\n\t\t */\r\n\t\tuint256 blockNumber = IPolicy(config().policy()).lockUpBlocks();\r\n\t\tblockNumber = blockNumber.add(block.number);\r\n\t\tsetStorageWithdrawalStatus(_property, msg.sender, blockNumber);\r\n\t}\r\n\r\n\t/**\r\n\t * Withdraw staking.\r\n\t * Releases canceled staking and transfer the staked amount to the sender.\r\n\t */\r\n\tfunction withdraw(address _property) external {\r\n\t\t/**\r\n\t\t * Validates the target of staked is included Property set.\r\n\t\t */\r\n\t\taddressValidator().validateGroup(_property, config().propertyGroup());\r\n\r\n\t\t/**\r\n\t\t * Validates the block number reaches the block number where staking can be released.\r\n\t\t */\r\n\t\trequire(possible(_property, msg.sender), \"waiting for release\");\r\n\r\n\t\t/**\r\n\t\t * Validates the sender is staking to the target Property.\r\n\t\t */\r\n\t\tuint256 lockedUpValue = getStorageValue(_property, msg.sender);\r\n\t\trequire(lockedUpValue != 0, \"dev token is not locked\");\r\n\r\n\t\t/**\r\n\t\t * Since the increase of rewards will stop with the release of the staking,\r\n\t\t * saves the undrawn withdrawable reward before releasing it.\r\n\t\t */\r\n\t\tupdatePendingInterestWithdrawal(_property, msg.sender);\r\n\r\n\t\t/**\r\n\t\t * Transfer the staked amount to the sender.\r\n\t\t */\r\n\t\tIProperty(_property).withdraw(msg.sender, lockedUpValue);\r\n\r\n\t\t/**\r\n\t\t * Saves variables that should change due to the canceling staking..\r\n\t\t */\r\n\t\tupdateValues(false, msg.sender, _property, lockedUpValue);\r\n\r\n\t\t/**\r\n\t\t * Sets the staked amount to 0.\r\n\t\t */\r\n\t\tsetStorageValue(_property, msg.sender, 0);\r\n\r\n\t\t/**\r\n\t\t * Sets the cancellation status to not have.\r\n\t\t */\r\n\t\tsetStorageWithdrawalStatus(_property, msg.sender, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the current staking amount, and the block number in which the recorded last.\r\n\t * These values are used to calculate the cumulative sum of the staking.\r\n\t */\r\n\tfunction getCumulativeLockedUpUnitAndBlock(address _property)\r\n\t\tprivate\r\n\t\tview\r\n\t\treturns (uint256 _unit, uint256 _block)\r\n\t{\r\n\t\t/**\r\n\t\t * Get the current staking amount and the last recorded block number from the `CumulativeLockedUpUnitAndBlock` storage.\r\n\t\t * If the last recorded block number is not 0, it is returns as it is.\r\n\t\t */\r\n\t\t(\r\n\t\t\tuint256 unit,\r\n\t\t\tuint256 lastBlock\r\n\t\t) = getStorageCumulativeLockedUpUnitAndBlock(_property);\r\n\t\tif (lastBlock > 0) {\r\n\t\t\treturn (unit, lastBlock);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * If the last recorded block number is 0, this function falls back as already staked before the current specs (before DIP4).\r\n\t\t * More detail for DIP4: https://github.com/dev-protocol/DIPs/issues/4\r\n\t\t *\r\n\t\t * When the passed address is 0, the caller wants to know the total staking amount on the protocol,\r\n\t\t * so gets the total staking amount from `AllValue` storage.\r\n\t\t * When the address is other than 0, the caller wants to know the staking amount of a Property,\r\n\t\t * so gets the staking amount from the `PropertyValue` storage.\r\n\t\t */\r\n\t\tunit = _property == address(0)\r\n\t\t\t? getStorageAllValue()\r\n\t\t\t: getStoragePropertyValue(_property);\r\n\r\n\t\t/**\r\n\t\t * Staking pre-DIP4 will be treated as staked simultaneously with the DIP4 release.\r\n\t\t * Therefore, the last recorded block number is the same as the DIP4 release block.\r\n\t\t */\r\n\t\tlastBlock = getStorageDIP4GenesisBlock();\r\n\t\treturn (unit, lastBlock);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the cumulative sum of the staking on passed address, the current staking amount,\r\n\t * and the block number in which the recorded last.\r\n\t * The latest cumulative sum can be calculated using the following formula:\r\n\t * (current staking amount) * (current block number - last recorded block number) + (last cumulative sum)\r\n\t */\r\n\tfunction getCumulativeLockedUp(address _property)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256 _value,\r\n\t\t\tuint256 _unit,\r\n\t\t\tuint256 _block\r\n\t\t)\r\n\t{\r\n\t\t/**\r\n\t\t * Gets the current staking amount and the last recorded block number from the `getCumulativeLockedUpUnitAndBlock` function.\r\n\t\t */\r\n\t\t(uint256 unit, uint256 lastBlock) = getCumulativeLockedUpUnitAndBlock(\r\n\t\t\t_property\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Gets the last cumulative sum of the staking from `CumulativeLockedUpValue` storage.\r\n\t\t */\r\n\t\tuint256 lastValue = getStorageCumulativeLockedUpValue(_property);\r\n\r\n\t\t/**\r\n\t\t * Returns the latest cumulative sum, current staking amount as a unit, and last recorded block number.\r\n\t\t */\r\n\t\treturn (\r\n\t\t\tlastValue.add(unit.mul(block.number.sub(lastBlock))),\r\n\t\t\tunit,\r\n\t\t\tlastBlock\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the cumulative sum of the staking on the protocol totally, the current staking amount,\r\n\t * and the block number in which the recorded last.\r\n\t */\r\n\tfunction getCumulativeLockedUpAll()\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256 _value,\r\n\t\t\tuint256 _unit,\r\n\t\t\tuint256 _block\r\n\t\t)\r\n\t{\r\n\t\t/**\r\n\t\t * If the 0 address is passed as a key, it indicates the entire protocol.\r\n\t\t */\r\n\t\treturn getCumulativeLockedUp(address(0));\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the `CumulativeLockedUpValue` and `CumulativeLockedUpUnitAndBlock` storage.\r\n\t * This function expected to executes when the amount of staking as a unit changes.\r\n\t */\r\n\tfunction updateCumulativeLockedUp(\r\n\t\tbool _addition,\r\n\t\taddress _property,\r\n\t\tuint256 _unit\r\n\t) private {\r\n\t\taddress zero = address(0);\r\n\r\n\t\t/**\r\n\t\t * Gets the cumulative sum of the staking amount, staking amount, and last recorded block number for the passed Property address.\r\n\t\t */\r\n\t\t(uint256 lastValue, uint256 lastUnit, ) = getCumulativeLockedUp(\r\n\t\t\t_property\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Gets the cumulative sum of the staking amount, staking amount, and last recorded block number for the protocol total.\r\n\t\t */\r\n\t\t(uint256 lastValueAll, uint256 lastUnitAll, ) = getCumulativeLockedUp(\r\n\t\t\tzero\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Adds or subtracts the staking amount as a new unit to the cumulative sum of the staking for the passed Property address.\r\n\t\t */\r\n\t\tsetStorageCumulativeLockedUpValue(\r\n\t\t\t_property,\r\n\t\t\t_addition ? lastValue.add(_unit) : lastValue.sub(_unit)\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Adds or subtracts the staking amount as a new unit to the cumulative sum of the staking for the protocol total.\r\n\t\t */\r\n\t\tsetStorageCumulativeLockedUpValue(\r\n\t\t\tzero,\r\n\t\t\t_addition ? lastValueAll.add(_unit) : lastValueAll.sub(_unit)\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Adds or subtracts the staking amount to the staking unit for the passed Property address.\r\n\t\t * Also, record the latest block number.\r\n\t\t */\r\n\t\tsetStorageCumulativeLockedUpUnitAndBlock(\r\n\t\t\t_property,\r\n\t\t\t_addition ? lastUnit.add(_unit) : lastUnit.sub(_unit),\r\n\t\t\tblock.number\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Adds or subtracts the staking amount to the staking unit for the protocol total.\r\n\t\t * Also, record the latest block number.\r\n\t\t */\r\n\t\tsetStorageCumulativeLockedUpUnitAndBlock(\r\n\t\t\tzero,\r\n\t\t\t_addition ? lastUnitAll.add(_unit) : lastUnitAll.sub(_unit),\r\n\t\t\tblock.number\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Updates cumulative sum of the maximum mint amount calculated by Allocator contract, the latest maximum mint amount per block,\r\n\t * and the last recorded block number.\r\n\t * The cumulative sum of the maximum mint amount is always added.\r\n\t * By recording that value when the staker last stakes, the difference from the when the staker stakes can be calculated.\r\n\t */\r\n\tfunction update() public {\r\n\t\t/**\r\n\t\t * Gets the cumulative sum of the maximum mint amount and the maximum mint number per block.\r\n\t\t */\r\n\t\t(uint256 _nextRewards, uint256 _amount) = dry();\r\n\r\n\t\t/**\r\n\t\t * Records each value and the latest block number.\r\n\t\t */\r\n\t\tsetStorageCumulativeGlobalRewards(_nextRewards);\r\n\t\tsetStorageLastSameRewardsAmountAndBlock(_amount, block.number);\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the cumulative sum of the maximum mint amount when staking, the cumulative sum of staker reward as an interest of the target Property\r\n\t * and the cumulative staking amount, and the latest block number.\r\n\t */\r\n\tfunction updateStatesAtLockup(\r\n\t\taddress _property,\r\n\t\taddress _user,\r\n\t\tuint256 _interest\r\n\t) private {\r\n\t\t/**\r\n\t\t * Gets the cumulative sum of the maximum mint amount.\r\n\t\t */\r\n\t\t(uint256 _reward, ) = dry();\r\n\r\n\t\t/**\r\n\t\t * Records each value and the latest block number.\r\n\t\t */\r\n\t\tif (isSingle(_property, _user)) {\r\n\t\t\tsetStorageLastCumulativeGlobalReward(_property, _user, _reward);\r\n\t\t}\r\n\t\tsetStorageLastCumulativePropertyInterest(_property, _user, _interest);\r\n\t\t(uint256 cLocked, , ) = getCumulativeLockedUp(_property);\r\n\t\tsetStorageLastCumulativeLockedUpAndBlock(\r\n\t\t\t_property,\r\n\t\t\t_user,\r\n\t\t\tcLocked,\r\n\t\t\tblock.number\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the last cumulative staking amount of the passed Property address and the last recorded block number.\r\n\t */\r\n\tfunction getLastCumulativeLockedUpAndBlock(address _property, address _user)\r\n\t\tprivate\r\n\t\tview\r\n\t\treturns (uint256 _cLocked, uint256 _block)\r\n\t{\r\n\t\t/**\r\n\t\t * Gets the values from `LastCumulativeLockedUpAndBlock` storage.\r\n\t\t */\r\n\t\t(\r\n\t\t\tuint256 cLocked,\r\n\t\t\tuint256 blockNumber\r\n\t\t) = getStorageLastCumulativeLockedUpAndBlock(_property, _user);\r\n\r\n\t\t/**\r\n\t\t * When the last recorded block number is 0, the block number at the time of the DIP4 release is returned as being staked at the same time as the DIP4 release.\r\n\t\t * More detail for DIP4: https://github.com/dev-protocol/DIPs/issues/4\r\n\t\t */\r\n\t\tif (blockNumber == 0) {\r\n\t\t\tblockNumber = getStorageDIP4GenesisBlock();\r\n\t\t}\r\n\t\treturn (cLocked, blockNumber);\r\n\t}\r\n\r\n\t/**\r\n\t * Referring to the values recorded in each storage to returns the latest cumulative sum of the maximum mint amount and the latest maximum mint amount per block.\r\n\t */\r\n\tfunction dry()\r\n\t\tprivate\r\n\t\tview\r\n\t\treturns (uint256 _nextRewards, uint256 _amount)\r\n\t{\r\n\t\t/**\r\n\t\t * Gets the latest mint amount per block from Allocator contract.\r\n\t\t */\r\n\t\tuint256 rewardsAmount = IAllocator(config().allocator())\r\n\t\t\t.calculateMaxRewardsPerBlock();\r\n\r\n\t\t/**\r\n\t\t * Gets the maximum mint amount per block, and the last recorded block number from `LastSameRewardsAmountAndBlock` storage.\r\n\t\t */\r\n\t\t(\r\n\t\t\tuint256 lastAmount,\r\n\t\t\tuint256 lastBlock\r\n\t\t) = getStorageLastSameRewardsAmountAndBlock();\r\n\r\n\t\t/**\r\n\t\t * If the recorded maximum mint amount per block and the result of the Allocator contract are different,\r\n\t\t * the result of the Allocator contract takes precedence as a maximum mint amount per block.\r\n\t\t */\r\n\t\tuint256 lastMaxRewards = lastAmount == rewardsAmount\r\n\t\t\t? rewardsAmount\r\n\t\t\t: lastAmount;\r\n\r\n\t\t/**\r\n\t\t * Calculates the difference between the latest block number and the last recorded block number.\r\n\t\t */\r\n\t\tuint256 blocks = lastBlock > 0 ? block.number.sub(lastBlock) : 0;\r\n\r\n\t\t/**\r\n\t\t * Adds the calculated new cumulative maximum mint amount to the recorded cumulative maximum mint amount.\r\n\t\t */\r\n\t\tuint256 additionalRewards = lastMaxRewards.mul(blocks);\r\n\t\tuint256 nextRewards = getStorageCumulativeGlobalRewards().add(\r\n\t\t\tadditionalRewards\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Returns the latest theoretical cumulative sum of maximum mint amount and maximum mint amount per block.\r\n\t\t */\r\n\t\treturn (nextRewards, rewardsAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the latest theoretical cumulative sum of maximum mint amount, the holder's reward of the passed Property address and its unit price,\r\n\t * and the staker's reward as interest and its unit price.\r\n\t * The latest theoretical cumulative sum of maximum mint amount is got from `dry` function.\r\n\t * The Holder's reward is a staking(delegation) reward received by the holder of the Property contract(token) according to the share.\r\n\t * The unit price of the holder's reward is the reward obtained per 1 piece of Property contract(token).\r\n\t * The staker rewards are rewards for staking users.\r\n\t * The unit price of the staker reward is the reward per DEV token 1 piece that is staking.\r\n\t */\r\n\tfunction difference(address _property, uint256 _lastReward)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256 _reward,\r\n\t\t\tuint256 _holdersAmount,\r\n\t\t\tuint256 _holdersPrice,\r\n\t\t\tuint256 _interestAmount,\r\n\t\t\tuint256 _interestPrice\r\n\t\t)\r\n\t{\r\n\t\t/**\r\n\t\t * Gets the cumulative sum of the maximum mint amount.\r\n\t\t */\r\n\t\t(uint256 rewards, ) = dry();\r\n\r\n\t\t/**\r\n\t\t * Gets the cumulative sum of the staking amount of the passed Property address and\r\n\t\t * the cumulative sum of the staking amount of the protocol total.\r\n\t\t */\r\n\t\t(uint256 valuePerProperty, , ) = getCumulativeLockedUp(_property);\r\n\t\t(uint256 valueAll, , ) = getCumulativeLockedUpAll();\r\n\r\n\t\t/**\r\n\t\t * Calculates the amount of reward that can be received by the Property from the ratio of the cumulative sum of the staking amount of the Property address\r\n\t\t * and the cumulative sum of the staking amount of the protocol total.\r\n\t\t * If the past cumulative sum of the maximum mint amount passed as the second argument is 1 or more,\r\n\t\t * this result is the difference from that cumulative sum.\r\n\t\t */\r\n\t\tuint256 propertyRewards = rewards.sub(_lastReward).mul(\r\n\t\t\tvaluePerProperty.mulBasis().outOf(valueAll)\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Gets the staking amount and total supply of the Property and calls `Policy.holdersShare` function to calculates\r\n\t\t * the holder's reward amount out of the total reward amount.\r\n\t\t */\r\n\t\tuint256 lockedUpPerProperty = getStoragePropertyValue(_property);\r\n\t\tuint256 totalSupply = ERC20Mintable(_property).totalSupply();\r\n\t\tuint256 holders = IPolicy(config().policy()).holdersShare(\r\n\t\t\tpropertyRewards,\r\n\t\t\tlockedUpPerProperty\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * The total rewards amount minus the holder reward amount is the staker rewards as an interest.\r\n\t\t */\r\n\t\tuint256 interest = propertyRewards.sub(holders);\r\n\r\n\t\t/**\r\n\t\t * Returns each value and a unit price of each reward.\r\n\t\t */\r\n\t\treturn (\r\n\t\t\trewards,\r\n\t\t\tholders,\r\n\t\t\tholders.div(totalSupply),\r\n\t\t\tinterest,\r\n\t\t\tlockedUpPerProperty > 0 ? interest.div(lockedUpPerProperty) : 0\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the staker reward as interest.\r\n\t */\r\n\tfunction _calculateInterestAmount(address _property, address _user)\r\n\t\tprivate\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\t/**\r\n\t\t * Gets the cumulative sum of the staking amount, current staking amount, and last recorded block number of the Property.\r\n\t\t */\r\n\t\t(\r\n\t\t\tuint256 cLockProperty,\r\n\t\t\tuint256 unit,\r\n\t\t\tuint256 lastBlock\r\n\t\t) = getCumulativeLockedUp(_property);\r\n\r\n\t\t/**\r\n\t\t * Gets the cumulative sum of staking amount and block number of Property when the user staked.\r\n\t\t */\r\n\t\t(\r\n\t\t\tuint256 lastCLocked,\r\n\t\t\tuint256 lastBlockUser\r\n\t\t) = getLastCumulativeLockedUpAndBlock(_property, _user);\r\n\r\n\t\t/**\r\n\t\t * Get the amount the user is staking for the Property.\r\n\t\t */\r\n\t\tuint256 lockedUpPerAccount = getStorageValue(_property, _user);\r\n\r\n\t\t/**\r\n\t\t * Gets the cumulative sum of the Property's staker reward when the user staked.\r\n\t\t */\r\n\t\tuint256 lastInterest = getStorageLastCumulativePropertyInterest(\r\n\t\t\t_property,\r\n\t\t\t_user\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Calculates the cumulative sum of the staking amount from the time the user staked to the present.\r\n\t\t * It can be calculated by multiplying the staking amount by the number of elapsed blocks.\r\n\t\t */\r\n\t\tuint256 cLockUser = lockedUpPerAccount.mul(\r\n\t\t\tblock.number.sub(lastBlockUser)\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Determines if the user is the only staker to the Property.\r\n\t\t */\r\n\t\tbool isOnly = unit == lockedUpPerAccount && lastBlock <= lastBlockUser;\r\n\r\n\t\t/**\r\n\t\t * If the user is the Property's only staker and the first staker, and the only staker on the protocol:\r\n\t\t */\r\n\t\tif (isSingle(_property, _user)) {\r\n\t\t\t/**\r\n\t\t\t * Passing the cumulative sum of the maximum mint amount when staked, to the `difference` function,\r\n\t\t\t * gets the staker reward amount that the user can receive from the time of staking to the present.\r\n\t\t\t * In the case of the staking is single, the ratio of the Property and the user account for 100% of the cumulative sum of the maximum mint amount,\r\n\t\t\t * so the difference cannot be calculated with the value of `LastCumulativePropertyInterest`.\r\n\t\t\t * Therefore, it is necessary to calculate the difference using the cumulative sum of the maximum mint amounts at the time of staked.\r\n\t\t\t */\r\n\t\t\t(, , , , uint256 interestPrice) = difference(\r\n\t\t\t\t_property,\r\n\t\t\t\tgetStorageLastCumulativeGlobalReward(_property, _user)\r\n\t\t\t);\r\n\r\n\t\t\t/**\r\n\t\t\t * Returns the result after adjusted decimals to 10^18.\r\n\t\t\t */\r\n\t\t\tuint256 result = interestPrice\r\n\t\t\t\t.mul(lockedUpPerAccount)\r\n\t\t\t\t.divBasis()\r\n\t\t\t\t.divBasis();\r\n\t\t\treturn result;\r\n\r\n\t\t\t/**\r\n\t\t\t * If not the single but the only staker:\r\n\t\t\t */\r\n\t\t} else if (isOnly) {\r\n\t\t\t/**\r\n\t\t\t * Pass 0 to the `difference` function to gets the Property's cumulative sum of the staker reward.\r\n\t\t\t */\r\n\t\t\t(, , , uint256 interest, ) = difference(_property, 0);\r\n\r\n\t\t\t/**\r\n\t\t\t * Calculates the difference in rewards that can be received by subtracting the Property's cumulative sum of staker rewards at the time of staking.\r\n\t\t\t */\r\n\t\t\tuint256 result = interest >= lastInterest\r\n\t\t\t\t? interest.sub(lastInterest).divBasis().divBasis()\r\n\t\t\t\t: 0;\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * If the user is the Property's not the first staker and not the only staker:\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Pass 0 to the `difference` function to gets the Property's cumulative sum of the staker reward.\r\n\t\t */\r\n\t\t(, , , uint256 interest, ) = difference(_property, 0);\r\n\r\n\t\t/**\r\n\t\t * Calculates the share of rewards that can be received by the user among Property's staker rewards.\r\n\t\t * \"Cumulative sum of the staking amount of the Property at the time of staking\" is subtracted from \"cumulative sum of the staking amount of the Property\",\r\n\t\t * and calculates the cumulative sum of staking amounts from the time of staking to the present.\r\n\t\t * The ratio of the \"cumulative sum of staking amount from the time the user staked to the present\" to that value is the share.\r\n\t\t */\r\n\t\tuint256 share = cLockUser.outOf(cLockProperty.sub(lastCLocked));\r\n\r\n\t\t/**\r\n\t\t * If the Property's staker reward is greater than the value of the `CumulativePropertyInterest` storage,\r\n\t\t * calculates the difference and multiply by the share.\r\n\t\t * Otherwise, it returns 0.\r\n\t\t */\r\n\t\tuint256 result = interest >= lastInterest\r\n\t\t\t? interest\r\n\t\t\t\t.sub(lastInterest)\r\n\t\t\t\t.mul(share)\r\n\t\t\t\t.divBasis()\r\n\t\t\t\t.divBasis()\r\n\t\t\t\t.divBasis()\r\n\t\t\t: 0;\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the total rewards currently available for withdrawal. (For calling from inside the contract)\r\n\t */\r\n\tfunction _calculateWithdrawableInterestAmount(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) private view returns (uint256) {\r\n\t\t/**\r\n\t\t * If the passed Property has not authenticated, returns always 0.\r\n\t\t */\r\n\t\tif (\r\n\t\t\tIMetricsGroup(config().metricsGroup()).hasAssets(_property) == false\r\n\t\t) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Gets the reward amount in saved without withdrawal.\r\n\t\t */\r\n\t\tuint256 pending = getStoragePendingInterestWithdrawal(_property, _user);\r\n\r\n\t\t/**\r\n\t\t * Gets the reward amount of before DIP4.\r\n\t\t */\r\n\t\tuint256 legacy = __legacyWithdrawableInterestAmount(_property, _user);\r\n\r\n\t\t/**\r\n\t\t * Gets the latest withdrawal reward amount.\r\n\t\t */\r\n\t\tuint256 amount = _calculateInterestAmount(_property, _user);\r\n\r\n\t\t/**\r\n\t\t * Returns the sum of all values.\r\n\t\t */\r\n\t\tuint256 withdrawableAmount = amount\r\n\t\t\t.add(pending) // solium-disable-next-line indentation\r\n\t\t\t.add(legacy);\r\n\t\treturn withdrawableAmount;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the total rewards currently available for withdrawal. (For calling from external of the contract)\r\n\t */\r\n\tfunction calculateWithdrawableInterestAmount(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) public view returns (uint256) {\r\n\t\tuint256 amount = _calculateWithdrawableInterestAmount(_property, _user);\r\n\t\treturn amount;\r\n\t}\r\n\r\n\t/**\r\n\t * Withdraws staking reward as an interest.\r\n\t */\r\n\tfunction withdrawInterest(address _property) external {\r\n\t\t/**\r\n\t\t * Validates the target of staking is included Property set.\r\n\t\t */\r\n\t\taddressValidator().validateGroup(_property, config().propertyGroup());\r\n\r\n\t\t/**\r\n\t\t * Gets the withdrawable amount.\r\n\t\t */\r\n\t\tuint256 value = _calculateWithdrawableInterestAmount(\r\n\t\t\t_property,\r\n\t\t\tmsg.sender\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Gets the cumulative sum of staker rewards of the passed Property address.\r\n\t\t */\r\n\t\t(, , , uint256 interest, ) = difference(_property, 0);\r\n\r\n\t\t/**\r\n\t\t * Validates rewards amount there are 1 or more.\r\n\t\t */\r\n\t\trequire(value > 0, \"your interest amount is 0\");\r\n\r\n\t\t/**\r\n\t\t * Sets the unwithdrawn reward amount to 0.\r\n\t\t */\r\n\t\tsetStoragePendingInterestWithdrawal(_property, msg.sender, 0);\r\n\r\n\t\t/**\r\n\t\t * Creates a Dev token instance.\r\n\t\t */\r\n\t\tERC20Mintable erc20 = ERC20Mintable(config().token());\r\n\r\n\t\t/**\r\n\t\t * Updates the staking status to avoid double rewards.\r\n\t\t */\r\n\t\tupdateStatesAtLockup(_property, msg.sender, interest);\r\n\t\t__updateLegacyWithdrawableInterestAmount(_property, msg.sender);\r\n\r\n\t\t/**\r\n\t\t * Mints the reward.\r\n\t\t */\r\n\t\trequire(erc20.mint(msg.sender, value), \"dev mint failed\");\r\n\r\n\t\t/**\r\n\t\t * Since the total supply of tokens has changed, updates the latest maximum mint amount.\r\n\t\t */\r\n\t\tupdate();\r\n\t}\r\n\r\n\t/**\r\n\t * Status updates with the addition or release of staking.\r\n\t */\r\n\tfunction updateValues(\r\n\t\tbool _addition,\r\n\t\taddress _account,\r\n\t\taddress _property,\r\n\t\tuint256 _value\r\n\t) private {\r\n\t\t/**\r\n\t\t * If added staking:\r\n\t\t */\r\n\t\tif (_addition) {\r\n\t\t\t/**\r\n\t\t\t * Updates the cumulative sum of the staking amount of the passed Property and the cumulative amount of the staking amount of the protocol total.\r\n\t\t\t */\r\n\t\t\tupdateCumulativeLockedUp(true, _property, _value);\r\n\r\n\t\t\t/**\r\n\t\t\t * Updates the current staking amount of the protocol total.\r\n\t\t\t */\r\n\t\t\taddAllValue(_value);\r\n\r\n\t\t\t/**\r\n\t\t\t * Updates the current staking amount of the Property.\r\n\t\t\t */\r\n\t\t\taddPropertyValue(_property, _value);\r\n\r\n\t\t\t/**\r\n\t\t\t * Updates the user's current staking amount in the Property.\r\n\t\t\t */\r\n\t\t\taddValue(_property, _account, _value);\r\n\r\n\t\t\t/**\r\n\t\t\t * If released staking:\r\n\t\t\t */\r\n\t\t} else {\r\n\t\t\t/**\r\n\t\t\t * Updates the cumulative sum of the staking amount of the passed Property and the cumulative amount of the staking amount of the protocol total.\r\n\t\t\t */\r\n\t\t\tupdateCumulativeLockedUp(false, _property, _value);\r\n\r\n\t\t\t/**\r\n\t\t\t * Updates the current staking amount of the protocol total.\r\n\t\t\t */\r\n\t\t\tsubAllValue(_value);\r\n\r\n\t\t\t/**\r\n\t\t\t * Updates the current staking amount of the Property.\r\n\t\t\t */\r\n\t\t\tsubPropertyValue(_property, _value);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Since each staking amount has changed, updates the latest maximum mint amount.\r\n\t\t */\r\n\t\tupdate();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the staking amount of the protocol total.\r\n\t */\r\n\tfunction getAllValue() external view returns (uint256) {\r\n\t\treturn getStorageAllValue();\r\n\t}\r\n\r\n\t/**\r\n\t * Adds the staking amount of the protocol total.\r\n\t */\r\n\tfunction addAllValue(uint256 _value) private {\r\n\t\tuint256 value = getStorageAllValue();\r\n\t\tvalue = value.add(_value);\r\n\t\tsetStorageAllValue(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Subtracts the staking amount of the protocol total.\r\n\t */\r\n\tfunction subAllValue(uint256 _value) private {\r\n\t\tuint256 value = getStorageAllValue();\r\n\t\tvalue = value.sub(_value);\r\n\t\tsetStorageAllValue(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the user's staking amount in the Property.\r\n\t */\r\n\tfunction getValue(address _property, address _sender)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn getStorageValue(_property, _sender);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds the user's staking amount in the Property.\r\n\t */\r\n\tfunction addValue(\r\n\t\taddress _property,\r\n\t\taddress _sender,\r\n\t\tuint256 _value\r\n\t) private {\r\n\t\tuint256 value = getStorageValue(_property, _sender);\r\n\t\tvalue = value.add(_value);\r\n\t\tsetStorageValue(_property, _sender, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the user is staking in the Property.\r\n\t */\r\n\tfunction hasValue(address _property, address _sender)\r\n\t\tprivate\r\n\t\tview\r\n\t\treturns (bool)\r\n\t{\r\n\t\tuint256 value = getStorageValue(_property, _sender);\r\n\t\treturn value != 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether a single user has all staking share.\r\n\t * This value is true when only one Property and one user is historically the only staker.\r\n\t */\r\n\tfunction isSingle(address _property, address _user)\r\n\t\tprivate\r\n\t\tview\r\n\t\treturns (bool)\r\n\t{\r\n\t\tuint256 perAccount = getStorageValue(_property, _user);\r\n\t\t(uint256 cLockProperty, uint256 unitProperty, ) = getCumulativeLockedUp(\r\n\t\t\t_property\r\n\t\t);\r\n\t\t(uint256 cLockTotal, , ) = getCumulativeLockedUpAll();\r\n\t\treturn perAccount == unitProperty && cLockProperty == cLockTotal;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the staking amount of the Property.\r\n\t */\r\n\tfunction getPropertyValue(address _property)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn getStoragePropertyValue(_property);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds the staking amount of the Property.\r\n\t */\r\n\tfunction addPropertyValue(address _property, uint256 _value) private {\r\n\t\tuint256 value = getStoragePropertyValue(_property);\r\n\t\tvalue = value.add(_value);\r\n\t\tsetStoragePropertyValue(_property, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Subtracts the staking amount of the Property.\r\n\t */\r\n\tfunction subPropertyValue(address _property, uint256 _value) private {\r\n\t\tuint256 value = getStoragePropertyValue(_property);\r\n\t\tuint256 nextValue = value.sub(_value);\r\n\t\tsetStoragePropertyValue(_property, nextValue);\r\n\t}\r\n\r\n\t/**\r\n\t * Saves the latest reward amount as an undrawn amount.\r\n\t */\r\n\tfunction updatePendingInterestWithdrawal(address _property, address _user)\r\n\t\tprivate\r\n\t{\r\n\t\t/**\r\n\t\t * Gets the latest reward amount.\r\n\t\t */\r\n\t\tuint256 withdrawableAmount = _calculateWithdrawableInterestAmount(\r\n\t\t\t_property,\r\n\t\t\t_user\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Saves the amount to `PendingInterestWithdrawal` storage.\r\n\t\t */\r\n\t\tsetStoragePendingInterestWithdrawal(\r\n\t\t\t_property,\r\n\t\t\t_user,\r\n\t\t\twithdrawableAmount\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Updates the reward amount of before DIP4 to prevent further addition it.\r\n\t\t */\r\n\t\t__updateLegacyWithdrawableInterestAmount(_property, _user);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the staking can be released.\r\n\t */\r\n\tfunction possible(address _property, address _from)\r\n\t\tprivate\r\n\t\tview\r\n\t\treturns (bool)\r\n\t{\r\n\t\tuint256 blockNumber = getStorageWithdrawalStatus(_property, _from);\r\n\t\tif (blockNumber == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (blockNumber <= block.number) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\tif (IPolicy(config().policy()).lockUpBlocks() == 1) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the reward amount of the calculation model before DIP4.\r\n\t * It can be calculated by subtracting \"the last cumulative sum of reward unit price\" from\r\n\t * \"the current cumulative sum of reward unit price,\" and multiplying by the staking amount.\r\n\t */\r\n\tfunction __legacyWithdrawableInterestAmount(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) private view returns (uint256) {\r\n\t\tuint256 _last = getStorageLastInterestPrice(_property, _user);\r\n\t\tuint256 price = getStorageInterestPrice(_property);\r\n\t\tuint256 priceGap = price.sub(_last);\r\n\t\tuint256 lockedUpValue = getStorageValue(_property, _user);\r\n\t\tuint256 value = priceGap.mul(lockedUpValue);\r\n\t\treturn value.divBasis();\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and treats the reward of before DIP4 as already received.\r\n\t */\r\n\tfunction __updateLegacyWithdrawableInterestAmount(\r\n\t\taddress _property,\r\n\t\taddress _user\r\n\t) private {\r\n\t\tuint256 interestPrice = getStorageInterestPrice(_property);\r\n\t\tif (getStorageLastInterestPrice(_property, _user) != interestPrice) {\r\n\t\t\tsetStorageLastInterestPrice(_property, _user, interestPrice);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the block number of the time of DIP4 release.\r\n\t */\r\n\tfunction setDIP4GenesisBlock(uint256 _block) external onlyOwner {\r\n\t\t/**\r\n\t\t * Validates the value is not set.\r\n\t\t */\r\n\t\trequire(getStorageDIP4GenesisBlock() == 0, \"already set the value\");\r\n\r\n\t\t/**\r\n\t\t * Sets the value.\r\n\t\t */\r\n\t\tsetStorageDIP4GenesisBlock(_block);\r\n\t}\r\n}\r\n\r\n// File: contracts/src/dev/Dev.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// prettier-ignore\r\n\r\n// prettier-ignore\r\n\r\n// prettier-ignore\r\n\r\n/**\r\n * The contract used as the DEV token.\r\n * The DEV token is an ERC20 token used as the native token of the Dev Protocol.\r\n * The DEV token is created by migration from its predecessor, the MVP, legacy DEV token. For that reason, the initial supply is 0.\r\n * Also, mint will be performed based on the Allocator contract.\r\n * When authenticated a new asset by the Market contracts, DEV token is burned as fees.\r\n */\r\ncontract Dev is\r\n\tERC20Detailed,\r\n\tERC20Mintable,\r\n\tERC20Burnable,\r\n\tUsingConfig,\r\n\tUsingValidator\r\n{\r\n\t/**\r\n\t * Initialize the passed address as AddressConfig address.\r\n\t * The token name is `Dev`, the token symbol is `DEV`, and the decimals is 18.\r\n\t */\r\n\tconstructor(address _config)\r\n\t\tpublic\r\n\t\tERC20Detailed(\"Dev\", \"DEV\", 18)\r\n\t\tUsingConfig(_config)\r\n\t{}\r\n\r\n\t/**\r\n\t * Staking DEV tokens.\r\n\t * The transfer destination must always be included in the address set for Property tokens.\r\n\t * This is because if the transfer destination is not a Property token, it is possible that the staked DEV token cannot be withdrawn.\r\n\t */\r\n\tfunction deposit(address _to, uint256 _amount) external returns (bool) {\r\n\t\trequire(transfer(_to, _amount), \"dev transfer failed\");\r\n\t\tlock(msg.sender, _to, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Staking DEV tokens by an allowanced address.\r\n\t * The transfer destination must always be included in the address set for Property tokens.\r\n\t * This is because if the transfer destination is not a Property token, it is possible that the staked DEV token cannot be withdrawn.\r\n\t */\r\n\tfunction depositFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _amount\r\n\t) external returns (bool) {\r\n\t\trequire(transferFrom(_from, _to, _amount), \"dev transferFrom failed\");\r\n\t\tlock(_from, _to, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Burn the DEV tokens as an authentication fee.\r\n\t * Only Market contracts can execute this function.\r\n\t */\r\n\tfunction fee(address _from, uint256 _amount) external returns (bool) {\r\n\t\taddressValidator().validateGroup(msg.sender, config().marketGroup());\r\n\t\t_burn(_from, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Call `Lockup.lockup` to execute staking.\r\n\t */\r\n\tfunction lock(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _amount\r\n\t) private {\r\n\t\tLockup(config().lockup()).lockup(_from, _to, _amount);\r\n\t}\r\n}\r\n\r\n// File: contracts/src/market/Market.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * A user-proposable contract for authenticating and associating assets with Property.\r\n * A user deploys a contract that inherits IMarketBehavior and creates this Market contract with the MarketFactory contract.\r\n */\r\ncontract Market is UsingConfig, IMarket, UsingValidator {\r\n\tusing SafeMath for uint256;\r\n\tbool public enabled;\r\n\taddress public behavior;\r\n\tuint256 public votingEndBlockNumber;\r\n\tuint256 public issuedMetrics;\r\n\tmapping(bytes32 => bool) private idMap;\r\n\tmapping(address => bytes32) private idHashMetricsMap;\r\n\r\n\t/**\r\n\t * Initialize the passed address as AddressConfig address and user-proposed contract.\r\n\t */\r\n\tconstructor(address _config, address _behavior)\r\n\t\tpublic\r\n\t\tUsingConfig(_config)\r\n\t{\r\n\t\t/**\r\n\t\t * Validates the sender is MarketFactory contract.\r\n\t\t */\r\n\t\taddressValidator().validateAddress(\r\n\t\t\tmsg.sender,\r\n\t\t\tconfig().marketFactory()\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Stores the contract address proposed by a user as an internal variable.\r\n\t\t */\r\n\t\tbehavior = _behavior;\r\n\r\n\t\t/**\r\n\t\t * By default this contract is disabled.\r\n\t\t */\r\n\t\tenabled = false;\r\n\r\n\t\t/**\r\n\t\t * Sets the period during which voting by voters can be accepted.\r\n\t\t * This period is determined by `Policy.marketVotingBlocks`.\r\n\t\t */\r\n\t\tuint256 marketVotingBlocks = IPolicy(config().policy())\r\n\t\t\t.marketVotingBlocks();\r\n\t\tvotingEndBlockNumber = block.number.add(marketVotingBlocks);\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the sender is the passed Property's author.\r\n\t */\r\n\tfunction propertyValidation(address _prop) private view {\r\n\t\taddressValidator().validateAddress(\r\n\t\t\tmsg.sender,\r\n\t\t\tIProperty(_prop).author()\r\n\t\t);\r\n\t\trequire(enabled, \"market is not enabled\");\r\n\t}\r\n\r\n\t/**\r\n\t * Modifier for validates the sender is the passed Property's author.\r\n\t */\r\n\tmodifier onlyPropertyAuthor(address _prop) {\r\n\t\tpropertyValidation(_prop);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Modifier for validates the sender is the author of the Property associated with the passed Metrics contract.\r\n\t */\r\n\tmodifier onlyLinkedPropertyAuthor(address _metrics) {\r\n\t\taddress _prop = Metrics(_metrics).property();\r\n\t\tpropertyValidation(_prop);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Activates this Market.\r\n\t * Called from VoteCounter contract when passed the voting or from MarketFactory contract when the first Market is created.\r\n\t */\r\n\tfunction toEnable() external {\r\n\t\taddressValidator().validateAddresses(\r\n\t\t\tmsg.sender,\r\n\t\t\tconfig().marketFactory(),\r\n\t\t\tconfig().voteCounter()\r\n\t\t);\r\n\t\tenabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Bypass to IMarketBehavior.authenticate.\r\n\t * Authenticates the new asset and proves that the Property author is the owner of the asset.\r\n\t */\r\n\tfunction authenticate(\r\n\t\taddress _prop,\r\n\t\tstring memory _args1,\r\n\t\tstring memory _args2,\r\n\t\tstring memory _args3,\r\n\t\tstring memory _args4,\r\n\t\tstring memory _args5\r\n\t) public onlyPropertyAuthor(_prop) returns (bool) {\r\n\t\tuint256 len = bytes(_args1).length;\r\n\t\trequire(len > 0, \"id is required\");\r\n\r\n\t\treturn\r\n\t\t\tIMarketBehavior(behavior).authenticate(\r\n\t\t\t\t_prop,\r\n\t\t\t\t_args1,\r\n\t\t\t\t_args2,\r\n\t\t\t\t_args3,\r\n\t\t\t\t_args4,\r\n\t\t\t\t_args5,\r\n\t\t\t\taddress(this),\r\n\t\t\t\tmsg.sender\r\n\t\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the authentication fee.\r\n\t * Calculates by gets the staking amount of the Property to be authenticated\r\n\t * and the total number of authenticated assets on the protocol, and calling `Policy.authenticationFee`.\r\n\t */\r\n\tfunction getAuthenticationFee(address _property)\r\n\t\tprivate\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t{\r\n\t\tuint256 tokenValue = ILockup(config().lockup()).getPropertyValue(\r\n\t\t\t_property\r\n\t\t);\r\n\t\tIPolicy policy = IPolicy(config().policy());\r\n\t\tIMetricsGroup metricsGroup = IMetricsGroup(config().metricsGroup());\r\n\t\treturn\r\n\t\t\tpolicy.authenticationFee(\r\n\t\t\t\tmetricsGroup.totalIssuedMetrics(),\r\n\t\t\t\ttokenValue\r\n\t\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * A function that will be called back when the asset is successfully authenticated.\r\n\t * There are cases where oracle is required for the authentication process, so the function is used callback style.\r\n\t */\r\n\tfunction authenticatedCallback(address _property, bytes32 _idHash)\r\n\t\texternal\r\n\t\treturns (address)\r\n\t{\r\n\t\t/**\r\n\t\t * Validates the sender is the saved IMarketBehavior address.\r\n\t\t */\r\n\t\taddressValidator().validateAddress(msg.sender, behavior);\r\n\t\trequire(enabled, \"market is not enabled\");\r\n\r\n\t\t/**\r\n\t\t * Validates the assets are not double authenticated.\r\n\t\t */\r\n\t\trequire(idMap[_idHash] == false, \"id is duplicated\");\r\n\t\tidMap[_idHash] = true;\r\n\r\n\t\t/**\r\n\t\t * Gets the Property author address.\r\n\t\t */\r\n\t\taddress sender = IProperty(_property).author();\r\n\r\n\t\t/**\r\n\t\t * Publishes a new Metrics contract and associate the Property with the asset.\r\n\t\t */\r\n\t\tIMetricsFactory metricsFactory = IMetricsFactory(\r\n\t\t\tconfig().metricsFactory()\r\n\t\t);\r\n\t\taddress metrics = metricsFactory.create(_property);\r\n\t\tidHashMetricsMap[metrics] = _idHash;\r\n\r\n\t\t/**\r\n\t\t * Burn as a authentication fee.\r\n\t\t */\r\n\t\tuint256 authenticationFee = getAuthenticationFee(_property);\r\n\t\trequire(\r\n\t\t\tDev(config().token()).fee(sender, authenticationFee),\r\n\t\t\t\"dev fee failed\"\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Adds the number of authenticated assets in this Market.\r\n\t\t */\r\n\t\tissuedMetrics = issuedMetrics.add(1);\r\n\t\treturn metrics;\r\n\t}\r\n\r\n\t/**\r\n\t * Release the authenticated asset.\r\n\t */\r\n\tfunction deauthenticate(address _metrics)\r\n\t\texternal\r\n\t\tonlyLinkedPropertyAuthor(_metrics)\r\n\t{\r\n\t\t/**\r\n\t\t * Validates the passed Metrics address is authenticated in this Market.\r\n\t\t */\r\n\t\tbytes32 idHash = idHashMetricsMap[_metrics];\r\n\t\trequire(idMap[idHash], \"not authenticated\");\r\n\r\n\t\t/**\r\n\t\t * Removes the authentication status from local variables.\r\n\t\t */\r\n\t\tidMap[idHash] = false;\r\n\t\tidHashMetricsMap[_metrics] = bytes32(0);\r\n\r\n\t\t/**\r\n\t\t * Removes the passed Metrics contract from the Metrics address set.\r\n\t\t */\r\n\t\tIMetricsFactory metricsFactory = IMetricsFactory(\r\n\t\t\tconfig().metricsFactory()\r\n\t\t);\r\n\t\tmetricsFactory.destroy(_metrics);\r\n\r\n\t\t/**\r\n\t\t * Subtracts the number of authenticated assets in this Market.\r\n\t\t */\r\n\t\tissuedMetrics = issuedMetrics.sub(1);\r\n\t}\r\n\r\n\t/**\r\n\t * Bypass to IMarketBehavior.schema.\r\n\t */\r\n\tfunction schema() external view returns (string memory) {\r\n\t\treturn IMarketBehavior(behavior).schema();\r\n\t}\r\n}\r\n\r\n// File: contracts/src/market/IMarketGroup.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IMarketGroup is IGroup {\r\n\tfunction getCount() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/src/market/MarketFactory.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * A factory contract that creates a new Market contract.\r\n */\r\ncontract MarketFactory is IMarketFactory, UsingConfig, UsingValidator {\r\n\tevent Create(address indexed _from, address _market);\r\n\r\n\t/**\r\n\t * Initialize the passed address as AddressConfig address.\r\n\t */\r\n\t// solium-disable-next-line no-empty-blocks\r\n\tconstructor(address _config) public UsingConfig(_config) {}\r\n\r\n\t/**\r\n\t * Creates a new Market contract.\r\n\t */\r\n\tfunction create(address _addr) external returns (address) {\r\n\t\t/**\r\n\t\t * Validates the passed address is not 0 address.\r\n\t\t */\r\n\t\taddressValidator().validateIllegalAddress(_addr);\r\n\r\n\t\t/**\r\n\t\t * Creates a new Market contract with the passed address as the IMarketBehavior.\r\n\t\t */\r\n\t\tMarket market = new Market(address(config()), _addr);\r\n\r\n\t\t/**\r\n\t\t * Adds the created Market contract to the Market address set.\r\n\t\t */\r\n\t\taddress marketAddr = address(market);\r\n\t\tIMarketGroup marketGroup = IMarketGroup(config().marketGroup());\r\n\t\tmarketGroup.addGroup(marketAddr);\r\n\r\n\t\t/**\r\n\t\t * For the first Market contract, it will be activated immediately.\r\n\t\t * If not, the Market contract will be activated after a vote by the voters.\r\n\t\t */\r\n\t\tif (marketGroup.getCount() == 1) {\r\n\t\t\tmarket.toEnable();\r\n\t\t}\r\n\r\n\t\temit Create(msg.sender, marketAddr);\r\n\t\treturn marketAddr;\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"}],\"name\":\"Create\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"configAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MarketFactory","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001d415aa39d647834786eb9b5a333a50e9935b796","EVMVersion":"Default","Library":"","LicenseType":"MPL-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://667b5de3a803aaac8684108683c8810e13256a965db08b51f2f62d7cb8b8b153"}]}