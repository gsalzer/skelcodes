{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16; /*\r\n\r\n    \r\n    \r\n    ███████╗████████╗██╗  ██╗     ██████╗  ██████╗            ██╗  ██╗██╗   ██╗███████╗\r\n    ██╔════╝╚══██╔══╝██║  ██║    ██╔════╝ ██╔═══██╗           ╚██╗██╔╝╚██╗ ██╔╝╚══███╔╝\r\n    █████╗     ██║   ███████║    ██║  ███╗██║   ██║            ╚███╔╝  ╚████╔╝   ███╔╝ \r\n    ██╔══╝     ██║   ██╔══██║    ██║   ██║██║   ██║            ██╔██╗   ╚██╔╝   ███╔╝  \r\n    ███████╗   ██║   ██║  ██║    ╚██████╔╝╚██████╔╝    ██╗    ██╔╝ ██╗   ██║   ███████╗\r\n    ╚══════╝   ╚═╝   ╚═╝  ╚═╝     ╚═════╝  ╚═════╝     ╚═╝    ╚═╝  ╚═╝   ╚═╝   ╚══════╝\r\n                                                                                       \r\n\r\n  \r\n*/\r\n\r\n\r\n// Owner Handler\r\ncontract ownerShip    // Auction Contract Owner and OwherShip change\r\n{\r\n    //Global storage declaration\r\n    address payable public ownerWallet;\r\n    address payable public newOwner;\r\n    //Event defined for ownership transfered\r\n    event OwnershipTransferredEv(address indexed previousOwner, address indexed newOwner);\r\n\r\n    //Sets owner only on first run\r\n    constructor() public \r\n    {\r\n        //Set contract owner\r\n        ownerWallet = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner \r\n    {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //the reason for this flow is to protect owners from sending ownership to unintended address due to human error\r\n    function acceptOwnership() public \r\n    {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferredEv(ownerWallet, newOwner);\r\n        ownerWallet = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n\r\n    //This will restrict function only for owner where attached\r\n    modifier onlyOwner() \r\n    {\r\n        require(msg.sender == ownerWallet);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract ethGO is ownerShip {\r\n\r\n    uint public defaultRefID = 1;   //this ref ID will be used if user joins without any ref ID\r\n    uint public constant maxDownLimit = 2;\r\n    uint public constant levelLifeTime = 3888000;  // = 45 days;\r\n    uint public lastIDCount = 0;\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint referrerID;\r\n        uint originalReferer;\r\n        address[] referral;\r\n        mapping(uint => uint) levelExpired;\r\n    }\r\n\r\n    mapping(uint => uint) public priceOfLevel;\r\n\r\n    mapping (address => userInfo) public userInfos;\r\n    mapping (uint => address) public userAddressByID;\r\n\r\n\r\n    event regLevelEv(uint indexed _userID, address indexed _userWallet, uint indexed _referrerID, address _refererWallet, uint _originalReferrer, uint _time);\r\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\r\n    event paidForLevelEv(uint userID, address indexed _user, uint referralID, address indexed _referral, uint _level, uint _amount, uint _time);\r\n    event lostForLevelEv(uint userID, address indexed _user, uint referralID, address indexed _referral, uint _level, uint _amount, uint _time);\r\n\r\n    constructor() public {\r\n\r\n        priceOfLevel[1] = 0.2 ether;\r\n        priceOfLevel[2] = 0.4 ether;\r\n        priceOfLevel[3] = 0.8 ether;\r\n        priceOfLevel[4] = 1.6 ether;\r\n        priceOfLevel[5] = 3.2 ether;\r\n        priceOfLevel[6] = 6.4 ether;\r\n        priceOfLevel[7] = 12.8 ether;\r\n        priceOfLevel[8] = 25.6 ether;\r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: 0,\r\n            originalReferer:0,\r\n            referral: new address[](0)\r\n        });\r\n        userInfos[ownerWallet] = UserInfo;\r\n        userAddressByID[lastIDCount] = ownerWallet;\r\n\r\n        for(uint i = 1; i <= 8; i++) {\r\n            userInfos[ownerWallet].levelExpired[i] = 99999999999;\r\n            emit paidForLevelEv(lastIDCount, ownerWallet, 0, address(0), i, priceOfLevel[i], now);\r\n        }\r\n        \r\n        emit regLevelEv(lastIDCount, msg.sender, 0, address(0), 0, now);\r\n    }\r\n    \r\n    function () external payable {\r\n        uint level;\r\n\r\n        if(msg.value == priceOfLevel[1]) level = 1;\r\n        else if(msg.value == priceOfLevel[2]) level = 2;\r\n        else if(msg.value == priceOfLevel[3]) level = 3;\r\n        else if(msg.value == priceOfLevel[4]) level = 4;\r\n        else if(msg.value == priceOfLevel[5]) level = 5;\r\n        else if(msg.value == priceOfLevel[6]) level = 6;\r\n        else if(msg.value == priceOfLevel[7]) level = 7;\r\n        else if(msg.value == priceOfLevel[8]) level = 8;\r\n        else revert('Incorrect Value send');\r\n\r\n        if(userInfos[msg.sender].joined) buyLevel(msg.sender, level);\r\n        else if(level == 1) {\r\n            uint refId = 0;\r\n            address referrer = bytesToAddress(msg.data);\r\n\r\n            if(userInfos[referrer].joined) refId = userInfos[referrer].id;\r\n            else revert('Incorrect referrer');\r\n\r\n            regUser(msg.sender, refId);\r\n        }\r\n        else revert('Please buy first level for 0.2 ETH');\r\n    }\r\n\r\n    function regUser(address _user, uint _referrerID) public payable returns(bool) {\r\n        if(!(_referrerID > 0 && _referrerID <= lastIDCount)) _referrerID = defaultRefID;\r\n        uint originalReferer = _referrerID;\r\n        require(!userInfos[_user].joined, 'User exist');\r\n        \r\n        \r\n        \r\n        \r\n        if(userInfos[userAddressByID[_referrerID]].referral.length >= maxDownLimit) _referrerID = userInfos[findFreeReferrer(userAddressByID[_referrerID])].id;\r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: _referrerID,\r\n            originalReferer: originalReferer,\r\n            referral: new address[](0)\r\n        });\r\n\r\n        userInfos[_user] = UserInfo;\r\n        userAddressByID[lastIDCount] = _user;\r\n\r\n        userInfos[_user].levelExpired[1] = now + levelLifeTime;\r\n\r\n        userInfos[userAddressByID[_referrerID]].referral.push(_user);\r\n\r\n        //owner can buy levels without paying anything\r\n        if(msg.sender!=ownerWallet){\r\n            require(msg.value == priceOfLevel[1], 'Incorrect Value');\r\n            require(msg.sender == _user, 'Invalid user');\r\n            payForCycle(1, _user);  //it won't pay to uplines as this position is placed without paying anything.\r\n        }\r\n\r\n        emit regLevelEv(lastIDCount, _user, _referrerID, userAddressByID[_referrerID], originalReferer, now);\r\n        return true;\r\n    }\r\n\r\n    function buyLevel(address _user, uint _level) public payable {\r\n        require(userInfos[_user].joined, 'User not exist'); \r\n        require(_level > 0 && _level <= 10, 'Incorrect level');\r\n        \r\n        \r\n        \r\n        \r\n        \r\n\r\n        if(_level == 1) {\r\n            userInfos[_user].levelExpired[1] += levelLifeTime;\r\n        }\r\n        else {\r\n            \r\n\r\n            for(uint l =_level - 1; l > 0; l--) require(userInfos[_user].levelExpired[l] >= now, 'Buy the previous level');\r\n\r\n            if(userInfos[_user].levelExpired[_level] == 0) userInfos[_user].levelExpired[_level] = now + levelLifeTime;\r\n            else userInfos[_user].levelExpired[_level] += levelLifeTime;\r\n        }\r\n        \r\n        //owner can buy levels without paying anything\r\n        if(msg.sender!=ownerWallet){\r\n            require(msg.value == priceOfLevel[_level], 'Incorrect Value');\r\n            require(msg.sender == _user, 'Invalid user');\r\n            payForCycle(_level, _user);  //it won't pay to uplines as this position is placed without paying anything.\r\n        }\r\n\r\n        emit levelBuyEv(_user, _level, msg.value, now);\r\n    }\r\n    \r\n\r\n    function payForCycle(uint _level, address _user) internal {\r\n        address referer;\r\n        address referer1;\r\n        address def = userAddressByID[defaultRefID];\r\n        uint256 price = priceOfLevel[_level] * 4500 / 10000;\r\n        uint256 adminPart = price * 10000 / 45000;\r\n\r\n        referer = findValidUpline(_user, _level);\r\n        referer1 = findValidUpline(referer, _level);\r\n\r\n        if(!userInfos[referer].joined) \r\n        {\r\n            address(uint160(def)).transfer(price);\r\n            emit lostForLevelEv(userInfos[referer].id, referer, userInfos[_user].id, _user, _level, price, now);\r\n        }\r\n        else\r\n        {\r\n            address(uint160(referer)).transfer(price);\r\n            emit paidForLevelEv(userInfos[referer].id, referer, userInfos[_user].id, _user, _level, price, now);\r\n        }\r\n\r\n        if(!userInfos[referer1].joined  || !(userInfos[_user].levelExpired[_level] >= now ) ) \r\n        {\r\n            address(uint160(def)).transfer(price);\r\n            emit lostForLevelEv(userInfos[referer1].id, referer1, userInfos[_user].id, _user, _level, price, now);\r\n        }\r\n        else\r\n        {\r\n            address(uint160(referer1)).transfer(price);\r\n            emit paidForLevelEv(userInfos[referer1].id, referer1, userInfos[_user].id, _user, _level, price, now);\r\n        }\r\n        ownerWallet.transfer(adminPart);\r\n    }\r\n\r\n    function findValidUpline(address _user, uint _level) internal returns(address)\r\n    {\r\n        for(uint i=0;i<64;i++)\r\n        {\r\n           _user = userAddressByID[userInfos[_user].referrerID];\r\n           if(userInfos[_user].levelExpired[_level] >= now ) break;\r\n        }\r\n        if(!(userInfos[_user].levelExpired[_level] >= now ))  userAddressByID[defaultRefID];\r\n        return _user;\r\n    }\r\n\r\n\r\n\r\n    function findFreeReferrer(address _user) public view returns(address) {\r\n        if(userInfos[_user].referral.length < maxDownLimit) return _user;\r\n\r\n        address[] memory referrals = new address[](126);\r\n        referrals[0] = userInfos[_user].referral[0];\r\n        referrals[1] = userInfos[_user].referral[1];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for(uint i = 0; i < 126; i++) {\r\n            if(userInfos[referrals[i]].referral.length == maxDownLimit) {\r\n                if(i < 62) {\r\n                    referrals[(i+1)*2] = userInfos[referrals[i]].referral[0];\r\n                    referrals[(i+1)*2+1] = userInfos[referrals[i]].referral[1];\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n\r\n        return freeReferrer;\r\n    }\r\n\r\n    function viewUserReferral(address _user) public view returns(address[] memory) {\r\n        return userInfos[_user].referral;\r\n    }\r\n\r\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\r\n        return userInfos[_user].levelExpired[_level];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n\r\n        \r\n    function changeDefaultRefID(uint newDefaultRefID) onlyOwner public returns(string memory){\r\n        //this ref ID will be assigned to user who joins without any referral ID.\r\n        defaultRefID = newDefaultRefID;\r\n        return(\"Default Ref ID updated successfully\");\r\n    }\r\n    \r\n    function viewTimestampSinceJoined(address usr) public view returns(uint256[8] memory timeSinceJoined )\r\n    {\r\n        if(userInfos[usr].joined)\r\n        {\r\n            for(uint256 i=0;i<8;i++)\r\n            {\r\n                uint256 t = userInfos[usr].levelExpired[i+1];\r\n                if(t>now)\r\n                {\r\n                    timeSinceJoined[i] = (t-now);\r\n                }\r\n            }\r\n        }\r\n        return timeSinceJoined;\r\n    }\r\n    \r\n    function ownerOnlyCreateUser(address[] memory _user ) public onlyOwner returns(bool)\r\n    {\r\n        require(_user.length <= 50, \"invalid input\");\r\n        for(uint i=0; i < _user.length; i++ )\r\n        {\r\n            require(regUser(_user[i], 1),\"registration fail\");\r\n        }\r\n        return true;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferredEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"levelBuyEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"lostForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"paidForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_refererWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_originalReferrer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"regLevelEv\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultRefID\",\"type\":\"uint256\"}],\"name\":\"changeDefaultRefID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultRefID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levelLifeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDownLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_user\",\"type\":\"address[]\"}],\"name\":\"ownerOnlyCreateUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceOfLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originalReferer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"viewTimestampSinceJoined\",\"outputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"timeSinceJoined\",\"type\":\"uint256[8]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"viewUserLevelExpired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ethGO","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c8318bb9064e28debe5b0d1908dd90b54462132b95b9874a55bcd84114d80ad8"}]}