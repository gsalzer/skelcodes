{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/upgradable/OwnableUpgradable.sol\n\npragma solidity ^0.5.16;\n\n// import \"../openzeppelin/upgrades/contracts/Initializable.sol\";\n\ncontract OwnableUpgradable is Initializable {\n    address payable public owner;\n    address payable internal newOwnerCandidate;\n\n    // Initializer – Constructor for Upgradable contracts\n    function initialize() public initializer {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Permission denied\");\n        _;\n    }\n\n    function changeOwner(address payable newOwner) public onlyOwner {\n        newOwnerCandidate = newOwner;\n    }\n\n    function acceptOwner() public {\n        require(msg.sender == newOwnerCandidate, \"Permission denied\");\n        owner = newOwnerCandidate;\n    }\n\n    uint256[50] private ______gap;\n}\n\n// File: contracts/upgradable/AdminableUpgradable.sol\n\npragma solidity ^0.5.16;\n\n// import \"../openzeppelin/upgrades/contracts/Initializable.sol\";\n\n\n\ncontract AdminableUpgradable is Initializable, OwnableUpgradable {\n    mapping(address => bool) public admins;\n\n\n    modifier onlyOwnerOrAdmin {\n        require(msg.sender == owner ||\n                admins[msg.sender], \"Permission denied\");\n        _;\n    }\n\n\n    // Initializer – Constructor for Upgradable contracts\n    function initialize() public initializer {\n        OwnableUpgradable.initialize();  // Initialize Parent Contract\n    }\n\n\n    function setAdminPermission(address _admin, bool _status) public onlyOwner {\n        admins[_admin] = _status;\n    }\n\n    function setAdminPermission(address[] memory _admins, bool _status) public onlyOwner {\n        for (uint i = 0; i < _admins.length; i++) {\n            admins[_admins[i]] = _status;\n        }\n    }\n\n\n    uint256[50] private ______gap;\n}\n\n// File: contracts/utils/DSMath.sol\n\npragma solidity ^0.5.0;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y, uint base) internal pure returns (uint z) {\n        z = add(mul(x, y), base / 2) / base;\n    }\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    /*function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }*/\n}\n\n// File: contracts/affiliateProgram/AffiliateProgram.sol\n\npragma solidity ^0.5.16;\n\n\n\n\n\ncontract AffiliateProgram is Initializable, DSMath, AdminableUpgradable {\n\n    struct LevelProgram {\n        uint8 percent;\n        uint80 ethAmount;\n    }\n\n    struct Partner {\n        // first bytes32 (== uint256) slot\n        address partnerAddr;        //  address of the partner\n        uint8 level;                //  Aff Program level\n\n        // second bytes32 (== uint256) slot\n        uint80 profit;              //  partner's current profit\n        uint80 referralsCount;      //  partner's referrals count\n        uint80 referralsEthValue;   //  eth invested by partner's referrals\n    }\n\n\n    uint256 public constant LEVEL_COUNTER = 3;\n\n\n    mapping(uint8 => LevelProgram) public levels;\n\n    mapping(bytes32 => Partner) public codeToPartner;\n    mapping(address => bytes32) public partnerToCode;\n\n    mapping(address => bool) public permissionAddresses;\n\n    mapping(address => address) internal referralToReferrer;\n\n\n    // ** EVENTS **\n\n    event PartnerAdded(address indexed partner, uint8 level, bytes32 code);\n\n    event ReferralAdded(address indexed referral, bytes32 code);\n\n    event ProfitDistributed(bytes32 indexed code, uint256 profit);\n\n    event ProfitWithdrawn(address indexed partner, uint256 profit);\n\n\n    // ** MODIFIERS **\n\n    modifier needPermission {\n        require(permissionAddresses[msg.sender], \"Permission denied\");\n        _;\n    }\n\n    modifier RegDataValidation(address partner, bytes32 code) {\n        require(partner != address(0), \"Address must not be zero\");\n        require(code != bytes32(0), \"Promocode must not be zero\");\n        require(codeToPartner[code].partnerAddr == address(0), \"Promo code is already registered\");\n        require(partnerToCode[partner] == bytes32(0), \"User is already registered\");\n        _;\n    }\n\n\n    // ** INITIALIZER – Constructor for Upgradable contracts **\n\n    function initialize() public initializer {\n        levels[0] = LevelProgram(20, 0 ether);      // 20% and 0 ETH from referrals\n        levels[1] = LevelProgram(35, 1000 ether);   // 35% and more 1000 ETH from referrals\n        levels[2] = LevelProgram(50, 3000 ether);   // 50% and more 3000 ETH from referrals\n    }\n\n\n    // ** PUBLIC VIEW functions **\n\n    function getPartnerByCode(bytes32 code) public view returns (address, uint8, uint256, uint256, uint256) {\n        Partner memory curPartner = codeToPartner[code];\n\n        return (\n            curPartner.partnerAddr,\n            curPartner.level,\n            curPartner.referralsCount,\n            curPartner.referralsEthValue,\n            curPartner.profit\n        );\n    }\n\n    function getPartnerByReferral(address referral) public view returns (address, uint8, uint256, uint256, uint256) {\n        Partner memory curPartner = codeToPartner[partnerToCode[referralToReferrer[referral]]];\n\n        return (\n            curPartner.partnerAddr,\n            curPartner.level,\n            curPartner.referralsCount,\n            curPartner.referralsEthValue,\n            curPartner.profit\n        );\n    }\n\n    function getProfitPercentByReferral(address referral) public view returns (uint8) {\n        Partner memory curPartner = codeToPartner[partnerToCode[referralToReferrer[referral]]];\n\n        return levels[curPartner.level].percent;\n    }\n\n    function isUserInPartnership(bytes32 code, address referral) public view returns (bool) {\n        return (referralToReferrer[referral] == codeToPartner[code].partnerAddr);\n    }\n\n\n    // ** ONLY_OWNER_OR_ADMIN functions **\n\n    function setPermissionAddress(address addr, bool status)\n        public\n        onlyOwnerOrAdmin\n    {\n        permissionAddresses[addr] = status;\n    }\n\n    function setPermissionAddresses(address[] memory addrs, bool status)\n        public\n        onlyOwnerOrAdmin\n    {\n        for (uint i = 0; i < addrs.length; i++) {\n            permissionAddresses[addrs[i]] = status;\n        }\n    }\n\n    function updateLevel(uint8 level, uint8 percent, uint80 ethAmount)\n        public\n        onlyOwnerOrAdmin\n    {\n        require(level < LEVEL_COUNTER, \"Level is incorrect\");\n        require(percent <= 100, \"Percent is incorrect\");\n\n        levels[level].percent = percent;\n        levels[level].ethAmount = ethAmount;\n    }\n\n    function addPartnerByAdmin(address partner, uint8 level, bytes32 code)\n        public\n        onlyOwnerOrAdmin\n        RegDataValidation(partner, code)\n    {\n        require(level < LEVEL_COUNTER, \"Level is incorrect\");\n\n        _addPartnerHelper(partner, level, code);\n    }\n\n\n    // ** PUBLIC functions **\n\n    function register(bytes32 code)\n        public\n        RegDataValidation(msg.sender, code)\n    {\n        _addPartnerHelper(msg.sender, 0, code);\n    }\n\n    function withdrawProfit() public {\n        address payable partner = msg.sender;\n        uint ethToWithdraw = codeToPartner[partnerToCode[partner]].profit;\n        require(ethToWithdraw > 0, \"No profit\");\n\n        // UPD partner's profit state and transfer eth\n        codeToPartner[partnerToCode[partner]].profit = 0;\n        partner.transfer(ethToWithdraw);\n\n        emit ProfitWithdrawn(partner, ethToWithdraw);\n    }\n\n\n    // ** PUBLIC PAYABLE NEED_PERMISSION functions - distribute profit **\n\n    function distributeProfit(address partner)\n        public\n        payable\n        needPermission\n    {\n        _distributeProfitHelper(partnerToCode[partner]);\n    }\n\n    function distributeProfit(bytes32 code)\n        public\n        payable\n        needPermission\n    {\n        _distributeProfitHelper(code);\n    }\n\n    function distributeProfitByReferral(address referral)\n        public\n        payable\n        needPermission\n    {\n        _distributeProfitHelper(partnerToCode[referralToReferrer[referral]]);\n    }\n\n\n    // ** PUBLIC NEED_PERMISSION functions - add referral **\n\n    function addReferral(address referral, bytes32 code, uint256 ethValue)\n        public\n        needPermission\n        returns(uint256)    // 0 == deposit added to a new referrer\n                            // 1 == deposit added to an exists referrer\n                            // 2 == deposit did not add, referrer does not exist\n    {\n        return _addReferralHelper(referral, code, ethValue);\n    }\n\n    function addReferral(address referral, address partner, uint256 ethValue)\n        public\n        needPermission\n        returns(uint256)    // 0 == deposit added to a new referrer\n                            // 1 == deposit added to an exists referrer\n                            // 2 == deposit did not add, referrer does not exist\n    {\n        return _addReferralHelper(referral, partnerToCode[partner], ethValue);\n    }\n\n\n    // ** INTERNAL functions **\n\n    function _addPartnerHelper(address partner, uint8 level, bytes32 code)\n        internal\n    {\n        // Set New Partner\n        partnerToCode[partner] = code;\n        codeToPartner[code] = Partner(partner, level, 0, 0, 0);\n\n        emit PartnerAdded(partner, level, code);\n    }\n\n    function _distributeProfitHelper(bytes32 code)\n        internal\n    {\n        Partner memory curPartner = codeToPartner[code];\n        require(curPartner.partnerAddr != address(0), \"Promocode is not exists\");\n\n        // UPD partner's profit state\n        uint curProfit = msg.value;\n        codeToPartner[code].profit = uint80(add(curPartner.profit, curProfit));\n\n        emit ProfitDistributed(code, curProfit);\n    }\n\n    function _addReferralHelper(address referral, bytes32 code, uint256 ethValue)\n        internal\n        returns(uint256)    // 0 == deposit added to a new referrer\n                            // 1 == deposit added to an exists referrer\n                            // 2 == deposit did not add, referrer does not exist\n    {\n        Partner memory curPartner = codeToPartner[code];\n\n        // Referrer does not exist\n        // require(codeToPartner[code].partnerAddr != address(0), \"Referrer does not exist\");\n        if (curPartner.partnerAddr == address(0)) {\n            return 2;\n        }\n\n        // UPD referralsEthValue state\n        uint80 referralsEthValue;\n        codeToPartner[code].referralsEthValue = referralsEthValue = uint80(add(curPartner.referralsEthValue, ethValue));\n\n        // UPD level state\n        uint level = (referralsEthValue < levels[1].ethAmount) ? 0 : ((referralsEthValue < levels[2].ethAmount) ? 1 : 2);\n        if (level > curPartner.level) {\n            codeToPartner[code].level = uint8(level);\n        }\n\n        // Referral is already added\n        // require(referralToReferrer[referral] == address(0), \"Referral is already added\");\n        if (referralToReferrer[referral] != address(0)) {\n            return 1;\n        }\n\n        // UPD referralsCount and referralToReferrer states\n        codeToPartner[code].referralsCount += 1;\n        referralToReferrer[referral] = curPartner.partnerAddr;\n\n        emit ReferralAdded(referral, code);\n        return 0;\n    }\n\n\n    uint256[50] private ______gap;\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"PartnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"ProfitDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"ProfitWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"ReferralAdded\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"LEVEL_COUNTER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"addPartnerByAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"}],\"name\":\"addReferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"}],\"name\":\"addReferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"codeToPartner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"partnerAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint80\",\"name\":\"profit\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"referralsCount\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"referralsEthValue\",\"type\":\"uint80\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"distributeProfit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"distributeProfit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"distributeProfitByReferral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"getPartnerByCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"getPartnerByReferral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"getProfitPercentByReferral\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"isUserInPartnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"},{\"internalType\":\"uint80\",\"name\":\"ethAmount\",\"type\":\"uint80\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partnerToCode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permissionAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdminPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_admins\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdminPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setPermissionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setPermissionAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"},{\"internalType\":\"uint80\",\"name\":\"ethAmount\",\"type\":\"uint80\"}],\"name\":\"updateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AffiliateProgram","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}