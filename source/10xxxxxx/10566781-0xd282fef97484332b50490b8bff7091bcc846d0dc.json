{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: solidity/contracts/utility/interfaces/IOwned.sol\n\npragma solidity 0.4.26;\n\n/*\n    Owned contract interface\n*/\ncontract IOwned {\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n    function owner() public view returns (address) {this;}\n\n    function transferOwnership(address _newOwner) public;\n    function acceptOwnership() public;\n}\n\n// File: solidity/contracts/token/interfaces/IERC20Token.sol\n\npragma solidity 0.4.26;\n\n/*\n    ERC20 Standard Token interface\n*/\ncontract IERC20Token {\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n    function name() public view returns (string) {this;}\n    function symbol() public view returns (string) {this;}\n    function decimals() public view returns (uint8) {this;}\n    function totalSupply() public view returns (uint256) {this;}\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n// File: solidity/contracts/utility/interfaces/ITokenHolder.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Token Holder interface\n*/\ncontract ITokenHolder is IOwned {\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterAnchor.sol\n\npragma solidity 0.4.26;\n\n\n\n/*\n    Converter Anchor interface\n*/\ncontract IConverterAnchor is IOwned, ITokenHolder {\n}\n\n// File: solidity/contracts/utility/interfaces/IWhitelist.sol\n\npragma solidity 0.4.26;\n\n/*\n    Whitelist interface\n*/\ncontract IWhitelist {\n    function isWhitelisted(address _address) public view returns (bool);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverter.sol\n\npragma solidity 0.4.26;\n\n\n\n\n\n/*\n    Converter interface\n*/\ncontract IConverter is IOwned {\n    function converterType() public pure returns (uint16);\n    function anchor() public view returns (IConverterAnchor) {this;}\n    function isActive() public view returns (bool);\n\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256);\n    function convert(IERC20Token _sourceToken,\n                     IERC20Token _targetToken,\n                     uint256 _amount,\n                     address _trader,\n                     address _beneficiary) public payable returns (uint256);\n\n    function conversionWhitelist() public view returns (IWhitelist) {this;}\n    function conversionFee() public view returns (uint32) {this;}\n    function maxConversionFee() public view returns (uint32) {this;}\n    function reserveBalance(IERC20Token _reserveToken) public view returns (uint256);\n    function() external payable;\n\n    function transferAnchorOwnership(address _newOwner) public;\n    function acceptAnchorOwnership() public;\n    function setConversionFee(uint32 _conversionFee) public;\n    function setConversionWhitelist(IWhitelist _whitelist) public;\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n    function withdrawETH(address _to) public;\n    function addReserve(IERC20Token _token, uint32 _ratio) public;\n\n    // deprecated, backward compatibility\n    function token() public view returns (IConverterAnchor);\n    function transferTokenOwnership(address _newOwner) public;\n    function acceptTokenOwnership() public;\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool);\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\n    function connectorTokens(uint256 _index) public view returns (IERC20Token);\n    function connectorTokenCount() public view returns (uint16);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterUpgrader.sol\n\npragma solidity 0.4.26;\n\n/*\n    Converter Upgrader interface\n*/\ncontract IConverterUpgrader {\n    function upgrade(bytes32 _version) public;\n    function upgrade(uint16 _version) public;\n}\n\n// File: solidity/contracts/converter/interfaces/IBancorFormula.sol\n\npragma solidity 0.4.26;\n\n/*\n    Bancor Formula interface\n*/\ncontract IBancorFormula {\n    function purchaseTargetAmount(uint256 _supply,\n                                  uint256 _reserveBalance,\n                                  uint32 _reserveWeight,\n                                  uint256 _amount)\n                                  public view returns (uint256);\n\n    function saleTargetAmount(uint256 _supply,\n                              uint256 _reserveBalance,\n                              uint32 _reserveWeight,\n                              uint256 _amount)\n                              public view returns (uint256);\n\n    function crossReserveTargetAmount(uint256 _sourceReserveBalance,\n                                      uint32 _sourceReserveWeight,\n                                      uint256 _targetReserveBalance,\n                                      uint32 _targetReserveWeight,\n                                      uint256 _amount)\n                                      public view returns (uint256);\n\n    function fundCost(uint256 _supply,\n                      uint256 _reserveBalance,\n                      uint32 _reserveRatio,\n                      uint256 _amount)\n                      public view returns (uint256);\n\n    function fundSupplyAmount(uint256 _supply,\n                              uint256 _reserveBalance,\n                              uint32 _reserveRatio,\n                              uint256 _amount)\n                              public view returns (uint256);\n\n    function liquidateReserveAmount(uint256 _supply,\n                                    uint256 _reserveBalance,\n                                    uint32 _reserveRatio,\n                                    uint256 _amount)\n                                    public view returns (uint256);\n\n    function balancedWeights(uint256 _primaryReserveStakedBalance,\n                             uint256 _primaryReserveBalance,\n                             uint256 _secondaryReserveBalance,\n                             uint256 _reserveRateNumerator,\n                             uint256 _reserveRateDenominator)\n                             public view returns (uint32, uint32);\n}\n\n// File: solidity/contracts/IBancorNetwork.sol\n\npragma solidity 0.4.26;\n\n\n/*\n    Bancor Network interface\n*/\ncontract IBancorNetwork {\n    function convert2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public payable returns (uint256);\n\n    function claimAndConvert2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public returns (uint256);\n\n    function convertFor2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public payable returns (uint256);\n\n    function claimAndConvertFor2(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) public returns (uint256);\n\n    // deprecated, backward compatibility\n    function convert(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn\n    ) public payable returns (uint256);\n\n    // deprecated, backward compatibility\n    function claimAndConvert(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn\n    ) public returns (uint256);\n\n    // deprecated, backward compatibility\n    function convertFor(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for\n    ) public payable returns (uint256);\n\n    // deprecated, backward compatibility\n    function claimAndConvertFor(\n        IERC20Token[] _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for\n    ) public returns (uint256);\n}\n\n// File: solidity/contracts/utility/Owned.sol\n\npragma solidity 0.4.26;\r\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/Utils.sol\n\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\n\n// File: solidity/contracts/utility/interfaces/IContractRegistry.sol\n\npragma solidity 0.4.26;\n\n/*\n    Contract Registry interface\n*/\ncontract IContractRegistry {\n    function addressOf(bytes32 _contractName) public view returns (address);\n\n    // deprecated, backward compatibility\n    function getAddress(bytes32 _contractName) public view returns (address);\n}\n\n// File: solidity/contracts/utility/ContractRegistryClient.sol\n\npragma solidity 0.4.26;\r\r\r\r\n\r\n/**\r\n  * @dev Base contract for ContractRegistry clients\r\n*/\r\ncontract ContractRegistryClient is Owned, Utils {\r\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\r\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\r\n    bytes32 internal constant CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n    bytes32 internal constant CONVERTER_REGISTRY = \"BancorConverterRegistry\";\r\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\r\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 internal constant BANCOR_X = \"BancorX\";\r\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\r\n    bytes32 internal constant CHAINLINK_ORACLE_WHITELIST = \"ChainlinkOracleWhitelist\";\r\n\r\n    IContractRegistry public registry;      // address of the current contract-registry\r\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\r\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\r\n\r\n    /**\r\n      * @dev verifies that the caller is mapped to the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n    */\r\n    modifier only(bytes32 _contractName) {\r\n        _only(_contractName);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _only(bytes32 _contractName) internal view {\r\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev initializes a new ContractRegistryClient instance\r\n      *\r\n      * @param  _registry   address of a contract-registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) internal validAddress(_registry) {\r\n        registry = IContractRegistry(_registry);\r\n        prevRegistry = IContractRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n      * @dev updates to the new contract-registry\r\n     */\r\n    function updateRegistry() public {\r\n        // verify that this function is permitted\r\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\r\n\r\n        // get the new contract-registry\r\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\r\n\r\n        // verify that the new contract-registry is different and not zero\r\n        require(newRegistry != address(registry) && newRegistry != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\r\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // save a backup of the current contract-registry before replacing it\r\n        prevRegistry = registry;\r\n\r\n        // replace the current contract-registry with the new contract-registry\r\n        registry = newRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restores the previous contract-registry\r\n    */\r\n    function restoreRegistry() public ownerOnly {\r\n        // restore the previous contract-registry\r\n        registry = prevRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restricts the permission to update the contract-registry\r\n      *\r\n      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\r\n    */\r\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\r\n        // change the permission to update the contract-registry\r\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n      *\r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        return registry.addressOf(_contractName);\r\n    }\r\n}\n\n// File: solidity/contracts/utility/ReentrancyGuard.sol\n\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev ReentrancyGuard\r\n  *\r\n  * The contract provides protection against re-entrancy - calling a function (directly or\r\n  * indirectly) from within itself.\r\n*/\r\ncontract ReentrancyGuard {\r\n    // true while protected code is being executed, false otherwise\r\n    bool private locked = false;\r\n\r\n    /**\r\n      * @dev ensures instantiation only by sub-contracts\r\n    */\r\n    constructor() internal {}\r\n\r\n    // protects a function against reentrancy attacks\r\n    modifier protected() {\r\n        _protected();\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _protected() internal view {\r\n        require(!locked, \"ERR_REENTRANCY\");\r\n    }\r\n}\n\n// File: solidity/contracts/utility/SafeMath.sol\n\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   value 1\r\n      * @param _y   value 2\r\n      *\r\n      * @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n      *\r\n      * @param _x   minuend\r\n      * @param _y   subtrahend\r\n      *\r\n      * @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   factor 1\r\n      * @param _y   factor 2\r\n      *\r\n      * @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n      *\r\n      * @param _x   dividend\r\n      * @param _y   divisor\r\n      *\r\n      * @return quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\n\n// File: solidity/contracts/utility/TokenHandler.sol\n\npragma solidity 0.4.26;\n\n\ncontract TokenHandler {\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n    /**\n      * @dev executes the ERC20 token's `approve` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _spender approved address\n      * @param _value   allowance amount\n    */\n    function safeApprove(IERC20Token _token, address _spender, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransfer(IERC20Token _token, address _to, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\n    }\n\n    /**\n      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _from    source address\n      * @param _to      target address\n      * @param _value   transfer amount\n    */\n    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n    }\n\n    /**\n      * @dev executes a function on the ERC20 token and reverts upon failure\n      * the main purpose of this function is to prevent a non standard ERC20 token\n      * from failing silently\n      *\n      * @param _token   ERC20 token address\n      * @param _data    data to pass in to the token's contract for execution\n    */\n    function execute(IERC20Token _token, bytes memory _data) private {\n        uint256[1] memory ret = [uint256(1)];\n\n        assembly {\n            let success := call(\n                gas,            // gas remaining\n                _token,         // destination address\n                0,              // no ether\n                add(_data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\n                mload(_data),   // input length (loaded from the first 32 bytes in the `data` array)\n                ret,            // output buffer\n                32              // output length\n            )\n            if iszero(success) {\n                revert(0, 0)\n            }\n        }\n\n        require(ret[0] != 0, \"ERR_TRANSFER_FAILED\");\n    }\n}\n\n// File: solidity/contracts/utility/TokenHolder.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\r\n\r\n/**\r\n  * @dev We consider every contract to be a 'token holder' since it's currently not possible\r\n  * for a contract to deny receiving tokens.\r\n  *\r\n  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n  * the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n  *\r\n  * Note that we use the non standard ERC-20 interface which has no return value for transfer\r\n  * in order to support both non standard as well as standard token contracts.\r\n  * see https://github.com/ethereum/solidity/issues/4116\r\n*/\r\ncontract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\r\n    /**\r\n      * @dev withdraws tokens held by the contract and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        safeTransfer(_token, _to, _amount);\r\n    }\r\n}\n\n// File: solidity/contracts/token/interfaces/IEtherToken.sol\n\npragma solidity 0.4.26;\n\n\n/*\n    Ether Token interface\n*/\ncontract IEtherToken is IERC20Token {\n    function deposit() public payable;\n    function withdraw(uint256 _amount) public;\n    function depositTo(address _to) public payable;\n    function withdrawTo(address _to, uint256 _amount) public;\n}\n\n// File: solidity/contracts/bancorx/interfaces/IBancorX.sol\n\npragma solidity 0.4.26;\n\n\ncontract IBancorX {\n    function token() public view returns (IERC20Token) {this;}\n    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) public;\n    function getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);\n}\n\n// File: solidity/contracts/converter/ConverterBase.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\r\r\r\r\r\r\r\r\n\r\n/**\r\n  * @dev ConverterBase\r\n  *\r\n  * The converter contains the main logic for conversions between different ERC20 tokens.\r\n  *\r\n  * It is also the upgradable part of the mechanism (note that upgrades are opt-in).\r\n  *\r\n  * The anchor must be set on construction and cannot be changed afterwards.\r\n  * Wrappers are provided for some of the anchor's functions, for easier access.\r\n  *\r\n  * Once the converter accepts ownership of the anchor, it becomes the anchor's sole controller\r\n  * and can execute any of its functions.\r\n  *\r\n  * To upgrade the converter, anchor ownership must be transferred to a new converter, along with\r\n  * any relevant data.\r\n  *\r\n  * Note that the converter can transfer anchor ownership to a new converter that\r\n  * doesn't allow upgrades anymore, for finalizing the relationship between the converter\r\n  * and the anchor.\r\n  *\r\n  * Converter types (defined as uint16 type) -\r\n  * 0 = liquid token converter\r\n  * 1 = liquidity pool v1 converter\r\n  * 2 = liquidity pool v2 converter\r\n  *\r\n  * Note that converters don't currently support tokens with transfer fees.\r\n*/\r\ncontract ConverterBase is IConverter, TokenHandler, TokenHolder, ContractRegistryClient, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    uint32 internal constant WEIGHT_RESOLUTION = 1000000;\r\n    uint64 internal constant CONVERSION_FEE_RESOLUTION = 1000000;\r\n    address internal constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    struct Reserve {\r\n        uint256 balance;    // reserve balance\r\n        uint32 weight;      // reserve weight, represented in ppm, 1-1000000\r\n        bool deprecated1;   // deprecated\r\n        bool deprecated2;   // deprecated\r\n        bool isSet;         // true if the reserve is valid, false otherwise\r\n    }\r\n\r\n    /**\r\n      * @dev version number\r\n    */\r\n    uint16 public constant version = 30;\r\n\r\n    IConverterAnchor public anchor;                 // converter anchor contract\r\n    IWhitelist public conversionWhitelist;          // whitelist contract with list of addresses that are allowed to use the converter\r\n    IERC20Token[] public reserveTokens;             // ERC20 standard token addresses (prior version 17, use 'connectorTokens' instead)\r\n    mapping (address => Reserve) public reserves;   // reserve token addresses -> reserve data (prior version 17, use 'connectors' instead)\r\n    uint32 public reserveRatio = 0;                 // ratio between the reserves and the market cap, equal to the total reserve weights\r\n    uint32 public maxConversionFee = 0;             // maximum conversion fee for the lifetime of the contract,\r\n                                                    // represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\r\n    uint32 public conversionFee = 0;                // current conversion fee, represented in ppm, 0...maxConversionFee\r\n    bool public constant conversionsEnabled = true; // deprecated, backward compatibility\r\n\r\n    /**\r\n      * @dev triggered when the converter is activated\r\n      *\r\n      * @param _type        converter type\r\n      * @param _anchor      converter anchor\r\n      * @param _activated   true if the converter was activated, false if it was deactivated\r\n    */\r\n    event Activation(uint16 indexed _type, IConverterAnchor indexed _anchor, bool indexed _activated);\r\n\r\n    /**\r\n      * @dev triggered when a conversion between two tokens occurs\r\n      *\r\n      * @param _fromToken       source ERC20 token\r\n      * @param _toToken         target ERC20 token\r\n      * @param _trader          wallet that initiated the trade\r\n      * @param _amount          amount converted, in the source token\r\n      * @param _return          amount returned, minus conversion fee\r\n      * @param _conversionFee   conversion fee\r\n    */\r\n    event Conversion(\r\n        address indexed _fromToken,\r\n        address indexed _toToken,\r\n        address indexed _trader,\r\n        uint256 _amount,\r\n        uint256 _return,\r\n        int256 _conversionFee\r\n    );\r\n\r\n    /**\r\n      * @dev triggered when the rate between two tokens in the converter changes\r\n      * note that the event might be dispatched for rate updates between any two tokens in the converter\r\n      * note that prior to version 28, you should use the 'PriceDataUpdate' event instead\r\n      *\r\n      * @param  _token1 address of the first token\r\n      * @param  _token2 address of the second token\r\n      * @param  _rateN  rate of 1 unit of `_token1` in `_token2` (numerator)\r\n      * @param  _rateD  rate of 1 unit of `_token1` in `_token2` (denominator)\r\n    */\r\n    event TokenRateUpdate(\r\n        address indexed _token1,\r\n        address indexed _token2,\r\n        uint256 _rateN,\r\n        uint256 _rateD\r\n    );\r\n\r\n    /**\r\n      * @dev triggered when the conversion fee is updated\r\n      *\r\n      * @param  _prevFee    previous fee percentage, represented in ppm\r\n      * @param  _newFee     new fee percentage, represented in ppm\r\n    */\r\n    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\r\n\r\n    /**\r\n      * @dev used by sub-contracts to initialize a new converter\r\n      *\r\n      * @param  _anchor             anchor governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(\r\n        IConverterAnchor _anchor,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee\r\n    )\r\n        validAddress(_anchor)\r\n        ContractRegistryClient(_registry)\r\n        internal\r\n        validConversionFee(_maxConversionFee)\r\n    {\r\n        anchor = _anchor;\r\n        maxConversionFee = _maxConversionFee;\r\n    }\r\n\r\n    // ensures that the converter is active\r\n    modifier active() {\r\n        _active();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _active() internal view {\r\n        require(isActive(), \"ERR_INACTIVE\");\r\n    }\r\n\r\n    // ensures that the converter is not active\r\n    modifier inactive() {\r\n        _inactive();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _inactive() internal view {\r\n        require(!isActive(), \"ERR_ACTIVE\");\r\n    }\r\n\r\n    // validates a reserve token address - verifies that the address belongs to one of the reserve tokens\r\n    modifier validReserve(IERC20Token _address) {\r\n        _validReserve(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validReserve(IERC20Token _address) internal view {\r\n        require(reserves[_address].isSet, \"ERR_INVALID_RESERVE\");\r\n    }\r\n\r\n    // validates conversion fee\r\n    modifier validConversionFee(uint32 _conversionFee) {\r\n        _validConversionFee(_conversionFee);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validConversionFee(uint32 _conversionFee) internal pure {\r\n        require(_conversionFee <= CONVERSION_FEE_RESOLUTION, \"ERR_INVALID_CONVERSION_FEE\");\r\n    }\r\n\r\n    // validates reserve weight\r\n    modifier validReserveWeight(uint32 _weight) {\r\n        _validReserveWeight(_weight);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validReserveWeight(uint32 _weight) internal pure {\r\n        require(_weight > 0 && _weight <= WEIGHT_RESOLUTION, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n    }\r\n\r\n    /**\r\n      * @dev deposits ether\r\n      * can only be called if the converter has an ETH reserve\r\n    */\r\n    function() external payable {\r\n        require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_INVALID_RESERVE\"); // require(hasETHReserve(), \"ERR_INVALID_RESERVE\");\r\n        // a workaround for a problem when running solidity-coverage\r\n        // see https://github.com/sc-forks/solidity-coverage/issues/487\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws ether\r\n      * can only be called by the owner if the converter is inactive or by upgrader contract\r\n      * can only be called after the upgrader contract has accepted the ownership of this contract\r\n      * can only be called if the converter has an ETH reserve\r\n      *\r\n      * @param _to  address to send the ETH to\r\n    */\r\n    function withdrawETH(address _to)\r\n        public\r\n        protected\r\n        ownerOnly\r\n        validReserve(IERC20Token(ETH_RESERVE_ADDRESS))\r\n    {\r\n        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\r\n\r\n        // verify that the converter is inactive or that the owner is the upgrader contract\r\n        require(!isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\r\n        _to.transfer(address(this).balance);\r\n\r\n        // sync the ETH reserve balance\r\n        syncReserveBalance(IERC20Token(ETH_RESERVE_ADDRESS));\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not the converter version is 28 or higher\r\n      *\r\n      * @return true, since the converter version is 28 or higher\r\n    */\r\n    function isV28OrHigher() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev allows the owner to update & enable the conversion whitelist contract address\r\n      * when set, only addresses that are whitelisted are actually allowed to use the converter\r\n      * note that the whitelist check is actually done by the BancorNetwork contract\r\n      *\r\n      * @param _whitelist    address of a whitelist contract\r\n    */\r\n    function setConversionWhitelist(IWhitelist _whitelist)\r\n        public\r\n        ownerOnly\r\n        notThis(_whitelist)\r\n    {\r\n        conversionWhitelist = _whitelist;\r\n    }\r\n\r\n    /**\r\n      * @dev returns true if the converter is active, false otherwise\r\n      *\r\n      * @return true if the converter is active, false otherwise\r\n    */\r\n    function isActive() public view returns (bool) {\r\n        return anchor.owner() == address(this);\r\n    }\r\n\r\n    /**\r\n      * @dev transfers the anchor ownership\r\n      * the new owner needs to accept the transfer\r\n      * can only be called by the converter upgrder while the upgrader is the owner\r\n      * note that prior to version 28, you should use 'transferAnchorOwnership' instead\r\n      *\r\n      * @param _newOwner    new token owner\r\n    */\r\n    function transferAnchorOwnership(address _newOwner)\r\n        public\r\n        ownerOnly\r\n        only(CONVERTER_UPGRADER)\r\n    {\r\n        anchor.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * most converters are also activated as soon as they accept the anchor ownership\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() public ownerOnly {\r\n        // verify the the converter has at least one reserve\r\n        require(reserveTokenCount() > 0, \"ERR_INVALID_RESERVE_COUNT\");\r\n        anchor.acceptOwnership();\r\n        syncReserveBalances();\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws tokens held by the anchor and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawFromAnchor(IERC20Token _token, address _to, uint256 _amount) public ownerOnly {\r\n        anchor.withdrawTokens(_token, _to, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev updates the current conversion fee\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _conversionFee new conversion fee, represented in ppm\r\n    */\r\n    function setConversionFee(uint32 _conversionFee) public ownerOnly {\r\n        require(_conversionFee <= maxConversionFee, \"ERR_INVALID_CONVERSION_FEE\");\r\n        emit ConversionFeeUpdate(conversionFee, _conversionFee);\r\n        conversionFee = _conversionFee;\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws tokens held by the converter and sends them to an account\r\n      * can only be called by the owner\r\n      * note that reserve tokens can only be withdrawn by the owner while the converter is inactive\r\n      * unless the owner is the converter upgrader contract\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public protected ownerOnly {\r\n        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\r\n\r\n        // if the token is not a reserve token, allow withdrawal\r\n        // otherwise verify that the converter is inactive or that the owner is the upgrader contract\r\n        require(!reserves[_token].isSet || !isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\r\n        super.withdrawTokens(_token, _to, _amount);\r\n\r\n        // if the token is a reserve token, sync the reserve balance\r\n        if (reserves[_token].isSet)\r\n            syncReserveBalance(_token);\r\n    }\r\n\r\n    /**\r\n      * @dev upgrades the converter to the latest version\r\n      * can only be called by the owner\r\n      * note that the owner needs to call acceptOwnership on the new converter after the upgrade\r\n    */\r\n    function upgrade() public ownerOnly {\r\n        IConverterUpgrader converterUpgrader = IConverterUpgrader(addressOf(CONVERTER_UPGRADER));\r\n\r\n        // trigger de-activation event\r\n        emit Activation(converterType(), anchor, false);\r\n\r\n        transferOwnership(converterUpgrader);\r\n        converterUpgrader.upgrade(version);\r\n        acceptOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of reserve tokens defined\r\n      * note that prior to version 17, you should use 'connectorTokenCount' instead\r\n      *\r\n      * @return number of reserve tokens\r\n    */\r\n    function reserveTokenCount() public view returns (uint16) {\r\n        return uint16(reserveTokens.length);\r\n    }\r\n\r\n    /**\r\n      * @dev defines a new reserve token for the converter\r\n      * can only be called by the owner while the converter is inactive\r\n      *\r\n      * @param _token   address of the reserve token\r\n      * @param _weight  reserve weight, represented in ppm, 1-1000000\r\n    */\r\n    function addReserve(IERC20Token _token, uint32 _weight)\r\n        public\r\n        ownerOnly\r\n        inactive\r\n        validAddress(_token)\r\n        notThis(_token)\r\n        validReserveWeight(_weight)\r\n    {\r\n        // validate input\r\n        require(_token != address(anchor) && !reserves[_token].isSet, \"ERR_INVALID_RESERVE\");\r\n        require(_weight <= WEIGHT_RESOLUTION - reserveRatio, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n        require(reserveTokenCount() < uint16(-1), \"ERR_INVALID_RESERVE_COUNT\");\r\n\r\n        Reserve storage newReserve = reserves[_token];\r\n        newReserve.balance = 0;\r\n        newReserve.weight = _weight;\r\n        newReserve.isSet = true;\r\n        reserveTokens.push(_token);\r\n        reserveRatio += _weight;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the reserve's weight\r\n      * added in version 28\r\n      *\r\n      * @param _reserveToken    reserve token contract address\r\n      *\r\n      * @return reserve weight\r\n    */\r\n    function reserveWeight(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint32)\r\n    {\r\n        return reserves[_reserveToken].weight;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the reserve's balance\r\n      * note that prior to version 17, you should use 'getConnectorBalance' instead\r\n      *\r\n      * @param _reserveToken    reserve token contract address\r\n      *\r\n      * @return reserve balance\r\n    */\r\n    function reserveBalance(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint256)\r\n    {\r\n        return reserves[_reserveToken].balance;\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not the converter has an ETH reserve\r\n      *\r\n      * @return true if the converter has an ETH reserve, false otherwise\r\n    */\r\n    function hasETHReserve() public view returns (bool) {\r\n        return reserves[ETH_RESERVE_ADDRESS].isSet;\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * can only be called by the bancor network contract\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function convert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address _beneficiary)\r\n        public\r\n        payable\r\n        protected\r\n        only(BANCOR_NETWORK)\r\n        returns (uint256)\r\n    {\r\n        // validate input\r\n        require(_sourceToken != _targetToken, \"ERR_SAME_SOURCE_TARGET\");\r\n\r\n        // if a whitelist is set, verify that both and trader and the beneficiary are whitelisted\r\n        require(conversionWhitelist == address(0) ||\r\n                (conversionWhitelist.isWhitelisted(_trader) && conversionWhitelist.isWhitelisted(_beneficiary)),\r\n                \"ERR_NOT_WHITELISTED\");\r\n\r\n        return doConvert(_sourceToken, _targetToken, _amount, _trader, _beneficiary);\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * called by ConverterBase and allows the inherited contracts to implement custom conversion logic\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address _beneficiary) internal returns (uint256);\r\n\r\n    /**\r\n      * @dev returns the conversion fee for a given target amount\r\n      *\r\n      * @param _targetAmount  target amount\r\n      *\r\n      * @return conversion fee\r\n    */\r\n    function calculateFee(uint256 _targetAmount) internal view returns (uint256) {\r\n        return _targetAmount.mul(conversionFee).div(CONVERSION_FEE_RESOLUTION);\r\n    }\r\n\r\n    /**\r\n      * @dev syncs the stored reserve balance for a given reserve with the real reserve balance\r\n      *\r\n      * @param _reserveToken    address of the reserve token\r\n    */\r\n    function syncReserveBalance(IERC20Token _reserveToken) internal validReserve(_reserveToken) {\r\n        if (_reserveToken == ETH_RESERVE_ADDRESS)\r\n            reserves[_reserveToken].balance = address(this).balance;\r\n        else\r\n            reserves[_reserveToken].balance = _reserveToken.balanceOf(this);\r\n    }\r\n\r\n    /**\r\n      * @dev syncs all stored reserve balances\r\n    */\r\n    function syncReserveBalances() internal {\r\n        uint256 reserveCount = reserveTokens.length;\r\n        for (uint256 i = 0; i < reserveCount; i++)\r\n            syncReserveBalance(reserveTokens[i]);\r\n    }\r\n\r\n    /**\r\n      * @dev helper, dispatches the Conversion event\r\n      *\r\n      * @param _sourceToken     source ERC20 token\r\n      * @param _targetToken     target ERC20 token\r\n      * @param _trader          address of the caller who executed the conversion\r\n      * @param _amount          amount purchased/sold (in the source token)\r\n      * @param _returnAmount    amount returned (in the target token)\r\n    */\r\n    function dispatchConversionEvent(\r\n        IERC20Token _sourceToken,\r\n        IERC20Token _targetToken,\r\n        address _trader,\r\n        uint256 _amount,\r\n        uint256 _returnAmount,\r\n        uint256 _feeAmount)\r\n        internal\r\n    {\r\n        // fee amount is converted to 255 bits -\r\n        // negative amount means the fee is taken from the source token, positive amount means its taken from the target token\r\n        // currently the fee is always taken from the target token\r\n        // since we convert it to a signed number, we first ensure that it's capped at 255 bits to prevent overflow\r\n        assert(_feeAmount < 2 ** 255);\r\n        emit Conversion(_sourceToken, _targetToken, _trader, _amount, _returnAmount, int256(_feeAmount));\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated since version 28, backward compatibility - use only for earlier versions\r\n    */\r\n    function token() public view returns (IConverterAnchor) {\r\n        return anchor;\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function transferTokenOwnership(address _newOwner) public ownerOnly {\r\n        transferAnchorOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function acceptTokenOwnership() public ownerOnly {\r\n        acceptAnchorOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) {\r\n        Reserve memory reserve = reserves[_address];\r\n        return(reserve.balance, reserve.weight, false, false, reserve.isSet);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectorTokens(uint256 _index) public view returns (IERC20Token) {\r\n        return ConverterBase.reserveTokens[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectorTokenCount() public view returns (uint16) {\r\n        return reserveTokenCount();\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256) {\r\n        return reserveBalance(_connectorToken);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getReturn(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256) {\r\n        return targetAmountAndFee(_sourceToken, _targetToken, _amount);\r\n    }\r\n}\n\n// File: solidity/contracts/converter/LiquidityPoolConverter.sol\n\npragma solidity 0.4.26;\r\r\n\r\n/**\r\n  * @dev Liquidity Pool Converter\r\n  *\r\n  * The liquidity pool converter is the base contract for specific types of converters that\r\n  * manage liquidity pools.\r\n  *\r\n  * Liquidity pools have 2 reserves or more and they allow converting between them.\r\n  *\r\n  * Note that TokenRateUpdate events are dispatched for pool tokens as well.\r\n  * The pool token is the first token in the event in that case.\r\n*/\r\ncontract LiquidityPoolConverter is ConverterBase {\r\n    /**\r\n      * @dev triggered after liquidity is added\r\n      *\r\n      * @param  _provider       liquidity provider\r\n      * @param  _reserveToken   reserve token address\r\n      * @param  _amount         reserve token amount\r\n      * @param  _newBalance     reserve token new balance\r\n      * @param  _newSupply      pool token new supply\r\n    */\r\n    event LiquidityAdded(\r\n        address indexed _provider,\r\n        address indexed _reserveToken,\r\n        uint256 _amount,\r\n        uint256 _newBalance,\r\n        uint256 _newSupply\r\n    );\r\n\r\n    /**\r\n      * @dev triggered after liquidity is removed\r\n      *\r\n      * @param  _provider       liquidity provider\r\n      * @param  _reserveToken   reserve token address\r\n      * @param  _amount         reserve token amount\r\n      * @param  _newBalance     reserve token new balance\r\n      * @param  _newSupply      pool token new supply\r\n    */\r\n    event LiquidityRemoved(\r\n        address indexed _provider,\r\n        address indexed _reserveToken,\r\n        uint256 _amount,\r\n        uint256 _newBalance,\r\n        uint256 _newSupply\r\n    );\r\n\r\n    /**\r\n      * @dev initializes a new LiquidityPoolConverter instance\r\n      *\r\n      * @param  _anchor             anchor governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(\r\n        IConverterAnchor _anchor,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee\r\n    )\r\n        ConverterBase(_anchor, _registry, _maxConversionFee)\r\n        internal\r\n    {\r\n    }\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * also activates the converter\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() public {\r\n        // verify that the converter has at least 2 reserves\r\n        require(reserveTokenCount() > 1, \"ERR_INVALID_RESERVE_COUNT\");\r\n        super.acceptAnchorOwnership();\r\n    }\r\n}\n\n// File: solidity/contracts/token/interfaces/ISmartToken.sol\n\npragma solidity 0.4.26;\n\n\n\n\n/*\n    Smart Token interface\n*/\ncontract ISmartToken is IConverterAnchor, IERC20Token {\n    function disableTransfers(bool _disable) public;\n    function issue(address _to, uint256 _amount) public;\n    function destroy(address _from, uint256 _amount) public;\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v1/LiquidityPoolV1Converter.sol\n\npragma solidity 0.4.26;\r\r\r\n\r\n/**\r\n  * @dev Liquidity Pool v1 Converter\r\n  *\r\n  * The liquidity pool v1 converter is a specialized version of a converter that manages\r\n  * a classic bancor liquidity pool.\r\n  *\r\n  * Even though classic pools can have many reserves, the most common configuration of\r\n  * the pool has 2 reserves with 50%/50% weights.\r\n*/\r\ncontract LiquidityPoolV1Converter is LiquidityPoolConverter {\r\n    IEtherToken internal etherToken = IEtherToken(0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315);\r\n\r\n    /**\r\n      * @dev triggered after a conversion with new price data\r\n      * deprecated, use `TokenRateUpdate` from version 28 and up\r\n      *\r\n      * @param  _connectorToken     reserve token\r\n      * @param  _tokenSupply        smart token supply\r\n      * @param  _connectorBalance   reserve balance\r\n      * @param  _connectorWeight    reserve weight\r\n    */\r\n    event PriceDataUpdate(\r\n        address indexed _connectorToken,\r\n        uint256 _tokenSupply,\r\n        uint256 _connectorBalance,\r\n        uint32 _connectorWeight\r\n    );\r\n\r\n    /**\r\n      * @dev initializes a new LiquidityPoolV1Converter instance\r\n      *\r\n      * @param  _token              pool token governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(\r\n        ISmartToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee\r\n    )\r\n        LiquidityPoolConverter(_token, _registry, _maxConversionFee)\r\n        public\r\n    {\r\n    }\r\n\r\n    /**\r\n      * @dev returns the converter type\r\n      *\r\n      * @return see the converter types in the the main contract doc\r\n    */\r\n    function converterType() public pure returns (uint16) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * also activates the converter\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() public ownerOnly {\r\n        super.acceptAnchorOwnership();\r\n\r\n        emit Activation(converterType(), anchor, true);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected target amount of converting one reserve to another along with the fee\r\n      *\r\n      * @param _sourceToken contract address of the source reserve token\r\n      * @param _targetToken contract address of the target reserve token\r\n      * @param _amount      amount of tokens received from the user\r\n      *\r\n      * @return expected target amount\r\n      * @return expected fee\r\n    */\r\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount)\r\n        public\r\n        view\r\n        active\r\n        validReserve(_sourceToken)\r\n        validReserve(_targetToken)\r\n        returns (uint256, uint256)\r\n    {\r\n        // validate input\r\n        require(_sourceToken != _targetToken, \"ERR_SAME_SOURCE_TARGET\");\r\n\r\n        uint256 amount = IBancorFormula(addressOf(BANCOR_FORMULA)).crossReserveTargetAmount(\r\n            reserveBalance(_sourceToken),\r\n            reserves[_sourceToken].weight,\r\n            reserveBalance(_targetToken),\r\n            reserves[_targetToken].weight,\r\n            _amount\r\n        );\r\n\r\n        // return the amount minus the conversion fee and the conversion fee\r\n        uint256 fee = calculateFee(amount);\r\n        return (amount - fee, fee);\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * can only be called by the bancor network contract\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address _beneficiary)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // get expected target amount and fee\r\n        (uint256 amount, uint256 fee) = targetAmountAndFee(_sourceToken, _targetToken, _amount);\r\n\r\n        // ensure that the trade gives something in return\r\n        require(amount != 0, \"ERR_ZERO_TARGET_AMOUNT\");\r\n\r\n        // ensure that the trade won't deplete the reserve balance\r\n        uint256 targetReserveBalance = reserveBalance(_targetToken);\r\n        assert(amount < targetReserveBalance);\r\n\r\n        // ensure that the input amount was already deposited\r\n        if (_sourceToken == ETH_RESERVE_ADDRESS)\r\n            require(msg.value == _amount, \"ERR_ETH_AMOUNT_MISMATCH\");\r\n        else\r\n            require(msg.value == 0 && _sourceToken.balanceOf(this).sub(reserveBalance(_sourceToken)) >= _amount, \"ERR_INVALID_AMOUNT\");\r\n\r\n        // sync the reserve balances\r\n        syncReserveBalance(_sourceToken);\r\n        reserves[_targetToken].balance = reserves[_targetToken].balance.sub(amount);\r\n\r\n        // transfer funds to the beneficiary in the to reserve token\r\n        if (_targetToken == ETH_RESERVE_ADDRESS)\r\n            _beneficiary.transfer(amount);\r\n        else\r\n            safeTransfer(_targetToken, _beneficiary, amount);\r\n\r\n        // dispatch the conversion event\r\n        dispatchConversionEvent(_sourceToken, _targetToken, _trader, _amount, amount, fee);\r\n\r\n        // dispatch rate updates\r\n        dispatchRateEvents(_sourceToken, _targetToken);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev increases the pool's liquidity and mints new shares in the pool to the caller\r\n      * note that prior to version 28, you should use 'fund' instead\r\n      *\r\n      * @param _reserveTokens   address of each reserve token\r\n      * @param _reserveAmounts  amount of each reserve token\r\n      * @param _minReturn       token minimum return-amount\r\n    */\r\n    function addLiquidity(IERC20Token[] memory _reserveTokens, uint256[] memory _reserveAmounts, uint256 _minReturn)\r\n        public\r\n        payable\r\n        protected\r\n        active\r\n    {\r\n        // verify the user input\r\n        verifyLiquidityInput(_reserveTokens, _reserveAmounts, _minReturn);\r\n\r\n        // if one of the reserves is ETH, then verify that the input amount of ETH is equal to the input value of ETH\r\n        for (uint256 i = 0; i < _reserveTokens.length; i++)\r\n            if (_reserveTokens[i] == ETH_RESERVE_ADDRESS)\r\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\r\n\r\n        // if the input value of ETH is larger than zero, then verify that one of the reserves is ETH\r\n        if (msg.value > 0)\r\n            require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_NO_ETH_RESERVE\");\r\n\r\n        // get the total supply\r\n        uint256 totalSupply = ISmartToken(anchor).totalSupply();\r\n\r\n        // transfer from the user an equally-worth amount of each one of the reserve tokens\r\n        uint256 amount = addLiquidityToPool(_reserveTokens, _reserveAmounts, totalSupply);\r\n\r\n        // verify that the equivalent amount of tokens is equal to or larger than the user's expectation\r\n        require(amount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\r\n\r\n        // issue the tokens to the user\r\n        ISmartToken(anchor).issue(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n      * @dev decreases the pool's liquidity and burns the caller's shares in the pool\r\n      * note that prior to version 28, you should use 'liquidate' instead\r\n      *\r\n      * @param _amount                  token amount\r\n      * @param _reserveTokens           address of each reserve token\r\n      * @param _reserveMinReturnAmounts minimum return-amount of each reserve token\r\n    */\r\n    function removeLiquidity(uint256 _amount, IERC20Token[] memory _reserveTokens, uint256[] memory _reserveMinReturnAmounts)\r\n        public\r\n        protected\r\n        active\r\n    {\r\n        // verify the user input\r\n        verifyLiquidityInput(_reserveTokens, _reserveMinReturnAmounts, _amount);\r\n\r\n        // get the total supply BEFORE destroying the user tokens\r\n        uint256 totalSupply = ISmartToken(anchor).totalSupply();\r\n\r\n        // destroy the user tokens\r\n        ISmartToken(anchor).destroy(msg.sender, _amount);\r\n\r\n        // transfer to the user an equivalent amount of each one of the reserve tokens\r\n        removeLiquidityFromPool(_reserveTokens, _reserveMinReturnAmounts, totalSupply, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev increases the pool's liquidity and mints new shares in the pool to the caller\r\n      * for example, if the caller increases the supply by 10%,\r\n      * then it will cost an amount equal to 10% of each reserve token balance\r\n      * note that starting from version 28, you should use 'addLiquidity' instead\r\n      *\r\n      * @param _amount  amount to increase the supply by (in the pool token)\r\n    */\r\n    function fund(uint256 _amount) public payable protected {\r\n        syncReserveBalances();\r\n        reserves[ETH_RESERVE_ADDRESS].balance = reserves[ETH_RESERVE_ADDRESS].balance.sub(msg.value);\r\n\r\n        uint256 supply = ISmartToken(anchor).totalSupply();\r\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\r\n\r\n        // iterate through the reserve tokens and transfer a percentage equal to the weight between\r\n        // _amount and the total supply in each reserve from the caller to the converter\r\n        uint256 reserveCount = reserveTokens.length;\r\n        for (uint256 i = 0; i < reserveCount; i++) {\r\n            IERC20Token reserveToken = reserveTokens[i];\r\n            uint256 rsvBalance = reserves[reserveToken].balance;\r\n            uint256 reserveAmount = formula.fundCost(supply, rsvBalance, reserveRatio, _amount);\r\n\r\n            // transfer funds from the caller in the reserve token\r\n            if (reserveToken == ETH_RESERVE_ADDRESS) {\r\n                if (msg.value > reserveAmount) {\r\n                    msg.sender.transfer(msg.value - reserveAmount);\r\n                }\r\n                else if (msg.value < reserveAmount) {\r\n                    require(msg.value == 0, \"ERR_INVALID_ETH_VALUE\");\r\n                    safeTransferFrom(etherToken, msg.sender, this, reserveAmount);\r\n                    etherToken.withdraw(reserveAmount);\r\n                }\r\n            }\r\n            else {\r\n                safeTransferFrom(reserveToken, msg.sender, this, reserveAmount);\r\n            }\r\n\r\n            // sync the reserve balance\r\n            uint256 newReserveBalance = rsvBalance.add(reserveAmount);\r\n            reserves[reserveToken].balance = newReserveBalance;\r\n\r\n            uint256 newPoolTokenSupply = supply.add(_amount);\r\n\r\n            // dispatch liquidity update for the pool token/reserve\r\n            emit LiquidityAdded(msg.sender, reserveToken, reserveAmount, newReserveBalance, newPoolTokenSupply);\r\n\r\n            // dispatch the `TokenRateUpdate` event for the pool token\r\n            uint32 reserveWeight = reserves[reserveToken].weight;\r\n            dispatchPoolTokenRateEvent(newPoolTokenSupply, reserveToken, newReserveBalance, reserveWeight);\r\n        }\r\n\r\n        // issue new funds to the caller in the pool token\r\n        ISmartToken(anchor).issue(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev decreases the pool's liquidity and burns the caller's shares in the pool\r\n      * for example, if the holder sells 10% of the supply,\r\n      * then they will receive 10% of each reserve token balance in return\r\n      * note that starting from version 28, you should use 'removeLiquidity' instead\r\n      *\r\n      * @param _amount  amount to liquidate (in the pool token)\r\n    */\r\n    function liquidate(uint256 _amount) public protected {\r\n        require(_amount > 0, \"ERR_ZERO_AMOUNT\");\r\n\r\n        uint256 totalSupply = ISmartToken(anchor).totalSupply();\r\n        ISmartToken(anchor).destroy(msg.sender, _amount);\r\n\r\n        uint256[] memory reserveMinReturnAmounts = new uint256[](reserveTokens.length);\r\n        for (uint256 i = 0; i < reserveMinReturnAmounts.length; i++)\r\n            reserveMinReturnAmounts[i] = 1;\r\n\r\n        removeLiquidityFromPool(reserveTokens, reserveMinReturnAmounts, totalSupply, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev verifies that a given array of tokens is identical to the converter's array of reserve tokens\r\n      * we take this input in order to allow specifying the corresponding reserve amounts in any order\r\n      *\r\n      * @param _reserveTokens   array of reserve tokens\r\n      * @param _reserveAmounts  array of reserve amounts\r\n      * @param _amount          token amount\r\n    */\r\n    function verifyLiquidityInput(IERC20Token[] memory _reserveTokens, uint256[] memory _reserveAmounts, uint256 _amount) private view {\r\n        uint256 i;\r\n        uint256 j;\r\n\r\n        uint256 length = reserveTokens.length;\r\n        require(length == _reserveTokens.length, \"ERR_INVALID_RESERVE\");\r\n        require(length == _reserveAmounts.length, \"ERR_INVALID_AMOUNT\");\r\n\r\n        for (i = 0; i < length; i++) {\r\n            // verify that every input reserve token is included in the reserve tokens\r\n            require(reserves[_reserveTokens[i]].isSet, \"ERR_INVALID_RESERVE\");\r\n            for (j = 0; j < length; j++) {\r\n                if (reserveTokens[i] == _reserveTokens[j])\r\n                    break;\r\n            }\r\n            // verify that every reserve token is included in the input reserve tokens\r\n            require(j < length, \"ERR_INVALID_RESERVE\");\r\n            // verify that every input reserve token amount is larger than zero\r\n            require(_reserveAmounts[i] > 0, \"ERR_INVALID_AMOUNT\");\r\n        }\r\n\r\n        // verify that the input token amount is larger than zero\r\n        require(_amount > 0, \"ERR_ZERO_AMOUNT\");\r\n    }\r\n\r\n    /**\r\n      * @dev adds liquidity (reserve) to the pool\r\n      *\r\n      * @param _reserveTokens   address of each reserve token\r\n      * @param _reserveAmounts  amount of each reserve token\r\n      * @param _totalSupply     token total supply\r\n    */\r\n    function addLiquidityToPool(IERC20Token[] memory _reserveTokens, uint256[] memory _reserveAmounts, uint256 _totalSupply)\r\n        private\r\n        returns (uint256)\r\n    {\r\n        if (_totalSupply == 0)\r\n            return addLiquidityToEmptyPool(_reserveTokens, _reserveAmounts);\r\n        return addLiquidityToNonEmptyPool(_reserveTokens, _reserveAmounts, _totalSupply);\r\n    }\r\n\r\n    /**\r\n      * @dev adds liquidity (reserve) to the pool when it's empty\r\n      *\r\n      * @param _reserveTokens   address of each reserve token\r\n      * @param _reserveAmounts  amount of each reserve token\r\n    */\r\n    function addLiquidityToEmptyPool(IERC20Token[] memory _reserveTokens, uint256[] memory _reserveAmounts)\r\n        private\r\n        returns (uint256)\r\n    {\r\n        // calculate the geometric-mean of the reserve amounts approved by the user\r\n        uint256 amount = geometricMean(_reserveAmounts);\r\n\r\n        // transfer each one of the reserve amounts from the user to the pool\r\n        for (uint256 i = 0; i < _reserveTokens.length; i++) {\r\n            if (_reserveTokens[i] != ETH_RESERVE_ADDRESS) // ETH has already been transferred as part of the transaction\r\n                safeTransferFrom(_reserveTokens[i], msg.sender, this, _reserveAmounts[i]);\r\n\r\n            reserves[_reserveTokens[i]].balance = _reserveAmounts[i];\r\n\r\n            emit LiquidityAdded(msg.sender, _reserveTokens[i], _reserveAmounts[i], _reserveAmounts[i], amount);\r\n\r\n            // dispatch the `TokenRateUpdate` event for the pool token\r\n            uint32 reserveWeight = reserves[_reserveTokens[i]].weight;\r\n            dispatchPoolTokenRateEvent(amount, _reserveTokens[i], _reserveAmounts[i], reserveWeight);\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev adds liquidity (reserve) to the pool when it's not empty\r\n      *\r\n      * @param _reserveTokens   address of each reserve token\r\n      * @param _reserveAmounts  amount of each reserve token\r\n      * @param _totalSupply     token total supply\r\n    */\r\n    function addLiquidityToNonEmptyPool(IERC20Token[] memory _reserveTokens, uint256[] memory _reserveAmounts, uint256 _totalSupply)\r\n        private\r\n        returns (uint256)\r\n    {\r\n        syncReserveBalances();\r\n        reserves[ETH_RESERVE_ADDRESS].balance = reserves[ETH_RESERVE_ADDRESS].balance.sub(msg.value);\r\n\r\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\r\n        uint256 amount = getMinShare(formula, _totalSupply, _reserveTokens, _reserveAmounts);\r\n        uint256 newPoolTokenSupply = _totalSupply.add(amount);\r\n\r\n        for (uint256 i = 0; i < _reserveTokens.length; i++) {\r\n            IERC20Token reserveToken = _reserveTokens[i];\r\n            uint256 rsvBalance = reserves[reserveToken].balance;\r\n            uint256 reserveAmount = formula.fundCost(_totalSupply, rsvBalance, reserveRatio, amount);\r\n            require(reserveAmount > 0, \"ERR_ZERO_TARGET_AMOUNT\");\r\n            assert(reserveAmount <= _reserveAmounts[i]);\r\n\r\n            // transfer each one of the reserve amounts from the user to the pool\r\n            if (reserveToken != ETH_RESERVE_ADDRESS) // ETH has already been transferred as part of the transaction\r\n                safeTransferFrom(reserveToken, msg.sender, this, reserveAmount);\r\n            else if (_reserveAmounts[i] > reserveAmount) // transfer the extra amount of ETH back to the user\r\n                msg.sender.transfer(_reserveAmounts[i] - reserveAmount);\r\n\r\n            uint256 newReserveBalance = rsvBalance.add(reserveAmount);\r\n            reserves[reserveToken].balance = newReserveBalance;\r\n\r\n            emit LiquidityAdded(msg.sender, reserveToken, reserveAmount, newReserveBalance, newPoolTokenSupply);\r\n\r\n            // dispatch the `TokenRateUpdate` event for the pool token\r\n            uint32 reserveWeight = reserves[_reserveTokens[i]].weight;\r\n            dispatchPoolTokenRateEvent(newPoolTokenSupply, _reserveTokens[i], newReserveBalance, reserveWeight);\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev removes liquidity (reserve) from the pool\r\n      *\r\n      * @param _reserveTokens           address of each reserve token\r\n      * @param _reserveMinReturnAmounts minimum return-amount of each reserve token\r\n      * @param _totalSupply             token total supply\r\n      * @param _amount                  token amount\r\n    */\r\n    function removeLiquidityFromPool(IERC20Token[] memory _reserveTokens, uint256[] memory _reserveMinReturnAmounts, uint256 _totalSupply, uint256 _amount)\r\n        private\r\n    {\r\n        syncReserveBalances();\r\n\r\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\r\n        uint256 newPoolTokenSupply = _totalSupply.sub(_amount);\r\n\r\n        for (uint256 i = 0; i < _reserveTokens.length; i++) {\r\n            IERC20Token reserveToken = _reserveTokens[i];\r\n            uint256 rsvBalance = reserves[reserveToken].balance;\r\n            uint256 reserveAmount = formula.liquidateReserveAmount(_totalSupply, rsvBalance, reserveRatio, _amount);\r\n            require(reserveAmount >= _reserveMinReturnAmounts[i], \"ERR_ZERO_TARGET_AMOUNT\");\r\n\r\n            uint256 newReserveBalance = rsvBalance.sub(reserveAmount);\r\n            reserves[reserveToken].balance = newReserveBalance;\r\n\r\n            // transfer each one of the reserve amounts from the pool to the user\r\n            if (reserveToken == ETH_RESERVE_ADDRESS)\r\n                msg.sender.transfer(reserveAmount);\r\n            else\r\n                safeTransfer(reserveToken, msg.sender, reserveAmount);\r\n\r\n            emit LiquidityRemoved(msg.sender, reserveToken, reserveAmount, newReserveBalance, newPoolTokenSupply);\r\n\r\n            // dispatch the `TokenRateUpdate` event for the pool token\r\n            uint32 reserveWeight = reserves[reserveToken].weight;\r\n            dispatchPoolTokenRateEvent(newPoolTokenSupply, reserveToken, newReserveBalance, reserveWeight);\r\n        }\r\n    }\r\n\r\n    function getMinShare(IBancorFormula formula, uint256 _totalSupply, IERC20Token[] memory _reserveTokens, uint256[] memory _reserveAmounts) private view returns (uint256) {\r\n        uint256 minIndex = 0;\r\n        for (uint256 i = 1; i < _reserveTokens.length; i++) {\r\n            if (_reserveAmounts[i].mul(reserves[_reserveTokens[minIndex]].balance) < _reserveAmounts[minIndex].mul(reserves[_reserveTokens[i]].balance))\r\n                minIndex = i;\r\n        }\r\n        return formula.fundSupplyAmount(_totalSupply, reserves[_reserveTokens[minIndex]].balance, reserveRatio, _reserveAmounts[minIndex]);\r\n    }\r\n\r\n    /**\r\n      * @dev calculates the number of decimal digits in a given value\r\n      *\r\n      * @param _x   value (assumed positive)\r\n      * @return the number of decimal digits in the given value\r\n    */\r\n    function decimalLength(uint256 _x) public pure returns (uint256) {\r\n        uint256 y = 0;\r\n        for (uint256 x = _x; x > 0; x /= 10)\r\n            y++;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n      * @dev calculates the nearest integer to a given quotient\r\n      *\r\n      * @param _n   quotient numerator\r\n      * @param _d   quotient denominator\r\n      * @return the nearest integer to the given quotient\r\n    */\r\n    function roundDiv(uint256 _n, uint256 _d) public pure returns (uint256) {\r\n        return (_n + _d / 2) / _d;\r\n    }\r\n\r\n    /**\r\n      * @dev calculates the average number of decimal digits in a given list of values\r\n      *\r\n      * @param _values  list of values (each of which assumed positive)\r\n      * @return the average number of decimal digits in the given list of values\r\n    */\r\n    function geometricMean(uint256[] memory _values) public pure returns (uint256) {\r\n        uint256 numOfDigits = 0;\r\n        uint256 length = _values.length;\r\n        for (uint256 i = 0; i < length; i++)\r\n            numOfDigits += decimalLength(_values[i]);\r\n        return uint256(10) ** (roundDiv(numOfDigits, length) - 1);\r\n    }\r\n\r\n     /**\r\n      * @dev dispatches rate events for both reserves / pool tokens\r\n      * only used to circumvent the `stack too deep` compiler error\r\n      *\r\n      * @param _sourceToken address of the source reserve token\r\n      * @param _targetToken address of the target reserve token\r\n    */\r\n    function dispatchRateEvents(IERC20Token _sourceToken, IERC20Token _targetToken) private {\r\n        uint256 poolTokenSupply = ISmartToken(anchor).totalSupply();\r\n        uint256 sourceReserveBalance = reserveBalance(_sourceToken);\r\n        uint256 targetReserveBalance = reserveBalance(_targetToken);\r\n        uint32 sourceReserveWeight = reserves[_sourceToken].weight;\r\n        uint32 targetReserveWeight = reserves[_targetToken].weight;\r\n\r\n        // dispatch token rate update event\r\n        uint256 rateN = targetReserveBalance.mul(sourceReserveWeight);\r\n        uint256 rateD = sourceReserveBalance.mul(targetReserveWeight);\r\n        emit TokenRateUpdate(_sourceToken, _targetToken, rateN, rateD);\r\n\r\n        // dispatch the `TokenRateUpdate` event for the pool token\r\n        dispatchPoolTokenRateEvent(poolTokenSupply, _sourceToken, sourceReserveBalance, sourceReserveWeight);\r\n        dispatchPoolTokenRateEvent(poolTokenSupply, _targetToken, targetReserveBalance, targetReserveWeight);\r\n\r\n        // dispatch price data update events (deprecated events)\r\n        emit PriceDataUpdate(_sourceToken, poolTokenSupply, sourceReserveBalance, sourceReserveWeight);\r\n        emit PriceDataUpdate(_targetToken, poolTokenSupply, targetReserveBalance, targetReserveWeight);\r\n    }\r\n\r\n    /**\r\n      * @dev dispatches the `TokenRateUpdate` for the pool token\r\n      * only used to circumvent the `stack too deep` compiler error\r\n      *\r\n      * @param _poolTokenSupply total pool token supply\r\n      * @param _reserveToken    address of the reserve token\r\n      * @param _reserveBalance  reserve balance\r\n      * @param _reserveWeight   reserve weight\r\n    */\r\n    function dispatchPoolTokenRateEvent(uint256 _poolTokenSupply, IERC20Token _reserveToken, uint256 _reserveBalance, uint32 _reserveWeight) private {\r\n        emit TokenRateUpdate(anchor, _reserveToken, _reserveBalance.mul(WEIGHT_RESOLUTION), _poolTokenSupply.mul(_reserveWeight));\r\n    }\r\n}\n\n// File: solidity/contracts/converter/interfaces/ITypedConverterFactory.sol\n\npragma solidity 0.4.26;\n\n\n\n\n/*\n    Typed Converter Factory interface\n*/\ncontract ITypedConverterFactory {\n    function converterType() public pure returns (uint16);\n    function createConverter(IConverterAnchor _anchor, IContractRegistry _registry, uint32 _maxConversionFee) public returns (IConverter);\n}\n\n// File: solidity/contracts/converter/types/liquidity-pool-v1/LiquidityPoolV1ConverterFactory.sol\n\npragma solidity 0.4.26;\r\r\r\r\r\n\r\n/*\r\n    LiquidityPoolV1Converter Factory\r\n*/\r\ncontract LiquidityPoolV1ConverterFactory is ITypedConverterFactory {\r\n    /**\r\n      * @dev returns the converter type the factory is associated with\r\n      *\r\n      * @return converter type\r\n    */\r\n    function converterType() public pure returns (uint16) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n      * @dev creates a new converter with the given arguments and transfers\r\n      * the ownership to the caller\r\n      *\r\n      * @param _anchor            anchor governed by the converter\r\n      * @param _registry          address of a contract registry contract\r\n      * @param _maxConversionFee  maximum conversion fee, represented in ppm\r\n      *\r\n      * @return a new converter\r\n    */\r\n    function createConverter(IConverterAnchor _anchor, IContractRegistry _registry, uint32 _maxConversionFee) public returns (IConverter) {\r\n        IConverter converter = new LiquidityPoolV1Converter(ISmartToken(_anchor), _registry, _maxConversionFee);\r\n        converter.transferOwnership(msg.sender);\r\n        return converter;\r\n    }\r\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_anchor\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_maxConversionFee\",\"type\":\"uint32\"}],\"name\":\"createConverter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"converterType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"LiquidityPoolV1ConverterFactory","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}