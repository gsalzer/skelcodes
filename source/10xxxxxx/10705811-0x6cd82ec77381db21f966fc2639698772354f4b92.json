{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.9;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n  function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n}\r\n\r\ncontract HYDRAStaking {\r\n\r\n    using SafeMath for uint;\r\n\r\n    address private immutable sdcpToken;\r\n    address private immutable v2Pair;\r\n\r\n    uint8 private immutable sdcpDec;\r\n\r\n    uint constant DAY =  60 * 60 * 24; \r\n\r\n    uint constant RATE = 10000;\r\n    uint constant LEAST = 500;\r\n\r\n    address _owner;\r\n    uint public bonus = 0;\r\n\r\n    constructor(address sdcp , address v2) public {\r\n      _owner = msg.sender;\r\n      sdcpToken = sdcp;\r\n      sdcpDec = IERC20(sdcp).decimals();\r\n      v2Pair = v2;\r\n      require(IUniswapV2Pair(v2).token0() == sdcp || IUniswapV2Pair(v2).token1() == sdcp, \"E/no sdcp\");\r\n    }\r\n\r\n    struct Staking {\r\n      uint amount;\r\n      uint stakeTime;\r\n      uint earnTime;   \r\n    }\r\n\r\n    mapping(address => Staking) V2Stakings;\r\n    mapping(address => Staking) SDCPStakings;\r\n\r\n\r\n    mapping(uint => uint) dayPrices;\r\n\r\n    mapping(uint => bool) raiseOver10;\r\n\r\n    \r\n    function myV2Staking() external view returns (uint, uint, uint ) {\r\n      return (V2Stakings[msg.sender].amount, V2Stakings[msg.sender].stakeTime, myV2Earn());\r\n    }\r\n\r\n    function stakingV2(uint amount) external {\r\n      require(V2Stakings[msg.sender].amount == 0, \"E/aleady staking\");\r\n      require(IERC20(v2Pair).transferFrom(msg.sender, address(this), amount), \"E/transfer error\");\r\n      V2Stakings[msg.sender] = Staking(amount, now, now);\r\n    }\r\n\r\n    \r\n    function wdV2(uint amount) external {\r\n      uint stakingToal = V2Stakings[msg.sender].amount;\r\n      uint stakingTime = V2Stakings[msg.sender].stakeTime;\r\n\r\n      require(stakingToal >= amount, \"E/not enough\");\r\n      require(now >= stakingTime + 2 * DAY, \"E/locked\");\r\n\r\n     \r\n      wdV2Earn() ;\r\n\r\n      IERC20(v2Pair).transfer(msg.sender, amount);\r\n\r\n     \r\n      if(stakingToal - amount > 0) {\r\n        V2Stakings[msg.sender] = Staking(stakingToal - amount, now, now);\r\n      } else {\r\n        delete V2Stakings[msg.sender];\r\n      }\r\n    }\r\n\r\n    \r\n    function myV2Earn() internal view returns (uint) {\r\n      Staking memory s = V2Stakings[msg.sender];\r\n      if(s.amount == 0) {\r\n        return 0;\r\n      }\r\n\r\n      uint endDay = getDay(now);\r\n      uint startDay = getDay(s.earnTime);\r\n      if(endDay > startDay) {\r\n        uint earnDays = endDay - startDay;\r\n\r\n        uint earns = 0;\r\n        if(earnDays > 0) {\r\n          earns = s.amount.mul(earnDays).mul(RATE).div(10 ** (uint(18).sub(sdcpDec)));\r\n        }\r\n        return earns;\r\n      } \r\n      return 0;\r\n    }\r\n\r\n    function wdV2Earn() public {\r\n      uint earnsTotal = myV2Earn();\r\n      uint fee = earnsTotal * 8 / 100;\r\n      bonus = bonus.add(fee);\r\n\r\n      IERC20(sdcpToken).transfer(msg.sender, earnsTotal.sub(fee));\r\n      V2Stakings[msg.sender].earnTime = now;\r\n    }\r\n\r\n    // ----- for sdcp staking  ------\r\n    function mySDCPStaking() external view returns (uint, uint, uint ) {\r\n      return (SDCPStakings[msg.sender].amount, SDCPStakings[msg.sender].stakeTime, mySDCPEarn());\r\n    }\r\n\r\n    function stakingSDCP(uint amount) external {\r\n      require(amount >= LEAST * 10 ** uint(sdcpDec), \"E/not enough\");\r\n      require(SDCPStakings[msg.sender].amount == 0, \"E/aleady staking\");\r\n      require(IERC20(sdcpToken).transferFrom(msg.sender, address(this), amount), \"E/transfer error\");\r\n      \r\n      SDCPStakings[msg.sender] = Staking(amount, now, now);\r\n    }\r\n\r\n    function wdSDCP(uint amount) external {\r\n      uint stakingToal = SDCPStakings[msg.sender].amount;\r\n      require(stakingToal >= amount, \"E/not enough\");\r\n\r\n      wdSDCPEarn();\r\n      \r\n      if(stakingToal - amount >= LEAST * 10 ** uint(sdcpDec)) {\r\n        \r\n        uint fee = amount * 8 / 100;\r\n        bonus = bonus.add(fee);\r\n\r\n        IERC20(sdcpToken).transfer(msg.sender, amount.sub(fee));\r\n        SDCPStakings[msg.sender] = Staking(stakingToal - amount, now, now);\r\n      } else {\r\n        \r\n        uint fee = stakingToal * 8 / 100;\r\n        bonus = bonus.add(fee);\r\n\r\n        IERC20(sdcpToken).transfer(msg.sender, stakingToal.sub(fee));\r\n        delete SDCPStakings[msg.sender];\r\n      }\r\n    }\r\n\r\n    \r\n    function mySDCPEarn() internal view returns (uint) {\r\n      Staking memory s = SDCPStakings[msg.sender];\r\n      if(s.amount == 0) {\r\n        return 0;\r\n      }\r\n\r\n      uint earnDays = getEarnDays(s);\r\n      uint earns = 0;\r\n      if(earnDays > 0) {\r\n        earns = s.amount.div(100) * earnDays;\r\n      }\r\n      return earns;\r\n    }\r\n\r\n    \r\n\r\n    function wdSDCPEarn() public {\r\n      uint earnsTotal = mySDCPEarn();\r\n\r\n      uint fee = earnsTotal * 8 / 100;\r\n      bonus = bonus.add(fee);\r\n\r\n      IERC20(sdcpToken).transfer(msg.sender, earnsTotal.sub(fee));\r\n\r\n      SDCPStakings[msg.sender].earnTime = now;\r\n    }\r\n\r\n    \r\n    function getEarnDays(Staking memory s) internal view returns (uint) {\r\n    \r\n      uint startDay = getDay(s.earnTime);\r\n    \r\n      uint endDay = getDay(now);\r\n\r\n    \r\n      uint earnDays = 0;\r\n      while(endDay > startDay) {\r\n        if(raiseOver10[startDay]) {\r\n          earnDays += 1;\r\n        }\r\n        startDay += 1;\r\n      }\r\n      return earnDays;\r\n    }\r\n\r\n    // get 1 sdcp  =  x eth\r\n    function fetchPrice() internal view returns (uint) {\r\n      (uint reserve0, uint reserve1,) = IUniswapV2Pair(v2Pair).getReserves();\r\n      require(reserve0 > 0 && reserve1 > 0, 'E/INSUFFICIENT_LIQUIDITY');\r\n      uint oneSdcp = 10 ** uint(sdcpDec);  \r\n\r\n      if(IUniswapV2Pair(v2Pair).token0() == sdcpToken) {\r\n        return oneSdcp.mul(reserve1) / reserve0;\r\n      } else {\r\n        return oneSdcp.mul(reserve0) / reserve1;\r\n      }\r\n    }\r\n\r\n    \r\n    function getDay(uint ts) internal pure returns (uint) {   \r\n      return ts / DAY;\r\n    }\r\n\r\n    \r\n    function updatePrice() external {\r\n    \r\n      uint d = getDay(now);\r\n    \r\n      uint p = fetchPrice();\r\n\r\n      dayPrices[d] = p;\r\n      \r\n      uint lastPrice = dayPrices[d-1];\r\n      \r\n      if(lastPrice > 0) {\r\n\r\n        if(p > lastPrice.add(lastPrice/10)) {\r\n          raiseOver10[d] = true;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n      require(isOwner(), \"Ownable: caller is not the owner\");\r\n      _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n      return _owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      _owner = newOwner;\r\n    }\r\n\r\n    function withdrawSDCP(uint amount) external onlyOwner {\r\n      IERC20(sdcpToken).transfer(msg.sender, amount);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sdcp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"v2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"bonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mySDCPStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myV2Staking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakingSDCP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakingV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wdSDCP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wdSDCPEarn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wdV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wdV2Earn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSDCP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"HYDRAStaking","CompilerVersion":"v0.6.9+commit.3e3065ac","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001e79691646dd50c92efc4db591b0ba05c7e264c5000000000000000000000000179e433a7df70d91c0537cfcad368bcd668322cf","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9596b42a20e2cea41f714b97445084337b3348204fcc39580be7df682f3426e8"}]}