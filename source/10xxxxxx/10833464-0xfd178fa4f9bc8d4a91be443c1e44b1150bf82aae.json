{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-07-10\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface UniswapV2 {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    \r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\n\r\ninterface PreviousLiquidityContract {\r\n    function emergencyWithdrawLiquidityTokens() external;\r\n    function getStaker(address _staker) external view returns (uint, uint);\r\n}\r\n\r\n\r\ninterface Minter {\r\n    function liquidityRewards(address recipient, uint amount) external;\r\n}\r\n\r\n\r\n// Liquidity pool allows a user to stake Uniswap liquidity tokens (tokens representaing shares of USDT and PAMP tokens in the Uniswap liquidity pool)\r\n// Users receive rewards in tokens for locking up their liquidity\r\ncontract LiquidityPool {\r\n    using SafeMath for uint256;\r\n    \r\n    \r\n    IERC20 public uniswapPair;\r\n    \r\n    IERC20 public pampToken;\r\n    \r\n    IERC20 public secondToken;\r\n    \r\n    PreviousLiquidityContract public previousContract;\r\n    \r\n    Minter public minter;\r\n    \r\n    address public owner;\r\n    \r\n    uint public minStakeDurationDays;\r\n    \r\n    uint public rewardAdjustmentFactor;\r\n    \r\n    bool public stakingEnabled;\r\n    \r\n    bool public exponentialRewardsEnabled;\r\n    \r\n    uint public exponentialDaysMax;\r\n    \r\n    UniswapV2 public uniswapV2;\r\n    \r\n    struct staker {\r\n        uint startTimestamp;        // Unix timestamp of when the tokens were initially staked\r\n        uint lastTimestamp;         // Last time tokens were locked or reinvested\r\n        uint poolTokenBalance;      // Balance of Uniswap liquidity tokens\r\n        uint lockedRewardBalance;   // Locked rewards in PAMP\r\n        bool hasMigrated;           // Has staker migrated from previous liquidity contract\r\n    }\r\n    \r\n    mapping(address => staker) public stakers;\r\n    mapping(address => uint) public previousContractBalances;\r\n    \r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    \r\n    constructor() public {\r\n        uniswapPair = IERC20(0xDb7299106d86dDe6A3978b532149b98f17cdFf3C);\r\n        pampToken = IERC20(0xF0FAC7104aAC544e4a7CE1A55ADF2B5a25c65bD1);\r\n        uniswapV2 = UniswapV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        minter = Minter(0x7425fc3B4Bd8def8E74f67F238d4860A5AEBf3bF);\r\n        secondToken = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n        minStakeDurationDays = 2;\r\n        owner = msg.sender;\r\n        rewardAdjustmentFactor = 25E19;\r\n        stakingEnabled = true;\r\n        exponentialRewardsEnabled = true;\r\n        exponentialDaysMax = 60;\r\n        pampToken.approve(address(uniswapV2), 100000000E18);\r\n    }\r\n    \r\n    \r\n    function stakeLiquidityTokens(uint256 numPoolTokensToStake) external {\r\n        \r\n        require(numPoolTokensToStake > 0);\r\n        require(stakingEnabled, \"Staking is currently disabled.\");\r\n        \r\n        uint previousBalance = uniswapPair.balanceOf(address(this));                    \r\n        \r\n        uniswapPair.transferFrom(msg.sender, address(this), numPoolTokensToStake);      // Transfer liquidity tokens from the sender to this contract\r\n        \r\n        uint postBalance = uniswapPair.balanceOf(address(this));\r\n        \r\n        require(previousBalance.add(numPoolTokensToStake) == postBalance);              // This is a sanity check and likely not required as the Uniswap token is ERC20\r\n        \r\n        staker storage thisStaker = stakers[msg.sender];                                // Get the sender's information\r\n        \r\n        if(thisStaker.startTimestamp == 0 || thisStaker.poolTokenBalance == 0) {\r\n            thisStaker.startTimestamp = block.timestamp;\r\n            thisStaker.lastTimestamp = block.timestamp;\r\n            thisStaker.hasMigrated = true;\r\n        } else {                                                                        // If the sender is currently staking, adding to his balance results in a holding time penalty\r\n            uint percent = mulDiv(1000000, numPoolTokensToStake, thisStaker.poolTokenBalance);      // This is not really 'percent' it is just a number that represents the totalAmount as a fraction of the recipientBalance\r\n            assert(percent > 0);\r\n            if(percent > 1) {\r\n                percent = percent.div(2);           // We divide the 'penalty' by 2 so that the penalty is not as bad\r\n            }\r\n            if(percent.add(thisStaker.startTimestamp) > block.timestamp) {         // We represent the 'percent' or 'penalty' as seconds and add to the recipient's unix time\r\n               thisStaker.startTimestamp = block.timestamp; // Receiving too many tokens resets your holding time\r\n            } else {\r\n                thisStaker.startTimestamp = thisStaker.startTimestamp.add(percent);               \r\n            }\r\n        }\r\n        \r\n         \r\n        thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.add(numPoolTokensToStake);\r\n\r\n    }\r\n    \r\n    function addLiquidity(uint _numTokensToReinvest, uint _numSecondTokensToInvest) external {      // This allows you to add liquidity without the burn penalty\r\n        pampToken.transferFrom(msg.sender, address(this), _numTokensToReinvest);\r\n        secondToken.transferFrom(msg.sender, address(this), _numSecondTokensToInvest);\r\n        (uint amountToken, uint amountETH, uint liquidity) = uniswapV2.addLiquidity(address(pampToken), address(secondToken), _numTokensToReinvest, _numSecondTokensToInvest, 0, 0, address(this), now+86400);  // Adding liquidity to Uniswap via the router\r\n        \r\n        staker storage thisStaker = stakers[msg.sender];                                // Get the sender's information\r\n        \r\n        if(thisStaker.startTimestamp == 0 || thisStaker.poolTokenBalance == 0) {\r\n            thisStaker.startTimestamp = block.timestamp;\r\n            thisStaker.lastTimestamp = block.timestamp;\r\n            thisStaker.hasMigrated = true;\r\n        } else {                                                                        // If the sender is currently staking, adding to his balance results in a holding time penalty\r\n            uint percent = mulDiv(1000000, liquidity, thisStaker.poolTokenBalance);      // This is not really 'percent' it is just a number that represents the totalAmount as a fraction of the recipientBalance\r\n            assert(percent > 0);\r\n            if(percent > 1) {\r\n                percent = percent.div(2);           // We divide the 'penalty' by 2 so that the penalty is not as bad\r\n            }\r\n            if(percent.add(thisStaker.startTimestamp) > block.timestamp) {         // We represent the 'percent' or 'penalty' as seconds and add to the recipient's unix time\r\n               thisStaker.startTimestamp = block.timestamp; // Receiving too many tokens resets your holding time\r\n            } else {\r\n                thisStaker.startTimestamp = thisStaker.startTimestamp.add(percent);               \r\n            }\r\n        }\r\n        \r\n         \r\n        thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.add(liquidity);\r\n    }\r\n    \r\n    /*function migrateState() external {\r\n        staker storage thisStaker = stakers[msg.sender]; \r\n        require(!thisStaker.hasMigrated, \"You have already migrated\");\r\n\r\n        \r\n        (uint startTimestamp, uint poolTokenBalance) = previousContract.getStaker(msg.sender);\r\n        \r\n        \r\n        thisStaker.startTimestamp = startTimestamp;\r\n        thisStaker.lastTimestamp = startTimestamp;\r\n        thisStaker.hasMigrated = true;\r\n        previousContractBalances[msg.sender] = poolTokenBalance;\r\n    }\r\n    \r\n    function migrateTokens() external {\r\n        staker storage thisStaker = stakers[msg.sender]; \r\n        uniswapPair.transferFrom(msg.sender, address(this), previousContractBalances[msg.sender]);\r\n        thisStaker.poolTokenBalance = previousContractBalances[msg.sender];\r\n    }*/\r\n    \r\n    // Withdraw liquidity tokens, pretty self-explanatory\r\n    function withdrawLiquidityTokens(uint256 numPoolTokensToWithdraw) external {\r\n        \r\n        require(numPoolTokensToWithdraw > 0);\r\n        \r\n        staker storage thisStaker = stakers[msg.sender];\r\n        \r\n        require(thisStaker.hasMigrated, \"You must migrate\");\r\n                \r\n        require(thisStaker.poolTokenBalance >= numPoolTokensToWithdraw, \"Pool token balance too low\");\r\n        \r\n        uint daysStaked = block.timestamp.sub(thisStaker.startTimestamp) / 86400;  // Calculate time staked in days\r\n        \r\n        require(daysStaked >= minStakeDurationDays);\r\n        \r\n        uint tokensOwed = calculateTokensOwed(msg.sender);      // We give all of the rewards owed to the sender on a withdrawal, regardless of the amount withdrawn\r\n        \r\n        tokensOwed = tokensOwed.add(thisStaker.lockedRewardBalance);\r\n        \r\n        thisStaker.lockedRewardBalance = 0;\r\n        thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.sub(numPoolTokensToWithdraw);\r\n        \r\n        thisStaker.startTimestamp = block.timestamp; // Reset staking timer on withdrawal\r\n        thisStaker.lastTimestamp = block.timestamp;\r\n        \r\n        minter.liquidityRewards(msg.sender, tokensOwed);            \r\n        \r\n        uniswapPair.transfer(msg.sender, numPoolTokensToWithdraw);\r\n    }\r\n    \r\n    function withdrawRewards() external {\r\n        \r\n        staker storage thisStaker = stakers[msg.sender];\r\n        \r\n        uint daysStaked = block.timestamp.sub(thisStaker.startTimestamp) / 86400;  // Calculate time staked in days\r\n        \r\n        require(daysStaked >= minStakeDurationDays);\r\n        \r\n        uint tokensOwed = calculateTokensOwed(msg.sender);\r\n        \r\n        tokensOwed = tokensOwed.add(thisStaker.lockedRewardBalance);\r\n        \r\n        thisStaker.lockedRewardBalance = 0;\r\n        thisStaker.startTimestamp = block.timestamp; // Reset staking timer on withdrawal\r\n        thisStaker.lastTimestamp = block.timestamp;\r\n        \r\n        minter.liquidityRewards(msg.sender, tokensOwed);            \r\n    }\r\n    \r\n    function lockRewards() external {\r\n        \r\n        uint currentRewards = calculateTokensOwed(msg.sender);\r\n        \r\n        staker storage thisStaker = stakers[msg.sender];\r\n        thisStaker.lastTimestamp = block.timestamp;\r\n        thisStaker.lockedRewardBalance = thisStaker.lockedRewardBalance.add(currentRewards);\r\n        \r\n    }\r\n    \r\n    function reinvestRewards(bool locked, uint _numTokensToReinvest, uint _numSecondTokensToInvest) external {\r\n        \r\n        staker storage thisStaker = stakers[msg.sender];\r\n        \r\n        if(locked) {\r\n            thisStaker.lockedRewardBalance = thisStaker.lockedRewardBalance.sub(_numTokensToReinvest);  \r\n            minter.liquidityRewards(address(this), _numTokensToReinvest);\r\n            secondToken.transferFrom(msg.sender, address(this), _numSecondTokensToInvest);      // Second token needs to be approved to be spent by this contract\r\n            (uint amountToken, uint amountETH, uint liquidity) = uniswapV2.addLiquidity(address(pampToken), address(secondToken), _numTokensToReinvest, _numSecondTokensToInvest, 0, 0, address(this), now+86400);  // Adding liquidity to Uniswap via the router\r\n            thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.add(liquidity);\r\n            \r\n        } else {\r\n            uint numTokensToReinvest = calculateTokensOwed(msg.sender);\r\n            thisStaker.lastTimestamp = block.timestamp;\r\n            minter.liquidityRewards(address(this), numTokensToReinvest);\r\n            secondToken.transferFrom(msg.sender, address(this), _numSecondTokensToInvest);\r\n            (uint amountToken, uint amountETH, uint liquidity) = uniswapV2.addLiquidity(address(pampToken), address(secondToken), numTokensToReinvest, _numSecondTokensToInvest, 0, 0, address(this), now+86400);\r\n            thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.add(liquidity);\r\n        }\r\n    }\r\n    \r\n    // If you call this function you forfeit your rewards\r\n    function emergencyWithdrawLiquidityTokens() external {\r\n        staker storage thisStaker = stakers[msg.sender];\r\n        uint poolTokenBalance = thisStaker.poolTokenBalance;\r\n        thisStaker.poolTokenBalance = 0;\r\n        thisStaker.startTimestamp = block.timestamp;\r\n        thisStaker.lastTimestamp = block.timestamp;\r\n        thisStaker.lockedRewardBalance = 0;\r\n        uniswapPair.transfer(msg.sender, poolTokenBalance);\r\n    }\r\n    \r\n    function calculateTokensOwed(address stakerAddr) public view returns (uint256) {\r\n        \r\n        staker memory thisStaker = stakers[stakerAddr];\r\n        \r\n        uint totalDaysStaked = block.timestamp.sub(thisStaker.startTimestamp) / 86400;  // Calculate time staked in days\r\n        uint daysSinceLast = block.timestamp.sub(thisStaker.lastTimestamp) / 86400;\r\n        \r\n        uint tokens = mulDiv(daysSinceLast.mul(rewardAdjustmentFactor), thisStaker.poolTokenBalance, uniswapPair.totalSupply()); // The formula is as follows: tokens owned = (days staked * reward adjustment factor) * (sender liquidity token balance / total supply of liquidity token)\r\n        \r\n        if(totalDaysStaked > exponentialDaysMax) {\r\n            totalDaysStaked = exponentialDaysMax;\r\n        }\r\n        \r\n        if(exponentialRewardsEnabled) {\r\n            return tokens * totalDaysStaked;\r\n        } else {\r\n            return tokens;\r\n        }\r\n        \r\n        \r\n    }\r\n    \r\n    function calculateMonthlyYield() public view returns (uint256) {\r\n        uint tokensInPool = pampToken.balanceOf(address(uniswapPair));\r\n        uint tokens = 30 * mulDiv(30 * rewardAdjustmentFactor, 1, 2); // Tokens given per month for 50% of pool (50% because APY should also consider ETH contribution)\r\n        return mulDiv(10000, tokens, tokensInPool);\r\n        \r\n    }\r\n    \r\n    function updateUniswapPair(address _uniswapPair) external onlyOwner {\r\n        uniswapPair = IERC20(_uniswapPair);\r\n    }\r\n    \r\n    function updateUinswapV2(address _uniswapv2) external onlyOwner {\r\n        uniswapV2 = UniswapV2(_uniswapv2);\r\n        pampToken.approve(address(uniswapV2), 100000000E18);\r\n    }\r\n    \r\n    function updatePampToken(address _pampToken) external onlyOwner {\r\n        pampToken = IERC20(_pampToken);\r\n    }\r\n    \r\n    function updateMinter(address _minter) external onlyOwner {\r\n        minter = Minter(_minter);\r\n    }\r\n    \r\n    function updatePreviousLiquidityContract(address _previousContract) external onlyOwner {\r\n        previousContract = PreviousLiquidityContract(_previousContract);\r\n    }\r\n    \r\n    function updateMinStakeDurationDays(uint _minStakeDurationDays) external onlyOwner {\r\n        minStakeDurationDays = _minStakeDurationDays;\r\n    }\r\n    \r\n    function updateRewardAdjustmentFactor(uint _rewardAdjustmentFactor) external onlyOwner {\r\n        rewardAdjustmentFactor = _rewardAdjustmentFactor;\r\n    }\r\n    \r\n    function updateStakingEnabled(bool _stakingEnbaled) external onlyOwner {\r\n        stakingEnabled = _stakingEnbaled;\r\n    }\r\n    \r\n    function updateExponentialRewardsEnabled(bool _exponentialRewards) external onlyOwner {\r\n        exponentialRewardsEnabled = _exponentialRewards;\r\n    }\r\n    \r\n    function updateExponentialDaysMax(uint _exponentialDaysMax) external onlyOwner {\r\n        exponentialDaysMax = _exponentialDaysMax;\r\n    }\r\n    \r\n    function updateSecondToken(address _secondToken) external onlyOwner {\r\n        secondToken = IERC20(_secondToken);\r\n        secondToken.approve(address(uniswapV2), 100000000E18);\r\n    }\r\n    \r\n    function transferPampTokens(uint _numTokens) external onlyOwner {\r\n        pampToken.transfer(msg.sender, _numTokens);\r\n    }\r\n    \r\n    function transferSecondTokens(uint _numTokens) external onlyOwner {\r\n        secondToken.transfer(msg.sender, _numTokens);\r\n    }\r\n    \r\n    function giveMeDayStart() external onlyOwner {\r\n        stakers[owner].startTimestamp = stakers[owner].startTimestamp.sub(86400);\r\n    }\r\n    \r\n    function giveMeDayLast() external onlyOwner {\r\n        stakers[owner].lastTimestamp = stakers[owner].lastTimestamp.sub(86400);\r\n    }\r\n    \r\n    \r\n    function getStaker(address _staker) external view returns (uint, uint, uint, uint, bool) {\r\n        return (stakers[_staker].startTimestamp, stakers[_staker].lastTimestamp, stakers[_staker].poolTokenBalance, stakers[_staker].lockedRewardBalance, stakers[_staker].hasMigrated);\r\n    }\r\n    \r\n    \r\n     function mulDiv (uint x, uint y, uint z) public pure returns (uint) {\r\n          (uint l, uint h) = fullMul (x, y);\r\n          assert (h < z);\r\n          uint mm = mulmod (x, y, z);\r\n          if (mm > l) h -= 1;\r\n          l -= mm;\r\n          uint pow2 = z & -z;\r\n          z /= pow2;\r\n          l /= pow2;\r\n          l += h * ((-pow2) / pow2 + 1);\r\n          uint r = 1;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          return l * r;\r\n    }\r\n    \r\n    function fullMul (uint x, uint y) private pure returns (uint l, uint h) {\r\n          uint mm = mulmod (x, y, uint (-1));\r\n          l = x * y;\r\n          h = mm - l;\r\n          if (mm < l) h -= 1;\r\n    }\r\n    \r\n    fallback() external payable {}\r\n    receive() external payable {}\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numTokensToReinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numSecondTokensToInvest\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateMonthlyYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddr\",\"type\":\"address\"}],\"name\":\"calculateTokensOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exponentialDaysMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exponentialRewardsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getStaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"giveMeDayLast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"giveMeDayStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakeDurationDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"contract Minter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pampToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousContract\",\"outputs\":[{\"internalType\":\"contract PreviousLiquidityContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"previousContractBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_numTokensToReinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numSecondTokensToInvest\",\"type\":\"uint256\"}],\"name\":\"reinvestRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAdjustmentFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numPoolTokensToStake\",\"type\":\"uint256\"}],\"name\":\"stakeLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedRewardBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasMigrated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"transferPampTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"transferSecondTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2\",\"outputs\":[{\"internalType\":\"contract UniswapV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exponentialDaysMax\",\"type\":\"uint256\"}],\"name\":\"updateExponentialDaysMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_exponentialRewards\",\"type\":\"bool\"}],\"name\":\"updateExponentialRewardsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeDurationDays\",\"type\":\"uint256\"}],\"name\":\"updateMinStakeDurationDays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"updateMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pampToken\",\"type\":\"address\"}],\"name\":\"updatePampToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_previousContract\",\"type\":\"address\"}],\"name\":\"updatePreviousLiquidityContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardAdjustmentFactor\",\"type\":\"uint256\"}],\"name\":\"updateRewardAdjustmentFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_secondToken\",\"type\":\"address\"}],\"name\":\"updateSecondToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_stakingEnbaled\",\"type\":\"bool\"}],\"name\":\"updateStakingEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapv2\",\"type\":\"address\"}],\"name\":\"updateUinswapV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapPair\",\"type\":\"address\"}],\"name\":\"updateUniswapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numPoolTokensToWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdrawLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LiquidityPool","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c7003f6b7bc252c14a266a53588b18f7c393f79fac98e350efcb00aa7144845e"}]}