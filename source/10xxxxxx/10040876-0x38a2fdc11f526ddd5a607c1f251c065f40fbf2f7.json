{"status":"1","message":"OK","result":[{"SourceCode":"{\"Ownable.sol\":{\"content\":\"pragma solidity 0.6.6;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address public owner;\\n\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n}\"},\"PhoenixDAO.sol\":{\"content\":\"/**\\n *Submitted for verification at Etherscan.io on 2020-05-10\\n*/\\n\\npragma solidity 0.6.6;\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ninterface PhoenixAuth {\\n    function authenticate(address _sender, uint _value, uint _challenge, uint _partnerId) external;\\n}\\n\\ninterface tokenRecipient {\\n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;\\n}\\n\\ncontract PhoenixDAO is Ownable {\\n    using SafeMath for uint256;\\n\\n    string public name = \\\"PhoenixDAO\\\";           //The Token\\u0027s name: e.g. DigixDAO Tokens\\n    uint8 public decimals = 18;             //Number of decimals of the smallest unit\\n    string public symbol = \\\"PHNX\\\";         //An identifier: e.g. REP\\n    uint public totalSupply;\\n    address public phoenixAuthAddress = address(0);\\n    address public initialOwner;\\n\\n    mapping (address =\\u003e uint256) public balances;\\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowed;\\n\\n////////////////\\n// Constructor\\n////////////////\\n\\n    /// @notice Constructor to create a PhoenixToken\\n    constructor() public {\\n        totalSupply = 110000000 * 10**18;\\n        // Give the creator all initial tokens\\n        balances[msg.sender] = totalSupply;\\n        initialOwner = msg.sender;\\n    }\\n\\n\\n///////////////////\\n// ERC20 Methods\\n///////////////////\\n\\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\\n    /// @param _to The address of the recipient\\n    /// @param _amount The amount of tokens to be transferred\\n    /// @return success Whether the transfer was successful or not\\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\\n        doTransfer(msg.sender, _to, _amount);\\n        return true;\\n    }\\n\\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\\n    ///  is approved by `_from`\\n    /// @param _from The address holding the tokens being transferred\\n    /// @param _to The address of the recipient\\n    /// @param _amount The amount of tokens to be transferred\\n    /// @return success True if the transfer was successful\\n    function transferFrom(address _from, address _to, uint256 _amount\\n    ) public returns (bool success) {\\n        // The standard ERC 20 transferFrom functionality\\n        require(allowed[_from][msg.sender] \\u003e= _amount);\\n        allowed[_from][msg.sender] -= _amount;\\n        doTransfer(_from, _to, _amount);\\n        return true;\\n    }\\n\\n    /// @dev This is the actual transfer function in the token contract, it can\\n    ///  only be called by other functions in this contract.\\n    /// @param _from The address holding the tokens being transferred\\n    /// @param _to The address of the recipient\\n    /// @param _amount The amount of tokens to be transferred\\n    function doTransfer(address _from, address _to, uint _amount\\n    ) internal {\\n        // Do not allow transfer to 0x0 or the token contract itself\\n        require((_to != address(0)) \\u0026\\u0026 (_to != address(this)));\\n        require(_amount \\u003c= balances[_from]);\\n        balances[_from] = balances[_from].sub(_amount);\\n        balances[_to] = balances[_to].add(_amount);\\n        emit Transfer(_from, _to, _amount);\\n    }\\n\\n    /// @param _owner address to check balance for\\n    /// @return balance The balance of `_owner`\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\n        return balances[_owner];\\n    }\\n\\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\\n    ///  its behalf. This is a modified version of the ERC20 approve function\\n    ///  to be a little bit safer\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @param _amount The amount of tokens to be approved for transfer\\n    /// @return success True if the approval was successful\\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\\n        // To change the approve amount you first have to reduce the addresses`\\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\\n        //  already 0 to mitigate the race condition described here:\\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\\n\\n        allowed[msg.sender][_spender] = _amount;\\n        emit Approval(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n\\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\\n        tokenRecipient spender = tokenRecipient(_spender);\\n        if (approve(_spender, _value)) {\\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\\n            return true;\\n        }\\n    }\\n\\n    /// @dev This function burns _value amount of tokens from msg.sender account. Can be executed only by owner. \\n    /// @param _value Amount of tokens to burn.\\n    function burn(uint256 _value) public onlyOwner {\\n        require(balances[msg.sender] \\u003e= _value);\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        totalSupply = totalSupply.sub(_value);\\n    }\\n\\n    /// @dev This function makes it easy to read the `allowed[]` map\\n    /// @param _owner The address of the account that owns the token\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @return remaining Amount of remaining tokens of _owner that _spender is allowed\\n    ///  to spend\\n    function allowance(address _owner, address _spender\\n    ) public view returns (uint256 remaining) {\\n        return allowed[_owner][_spender];\\n    }\\n\\n\\n    function setPhoenixAuthAddress(address _auth) public onlyOwner {\\n        phoenixAuthAddress = _auth;\\n        \\n    }\\n\\n    function authenticate(uint _value, uint _challenge, uint _partnerId) public {\\n        PhoenixAuth phoenix = PhoenixAuth(phoenixAuthAddress);\\n        phoenix.authenticate(msg.sender, _value, _challenge, _partnerId);\\n        doTransfer(msg.sender, owner, _value);\\n    }\\n\\n    function setBalances(address[] memory  _addressList, uint[] memory _amounts) public onlyOwner {\\n        require(_addressList.length == _amounts.length);\\n        for (uint i = 0; i \\u003c _addressList.length; i++) {\\n          require(balances[_addressList[i]] == 0);\\n          transfer(_addressList[i], _amounts[i]);\\n        }\\n    }\\n\\n    \\n    event Transfer(address indexed _from,address indexed _to,uint256 _amount);\\n\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _spender,\\n        uint256 _amount\\n        );\\n\\n    event Burn(\\n        address indexed _burner,\\n        uint256 _amount\\n        );\\n    \\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.6.6;\\n\\n\\n/**\\n* @title SafeMath\\n* @dev Math operations with safety checks that throw on error\\n*/\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n    \\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_burner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_challenge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_partnerId\",\"type\":\"uint256\"}],\"name\":\"authenticate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phoenixAuthAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addressList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_auth\",\"type\":\"address\"}],\"name\":\"setPhoenixAuthAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PhoenixDAO","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://14e74e081c0572619bdeb771d3f8d0d0131d8f0c336e1905b8f9ec0839681943"}]}