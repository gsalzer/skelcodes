{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n /**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function percent(uint value,uint numerator, uint denominator, uint precision) internal pure  returns(uint quotient) {\r\n        uint _numerator  = numerator * 10 ** (precision+1);\r\n        uint _quotient =  ((_numerator / denominator) + 5) / 10;\r\n        return (value*_quotient/1000000000000000000);\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract Receiver {\r\n    function sendFundsTo(address tracker, uint256 amount, address receiver) public returns (bool) {\r\n        return ERC20(tracker).transfer(receiver, amount);\r\n    }\r\n}\r\n\r\ncontract DLTS {\r\n    \r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    \r\n    string public name                                      = \"DLTS2.0\";\r\n    string public symbol                                    = \"DLTS\";\r\n    uint8 constant public decimals                          = 18;\r\n    uint8 constant internal dividendFee_                    = 5;\r\n    uint8 constant internal referralPer_                    = 20;\r\n    uint8 constant internal developerFee_                   = 5;\r\n   \r\n\tuint256 internal stakePer_                              = 250000000000000000;\r\n\tuint256 internal sellPer_                               = 5000000000000000000;\r\n    uint256 constant internal tokenPriceInitial_            = 0.0025 ether;\r\n    uint256 constant internal tokenPriceIncremental_        = 0.0000001 ether;\r\n    uint256 constant internal tokenPriceDecremental_        = 0.00000015 ether;\r\n    uint256 constant internal dltxPrice_                    = 0.004 ether;\r\n    uint256 constant internal magnitude                     = 2**64;\r\n    \r\n   \r\n    uint256 public stakingRequirement                       = 1e18;\r\n    \r\n    // Ambassador program\r\n    mapping(address => bool) internal ambassadors_;\r\n    uint256 constant internal ambassadorMaxPurchase_        = 1 ether;\r\n    uint256 constant internal ambassadorQuota_              = 1 ether;\r\n    \r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    \r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) internal stakeBalanceLedger_;\r\n    mapping(address => uint256) internal stakingTime_;\r\n    mapping(address => uint256) internal sellTime_;\r\n    mapping(address => uint256) internal referralBalance_;\r\n    mapping(address => uint256) public DLTXbuying_;\r\n    mapping(address => uint256) public DLTXbuyingETHamt_;\r\n    mapping(address => address) public receiversMap;\r\n    \r\n    mapping(address => address) internal referralLevel1Address;\r\n    mapping(address => address) internal referralLevel2Address;\r\n    mapping(address => address) internal referralLevel3Address;\r\n    mapping(address => address) internal referralLevel4Address;\r\n    mapping(address => address) internal referralLevel5Address;\r\n    mapping(address => address) internal referralLevel6Address;\r\n    mapping(address => address) internal referralLevel7Address;\r\n    mapping(address => address) internal referralLevel8Address;\r\n    mapping(address => address) internal referralLevel9Address;\r\n    mapping(address => address) internal referralLevel10Address;\r\n    \r\n    mapping(address => int256) internal payoutsTo_;\r\n    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\r\n    uint256 internal tokenSupply_                           = 0;\r\n    uint256 internal developerBalance                       = 0;\r\n   \r\n    uint256 internal profitPerShare_;\r\n    \r\n  \r\n    mapping(bytes32 => bool) public administrators;\r\n    \r\n    bool public onlyAmbassadors = false;\r\n    \r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    \r\n     // Only people with tokens\r\n    modifier onlybelievers () {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n    \r\n    // Only people with profits\r\n    modifier onlyhodler() {\r\n        require(myDividends(true) > 0);\r\n        _;\r\n    }\r\n    \r\n    // Only admin\r\n    modifier onlyAdministrator(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[keccak256(_customerAddress)]);\r\n        _;\r\n    }\r\n\t \r\n    \r\n    modifier antiEarlyWhale(uint256 _amountOfEthereum){\r\n        address _customerAddress = msg.sender;\r\n        if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){\r\n            require(\r\n                // is the customer in the ambassador list?\r\n                ambassadors_[_customerAddress] == true &&\r\n                // does the customer purchase exceed the max ambassador quota?\r\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_\r\n            );\r\n            // updated the accumulated quota    \r\n            ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\r\n            _;\r\n        } else {\r\n            // in case the ether count drops low, the ambassador phase won't reinitiate\r\n            onlyAmbassadors = false;\r\n            _;    \r\n        }\r\n    }\r\n    \r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    \r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n    \r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n    \r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n    \r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    \r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    \r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS --  \r\n    */\r\n    function DLTS() public {\r\n        // add administrators here\r\n        administrators[0x444dab79bea484e63b43f800cdc20827aa809c843c419350c3263082287a9e27] = true;\r\n        \r\n        ambassadors_[0x0000000000000000000000000000000000000000] = true;\r\n    }\r\n     \r\n    /**\r\n     * BUY\r\n     */\r\n    function buy(address _referredBy) public payable returns(uint256) {\r\n        purchaseTokens(msg.value, _referredBy);\r\n    }\r\n    \r\n    function() payable public {\r\n        purchaseTokens(msg.value, 0x0);\r\n    }\r\n    \r\n    /**\r\n     * REINVEST\r\n     */\r\n    function reinvest() onlyhodler() public {\r\n        \r\n        uint256 _dividends                  = myDividends(false); // retrieve ref. bonus later in the code\r\n        \r\n        address _customerAddress            = msg.sender;\r\n        payoutsTo_[_customerAddress]        +=  (int256) (_dividends * magnitude);\r\n        \r\n        _dividends                          += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress]  = 0;\r\n        \r\n        uint256 _tokens                     = purchaseTokens(_dividends, 0x0);\r\n        // fire event\r\n        onReinvestment(_customerAddress, _dividends, _tokens);\r\n    }\r\n    \r\n    /**\r\n     * EXIT\r\n     */\r\n    function exit() public {\r\n        \r\n        address _customerAddress            = msg.sender;\r\n        uint256 _tokens                     = tokenBalanceLedger_[_customerAddress];\r\n        if(_tokens > 0) sell();\r\n        withdraw();\r\n    }\r\n\r\n    /**\r\n     * WITHDRAW\r\n     */\r\n    function withdraw() onlyhodler() public {\r\n        \r\n        address _customerAddress            = msg.sender;\r\n        uint256 _dividends                  = myDividends(false); // get ref. bonus later in the code\r\n        \r\n        payoutsTo_[_customerAddress]        +=  (int256) (_dividends * magnitude);\r\n        \r\n        _dividends                          += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress]  = 0;\r\n        \r\n        _customerAddress.transfer(_dividends);\r\n        // fire event\r\n        onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    \r\n    /**\r\n     * SELL\r\n     */\r\n    function sell() onlybelievers () public {\r\n        address _customerAddress                = msg.sender;\r\n\t\tuint8  sellFee_\t                    \t=1;\r\n\t\t\r\n\t\t  uint256 timediff                      = SafeMath.sub(now, sellTime_[_customerAddress]);\r\n\t        if (timediff >= 86400){\r\n\t\t\t\tuint256 _amountOfTokens \t\t\t= tokenBalanceLedger_[_customerAddress];\r\n\t\t\t\trequire(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\t\t\t\tuint256 _tokenstosell               = SafeMath.percent(_amountOfTokens,sellPer_,100,18);\r\n\t\t\t\tuint256 _tokens                     = _tokenstosell/1e18;\r\n\t\t\t\tuint256 _ethereum                   = tokensToEthereum_(_tokens);\r\n\t\t\t\tuint256 _dividends                  = SafeMath.percent(_ethereum,sellFee_,100,18);\r\n\t\t\t\tuint256 _taxedEthereum              = SafeMath.sub(_ethereum, _dividends);\r\n\t\t\t\t// burn the sold tokens\r\n\t\t\t\ttokenSupply_                        = SafeMath.sub(tokenSupply_, _tokens);\r\n\t\t\t\ttokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n\t\t\t\t// update dividends tracker\r\n\t\t\t\tint256 _updatedPayouts              = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\r\n\t\t\t\tpayoutsTo_[_customerAddress]        -= _updatedPayouts;       \r\n\t\t\t\t// dividing by zero is a bad idea\r\n\t\t\t\tif (tokenSupply_ > 0) {\r\n\t\t\t\t\t// update the amount of dividends per token\r\n\t\t\t\t\tprofitPerShare_                 = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n\t\t\t\t}\r\n\t\t\t\tsellTime_[_customerAddress] = now;\r\n\t\t\t\t// fire event\r\n\t\t\t\tonTokenSell(_customerAddress, _tokens, _taxedEthereum);\r\n\t\t\t\r\n\t        }\r\n\t\r\n    }\r\n    \r\n    /**\r\n     * TRANSFER\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlybelievers () public returns(bool) {\r\n        address _customerAddress            = msg.sender;\r\n        \r\n        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        \r\n        if(myDividends(true) > 0) withdraw();\r\n       \r\n       \r\n        uint256 _taxedTokens                = _amountOfTokens;\r\n        uint256 _dividends                  = myDividends(false);\r\n        \r\n        tokenSupply_                        = tokenSupply_;\r\n        \r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress]     = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\r\n       \r\n        payoutsTo_[_customerAddress]        -= (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress]              += (int256) (profitPerShare_ * _taxedTokens);\r\n       \r\n        profitPerShare_                     = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n       \r\n        Transfer(_customerAddress, _toAddress, _taxedTokens);\r\n        return true;\r\n    }\r\n    \r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    \r\n    function disableInitialStage() onlyAdministrator() public {\r\n        onlyAmbassadors                     = false;\r\n    }\r\n    \r\n     function changeStakePercent(uint256 stakePercent) onlyAdministrator() public {\r\n        stakePer_                           = stakePercent;\r\n    }\r\n\t \r\n     function changeSellPercent(uint256 sellPercent) onlyAdministrator() public {\r\n        sellPer_                           = sellPercent;\r\n    }\r\n    \r\n    function setAdministrator(bytes32 _identifier, bool _status) onlyAdministrator() public {\r\n        administrators[_identifier]         = _status;\r\n    }\r\n    \r\n    function setStakingRequirement(uint256 _amountOfTokens) onlyAdministrator() public {\r\n        stakingRequirement                  = _amountOfTokens;\r\n    }\r\n    \r\n    function setName(string _name) onlyAdministrator() public {\r\n        name                                = _name;\r\n    }\r\n    \r\n    function setSymbol(string _symbol) onlyAdministrator() public {\r\n        symbol                              = _symbol;\r\n    }\r\n    \r\n      \r\n    function withdrawDeveloperFees(uint256 _withdrawAmount) external onlyAdministrator {\r\n        address _adminAddress   = msg.sender;\r\n        require(developerBalance >= _withdrawAmount);\r\n        _adminAddress.transfer(_withdrawAmount);\r\n        developerBalance        = SafeMath.sub(developerBalance, _withdrawAmount);\r\n\t\t\r\n\t\t\r\n    }\r\n\t\r\n\t\r\n    \r\n    /*---------- CALCULATORS  ----------*/\r\n    \r\n    function totalEthereumBalance() public view returns(uint) {\r\n        return this.balance;\r\n    }\r\n   \r\n    function totalDeveloperBalance() public view returns(uint) {\r\n        return developerBalance;\r\n    }\r\n   \r\n\t\r\n    \r\n    function totalSupply() public view returns(uint256) {\r\n        return tokenSupply_;\r\n    }\r\n    \r\n    \r\n    function myTokens() public view returns(uint256) {\r\n        address _customerAddress            = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n    \r\n    \r\n    function myDividends(bool _includeReferralBonus) public view returns(uint256) {\r\n        address _customerAddress            = msg.sender;\r\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\r\n    }\r\n    \r\n   \r\n    function balanceOf(address _customerAddress) view public returns(uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\t\r\n\r\n    function dividendsOf(address _customerAddress) view public returns(uint256) {\r\n        return (uint256) ((int256)(profitPerShare_ * (tokenBalanceLedger_[_customerAddress] + stakeBalanceLedger_[_customerAddress])) - payoutsTo_[_customerAddress]) / magnitude;\r\n    }\r\n    \r\n   \r\n    function sellPrice() public view returns(uint256) {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_       - tokenPriceDecremental_;\r\n        } else {\r\n            uint256 _ethereum               = tokensToEthereum_(1e18);\r\n            uint256 _taxedEthereum          = _ethereum;\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n    \r\n   \r\n    function buyPrice() public view returns(uint256) {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_       + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum               = tokensToEthereum_(1e18);\r\n            uint256 untotalDeduct           = developerFee_ + referralPer_ + dividendFee_ ;\r\n            uint256 totalDeduct             = SafeMath.percent(_ethereum,untotalDeduct,100,18);\r\n            uint256 _taxedEthereum          = SafeMath.add(_ethereum, totalDeduct);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n   \r\n    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {\r\n        uint256 untotalDeduct               = developerFee_ + referralPer_ + dividendFee_ ;\r\n        uint256 totalDeduct                 = SafeMath.percent(_ethereumToSpend,untotalDeduct,100,18);\r\n        uint256 _taxedEthereum              = SafeMath.sub(_ethereumToSpend, totalDeduct);\r\n        uint256 _amountOfTokens             = ethereumToTokens_(_taxedEthereum);\r\n        return _amountOfTokens;\r\n    }\r\n   \r\n    function calculateEthereumReceived(uint256 _tokensToSell) public view returns(uint256) {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _ethereum                   = tokensToEthereum_(_tokensToSell);\r\n        uint256 _taxedEthereum              = _ethereum;\r\n        return _taxedEthereum;\r\n    }\r\n    \r\n    function stakeTokens(uint256 _amountOfTokens) onlybelievers () public returns(bool){\r\n        address _customerAddress            = msg.sender;\r\n      \r\n        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _amountOfTokensWith1Token   = SafeMath.sub(_amountOfTokens, 1e18);\r\n        stakingTime_[_customerAddress]      = now;\r\n        stakeBalanceLedger_[_customerAddress] = SafeMath.add(stakeBalanceLedger_[_customerAddress], _amountOfTokensWith1Token);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokensWith1Token);\r\n    }\r\n    \r\n    \r\n    function stakeTokensBalance(address _customerAddress) public view returns(uint256){\r\n       uint256 timediff                    = SafeMath.sub(now, stakingTime_[_customerAddress]);\r\n        uint256 dayscount                   = SafeMath.div(timediff, 86400); //86400 Sec for 1 Day\r\n        uint256 roiPercent                  = SafeMath.mul(dayscount, stakePer_);\r\n        uint256 roiTokens                   = SafeMath.percent(stakeBalanceLedger_[_customerAddress],roiPercent,100,18);\r\n        uint256 finalBalance                = SafeMath.add(stakeBalanceLedger_[_customerAddress],roiTokens/1e18);\r\n        return finalBalance;\r\n    }\r\n    \r\n    function stakeTokensTime(address _customerAddress) public view returns(uint256){\r\n        return stakingTime_[_customerAddress];\r\n    }\r\n\t\r\n\tfunction sellTime(address _customerAddress) public view returns(uint256){\r\n        return sellTime_[_customerAddress];\r\n    }\r\n\t\r\n\tfunction sellTokenlimit() public view returns(uint256){\r\n        return sellPer_;\r\n    }\r\n    \r\n    function releaseStake() onlybelievers () public returns(bool){\r\n       \r\n         address _customerAddress            = msg.sender;\r\n    \r\n        require(!onlyAmbassadors && stakingTime_[_customerAddress] > 0);\r\n        uint256 _amountOfTokens             = stakeBalanceLedger_[_customerAddress];\r\n        uint256 timediff                    = SafeMath.sub(now, stakingTime_[_customerAddress]);\r\n        uint256 dayscount                   = SafeMath.div(timediff, 86400);\r\n        uint256 roiPercent                  = SafeMath.mul(dayscount, stakePer_);\r\n        uint256 roiTokens                   = SafeMath.percent(_amountOfTokens,roiPercent,100,18);\r\n        uint256 finalBalance                = SafeMath.add(_amountOfTokens,roiTokens/1e18);\r\n        \r\n    \r\n        tokenSupply_                        = SafeMath.add(tokenSupply_, roiTokens/1e18);\r\n    \r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], finalBalance);\r\n        stakeBalanceLedger_[_customerAddress] = 0;\r\n        stakingTime_[_customerAddress]      = 0;\r\n        \r\n    }\r\n    \r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    \r\n    uint256 developerFee;\r\n    \r\n    uint256 incETH;\r\n    address _refAddress; \r\n    uint256 _referralBonus;\r\n    \r\n    uint256 bonusLv1;\r\n    uint256 bonusLv2;\r\n    uint256 bonusLv3;\r\n    uint256 bonusLv4;\r\n    uint256 bonusLv5;\r\n    uint256 bonusLv6;\r\n    uint256 bonusLv7;\r\n    uint256 bonusLv8;\r\n    uint256 bonusLv9;\r\n    uint256 bonusLv10;\r\n    \r\n    uint256 DLTXtoETH;\r\n    uint256 DLTXbalance;\r\n    \r\n    address chkLv2;\r\n    address chkLv3;\r\n    address chkLv4;\r\n    address chkLv5;\r\n    address chkLv6;\r\n    address chkLv7;\r\n    address chkLv8;\r\n    address chkLv9;\r\n    address chkLv10;\r\n    \r\n    struct RefUserDetail {\r\n        address refUserAddress;\r\n        uint256 refLevel;\r\n    }\r\n\r\n    mapping(address => mapping (uint => RefUserDetail)) public RefUser;\r\n    mapping(address => uint256) public referralCount_;\r\n    \r\n    function getDownlineRef(address senderAddress, uint dataId) external view returns (address,uint) { \r\n        return (RefUser[senderAddress][dataId].refUserAddress,RefUser[senderAddress][dataId].refLevel);\r\n    }\r\n    \r\n    function addDownlineRef(address senderAddress, address refUserAddress, uint refLevel) internal {\r\n        referralCount_[senderAddress]++;\r\n        uint dataId = referralCount_[senderAddress];\r\n        RefUser[senderAddress][dataId].refUserAddress = refUserAddress;\r\n        RefUser[senderAddress][dataId].refLevel = refLevel;\r\n    }\r\n\r\n    function getref(address _customerAddress, uint _level) public view returns(address lv) {\r\n        if(_level == 1) {\r\n            lv = referralLevel1Address[_customerAddress];\r\n        } else if(_level == 2) {\r\n            lv = referralLevel2Address[_customerAddress];\r\n        } else if(_level == 3) {\r\n            lv = referralLevel3Address[_customerAddress];\r\n        } else if(_level == 4) {\r\n            lv = referralLevel4Address[_customerAddress];\r\n        } else if(_level == 5) {\r\n            lv = referralLevel5Address[_customerAddress];\r\n        } else if(_level == 6) {\r\n            lv = referralLevel6Address[_customerAddress];\r\n        } else if(_level == 7) {\r\n            lv = referralLevel7Address[_customerAddress];\r\n        } else if(_level == 8) {\r\n            lv = referralLevel8Address[_customerAddress];\r\n        } else if(_level == 9) {\r\n            lv = referralLevel9Address[_customerAddress];\r\n        } else if(_level == 10) {\r\n            lv = referralLevel10Address[_customerAddress];\r\n        }\r\n\t\t\r\n        return lv;\r\n    }\r\n    \r\n    function distributeRefBonus(uint256 _incomingEthereum, address _referredBy, address _sender, bool _newReferral) internal {\r\n        address _customerAddress        = _sender;\r\n        uint256 remainingRefBonus       = _incomingEthereum;\r\n        _referralBonus                  = _incomingEthereum;\r\n        \r\n        bonusLv1                        = SafeMath.percent(_referralBonus,30,100,18);\r\n        bonusLv2                        = SafeMath.percent(_referralBonus,20,100,18);\r\n        bonusLv3                        = SafeMath.percent(_referralBonus,10,100,18);\r\n        bonusLv4                        = SafeMath.percent(_referralBonus,5,100,18);\r\n        bonusLv5                        = SafeMath.percent(_referralBonus,3,100,18);\r\n        bonusLv6                        = SafeMath.percent(_referralBonus,2,100,18);\r\n        bonusLv7                        = SafeMath.percent(_referralBonus,2,100,18);\r\n        bonusLv8                        = SafeMath.percent(_referralBonus,2,100,18);\r\n        bonusLv9                        = SafeMath.percent(_referralBonus,1,100,18);\r\n        bonusLv10                       = SafeMath.percent(_referralBonus,1,100,18);\r\n        \r\n      \r\n        referralLevel1Address[_customerAddress]                     = _referredBy;\r\n        referralBalance_[referralLevel1Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel1Address[_customerAddress]], bonusLv1);\r\n        remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv1);\r\n        if(_newReferral == true) {\r\n            addDownlineRef(_referredBy, _customerAddress, 1);\r\n        }\r\n        \r\n        chkLv2                          = referralLevel1Address[_referredBy];\r\n        chkLv3                          = referralLevel2Address[_referredBy];\r\n        chkLv4                          = referralLevel3Address[_referredBy];\r\n        chkLv5                          = referralLevel4Address[_referredBy];\r\n        chkLv6                          = referralLevel5Address[_referredBy];\r\n        chkLv7                          = referralLevel6Address[_referredBy];\r\n        chkLv8                          = referralLevel7Address[_referredBy];\r\n        chkLv9                          = referralLevel8Address[_referredBy];\r\n        chkLv10                         = referralLevel9Address[_referredBy];\r\n        \r\n      \r\n        if(chkLv2 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel2Address[_customerAddress]                     = referralLevel1Address[_referredBy];\r\n            referralBalance_[referralLevel2Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel2Address[_customerAddress]], bonusLv2);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv2);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel1Address[_referredBy], _customerAddress, 2);\r\n            }\r\n        }\r\n        \r\n      \r\n        if(chkLv3 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel3Address[_customerAddress]                     = referralLevel2Address[_referredBy];\r\n            referralBalance_[referralLevel3Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel3Address[_customerAddress]], bonusLv3);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv3);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel2Address[_referredBy], _customerAddress, 3);\r\n            }\r\n        }\r\n        \r\n      \r\n        if(chkLv4 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel4Address[_customerAddress]                     = referralLevel3Address[_referredBy];\r\n            referralBalance_[referralLevel4Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel4Address[_customerAddress]], bonusLv4);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv4);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel3Address[_referredBy], _customerAddress, 4);\r\n            }\r\n        }\r\n        \r\n      \r\n        if(chkLv5 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel5Address[_customerAddress]                     = referralLevel4Address[_referredBy];\r\n            referralBalance_[referralLevel5Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel5Address[_customerAddress]], bonusLv5);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv5);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel4Address[_referredBy], _customerAddress, 5);\r\n            }\r\n        }\r\n        \r\n      \r\n        if(chkLv6 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel6Address[_customerAddress]                     = referralLevel5Address[_referredBy];\r\n            referralBalance_[referralLevel6Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel6Address[_customerAddress]], bonusLv6);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv6);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel5Address[_referredBy], _customerAddress, 6);\r\n            }\r\n        }\r\n        \r\n        \r\n        if(chkLv7 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel7Address[_customerAddress]                     = referralLevel6Address[_referredBy];\r\n            referralBalance_[referralLevel7Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel7Address[_customerAddress]], bonusLv7);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv7);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel6Address[_referredBy], _customerAddress, 7);\r\n            }\r\n        }\r\n        \r\n        \r\n        if(chkLv8 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel8Address[_customerAddress]                     = referralLevel7Address[_referredBy];\r\n            referralBalance_[referralLevel8Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel8Address[_customerAddress]], bonusLv8);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv8);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel7Address[_referredBy], _customerAddress, 8);\r\n            }\r\n        }\r\n        \r\n        \r\n        if(chkLv9 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel9Address[_customerAddress]                     = referralLevel8Address[_referredBy];\r\n            referralBalance_[referralLevel9Address[_customerAddress]]   = SafeMath.add(referralBalance_[referralLevel9Address[_customerAddress]], bonusLv9);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv9);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel8Address[_referredBy], _customerAddress, 9);\r\n            }\r\n        }\r\n        \r\n       \r\n        if(chkLv10 != 0x0000000000000000000000000000000000000000) {\r\n            referralLevel10Address[_customerAddress]                    = referralLevel9Address[_referredBy];\r\n            referralBalance_[referralLevel10Address[_customerAddress]]  = SafeMath.add(referralBalance_[referralLevel10Address[_customerAddress]], bonusLv10);\r\n            remainingRefBonus                                           = SafeMath.sub(remainingRefBonus, bonusLv10);\r\n            if(_newReferral == true) {\r\n                addDownlineRef(referralLevel9Address[_referredBy], _customerAddress, 10);\r\n            }\r\n        }\r\n        \r\n        developerBalance                    = SafeMath.add(developerBalance, remainingRefBonus);\r\n    }\r\n\r\n\r\n    function createDLTXReceivers(address _customerAddress, uint256 _DLTXamt, uint256 _DLTXETHamt) public returns(address){\r\n            DLTXbuying_[_customerAddress] = _DLTXamt;\r\n            DLTXbuyingETHamt_[_customerAddress] = _DLTXETHamt;\r\n            if(receiversMap[_customerAddress] == 0x0000000000000000000000000000000000000000) {\r\n                receiversMap[_customerAddress] = new Receiver();\r\n            }\r\n            return receiversMap[_customerAddress];\r\n    }\r\n    \r\n    function showDLTXReceivers(address _customerAddress) public view returns(address){\r\n            return receiversMap[_customerAddress];\r\n    }\r\n    \r\n    function showDLTXBalance(address tracker, address _customerAddress) public view returns(uint256){\r\n            return ERC20(0x0435316b3ab4b999856085c98c3b1ab21d85cd4d).balanceOf(receiversMap[_customerAddress]);\r\n    }\r\n    \r\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) antiEarlyWhale(_incomingEthereum) internal returns(uint256) {\r\n        \r\n        address _customerAddress            = msg.sender;\r\n        incETH                              = _incomingEthereum;\r\n        \r\n        if(DLTXbuying_[_customerAddress] > 0) {\r\n            DLTXbalance = ERC20(0x0435316b3ab4b999856085c98c3b1ab21d85cd4d).balanceOf(receiversMap[_customerAddress]);\r\n            require(DLTXbalance >= DLTXbuying_[_customerAddress]);\r\n            require(incETH >= DLTXbuyingETHamt_[_customerAddress]);\r\n            DLTXtoETH                       = (DLTXbuying_[_customerAddress]/10**18) * dltxPrice_;\r\n            incETH                          = SafeMath.add(incETH, DLTXtoETH);\r\n            \r\n            Receiver(receiversMap[_customerAddress]).sendFundsTo(0x0435316b3ab4b999856085c98c3b1ab21d85cd4d, DLTXbalance, 0x5dfF6644254223bCF27086719B899c3b1Ff08943);\r\n            \r\n            DLTXbuying_[_customerAddress] = 0;\r\n            DLTXbuyingETHamt_[_customerAddress] = 0;\r\n        }\r\n       \r\n        developerFee                        = SafeMath.percent(incETH,developerFee_,100,18);\r\n        developerBalance                    = SafeMath.add(developerBalance, developerFee);\r\n        \r\n\t\t\r\n        \r\n        _referralBonus                      = SafeMath.percent(incETH,referralPer_,100,18);\r\n        \r\n        uint256 _dividends                  = SafeMath.percent(incETH,dividendFee_,100,18);\r\n        \r\n        uint256 untotalDeduct               = developerFee_ + referralPer_ + dividendFee_;\r\n        uint256 totalDeduct                 = SafeMath.percent(incETH,untotalDeduct,100,18);\r\n        \r\n        uint256 _taxedEthereum              = SafeMath.sub(incETH, totalDeduct);\r\n        uint256 _amountOfTokens             = ethereumToTokens_(_taxedEthereum);\r\n        uint256 _fee                        = _dividends * magnitude;\r\n        bool    _newReferral                = true;\r\n        if(referralLevel1Address[_customerAddress] != 0x0000000000000000000000000000000000000000) {\r\n            _referredBy                     = referralLevel1Address[_customerAddress];\r\n            _newReferral                    = false;\r\n        }\r\n        \r\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\r\n        \r\n        if(\r\n           \r\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\r\n           \r\n            _referredBy != _customerAddress &&\r\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\r\n        ){\r\n            \r\n            distributeRefBonus(_referralBonus,_referredBy,_customerAddress,_newReferral);\r\n        } else {\r\n           \r\n            developerBalance                = SafeMath.add(developerBalance, _referralBonus);\r\n        }\r\n       \r\n        if(tokenSupply_ > 0){\r\n           \r\n            tokenSupply_                    = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n           \r\n            profitPerShare_                 += (_dividends * magnitude / (tokenSupply_));\r\n            \r\n            _fee                            = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\r\n        } else {\r\n            \r\n            tokenSupply_                    = _amountOfTokens;\r\n        }\r\n        \r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        int256 _updatedPayouts              = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\r\n        payoutsTo_[_customerAddress]        += _updatedPayouts;\r\n       \r\n        onTokenPurchase(_customerAddress, incETH, _amountOfTokens, _referredBy);\r\n        return _amountOfTokens;\r\n    }\r\n\r\n   \r\n    function ethereumToTokens_(uint256 _ethereum) internal view returns(uint256) {\r\n        uint256 _tokenPriceInitial          = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived             = \r\n         (\r\n            (\r\n                SafeMath.sub(\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial**2)\r\n                            +\r\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n                            +\r\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\r\n                            +\r\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\r\n                        )\r\n                    ), _tokenPriceInitial\r\n                )\r\n            )/(tokenPriceIncremental_)\r\n        )-(tokenSupply_)\r\n        ;\r\n\r\n        return _tokensReceived;\r\n    }\r\n    \r\n    \r\n     function tokensToEthereum_(uint256 _tokens) internal view returns(uint256) {\r\n        uint256 tokens_                     = (_tokens + 15e17);\r\n        uint256 _tokenSupply                = (tokenSupply_ + 15e17);\r\n        uint256 _etherReceived              =\r\n        (\r\n            SafeMath.sub(\r\n                (\r\n                    (\r\n                        (\r\n                            tokenPriceInitial_ +(tokenPriceDecremental_ * (_tokenSupply/15e17))\r\n                        )-tokenPriceDecremental_\r\n                    )*(tokens_ - 15e17)\r\n                ),(tokenPriceDecremental_*((tokens_**2-tokens_)/15e17))/2\r\n            )\r\n        /15e17);\r\n        return _etherReceived;\r\n    }\r\n\t    \r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"receiversMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tracker\",\"type\":\"address\"},{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"showDLTXBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyAmbassadors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"dataId\",\"type\":\"uint256\"}],\"name\":\"getDownlineRef\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"DLTXbuyingETHamt_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"stakeTokensBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefUser\",\"outputs\":[{\"name\":\"refUserAddress\",\"type\":\"address\"},{\"name\":\"refLevel\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"sellTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseStake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"showDLTXReceivers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeveloperBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellPercent\",\"type\":\"uint256\"}],\"name\":\"changeSellPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"stakeTokensTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"setStakingRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawDeveloperFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableInitialStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"_DLTXamt\",\"type\":\"uint256\"},{\"name\":\"_DLTXETHamt\",\"type\":\"uint256\"}],\"name\":\"createDLTXReceivers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"DLTXbuying_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellTokenlimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stakePercent\",\"type\":\"uint256\"}],\"name\":\"changeStakePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getref\",\"outputs\":[{\"name\":\"lv\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCount_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"DLTS","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a321579d722e33fc66a9ccb743818b195a6ef97ff20d418ae16b5bb7e66a36bd"}]}