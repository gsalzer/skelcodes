{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\n// import SafeMath for safety checks\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n     function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n     \tuint256 c = a + b;\r\n     \trequire(c >= a, \"SafeMath: addition overflow\");\r\n\r\n     \treturn c;\r\n     }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n     \trequire(b <= a, \"SafeMath: subtraction overflow\");\r\n     \tuint256 c = a - b;\r\n\r\n     \treturn c;\r\n     }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n        \treturn 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n     function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n     \trequire(b != 0, \"SafeMath: modulo by zero\");\r\n     \treturn a % b;\r\n     }\r\n }\r\n\r\n// import abstract token contract\r\ncontract ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address tokenlender) external view returns (uint balance);\r\n    function allowance(address tokenlender, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenlender, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\ncontract MCL {\r\n\r\n  using SafeMath for uint256;\r\n\r\n// Public parameters for ERC20 token\r\nuint8 public decimals = 18;\r\nstring public name = \"MCreditToken\";\r\nstring public symbol = \"TEST-TOKEN\";\r\nuint256 public totalSupply= 300000000 *(10**uint256(decimals));\r\nERC20 public usdt = ERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\nERC20 public MCLtoken;\r\nuint256 public totalSellAmount;\r\nuint256 public minimalSellAmount;\r\nuint256 public remainedSellAmount;\r\nuint256 public price;\r\nbool public openForSale;\r\n\r\nmapping(address => uint256) public lockedToken;\r\nmapping(address => uint256) public lockedAt;\r\nmapping(address => uint256[]) public releaseStep;\r\nmapping(address => uint256) public interval;\r\n\r\n\r\n\r\n\r\nmapping(address => uint256) public balanceOf;\r\nmapping(address => mapping(address => uint256)) public allowance;\r\nmapping(address => bool) public blacklist;\r\n\r\n// Only owner can call mint and transferOwnership function\r\naddress public owner;\r\n\r\n// disable minting functions when mintingFinished is true\r\nbool public mintingFinished = false;\r\n\r\n// Events that notify clients about token transfer, approval and burn \r\nevent Transfer(address indexed from, address indexed to, uint256 value);\r\nevent Mint(address indexed minter, uint256 value);\r\nevent Burn(address indexed from, uint256 value);\r\nevent Approval(address indexed _owner, address indexed _spender, uint256 value);\r\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\nevent MintFinished();\r\nevent ForSale(uint256 price, uint256 totalSellAmount, uint256 minimalSellAmount);\r\nevent PauseSale();\r\nevent OpenSale();\r\nevent TokenPurchased(uint256 sellAmount, uint256 fee);\r\nevent TokenLocked(address indexed owner, uint256 amount);\r\n\r\n\r\n    /**\r\n     * Constructor function\r\n     *\r\n     * Initializes contract with initial supply and designate ownership \r\n     */\r\n     constructor(address _owner) public {\r\n        owner = _owner;\r\n        balanceOf[owner] = totalSupply;\r\n        MCLtoken = ERC20(address(this));\r\n        emit Transfer(address(0),owner,totalSupply);\r\n    }\r\n\r\n\r\n  /**\r\n  * @dev enable people to buy tokens\r\n  * @param _price 1*(10e18)USDT = (_price) uint of MCL token\r\n  * @param _totalSellAmount The total amount to be sold.\r\n  * @param _minimalSellAmount The minimal amount to be sold in each transaction.\r\n  */\r\n  function setPriceAndOpenSale(uint256 _price, uint256 _totalSellAmount, uint256 _minimalSellAmount) public returns (bool){\r\n    require(msg.sender == owner);\r\n    openForSale = true;\r\n    price = _price;\r\n    totalSellAmount = _totalSellAmount;\r\n    minimalSellAmount = _minimalSellAmount;\r\n    remainedSellAmount = _totalSellAmount;\r\n    emit ForSale(price, totalSellAmount, minimalSellAmount);\r\n    emit OpenSale(); \r\n    return true;\r\n}\r\n\r\n /**\r\n  * @dev pause token sale\r\n  */\r\n  function pauseSale() public returns (bool){ \r\n    require(msg.sender == owner);\r\n    openForSale = false;\r\n    emit PauseSale();\r\n    return true;\r\n}\r\n\r\n /**\r\n  * @dev open token sale\r\n  */\r\n  function openSale() public returns (bool){ \r\n    require(msg.sender == owner);\r\n    openForSale = true;\r\n    emit OpenSale();\r\n    return true;\r\n}\r\n /**\r\n  * @dev purchase MCL token by usdt\r\n  * @param _amount numbers of token to purchase\r\n  */\r\n  function purchase(uint256 _amount) public returns (bool){\r\n    require(openForSale);\r\n    require(_amount >= minimalSellAmount);\r\n    require(remainedSellAmount >= _amount);\r\n    uint256 fee = price.mul(_amount).div(10**18);\r\n    require(usdt.transferFrom(msg.sender, address(this), fee),\"USDT transfer failed, insufficient amount or you do not approve this contract to use your USDT\");\r\n    // require(MCLtoken.transfer(msg.sender, _amount),\"MCL transfer failed, the contract currently does not have enough MCL tokens\");\r\n    balanceOf[address(this)] = balanceOf[address(this)].sub(_amount);\r\n    balanceOf[msg.sender] = balanceOf[msg.sender].add(_amount);\r\n    remainedSellAmount = remainedSellAmount.sub(_amount);\r\n    emit Transfer(address(this), msg.sender, _amount);\r\n\r\n    emit TokenPurchased(_amount, fee);\r\n    return true;\r\n}\r\n\r\n /**\r\n  * @dev withdraw all USDT to recipient\r\n  * @param _recipient address to receive USDT\r\n  */\r\n  function withdrawUSDT(address _recipient) public returns (bool) {\r\n    require(msg.sender == owner);\r\n    require(usdt.transfer(_recipient, usdt.balanceOf(address(this))));\r\n    return true;\r\n}\r\n\r\n /**\r\n  * @dev withdraw all MCL to recipient\r\n  * @param _recipient address to receive MCL\r\n  */\r\n  function withdrawMCL(address _recipient) public returns (bool) {\r\n    require(msg.sender == owner);\r\n    require(MCLtoken.transfer(_recipient, MCLtoken.balanceOf(address(this))));\r\n    return true;\r\n}\r\n\r\n/**\r\n  * @dev send locked token to recipient\r\n  * @param _to the recipient\r\n  * @param _value locked token amount\r\n  * @param _interval timestamp interval to release tokens\r\n  * @param _releaseStep release step to release tokens \r\n\r\n  */\r\n  function sendLockedToken(address _to, uint256 _value, uint256 _interval, uint256[] memory _releaseStep) public returns (bool) {\r\n    require(msg.sender == owner);\r\n    require(!blacklist[_to]);\r\n    require(!blacklist[msg.sender]);\r\n    require(_to != address(0));\r\n    require(_value <= balanceOf[msg.sender]);\r\n    require(lockedToken[_to] == 0, \"the recipient must not have locked tokens\");\r\n    uint256 x;\r\n    for(uint8 i=0; i<_releaseStep.length; i++){\r\n        x = x.add(_releaseStep[i]);\r\n    }\r\n    require(x ==_value, \"you must make sure all locked tokens are able to release\");\r\n    lockedToken[_to] = lockedToken[_to].add(_value);\r\n    lockedAt[_to] = now;\r\n    releaseStep[_to] = _releaseStep;\r\n    interval[_to] = _interval;\r\n\r\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n    balanceOf[_to] = balanceOf[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    emit TokenLocked(_to, _value);\r\n    return true;\r\n}\r\n\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool){\r\n    require(!blacklist[_to]);\r\n    require(!blacklist[msg.sender]);\r\n    require(_to != address(0));\r\n    require(_value <= balanceOf[msg.sender]);\r\n    if(lockedToken[msg.sender] == 0){\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    } \r\n    else {\r\n        uint256 x = now.sub(lockedAt[msg.sender]).div(interval[msg.sender]);\r\n        uint256 currentLockedToken = lockedToken[msg.sender];\r\n        for(uint8 i; i<x; i++){\r\n            currentLockedToken = currentLockedToken.sub(releaseStep[msg.sender][i]);\r\n        }\r\n        require(balanceOf[msg.sender].sub(_value) >= currentLockedToken, \"tokens are currently locked\" );\r\n        if(currentLockedToken == 0 ){\r\n            lockedToken[msg.sender] = 0;\r\n        }\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n* Transfer tokens from other address\r\n*\r\n* Send `_value` tokens to `_to` on behalf of `_from`\r\n*\r\n* @param _from The address of the sender\r\n* @param _to The address of the recipient\r\n* @param _value the amount to send \r\n*/\r\n\r\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n  require(!blacklist[_to]);\r\n  require(!blacklist[msg.sender]);\r\n  require(_to != address(0));\r\n  require(_value <= allowance[_from][msg.sender]);\r\n  require(_value <= balanceOf[_from]);\r\n  require(lockedToken[_from] == 0, \"account with locked tokens is not allowed to make transfer with this function\");\r\n  allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n  balanceOf[_from] = balanceOf[_from].sub(_value);\r\n  balanceOf[_to] = balanceOf[_to].add(_value);\r\n  emit Transfer(_from, _to, _value);\r\n  return true;\r\n}\r\n\r\n/**\r\n* @dev Set allowance for other address\r\n*\r\n* Allows `_spender` to spend no more than `_value` tokens on your behalf\r\n*\r\n* @param _spender The address authorized to spend\r\n* @param _value the max amount they can spend\r\n\r\n*/\r\nfunction approve(address _spender, uint256 _value) public returns (bool) {\r\n\t\r\n\tallowance[msg.sender][_spender] = _value;\r\n\temit Approval(msg.sender, _spender, _value);\r\n\treturn true;\r\n}\r\n\r\n/**\r\n* @dev Call this function to burn tokens instead of sending to address(0)\r\n\r\n* @param _value amount to burn\r\n\r\n*/\r\nfunction burn(uint256 _value) public returns (bool) {\r\n\t\r\n\trequire(balanceOf[msg.sender] >= _value);\r\n\tbalanceOf[msg.sender] =balanceOf[msg.sender].sub(_value);\r\n\ttotalSupply = totalSupply.sub(_value);\r\n\temit Burn(msg.sender, _value);\r\n\treturn true;\r\n}\r\n\r\n/**\r\n* @dev Call this function to mint tokens (only contract owner can trigger the function) and increase the total supply accordingly\r\n\r\n* @param _value amount to mint\r\n\r\n*/\r\nfunction mint(uint256 _value) public returns (bool) {\r\n    require(!mintingFinished);\r\n    require(msg.sender == owner);\r\n    balanceOf[msg.sender] = balanceOf[msg.sender].add(_value);\r\n    totalSupply = totalSupply.add(_value);\r\n    emit Mint(msg.sender, _value);\r\n    emit Transfer(address(0),msg.sender,_value);\r\n    return true;\r\n}\r\n\r\n/**\r\n* @dev Function to stop minting new tokens, when this function is called, function mint will be permanently disabled\r\n\r\n*/\r\n\r\nfunction finishMinting() public returns (bool) {\r\n    require(msg.sender == owner);\r\n    require(!mintingFinished);\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n}\r\n\r\n\r\n\r\n/**\r\n* @dev Transfer ownership of this contract to given address\r\n\r\n* @param _newOwner new owner address\r\n\r\n*/\r\nfunction transferOwnership(address _newOwner) public {\r\n\trequire(msg.sender == owner);\r\n\towner = _newOwner;\r\n    emit OwnershipTransferred(msg.sender,owner);\r\n}\r\n\r\n/**\r\n* Ban address\r\n*\r\n* @param addr ban addr\r\n*/\r\nfunction ban(address addr) public {\r\n    require(msg.sender == owner);\r\n    blacklist[addr] = true;\r\n}\r\n/**\r\n* Enable address\r\n*\r\n* @param addr enable addr\r\n*/\r\nfunction enable(address addr) public {\r\n    require(msg.sender == owner);\r\n    blacklist[addr] = false;\r\n}\r\n\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimalSellAmount\",\"type\":\"uint256\"}],\"name\":\"ForSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OpenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"TokenPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MCLtoken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ban\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"enable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"interval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openForSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"releaseStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainedSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_releaseStep\",\"type\":\"uint256[]\"}],\"name\":\"sendLockedToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalSellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimalSellAmount\",\"type\":\"uint256\"}],\"name\":\"setPriceAndOpenSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawMCL\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawUSDT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MCL","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000e7623758631df1161afc3da0afb0649ecb67d354","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8586eba2998d0700f30b450b71097f4e1df0c593e9ea4138ffb5899decde365f"}]}