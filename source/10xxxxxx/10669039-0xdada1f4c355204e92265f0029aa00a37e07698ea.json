{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary AddressLib {\n    address public constant ADDRESS_EMPTY = address(0x0);\n\n    /**\n     * @dev Checks if this address is all 0s\n     * @param self The address this function was called on\n     * @return boolean\n     */\n    function isEmpty(address self) internal pure returns (bool) {\n        return self == ADDRESS_EMPTY;\n    }\n\n    /**\n     * @dev Checks if this address is the same as another address\n     * @param self The address this function was called on\n     * @param other Address to check against itself\n     * @return boolean\n     */\n    function isEqualTo(address self, address other) internal pure returns (bool) {\n        return self == other;\n    }\n\n    /**\n     * @dev Checks if this address is different to another address\n     * @param self The address this function was called on\n     * @param other Address to check against itself\n     * @return boolean\n     */\n    function isNotEqualTo(address self, address other) internal pure returns (bool) {\n        return self != other;\n    }\n\n    /**\n     * @dev Checks if this address is not all 0s\n     * @param self The address this function was called on\n     * @return boolean\n     */\n    function isNotEmpty(address self) internal pure returns (bool) {\n        return self != ADDRESS_EMPTY;\n    }\n\n    /**\n     * @dev Throws an error if address is all 0s\n     * @param self The address this function was called on\n     * @param message Error message if address is all 0s\n     */\n    function requireNotEmpty(address self, string memory message) internal pure {\n        require(isNotEmpty(self), message);\n    }\n\n    /**\n     * @dev Throws an error if address is not all 0s\n     * @param self The address this function was called on\n     * @param message Error message if address is not all 0s\n     */\n    function requireEmpty(address self, string memory message) internal pure {\n        require(isEmpty(self), message);\n    }\n\n    /**\n     * @dev Throws an error if address is not the same as another address\n     * @param self The address this function was called on\n     * @param other The address to check against itself\n     * @param message Error message if addresses are not the same\n     */\n    function requireEqualTo(address self, address other, string memory message)\n        internal\n        pure\n    {\n        require(isEqualTo(self, other), message);\n    }\n\n    /**\n     * @dev Throws an error if address is the same as another address\n     * @param self The address this function was called on\n     * @param other The address to check against itself\n     * @param message Error message if addresses are the same\n     */\n    function requireNotEqualTo(address self, address other, string memory message)\n        internal\n        pure\n    {\n        require(isNotEqualTo(self, other), message);\n    }\n}\n\nlibrary AssetSettingsLib {\n    using SafeMath for uint256;\n    using AddressLib for address;\n    using Address for address;\n\n    /**\n        @notice This struct manages the asset settings in the platform.\n        @param cTokenAddress cToken address associated to the asset. \n        @param maxLoanAmount max loan amount configured for the asset.\n     */\n    struct AssetSettings {\n        // It prepresents the cTokenAddress or 0x0.\n        address cTokenAddress;\n        // It represents the maximum loan amount to borrow.\n        uint256 maxLoanAmount;\n    }\n\n    /**\n        @notice It initializes the struct instance with the given parameters.\n        @param cTokenAddress the initial cToken address.\n        @param maxLoanAmount the initial max loan amount.\n     */\n    function initialize(\n        AssetSettings storage self,\n        address cTokenAddress,\n        uint256 maxLoanAmount\n    ) internal {\n        require(maxLoanAmount > 0, \"INIT_MAX_AMOUNT_REQUIRED\");\n        require(\n            cTokenAddress.isEmpty() || cTokenAddress.isContract(),\n            \"CTOKEN_MUST_BE_CONTRACT_OR_EMPTY\"\n        );\n        self.cTokenAddress = cTokenAddress;\n        self.maxLoanAmount = maxLoanAmount;\n    }\n\n    /**\n        @notice Checks whether the current asset settings exists or not.\n        @dev It throws a require error if the asset settings already exists.\n        @param self the current asset settings.\n     */\n    function requireNotExists(AssetSettings storage self) internal view {\n        require(exists(self) == false, \"ASSET_SETTINGS_ALREADY_EXISTS\");\n    }\n\n    /**\n        @notice Checks whether the current asset settings exists or not.\n        @dev It throws a require error if the asset settings doesn't exist.\n        @param self the current asset settings.\n     */\n    function requireExists(AssetSettings storage self) internal view {\n        require(exists(self) == true, \"ASSET_SETTINGS_NOT_EXISTS\");\n    }\n\n    /**\n        @notice Tests whether the current asset settings exists or not.\n        @param self the current asset settings.\n        @return true if the current settings exists (max loan amount higher than zero). Otherwise it returns false.\n     */\n    function exists(AssetSettings storage self) internal view returns (bool) {\n        return self.maxLoanAmount > 0;\n    }\n\n    /**\n        @notice Tests whether a given amount is greater than the current max loan amount.\n        @param self the current asset settings.\n        @param amount to test.\n        @return true if the given amount is greater than the current max loan amount. Otherwise it returns false.\n     */\n    function exceedsMaxLoanAmount(AssetSettings storage self, uint256 amount)\n        internal\n        view\n        returns (bool)\n    {\n        return amount > self.maxLoanAmount;\n    }\n\n    /**\n        @notice It updates the cToken address.\n        @param self the current asset settings.\n        @param newCTokenAddress the new cToken address to set.\n     */\n    function updateCTokenAddress(AssetSettings storage self, address newCTokenAddress)\n        internal\n    {\n        requireExists(self);\n        require(self.cTokenAddress != newCTokenAddress, \"NEW_CTOKEN_ADDRESS_REQUIRED\");\n        self.cTokenAddress = newCTokenAddress;\n    }\n\n    /**\n        @notice It updates the max loan amount.\n        @param self the current asset settings.\n        @param newMaxLoanAmount the new max loan amount to set.\n     */\n    function updateMaxLoanAmount(AssetSettings storage self, uint256 newMaxLoanAmount)\n        internal\n    {\n        requireExists(self);\n        require(self.maxLoanAmount != newMaxLoanAmount, \"NEW_MAX_LOAN_AMOUNT_REQUIRED\");\n        require(newMaxLoanAmount > 0, \"MAX_LOAN_AMOUNT_NOT_ZERO\");\n        self.maxLoanAmount = newMaxLoanAmount;\n    }\n}\n\nlibrary PlatformSettingsLib {\n    /**\n        It defines a platform settings. It includes: value, min, and max values.\n     */\n    struct PlatformSetting {\n        uint256 value;\n        uint256 min;\n        uint256 max;\n        bool exists;\n    }\n\n    /**\n        @notice It creates a new platform setting given a name, min and max values.\n        @param value initial value for the setting.\n        @param min min value allowed for the setting.\n        @param max max value allowed for the setting.\n     */\n    function initialize(\n        PlatformSetting storage self,\n        uint256 value,\n        uint256 min,\n        uint256 max\n    ) internal {\n        requireNotExists(self);\n        require(value >= min, \"VALUE_MUST_BE_GT_MIN_VALUE\");\n        require(value <= max, \"VALUE_MUST_BE_LT_MAX_VALUE\");\n        self.value = value;\n        self.min = min;\n        self.max = max;\n        self.exists = true;\n    }\n\n    /**\n        @notice Checks whether the current platform setting exists or not.\n        @dev It throws a require error if the platform setting already exists.\n        @param self the current platform setting.\n     */\n    function requireNotExists(PlatformSetting storage self) internal view {\n        require(self.exists == false, \"PLATFORM_SETTING_ALREADY_EXISTS\");\n    }\n\n    /**\n        @notice Checks whether the current platform setting exists or not.\n        @dev It throws a require error if the current platform setting doesn't exist.\n        @param self the current platform setting.\n     */\n    function requireExists(PlatformSetting storage self) internal view {\n        require(self.exists == true, \"PLATFORM_SETTING_NOT_EXISTS\");\n    }\n\n    /**\n        @notice It updates a current platform setting.\n        @dev It throws a require error if:\n            - The new value is equal to the current value.\n            - The new value is not lower than the max value.\n            - The new value is not greater than the min value\n        @param self the current platform setting.\n        @param newValue the new value to set in the platform setting.\n     */\n    function update(PlatformSetting storage self, uint256 newValue)\n        internal\n        returns (uint256 oldValue)\n    {\n        requireExists(self);\n        require(self.value != newValue, \"NEW_VALUE_REQUIRED\");\n        require(newValue >= self.min, \"NEW_VALUE_MUST_BE_GT_MIN_VALUE\");\n        require(newValue <= self.max, \"NEW_VALUE_MUST_BE_LT_MAX_VALUE\");\n        oldValue = self.value;\n        self.value = newValue;\n    }\n\n    /**\n        @notice It removes a current platform setting.\n        @param self the current platform setting to remove.\n     */\n    function remove(PlatformSetting storage self) internal {\n        requireExists(self);\n        self.value = 0;\n        self.min = 0;\n        self.max = 0;\n        self.exists = false;\n    }\n}\n\ninterface SettingsInterface {\n    /**\n        @notice This event is emitted when a new platform setting is created.\n        @param settingName new setting name.\n        @param sender address that created it.\n        @param value value for the new setting.\n     */\n    event PlatformSettingCreated(\n        bytes32 indexed settingName,\n        address indexed sender,\n        uint256 value,\n        uint256 minValue,\n        uint256 maxValue\n    );\n\n    /**\n        @notice This event is emitted when a current platform setting is removed.\n        @param settingName setting name removed.\n        @param sender address that removed it.\n     */\n    event PlatformSettingRemoved(\n        bytes32 indexed settingName,\n        uint256 lastValue,\n        address indexed sender\n    );\n\n    /**\n        @notice This event is emitted when a platform setting is updated.\n        @param settingName settings name updated.\n        @param sender address that updated it.\n        @param oldValue old value for the setting.\n        @param newValue new value for the setting.\n     */\n    event PlatformSettingUpdated(\n        bytes32 indexed settingName,\n        address indexed sender,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n        @notice This event is emitted when a lending pool is paused.\n        @param account address that paused the lending pool.\n        @param lendingPoolAddress lending pool address which was paused.\n     */\n    event LendingPoolPaused(address indexed account, address indexed lendingPoolAddress);\n\n    /**\n        @notice This event is emitted when a lending pool is unpaused.\n        @param account address that paused the lending pool.\n        @param lendingPoolAddress lending pool address which was unpaused.\n     */\n    event LendingPoolUnpaused(\n        address indexed account,\n        address indexed lendingPoolAddress\n    );\n\n    /**\n        @notice This event is emitted when an new asset settings is created.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to create the settings.\n        @param cTokenAddress cToken address to configure for the asset.\n        @param maxLoanAmount max loan amount to configure for the asset.\n     */\n    event AssetSettingsCreated(\n        address indexed sender,\n        address indexed assetAddress,\n        address cTokenAddress,\n        uint256 maxLoanAmount\n    );\n\n    /**\n        @notice This event is emitted when an asset settings is removed.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to remove the settings.\n     */\n    event AssetSettingsRemoved(address indexed sender, address indexed assetAddress);\n\n    /**\n        @notice This event is emitted when an asset settings (address type) is updated.\n        @param assetSettingName asset setting name updated.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to update the asset settings.\n        @param oldValue old value used for the asset setting.\n        @param newValue the value updated.\n     */\n    event AssetSettingsAddressUpdated(\n        bytes32 indexed assetSettingName,\n        address indexed sender,\n        address indexed assetAddress,\n        address oldValue,\n        address newValue\n    );\n\n    /**\n        @notice This event is emitted when an asset settings (uint256 type) is updated.\n        @param assetSettingName asset setting name updated.\n        @param sender the transaction sender address.\n        @param assetAddress the asset address used to update the asset settings.\n        @param oldValue old value used for the asset setting.\n        @param newValue the value updated.\n     */\n    event AssetSettingsUintUpdated(\n        bytes32 indexed assetSettingName,\n        address indexed sender,\n        address indexed assetAddress,\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n        @notice It creates a new platform setting given a setting name, value, min and max values.\n        @param settingName setting name to create.\n        @param value the initial value for the given setting name.\n        @param minValue the min value for the setting.\n        @param maxValue the max value for the setting.\n     */\n    function createPlatformSetting(\n        bytes32 settingName,\n        uint256 value,\n        uint256 minValue,\n        uint256 maxValue\n    ) external;\n\n    /**\n        @notice It updates an existent platform setting given a setting name.\n        @notice It only allows to update the value (not the min or max values).\n        @notice In case you need to update the min or max values, you need to remove it, and create it again.\n        @param settingName setting name to update.\n        @param newValue the new value to set.\n     */\n    function updatePlatformSetting(bytes32 settingName, uint256 newValue) external;\n\n    /**\n        @notice Removes a current platform setting given a setting name.\n        @param settingName to remove.\n     */\n    function removePlatformSetting(bytes32 settingName) external;\n\n    /**\n        @notice It gets the current platform setting for a given setting name\n        @param settingName to get.\n        @return the current platform setting.\n     */\n    function getPlatformSetting(bytes32 settingName)\n        external\n        view\n        returns (PlatformSettingsLib.PlatformSetting memory);\n\n    /**\n        @notice It gets the current platform setting value for a given setting name\n        @param settingName to get.\n        @return the current platform setting value.\n     */\n    function getPlatformSettingValue(bytes32 settingName) external view returns (uint256);\n\n    /**\n        @notice It tests whether a setting name is already configured.\n        @param settingName setting name to test.\n        @return true if the setting is already configured. Otherwise it returns false.\n     */\n    function hasPlatformSetting(bytes32 settingName) external view returns (bool);\n\n    /**\n        @notice It gets whether the platform is paused or not.\n        @return true if platform is paused. Otherwise it returns false.\n     */\n    function isPaused() external view returns (bool);\n\n    /**\n        @notice It gets whether a lending pool is paused or not.\n        @param lendingPoolAddress lending pool address to test.\n        @return true if the lending pool is paused. Otherwise it returns false.\n     */\n    function lendingPoolPaused(address lendingPoolAddress) external view returns (bool);\n\n    /**\n        @notice It pauses a specific lending pool.\n        @param lendingPoolAddress lending pool address to pause.\n     */\n    function pauseLendingPool(address lendingPoolAddress) external;\n\n    /**\n        @notice It unpauses a specific lending pool.\n        @param lendingPoolAddress lending pool address to unpause.\n     */\n    function unpauseLendingPool(address lendingPoolAddress) external;\n\n    /**\n        @notice It creates a new asset settings in the platform.\n        @param assetAddress asset address used to create the new setting.\n        @param cTokenAddress cToken address used to configure the asset setting.\n        @param maxLoanAmount the max loan amount used to configure the asset setting.\n     */\n    function createAssetSettings(\n        address assetAddress,\n        address cTokenAddress,\n        uint256 maxLoanAmount\n    ) external;\n\n    /**\n        @notice It removes all the asset settings for a specific asset address.\n        @param assetAddress asset address used to remove the asset settings.\n     */\n    function removeAssetSettings(address assetAddress) external;\n\n    /**\n        @notice It updates the maximum loan amount for a specific asset address.\n        @param assetAddress asset address to configure.\n        @param newMaxLoanAmount the new maximum loan amount to configure.\n     */\n    function updateMaxLoanAmount(address assetAddress, uint256 newMaxLoanAmount) external;\n\n    /**\n        @notice It updates the cToken address for a specific asset address.\n        @param assetAddress asset address to configure.\n        @param newCTokenAddress the new cToken address to configure.\n     */\n    function updateCTokenAddress(address assetAddress, address newCTokenAddress) external;\n\n    /**\n        @notice Gets the current asset addresses list.\n        @return the asset addresses list.\n     */\n    function getAssets() external view returns (address[] memory);\n\n    /**\n        @notice Get the current asset settings for a given asset address.\n        @param assetAddress asset address used to get the current settings.\n        @return the current asset settings.\n     */\n    function getAssetSettings(address assetAddress)\n        external\n        view\n        returns (AssetSettingsLib.AssetSettings memory);\n\n    /**\n        @notice Tests whether amount exceeds the current maximum loan amount for a specific asset settings.\n        @param assetAddress asset address to test the setting.\n        @param amount amount to test.\n        @return true if amount exceeds current max loan amout. Otherwise it returns false.\n     */\n    function exceedsMaxLoanAmount(address assetAddress, uint256 amount)\n        external\n        view\n        returns (bool);\n\n    /**\n        @notice Tests whether an account has the pauser role.\n        @param account account to test.\n        @return true if account has the pauser role. Otherwise it returns false.\n     */\n    function hasPauserRole(address account) external view returns (bool);\n}\n\ninterface IATMSettings {\n    /** Events */\n\n    /**\n        @notice This event is emitted when an ATM is paused.\n        @param atm paused ATM address.\n        @param account address that paused the ATM.\n     */\n    event ATMPaused(address indexed atm, address indexed account);\n\n    /**\n        @notice This event is emitted when an ATM is unpaused.\n        @param atm unpaused ATM address.\n        @param account address that unpaused the ATM.\n     */\n    event ATMUnpaused(address indexed account, address indexed atm);\n\n    /**\n        @notice This event is emitted when the setting for a Market/ATM is set.\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param atm ATM address to set in the given market.\n        @param account address that set the setting.\n     */\n    event MarketToAtmSet(\n        address indexed borrowedToken,\n        address indexed collateralToken,\n        address indexed atm,\n        address account\n    );\n\n    /**\n        @notice This event is emitted when the setting for a Market/ATM is updated.\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param oldAtm the old ATM address in the given market.\n        @param newAtm the new ATM address in the given market.\n        @param account address that updated the setting.\n     */\n    event MarketToAtmUpdated(\n        address indexed borrowedToken,\n        address indexed collateralToken,\n        address indexed oldAtm,\n        address newAtm,\n        address account\n    );\n\n    /**\n        @notice This event is emitted when the setting for a Market/ATM is removed.\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param oldAtm last ATM address in the given market.\n        @param account address that removed the setting.\n     */\n    event MarketToAtmRemoved(\n        address indexed borrowedToken,\n        address indexed collateralToken,\n        address indexed oldAtm,\n        address account\n    );\n\n    /* State Variables */\n\n    /** Modifiers */\n\n    /* Constructor */\n\n    /** External Functions */\n\n    /**\n        @notice It pauses an given ATM.\n        @param atmAddress ATM address to pause.\n     */\n    function pauseATM(address atmAddress) external;\n\n    /**\n        @notice It unpauses an given ATM.\n        @param atmAddress ATM address to unpause.\n     */\n    function unpauseATM(address atmAddress) external;\n\n    /**\n        @notice Gets whether an ATM is paused or not.\n        @param atmAddress ATM address to test.\n        @return true if ATM is paused. Otherwise it returns false.\n     */\n    function isATMPaused(address atmAddress) external view returns (bool);\n\n    /**\n        @notice Sets an ATM for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param atmAddress ATM address to set.\n     */\n    function setATMToMarket(\n        address borrowedToken,\n        address collateralToken,\n        address atmAddress\n    ) external;\n\n    /**\n        @notice Updates a new ATM for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param newAtmAddress the new ATM address to update.\n     */\n    function updateATMToMarket(\n        address borrowedToken,\n        address collateralToken,\n        address newAtmAddress\n    ) external;\n\n    /**\n        @notice Removes the ATM address for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n     */\n    function removeATMToMarket(address borrowedToken, address collateralToken) external;\n\n    /**\n        @notice Gets the ATM configured for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @return the ATM address configured for a given market.\n     */\n    function getATMForMarket(address borrowedToken, address collateralToken)\n        external\n        view\n        returns (address);\n\n    /**\n        @notice Tests whether an ATM is configured for a given market (borrowed token and collateral token) or not.\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param atmAddress ATM address to test.\n        @return true if the ATM is configured for the market. Otherwise it returns false.\n     */\n    function isATMForMarket(\n        address borrowedToken,\n        address collateralToken,\n        address atmAddress\n    ) external view returns (bool);\n}\n\ncontract ATMSettings is IATMSettings {\n    using Address for address;\n    /** Constants */\n\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* State Variables */\n\n    SettingsInterface public settings;\n\n    /**\n        @notice It represents a mapping to identify whether a ATM is paused or not.\n\n        i.e.: address(ATM) => true or false.\n     */\n    mapping(address => bool) public atmPaused;\n\n    /**\n        @notice It represents a mapping to identify the ATM used in a given market.\n        @notice A market is defined by a borrowed token and a collateral token.\n\n        i.e.: address(DAI) => address(ETH) => address(ATM Teller)\n     */\n    mapping(address => mapping(address => address)) public marketToAtm;\n\n    /** Modifiers */\n\n    /**\n        @notice It checks whether sender address has the pauser role or not.\n        @dev It throws a require error if sender hasn't the pauser role.\n     */\n    modifier withPauserRole() {\n        require(settings.hasPauserRole(msg.sender), \"SENDER_HASNT_PAUSER_ROLE\");\n        _;\n    }\n\n    /* Constructor */\n\n    constructor(address settingsAddress) public {\n        require(settingsAddress != address(0x0), \"SETTINGS_MUST_BE_PROVIDED\");\n\n        settings = SettingsInterface(settingsAddress);\n    }\n\n    /** External Functions */\n\n    /**\n        @notice It pauses a given ATM.\n        @param atmAddress ATM address to pause.\n     */\n    function pauseATM(address atmAddress) external withPauserRole() {\n        require(settings.isPaused() == false, \"PLATFORM_IS_ALREADY_PAUSED\");\n        require(atmPaused[atmAddress] == false, \"ATM_IS_ALREADY_PAUSED\");\n\n        atmPaused[atmAddress] = true;\n\n        emit ATMPaused(atmAddress, msg.sender);\n    }\n\n    /**\n        @notice It unpauses a given ATM.\n        @param atmAddress ATM address to unpause.\n     */\n    function unpauseATM(address atmAddress) external withPauserRole() {\n        require(settings.isPaused() == false, \"PLATFORM_IS_PAUSED\");\n        require(atmPaused[atmAddress] == true, \"ATM_IS_NOT_PAUSED\");\n\n        atmPaused[atmAddress] = false;\n\n        emit ATMUnpaused(msg.sender, atmAddress);\n    }\n\n    /**\n        @notice Gets whether an ATM is paused (or the platform is paused) or not.\n        @param atmAddress ATM address to test.\n        @return true if ATM is paused. Otherwise it returns false.\n     */\n    function isATMPaused(address atmAddress) external view returns (bool) {\n        return settings.isPaused() || atmPaused[atmAddress];\n    }\n\n    /**\n        @notice Sets an ATM for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param atmAddress ATM address to set.\n     */\n    function setATMToMarket(\n        address borrowedToken,\n        address collateralToken,\n        address atmAddress\n    ) external withPauserRole() {\n        require(borrowedToken.isContract() == true, \"BORROWED_TOKEN_MUST_BE_CONTRACT\");\n        require(\n            collateralToken == ETH_ADDRESS || collateralToken.isContract() == true,\n            \"COLL_TOKEN_MUST_BE_CONTRACT\"\n        );\n        require(\n            marketToAtm[borrowedToken][collateralToken] == address(0x0),\n            \"ATM_TO_MARKET_ALREADY_EXIST\"\n        );\n\n        marketToAtm[borrowedToken][collateralToken] = atmAddress;\n\n        emit MarketToAtmSet(borrowedToken, collateralToken, atmAddress, msg.sender);\n    }\n\n    /**\n        @notice Updates a new ATM for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param newAtmAddress the new ATM address to update.\n     */\n    function updateATMToMarket(\n        address borrowedToken,\n        address collateralToken,\n        address newAtmAddress\n    ) external withPauserRole() {\n        require(borrowedToken.isContract() == true, \"BORROWED_TOKEN_MUST_BE_CONTRACT\");\n        require(\n            collateralToken == ETH_ADDRESS || collateralToken.isContract() == true,\n            \"COLL_TOKEN_MUST_BE_CONTRACT\"\n        );\n        require(\n            marketToAtm[borrowedToken][collateralToken] != address(0x0),\n            \"ATM_TO_MARKET_NOT_EXIST\"\n        );\n        require(\n            marketToAtm[borrowedToken][collateralToken] != newAtmAddress,\n            \"PROVIDE_NEW_ATM_FOR_MARKET\"\n        );\n\n        address oldAtm = marketToAtm[borrowedToken][collateralToken];\n\n        marketToAtm[borrowedToken][collateralToken] = newAtmAddress;\n\n        emit MarketToAtmUpdated(\n            borrowedToken,\n            collateralToken,\n            oldAtm,\n            newAtmAddress,\n            msg.sender\n        );\n    }\n\n    /**\n        @notice Removes the ATM address for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n     */\n    function removeATMToMarket(address borrowedToken, address collateralToken)\n        external\n        withPauserRole()\n    {\n        require(borrowedToken.isContract() == true, \"BORROWED_TOKEN_MUST_BE_CONTRACT\");\n        require(\n            collateralToken == ETH_ADDRESS || collateralToken.isContract() == true,\n            \"COLL_TOKEN_MUST_BE_CONTRACT\"\n        );\n        require(\n            marketToAtm[borrowedToken][collateralToken] != address(0x0),\n            \"ATM_TO_MARKET_NOT_EXIST\"\n        );\n\n        address oldAtmAddress = marketToAtm[borrowedToken][collateralToken];\n\n        delete marketToAtm[borrowedToken][collateralToken];\n\n        emit MarketToAtmRemoved(\n            borrowedToken,\n            collateralToken,\n            oldAtmAddress,\n            msg.sender\n        );\n    }\n\n    /**\n        @notice Gets the ATM configured for a given market (borrowed token and collateral token).\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @return the ATM address configured for a given market.\n     */\n    function getATMForMarket(address borrowedToken, address collateralToken)\n        external\n        view\n        returns (address)\n    {\n        return marketToAtm[borrowedToken][collateralToken];\n    }\n\n    /**\n        @notice Tests whether an ATM is configured for a given market (borrowed token and collateral token) or not.\n        @param borrowedToken borrowed token address.\n        @param collateralToken collateral token address.\n        @param atmAddress ATM address to test.\n        @return true if the ATM is configured for the market. Otherwise it returns false.\n     */\n    function isATMForMarket(\n        address borrowedToken,\n        address collateralToken,\n        address atmAddress\n    ) external view returns (bool) {\n        return marketToAtm[borrowedToken][collateralToken] == atmAddress;\n    }\n\n    /** Internal functions */\n\n    /** Private functions */\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"settingsAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"atm\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ATMPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"atm\",\"type\":\"address\"}],\"name\":\"ATMUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowedToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAtm\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MarketToAtmRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowedToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"atm\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MarketToAtmSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowedToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAtm\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAtm\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MarketToAtmUpdated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"atmPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"}],\"name\":\"getATMForMarket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"atmAddress\",\"type\":\"address\"}],\"name\":\"isATMForMarket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"atmAddress\",\"type\":\"address\"}],\"name\":\"isATMPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketToAtm\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"atmAddress\",\"type\":\"address\"}],\"name\":\"pauseATM\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"}],\"name\":\"removeATMToMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"atmAddress\",\"type\":\"address\"}],\"name\":\"setATMToMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settings\",\"outputs\":[{\"internalType\":\"contract SettingsInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"atmAddress\",\"type\":\"address\"}],\"name\":\"unpauseATM\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAtmAddress\",\"type\":\"address\"}],\"name\":\"updateATMToMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ATMSettings","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001d8f58d89c46562d9e6050c8ad0eec93dc8a2db3","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}