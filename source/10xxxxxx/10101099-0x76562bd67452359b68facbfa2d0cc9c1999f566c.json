{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n\r\n\r\ncontract LockMapping {\r\n\r\n  Receipt[] public receipts;\r\n  uint256 public receiptCount;\r\n\r\n\tstruct Receipt {\r\n\r\n\t\taddress asset;\r\n\t    address owner;\t\t//owner of this receipt\r\n\t    string targetAddress;\r\n\t    uint256 amount;\r\n\t    uint256 startTime;\r\n\t    uint256 endTime;\r\n\t    bool finished;\r\n\r\n  \t}\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract MerkleTreeGenerator is Owned {\r\n\r\n    using SafeMath for uint256;\r\n\tevent Log(bytes data);\r\n\r\n\tLockMapping candyReceipt = LockMapping(0x91517330816D4727EDc7C3F5Ae4CC5beF02Ec70f);\r\n\r\n\tuint256 constant pathMaximalLength = 7;\r\n\tuint256 constant public MerkleTreeMaximalLeafCount = 1 << pathMaximalLength;\r\n\tuint256 constant treeMaximalSize = MerkleTreeMaximalLeafCount * 2;\r\n\tuint256 public MerkleTreeCount = 0;\r\n\tuint256 public ReceiptCountInTree = 0;\r\n\tmapping (uint256 => MerkleTree) indexToMerkleTree;\r\n\r\n\tstruct MerkleTree {\r\n\t\tbytes32 root;\r\n\t\tuint256 leaf_count;\r\n        uint256 first_recipt_id;\r\n        uint256 size;\r\n  \t}\r\n\r\n  \tstruct MerkleNode {\r\n\r\n\t\tbytes32 hash;\r\n\t\tbool is_left_child_node;\r\n\r\n  \t}\r\n\r\n  \tstruct MerklePath {\r\n  \t    MerkleNode[] merkle_path_nodes;\r\n  \t}\r\n\r\n  \tstruct Receipt {\r\n\r\n\t\t  address asset;\t\t\r\n\t    address owner;\t\t\r\n\t    string targetAddress;\r\n\t    uint256 amount;\r\n\t    uint256 startTime;\r\n\t    uint256 endTime;\r\n\t    bool finished;\r\n\r\n  \t}\r\n\r\n\r\n\r\n  \t//fetch receipts\r\n  \tfunction ReceiptsToLeaves(uint256 _start, uint256 _leafCount, bool _event) internal returns (bytes32[]){\r\n  \t    bytes32[] memory leaves = new bytes32[](_leafCount);\r\n\r\n\t\tfor(uint256 i = _start; i< _start + _leafCount; i++) {\r\n            (\r\n    \t\t    ,\r\n    \t\t    ,\r\n    \t\t    string memory targetAddress,\r\n    \t\t    uint256 amount,\r\n    \t\t    ,\r\n    \t\t    ,\r\n    \t\t    bool finished\r\n\t\t    ) = candyReceipt.receipts(i);\r\n\r\n\r\n\t\t    bytes32 amountHash = sha256(amount);\r\n\t\t    bytes32 targetAddressHash = sha256(targetAddress);\r\n\t\t    bytes32 receiptIdHash = sha256(i);\r\n\r\n\t\t    leaves[i - _start] = (sha256(amountHash, targetAddressHash, receiptIdHash));\r\n\r\n\t\t    if(_event)\r\n\t\t        Log(abi.encodePacked(amountHash, targetAddressHash, receiptIdHash));\r\n        }\r\n\r\n        return leaves;\r\n  \t}\r\n\r\n  \t \t//create new receipt\r\n\tfunction GenerateMerkleTree() external onlyOwner {\r\n\r\n        uint256 receiptCount = candyReceipt.receiptCount() - ReceiptCountInTree;\r\n\r\n\t\trequire(receiptCount > 0);\r\n\r\n\t\tuint256 leafCount = receiptCount < MerkleTreeMaximalLeafCount ? receiptCount : MerkleTreeMaximalLeafCount;\r\n        bytes32[] memory leafNodes = ReceiptsToLeaves(ReceiptCountInTree, leafCount, true);\r\n\r\n\r\n        bytes32[treeMaximalSize] memory allNodes;\r\n  \t    uint256 nodeCount;\r\n\r\n  \t    (allNodes, nodeCount) = LeavesToTree(leafNodes);\r\n\r\n\t\tMerkleTree memory merkleTree = MerkleTree(allNodes[nodeCount - 1], leafCount, ReceiptCountInTree, nodeCount);\r\n\r\n\t\tindexToMerkleTree[MerkleTreeCount] = merkleTree;\r\n\t\tReceiptCountInTree = ReceiptCountInTree + leafCount;\r\n\t\tMerkleTreeCount = MerkleTreeCount + 1;\r\n  \t}\r\n\r\n  \t//get users merkle tree path\r\n  \tfunction GenerateMerklePath(uint256 receiptId) public view returns(uint256, uint256, bytes32[pathMaximalLength], bool[pathMaximalLength]) {\r\n\r\n  \t    require(receiptId < ReceiptCountInTree);\r\n  \t    uint256 treeIndex = MerkleTreeCount - 1;\r\n  \t    for (; treeIndex >= 0 ; treeIndex--){\r\n\r\n  \t        if (receiptId >= indexToMerkleTree[treeIndex].first_recipt_id)\r\n  \t            break;\r\n  \t    }\r\n\r\n  \t    bytes32[pathMaximalLength] memory neighbors;\r\n  \t    bool[pathMaximalLength] memory isLeftNeighbors;\r\n  \t    uint256 pathLength;\r\n\r\n  \t    MerkleTree merkleTree = indexToMerkleTree[treeIndex];\r\n  \t    uint256 index = receiptId - merkleTree.first_recipt_id;\r\n  \t    (pathLength, neighbors, isLeftNeighbors) = GetPath(merkleTree, index);\r\n  \t    return (treeIndex, pathLength, neighbors, isLeftNeighbors);\r\n\r\n  \t}\r\n\r\n  \tfunction LeavesToTree(bytes32[] _leaves) internal returns (bytes32[treeMaximalSize], uint256){\r\n        uint256 leafCount = _leaves.length;\r\n\t\tbytes32 left;\r\n\t\tbytes32 right;\r\n\r\n        uint256 newAdded = 0;\r\n\t\tuint256 i = 0;\r\n\r\n\t\tbytes32[treeMaximalSize] memory nodes;\r\n\r\n\t\tfor (uint256 t = 0; t < leafCount ; t++)\r\n\t\t{\r\n\t\t    nodes[t] = _leaves[t];\r\n\t\t}\r\n\r\n\t\tuint256 nodeCount = leafCount;\r\n        if(_leaves.length % 2 == 1) {\r\n            nodes[leafCount] = (_leaves[leafCount - 1]);\r\n            nodeCount = nodeCount + 1;\r\n        }\r\n\r\n\r\n        // uint256 nodeToAdd = nodes.length / 2;\r\n        uint256 nodeToAdd = nodeCount / 2;\r\n\r\n\t\twhile( i < nodeCount - 1) {\r\n\r\n\t\t    left = nodes[i++];\r\n            right = nodes[i++];\r\n            nodes[nodeCount++] = sha256(left,right);\r\n            if (++newAdded != nodeToAdd)\r\n                continue;\r\n\r\n            if (nodeToAdd % 2 == 1 && nodeToAdd != 1)\r\n            {\r\n                nodeToAdd++;\r\n                nodes[nodeCount] = nodes[nodeCount - 1];\r\n                nodeCount++;\r\n            }\r\n\r\n            nodeToAdd /= 2;\r\n            newAdded = 0;\r\n\t\t}\r\n\r\n\t\treturn (nodes, nodeCount);\r\n  \t}\r\n\r\n  \tfunction GetPath(MerkleTree _merkleTree, uint256 _index) internal returns(uint256, bytes32[pathMaximalLength],bool[pathMaximalLength]){\r\n\r\n  \t    bytes32[] memory leaves = ReceiptsToLeaves(_merkleTree.first_recipt_id, _merkleTree.leaf_count, false);\r\n  \t    bytes32[treeMaximalSize] memory allNodes;\r\n  \t    uint256 nodeCount;\r\n\r\n  \t    (allNodes, nodeCount)= LeavesToTree(leaves);\r\n  \t    require(nodeCount == _merkleTree.size);\r\n\r\n  \t    bytes32[] memory nodes = new bytes32[](_merkleTree.size);\r\n  \t    for (uint256 t = 0; t < _merkleTree.size; t++){\r\n  \t        nodes[t] = allNodes[t];\r\n  \t    }\r\n\r\n  \t    return GeneratePath(nodes, _merkleTree.leaf_count, _index);\r\n  \t}\r\n\r\n  \tfunction GeneratePath(bytes32[] _nodes, uint256 _leafCount, uint256 _index) internal returns(uint256, bytes32[pathMaximalLength],bool[pathMaximalLength]){\r\n  \t    bytes32[pathMaximalLength] memory neighbors;\r\n  \t    bool[pathMaximalLength] memory isLeftNeighbors;\r\n  \t    uint256 indexOfFirstNodeInRow = 0;\r\n  \t    uint256 nodeCountInRow = _leafCount;\r\n  \t    bytes32 neighbor;\r\n  \t    bool isLeftNeighbor;\r\n  \t    uint256 shift;\r\n  \t    uint256 i = 0;\r\n\r\n  \t    while (_index < _nodes.length - 1) {\r\n\r\n            if (_index % 2 == 0)\r\n            {\r\n                // add right neighbor node\r\n                neighbor = _nodes[_index + 1];\r\n                isLeftNeighbor = false;\r\n            }\r\n            else\r\n            {\r\n                // add left neighbor node\r\n                neighbor = _nodes[_index - 1];\r\n                isLeftNeighbor = true;\r\n            }\r\n\r\n            neighbors[i] = neighbor;\r\n            isLeftNeighbors[i++] = isLeftNeighbor;\r\n\r\n            nodeCountInRow = nodeCountInRow % 2 == 0 ? nodeCountInRow : nodeCountInRow + 1;\r\n            shift = (_index - indexOfFirstNodeInRow) / 2;\r\n            indexOfFirstNodeInRow += nodeCountInRow;\r\n            _index = indexOfFirstNodeInRow + shift;\r\n            nodeCountInRow /= 2;\r\n\r\n  \t    }\r\n\r\n  \t    return (i, neighbors,isLeftNeighbors);\r\n  \t}\r\n\r\n    function GetMerkleTreeNodes(uint256 treeIndex) public view returns (bytes32[], uint256){\r\n        MerkleTree merkleTree = indexToMerkleTree[treeIndex];\r\n  \t    bytes32[] memory leaves = ReceiptsToLeaves(merkleTree.first_recipt_id, merkleTree.leaf_count, false);\r\n  \t    bytes32[treeMaximalSize] memory allNodes;\r\n  \t    uint256 nodeCount;\r\n\r\n  \t    (allNodes, nodeCount)= LeavesToTree(leaves);\r\n  \t    require(nodeCount == merkleTree.size);\r\n\r\n  \t    bytes32[] memory nodes = new bytes32[](merkleTree.size);\r\n  \t    for (uint256 t = 0; t < merkleTree.size; t++){\r\n  \t        nodes[t] = allNodes[t];\r\n  \t    }\r\n        return (nodes, merkleTree.leaf_count);\r\n    }\r\n\r\n    function GetMerkleTree(uint256 treeIndex) public view returns (bytes32, uint256, uint256, uint256){\r\n        require(treeIndex < MerkleTreeCount);\r\n        MerkleTree merkleTree = indexToMerkleTree[treeIndex];\r\n        return (merkleTree.root, merkleTree.first_recipt_id, merkleTree.leaf_count, merkleTree.size);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"treeIndex\",\"type\":\"uint256\"}],\"name\":\"GetMerkleTree\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MerkleTreeCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"treeIndex\",\"type\":\"uint256\"}],\"name\":\"GetMerkleTreeNodes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MerkleTreeMaximalLeafCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"GenerateMerkleTree\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"receiptId\",\"type\":\"uint256\"}],\"name\":\"GenerateMerklePath\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32[7]\"},{\"name\":\"\",\"type\":\"bool[7]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReceiptCountInTree\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MerkleTreeGenerator","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bd0a18f813e1b56966850cb6cfb71feb0b1d65bc2a987277ba5c385c61cb64b3"}]}