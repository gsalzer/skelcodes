{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17; // optimization runs: 200\r\n\r\n\r\ninterface DharmaTradeReserveV1Interface {\r\n  event RoleModified(Role indexed role, address account);\r\n  event RolePaused(Role indexed role);\r\n  event RoleUnpaused(Role indexed role);\r\n\r\n  enum Role {\r\n    WITHDRAWAL_MANAGER,\r\n    PAUSER\r\n  }\r\n\r\n  struct RoleStatus {\r\n    address account;\r\n    bool paused;\r\n  }\r\n  \r\n  function tradeDaiForEther(\r\n    uint256 daiAmount,\r\n    uint256 quotedEtherAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalDaiSold);\r\n  \r\n  function tradeEtherForDai(\r\n    uint256 quotedDaiAmount,\r\n    uint256 deadline\r\n  ) external payable returns (uint256 totalDaiBought);\r\n\r\n  function withdrawEther(address payable recipient, uint256 etherAmount) external;\r\n\r\n  function withdrawDai(address recipient, uint256 daiAmount) external;\r\n\r\n  function withdrawDaiToPrimaryRecipient(uint256 daiAmount) external;\r\n\r\n  function withdraw(\r\n    ERC20Interface token, address recipient, uint256 amount\r\n  ) external returns (bool success);\r\n\r\n  function callAny(\r\n    address payable target, uint256 amount, bytes calldata data\r\n  ) external returns (bool ok, bytes memory returnData);\r\n\r\n  function setPrimaryRecipient(address recipient) external;\r\n\r\n  function setRole(Role role, address account) external;\r\n\r\n  function removeRole(Role role) external;\r\n\r\n  function pause(Role role) external;\r\n\r\n  function unpause(Role role) external;\r\n\r\n  function isPaused(Role role) external view returns (bool paused);\r\n\r\n  function isRole(Role role) external view returns (bool hasRole);\r\n\r\n  function getWithdrawalManager() external view returns (address withdrawalManager);\r\n\r\n  function getPauser() external view returns (address pauser);\r\n  \r\n  function getReserves() external view returns (\r\n    uint256 eth, uint256 dai\r\n  );\r\n\r\n  function getPrimaryRecipient() external view returns (\r\n    address recipient\r\n  );\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n  function balanceOf(address) external view returns (uint256);\r\n  function approve(address, uint256) external returns (bool);\r\n  function transfer(address, uint256) external returns (bool);\r\n  function transferFrom(address, address, uint256) external returns (bool);\r\n}\r\n\r\n\r\ninterface UniswapV1Interface {\r\n  function ethToTokenSwapInput(\r\n    uint256 minTokens, uint256 deadline\r\n  ) external payable returns (uint256 tokensBought);\r\n\r\n  function tokenToEthTransferOutput(\r\n    uint256 ethBought, uint256 maxTokens, uint256 deadline, address recipient\r\n  ) external returns (uint256 tokensSold);\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n *\r\n * In order to transfer ownership, a recipient must be specified, at which point\r\n * the specified recipient can call `acceptOwnership` and take ownership.\r\n */\r\ncontract TwoStepOwnable {\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  address private _owner;\r\n\r\n  address private _newPotentialOwner;\r\n\r\n  /**\r\n   * @dev Allows a new account (`newOwner`) to accept ownership.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    require(\r\n      newOwner != address(0),\r\n      \"TwoStepOwnable: new potential owner is the zero address.\"\r\n    );\r\n\r\n    _newPotentialOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel a transfer of ownership to a new account.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function cancelOwnershipTransfer() external onlyOwner {\r\n    delete _newPotentialOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to the caller.\r\n   * Can only be called by a new potential owner set by the current owner.\r\n   */\r\n  function acceptOwnership() external {\r\n    require(\r\n      msg.sender == _newPotentialOwner,\r\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\r\n    );\r\n\r\n    delete _newPotentialOwner;\r\n\r\n    emit OwnershipTransferred(_owner, msg.sender);\r\n\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() external view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n  \r\n  function _initializeOwner() internal {\r\n    // Ensure that this function is only callable during contract construction.\r\n    assembly { if extcodesize(address) { revert(0, 0) } }\r\n    \r\n    // Set the transaction submitter as the initial owner.\r\n    _owner = tx.origin;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaTradeReserveV1\r\n * @author 0age\r\n * @notice This contract facilitates Eth <=> Dai trades. It designates a\r\n * collection of \"roles\" - these are dedicated accounts that can be modified by\r\n * the owner, and that can trigger specific functionality. These roles are:\r\n *  - withdrawalManager (0): initiates transfers to a recipient set by owner\r\n *  - pauser (1): pauses any role (only the owner is then able to unpause it)\r\n *\r\n * Reserves can be retrieved via `getReserves`, and current withdrawal addresses\r\n * via `getPrimaryRecipient`.\r\n */\r\ncontract DharmaTradeReserveV1 is DharmaTradeReserveV1Interface, TwoStepOwnable {\r\n  // Maintain a role status mapping with assigned accounts and paused states.\r\n  mapping(uint256 => RoleStatus) private _roles;\r\n\r\n  // Maintain a \"primary recipient\" the withdrawal manager can transfer Dai to.\r\n  address private _primaryRecipient;\r\n\r\n  // This contract interacts with Dai and Uniswap V1.\r\n  ERC20Interface internal constant _DAI = ERC20Interface(\r\n    0x6B175474E89094C44Da98b954EedeAC495271d0F\r\n  );\r\n  \r\n  UniswapV1Interface internal constant _UNISWAP_DAI = UniswapV1Interface(\r\n    0x2a1530C4C41db0B0b2bB646CB5Eb1A67b7158667\r\n  );\r\n\r\n  /**\r\n   * @notice In the initializer, set the initial owner to the transaction\r\n   * submitter and set full allowance for Uniswap to transfer Dai.\r\n   */\r\n  function initialize() external {\r\n    // Ensure that this function is only callable during contract construction.\r\n    assembly { if extcodesize(address) { revert(0, 0) } }\r\n      \r\n    // Set the transaction submitter as the initial owner.\r\n    _initializeOwner();\r\n  \r\n    // Call Dai to set an allowance for Uniswap in order to perform trades.\r\n    require(_DAI.approve(address(_UNISWAP_DAI), uint256(-1)));\r\n  }\r\n  \r\n  /**\r\n   * @notice Pull in `daiAmount` Dai from the caller, trade it for Ether using\r\n   * Uniswap, and return `quotedEtherAmount` Ether to the caller.\r\n   * @param daiAmount uint256 The amount of Dai to supply when trading for Ether.\r\n   * @param quotedEtherAmount uint256 The amount of Ether to return to the caller.\r\n   * @param deadline uint256 The timestamp the order is valid until.\r\n   * @return The amount of Dai sold as part of the trade.\r\n   */\r\n  function tradeDaiForEther(\r\n    uint256 daiAmount,\r\n    uint256 quotedEtherAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalDaiSold) {\r\n    // Transfer the Dai from the caller and revert on failure.\r\n    bool ok = (_DAI.transferFrom(msg.sender, address(this), daiAmount));\r\n    require(ok, \"Dai transfer in failed.\");\r\n    \r\n    // Trade the Dai for the quoted Ether amount on Uniswap and send to caller.\r\n    totalDaiSold = _UNISWAP_DAI.tokenToEthTransferOutput(\r\n      quotedEtherAmount, daiAmount, deadline, msg.sender\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Accept `msg.value` Ether from the caller, trade it for Dai using\r\n   * Uniswap, and return `quotedDaiAmount` Dai to the caller.\r\n   * @param quotedDaiAmount uint256 The amount of Dai to return to the caller.\r\n   * @param deadline uint256 The timestamp the order is valid until.\r\n   * @return The amount of Dai bought as part of the trade.\r\n   */ \r\n  function tradeEtherForDai(\r\n    uint256 quotedDaiAmount,\r\n    uint256 deadline\r\n  ) external payable returns (uint256 totalDaiBought) {\r\n    // Trade the Ether for the quoted Dai amount on Uniswap.\r\n    totalDaiBought = _UNISWAP_DAI.ethToTokenSwapInput.value(msg.value)(\r\n      quotedDaiAmount, deadline\r\n    );\r\n\r\n    // Transfer the Dai to the caller and revert on failure.\r\n    bool ok = (_DAI.transfer(msg.sender, quotedDaiAmount));\r\n    require(ok, \"Dai transfer out failed.\");\r\n  }\r\n  \r\n  /**\r\n   * @notice Transfer `daiAmount` Dai for to the current primary recipient set by\r\n   * the owner. Only the owner or the designated withdrawal manager role may call\r\n   * this function.\r\n   * @param daiAmount uint256 The amount of Dai to transfer to the primary\r\n   * recipient.\r\n   */ \r\n  function withdrawDaiToPrimaryRecipient(\r\n    uint256 daiAmount\r\n  ) external onlyOwnerOr(Role.WITHDRAWAL_MANAGER) {\r\n    // Get the current primary recipient.\r\n    address primaryRecipient = _primaryRecipient;\r\n    require(\r\n      primaryRecipient != address(0), \"No primary recipient currently set.\"\r\n    );\r\n    \r\n    // Transfer the supplied Dai amount to the primary recipient.\r\n    bool ok = _DAI.transfer(primaryRecipient, daiAmount);\r\n    require(ok, \"Dai transfer failed.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `etherAmount` Ether to `recipient`. Only the owner may\r\n   * call this function.\r\n   * @param recipient address The account to transfer Ether to.\r\n   * @param etherAmount uint256 The amount of Ether to transfer.\r\n   */\r\n  function withdrawEther(\r\n    address payable recipient, uint256 etherAmount\r\n  ) external onlyOwner {\r\n    bool ok;\r\n\r\n    // Transfer the Ether to the specified recipient.\r\n    (ok, ) = recipient.call.value(etherAmount)(\"\");\r\n    if (!ok) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `daiAmount` Dai to `recipient`. Only the owner may call\r\n   * this function.\r\n   * @param recipient address The account to transfer Dai to.\r\n   * @param daiAmount uint256 The amount of Dai to transfer.\r\n   */\r\n  function withdrawDai(\r\n    address recipient, uint256 daiAmount\r\n  ) external onlyOwner {\r\n    // Transfer the Dai to the specified recipient.\r\n    require(_DAI.transfer(recipient, daiAmount), \"Dai transfer failed.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `amount` of ERC20 token `token` to `recipient`. Only the\r\n   * owner may call this function.\r\n   * @param token ERC20Interface The ERC20 token to transfer.\r\n   * @param recipient address The account to transfer the tokens to.\r\n   * @param amount uint256 The amount of tokens to transfer.\r\n   * @return A boolean to indicate if the transfer was successful - note that\r\n   * unsuccessful ERC20 transfers will usually revert.\r\n   */\r\n  function withdraw(\r\n    ERC20Interface token, address recipient, uint256 amount\r\n  ) external onlyOwner returns (bool success) {\r\n    // Transfer the token to the specified recipient.\r\n    success = token.transfer(recipient, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Call account `target`, supplying value `amount` and data `data`.\r\n   * Only the owner may call this function.\r\n   * @param target address The account to call.\r\n   * @param amount uint256 The amount of ether to include as an endowment.\r\n   * @param data bytes The data to include along with the call.\r\n   * @return A boolean to indicate if the call was successful, as well as the\r\n   * returned data or revert reason.\r\n   */\r\n  function callAny(\r\n    address payable target, uint256 amount, bytes calldata data\r\n  ) external onlyOwner returns (bool ok, bytes memory returnData) {\r\n    // Call the specified target and supply the specified data.\r\n    (ok, returnData) = target.call.value(amount)(data);\r\n  }\r\n\r\n  /**\r\n   * @notice Set `recipient` as the new primary recipient for Dai withdrawals.\r\n   * Only the owner may call this function.\r\n   * @param recipient address The new primary recipient.\r\n   */\r\n  function setPrimaryRecipient(address recipient) external onlyOwner {\r\n    // Set the new primary recipient.\r\n    _primaryRecipient = recipient;\r\n  }\r\n\r\n  /**\r\n   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\r\n   * the owner or the designated pauser may call this function. Also, bear in\r\n   * mind that only the owner may unpause a role once paused.\r\n   * @param role The role to pause. Permitted roles are withdrawal manager (0)\r\n   * and pauser (1).\r\n   */\r\n  function pause(Role role) external onlyOwnerOr(Role.PAUSER) {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n    require(!storedRoleStatus.paused, \"Role in question is already paused.\");\r\n    storedRoleStatus.paused = true;\r\n    emit RolePaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\r\n   * Only the owner may call this function.\r\n   * @param role The role to unpause. Permitted roles are withdrawal manager (0)\r\n   * and pauser (1).\r\n   */\r\n  function unpause(Role role) external onlyOwner {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n    require(storedRoleStatus.paused, \"Role in question is already unpaused.\");\r\n    storedRoleStatus.paused = false;\r\n    emit RoleUnpaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new account on a given role and emit a `RoleModified` event\r\n   * if the role holder has changed. Only the owner may call this function.\r\n   * @param role The role that the account will be set for. Permitted roles are\r\n   * withdrawal manager (0) and pauser (1).\r\n   * @param account The account to set as the designated role bearer.\r\n   */\r\n  function setRole(Role role, address account) external onlyOwner {\r\n    require(account != address(0), \"Must supply an account.\");\r\n    _setRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove any current role bearer for a given role and emit a\r\n   * `RoleModified` event if a role holder was previously set. Only the owner\r\n   * may call this function.\r\n   * @param role The role that the account will be removed from. Permitted roles\r\n   * are withdrawal manager (0) and pauser (1).\r\n   */\r\n  function removeRole(Role role) external onlyOwner {\r\n    _setRole(role, address(0));\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether or not the functionality\r\n   * associated with a given role is currently paused or not. The owner or the\r\n   * pauser may pause any given role (including the pauser itself), but only the\r\n   * owner may unpause functionality. Additionally, the owner may call paused\r\n   * functions directly.\r\n   * @param role The role to check the pause status on. Permitted roles are\r\n   * withdrawal manager (0) and pauser (1).\r\n   * @return A boolean to indicate if the functionality associated with the role\r\n   * in question is currently paused.\r\n   */\r\n  function isPaused(Role role) external view returns (bool paused) {\r\n    paused = _isPaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether the caller is the current\r\n   * role holder.\r\n   * @param role The role to check for. Permitted roles are withdrawal manager (0)\r\n   * and pauser (1).\r\n   * @return A boolean indicating if the caller has the specified role.\r\n   */\r\n  function isRole(Role role) external view returns (bool hasRole) {\r\n    hasRole = _isRole(role);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * withdrawal manager role. The withdrawal manager can transfer Dai to the\r\n   * \"primary recipient\" address set by the owner.\r\n   * @return The address of the current withdrawal manager, or the null address\r\n   * if none is set.\r\n   */\r\n  function getWithdrawalManager() external view returns (address withdrawalManager) {\r\n    withdrawalManager = _roles[uint256(Role.WITHDRAWAL_MANAGER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * pauser role. The pauser can pause any role from taking its standard action,\r\n   * though the owner will still be able to call the associated function in the\r\n   * interim and is the only entity able to unpause the given role once paused.\r\n   * @return The address of the current pauser, or the null address if none is\r\n   * set.\r\n   */\r\n  function getPauser() external view returns (address pauser) {\r\n    pauser = _roles[uint256(Role.PAUSER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the current reserves held by this\r\n   * contract.\r\n   * @return The Ether and Dai reserves held by this contract.\r\n   */ \r\n  function getReserves() external view returns (\r\n    uint256 eth, uint256 dai\r\n  ) {\r\n    eth = address(this).balance;\r\n    dai = _DAI.balanceOf(address(this));\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the address of the current\r\n   * primary recipient.\r\n   * @return The primary recipient.\r\n   */  \r\n  function getPrimaryRecipient() external view returns (\r\n    address recipient\r\n  ) {\r\n    recipient = _primaryRecipient;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set a new account on a given role and emit a\r\n   * `RoleModified` event if the role holder has changed.\r\n   * @param role The role that the account will be set for. Permitted roles\r\n   * are withdrawal manager (0) and pauser (1).\r\n   * @param account The account to set as the designated role bearer.\r\n   */\r\n  function _setRole(Role role, address account) internal {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n\r\n    if (account != storedRoleStatus.account) {\r\n      storedRoleStatus.account = account;\r\n      emit RoleModified(role, account);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to check whether the caller is the current\r\n   * role holder.\r\n   * @param role The role to check for. Permitted roles are withdrawal manager (0)\r\n   * and pauser (1).\r\n   * @return A boolean indicating if the caller has the specified role.\r\n   */\r\n  function _isRole(Role role) internal view returns (bool hasRole) {\r\n    hasRole = msg.sender == _roles[uint256(role)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to check whether the given role is paused or\r\n   * not.\r\n   * @param role The role to check for. Permitted Permitted roles are withdrawal manager (0)\r\n   * and pauser (1).\r\n   * @return A boolean indicating if the specified role is paused or not.\r\n   */\r\n  function _isPaused(Role role) internal view returns (bool paused) {\r\n    paused = _roles[uint256(role)].paused;\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier that throws if called by any account other than the owner\r\n   * or the supplied role, or if the caller is not the owner and the role in\r\n   * question is paused.\r\n   * @param role The role to require unless the caller is the owner. Permitted\r\n   * Permitted roles are withdrawal manager (0) and pauser (1).\r\n   */\r\n  modifier onlyOwnerOr(Role role) {\r\n    if (!isOwner()) {\r\n      require(_isRole(role), \"Caller does not have a required role.\");\r\n      require(!_isPaused(role), \"Role in question is currently paused.\");\r\n    }\r\n    _;\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DharmaTradeReserveV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RoleModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DharmaTradeReserveV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"RolePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DharmaTradeReserveV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"RoleUnpaused\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callAny\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pauser\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrimaryRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dai\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawalManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"withdrawalManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum DharmaTradeReserveV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum DharmaTradeReserveV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"isRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasRole\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum DharmaTradeReserveV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum DharmaTradeReserveV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"removeRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"setPrimaryRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum DharmaTradeReserveV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quotedEtherAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"tradeDaiForEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalDaiSold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quotedDaiAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"tradeEtherForDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalDaiBought\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum DharmaTradeReserveV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawDaiToPrimaryRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DharmaTradeReserveV1","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://375379ae381231c6120a44d99fd93e87b6eff535a70d77ab68be70359c72a489"}]}