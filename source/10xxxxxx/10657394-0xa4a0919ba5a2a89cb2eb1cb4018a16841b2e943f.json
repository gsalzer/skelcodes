{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/libs/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/common/ZeroCopySource.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary ZeroCopySource {\r\n    /* @notice              Read next byte as boolean type starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the boolean value\r\n    *  @return              The the read boolean value and new offset\r\n    */\r\n    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\r\n        require(offset + 1 <= buff.length, \"Offset exceeds limit\");\r\n        // byte === bytes1\r\n        byte v;\r\n        assembly{\r\n            v := mload(add(add(buff, 0x20), offset))\r\n        }\r\n        bool value;\r\n        if (v == 0x01) {\r\n\t\t    value = true;\r\n    \t} else if (v == 0x00) {\r\n            value = false;\r\n        } else {\r\n            revert(\"NextBool value error\");\r\n        }\r\n        return (value, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next byte starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the byte value\r\n    *  @return              The read byte value and new offset\r\n    */\r\n    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\r\n        require(offset + 1 <= buff.length, \"Offset exceeds maximum\");\r\n        byte v;\r\n        assembly{\r\n            v := mload(add(add(buff, 0x20), offset))\r\n        }\r\n        return (v, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next byte as uint8 starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the byte value\r\n    *  @return              The read uint8 value and new offset\r\n    */\r\n    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\r\n        require(offset + 1 <= buff.length, \"Offset exceeds maximum\");\r\n        uint8 v;\r\n        assembly{\r\n            let tmpbytes := mload(0x40)\r\n            let bvalue := mload(add(add(buff, 0x20), offset))\r\n            mstore8(tmpbytes, byte(0, bvalue))\r\n            mstore(0x40, add(tmpbytes, 0x01))\r\n            v := mload(sub(tmpbytes, 0x1f))\r\n        }\r\n        return (v, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next two bytes as uint16 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint16 value\r\n    *  @return              The read uint16 value and updated offset\r\n    */\r\n    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\r\n        require(offset + 2 <= buff.length, \"offset exceeds maximum\");\r\n        \r\n        uint16 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let bvalue := mload(add(add(buff, 0x20), offset))\r\n            mstore8(tmpbytes, byte(0x01, bvalue))\r\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\r\n            mstore(0x40, add(tmpbytes, 0x02))\r\n            v := mload(sub(tmpbytes, 0x1e))\r\n        }\r\n        return (v, offset + 2);\r\n    }\r\n\r\n\r\n    /* @notice              Read next four bytes as uint32 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint32 value\r\n    *  @return              The read uint32 value and updated offset\r\n    */\r\n    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\r\n        require(offset + 4 <= buff.length, \"offset exceeds maximum\");\r\n        uint32 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x04\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\r\n        }\r\n        return (v, offset + 4);\r\n    }\r\n\r\n    /* @notice              Read next eight bytes as uint64 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint64 value\r\n    *  @return              The read uint64 value and updated offset\r\n    */\r\n    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\r\n        require(offset + 8 <= buff.length, \"offset exceeds maximum\");\r\n        uint64 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x08\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\r\n        }\r\n        return (v, offset + 8);\r\n    }\r\n\r\n    /* @notice              Read next 32 bytes as uint256 type starting from offset,\r\n                            there are limits considering the numerical limits in multi-chain\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint256 value\r\n    *  @return              The read uint256 value and updated offset\r\n    */\r\n    function NextUint256(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\r\n        require(offset + 32 <= buff.length, \"offset exceeds maximum\");\r\n        uint256 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x20\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(tmpbytes)\r\n        }\r\n        require(v >= 0 && v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n        return (v, offset + 32);\r\n    }\r\n    /* @notice              Read next variable bytes starting from offset,\r\n                            the decoding rule coming from multi-chain\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read variable bytes array value and updated offset\r\n    */\r\n    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\r\n        uint len;\r\n        (len, offset) = NextVarUint(buff, offset);\r\n        require(offset + len <= buff.length, \"offset exceeds maximum\");\r\n        bytes memory tempBytes;\r\n        assembly{\r\n            switch iszero(len)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(len, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, len)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, len)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return (tempBytes, offset + len);\r\n    }\r\n    /* @notice              Read next 32 bytes starting from offset,\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read bytes32 value and updated offset\r\n    */\r\n    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\r\n        require(offset + 32 <= buff.length, \"offset exceeds maximum\");\r\n        bytes32 v;\r\n        assembly {\r\n            v := mload(add(buff, add(offset, 0x20)))\r\n        }\r\n        return (v, offset + 32);\r\n    }\r\n\r\n    /* @notice              Read next 20 bytes starting from offset,\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read bytes20 value and updated offset\r\n    */\r\n    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\r\n        require(offset + 20 <= buff.length, \"offset exceeds maximum\");\r\n        bytes20 v;\r\n        assembly {\r\n            v := mload(add(buff, add(offset, 0x20)))\r\n        }\r\n        return (v, offset + 20);\r\n    }\r\n    \r\n    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\r\n        byte v;\r\n        (v, offset) = NextByte(buff, offset);\r\n\r\n        if (v == 0xFD) {\r\n            return NextUint16(buff, offset);\r\n        } else if (v == 0xFE) {\r\n            return NextUint32(buff, offset);\r\n        } else if (v == 0xFF) {\r\n            return NextUint64(buff, offset);\r\n        } else{\r\n            return (uint8(v), offset);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libs/common/ZeroCopySink.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary ZeroCopySink {\r\n    /* @notice          Convert boolean value into bytes\r\n    *  @param b         The boolean value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteBool(bool b) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            mstore(buff, 1)\r\n            switch iszero(b)\r\n            case 1 {\r\n                mstore(add(buff, 0x20), shl(248, 0x00))\r\n                // mstore8(add(buff, 0x20), 0x00)\r\n            }\r\n            default {\r\n                mstore(add(buff, 0x20), shl(248, 0x01))\r\n                // mstore8(add(buff, 0x20), 0x01)\r\n            }\r\n            mstore(0x40, add(buff, 0x40))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert byte value into bytes\r\n    *  @param b         The byte value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteByte(byte b) internal pure returns (bytes memory) {\r\n        return WriteUint8(uint8(b));\r\n    }\r\n\r\n    /* @notice          Convert uint8 value into bytes\r\n    *  @param v         The uint8 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            mstore(buff, 1)\r\n            mstore(add(buff, 0x20), shl(248, v))\r\n            // mstore(add(buff, 0x20), byte(0x1f, v))\r\n            mstore(0x40, add(buff, 0x40))\r\n        }    \r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert uint16 value into bytes\r\n    *  @param v         The uint16 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x02\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x40))\r\n        }\r\n        return buff;\r\n    }\r\n    \r\n    /* @notice          Convert uint32 value into bytes\r\n    *  @param v         The uint32 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x04\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x40))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert uint64 value into bytes\r\n    *  @param v         The uint64 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x08\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x40))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert limited uint256 value into bytes\r\n    *  @param v         The uint256 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\r\n        require(v >= 0 && v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x20\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x40))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Encode bytes format data into bytes\r\n    *  @param data      The bytes array data\r\n    *  @return          Encoded bytes array\r\n    */\r\n    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\r\n        uint64 l = uint64(data.length);\r\n        return abi.encodePacked(WriteVarUint(l), data);\r\n    }\r\n\r\n    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\r\n        if (v < 0xFD){\r\n    \t\treturn WriteUint8(uint8(v));\r\n    \t} else if (v <= 0xFFFF) {\r\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\r\n    \t} else if (v <= 0xFFFFFFFF) {\r\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\r\n    \t} else {\r\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\r\n    \t}\r\n    }\r\n\r\n    // TO Be Checked\r\n    function WriteInt8(int8 v) internal pure returns (bytes memory) {\r\n        return WriteUint8(uint8(v));\r\n    }\r\n\r\n    function WriteInt16(int16 v) internal pure returns (bytes memory){\r\n        return WriteUint16(uint16(v));\r\n    }\r\n\r\n    function WriteInt32(int32 v) internal pure returns (bytes memory) {\r\n        return WriteUint32(uint32(v));\r\n    }\r\n\r\n    function WriteInt64(int64 v) internal pure returns (bytes memory) {\r\n        return WriteUint64(uint64(v));\r\n    }\r\n}\r\n\r\n// File: contracts/libs/utils/Utils.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary Utils {\r\n\r\n    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32\r\n    *  @param _bs   Source bytes array\r\n    *  @return      bytes32\r\n    */\r\n    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\r\n        require(_bs.length == 32, \"bytes length is not 32.\");\r\n        assembly {\r\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\r\n            value := mload(add(_bs, 0x20))\r\n        }\r\n    }\r\n\r\n    /* @notice      Convert bytes to uint256\r\n    *  @param _b    Source bytes should have length of 32\r\n    *  @return      uint256\r\n    */\r\n    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\r\n        require(_bs.length == 32, \"bytes length is not 32.\");\r\n        assembly {\r\n            // load 32 bytes from memory starting from position _bs + 32\r\n            value := mload(add(_bs, 0x20))\r\n        }\r\n        require(value >= 0 && value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n    }\r\n\r\n    /* @notice      Convert uint256 to bytes\r\n    *  @param _b    uint256 that needs to be converted\r\n    *  @return      bytes\r\n    */\r\n    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\r\n        require(_value >= 0 && _value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n        assembly {\r\n            // Get a location of some free memory and store it in result as\r\n            // Solidity does for memory variables.\r\n            bs := mload(0x40)\r\n            // Put 0x20 at the first word, the length of bytes for uint256 value\r\n            mstore(bs, 0x20)\r\n            //In the next word, put value in bytes format to the next 32 bytes\r\n            mstore(add(bs, 0x20), _value)\r\n            // Update the free-memory pointer by padding our last write location to 32 bytes\r\n            mstore(0x40, add(bs, 0x40))\r\n        }\r\n    }\r\n\r\n    /* @notice      Convert bytes to address\r\n    *  @param _bs   Source bytes: bytes length must be 20\r\n    *  @return      Converted address from source bytes\r\n    */\r\n    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\r\n    {\r\n        require(_bs.length == 20, \"bytes length does not match address\");\r\n        assembly {\r\n            // for _bs, first word store _bs.length, second word store _bs.value\r\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\r\n            addr := mload(add(_bs, 0x14))\r\n        }\r\n\r\n    }\r\n    \r\n    /* @notice      Convert address to bytes\r\n    *  @param _addr Address need to be converted\r\n    *  @return      Converted bytes from address\r\n    */\r\n    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\r\n        assembly {\r\n            // Get a location of some free memory and store it in result as\r\n            // Solidity does for memory variables.\r\n            bs := mload(0x40)\r\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\r\n            mstore(bs, 0x14)\r\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\r\n            mstore(add(bs, 0x20), shl(96, _addr))\r\n            // Update the free-memory pointer by padding our last write location to 32 bytes\r\n            mstore(0x40, add(bs, 0x40))\r\n       }\r\n    }\r\n\r\n    /* @notice          Do hash leaf as the multi-chain does\r\n    *  @param _data     Data in bytes format\r\n    *  @return          Hashed value in bytes32 format\r\n    */\r\n    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\r\n        result = sha256(abi.encodePacked(byte(0x0), _data));\r\n    }\r\n\r\n    /* @notice          Do hash children as the multi-chain does\r\n    *  @param _l        Left node\r\n    *  @param _r        Right node\r\n    *  @return          Hashed value in bytes32 format\r\n    */\r\n    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\r\n        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\r\n    }\r\n\r\n    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately\r\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368\r\n    *  @param _preBytes     The bytes stored in storage\r\n    *  @param _postBytes    The bytes stored in memory\r\n    *  @return              Bool type indicating if they are equal\r\n    */\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // fslot can contain both the length and contents of the array\r\n                // if slength < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                // slength != 0\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    /* @notice              Slice the _bytes from _start index till the result has length of _length\r\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246\r\n    *  @param _bytes        The original bytes needs to be sliced\r\n    *  @param _start        The index of _bytes for the start of sliced bytes\r\n    *  @param _length       The index of _bytes for the end of sliced bytes\r\n    *  @return              The sliced bytes\r\n    */\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                // lengthmod <= _length % 32\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    /* @notice              Decide if _addrArray contains _addr\r\n    *  @param _addrArray    The array consist of serveral address\r\n    *  @param _addr         The specific address to be looked into\r\n    *  @return              True means containment, false meansdo do not contain.\r\n    */\r\n    function containsAddress(address[] memory _addrArray, address _addr) internal pure returns (bool exist){\r\n        exist = false;\r\n        for(uint i = 0; i < _addrArray.length; i++){\r\n            if (_addr == _addrArray[i]){\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* @notice              TODO\r\n    *  @param key\r\n    *  @return\r\n    */\r\n    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {\r\n        require(key.length >= 34, \"key lenggh is too short\");\r\n         newkey = slice(key, 0, 35);\r\n         if (uint8(key[66]) % 2 == 0){\r\n             newkey[2] = byte(0x02);\r\n         } else {\r\n             newkey[2] = byte(0x03);\r\n         }\r\n         return newkey;\r\n    }\r\n    \r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /* @notice              In an ordered array,find closet the array\r\n    *                       index whose value closest to the target number.\r\n    *                       The height of the query must be greater than\r\n    *                       the height of the init genesis block height,\r\n    *                       other than it will return -1.\r\n    *  @param _arr          The array to retrieve\r\n    *  @param _len          the array length\r\n    *  @param _v            the target number\r\n    *  @return              the array index whose value closest to the target number.\r\n    */\r\n    function findBookKeeper(uint64[] memory _arr, uint64 _len, uint _v) internal pure returns (uint64, bool) {\r\n        require(_len > 0, \"book keeper list cannot empty\");\r\n        require(_arr.length == _len, \"cannot partially query\");\r\n        require(_v > 0, \"block height must be positive\");\r\n\r\n        uint64 left = 0;\r\n        uint64 right = _len - 1;\r\n\r\n        // if only one block height, just return index 0\r\n        if (_len == 1){\r\n            return (0, true);\r\n        }\r\n\r\n        while (left <= right){\r\n            uint64 middle = left + ((right - left) >> 1);\r\n\r\n            if(_arr[middle] == _v){\r\n                return (middle, true);\r\n            }\r\n\r\n            if(_arr[middle] < _v){\r\n\t\t\t    left = middle + 1;\r\n            } else {\r\n                right = middle - 1;\r\n            }\r\n        }\r\n\r\n        if(left >= 1 && _arr[left - 1] < _v){\r\n            return (left - 1, true);\r\n        }\r\n\r\n        return (0, false);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/core/v2.0/CrossChainManager/interface/IEthCrossChainManager.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IEthCrossChainManager {\r\n    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\r\n}\r\n\r\n// File: contracts/core/v2.0/CrossChainManager/interface/IEthCrossChainManagerProxy.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IEthCrossChainManagerProxy {\r\n    function getEthCrossChainManager() external view returns (address);\r\n}\r\n\r\n// File: contracts/core/v2.0/lockproxypip1/LockProxyPip1.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ERC20Interface {\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract LockProxyPip1 is Context {\r\n    using SafeMath for uint;\r\n\r\n    struct RegisterAssetTxArgs {\r\n        bytes assetHash;\r\n        bytes nativeAssetHash;\r\n    }\r\n\r\n    struct TxArgs {\r\n        bytes fromAssetHash;\r\n        bytes toAssetHash;\r\n        bytes toAddress;\r\n        uint256 amount;\r\n        uint256 feeAmount;\r\n        bytes feeAddress;\r\n        bytes fromAddress;\r\n        uint256 nonce;\r\n    }\r\n\r\n    address public managerProxyContract;\r\n    uint256 public currentNonce = 0;\r\n\r\n    mapping(bytes32 => bool) public registry;\r\n    mapping(bytes32 => uint256) public balances;\r\n\r\n    event SetManagerProxyEvent(address manager);\r\n    event DelegateAssetEvent(address assetHash, uint64 nativeChainId, bytes nativeLockProxy, bytes nativeAssetHash);\r\n    event UnlockEvent(address toAssetHash, address toAddress, uint256 amount, bytes txArgs);\r\n    event LockEvent(address fromAssetHash, address fromAddress, uint64 toChainId, bytes toAssetHash, bytes toAddress, bytes txArgs);\r\n\r\n    constructor(address ethCCMProxyAddr) public {\r\n        managerProxyContract = ethCCMProxyAddr;\r\n        emit SetManagerProxyEvent(managerProxyContract);\r\n    }\r\n\r\n    modifier onlyManagerContract() {\r\n        IEthCrossChainManagerProxy ieccmp = IEthCrossChainManagerProxy(managerProxyContract);\r\n        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\r\n        _;\r\n    }\r\n\r\n    function delegateAsset(uint64 nativeChainId, bytes memory nativeLockProxy, bytes memory nativeAssetHash, uint256 delegatedSupply) public {\r\n        require(nativeChainId > 0, \"nativeChainId cannot be zero\");\r\n        require(nativeLockProxy.length > 0, \"empty nativeLockProxy\");\r\n        require(nativeAssetHash.length > 0, \"empty nativeAssetHash\");\r\n\r\n        address assetHash = _msgSender();\r\n        bytes32 key = _getRegistryKey(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\r\n\r\n        require(registry[key] != true, \"asset already registered\");\r\n        require(balances[key] == 0, \"balance is not zero\");\r\n        require(_balanceFor(assetHash) == delegatedSupply, \"controlled balance does not match delegatedSupply\");\r\n\r\n        registry[key] = true;\r\n\r\n        RegisterAssetTxArgs memory txArgs = RegisterAssetTxArgs({\r\n            assetHash: Utils.addressToBytes(assetHash),\r\n            nativeAssetHash: nativeAssetHash\r\n        });\r\n\r\n        bytes memory txData = _serializeRegisterAssetTxArgs(txArgs);\r\n\r\n        IEthCrossChainManager eccm = _getEccm();\r\n        require(eccm.crossChain(nativeChainId, nativeLockProxy, \"registerAsset\", txData), \"EthCrossChainManager crossChain executed error!\");\r\n        balances[key] = delegatedSupply;\r\n\r\n        emit DelegateAssetEvent(assetHash, nativeChainId, nativeLockProxy, nativeAssetHash);\r\n    }\r\n\r\n    function registerAsset(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {\r\n        RegisterAssetTxArgs memory args = _deserializeRegisterAssetTxArgs(argsBs);\r\n\r\n        bytes32 key = _getRegistryKey(Utils.bytesToAddress(args.nativeAssetHash), fromChainId, fromContractAddr, args.assetHash);\r\n\r\n        require(registry[key] != true, \"asset already registerd\");\r\n        registry[key] = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /* @notice                  This function is meant to be invoked by the user,\r\n    *                           a certain amount teokens will be locked in the proxy contract the invoker/msg.sender immediately.\r\n    *                           Then the same amount of tokens will be unloked from target chain proxy contract at the target chain with chainId later.\r\n    *  @param fromAssetHash     The asset hash in current chain\r\n    *  @param toChainId         The target chain id\r\n    *\r\n    *  @param toAddress         The address in bytes format to receive same amount of tokens in target chain\r\n    *  @param amount            The amount of tokens to be crossed from ethereum to the chain with chainId\r\n    */\r\n    function lock(\r\n        address fromAssetHash,\r\n        uint64 toChainId,\r\n        bytes memory targetProxyHash,\r\n        bytes memory toAssetHash,\r\n        bytes memory toAddress,\r\n        uint256 amount,\r\n        uint256 feeAmount,\r\n        bytes memory feeAddress\r\n    )\r\n        public\r\n        payable\r\n        returns (bool)\r\n    {\r\n        require(toChainId > 0, \"toChainId cannot be zero\");\r\n        require(targetProxyHash.length > 0, \"empty targetProxyHash\");\r\n        require(toAssetHash.length > 0, \"empty toAssetHash\");\r\n        require(toAddress.length > 0, \"empty toAddress\");\r\n        require(amount > 0, \"amount must be more than zero!\");\r\n\r\n        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\r\n\r\n        bytes32 key = _getRegistryKey(fromAssetHash, toChainId, targetProxyHash, toAssetHash);\r\n        require(registry[key] == true, \"asset not registered\");\r\n\r\n        uint256 nonce = _getNextNonce();\r\n        TxArgs memory txArgs = TxArgs({\r\n            fromAssetHash: Utils.addressToBytes(fromAssetHash),\r\n            toAssetHash: toAssetHash,\r\n            toAddress: toAddress,\r\n            amount: amount,\r\n            feeAmount: feeAmount,\r\n            feeAddress: feeAddress,\r\n            fromAddress: abi.encodePacked(_msgSender()),\r\n            nonce: nonce\r\n        });\r\n\r\n        require(feeAmount <= amount, \"fee amount cannot be greater than amount\");\r\n\r\n        bytes memory txData = _serializeTxArgs(txArgs);\r\n        IEthCrossChainManager eccm = _getEccm();\r\n\r\n        require(eccm.crossChain(toChainId, targetProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\r\n        balances[key] = balances[key].add(txArgs.amount);\r\n\r\n        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, txData);\r\n\r\n        return true;\r\n    }\r\n\r\n    // /* @notice                  This function is meant to be invoked by the ETH crosschain management contract,\r\n    // *                           then mint a certin amount of tokens to the designated address since a certain amount\r\n    // *                           was burnt from the source chain invoker.\r\n    // *  @param argsBs            The argument bytes recevied by the ethereum lock proxy contract, need to be deserialized.\r\n    // *                           based on the way of serialization in the source chain proxy contract.\r\n    // *  @param fromContractAddr  The source chain contract address\r\n    // *  @param fromChainId       The source chain id\r\n    // */\r\n    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {\r\n        TxArgs memory args = _deserializeTxArgs(argsBs);\r\n        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\r\n        address toAddress = Utils.bytesToAddress(args.toAddress);\r\n\r\n        bytes32 key = _getRegistryKey(toAssetHash, fromChainId, fromContractAddr, args.fromAssetHash);\r\n\r\n        require(registry[key] == true, \"asset not registered\");\r\n        require(balances[key] >= args.amount, \"insufficient balance in registry\");\r\n\r\n        balances[key] = balances[key].sub(args.amount);\r\n        require(_transferFromContract(toAssetHash, toAddress, args.amount), \"transfer asset from lock_proxy contract to toAddress failed!\");\r\n\r\n        emit UnlockEvent(toAssetHash, toAddress, args.amount, argsBs);\r\n        return true;\r\n    }\r\n\r\n    function _getNextNonce() private returns (uint256) {\r\n      currentNonce++;\r\n      return currentNonce;\r\n    }\r\n\r\n    function _balanceFor(address fromAssetHash) public view returns (uint256) {\r\n        if (fromAssetHash == address(0)) {\r\n            // return address(this).balance; // this expression would result in error: Failed to decode output: Error: insufficient data for uint256 type\r\n            address selfAddr = address(this);\r\n            return selfAddr.balance;\r\n        } else {\r\n            ERC20Interface erc20Token = ERC20Interface(fromAssetHash);\r\n            return erc20Token.balanceOf(address(this));\r\n        }\r\n    }\r\n    function _getEccm() internal view returns (IEthCrossChainManager) {\r\n      IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract);\r\n      address eccmAddr = eccmp.getEthCrossChainManager();\r\n      IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\r\n      return eccm;\r\n    }\r\n    function _getRegistryKey(address assetHash, uint64 nativeChainId, bytes memory nativeLockProxy, bytes memory nativeAssetHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\r\n            keccak256(abi.encodePacked(assetHash)),\r\n            keccak256(abi.encodePacked(nativeChainId)),\r\n            keccak256(abi.encodePacked(nativeLockProxy)),\r\n            keccak256(abi.encodePacked(nativeAssetHash))\r\n        ));\r\n    }\r\n    function _transferToContract(address fromAssetHash, uint256 amount) internal returns (bool) {\r\n        if (fromAssetHash == address(0)) {\r\n            // fromAssetHash === address(0) denotes user choose to lock ether\r\n            // passively check if the received msg.value equals amount\r\n            require(msg.value == amount, \"transferred ether is not equal to amount!\");\r\n        } else {\r\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\r\n            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\r\n        }\r\n        return true;\r\n    }\r\n    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\r\n        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\r\n            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress\r\n            // convert toAddress from 'address' type to 'address payable' type, then actively transfer ether\r\n            address(uint160(toAddress)).transfer(amount);\r\n        } else {\r\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\r\n            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function _transferERC20ToContract(address fromAssetHash, address fromAddress, address toAddress, uint256 amount) internal returns (bool) {\r\n         ERC20Interface erc20Token = ERC20Interface(fromAssetHash);\r\n         require(erc20Token.transferFrom(fromAddress, toAddress, amount), \"trasnfer ERC20 Token failed!\");\r\n         return true;\r\n    }\r\n    function _transferERC20FromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\r\n         ERC20Interface erc20Token = ERC20Interface(toAssetHash);\r\n         require(erc20Token.transfer(toAddress, amount), \"trasnfer ERC20 Token failed!\");\r\n         return true;\r\n    }\r\n\r\n    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        buff = abi.encodePacked(\r\n            ZeroCopySink.WriteVarBytes(args.fromAssetHash),\r\n            ZeroCopySink.WriteVarBytes(args.toAssetHash),\r\n            ZeroCopySink.WriteVarBytes(args.toAddress),\r\n            ZeroCopySink.WriteUint255(args.amount),\r\n            ZeroCopySink.WriteUint255(args.feeAmount),\r\n            ZeroCopySink.WriteVarBytes(args.feeAddress),\r\n            ZeroCopySink.WriteVarBytes(args.fromAddress),\r\n            ZeroCopySink.WriteUint255(args.nonce)\r\n        );\r\n        return buff;\r\n    }\r\n\r\n    function _serializeRegisterAssetTxArgs(RegisterAssetTxArgs memory args) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        buff = abi.encodePacked(\r\n            ZeroCopySink.WriteVarBytes(args.assetHash),\r\n            ZeroCopySink.WriteVarBytes(args.nativeAssetHash)\r\n        );\r\n        return buff;\r\n    }\r\n\r\n    function _deserializeRegisterAssetTxArgs(bytes memory valueBs) internal pure returns (RegisterAssetTxArgs memory) {\r\n        RegisterAssetTxArgs memory args;\r\n        uint256 off = 0;\r\n        (args.assetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\r\n        (args.nativeAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\r\n        return args;\r\n    }\r\n\r\n    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {\r\n        TxArgs memory args;\r\n        uint256 off = 0;\r\n        (args.fromAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\r\n        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\r\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\r\n        (args.amount, off) = ZeroCopySource.NextUint256(valueBs, off);\r\n        return args;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethCCMProxyAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nativeChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"nativeLockProxy\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"nativeAssetHash\",\"type\":\"bytes\"}],\"name\":\"DelegateAssetEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toAssetHash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"txArgs\",\"type\":\"bytes\"}],\"name\":\"LockEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"SetManagerProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAssetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"txArgs\",\"type\":\"bytes\"}],\"name\":\"UnlockEvent\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"}],\"name\":\"_balanceFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"nativeChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"nativeLockProxy\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"nativeAssetHash\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"delegatedSupply\",\"type\":\"uint256\"}],\"name\":\"delegateAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"targetProxyHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"toAssetHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"feeAddress\",\"type\":\"bytes\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerProxyContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"argsBs\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"fromContractAddr\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"fromChainId\",\"type\":\"uint64\"}],\"name\":\"registerAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"argsBs\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"fromContractAddr\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"fromChainId\",\"type\":\"uint64\"}],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LockProxyPip1","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005a51e2ebf8d136926b9ca7b59b60464e7c44d2eb","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e2dfffd61f9e57fddcd37095e4b13ef9b323a97ad2dc38d4c2a1095d4cfcc311"}]}