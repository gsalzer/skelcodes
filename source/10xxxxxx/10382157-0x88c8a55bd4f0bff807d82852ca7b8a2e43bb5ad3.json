{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @unlock-protocol/unlock-abi-7/IPublicLockV7Sol6.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n* @title The PublicLock Interface\r\n* @author Nick Furfaro (unlock-protocol.com)\r\n */\r\n\r\n\r\ninterface IPublicLockV7Sol6\r\n{\r\n\r\n// See indentationissue description here:\r\n// https://github.com/duaraghav8/Ethlint/issues/268\r\n// solium-disable indentation\r\n\r\n  /// Functions\r\n\r\n  function initialize(\r\n    address _lockCreator,\r\n    uint _expirationDuration,\r\n    address _tokenAddress,\r\n    uint _keyPrice,\r\n    uint _maxNumberOfKeys,\r\n    string calldata _lockName\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\r\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\r\n   */\r\n  receive() external payable;\r\n\r\n  /**\r\n   * @dev Never used directly\r\n   */\r\n  function initialize() external;\r\n\r\n  /**\r\n  * @notice The version number of the current implementation on this network.\r\n  * @return The current version number.\r\n  */\r\n  function publicLockVersion() external pure returns (uint);\r\n\r\n  /**\r\n  * @notice Gets the current balance of the account provided.\r\n  * @param _tokenAddress The token type to retrieve the balance of.\r\n  * @param _account The account to get the balance of.\r\n  * @return The number of tokens of the given type for the given address, possibly 0.\r\n  */\r\n  function getBalance(\r\n    address _tokenAddress,\r\n    address _account\r\n  ) external view\r\n    returns (uint);\r\n\r\n  /**\r\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\r\n  * @dev Throws if called by other than a lock manager.\r\n  * @dev Throws if lock contract has already been disabled.\r\n  */\r\n  function disableLock() external;\r\n\r\n  /**\r\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\r\n   * @dev Throws if called by other than a lock manager or beneficiary\r\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\r\n   * the same as `tokenAddress` in MixinFunds.\r\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\r\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\r\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\r\n   * use cases.\r\n   */\r\n  function withdraw(\r\n    address _tokenAddress,\r\n    uint _amount\r\n  ) external;\r\n\r\n  /**\r\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @dev Throws if lock has been disabled\r\n   * @dev Throws if _tokenAddress is not a valid token\r\n   * @param _keyPrice The new price to set for keys\r\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\r\n   * or 0 to use ETH\r\n   */\r\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\r\n\r\n  /**\r\n   * A function which lets a Lock manager update the beneficiary account,\r\n   * which receives funds on withdrawal.\r\n   * @dev Throws if called by other than a Lock manager or beneficiary\r\n   * @dev Throws if _beneficiary is address(0)\r\n   * @param _beneficiary The new address to set as the beneficiary\r\n   */\r\n  function updateBeneficiary( address _beneficiary ) external;\r\n\r\n    /**\r\n   * Checks if the user has a non-expired key.\r\n   * @param _user The address of the key owner\r\n   */\r\n  function getHasValidKey(\r\n    address _user\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Find the tokenId for a given user\r\n   * @return The tokenId of the NFT, else returns 0\r\n   * @param _account The address of the key owner\r\n  */\r\n  function getTokenIdFor(\r\n    address _account\r\n  ) external view returns (uint);\r\n\r\n  /**\r\n  * A function which returns a subset of the keys for this Lock as an array\r\n  * @param _page the page of key owners requested when faceted by page size\r\n  * @param _pageSize the number of Key Owners requested per page\r\n  * @dev Throws if there are no key owners yet\r\n  */\r\n  function getOwnersByPage(\r\n    uint _page,\r\n    uint _pageSize\r\n  ) external view returns (address[] memory);\r\n\r\n  /**\r\n   * Checks if the given address owns the given tokenId.\r\n   * @param _tokenId The tokenId of the key to check\r\n   * @param _keyOwner The potential key owners address\r\n   */\r\n  function isKeyOwner(\r\n    uint _tokenId,\r\n    address _keyOwner\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\r\n  * @param _keyOwner address of the user for whom we search the key\r\n  * @dev Returns 0 if the owner has never owned a key for this lock\r\n  */\r\n  function keyExpirationTimestampFor(\r\n    address _keyOwner\r\n  ) external view returns (uint timestamp);\r\n\r\n  /**\r\n   * external function which returns the total number of unique owners (both expired\r\n   * and valid).  This may be larger than totalSupply.\r\n   */\r\n  function numberOfOwners() external view returns (uint);\r\n\r\n  /**\r\n   * Allows a Lock manager to assign a descriptive name for this Lock.\r\n   * @param _lockName The new name for the lock\r\n   * @dev Throws if called by other than a Lock manager\r\n   */\r\n  function updateLockName(\r\n    string calldata _lockName\r\n  ) external;\r\n\r\n  /**\r\n   * Allows a Lock manager to assign a Symbol for this Lock.\r\n   * @param _lockSymbol The new Symbol for the lock\r\n   * @dev Throws if called by other than a Lock manager\r\n   */\r\n  function updateLockSymbol(\r\n    string calldata _lockSymbol\r\n  ) external;\r\n\r\n  /**\r\n    * @dev Gets the token symbol\r\n    * @return string representing the token symbol\r\n    */\r\n  function symbol()\r\n    external view\r\n    returns(string memory);\r\n\r\n    /**\r\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _baseTokenURI String representing the base of the URI for this lock.\r\n   */\r\n  function setBaseTokenURI(\r\n    string calldata _baseTokenURI\r\n  ) external;\r\n\r\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n   *  Metadata JSON Schema\".\r\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n   * @param _tokenId The tokenID we're inquiring about\r\n   * @return String representing the URI for the requested token\r\n   */\r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  ) external view returns(string memory);\r\n\r\n  /**\r\n   * @notice Allows a Lock manager to add or remove an event hook\r\n   */\r\n  function setEventHooks(\r\n    address _onKeyPurchaseHook,\r\n    address _onKeyCancelHook\r\n  ) external;\r\n\r\n  /**\r\n   * Allows a Lock manager to give a collection of users a key with no charge.\r\n   * Each key may be assigned a different expiration date.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _recipients An array of receiving addresses\r\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\r\n   */\r\n  function grantKeys(\r\n    address[] calldata _recipients,\r\n    uint[] calldata _expirationTimestamps,\r\n    address[] calldata _keyManagers\r\n  ) external;\r\n\r\n  /**\r\n  * @dev Purchase function\r\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\r\n  * (_value is ignored when using ETH)\r\n  * @param _recipient address of the recipient of the purchased key\r\n  * @param _referrer address of the user making the referral\r\n  * @param _data arbitrary data populated by the front-end which initiated the sale\r\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\r\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\r\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\r\n  * than keyPrice is approved for spending).\r\n  */\r\n  function purchase(\r\n    uint256 _value,\r\n    address _recipient,\r\n    address _referrer,\r\n    bytes calldata _data\r\n  ) external payable;\r\n\r\n  /**\r\n   * @notice returns the minimum price paid for a purchase with these params.\r\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\r\n   */\r\n  function purchasePriceFor(\r\n    address _recipient,\r\n    address _referrer,\r\n    bytes calldata _data\r\n  ) external view\r\n    returns (uint);\r\n\r\n  /**\r\n   * Allow a Lock manager to change the transfer fee.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\r\n   * Ex: 200 bps = 2%\r\n   */\r\n  function updateTransferFee(\r\n    uint _transferFeeBasisPoints\r\n  ) external;\r\n\r\n  /**\r\n   * Determines how much of a fee a key owner would need to pay in order to\r\n   * transfer the key to another account.  This is pro-rated so the fee goes down\r\n   * overtime.\r\n   * @dev Throws if _keyOwner does not have a valid key\r\n   * @param _keyOwner The owner of the key check the transfer fee for.\r\n   * @param _time The amount of time to calculate the fee for.\r\n   * @return The transfer fee in seconds.\r\n   */\r\n  function getTransferFee(\r\n    address _keyOwner,\r\n    uint _time\r\n  ) external view returns (uint);\r\n\r\n  /**\r\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\r\n   * @param _keyOwner The key owner to whom we wish to send a refund to\r\n   * @param amount The amount to refund the key-owner\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @dev Throws if _keyOwner does not have a valid key\r\n   */\r\n  function expireAndRefundFor(\r\n    address _keyOwner,\r\n    uint amount\r\n  ) external;\r\n\r\n   /**\r\n   * @dev allows the key manager to expire a given tokenId\r\n   * and send a refund to the keyOwner based on the amount of time remaining.\r\n   * @param _tokenId The id of the key to cancel.\r\n   */\r\n  function cancelAndRefund(uint _tokenId) external;\r\n\r\n  /**\r\n   * @dev Cancels a key managed by a different user and sends the funds to the keyOwner.\r\n   * @param _keyManager the key managed by this user will be canceled\r\n   * @param _v _r _s getCancelAndRefundApprovalHash signed by the _keyManager\r\n   * @param _tokenId The key to cancel\r\n   */\r\n  function cancelAndRefundFor(\r\n    address _keyManager,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s,\r\n    uint _tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Sets the minimum nonce for a valid off-chain approval message from the\r\n   * senders account.\r\n   * @dev This can be used to invalidate a previously signed message.\r\n   */\r\n  function invalidateOffchainApproval(\r\n    uint _nextAvailableNonce\r\n  ) external;\r\n\r\n  /**\r\n   * Allow a Lock manager to change the refund penalty.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _freeTrialLength The new duration of free trials for this lock\r\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\r\n   */\r\n  function updateRefundPenalty(\r\n    uint _freeTrialLength,\r\n    uint _refundPenaltyBasisPoints\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Determines how much of a refund a key owner would receive if they issued\r\n   * @param _keyOwner The key owner to get the refund value for.\r\n   * a cancelAndRefund block.timestamp.\r\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\r\n   * than what the user reads from this call.\r\n   */\r\n  function getCancelAndRefundValueFor(\r\n    address _keyOwner\r\n  ) external view returns (uint refund);\r\n\r\n  function keyManagerToNonce(address ) external view returns (uint256 );\r\n\r\n  /**\r\n   * @notice returns the hash to sign in order to allow another user to cancel on your behalf.\r\n   * @dev this can be computed in JS instead of read from the contract.\r\n   * @param _keyManager The key manager's address (also the message signer)\r\n   * @param _txSender The address cancelling cancel on behalf of the keyOwner\r\n   * @return approvalHash The hash to sign\r\n   */\r\n  function getCancelAndRefundApprovalHash(\r\n    address _keyManager,\r\n    address _txSender\r\n  ) external view returns (bytes32 approvalHash);\r\n\r\n  function addKeyGranter(address account) external;\r\n\r\n  function addLockManager(address account) external;\r\n\r\n  function isKeyGranter(address account) external view returns (bool);\r\n\r\n  function isLockManager(address account) external view returns (bool);\r\n\r\n  function onKeyPurchaseHook() external view returns(address);\r\n\r\n  function onKeyCancelHook() external view returns(address);\r\n\r\n  function revokeKeyGranter(address _granter) external;\r\n\r\n  function renounceLockManager() external;\r\n\r\n  ///===================================================================\r\n  /// Auto-generated getter functions from public state variables\r\n\r\n  function beneficiary() external view returns (address );\r\n\r\n  function expirationDuration() external view returns (uint256 );\r\n\r\n  function freeTrialLength() external view returns (uint256 );\r\n\r\n  function isAlive() external view returns (bool );\r\n\r\n  function keyPrice() external view returns (uint256 );\r\n\r\n  function maxNumberOfKeys() external view returns (uint256 );\r\n\r\n  function owners(uint256 ) external view returns (address );\r\n\r\n  function refundPenaltyBasisPoints() external view returns (uint256 );\r\n\r\n  function tokenAddress() external view returns (address );\r\n\r\n  function transferFeeBasisPoints() external view returns (uint256 );\r\n\r\n  function unlockProtocol() external view returns (address );\r\n\r\n  function keyManagerOf(uint) external view returns (address );\r\n\r\n  ///===================================================================\r\n\r\n  /**\r\n  * @notice Allows the key owner to safely share their key (parent key) by\r\n  * transferring a portion of the remaining time to a new key (child key).\r\n  * @dev Throws if key is not valid.\r\n  * @dev Throws if `_to` is the zero address\r\n  * @param _to The recipient of the shared key\r\n  * @param _tokenId the key to share\r\n  * @param _timeShared The amount of time shared\r\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  * `onERC721Received` on `_to` and throws if the return value is not\r\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\r\n  * @dev Emit Transfer event\r\n  */\r\n  function shareKey(\r\n    address _to,\r\n    uint _tokenId,\r\n    uint _timeShared\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Update transfer and cancel rights for a given key\r\n  * @param _tokenId The id of the key to assign rights for\r\n  * @param _keyManager The address to assign the rights to for the given key\r\n  */\r\n  function setKeyManagerOf(\r\n    uint _tokenId,\r\n    address _keyManager\r\n  ) external;\r\n\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external view returns (string memory _name);\r\n  ///===================================================================\r\n\r\n  /// From ERC165.sol\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool );\r\n  ///===================================================================\r\n\r\n  /// From ERC-721\r\n  /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address _owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n    * @notice Get the approved address for a single NFT\r\n    * @dev Throws if `_tokenId` is not a valid NFT.\r\n    * @param _tokenId The NFT to find the approved address for\r\n    * @return operator The approved address for this NFT, or the zero address if there is none\r\n    */\r\n    function getApproved(uint256 _tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address _owner, address operator) external view returns (bool);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/mixins/LockRoles.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n/**\r\n * @notice Provides modifiers for interfacing with roles from a lock.\r\n */\r\ncontract LockRoles\r\n{\r\n  /**\r\n   * @notice Lock managers are admins for the lock contract.\r\n   */\r\n  modifier onlyLockManager(\r\n    IPublicLockV7Sol6 _lock\r\n  )\r\n  {\r\n    require(_lock.isLockManager(msg.sender), 'ONLY_LOCK_MANAGER');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Key granters and lock managers have permission to distribute keys without any expense.\r\n   */\r\n  modifier onlyKeyGranterOrManager(\r\n    IPublicLockV7Sol6 _lock\r\n  )\r\n  {\r\n    require(_lock.isKeyGranter(msg.sender) || _lock.isLockManager(msg.sender), 'ONLY_KEY_GRANTER');\r\n    _;\r\n  }\r\n}\r\n\r\n// File: contracts/KeyPurchaser.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice Purchase a key priced in any ERC-20 token - either once or as a regular subscription.\r\n * This allows the user to purchase or subscribe to a key with 1 tx (`approve`)\r\n * or if the token supports it, with 1 signed message (`permit`).\r\n *\r\n * The user can remove the ERC-20 approval to cancel anytime.\r\n *\r\n * Risk: if the user transfers or cancels the key, they would naturally expect that also cancels\r\n * the subscription but it does not. This should be handled by the frontend.\r\n */\r\ncontract KeyPurchaser is Initializable, LockRoles\r\n{\r\n  using Address for address payable;\r\n  using SafeERC20 for IERC20;\r\n  using SafeMath for uint;\r\n\r\n  /**\r\n   * @notice Emitted when the stop is triggered by a stopper (`account`).\r\n   */\r\n  event Stopped(address account);\r\n\r\n  // set on initialize and cannot change\r\n\r\n  /**\r\n   * @notice This is the lock for the content users are subscribing to.\r\n   */\r\n  IPublicLockV7Sol6 public lock;\r\n\r\n  /**\r\n   * @notice The most you will spend on a single key purchase.\r\n   * @dev This allows the lock owner to increase the key price overtime, up to a point, without\r\n   * breaking subscriptions.\r\n   */\r\n  uint public maxPurchasePrice;\r\n\r\n  /**\r\n   * @notice How close to the end of a subscription someone may renew the purchase.\r\n   * @dev To ensure that the subscription never expires, we allow this amount of time (maybe 1 day)\r\n   * before it expires for the renewal to happen.\r\n   */\r\n  uint public renewWindow;\r\n\r\n  /**\r\n   * @notice The earliest a renewal may be purchased after the previous purchase was done.\r\n   * @dev This typically would not apply, but helps to avoid potential abuse or confusion\r\n   * around cancel and transfer scenarios.\r\n   */\r\n  uint public renewMinFrequency;\r\n\r\n  /**\r\n   * @notice The amount of tokens rewarded from the end user to the msg.sender for enabling this feature.\r\n   * This is paid with each renewal of the key.\r\n   */\r\n  uint public msgSenderReward;\r\n\r\n  // admin can change these anytime\r\n\r\n  /**\r\n   * @notice Metadata for these subscription terms which may be displayed on the frontend.\r\n   */\r\n  string public name;\r\n\r\n  /**\r\n   * @notice Metadata for these subscription terms which can be used to supress the offering\r\n   * from the frontend.\r\n   */\r\n  bool internal hidden;\r\n\r\n  /**\r\n   * @notice Indicates if the contract has been disabled by a lock manager. Once stopped it\r\n   * may never start again.\r\n   */\r\n  bool public stopped;\r\n\r\n  // store minimal history\r\n\r\n  /**\r\n   * @notice Tracks when the key was last purchased for a user's subscription.\r\n   * @dev This is used to enforce renewWindow and renewMinFrequency.\r\n   */\r\n  mapping(address => uint) public timestampOfLastPurchase;\r\n\r\n  /**\r\n   * @notice Called once to set terms that cannot change later on.\r\n   * @dev We are using initialize instead of a constructor so that this\r\n   * contract may be deployed with a minimal proxy.\r\n   */\r\n  function initialize(\r\n    IPublicLockV7Sol6 _lock,\r\n    uint _maxPurchasePrice,\r\n    uint _renewWindow,\r\n    uint _renewMinFrequency,\r\n    uint _msgSenderReward\r\n  ) public\r\n    initializer()\r\n  {\r\n    lock = _lock;\r\n    maxPurchasePrice = _maxPurchasePrice;\r\n    renewWindow = _renewWindow;\r\n    renewMinFrequency = _renewMinFrequency;\r\n    msgSenderReward = _msgSenderReward;\r\n    approveSpending();\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not stopped.\r\n   */\r\n  modifier whenNotStopped()\r\n  {\r\n    require(!stopped, 'Stoppable: stopped');\r\n    _;\r\n  }\r\n\r\n  /**\r\n    * @notice Called by a stopper to stop, triggers stopped state.\r\n    */\r\n  function stop() public onlyLockManager(lock) whenNotStopped\r\n  {\r\n    stopped = true;\r\n    emit Stopped(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Approves the lock to spend funds held by this contract.\r\n   * @dev Automatically called on initialize, needs to be called again if the tokenAddress changes.\r\n   * No permissions required, it's okay to call this again. Typically that would not be required.\r\n   */\r\n  function approveSpending() public\r\n  {\r\n    IERC20 token = IERC20(lock.tokenAddress());\r\n    if(address(token) != address(0))\r\n    {\r\n      token.approve(address(lock), uint(-1));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Used by admins to update metadata which may be leveraged by the frontend.\r\n   * @param _name An optional name to display on the frontend.\r\n   * @param _hidden A flag to indicate if the subscription should be displayed on the frontend.\r\n   */\r\n  function config(\r\n    string memory _name,\r\n    bool _hidden\r\n  ) public\r\n    onlyLockManager(lock)\r\n  {\r\n    name = _name;\r\n    hidden = _hidden;\r\n  }\r\n\r\n  /**\r\n   * @notice Indicates if this purchaser should be exposed as an option to users on the frontend.\r\n   * False does not necessarily mean previous subs will no longer work (see `stopped` for that).\r\n   */\r\n  function shouldBeDisplayed() public view returns(bool)\r\n  {\r\n    return !stopped && !hidden;\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if terms allow someone to purchase another key on behalf of a given _recipient.\r\n   * @return purchasePrice as an internal gas optimization so we don't need to look it up again.\r\n   * @param _referrer An address passed to the lock during purchase, potentially offering them a reward.\r\n   * @param _data Arbitrary data included with the lock purchase. This may be used for things such as\r\n   * a discount code, which can be safely done by having the maxPurchasePrice lower then the actual keyPrice.\r\n   */\r\n  function _readyToPurchaseFor(\r\n    address payable _recipient,\r\n    address _referrer,\r\n    bytes memory _data\r\n  ) private view\r\n    // Prevent any purchase after these subscription terms have been stopped\r\n    whenNotStopped\r\n    returns(uint purchasePrice)\r\n  {\r\n    uint lastPurchase = timestampOfLastPurchase[_recipient];\r\n    // `now` must be strictly larger than the timestamp of the last block\r\n    // so now - lastPurchase is always >= 1\r\n    require(now - lastPurchase >= renewMinFrequency, 'BEFORE_MIN_FREQUENCY');\r\n\r\n    uint expiration = lock.keyExpirationTimestampFor(_recipient);\r\n    require(expiration <= now || expiration - now <= renewWindow, 'OUTSIDE_RENEW_WINDOW');\r\n\r\n    purchasePrice = lock.purchasePriceFor(_recipient, _referrer, _data);\r\n    require(purchasePrice <= maxPurchasePrice, 'PRICE_TOO_HIGH');\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if terms allow someone to purchase another key on behalf of a given _recipient.\r\n   * @dev This will throw an error if it's not time to renew a purchase for the _recipient.\r\n   * This is slightly different than the internal _readyToPurchaseFor as a gas optimization.\r\n   * When actually processing the purchase we don't need to check the balance because the transfer\r\n   * itself would fail.\r\n   * @param _referrer An address passed to the lock during purchase, potentially offering them a reward.\r\n   * @param _data Arbitrary data included with the lock purchase. This may be used for things such as\r\n   * a discount code, which can be safely done by having the maxPurchasePrice lower then the actual keyPrice.\r\n   */\r\n  function readyToPurchaseFor(\r\n    address payable _recipient,\r\n    address _referrer,\r\n    bytes memory _data\r\n  ) public view\r\n  {\r\n    uint purchasePrice = _readyToPurchaseFor(_recipient, _referrer, _data);\r\n    purchasePrice = purchasePrice.add(msgSenderReward);\r\n\r\n    // It's okay if the lock changes tokenAddress as the ERC-20 approval is specifically\r\n    // for the token the endUser wanted to spend\r\n    IERC20 token = IERC20(lock.tokenAddress());\r\n    require(token.balanceOf(_recipient) >= purchasePrice, 'INSUFFICIENT_BALANCE');\r\n    require(token.allowance(_recipient, address(this)) >= purchasePrice, 'INSUFFICIENT_ALLOWANCE');\r\n  }\r\n\r\n  /**\r\n   * @notice Called by anyone to purchase or renew a key on behalf of a user.\r\n   * @dev The user must have ERC-20 spending approved and the purchase must meet the terms\r\n   * defined during initialization.\r\n   * @param _referrer An address passed to the lock during purchase, potentially offering them a reward.\r\n   * @param _data Arbitrary data included with the lock purchase. This may be used for things such as\r\n   * a discount code, which can be safely done by having the maxPurchasePrice lower then the actual keyPrice.\r\n   */\r\n  function purchaseFor(\r\n    address payable _recipient,\r\n    address _referrer,\r\n    bytes memory _data\r\n  ) public\r\n  {\r\n    // It's okay if the lock changes tokenAddress as the ERC-20 approval is specifically\r\n    // the token the endUser wanted to spend\r\n    IERC20 token = IERC20(lock.tokenAddress());\r\n\r\n    uint keyPrice = _readyToPurchaseFor(_recipient, _referrer, _data);\r\n    uint totalCost = keyPrice.add(msgSenderReward);\r\n    if(totalCost > 0)\r\n    {\r\n      // We don't need safeTransfer as if these do not work the purchase will fail\r\n      token.transferFrom(_recipient, address(this), totalCost);\r\n      if(msgSenderReward > 0)\r\n      {\r\n        token.transfer(msg.sender, msgSenderReward);\r\n      }\r\n\r\n      // approve from this contract to the lock is already complete\r\n    }\r\n\r\n    lock.purchase(keyPrice, _recipient, _referrer, _data);\r\n    timestampOfLastPurchase[_recipient] = now;\r\n\r\n    // RE events: it's not clear emitting an event adds value over the ones from purchase and the token transfer\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Stopped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"approveSpending\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_hidden\",\"type\":\"bool\"}],\"name\":\"config\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPublicLockV7Sol6\",\"name\":\"_lock\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxPurchasePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_renewWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_renewMinFrequency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_msgSenderReward\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"contract IPublicLockV7Sol6\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPurchasePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"msgSenderReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"purchaseFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"readyToPurchaseFor\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renewMinFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renewWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldBeDisplayed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timestampOfLastPurchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"KeyPurchaser","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"2000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://aa9a8850726f88a294ba5d665942781c046b58fedb8855ca818f2927754742a3"}]}