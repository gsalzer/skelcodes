{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\n\n\n// via https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC1155 {\r\n  // Events\r\n\r\n  /**\r\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\r\n   *   Operator MUST be msg.sender\r\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\r\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\r\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\r\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\r\n   */\r\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\r\n\r\n  /**\r\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\r\n   *   Operator MUST be msg.sender\r\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\r\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\r\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\r\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\r\n   */\r\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\r\n\r\n  /**\r\n   * @dev MUST emit when an approval is updated\r\n   */\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  /**\r\n   * @dev MUST emit when the URI is updated for a token ID\r\n   *   URIs are defined in RFC 3986\r\n   *   The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata JSON Schema\"\r\n   */\r\n  event URI(string _amount, uint256 indexed _id);\r\n\r\n  /**\r\n   * @notice Transfers amount of an _id from the _from address to the _to address specified\r\n   * @dev MUST emit TransferSingle event on success\r\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\r\n   * MUST throw if `_to` is the zero address\r\n   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\r\n   * MUST throw on any other error\r\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n   * @param _from    Source address\r\n   * @param _to      Target address\r\n   * @param _id      ID of the token type\r\n   * @param _amount  Transfered amount\r\n   * @param _data    Additional data with no specified format, sent in call to `_to`\r\n   */\r\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\r\n\r\n  /**\r\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\r\n   * @dev MUST emit TransferBatch event on success\r\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\r\n   * MUST throw if `_to` is the zero address\r\n   * MUST throw if length of `_ids` is not the same as length of `_amounts`\r\n   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\r\n   * MUST throw on any other error\r\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\r\n   * @param _from     Source addresses\r\n   * @param _to       Target addresses\r\n   * @param _ids      IDs of each token type\r\n   * @param _amounts  Transfer amounts per token type\r\n   * @param _data     Additional data with no specified format, sent in call to `_to`\r\n  */\r\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\r\n  \r\n  /**\r\n   * @notice Get the balance of an account's Tokens\r\n   * @param _owner  The address of the token holder\r\n   * @param _id     ID of the Token\r\n   * @return        The _owner's balance of the Token type requested\r\n   */\r\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the balance of multiple account/token pairs\r\n   * @param _owners The addresses of the token holders\r\n   * @param _ids    ID of the Tokens\r\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\r\n   */\r\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\r\n\r\n  /**\r\n   * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller's tokens\r\n   * @dev MUST emit the ApprovalForAll event on success\r\n   * @param _operator  Address to add to the set of authorized operators\r\n   * @param _approved  True if the operator is approved, false to revoke approval\r\n   */\r\n  function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n  /**\r\n   * @notice Queries the approval status of an operator for a given owner\r\n   * @param _owner     The owner of the Tokens\r\n   * @param _operator  Address of authorized operator\r\n   * @return           True if the operator is approved, false if not\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\r\n\r\n}\n\ncontract SaleTokens is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IERC1155 public erc1155Collection;\r\n\r\n    // Address where funds are collected\r\n    address payable private walletStoredFunds;\r\n    address private walletStoredNFT;\r\n\r\n    // prices in MANA by token id\r\n    mapping(uint256 => uint256) public priceByTokenId;\r\n\r\n    uint256 public rateMANAETH;\r\n\r\n    uint256 public referralPercent = 25;\r\n\r\n    address[] public referralList;\r\n\r\n    event SoldNFT(\r\n        address indexed _caller,\r\n        uint256 indexed _tokenId,\r\n        uint256 indexed _count\r\n    );\r\n\r\n    /**\r\n     * @dev Constructor of the contract.\r\n     * @param _walletStoredFunds - Address of the recipient of the funds\r\n     * @param _walletStoredNFT - Address stored NFTs\r\n     * @param _erc1155Collection - Address of the collection\r\n     * @param _tokenIds - List token ids for prices\r\n     * @param _prices - prices in MANA\r\n     * @param _rateMANAETH - rate of MANA in WEI (1e18 = 1eth)\r\n     */\r\n    constructor(\r\n        address payable _walletStoredFunds,\r\n        address payable _walletStoredNFT,\r\n        IERC1155 _erc1155Collection,\r\n        uint256[] memory _tokenIds,\r\n        uint256[] memory _prices,\r\n        uint256 _rateMANAETH\r\n    )\r\n    public {\r\n        require(_tokenIds.length == _prices.length, \"length for tokenIds and prices arrays must equals\");\r\n        walletStoredFunds = _walletStoredFunds;\r\n        walletStoredNFT = _walletStoredNFT;\r\n        erc1155Collection = _erc1155Collection;\r\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n            uint256 id = _tokenIds[i];\r\n            uint256 price = _prices[i];\r\n            priceByTokenId[id] = price;\r\n        }\r\n        rateMANAETH = _rateMANAETH;\r\n    }\r\n\r\n    /**\r\n* @dev Buy NFT for ETH\r\n* @param _nftId - nft id\r\n* @param _count - count\r\n* @param _data - Data to pass if receiver is contract\r\n* @param _referral -referral address\r\n*/\r\n    function buyNFTForETHWithReferral(uint256 _nftId, uint256 _count, bytes memory _data, address payable _referral) public payable {\r\n        require(_count >= 1, \"Count must more or equal 1\");\r\n\r\n        uint256 currentBalance = erc1155Collection.balanceOf(walletStoredNFT, _nftId);\r\n        require(_count <= currentBalance, \"Not enough NFTs\");\r\n\r\n        uint256 price = SafeMath.mul(priceByTokenId[_nftId], rateMANAETH);\r\n        require(price > 0, \"Price not correct\");\r\n        require(msg.value == SafeMath.mul(price, _count), \"Received ETH value not correct\");\r\n\r\n        if (_referral == address(0)) {\r\n            walletStoredFunds.transfer(msg.value);\r\n        } else {\r\n            bool referralRegistered = false;\r\n\r\n            for (uint256 i = 0; i < referralList.length; i++) {\r\n                if (_referral == referralList[i]) {\r\n                    referralRegistered = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (referralRegistered) {\r\n                require(referralPercent < 50 || referralPercent >= 1, \"referral Percent not correct\");\r\n                uint256 referralFee = SafeMath.div(SafeMath.mul(msg.value, referralPercent), 100);\r\n                require(referralFee < msg.value, \"referral Percent not correct\");\r\n                _referral.transfer(referralFee);\r\n                walletStoredFunds.transfer(msg.value - referralFee);\r\n            } else {\r\n                walletStoredFunds.transfer(msg.value);\r\n            }\r\n        }\r\n\r\n        erc1155Collection.safeTransferFrom(walletStoredNFT, msg.sender, _nftId, _count, _data);\r\n\r\n        emit SoldNFT(msg.sender, _nftId, _count);\r\n    }\r\n\r\n    /**\r\n    * @dev Buy NFT for ETH\r\n    * @param _nftId - nft id\r\n    * @param _count - count\r\n    * @param _data -Data to pass if receiver is contract\r\n    */\r\n    function buyNFTForETH(uint256 _nftId, uint256 _count, bytes calldata _data) external payable {\r\n        return buyNFTForETHWithReferral(_nftId, _count, _data, address(0));\r\n    }\r\n\r\n    function setPrices(\r\n        uint256[] memory _tokenIds,\r\n        uint256[] memory _prices\r\n    ) public onlyOwner {\r\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n            uint256 id = _tokenIds[i];\r\n            uint256 price = _prices[i];\r\n            priceByTokenId[id] = price;\r\n        }\r\n    }\r\n\r\n    function getPrices(uint256[] memory _tokenIds)\r\n    public view returns (uint256[] memory prices)\r\n    {\r\n        prices = new uint256[](_tokenIds.length);\r\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n            prices[i] = priceByTokenId[_tokenIds[i]] * rateMANAETH;\r\n        }\r\n        return prices;\r\n    }\r\n\r\n    function setRate(\r\n        uint256 _rateMANAETH\r\n    ) public onlyOwner {\r\n        rateMANAETH = _rateMANAETH;\r\n    }\r\n\r\n    function setReferralPercent(\r\n        uint256 _val\r\n    ) public onlyOwner {\r\n        require(referralPercent < 50, \"referral Percent not correct\");\r\n        require(referralPercent >= 1, \"referral Percent not correct\");\r\n        referralPercent = _val;\r\n    }\r\n\r\n    function setWallet(\r\n        address payable _wallet\r\n    ) public onlyOwner {\r\n        walletStoredFunds = _wallet;\r\n    }\r\n\r\n    function setWalletStoredNFT(\r\n        address payable _wallet\r\n    ) public onlyOwner {\r\n        walletStoredNFT = _wallet;\r\n    }\r\n\r\n    function addReferrals(\r\n        address[] memory _referralList\r\n    ) public onlyOwner {\r\n        for (uint256 i = 0; i < _referralList.length; i++) {\r\n            referralList.push(_referralList[i]);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_walletStoredFunds\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_walletStoredNFT\",\"type\":\"address\"},{\"internalType\":\"contract IERC1155\",\"name\":\"_erc1155Collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_rateMANAETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"SoldNFT\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_referralList\",\"type\":\"address[]\"}],\"name\":\"addReferrals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"buyNFTForETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address payable\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"buyNFTForETHWithReferral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc1155Collection\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceByTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateMANAETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rateMANAETH\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setReferralPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWalletStoredNFT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SaleTokens","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f49056577a9266cd6cfd1b8f6ac151d9bb3671d7000000000000000000000000f308239230dd2965fba141b164967e80069c4246000000000000000000000000d997fe65d5f4259840a220e39b1e9a33b645459b00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000009c86275da80000000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004100000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000043000000000000000000000000000000000000000000000000000000000000004400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000000064","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}