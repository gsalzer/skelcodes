{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.6.6;\n\n\ncontract AddressSet {\n    struct Set\n    {\n        address[] addresses;\n        mapping (address => uint) positions;\n        uint count;\n    }\n    mapping (bytes32 => Set) private sets;\n\n    function addAddressToSet(\n        bytes32 key,\n        address addr,\n        bool maintainList\n        ) internal\n    {\n        Set storage set = sets[key];\n        require(set.positions[addr] == 0, \"ALREADY_IN_SET\");\n        \n        if (maintainList) {\n            require(set.addresses.length == set.count, \"PREVIOUSLY_NOT_MAINTAILED\");\n            set.addresses.push(addr);\n        } else {\n            require(set.addresses.length == 0, \"MUST_MAINTAIN\");\n        }\n\n        set.count += 1;\n        set.positions[addr] = set.count;\n    }\n\n    function removeAddressFromSet(\n        bytes32 key,\n        address addr\n        )\n        internal\n    {\n        Set storage set = sets[key];\n        uint pos = set.positions[addr];\n        require(pos != 0, \"NOT_IN_SET\");\n\n        delete set.positions[addr];\n        set.count -= 1;\n\n        if (set.addresses.length > 0) {\n            address lastAddr = set.addresses[set.count];\n            if (lastAddr != addr) {\n                set.addresses[pos - 1] = lastAddr;\n                set.positions[lastAddr] = pos;\n            }\n            set.addresses.pop();\n        }\n    }\n\n    function removeSet(bytes32 key)\n        internal\n    {\n        delete sets[key];\n    }\n\n    function isAddressInSet(\n        bytes32 key,\n        address addr\n        )\n        internal\n        view\n        returns (bool)\n    {\n        return sets[key].positions[addr] != 0;\n    }\n\n    function numAddressesInSet(bytes32 key)\n        internal\n        view\n        returns (uint)\n    {\n        Set storage set = sets[key];\n        return set.count;\n    }\n\n    function addressesInSet(bytes32 key)\n        internal\n        view\n        returns (address[] memory)\n    {\n        Set storage set = sets[key];\n        require(set.count == set.addresses.length, \"NOT_MAINTAINED\");\n        return sets[key].addresses;\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    \n    \n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        virtual\n        onlyOwner\n    {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function renounceOwnership()\n        public\n        onlyOwner\n    {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n}\n\ncontract Claimable is Ownable\n{\n    address public pendingOwner;\n\n    \n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        override\n        onlyOwner\n    {\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\n        pendingOwner = newOwner;\n    }\n\n    \n    function claimOwnership()\n        public\n        onlyPendingOwner\n    {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\ninterface ModuleRegistry {\n    function registerModule(address module) external;\n    function deregisterModule(address module) external;\n    function isModuleRegistered(address module) external view returns (bool);\n    function modules() external view returns (address[] memory _modules);\n    function numOfModules() external view returns (uint);\n}\n\ncontract ModuleRegistryImpl is Claimable, AddressSet, ModuleRegistry\n{\n    bytes32 internal constant MODULE = keccak256(\"__MODULE__\");\n\n    event ModuleRegistered      (address indexed module);\n    event ModuleDeregistered    (address indexed module);\n\n    constructor() public Claimable() {}\n\n    function registerModule(address module)\n        external\n        override\n        onlyOwner\n    {\n        addAddressToSet(MODULE, module, true);\n        emit ModuleRegistered(module);\n    }\n\n    function deregisterModule(address module)\n        external\n        override\n        onlyOwner\n    {\n        removeAddressFromSet(MODULE, module);\n        emit ModuleDeregistered(module);\n    }\n\n    function isModuleRegistered(address module)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return isAddressInSet(MODULE, module);\n    }\n\n    function modules()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return addressesInSet(MODULE);\n    }\n\n    function numOfModules()\n        external\n        view\n        override\n        returns (uint)\n    {\n        return numAddressesInSet(MODULE);\n    }\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ModuleDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ModuleRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"deregisterModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"isModuleRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modules\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numOfModules\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"registerModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ModuleRegistryImpl","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}