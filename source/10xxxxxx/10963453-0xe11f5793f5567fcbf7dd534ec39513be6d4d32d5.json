{"status":"1","message":"OK","result":[{"SourceCode":"{\"AegisGovernance.sol\":{\"content\":\"pragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./EIP20Interface.sol\\\";\\nimport \\\"./EIP20NonStandardInterface.sol\\\";\\n\\n/**\\n * @notice AegisGovernance\\n * @author Aegis\\n */\\ncontract AegisGovernance {\\n    string public constant name = \\\"Aegis Governor\\\";\\n    function passVotes() public pure returns (uint) {return 500000e8;}\\n    function passMantissa() public pure returns (uint) {return 0.3e8;}\\n    function proposalThreshold() public pure returns (uint) { return 150000e8; } // 0.5% of AGS\\n    function proposalMaxOperations() public pure returns (uint) { return 10; }\\n    function votingDelay() public pure returns (uint) { return 1; }\\n    function votingPeriod() public pure returns (uint) { return 17280; }\\n\\n    TimelockInterface public timelock;\\n    address public guardian;\\n    uint public proposalCount;\\n    mapping (uint =\\u003e Proposal) public proposals;\\n    mapping (address =\\u003e uint) public latestProposalIds;\\n    mapping(address =\\u003e mapping(uint =\\u003e uint)) public checkPointVotes;\\n    mapping(address =\\u003e uint) public checkPointProposal;\\n\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,bool support)\\\");\\n\\n    event ProposalCreated(uint _id, address _proposer, address[] _targets, uint[] _values, string[] _signatures, bytes[] _calldatas, uint _startBlock, uint _endBlock, string _description);\\n    event VoteCast(address _voter, uint _proposalId, bool _support, uint _votes);\\n    event ProposalCanceled(uint _id);\\n    event ProposalQueued(uint _id, uint _eta);\\n    event ProposalExecuted(uint _id);\\n    event VotesLockup(address _account, uint _number, uint _lockup);\\n    event ProposeLockup(address _account, uint _number, uint _lockup);\\n    event ProposeFreed(address _account, uint _number, uint _remaining);\\n    event VotesFreed(address _account, uint _number, uint _remaining);\\n\\n    struct Proposal {\\n        uint id;\\n        address proposer;\\n        uint eta;\\n        address[] targets;\\n        uint[] values;\\n        string[] signatures;\\n        bytes[] calldatas;\\n        uint startBlock;\\n        uint endBlock;\\n        uint forVotes;\\n        uint againstVotes;\\n        bool canceled;\\n        bool executed;\\n        mapping (address =\\u003e Receipt) receipts;\\n    }\\n\\n    struct Receipt {\\n        bool hasVoted;\\n        bool support;\\n        uint votes;\\n    }\\n\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed\\n    }\\n\\n    constructor(address _timelock, address _guardian) public {\\n        timelock = TimelockInterface(_timelock);\\n        guardian = _guardian;\\n    }\\n\\n    function proposeLockup(uint _number) public {\\n        require(_number \\u003e 0, \\\"AegisGovernance::proposeLockup number must be greater than 0\\\");\\n        uint actualAmount = doTransferIn(msg.sender, _number);\\n        uint old = checkPointProposal[msg.sender];\\n        checkPointProposal[msg.sender] = old + actualAmount;\\n        emit ProposeLockup(msg.sender, _number, checkPointProposal[msg.sender]);\\n    }\\n\\n    function proposeFreed(address payable _account, uint _proposalId) public {\\n        require(state(_proposalId) != ProposalState.Active, \\\"AegisGovernance::proposeFreed voting is not closed\\\");\\n        Proposal storage proposal = proposals[_proposalId];\\n        require(_account == msg.sender \\u0026\\u0026 _account == proposal.proposer, \\\"AegisGovernance::proposeFreed no permission to operate\\\");\\n        require(checkPointProposal[_account] \\u003e 0, \\\"AegisGovernance::proposeFreed insufficient coins\\\");\\n        uint number = checkPointProposal[_account];\\n        doTransferOut(_account, number);\\n        checkPointProposal[_account] = 0;\\n        emit ProposeFreed(_account, number, checkPointProposal[_account]);\\n    }\\n\\n    function votesLockup(uint _number, uint _proposalId) public {\\n        require(_number \\u003e 0, \\\"AegisGovernance::votesLockup number must be greater than 0\\\");\\n        require(state(_proposalId) == ProposalState.Active, \\\"AegisGovernance::votesLockup voting is closed\\\");\\n        uint actualAmount = doTransferIn(msg.sender, _number);\\n        uint old = checkPointVotes[msg.sender][_proposalId];\\n        checkPointVotes[msg.sender][_proposalId] = old + actualAmount;\\n        emit VotesLockup(msg.sender, _number, getPriorVotes(msg.sender, _proposalId));\\n    }\\n\\n    function votesFreed(address payable _account, uint _proposalId) public {\\n        require(state(_proposalId) != ProposalState.Active, \\\"AegisGovernance::votesFreed voting is not closed\\\");\\n        require(msg.sender == _account, \\\"AegisGovernance::votesFreed no permission to operate\\\");\\n        uint number = checkPointVotes[_account][_proposalId];\\n        doTransferOut(_account, number);\\n        checkPointVotes[_account][_proposalId] = 0;\\n        emit VotesFreed(_account, number, checkPointVotes[_account][_proposalId]);\\n    }\\n\\n    function getPriorVotes(address _account, uint _proposalId) public view returns (uint) {\\n        return checkPointVotes[_account][_proposalId];\\n    }\\n\\n    function totalLockUp() public view returns (uint) {\\n        return EIP20Interface(underlying()).balanceOf(address(this));\\n    }\\n\\n    function propose(address[] memory _targets, uint[] memory _values, string[] memory _signatures, bytes[] memory _calldatas, string memory _description) public returns (uint) {\\n        require(checkPointProposal[msg.sender] \\u003e= proposalThreshold(), \\\"AegisGovernance::propose: proposer votes below proposal threshold\\\");\\n        require(_targets.length == _values.length \\u0026\\u0026 _targets.length == _signatures.length \\u0026\\u0026 _targets.length == _calldatas.length, \\\"AegisGovernance::propose: proposal function information arity mismatch\\\");\\n        require(_targets.length != 0, \\\"AegisGovernance::propose: must provide actions\\\");\\n        require(_targets.length \\u003c= proposalMaxOperations(), \\\"AegisGovernance::propose: too many actions\\\");\\n\\n        uint latestProposalId = latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n          ProposalState proposersLatestProposalState = state(latestProposalId);\\n          require(proposersLatestProposalState != ProposalState.Active, \\\"AegisGovernance::propose: one live proposal per proposer, found an already active proposal\\\");\\n          require(proposersLatestProposalState != ProposalState.Pending, \\\"AegisGovernance::propose: one live proposal per proposer, found an already pending proposal\\\");\\n        }\\n\\n        uint startBlock = add256(block.number, votingDelay());\\n        uint endBlock = add256(startBlock, votingPeriod());\\n\\n        proposalCount++;\\n        Proposal memory newProposal = Proposal({\\n            id: proposalCount,\\n            proposer: msg.sender,\\n            eta: 0,\\n            targets: _targets,\\n            values: _values,\\n            signatures: _signatures,\\n            calldatas: _calldatas,\\n            startBlock: startBlock,\\n            endBlock: endBlock,\\n            forVotes: 0,\\n            againstVotes: 0,\\n            canceled: false,\\n            executed: false\\n        });\\n\\n        proposals[newProposal.id] = newProposal;\\n        latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n        emit ProposalCreated(newProposal.id, msg.sender, _targets, _values, _signatures, _calldatas, startBlock, endBlock, _description);\\n        return newProposal.id;\\n    }\\n\\n    function queue(uint _proposalId) public {\\n        require(state(_proposalId) == ProposalState.Succeeded, \\\"AegisGovernance::queue: proposal can only be queued if it is succeeded\\\");\\n        Proposal storage proposal = proposals[_proposalId];\\n        uint eta = add256(block.timestamp, timelock.delay());\\n        for (uint i = 0; i \\u003c proposal.targets.length; i++) {\\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\\n        }\\n        proposal.eta = eta;\\n        emit ProposalQueued(_proposalId, eta);\\n    }\\n\\n    function _queueOrRevert(address _target, uint _value, string memory _signature, bytes memory _data, uint _eta) internal {\\n        require(!timelock.queuedTransactions(keccak256(abi.encode(_target, _value, _signature, _data, _eta))), \\\"AegisGovernance::_queueOrRevert: proposal action already queued at eta\\\");\\n        timelock.queueTransaction(_target, _value, _signature, _data, _eta);\\n    }\\n\\n    function execute(uint _proposalId) public payable {\\n        require(state(_proposalId) == ProposalState.Queued, \\\"AegisGovernance::execute: proposal can only be executed if it is queued\\\");\\n        Proposal storage proposal = proposals[_proposalId];\\n        proposal.executed = true;\\n        for (uint i = 0; i \\u003c proposal.targets.length; i++) {\\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n        emit ProposalExecuted(_proposalId);\\n    }\\n\\n    function cancel(uint _proposalId) public {\\n        ProposalState state = state(_proposalId);\\n        require(state != ProposalState.Executed, \\\"AegisGovernance::cancel: cannot cancel executed proposal\\\");\\n\\n        Proposal storage proposal = proposals[_proposalId];\\n        require(msg.sender == guardian || checkPointProposal[proposal.proposer] \\u003c proposalThreshold(), \\\"AegisGovernance::cancel: proposer above threshold\\\");\\n\\n        proposal.canceled = true;\\n        for (uint i = 0; i \\u003c proposal.targets.length; i++) {\\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n\\n        emit ProposalCanceled(_proposalId);\\n    }\\n\\n    function getActions(uint _proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\\n        Proposal storage p = proposals[_proposalId];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    function getReceipt(uint _proposalId, address _voter) public view returns (Receipt memory) {\\n        return proposals[_proposalId].receipts[_voter];\\n    }\\n\\n    function state(uint _proposalId) public view returns (ProposalState) {\\n        require(proposalCount \\u003e= _proposalId \\u0026\\u0026 _proposalId \\u003e 0, \\\"AegisGovernance::state: invalid proposal id\\\");\\n        Proposal storage proposal = proposals[_proposalId];\\n        if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (block.number \\u003c= proposal.startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number \\u003c= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (proposal.forVotes * passMantissa() / 1e8 \\u003c= proposal.againstVotes || proposal.forVotes + proposal.againstVotes \\u003c passVotes()) {\\n            return ProposalState.Defeated;\\n        } else if (proposal.eta == 0) {\\n            return ProposalState.Succeeded;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.timestamp \\u003e= add256(proposal.eta, timelock.GRACE_PERIOD())) {\\n            return ProposalState.Expired;\\n        } else {\\n            return ProposalState.Queued;\\n        }\\n    }\\n\\n    function castVote(uint _proposalId, bool _support) public {\\n        require(getPriorVotes(msg.sender, _proposalId) \\u003e 0, \\\"AegisGovernance::castVote not enough votes\\\");\\n        return _castVote(msg.sender, _proposalId, _support);\\n    }\\n\\n    function castVoteBySig(uint _proposalId, bool _support, uint8 _v, bytes32 _r, bytes32 _s) public {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, _proposalId, _support));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, _v, _r, _s);\\n        require(signatory != address(0), \\\"AegisGovernance::castVoteBySig: invalid signature\\\");\\n        return _castVote(signatory, _proposalId, _support);\\n    }\\n\\n    function _castVote(address _voter, uint _proposalId, bool _support) internal {\\n        require(state(_proposalId) == ProposalState.Active, \\\"AegisGovernance::_castVote: voting is closed\\\");\\n        Proposal storage proposal = proposals[_proposalId];\\n        Receipt storage receipt = proposal.receipts[_voter];\\n        require(receipt.hasVoted == false, \\\"AegisGovernance::_castVote: voter already voted\\\");\\n        uint votes = getPriorVotes(_voter, _proposalId);\\n\\n        if (_support) {\\n            proposal.forVotes = add256(proposal.forVotes, votes);\\n        } else {\\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = _support;\\n        receipt.votes = votes;\\n\\n        emit VoteCast(_voter, _proposalId, _support, votes);\\n    }\\n\\n    function doTransferIn(address from, uint amount) internal returns (uint) {\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying());\\n        uint balanceBefore = EIP20Interface(underlying()).balanceOf(address(this));\\n        token.transferFrom(from, address(this), amount);\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {\\n                    success := not(0)\\n                }\\n                case 32 {\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0)\\n                }\\n                default {\\n                    revert(0, 0)\\n                }\\n        }\\n        require(success, \\\"LOCKUP::TOKEN_TRANSFER_IN_FAILED\\\");\\n        \\n        uint balanceAfter = EIP20Interface(underlying()).balanceOf(address(this));\\n        require(balanceAfter \\u003e= balanceBefore, \\\"TOKEN_TRANSFER_IN_OVERFLOW\\\");\\n        return balanceAfter - balanceBefore;\\n    }\\n\\n    function doTransferOut(address payable to, uint amount) internal {\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying());\\n        token.transfer(to, amount);\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {\\n                    success := not(0)\\n                }\\n                case 32 {\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0)\\n                }\\n                default {\\n                    revert(0, 0)\\n                }\\n        }\\n        require(success, \\\"LOCKUP::TOKEN_TRANSFER_OUT_FAILED\\\");\\n    }\\n\\n    function underlying() internal pure returns (address) {\\n        return address(0xdB2F2bCCe3efa95EDA95a233aF45F3e0d4f00e2A);\\n    }\\n\\n    function __acceptAdmin() public {\\n        require(msg.sender == guardian, \\\"AegisGovernance::__acceptAdmin: sender must be gov guardian\\\");\\n        timelock.acceptAdmin();\\n    }\\n\\n    function __abdicate() public {\\n        require(msg.sender == guardian, \\\"AegisGovernance::__abdicate: sender must be gov guardian\\\");\\n        guardian = address(0);\\n    }\\n\\n    function __queueSetTimelockPendingAdmin(address _newPendingAdmin, uint _eta) public {\\n        require(msg.sender == guardian, \\\"AegisGovernance::__queueSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.queueTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(_newPendingAdmin), _eta);\\n    }\\n\\n    function __executeSetTimelockPendingAdmin(address _newPendingAdmin, uint _eta) public {\\n        require(msg.sender == guardian, \\\"AegisGovernance::__executeSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.executeTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(_newPendingAdmin), _eta);\\n    }\\n\\n    function add256(uint256 _a, uint256 _b) internal pure returns (uint) {\\n        uint c = _a + _b;\\n        require(c \\u003e= _a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub256(uint256 _a, uint256 _b) internal pure returns (uint) {\\n        require(_b \\u003c= _a, \\\"subtraction underflow\\\");\\n        return _a - _b;\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\\n\\ninterface TimelockInterface {\\n    function delay() external view returns (uint);\\n    function GRACE_PERIOD() external view returns (uint);\\n    function acceptAdmin() external;\\n    function queuedTransactions(bytes32 hash) external view returns (bool);\\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\\n}\"},\"EIP20Interface.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\n/**\\n * @title EIP20Interface\\n */\\ncontract EIP20Interface {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return uint\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param _owner The address from which the balance will be retrieved\\n     * @return uint\\n     */\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param _dst The address of the destination account\\n     * @param _amount The number of tokens to transfer\\n     * @return bool\\n     */\\n    function transfer(address _dst, uint256 _amount) external returns (bool success);\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param _src The address of the source account\\n     * @param _dst The address of the destination account\\n     * @param _amount The number of tokens to transfer\\n     * @return bool\\n     */\\n    function transferFrom(address _src, address _dst, uint256 _amount) external returns (bool success);\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @param _spender The address of the account which may transfer tokens\\n     * @param _amount The number of tokens that are approved (-1 means infinite)\\n     * @return uint\\n     */\\n    function approve(address _spender, uint256 _amount) external returns (bool success);\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param _owner The address of the account which owns the tokens to be spent\\n     * @param _spender The address of the account which may transfer tokens\\n     * @return uint\\n     */\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\\n}\"},\"EIP20NonStandardInterface.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\n/**\\n * @title EIP20NonStandardInterface\\n * @author Aegis\\n */\\ncontract EIP20NonStandardInterface {\\n    \\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return The supply of tokens\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param _owner The address from which the balance will be retrieved\\n     * @return uint\\n     */\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param _dst The address of the destination account\\n      * @param _amount The number of tokens to transfer\\n      */\\n    function transfer(address _dst, uint256 _amount) external;\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param _src: The address of the source account\\n      * @param _dst: The address of the destination account\\n      * @param _amount: The number of tokens to transfer\\n      */\\n    function transferFrom(address _src, address _dst, uint256 _amount) external;\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @param _spender The address of the account which may transfer tokens\\n      * @param _amount The number of tokens that are approved\\n      * @return bool\\n      */\\n    function approve(address _spender, uint256 _amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param _owner The address of the account which owns the tokens to be spent\\n      * @param _spender The address of the account which may transfer tokens\\n      * @return uint\\n      */\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_timelock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"ProposalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"_signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"_calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_eta\",\"type\":\"uint256\"}],\"name\":\"ProposalQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_remaining\",\"type\":\"uint256\"}],\"name\":\"ProposeFreed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lockup\",\"type\":\"uint256\"}],\"name\":\"ProposeLockup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_support\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_votes\",\"type\":\"uint256\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_remaining\",\"type\":\"uint256\"}],\"name\":\"VotesFreed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lockup\",\"type\":\"uint256\"}],\"name\":\"VotesLockup\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"BALLOT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"__abdicate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"__acceptAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPendingAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_eta\",\"type\":\"uint256\"}],\"name\":\"__executeSetTimelockPendingAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPendingAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_eta\",\"type\":\"uint256\"}],\"name\":\"__queueSetTimelockPendingAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_support\",\"type\":\"bool\"}],\"name\":\"castVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_support\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"castVoteBySig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"checkPointProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"checkPointVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"getActions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"getPriorVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"getReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"internalType\":\"struct AegisGovernance.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"latestProposalIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"passMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"passVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalMaxOperations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"_signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"proposeFreed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"proposeLockup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum AegisGovernance.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"contract TimelockInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLockUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"votesFreed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"votesLockup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"AegisGovernance","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000335c1af0aec656359777bcc3734c3533f3ba6b2a0000000000000000000000001d196f7d329438df306c892036b08989a853430d","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://06237a5e77529c09a04e6d99ffc033cdd646d7bce6f814f1802394e1ac6aec65"}]}