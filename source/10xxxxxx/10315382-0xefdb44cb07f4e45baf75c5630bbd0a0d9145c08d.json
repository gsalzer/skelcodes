{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\ninterface IDfFinanceOpen {\r\n\r\n    function deal(\r\n        address _walletOwner,\r\n        uint _coef,\r\n        uint _profitPercent,\r\n        bytes calldata _data,\r\n        uint _usdcToBuyEth,\r\n        uint _ethType\r\n    ) external payable\r\n    returns(address dfWallet);\r\n\r\n    function dfFinanceClose() external view returns(address dfFinanceClose);\r\n\r\n}\r\n\r\ninterface IDfFinanceClose {\r\n\r\n    // // setup with Compound Oracle eth price\r\n    // function setupStrategy(\r\n    //     address _owner, address _dfWallet, uint256 _deposit, uint8 _profitPercent, uint8 _fee\r\n    // ) external;\r\n\r\n    // setup with special eth price\r\n    function setupStrategy(\r\n        address _owner, address _dfWallet, uint256 _deposit, uint256 _priceEth, uint8 _profitPercent, uint8 _fee\r\n    ) external;\r\n\r\n    // setup with special eth price and current extraCoef – for strategy migration\r\n    function setupStrategy(\r\n        address _owner, address _dfWallet, uint256 _deposit, uint256 _priceEth, uint8 _profitPercent, uint8 _fee, uint256 _extraCoef\r\n    ) external;\r\n\r\n    // setup empty strategy (without deposit)\r\n    function setupStrategy(\r\n        address _owner, address _dfWallet, uint8 _profitPercent, uint8 _fee\r\n    ) external;\r\n\r\n    function getStrategy(\r\n        address _dfWallet\r\n    ) external view\r\n    returns(\r\n        address strategyOwner,\r\n        uint deposit,\r\n        uint extraCoef,\r\n        uint entryEthPrice,\r\n        uint profitPercent,\r\n        uint fee,\r\n        uint ethForRedeem,\r\n        uint usdToWithdraw,\r\n        bool onlyProfitInUsd);\r\n\r\n    function migrateStrategies(address[] calldata _dfWallets) external;\r\n\r\n    function collectAndCloseByUser(\r\n        address _dfWallet,\r\n        uint256 _ethForRedeem,\r\n        uint256 _minAmountUsd,\r\n        bool _onlyProfitInUsd,\r\n        bytes calldata _exData\r\n    ) external payable;\r\n\r\n    function exitAfterLiquidation(\r\n        address _dfWallet,\r\n        uint256 _ethForRedeem,\r\n        uint256 _minAmountUsd,\r\n        bytes calldata _exData\r\n    ) external payable;\r\n\r\n    function depositEth(address _dfWallet) external payable;\r\n\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IToken {\r\n    function decimals() external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function approve(address spender, uint value) external;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function deposit() external payable;\r\n    function withdraw(uint amount) external;\r\n}\r\n\r\ninterface IERC20Burnable {\r\n\r\n    function burn(uint256 amount) external;\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n\r\n}\r\n\r\ninterface IDfProfitToken {\r\n\r\n    function initialize(\r\n        string calldata _tokenName,\r\n        string calldata _tokenSymbol,\r\n        address _issuer,\r\n        uint256 _supply\r\n    ) external payable;\r\n\r\n}\r\n\r\n// import \"../openzeppelin/upgrades/contracts/Initializable.sol\";\r\n\r\ncontract OwnableUpgradable is Initializable {\r\n    address payable public owner;\r\n    address payable internal newOwnerCandidate;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Permission denied\");\r\n        _;\r\n    }\r\n\r\n    // ** INITIALIZERS – Constructors for Upgradable contracts **\r\n\r\n    function initialize() public initializer {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function initialize(address payable newOwner) public initializer {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function changeOwner(address payable newOwner) public onlyOwner {\r\n        newOwnerCandidate = newOwner;\r\n    }\r\n\r\n    function acceptOwner() public {\r\n        require(msg.sender == newOwnerCandidate, \"Permission denied\");\r\n        owner = newOwnerCandidate;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2018 Murray Software, LLC.\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n//solhint-disable max-line-length\r\n//solhint-disable no-inline-assembly\r\n\r\ncontract CloneFactory {\r\n\r\n    function createClone(address target) internal returns (address result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n\r\n    function isClone(address target, address query) internal view returns (bool result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\r\n            mstore(add(clone, 0xa), targetBytes)\r\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n\r\n            let other := add(clone, 0x40)\r\n            extcodecopy(query, other, 0, 0x2d)\r\n            result := and(\r\n            eq(mload(clone), mload(other)),\r\n            eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\n// import \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\r\n// import \"./SafeMath.sol\";\r\n\r\n// import \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// import \"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\";\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IToken token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IToken token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IToken token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IToken token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IToken token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IToken token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary UniversalERC20 {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IToken;\r\n\r\n    IToken private constant ZERO_ADDRESS = IToken(0x0000000000000000000000000000000000000000);\r\n    IToken private constant ETH_ADDRESS = IToken(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n    function universalTransfer(IToken token, address to, uint256 amount) internal {\r\n        universalTransfer(token, to, amount, false);\r\n    }\r\n\r\n    function universalTransfer(IToken token, address to, uint256 amount, bool mayFail) internal returns(bool) {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n\r\n        if (token == ZERO_ADDRESS || token == ETH_ADDRESS) {\r\n            if (mayFail) {\r\n                return address(uint160(to)).send(amount);\r\n            } else {\r\n                address(uint160(to)).transfer(amount);\r\n                return true;\r\n            }\r\n        } else {\r\n            token.safeTransfer(to, amount);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function universalApprove(IToken token, address to, uint256 amount) internal {\r\n        if (token != ZERO_ADDRESS && token != ETH_ADDRESS) {\r\n            token.safeApprove(to, amount);\r\n        }\r\n    }\r\n\r\n    function universalTransferFrom(IToken token, address from, address to, uint256 amount) internal {\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        if (token == ZERO_ADDRESS || token == ETH_ADDRESS) {\r\n            require(from == msg.sender && msg.value >= amount, \"msg.value is zero\");\r\n            if (to != address(this)) {\r\n                address(uint160(to)).transfer(amount);\r\n            }\r\n            if (msg.value > amount) {\r\n                msg.sender.transfer(uint256(msg.value).sub(amount));\r\n            }\r\n        } else {\r\n            token.safeTransferFrom(from, to, amount);\r\n        }\r\n    }\r\n\r\n    function universalBalanceOf(IToken token, address who) internal view returns (uint256) {\r\n        if (token == ZERO_ADDRESS || token == ETH_ADDRESS) {\r\n            return who.balance;\r\n        } else {\r\n            return token.balanceOf(who);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y, uint base) internal pure returns (uint z) {\r\n        z = add(mul(x, y), base / 2) / base;\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    /*function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }*/\r\n}\r\n\r\ncontract DfTokenizedStrategy is\r\n    Initializable,\r\n    DSMath,\r\n    OwnableUpgradable,\r\n    CloneFactory\r\n{\r\n    using UniversalERC20 for IToken;\r\n\r\n    struct TokenizedStrategy {\r\n        // bytes32 (== uint256) slot\r\n        uint80 initialEth;                  // in eth – max more 1.2 mln eth\r\n        uint80 entryEthPrice;               // in usd – max more 1.2 mln USD for 1 eth\r\n        uint8 profitPercent;                // min profit percent\r\n        bool onlyWithProfit;                // strategy can be closed only with profitPercent profit\r\n        bool transferDepositToOwner;        // deposit will be transferred to the owner after closing the strategy\r\n        StrategyClosingType closingType;    // strategy closing type\r\n        bool isStrategyClosed;              // strategy is closed\r\n    }\r\n\r\n    enum StrategyClosingType {\r\n        ANY_TYPE,\r\n        ETH,\r\n        USDC,\r\n        ETH_USDC\r\n    }\r\n\r\n    address public constant DF_FINANCE_OPEN = address(0xBA3EEeb0cf1584eE565F34fCaBa74d3e73268c0b);      // TODO: DfFinanceOpenCompound address\r\n\r\n    // DfProfitToken EIP1167 Source\r\n    address public constant sourceTokenAddress = address(0xaD35DA115Fbd6bB7437222779c4ccBb7411812c1);   // TODO: DfProfitToken address\r\n\r\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public constant USDC_ADDRESS = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n\r\n    address public profitToken;\r\n    address public dfFinanceClose;\r\n\r\n    // deposited eth in strategy by owner (with depositEth count)\r\n    uint256 public ethInDeposit;\r\n\r\n    TokenizedStrategy public strategy;\r\n\r\n    // ** EVENTS **\r\n\r\n    event ProfitTokenCreated(\r\n        address indexed profitToken\r\n    );\r\n\r\n    event DepositWithdrawn(\r\n        address indexed user,\r\n        uint ethToWithdraw,\r\n        uint usdToWithdraw\r\n    );\r\n\r\n    event ProfitWithdrawn(\r\n        address indexed user,\r\n        uint ethToWithdraw,\r\n        uint usdToWithdraw\r\n    );\r\n\r\n    // ** MODIFIERS **\r\n\r\n    modifier onlyDfClose {\r\n        require(msg.sender == dfFinanceClose, \"Permission denied\");\r\n        _;\r\n    }\r\n\r\n    modifier afterStrategyClosed {\r\n        require(strategy.isStrategyClosed, \"Strategy is not closed\");\r\n        _;\r\n    }\r\n\r\n    // ** INITIALIZER **\r\n\r\n    function initialize(\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        address payable _owner,\r\n        address _issuer,\r\n        bool _onlyWithProfit,\r\n        bool _transferDepositToOwner,\r\n        uint[5] memory _params,     // extraCoef [0], profitPercent [1], usdcToBuyEth [2], ethType [3], closingType [4]\r\n        bytes memory _exchangeData\r\n    ) public payable initializer {\r\n        // Initialize Parent Contract\r\n        OwnableUpgradable.initialize(_owner);  // Set owner state\r\n\r\n        require(_params[1] > 0, \"Profit percent can not be zero\");\r\n\r\n        uint curDeposit = address(this).balance;\r\n\r\n        uint extraEth = mul(curDeposit, sub(_params[0], 100)) / 100;\r\n        uint curEthPrice = wdiv(_params[2] * 1e12, extraEth);\r\n\r\n        // open strategy\r\n        IDfFinanceOpen(DF_FINANCE_OPEN)\r\n            .deal\r\n            .value(curDeposit)\r\n            (\r\n                address(this),\r\n                _params[0],     // extraCoef\r\n                _params[1],     // profitPercent\r\n                _exchangeData,      // 1inch exchange data\r\n                _params[2],     // usdcToBuyEth\r\n                _params[3]      // ethType\r\n            );\r\n\r\n        // UPD states after open strategy\r\n        ethInDeposit = curDeposit;\r\n        strategy = TokenizedStrategy({\r\n            initialEth: uint80(curDeposit),\r\n            entryEthPrice: uint80(curEthPrice),\r\n            profitPercent: uint8(_params[1]),\r\n            onlyWithProfit: _onlyWithProfit,\r\n            transferDepositToOwner: _transferDepositToOwner,\r\n            closingType: StrategyClosingType(_params[4]),\r\n            isStrategyClosed: false\r\n        });\r\n        dfFinanceClose = IDfFinanceOpen(DF_FINANCE_OPEN).dfFinanceClose();\r\n\r\n        // create token contract and mint tokens\r\n        profitToken = _createToken(_tokenName, _tokenSymbol, _issuer, _params[1], curEthPrice, curDeposit);\r\n    }\r\n\r\n    // ** PUBLIC VIEW functions **\r\n\r\n    function calculateProfit(address _userAddr) public view returns(\r\n        uint ethToWithdraw,\r\n        uint usdToWithdraw\r\n    ) {\r\n        // return zero if the strategy is not closed\r\n        if (!strategy.isStrategyClosed) {\r\n            return (0, 0);\r\n        }\r\n\r\n        uint ethBalance = IToken(ETH_ADDRESS).universalBalanceOf(address(this));\r\n        uint usdBalance = IToken(USDC_ADDRESS).universalBalanceOf(address(this));\r\n\r\n        uint tokenTotalSupply = IERC20(profitToken).totalSupply();\r\n\r\n        if (ethBalance == 0 && usdBalance == 0 || tokenTotalSupply == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        uint userTokenBalance = IERC20(profitToken).balanceOf(_userAddr);\r\n        uint userShare = wdiv(userTokenBalance, tokenTotalSupply);\r\n\r\n        ethToWithdraw = wmul(ethBalance, userShare);\r\n        usdToWithdraw = wmul(usdBalance * 1e12, userShare) / 1e12;\r\n    }\r\n\r\n    // ** PUBLIC functions **\r\n\r\n    function withdrawProfit() public afterStrategyClosed {\r\n        _withdrawProfitHelper(msg.sender);\r\n    }\r\n\r\n    function withdrawProfit(address[] memory _accounts) public afterStrategyClosed {\r\n        for (uint i = 0; i < _accounts.length; i++) {\r\n           _withdrawProfitHelper(_accounts[i]);\r\n        }\r\n    }\r\n\r\n    // ** ONLY_OWNER functions – calls DfFinanceClose **\r\n\r\n    function collectAndCloseByUser(\r\n        address _dfWallet,\r\n        uint256 _ethForRedeem,\r\n        uint256 _minAmountUsd,\r\n        bool _onlyProfitInUsd,\r\n        bytes memory _exData\r\n    ) public payable onlyOwner {\r\n\r\n        IDfFinanceClose(dfFinanceClose)\r\n            .collectAndCloseByUser\r\n            .value(msg.value)\r\n            (\r\n                _dfWallet,\r\n                _ethForRedeem,\r\n                _minAmountUsd,\r\n                _onlyProfitInUsd,\r\n                _exData\r\n            );\r\n\r\n    }\r\n\r\n    function depositEth(address _dfWallet) public payable onlyOwner {\r\n        (address strategyOwner,,,,,,,,) = IDfFinanceClose(dfFinanceClose).getStrategy(_dfWallet);\r\n        require(address(this) == strategyOwner, \"Incorrect dfWallet address\");\r\n\r\n        uint ethAmount = msg.value;\r\n\r\n        IDfFinanceClose(dfFinanceClose)\r\n            .depositEth\r\n            .value(ethAmount)\r\n            (\r\n                _dfWallet\r\n            );\r\n\r\n        // UPD ethInDeposit state\r\n        ethInDeposit = add(ethInDeposit, ethAmount);\r\n    }\r\n\r\n    function migrateStrategies(address[] memory _dfWallets) public onlyOwner {\r\n        IDfFinanceClose(dfFinanceClose).migrateStrategies(_dfWallets);\r\n    }\r\n\r\n    function exitAfterLiquidation(\r\n        address _dfWallet,\r\n        uint256 _ethForRedeem,\r\n        uint256 _minAmountUsd,\r\n        bytes memory _exData\r\n    ) public payable onlyOwner {\r\n\r\n        IDfFinanceClose(dfFinanceClose)\r\n            .exitAfterLiquidation\r\n            .value(msg.value)\r\n            (\r\n                _dfWallet,\r\n                _ethForRedeem,\r\n                _minAmountUsd,\r\n                _exData\r\n            );\r\n\r\n    }\r\n\r\n    function externalCall(address payable _to, bytes memory _data) public payable onlyOwner {\r\n        uint ethAmount = msg.value;\r\n        bytes32 response;\r\n\r\n        assembly {\r\n            let succeeded := call(sub(gas, 5000), _to, ethAmount, add(_data, 0x20), mload(_data), 0, 32)\r\n            response := mload(0)\r\n            switch iszero(succeeded)\r\n            case 1 {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    // ** CALLBACK function **\r\n\r\n    // closing strategy callback handler\r\n    function __callback(\r\n        bool _isStrategyClosed,\r\n        uint _closingType\r\n    ) external\r\n        onlyDfClose\r\n    returns(\r\n            bool success\r\n    ) {\r\n        // Incorrect closing type for Strategy\r\n        if (strategy.closingType != StrategyClosingType.ANY_TYPE &&\r\n            strategy.closingType != StrategyClosingType(_closingType)\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (_isStrategyClosed) {\r\n            // Strategy is not profitable enough\r\n            if (strategy.onlyWithProfit && !_isProfitable()) {\r\n                return false;\r\n            }\r\n\r\n            // UPD strategy state\r\n            strategy.isStrategyClosed = true;\r\n\r\n            // withdraw owner's deposit\r\n            if (strategy.transferDepositToOwner) {\r\n                _withdrawDeposit();\r\n            }\r\n        }\r\n\r\n        // success\r\n        return true;\r\n    }\r\n\r\n    // ** INTERNAL VIEW functions **\r\n\r\n    function _isProfitable() internal view returns(bool) {\r\n\r\n        (uint ethDeposit, uint usdDeposit, ) = _calculateWithdrawalOnDeposit();\r\n\r\n        uint ethBalance = sub(IToken(ETH_ADDRESS).universalBalanceOf(address(this)), ethDeposit);\r\n        uint usdBalance = sub(IToken(USDC_ADDRESS).universalBalanceOf(address(this)), usdDeposit);\r\n\r\n        // profitPercent in percent (10 == 10%)\r\n        uint targetProfitEth = wmul(strategy.initialEth, WAD * strategy.profitPercent / 100);\r\n        uint targetProfitUsd = IERC20(profitToken).totalSupply() / 1e12;  // 1 profit token == 1 USD\r\n\r\n        // strategy is profitable enough for closing\r\n        if (ethBalance >= targetProfitEth || usdBalance >= targetProfitUsd) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function _calculateWithdrawalOnDeposit() internal view returns(\r\n        uint ethToWithdraw,\r\n        uint usdToWithdraw,\r\n        uint depositEth     // rest deposit in eth after this withdrawal\r\n    ) {\r\n        depositEth = ethInDeposit;\r\n        if (depositEth == 0) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        uint ethBalance = IToken(ETH_ADDRESS).universalBalanceOf(address(this));\r\n        uint usdBalance = IToken(USDC_ADDRESS).universalBalanceOf(address(this));\r\n\r\n        // ethToWithdraw calculate\r\n        if (ethBalance >= depositEth) {\r\n            ethToWithdraw = depositEth;\r\n        } else if (ethBalance > 0) {\r\n            ethToWithdraw = ethBalance;\r\n        }\r\n\r\n        // update depositEth counter\r\n        if (ethToWithdraw > 0) {\r\n            depositEth = sub(depositEth, ethToWithdraw);\r\n        }\r\n\r\n        // calculate usdToWithdraw if there is not enough ETH\r\n        if (depositEth > 0) {\r\n            uint ethPrice = strategy.entryEthPrice;\r\n            uint depositUsd = wmul(depositEth, ethPrice) / 1e12;  // rest deposit in USDC\r\n\r\n            // usdToWithdraw calculate\r\n            if (usdBalance >= depositUsd) {\r\n                usdToWithdraw = depositUsd;\r\n            } else if (usdBalance > 0) {\r\n                usdToWithdraw = usdBalance;\r\n            }\r\n\r\n            // update depositEth counter\r\n            if (usdToWithdraw > 0) {\r\n                depositUsd = sub(depositUsd, usdToWithdraw);\r\n                depositEth = wdiv(depositUsd * 1e12, ethPrice);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ** INTERNAL functions **\r\n\r\n    function _createToken(\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        address _issuer,\r\n        uint _profitPercent,\r\n        uint _curEthPrice,\r\n        uint _curDeposit\r\n    ) internal returns (\r\n        address tokenAddr\r\n    ) {\r\n        // _profitPercent in percent (10 == 10%)\r\n        uint tokensPerEth = wmul(mul(_profitPercent, WAD) / 100, _curEthPrice);  // number of tokens for profit distribution per 1 eth\r\n\r\n        // create EIP1167 Minimal Proxy Contract\r\n        tokenAddr = createClone(sourceTokenAddress);\r\n        IDfProfitToken(tokenAddr)\r\n            .initialize\r\n            (\r\n                _tokenName,\r\n                _tokenSymbol,\r\n                _issuer,\r\n                wmul(_curDeposit, tokensPerEth)     // total supply\r\n            );\r\n\r\n        emit ProfitTokenCreated(tokenAddr);\r\n    }\r\n\r\n    function _withdrawDeposit() internal {\r\n        // calculate withdrawal on deposit\r\n        (uint ethToWithdraw, uint usdToWithdraw, uint restDepositEth) = _calculateWithdrawalOnDeposit();\r\n\r\n        // UPD ethInDeposit state\r\n        ethInDeposit = restDepositEth;\r\n\r\n        // withdraw deposit to owner\r\n        address userAddr = owner;\r\n        _withdrawHelper(userAddr, ethToWithdraw, usdToWithdraw);\r\n\r\n        emit DepositWithdrawn(userAddr, ethToWithdraw, usdToWithdraw);\r\n    }\r\n\r\n    function _withdrawProfitHelper(address _userAddr) internal {\r\n        uint tokenBalance = IERC20(profitToken).balanceOf(_userAddr);\r\n\r\n        if (tokenBalance == 0) {\r\n            return;  // User has no tokens to burn\r\n        }\r\n\r\n        // calculate user's profit\r\n        (uint ethToWithdraw, uint usdToWithdraw) = calculateProfit(_userAddr);\r\n\r\n        // burn all user's tokens\r\n        _burnTokensHelper(_userAddr, tokenBalance);\r\n\r\n        // withdraw user's profit\r\n        _withdrawHelper(_userAddr, ethToWithdraw, usdToWithdraw);\r\n\r\n        emit ProfitWithdrawn(_userAddr, ethToWithdraw, usdToWithdraw);\r\n    }\r\n\r\n    function _burnTokensHelper(address _userAddr, uint _amountToBurn) internal {\r\n        IERC20Burnable(profitToken).burnFrom(_userAddr, _amountToBurn);\r\n    }\r\n\r\n    function _withdrawHelper(\r\n        address _user, uint _ethToWithdraw, uint _usdToWithdraw\r\n    ) internal {\r\n        // withdraw ETH to user\r\n        if (_ethToWithdraw > 0) {\r\n            IToken(ETH_ADDRESS).universalTransfer(_user, _ethToWithdraw, true);\r\n        }\r\n\r\n        // withdraw USDC to user\r\n        if (_usdToWithdraw > 0) {\r\n            IToken(USDC_ADDRESS).universalTransfer(_user, _usdToWithdraw);\r\n        }\r\n    }\r\n\r\n    // **FALLBACK function**\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethToWithdraw\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdToWithdraw\",\"type\":\"uint256\"}],\"name\":\"DepositWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"profitToken\",\"type\":\"address\"}],\"name\":\"ProfitTokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethToWithdraw\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdToWithdraw\",\"type\":\"uint256\"}],\"name\":\"ProfitWithdrawn\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"DF_FINANCE_OPEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USDC_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isStrategyClosed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_closingType\",\"type\":\"uint256\"}],\"name\":\"__callback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"calculateProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethToWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdToWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dfWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ethForRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountUsd\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_onlyProfitInUsd\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_exData\",\"type\":\"bytes\"}],\"name\":\"collectAndCloseByUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dfWallet\",\"type\":\"address\"}],\"name\":\"depositEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dfFinanceClose\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethInDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dfWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ethForRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountUsd\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_exData\",\"type\":\"bytes\"}],\"name\":\"exitAfterLiquidation\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"externalCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_issuer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_onlyWithProfit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_transferDepositToOwner\",\"type\":\"bool\"},{\"internalType\":\"uint256[5]\",\"name\":\"_params\",\"type\":\"uint256[5]\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeData\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_dfWallets\",\"type\":\"address[]\"}],\"name\":\"migrateStrategies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sourceTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"initialEth\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"entryEthPrice\",\"type\":\"uint80\"},{\"internalType\":\"uint8\",\"name\":\"profitPercent\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onlyWithProfit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"transferDepositToOwner\",\"type\":\"bool\"},{\"internalType\":\"enum DfTokenizedStrategy.StrategyClosingType\",\"name\":\"closingType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isStrategyClosed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"withdrawProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DfTokenizedStrategy","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6e8d5f2286192c80f8de02e5c3239b08521191ea5be6e7f0e01cc059099796c6"}]}