{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IMorpherToken.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\ninterface IMorpherToken {\\n    /**\\n     * Emits a {Transfer} event in ERC-20 token contract.\\n     */\\n    function emitTransfer(address _from, address _to, uint256 _amount) external;\\n}\\n\"},\"MerkleProof.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        require(proof.length \\u003c 100, \\\"MerkleProof: proof too long. Use only sibling hashes.\\\");\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i \\u003c proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash \\u003c proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"},\"Migrations.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"},\"MorpherAdmin.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./MorpherState.sol\\\";\\nimport \\\"./MorpherTradeEngine.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Administrator of the Morpher platform\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherAdmin {\\n    MorpherState state;\\n    MorpherTradeEngine tradeEngine;\\n    using SafeMath for uint256;\\n\\n// ----------------------------------------------------------------------------\\n// Precision of prices and leverage\\n// ----------------------------------------------------------------------------\\n\\n    modifier onlyAdministrator {\\n        require(msg.sender == state.getAdministrator(), \\\"Function can only be called by the Administrator.\\\");\\n        _;\\n    }\\n    \\n    constructor(address _stateAddress, address _tradeEngine) public {\\n        state = MorpherState(_stateAddress);\\n        tradeEngine = MorpherTradeEngine(_tradeEngine);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Administrative functions\\n// Set state address and maximum permitted leverage on platform\\n// ----------------------------------------------------------------------------\\n    function setMorpherState(address _stateAddress) public onlyAdministrator {\\n        state = MorpherState(_stateAddress);\\n    }\\n\\n    function setMorpherTradeEngine(address _tradeEngine) public onlyAdministrator {\\n        tradeEngine = MorpherTradeEngine(_tradeEngine);\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// stockSplits(bytes32 _marketId, uint256 _fromIx, uint256 _toIx, uint256 _nominator, uint256 _denominator)\\n// Experimental and untested\\n// ----------------------------------------------------------------------------------\\n\\n    function stockSplits(bytes32 _marketId, uint256 _fromIx, uint256 _toIx, uint256 _nominator, uint256 _denominator) public onlyAdministrator {\\n        require(state.getMarketActive(_marketId) == false, \\\"Market must be paused to process stock splits.\\\");\\n        // If no _fromIx and _toIx specified, do entire _list\\n        if (_fromIx == 0) {\\n            _fromIx = 1;\\n        }\\n        if (_toIx == 0) {\\n            _toIx = state.getMaxMappingIndex(_marketId);\\n        }\\n        uint256 _positionLongShares;\\n        uint256 _positionShortShares;\\n        uint256 _positionAveragePrice;\\n        uint256 _positionAverageSpread;\\n        uint256 _positionAverageLeverage;\\n        uint256 _liquidationPrice;\\n        address _address;\\n        \\n        for (uint256 i = _fromIx; i \\u003c= _toIx; i++) {\\n             // GET position from state\\n             // multiply with nominator, divide by denominator (longShares/shortShares/meanEntry/meanSpread)\\n             // Write back to state\\n            _address = state.getExposureMappingAddress(_marketId, i);\\n            (_positionLongShares, _positionShortShares, _positionAveragePrice, _positionAverageSpread, _positionAverageLeverage, _liquidationPrice) = state.getPosition(_address, _marketId);\\n            _positionLongShares      = _positionLongShares.mul(_denominator).div(_nominator);\\n            _positionShortShares     = _positionShortShares.mul(_denominator).div(_nominator);\\n            _positionAveragePrice    = _positionAveragePrice.mul(_nominator).div(_denominator);\\n            _positionAverageSpread   = _positionAverageSpread.mul(_nominator).div(_denominator);\\n            if (_positionShortShares \\u003e 0) {\\n                _liquidationPrice    = tradeEngine.getLiquidationPrice(_positionAveragePrice, _positionAverageLeverage, false);\\n            } else {\\n                _liquidationPrice    = tradeEngine.getLiquidationPrice(_positionAveragePrice, _positionAverageLeverage, true);\\n            }               \\n            state.setPosition(_address, _marketId, now, _positionLongShares, _positionShortShares, _positionAveragePrice, _positionAverageSpread, _positionAverageLeverage, _liquidationPrice);   \\n        }\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// contractRolls(bytes32 _marketId, uint256 _fromIx, uint256 _toIx, uint256 _rollUp, uint256 _rollDown)\\n// Experimental and untested\\n// ----------------------------------------------------------------------------------\\n    function contractRolls(bytes32 _marketId, uint256 _fromIx, uint256 _toIx, uint256 _rollUp, uint256 _rollDown) public onlyAdministrator {\\n        // If no _fromIx and _toIx specified, do entire _list\\n        // dividends set meanEntry down, rolls either up or down\\n        require(state.getMarketActive(_marketId) == false, \\\"Market must be paused to process rolls.\\\");\\n        // If no _fromIx and _toIx specified, do entire _list\\n        if (_fromIx == 0) {\\n            _fromIx = 1;\\n        }\\n        if (_toIx == 0) {\\n            _toIx = state.getMaxMappingIndex(_marketId);\\n        }\\n        uint256 _positionLongShares;\\n        uint256 _positionShortShares;\\n        uint256 _positionAveragePrice;\\n        uint256 _positionAverageSpread;\\n        uint256 _positionAverageLeverage;\\n        uint256 _liquidationPrice;\\n        address _address;\\n        \\n        for (uint256 i = _fromIx; i \\u003c= _toIx; i++) {\\n             // GET position from state\\n             // shift by _upMove and _downMove (one of them is supposed to be zero)\\n             // Write back to state\\n            _address = state.getExposureMappingAddress(_marketId, i);\\n            (_positionLongShares, _positionShortShares, _positionAveragePrice, _positionAverageSpread, _positionAverageLeverage, _liquidationPrice) = state.getPosition(_address, _marketId);\\n            _positionAveragePrice    = _positionAveragePrice.add(_rollUp).sub(_rollDown);\\n            if (_positionShortShares \\u003e 0) {\\n                _liquidationPrice    = tradeEngine.getLiquidationPrice(_positionAveragePrice, _positionAverageLeverage, false);\\n            } else {\\n                _liquidationPrice    = tradeEngine.getLiquidationPrice(_positionAveragePrice, _positionAverageLeverage, true);\\n            }               \\n            state.setPosition(_address, _marketId, now, _positionLongShares, _positionShortShares, _positionAveragePrice, _positionAverageSpread, _positionAverageLeverage, _liquidationPrice);   \\n        }\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// stockDividends()\\n// May want to add support for dividends later\\n// ----------------------------------------------------------------------------------\\n/*    function stockDividends(bytes32 _marketId, uint256 _fromIx, uint256 _toIx, uint256 _meanEntryUp, uint256 _meanEntryDown) public onlyOracle returns (bool _success){\\n    }\\n*/\\n}\\n\"},\"MorpherAirdrop.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Holds the Airdrop Token balance on contract address\\n// AirdropAdmin can authorize addresses to receive airdrop.\\n// Users have to claim their airdrop actively or Admin initiates transfer.\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherAirdrop is Ownable {\\n    using SafeMath for uint256;\\n\\n// ----------------------------------------------------------------------------\\n// Mappings for authorized / claimed airdrop\\n// ----------------------------------------------------------------------------\\n    mapping(address =\\u003e uint256) private airdropClaimed;\\n    mapping(address =\\u003e uint256) private airdropAuthorized;\\n\\n    uint256 public totalAirdropAuthorized;\\n    uint256 public totalAirdropClaimed;\\n\\n    address public airdropAdmin;\\n    address public morpherToken;\\n\\n// ----------------------------------------------------------------------------\\n// Events\\n// ----------------------------------------------------------------------------\\n    event AirdropSent(address indexed _operator, address indexed _recipient, uint256 _amountClaimed, uint256 _amountAuthorized);\\n    event SetAirdropAuthorized(address indexed _recipient, uint256 _amountClaimed, uint256 _amountAuthorized);\\n\\n    constructor(address _airdropAdminAddress, address _morpherToken, address _coldStorageOwnerAddress) public {\\n        setAirdropAdmin(_airdropAdminAddress);\\n        setMorpherTokenAddress(_morpherToken);\\n        transferOwnership(_coldStorageOwnerAddress);\\n    }\\n\\n    modifier onlyAirdropAdmin {\\n        require(msg.sender == airdropAdmin, \\\"MorpherAirdrop: can only be called by Airdrop Administrator.\\\");\\n        _;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Administrative functions\\n// ----------------------------------------------------------------------------\\n    function setAirdropAdmin(address _address) public onlyOwner {\\n        airdropAdmin = _address;\\n    }\\n\\n    function setMorpherTokenAddress(address _address) public onlyOwner {\\n        morpherToken = _address;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Get airdrop amount authorized for or claimed by address\\n// ----------------------------------------------------------------------------\\n    function getAirdropClaimed(address _userAddress) public view returns (uint256 _amount) {\\n        return airdropClaimed[_userAddress];\\n    }\\n\\n    function getAirdropAuthorized(address _userAddress) public view returns (uint256 _balance) {\\n        return airdropAuthorized[_userAddress];\\n    }\\n\\n    function getAirdrop(address _userAddress) public view returns(uint256 _claimed, uint256 _authorized) {\\n        return (airdropClaimed[_userAddress], airdropAuthorized[_userAddress]);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Airdrop Administrator can authorize airdrop amount per address\\n// ----------------------------------------------------------------------------\\n    function setAirdropAuthorized(address _userAddress, uint256 _authorized) public onlyAirdropAdmin {\\n        // Can only set authorized amount to be higher than claimed\\n        require(_authorized \\u003e= airdropClaimed[_userAddress], \\\"MorpherAirdrop: airdrop authorized must be larger than claimed.\\\");\\n        // Authorized amount can be higher or lower than previously authorized amount, adjust accordingly\\n        totalAirdropAuthorized = totalAirdropAuthorized.sub(getAirdropAuthorized(_userAddress)).add(_authorized);\\n        airdropAuthorized[_userAddress] = _authorized;\\n        emit SetAirdropAuthorized(_userAddress, airdropClaimed[_userAddress], _authorized);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// User claims their entire airdrop\\n// ----------------------------------------------------------------------------\\n    function claimAirdrop() public {\\n        uint256 _amount = airdropAuthorized[msg.sender].sub(airdropClaimed[msg.sender]);\\n        _sendAirdrop(msg.sender, _amount);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// User claims part of their airdrop\\n// ----------------------------------------------------------------------------\\n    function claimSomeAirdrop(uint256 _amount) public {\\n        _sendAirdrop(msg.sender, _amount);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Administrator sends user their entire airdrop\\n// ----------------------------------------------------------------------------\\n    function adminSendAirdrop(address _recipient) public onlyAirdropAdmin {\\n        uint256 _amount = airdropAuthorized[_recipient].sub(airdropClaimed[_recipient]);\\n        _sendAirdrop(_recipient, _amount);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Administrator sends user part of their airdrop\\n// ----------------------------------------------------------------------------\\n    function adminSendSomeAirdrop(address _recipient, uint256 _amount) public onlyAirdropAdmin {\\n        _sendAirdrop(_recipient, _amount);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Administrator sends user entire airdrop\\n// ----------------------------------------------------------------------------\\n    function _sendAirdrop(address _recipient, uint256 _amount) private {\\n        require(airdropAuthorized[_recipient] \\u003e= airdropClaimed[_recipient].add(_amount), \\\"MorpherAirdrop: amount exceeds authorized airdrop amount.\\\");\\n        airdropClaimed[_recipient] = airdropClaimed[_recipient].add(_amount);\\n        totalAirdropClaimed = totalAirdropClaimed.add(_amount);\\n        IERC20(morpherToken).transfer(_recipient, _amount);\\n        emit AirdropSent(msg.sender, _recipient, airdropClaimed[_recipient], airdropAuthorized[_recipient]);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Administrator sends user part of their airdrop\\n// ----------------------------------------------------------------------------\\n    function adminAuthorizeAndSend(address _recipient, uint256 _amount) public onlyAirdropAdmin {\\n        setAirdropAuthorized(_recipient, getAirdropAuthorized(_recipient).add(_amount));\\n        _sendAirdrop(_recipient, _amount);\\n    }\\n\\n// ------------------------------------------------------------------------\\n// Don\\u0027t accept ETH\\n// ------------------------------------------------------------------------\\n    function () external payable {\\n        revert(\\\"MorpherAirdrop: you can\\u0027t deposit Ether here\\\");\\n    }\\n}\\n\"},\"MorpherBridge.sol\":{\"content\":\"// ------------------------------------------------------------------------\\n// MorpherBridge\\n// Handles deposit to and withdraws from the side chain, writing of the merkle\\n// root to the main chain by the side chain operator, and enforces a rolling 24 hours\\n// token withdraw limit from side chain to main chain.\\n// If side chain operator doesn\\u0027t write a merkle root hash to main chain for more than\\n// 72 hours positions and balaces from side chain can be transferred to main chain.\\n// ------------------------------------------------------------------------\\n\\npragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./MorpherState.sol\\\";\\nimport \\\"./MerkleProof.sol\\\";\\n\\ncontract MorpherBridge is Ownable {\\n\\n    MorpherState state;\\n    using SafeMath for uint256;\\n\\n    event TransferToLinkedChain(\\n        address indexed from,\\n        uint256 tokens,\\n        uint256 totalTokenSent,\\n        uint256 timeStamp,\\n        uint256 transferNonce,\\n        bytes32 indexed transferHash\\n    );\\n    event TrustlessWithdrawFromSideChain(address indexed from, uint256 tokens);\\n    event OperatorChainTransfer(address indexed from, uint256 tokens, bytes32 sidechainTransactionHash);\\n    event ClaimFailedTransferToSidechain(address indexed from, uint256 tokens);\\n    event PositionRecoveryFromSideChain(address indexed from, bytes32 positionHash);\\n    event TokenRecoveryFromSideChain(address indexed from, bytes32 positionHash);\\n    event SideChainMerkleRootUpdated(bytes32 _rootHash);\\n    event WithdrawLimitReset();\\n    event WithdrawLimitChanged(uint256 _withdrawLimit);\\n    event LinkState(address _address);\\n\\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\\n        setMorpherState(_stateAddress);\\n        transferOwnership(_coldStorageOwnerAddress);\\n    }\\n\\n    modifier onlySideChainOperator {\\n        require(msg.sender == state.getSideChainOperator(), \\\"MorpherBridge: Function can only be called by Sidechain Operator.\\\");\\n        _;\\n    }\\n\\n    modifier sideChainInactive {\\n        require(now - state.inactivityPeriod() \\u003e state.getSideChainMerkleRootWrittenAtTime(), \\\"MorpherBridge: Function can only be called if sidechain is inactive.\\\");\\n        _;\\n    }\\n    \\n    modifier fastTransfers {\\n        require(state.fastTransfersEnabled() == true, \\\"MorpherBridge: Fast transfers have been disabled permanently.\\\");\\n        _;\\n    }\\n\\n    modifier onlyMainchain {\\n        require(state.mainChain() == true, \\\"MorpherBridge: Function can only be executed on Ethereum.\\\" );\\n        _;\\n    }\\n    \\n    // ------------------------------------------------------------------------\\n    // Links Token Contract with State\\n    // ------------------------------------------------------------------------\\n    function setMorpherState(address _stateAddress) public onlyOwner {\\n        state = MorpherState(_stateAddress);\\n        emit LinkState(_stateAddress);\\n    }\\n\\n    function setInactivityPeriod(uint256 _periodInSeconds) private {\\n        state.setInactivityPeriod(_periodInSeconds);\\n    }\\n\\n    function disableFastTransfers() public onlyOwner  {\\n        state.disableFastWithdraws();\\n    }\\n\\n    function updateSideChainMerkleRoot(bytes32 _rootHash) public onlySideChainOperator {\\n        state.setSideChainMerkleRoot(_rootHash);\\n        emit SideChainMerkleRootUpdated(_rootHash);\\n    }\\n\\n    function resetLast24HoursAmountWithdrawn() public onlySideChainOperator {\\n        state.resetLast24HoursAmountWithdrawn();\\n        emit WithdrawLimitReset();\\n    }\\n\\n    function set24HourWithdrawLimit(uint256 _withdrawLimit) public onlySideChainOperator {\\n        state.set24HourWithdrawLimit(_withdrawLimit);\\n        emit WithdrawLimitChanged(_withdrawLimit);\\n    }\\n\\n    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token) {\\n        return state.getTokenSentToLinkedChain(_address);\\n    }\\n\\n    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token)  {\\n        return state.getTokenClaimedOnThisChain(_address);\\n    }\\n\\n    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _time)  {\\n        return state.getTokenSentToLinkedChainTime(_address);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // verifyWithdrawOk(uint256 _amount)\\n    // Checks if creating _amount token on main chain does not violate the 24 hour transfer limit\\n    // ------------------------------------------------------------------------\\n    function verifyWithdrawOk(uint256 _amount) public returns (bool _authorized) {\\n        uint256 _lastWithdrawLimitReductionTime = state.lastWithdrawLimitReductionTime();\\n        uint256 _withdrawLimit24Hours = state.withdrawLimit24Hours();\\n        \\n        if (now \\u003e _lastWithdrawLimitReductionTime) {\\n            uint256 _timePassed = now.sub(_lastWithdrawLimitReductionTime);\\n            state.update24HoursWithdrawLimit(_timePassed.mul(_withdrawLimit24Hours).div(1 days));\\n        }\\n        \\n        if (state.last24HoursAmountWithdrawn().add(_amount) \\u003c= _withdrawLimit24Hours) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // transferToSideChain(uint256 _tokens)\\n    // Transfer token to Morpher\\u0027s side chain to trade without fees and near instant\\n    // settlement.\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\n    // - 0 value transfers are not supported\\n    // Token are burned on the main chain and are created and credited to msg.sender\\n    //  on the side chain\\n    // ------------------------------------------------------------------------\\n    function transferToSideChain(uint256 _tokens) public {\\n        require(_tokens \\u003e= 0, \\\"MorpherBridge: Amount of tokens must be positive.\\\");\\n        require(state.balanceOf(msg.sender) \\u003e= _tokens, \\\"MorpherBridge: Insufficient balance.\\\");\\n        state.burn(msg.sender, _tokens);\\n        uint256 _newTokenSentToLinkedChain = getTokenSentToLinkedChain(msg.sender).add(_tokens);\\n        uint256 _transferNonce = state.getBridgeNonce();\\n        uint256 _timeStamp = now;\\n        bytes32 _transferHash = keccak256(\\n            abi.encodePacked(\\n                msg.sender,\\n                _tokens,\\n                _newTokenSentToLinkedChain,\\n                _timeStamp,\\n                _transferNonce\\n            )\\n        );\\n        state.setTokenSentToLinkedChain(msg.sender, _newTokenSentToLinkedChain);\\n        emit TransferToLinkedChain(msg.sender, _tokens, _newTokenSentToLinkedChain, _timeStamp, _transferNonce, _transferHash);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // fastTransferFromSideChain(uint256 _numOfToken, uint256 _tokenBurnedOnLinkedChain, bytes32[] memory _proof)\\n    // The sidechain operator can credit users with token they burend on the sidechain. Transfers\\n    // happen immediately. To be removed after Beta.\\n    // ------------------------------------------------------------------------\\n    function fastTransferFromSideChain(address _address, uint256 _numOfToken, uint256 _tokenBurnedOnLinkedChain, bytes32 _sidechainTransactionHash) public onlySideChainOperator fastTransfers {\\n        uint256 _tokenClaimed = state.getTokenClaimedOnThisChain(_address);\\n        require(verifyWithdrawOk(_numOfToken), \\\"MorpherBridge: Withdraw amount exceeds permitted 24 hour limit. Please try again in a few hours.\\\");\\n        require(_tokenClaimed.add(_numOfToken) \\u003c= _tokenBurnedOnLinkedChain, \\\"MorpherBridge: Token amount exceeds token deleted on linked chain.\\\");\\n        _chainTransfer(_address, _tokenClaimed, _numOfToken);\\n        emit OperatorChainTransfer(_address, _numOfToken, _sidechainTransactionHash);\\n    }\\n    \\n    // ------------------------------------------------------------------------\\n    // trustlessTransferFromSideChain(uint256 _numOfToken, uint256 _claimLimit, bytes32[] memory _proof)\\n    // Performs a merkle proof on the number of token that have been burned by the user on the side chain.\\n    // If the number of token claimed on the main chain is less than the number of burned token on the side chain\\n    // the difference (or less) can be claimed on the main chain.\\n    // ------------------------------------------------------------------------\\n    function trustlessTransferFromLinkedChain(uint256 _numOfToken, uint256 _claimLimit, bytes32[] memory _proof) public {\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _claimLimit));\\n        uint256 _tokenClaimed = state.getTokenClaimedOnThisChain(msg.sender);        \\n        require(mProof(_proof, leaf), \\\"MorpherBridge: Merkle Proof failed. Please make sure you entered the correct claim limit.\\\");\\n        require(verifyWithdrawOk(_numOfToken), \\\"MorpherBridge: Withdraw amount exceeds permitted 24 hour limit. Please try again in a few hours.\\\");\\n        require(_tokenClaimed.add(_numOfToken) \\u003c= _claimLimit, \\\"MorpherBridge: Token amount exceeds token deleted on linked chain.\\\");     \\n        _chainTransfer(msg.sender, _tokenClaimed, _numOfToken);   \\n        emit TrustlessWithdrawFromSideChain(msg.sender, _numOfToken);\\n    }\\n    \\n    // ------------------------------------------------------------------------\\n    // _chainTransfer(address _address, uint256 _tokenClaimed, uint256 _numOfToken)\\n    // Creates token on the chain for the user after proving their distruction on the \\n    // linked chain has been proven before \\n    // ------------------------------------------------------------------------\\n    function _chainTransfer(address _address, uint256 _tokenClaimed, uint256 _numOfToken) private {\\n        state.setTokenClaimedOnThisChain(_address, _tokenClaimed.add(_numOfToken));\\n        state.add24HoursWithdrawn(_numOfToken);\\n        state.mint(_address, _numOfToken);\\n    }\\n        \\n    // ------------------------------------------------------------------------\\n    // claimFailedTransferToSidechain(uint256 _wrongSideChainBalance, bytes32[] memory _proof)\\n    // If token sent to side chain were not credited to the user on the side chain within inactivityPeriod\\n    // they can reclaim the token on the main chain by submitting the proof that their\\n    // side chain balance is less than the number of token sent from main chain.\\n    // ------------------------------------------------------------------------\\n    function claimFailedTransferToSidechain(uint256 _wrongSideChainBalance, bytes32[] memory _proof) public {\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _wrongSideChainBalance));\\n        uint256 _tokenSentToLinkedChain = getTokenSentToLinkedChain(msg.sender);\\n        uint256 _tokenSentToLinkedChainTime = getTokenSentToLinkedChainTime(msg.sender);\\n        uint256 _inactivityPeriod = state.inactivityPeriod();\\n        \\n        require(now \\u003e _tokenSentToLinkedChainTime.add(_inactivityPeriod), \\\"MorpherBridge: Failed deposits can only be claimed after inactivity period.\\\");\\n        require(_wrongSideChainBalance \\u003c _tokenSentToLinkedChain, \\\"MorpherBridge: Other chain credit is greater equal to wrongSideChainBalance.\\\");\\n        require(verifyWithdrawOk(_tokenSentToLinkedChain.sub(_wrongSideChainBalance)), \\\"MorpherBridge: Claim amount exceeds permitted 24 hour limit.\\\");\\n        require(mProof(_proof, leaf), \\\"MorpherBridge: Merkle Proof failed. Enter total amount of deposits on side chain.\\\");\\n        \\n        uint256 _claimAmount = _tokenSentToLinkedChain.sub(_wrongSideChainBalance);\\n        state.setTokenSentToLinkedChain(msg.sender, _tokenSentToLinkedChain.sub(_claimAmount));\\n        state.add24HoursWithdrawn(_claimAmount);\\n        state.mint(msg.sender, _claimAmount);\\n        emit ClaimFailedTransferToSidechain(msg.sender, _claimAmount);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // recoverPositionFromSideChain(bytes32[] memory _proof, bytes32 _leaf, bytes32 _marketId, uint256 _timeStamp, uint256 _longShares, uint256 _shortShares, uint256 _meanEntryPrice, uint256 _meanEntrySpread, uint256 _meanEntryLeverage)\\n    // Failsafe against side chain operator becoming inactive or withholding Times (Time withhold attack).\\n    // After 72 hours of no update of the side chain merkle root users can withdraw their last recorded\\n    // positions from side chain to main chain. Overwrites eventually existing position on main chain.\\n    // ------------------------------------------------------------------------\\n    function recoverPositionFromSideChain(\\n        bytes32[] memory _proof,\\n        bytes32 _leaf,\\n        bytes32 _marketId,\\n        uint256 _timeStamp,\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n        ) public sideChainInactive onlyMainchain {\\n        require(_leaf == state.getPositionHash(msg.sender, _marketId, _timeStamp, _longShares, _shortShares, _meanEntryPrice, _meanEntrySpread, _meanEntryLeverage, _liquidationPrice), \\\"MorpherBridge: leaf does not equal position hash.\\\");\\n        require(state.getPositionClaimedOnMainChain(_leaf) == false, \\\"MorpherBridge: Position already transferred.\\\");\\n        require(mProof(_proof,_leaf) == true, \\\"MorpherBridge: Merkle proof failed.\\\");\\n        state.setPositionClaimedOnMainChain(_leaf);\\n        state.setPosition(msg.sender, _marketId, _timeStamp, _longShares, _shortShares, _meanEntryPrice, _meanEntrySpread, _meanEntryLeverage, _liquidationPrice);\\n        emit PositionRecoveryFromSideChain(msg.sender, _leaf);\\n        // Remark: After resuming operations side chain operator has 72 hours to sync and eliminate transferred positions on side chain to avoid double spend\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // recoverTokenFromSideChain(bytes32[] memory _proof, bytes32 _leaf, bytes32 _marketId, uint256 _timeStamp, uint256 _longShares, uint256 _shortShares, uint256 _meanEntryPrice, uint256 _meanEntrySpread, uint256 _meanEntryLeverage)\\n    // Failsafe against side chain operator becoming inactive or withholding times (time withhold attack).\\n    // After 72 hours of no update of the side chain merkle root users can withdraw their last recorded\\n    // token balance from side chain to main chain.\\n    // ------------------------------------------------------------------------\\n    function recoverTokenFromSideChain(bytes32[] memory _proof, bytes32 _leaf, uint256 _balance) public sideChainInactive onlyMainchain {\\n        // Require side chain root hash not set on Mainchain for more than 72 hours (=3 days)\\n        require(_leaf == state.getBalanceHash(msg.sender, _balance), \\\"MorpherBridge: Wrong balance.\\\");\\n        require(state.getPositionClaimedOnMainChain(_leaf) == false, \\\"MorpherBridge: Token already transferred.\\\");\\n        require(mProof(_proof,_leaf) == true, \\\"MorpherBridge: Merkle proof failed.\\\");\\n        require(verifyWithdrawOk(_balance), \\\"MorpherBridge: Withdraw amount exceeds permitted 24 hour limit.\\\");\\n        state.setPositionClaimedOnMainChain(_leaf);\\n        _chainTransfer(msg.sender, state.getTokenClaimedOnThisChain(msg.sender), _balance);\\n        emit TokenRecoveryFromSideChain(msg.sender, _leaf);\\n        // Remark: Side chain operator must adjust side chain balances for token recoveries before restarting operations to avoid double spend\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // mProof(bytes32[] memory _proof, bytes32 _leaf)\\n    // Computes merkle proof against the root hash of the sidechain stored in Morpher state\\n    // ------------------------------------------------------------------------\\n    function mProof(bytes32[] memory _proof, bytes32 _leaf) public view returns(bool _isTrue) {\\n        return MerkleProof.verify(_proof, state.getSideChainMerkleRoot(), _leaf);\\n    }\\n}\\n\"},\"MorpherEscrow.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Escrow contract to safely store and release the token allocated to Morpher at\\n// protocol inception\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherEscrow is Ownable{\\n    using SafeMath for uint256;\\n\\n    uint256 public lastEscrowTransferTime;\\n    address public recipient;\\n    address public morpherToken;\\n\\n    uint256 public constant RELEASEAMOUNT = 10**25;\\n    uint256 public constant RELEASEPERIOD = 30 days;\\n\\n    event EscrowReleased(uint256 _released, uint256 _leftInEscrow);\\n\\n    constructor(address _recipientAddress, address _morpherToken, address _coldStorageOwnerAddress) public {\\n        setRecipientAddress(_recipientAddress);\\n        setMorpherTokenAddress(_morpherToken);\\n        lastEscrowTransferTime = now;\\n        transferOwnership(_coldStorageOwnerAddress);\\n    }\\n\\n    // ----------------------------------------------------------------------------------\\n    // Owner can modify recipient address and update morpherToken adddress\\n    // ----------------------------------------------------------------------------------\\n    function setRecipientAddress(address _recipientAddress) public onlyOwner {\\n        recipient = _recipientAddress;\\n    }\\n\\n    function setMorpherTokenAddress(address _address) public onlyOwner {\\n        morpherToken = _address;\\n    }\\n\\n    // ----------------------------------------------------------------------------------\\n    // Anyone can release funds from escrow if enough time has elapsed\\n    // Every 30 days 1% of the total initial supply or 10m token are released to Morpher\\n    // ----------------------------------------------------------------------------------\\n    function releaseFromEscrow() public {\\n        require(IERC20(morpherToken).balanceOf(address(this)) \\u003e 0, \\\"No funds left in escrow.\\\");\\n        uint256 _releasedAmount;\\n        if (now \\u003e lastEscrowTransferTime.add(RELEASEPERIOD)) {\\n            if (IERC20(morpherToken).balanceOf(address(this)) \\u003e RELEASEAMOUNT) {\\n                _releasedAmount = RELEASEAMOUNT;\\n            } else {\\n                _releasedAmount = IERC20(morpherToken).balanceOf(address(this));\\n            }\\n            IERC20(morpherToken).transfer(recipient, _releasedAmount);\\n            lastEscrowTransferTime = lastEscrowTransferTime.add(RELEASEPERIOD);\\n            emit EscrowReleased(_releasedAmount, IERC20(morpherToken).balanceOf(address(this)));\\n        }\\n    }\\n}\\n\"},\"MorpherGovernance.sol\":{\"content\":\"pragma solidity 0.5.16;\\n// ------------------------------------------------------------------------\\n// Morpher Governance (MAIN CHAIN ONLY)\\n//\\n// Every user able and willig to lock up sufficient token can become a validator\\n// of the Morpher protocol. Validators function similiar to a board of directors\\n// and vote on the protocol Administrator and the Oracle contract.\\n// The Administrator (=Protocol CEO) has the power to add/delete markets and to\\n// pause the contracts to allow for updates.\\n// The Oracle contract is the address of the contract allowed to fetch prices\\n// from outside the smart contract.\\n//\\n// It becomes progressively harder to become a valdiator. Each new validator\\n// has to lock up (numberOfValidators + 1) * 10m Morpher token. Upon stepping\\n// down as validator only 99% of the locked up token are returned, the other 1%\\n// are burned.\\n//\\n// Governance is expected to become more sophisticated in the future\\n// ------------------------------------------------------------------------\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./MorpherState.sol\\\";\\n\\ncontract MorpherGovernance is Ownable {\\n\\n    using SafeMath for uint256;\\n    MorpherState state;\\n    \\n    event BecomeValidator(address indexed _sender, uint256 indexed _myValidatorIndex);\\n    event StepDownAsValidator(address indexed _sender, uint256 indexed _myValidatorIndex);\\n    event ElectedAdministrator(address indexed _administratorAddress, uint256 _votes);\\n    event ElectedOracle(address indexed _oracleAddress, uint256 _votes);\\n\\n    uint256 public constant MINVALIDATORLOCKUP = 10**25;\\n    uint256 public constant MAXVALIDATORS = 21;\\n    uint256 public constant VALIDATORWARMUPPERIOD = 7 days;\\n\\n    uint256 public numberOfValidators;\\n    uint256 public lastValidatorJoined;\\n    uint256 public rewardBasisPoints;\\n\\n    address public morpherToken;\\n\\n    mapping(address =\\u003e uint256) private validatorIndex;\\n    mapping(address =\\u003e uint256) private validatorJoinedAtTime;\\n    mapping(uint256 =\\u003e address) private validatorAddress;\\n    mapping(address =\\u003e address) private oracleVote;\\n    mapping(address =\\u003e address) private administratorVote;\\n    mapping(address =\\u003e uint256) private countVotes;\\n\\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\\n        setMorpherState(_stateAddress);\\n        transferOwnership(_coldStorageOwnerAddress);        \\n    }\\n    \\n    modifier onlyValidator() {\\n        require(isValidator(msg.sender), \\\"MorpherGovernance: Only Validators can invoke that function.\\\");\\n        _;\\n    }\\n\\n    function setMorpherState(address _stateAddress) private {\\n        state = MorpherState(_stateAddress);\\n    }\\n\\n    function setMorpherTokenAddress(address _address) public onlyOwner {\\n        morpherToken = _address;\\n    }\\n\\n    function getValidatorAddress(uint256 _index) public view returns (address _address) {\\n        return validatorAddress[_index];\\n    }\\n\\n    function getValidatorIndex(address _address) public view returns (uint256 _index) {\\n        return validatorIndex[_address];\\n    }\\n\\n    function isValidator(address _address) public view returns (bool) {\\n        return validatorIndex[_address] \\u003e 0;\\n    }\\n\\n    function setOracle(address  _oracleAddress) private {\\n        state.setOracleContract(_oracleAddress);\\n    }\\n\\n    function setAdministrator(address _administratorAddress) private {\\n        state.setAdministrator(_administratorAddress);\\n    }\\n\\n    function getMorpherAdministrator() public view returns (address _address) {\\n        return state.getAdministrator();\\n    }\\n\\n    function getMorpherOracle() public view returns (address _address)  {\\n        return state.getOracleContract();\\n    }\\n\\n    function getOracleVote(address _address) public view returns (address _votedOracleAddress) {\\n        return oracleVote[_address];\\n    }\\n\\n    function becomeValidator() public {\\n        // To become a validator you have to lock up 10m * (number of validators + 1) Morpher Token in escrow\\n        // After a warmup period of 7 days the new validator can vote on Oracle contract and protocol Administrator\\n        uint256 _requiredAmount = MINVALIDATORLOCKUP.mul(numberOfValidators.add(1));\\n        require(state.balanceOf(msg.sender) \\u003e= _requiredAmount, \\\"MorpherGovernance: Insufficient balance to become Validator.\\\");\\n        require(isValidator(msg.sender) == false, \\\"MorpherGovernance: Address is already Validator.\\\");\\n        require(numberOfValidators \\u003c= MAXVALIDATORS, \\\"MorpherGovernance: number of Validators can not exceed Max Validators.\\\");\\n        state.transfer(msg.sender, address(this), _requiredAmount);\\n        numberOfValidators = numberOfValidators.add(1);\\n        validatorIndex[msg.sender] = numberOfValidators;\\n        validatorJoinedAtTime[msg.sender] = now;\\n        lastValidatorJoined = now;\\n        validatorAddress[numberOfValidators] = msg.sender;\\n        emit BecomeValidator(msg.sender, numberOfValidators);\\n    }\\n\\n    function stepDownValidator() public onlyValidator {\\n        // Stepping down as validator nullifies the validator\\u0027s votes and releases his token\\n        // from escrow. If the validator stepping down is not the validator that joined last,\\n        // all validators who joined after the validator stepping down receive 10^7 * 0.99 token from\\n        // escrow, and their validator ordinal number is reduced by one. E.g. if validator 3 of 5 steps down\\n        // validator 4 becomes validator 3, and validator 5 becomes validator 4. Both receive 10^7 * 0.99 token\\n        // from escrow, as their new position requires fewer token in lockup. 1% of the token released from escrow \\n        // are burned for every validator receiving a payout. \\n        // Burning prevents vote delay attacks: validators stepping down and re-joining could\\n        // delay votes for VALIDATORWARMUPPERIOD.\\n        uint256 _myValidatorIndex = validatorIndex[msg.sender];\\n        require(state.balanceOf(address(this)) \\u003e= MINVALIDATORLOCKUP.mul(numberOfValidators), \\\"MorpherGovernance: Escrow does not have enough funds. Should not happen.\\\");\\n        // Stepping down as validator potentially releases token to the other validatorAddresses\\n        for (uint256 i = _myValidatorIndex; i \\u003c numberOfValidators; i++) {\\n            validatorAddress[i] = validatorAddress[i+1];\\n            validatorIndex[validatorAddress[i]] = i;\\n            // Release 9.9m of token to every validator moving up, burn 0.1m token\\n            state.transfer(address(this), validatorAddress[i], MINVALIDATORLOCKUP.div(100).mul(99));\\n            state.burn(address(this), MINVALIDATORLOCKUP.div(100));\\n        }\\n        // Release 99% of escrow token of validator dropping out, burn 1%\\n        validatorAddress[numberOfValidators] = address(0);\\n        validatorIndex[msg.sender] = 0;\\n        validatorJoinedAtTime[msg.sender] = 0;\\n        oracleVote[msg.sender] = address(0);\\n        administratorVote[msg.sender] = address(0);\\n        numberOfValidators = numberOfValidators.sub(1);\\n        countOracleVote();\\n        countAdministratorVote();\\n        state.transfer(address(this), msg.sender, MINVALIDATORLOCKUP.mul(_myValidatorIndex).div(100).mul(99));\\n        state.burn(address(this), MINVALIDATORLOCKUP.mul(_myValidatorIndex).div(100));\\n        emit StepDownAsValidator(msg.sender, validatorIndex[msg.sender]);\\n    }\\n\\n    function voteOracle(address _oracleAddress) public onlyValidator {\\n        require(validatorJoinedAtTime[msg.sender].add(VALIDATORWARMUPPERIOD) \\u003c now, \\\"MorpherGovernance: Validator was just appointed and is not eligible to vote yet.\\\");\\n        require(lastValidatorJoined.add(VALIDATORWARMUPPERIOD) \\u003c now, \\\"MorpherGovernance: New validator joined the board recently, please wait for the end of the warm up period.\\\");\\n        oracleVote[msg.sender] = _oracleAddress;\\n        // Count Oracle Votes\\n        (address _votedOracleAddress, uint256 _votes) = countOracleVote();\\n        emit ElectedOracle(_votedOracleAddress, _votes);\\n    }\\n\\n    function voteAdministrator(address _administratorAddress) public onlyValidator {\\n        require(validatorJoinedAtTime[msg.sender].add(VALIDATORWARMUPPERIOD) \\u003c now, \\\"MorpherGovernance: Validator was just appointed and is not eligible to vote yet.\\\");\\n        require(lastValidatorJoined.add(VALIDATORWARMUPPERIOD) \\u003c now, \\\"MorpherGovernance: New validator joined the board recently, please wait for the end of the warm up period.\\\");\\n        administratorVote[msg.sender] = _administratorAddress;\\n        // Count Administrator Votes\\n        (address _appointedAdministrator, uint256 _votes) = countAdministratorVote();\\n        emit ElectedAdministrator(_appointedAdministrator, _votes);\\n    }\\n\\n    function countOracleVote() public returns (address _votedOracleAddress, uint256 _votes) {\\n        // Count oracle votes\\n        for (uint256 i = 1; i \\u003c= numberOfValidators; i++) {\\n            countVotes[oracleVote[validatorAddress[i]]]++;\\n            if (countVotes[oracleVote[validatorAddress[i]]] \\u003e _votes) {\\n                _votes = countVotes[oracleVote[validatorAddress[i]]];\\n                _votedOracleAddress = oracleVote[validatorAddress[i]];\\n            }\\n        }\\n        // Evaluate: Simple majority of Validators resets oracleAddress\\n        if (_votes \\u003e numberOfValidators.div(2)) {\\n            setOracle(_votedOracleAddress);\\n        }\\n        for (uint256 i = 1; i \\u003c= numberOfValidators; i++) {\\n            countVotes[administratorVote[validatorAddress[i]]] = 0;\\n        }\\n        return(_votedOracleAddress, _votes);\\n    }\\n\\n    function countAdministratorVote() public returns (address _appointedAdministrator, uint256 _votes) {\\n        // Count Administrator votes\\n        for (uint256 i=1; i\\u003c=numberOfValidators; i++) {\\n            countVotes[administratorVote[validatorAddress[i]]]++;\\n            if (countVotes[administratorVote[validatorAddress[i]]] \\u003e _votes) {\\n                _votes = countVotes[administratorVote[validatorAddress[i]]];\\n                _appointedAdministrator = administratorVote[validatorAddress[i]];\\n            }\\n        }\\n        // Evaluate: Simple majority of Validators resets administratorAddress\\n        if (_votes \\u003e numberOfValidators / 2) {\\n            setAdministrator(_appointedAdministrator);\\n        }\\n        for (uint256 i = 1; i \\u003c= numberOfValidators; i++) {\\n            countVotes[administratorVote[validatorAddress[i]]] = 0;\\n        }\\n        return(_appointedAdministrator, _votes);\\n    }\\n}\\n\"},\"MorpherOracle.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./MorpherTradeEngine.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Morpher Oracle contract\\n// The oracle initates a new trade by calling trade engine and requesting a new orderId.\\n// An event is fired by the contract notifying the oracle operator to query a price/liquidation unchecked\\n// for a market/user and return the information via the callback function. Since calling\\n// the callback function requires gas, the user must send a fixed amount of Ether when\\n// creating their order.\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherOracle is Ownable {\\n\\n    MorpherTradeEngine tradeEngine;\\n\\n    bool public paused;\\n\\n    uint256 public gasForCallback;\\n    address payable public callBackCollectionAddress;\\n\\n    mapping(address =\\u003e bool) public callBackAddress;\\n\\n// ----------------------------------------------------------------------------------\\n// Events\\n// ----------------------------------------------------------------------------------\\n    event OrderCreated(\\n        bytes32 indexed _orderId,\\n        address indexed _address,\\n        bytes32 indexed _marketId,\\n        bool _tradeAmountGivenInShares,\\n        uint256 _tradeAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage\\n        );\\n\\n    event LiquidationOrderCreated(\\n        bytes32 indexed _orderId,\\n        address _sender,\\n        address indexed _address,\\n        bytes32 indexed _marketId\\n        );\\n\\n    event OrderProcessed(\\n        bytes32 indexed _orderId,\\n        uint256 _price,\\n        uint256 _spread,\\n        uint256 _positionLiquidationTimestamp,\\n        uint256 _timeStamp,\\n        uint256 _newLongShares,\\n        uint256 _newShortShares,\\n        uint256 _newMeanEntry,\\n        uint256 _newMeanSprad,\\n        uint256 _newMeanLeverage,\\n        uint256 _liquidationPrice\\n        );\\n\\n    event OrderFailed(\\n        bytes32 indexed _orderId,\\n        address indexed _address,\\n        bytes32 indexed _marketId,\\n        bool _tradeAmountGivenInShares,\\n        uint256 _tradeAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage\\n        );\\n\\n    event OrderCancelled(\\n        bytes32 indexed _orderId,\\n        address indexed _sender\\n        );\\n\\n    event CallbackAddressEnabled(\\n        address indexed _address\\n        );\\n\\n    event CallbackAddressDisabled(\\n        address indexed _address\\n        );\\n\\n    event OraclePaused(\\n        bool _paused\\n        );\\n\\n    event CallBackCollectionAddressChange(\\n        address _address\\n        );\\n\\n    event SetGasForCallback(\\n        uint256 _gasForCallback\\n        );\\n\\n    event LinkTradeEngine(\\n        address _address\\n        );\\n\\n    modifier onlyOracleOperator {\\n        require(isCallbackAddress(msg.sender), \\\"MorpherOracle: Only the oracle operator can call this function.\\\");\\n        _;\\n    }\\n\\n    modifier notPaused {\\n        require(paused == false, \\\"MorpherOracle: Oracle paused, aborting\\\");\\n        _;\\n    }\\n\\n   constructor(address _tradeEngineAddress, address _callBackAddress, address payable _gasCollectionAddress, uint256 _gasForCallback, address _coldStorageOwnerAddress) public {\\n        setTradeEngineAddress(_tradeEngineAddress);\\n        enableCallbackAddress(_callBackAddress);\\n        setCallbackCollectionAddress(_gasCollectionAddress);\\n        setGasForCallback(_gasForCallback);\\n        transferOwnership(_coldStorageOwnerAddress);\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// Setter/getter functions for trade engine address, oracle operator (callback) address,\\n// and prepaid gas limit for callback function\\n// ----------------------------------------------------------------------------------\\n    function setTradeEngineAddress(address _address) public onlyOwner {\\n        tradeEngine = MorpherTradeEngine(_address);\\n        emit LinkTradeEngine(_address);\\n    }\\n\\n    function setGasForCallback(uint256 _gasForCallback) public onlyOwner {\\n        gasForCallback = _gasForCallback;\\n        emit SetGasForCallback(_gasForCallback);\\n    }\\n\\n    function enableCallbackAddress(address _address) public onlyOwner {\\n        callBackAddress[_address] = true;\\n        emit CallbackAddressEnabled(_address);\\n    }\\n\\n    function disableCallbackAddress(address _address) public onlyOwner {\\n        callBackAddress[_address] = false;\\n        emit CallbackAddressDisabled(_address);\\n    }\\n\\n    function isCallbackAddress(address _address) public view returns (bool _isCallBackAddress) {\\n        return callBackAddress[_address];\\n    }\\n\\n    function setCallbackCollectionAddress(address payable _address) public onlyOwner {\\n        callBackCollectionAddress = _address;\\n        emit CallBackCollectionAddressChange(_address);\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// emitOrderFailed\\n// Can be called by Oracle Operator to notifiy user of failed order\\n// ----------------------------------------------------------------------------------\\n    function emitOrderFailed(\\n        bytes32 _orderId,\\n        address _address,\\n        bytes32 _marketId,\\n        bool _tradeAmountGivenInShares,\\n        uint256 _tradeAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage\\n    ) public onlyOracleOperator {\\n        emit OrderFailed(\\n            _orderId,\\n            _address,\\n            _marketId,\\n            _tradeAmountGivenInShares,\\n            _tradeAmount,\\n            _tradeDirection,\\n            _orderLeverage);\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// createOrder(bytes32  _marketId, bool _tradeAmountGivenInShares, uint256 _tradeAmount, bool _tradeDirection, uint256 _orderLeverage)\\n// Request a new orderId from trade engine and fires event for price/liquidation check request.\\n// ----------------------------------------------------------------------------------\\n    function createOrder(\\n        bytes32 _marketId,\\n        bool _tradeAmountGivenInShares,\\n        uint256 _tradeAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage\\n        ) public payable notPaused returns (bytes32 _orderId) {\\n        if (gasForCallback \\u003e 0) {\\n            require(msg.value \\u003e= gasForCallback, \\\"MorpherOracle: Must transfer gas costs for Oracle Callback function.\\\");\\n            callBackCollectionAddress.transfer(msg.value);\\n        }\\n        _orderId = tradeEngine.requestOrderId(msg.sender, _marketId, _tradeAmountGivenInShares, _tradeAmount, _tradeDirection, _orderLeverage);\\n        emit OrderCreated(\\n            _orderId,\\n            msg.sender,\\n            _marketId,\\n            _tradeAmountGivenInShares,\\n            _tradeAmount,\\n            _tradeDirection,\\n            _orderLeverage\\n            );\\n        return _orderId;\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// cancelOrder(bytes32  _orderId)\\n// Users can cancel their own orders before the _callback has been executed\\n// ----------------------------------------------------------------------------------\\n    function cancelOrder(bytes32 _orderId) public {\\n        tradeEngine.cancelOrder(_orderId, msg.sender);\\n        emit OrderCancelled(\\n            _orderId,\\n            msg.sender\\n            );\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// Setter/getter functions for pausing the Oracle contract\\n// ----------------------------------------------------------------------------------\\n    function pauseOracle() public onlyOwner {\\n        paused = true;\\n        emit OraclePaused(true);\\n    }\\n\\n    function unpauseOracle() public onlyOwner {\\n        paused = false;\\n        emit OraclePaused(false);\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// createLiquidationOrder(address _address, bytes32 _marketId)\\n// Checks if position has been liquidated since last check. Requires gas for callback\\n// function. Anyone can issue a liquidation order for any other address and market.\\n// ----------------------------------------------------------------------------------\\n    function createLiquidationOrder(\\n        address _address,\\n        bytes32 _marketId\\n        ) public notPaused payable returns (bytes32 _orderId) {\\n        if (gasForCallback \\u003e 0) {\\n            require(msg.value \\u003e= gasForCallback, \\\"MorpherOracle: Must transfer gas costs for Oracle Callback function.\\\");\\n            callBackCollectionAddress.transfer(msg.value);\\n        }\\n        _orderId = tradeEngine.requestOrderId(_address, _marketId, true, 0, true, 10**8);\\n        emit LiquidationOrderCreated(_orderId, msg.sender, _address, _marketId);\\n        return _orderId;\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// __callback(bytes32 _orderId, uint256 _price, uint256 _spread, uint256 _liquidationTimestamp, uint256 _timeStamp)\\n// Called by the oracle operator. Writes price/spread/liquidiation check to the blockchain.\\n// Trade engine processes the order and updates the portfolio in state if successful.\\n// ----------------------------------------------------------------------------------\\n    function __callback(\\n        bytes32 _orderId,\\n        uint256 _price,\\n        uint256 _spread,\\n        uint256 _liquidationTimestamp,\\n        uint256 _timeStamp\\n        ) public onlyOracleOperator notPaused returns (uint256 _newLongShares, uint256 _newShortShares, uint256 _newMeanEntry, uint256 _newMeanSpread, uint256 _newMeanLeverage, uint256 _liquidationPrice)  {\\n        (\\n            _newLongShares,\\n            _newShortShares,\\n            _newMeanEntry,\\n            _newMeanSpread,\\n            _newMeanLeverage,\\n            _liquidationPrice\\n        ) = tradeEngine.processOrder(_orderId, _price, _spread, _liquidationTimestamp, _timeStamp);\\n        emit OrderProcessed(\\n            _orderId,\\n            _price,\\n            _spread,\\n            _liquidationTimestamp,\\n            _timeStamp,\\n            _newLongShares,\\n            _newShortShares,\\n            _newMeanEntry,\\n            _newMeanSpread,\\n            _newMeanLeverage,\\n            _liquidationPrice\\n            );\\n        return (_newLongShares, _newShortShares, _newMeanEntry, _newMeanSpread, _newMeanLeverage, _liquidationPrice);\\n    }\\n\\n// ----------------------------------------------------------------------------------\\n// Auxiliary function to hash a string market name i.e.\\n// \\\"CRYPTO_BTC\\\" =\\u003e 0x0bc89e95f9fdaab7e8a11719155f2fd638cb0f665623f3d12aab71d1a125daf9;\\n// ----------------------------------------------------------------------------------\\n    function stringToHash(string memory _source) public pure returns (bytes32 _result) {\\n        return keccak256(abi.encodePacked(_source));\\n    }\\n}\\n\"},\"MorpherState.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IMorpherToken.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Data and token balance storage of the Morpher platform\\n// Writing access is only granted to platform contracts. The contract can be paused\\n// by an elected platform administrator (see MorpherGovernance) to perform protocol updates.\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherState is Ownable {\\n    using SafeMath for uint256;\\n\\n    bool public mainChain;\\n    uint256 public totalSupply;\\n    uint256 public totalToken;\\n    uint256 public totalInPositions;\\n    uint256 public totalOnOtherChain;\\n    uint256 public maximumLeverage = 10**9; // Leverage precision is 1e8, maximum leverage set to 10 initially\\n    uint256 constant PRECISION = 10**8;\\n    uint256 constant DECIMALS = 18;\\n    uint256 constant REWARDPERIOD = 1 days;\\n    bool public paused = false;\\n\\n    address public morpherGovernance;\\n    address public morpherRewards;\\n    address public administrator;\\n    address public oracleContract;\\n    address public sideChainOperator;\\n    address public morpherBridge;\\n    address public morpherToken;\\n\\n    uint256 public rewardBasisPoints;\\n    uint256 public lastRewardTime;\\n\\n    bytes32 public sideChainMerkleRoot;\\n    uint256 public sideChainMerkleRootWrittenAtTime;\\n\\n    // Set initial withdraw limit from sidechain to 20m token or 2% of initial supply\\n    uint256 public mainChainWithdrawLimit24 = 2 * 10**25;\\n\\n    mapping(address =\\u003e bool) private stateAccess;\\n    mapping(address =\\u003e bool) private transferAllowed;\\n\\n    mapping(address =\\u003e uint256) private balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowed;\\n\\n    mapping(bytes32 =\\u003e bool) private marketActive;\\n\\n    // ----------------------------------------------------------------------------\\n    // Position struct records virtual futures\\n    // ----------------------------------------------------------------------------\\n    struct position {\\n        uint256 lastUpdated;\\n        uint256 longShares;\\n        uint256 shortShares;\\n        uint256 meanEntryPrice;\\n        uint256 meanEntrySpread;\\n        uint256 meanEntryLeverage;\\n        uint256 liquidationPrice;\\n        bytes32 positionHash;\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // A portfolio is an address specific collection of postions\\n    // ----------------------------------------------------------------------------\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e position)) private portfolio;\\n\\n    // ----------------------------------------------------------------------------\\n    // Record all addresses that hold a position of a market, needed for clean stock splits\\n    // ----------------------------------------------------------------------------\\n    struct hasExposure {\\n        uint256 maxMappingIndex;\\n        mapping(address =\\u003e uint256) index;\\n        mapping(uint256 =\\u003e address) addy;\\n    }\\n\\n    mapping(bytes32 =\\u003e hasExposure) private exposureByMarket;\\n\\n    // ----------------------------------------------------------------------------\\n    // Bridge Variables\\n    // ----------------------------------------------------------------------------\\n    mapping (address =\\u003e uint256) private tokenClaimedOnThisChain;\\n    mapping (address =\\u003e uint256) private tokenSentToLinkedChain;\\n    mapping (address =\\u003e uint256) private tokenSentToLinkedChainTime;\\n    mapping (bytes32 =\\u003e bool) private positionClaimedOnMainChain;\\n\\n    uint256 public lastWithdrawLimitReductionTime;\\n    uint256 public last24HoursAmountWithdrawn;\\n    uint256 public withdrawLimit24Hours;\\n    uint256 public inactivityPeriod = 3 days;\\n    uint256 public transferNonce;\\n    bool public fastTransfersEnabled;\\n\\n    // ----------------------------------------------------------------------------\\n    // Sidechain spam protection\\n    // ----------------------------------------------------------------------------\\n\\n    mapping(address =\\u003e uint256) private lastRequestBlock;\\n    mapping(address =\\u003e uint256) private numberOfRequests;\\n    uint256 public numberOfRequestsLimit;\\n\\n    // ----------------------------------------------------------------------------\\n    // Events\\n    // ----------------------------------------------------------------------------\\n    event StateAccessGranted(address indexed whiteList, uint256 indexed blockNumber);\\n    event StateAccessDenied(address indexed blackList, uint256 indexed blockNumber);\\n\\n    event TransfersEnabled(address indexed whiteList);\\n    event TransfersDisabled(address indexed blackList);\\n\\n    event Transfer(address indexed sender, address indexed recipient, uint256 amount);\\n    event Mint(address indexed recipient, uint256 amount, uint256 totalToken);\\n    event Burn(address indexed recipient, uint256 amount, uint256 totalToken);\\n    event NewTotalSupply(uint256 newTotalSupply);\\n    event NewTotalOnOtherChain(uint256 newTotalOnOtherChain);\\n    event NewTotalInPositions(uint256 newTotalOnOtherChain);\\n    event OperatingRewardMinted(address indexed recipient, uint256 amount);\\n\\n    event RewardsChange(address indexed rewardsAddress, uint256 indexed rewardsBasisPoints);\\n    event LastRewardTime(uint256 indexed rewardsTime);\\n    event GovernanceChange(address indexed governanceAddress);\\n    event TokenChange(address indexed tokenAddress);\\n    event AdministratorChange(address indexed administratorAddress);\\n    event OracleChange(address indexed oracleContract);\\n    event MaximumLeverageChange(uint256 maxLeverage);\\n    event MarketActivated(bytes32 indexed activateMarket);\\n    event MarketDeActivated(bytes32 indexed deActivateMarket);\\n    event BridgeChange(address _bridgeAddress);\\n    event SideChainMerkleRootUpdate(bytes32 indexed sideChainMerkleRoot);\\n    event NewSideChainOperator(address indexed sideChainOperator);\\n    event NumberOfRequestsLimitUpdate(uint256 _numberOfRequests);\\n\\n    event MainChainWithdrawLimitUpdate(uint256 indexed mainChainWithdrawLimit24);\\n    event TokenSentToLinkedChain(address _address, uint256 _token, uint256 _totalTokenSent, bytes32 indexed _tokenSentToLinkedChainHash);\\n    event TransferredTokenClaimed(address _address, uint256 _token);\\n    event LastWithdrawAt();\\n    event RollingWithdrawnAmountUpdated(uint256 _last24HoursAmountWithdrawn, uint256 _lastWithdrawLimitReductionTime);\\n    event WithdrawLimitUpdated(uint256 _amount);\\n    event InactivityPeriodUpdated(uint256 _periodLength);\\n    event FastWithdrawsDisabled();\\n    event NewBridgeNonce(uint256 _transferNonce);\\n    event Last24HoursAmountWithdrawnReset();\\n\\n    event StatePaused(address administrator, bool _paused);\\n\\n    event SetAllowance(address indexed sender, address indexed spender, uint256 tokens);\\n    event SetPosition(bytes32 indexed positionHash,\\n        address indexed sender,\\n        bytes32 indexed marketId,\\n        uint256 timeStamp,\\n        uint256 longShares,\\n        uint256 shortShares,\\n        uint256 meanEntryPrice,\\n        uint256 meanEntrySpread,\\n        uint256 meanEntryLeverage,\\n        uint256 liquidationPrice\\n    );\\n    event SetBalance(address indexed account, uint256 balance, bytes32 indexed balanceHash);\\n    event TokenTransferredToOtherChain(address indexed account, uint256 tokenTransferredToOtherChain, bytes32 indexed transferHash);\\n\\n    modifier notPaused {\\n        require(paused == false, \\\"MorpherState: Contract paused, aborting\\\");\\n        _;\\n    }\\n\\n    modifier onlyPlatform {\\n        require(stateAccess[msg.sender] == true, \\\"MorpherState: Only Platform is allowed to execute operation.\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernance {\\n        require(msg.sender == getGovernance(), \\\"MorpherState: Calling contract not the Governance Contract. Aborting.\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdministrator {\\n        require(msg.sender == getAdministrator(), \\\"MorpherState: Caller is not the Administrator. Aborting.\\\");\\n        _;\\n    }\\n\\n    modifier onlySideChainOperator {\\n        require(msg.sender == sideChainOperator, \\\"MorpherState: Caller is not the Sidechain Operator. Aborting.\\\");\\n        _;\\n    }\\n\\n    modifier canTransfer {\\n        require(getCanTransfer(msg.sender), \\\"MorpherState: Caller may not transfer token. Aborting.\\\");\\n        _;\\n    }\\n\\n    modifier onlyBridge {\\n        require(msg.sender == getMorpherBridge(), \\\"MorpherState: Caller is not the Bridge. Aborting.\\\");\\n        _;\\n    }\\n\\n    modifier onlyMainChain {\\n        require(mainChain == true, \\\"MorpherState: Can only be called on mainchain.\\\");\\n        _;\\n    }\\n\\n    modifier onlySideChain {\\n        require(mainChain == false, \\\"MorpherState: Can only be called on mainchain.\\\");\\n        _;\\n    }\\n\\n    constructor(bool _mainChain, address _sideChainOperator, address _morpherTreasury) public {\\n        // @Deployer: Transfer State Ownership to cold storage address after deploying protocol\\n        mainChain = _mainChain; // true for Ethereum, false for Morpher PoA sidechain\\n        setLastRewardTime(now);\\n        uint256 _sideChainMint = 575000000 * 10**(DECIMALS);\\n        uint256 _mainChainMint = 425000000 * 10**(DECIMALS);\\n        grantAccess(owner());\\n        setSideChainOperator(owner());\\n        if (mainChain == false) { // Create token only on sidechain\\n            balances[owner()] = _sideChainMint; // Create airdrop and team token on sidechain\\n            totalToken = _sideChainMint;\\n            emit Mint(owner(), balanceOf(owner()), _sideChainMint);\\n            setRewardBasisPoints(0); // Reward is minted on mainchain\\n            setRewardAddress(address(0));\\n            setTotalOnOtherChain(_mainChainMint);\\n        } else {\\n            balances[owner()] = _mainChainMint; // Create treasury and investor token on mainchain\\n            totalToken = _mainChainMint;\\n            emit Mint(owner(), balanceOf(owner()), _mainChainMint);\\n            setRewardBasisPoints(15000); // 15000 / PRECISION = 0.00015\\n            setRewardAddress(_morpherTreasury);\\n            setTotalOnOtherChain(_sideChainMint);\\n        }\\n        fastTransfersEnabled = true;\\n        setNumberOfRequestsLimit(3);\\n        setMainChainWithdrawLimit(totalSupply / 50);\\n        setSideChainOperator(_sideChainOperator);\\n        denyAccess(owner());\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for market wise exposure\\n    // ----------------------------------------------------------------------------\\n\\n    function getMaxMappingIndex(bytes32 _marketId) public view returns(uint256 _maxMappingIndex) {\\n        return exposureByMarket[_marketId].maxMappingIndex;\\n    }\\n\\n    function getExposureMappingIndex(bytes32 _marketId, address _address) public view returns(uint256 _mappingIndex) {\\n        return exposureByMarket[_marketId].index[_address];\\n    }\\n\\n    function getExposureMappingAddress(bytes32 _marketId, uint256 _mappingIndex) public view returns(address _address) {\\n        return exposureByMarket[_marketId].addy[_mappingIndex];\\n    }\\n\\n    function setMaxMappingIndex(bytes32 _marketId, uint256 _maxMappingIndex) public onlyPlatform {\\n        exposureByMarket[_marketId].maxMappingIndex = _maxMappingIndex;\\n    }\\n\\n    function setExposureMapping(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform  {\\n        setExposureMappingIndex(_marketId, _address, _index);\\n        setExposureMappingAddress(_marketId, _address, _index);\\n    }\\n\\n    function setExposureMappingIndex(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\\n        exposureByMarket[_marketId].index[_address] = _index;\\n    }\\n\\n    function setExposureMappingAddress(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\\n        exposureByMarket[_marketId].addy[_index] = _address;\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for bridge variables\\n    // ----------------------------------------------------------------------------\\n    function setTokenClaimedOnThisChain(address _address, uint256 _token) public onlyBridge {\\n        tokenClaimedOnThisChain[_address] = _token;\\n        emit TransferredTokenClaimed(_address, _token);\\n    }\\n\\n    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token) {\\n        return tokenClaimedOnThisChain[_address];\\n    }\\n\\n    function setTokenSentToLinkedChain(address _address, uint256 _token) public onlyBridge {\\n        tokenSentToLinkedChain[_address] = _token;\\n        tokenSentToLinkedChainTime[_address] = now;\\n        emit TokenSentToLinkedChain(_address, _token, tokenSentToLinkedChain[_address], getBalanceHash(_address, tokenSentToLinkedChain[_address]));\\n    }\\n\\n    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token) {\\n        return tokenSentToLinkedChain[_address];\\n    }\\n\\n    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _timeStamp) {\\n        return tokenSentToLinkedChainTime[_address];\\n    }\\n\\n    function add24HoursWithdrawn(uint256 _amount) public onlyBridge {\\n        last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.add(_amount);\\n        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\\n    }\\n\\n    function update24HoursWithdrawLimit(uint256 _amount) public onlyBridge {\\n        if (last24HoursAmountWithdrawn \\u003e _amount) {\\n            last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.sub(_amount);\\n        } else {\\n            last24HoursAmountWithdrawn = 0;\\n        }\\n        lastWithdrawLimitReductionTime = now;\\n        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\\n    }\\n\\n    function set24HourWithdrawLimit(uint256 _limit) public onlyBridge {\\n        withdrawLimit24Hours = _limit;\\n        emit WithdrawLimitUpdated(_limit);\\n    }\\n\\n    function resetLast24HoursAmountWithdrawn() public onlyBridge {\\n        last24HoursAmountWithdrawn = 0;\\n        emit Last24HoursAmountWithdrawnReset();\\n    }\\n\\n    function setInactivityPeriod(uint256 _periodLength) public onlyBridge {\\n        inactivityPeriod = _periodLength;\\n        emit InactivityPeriodUpdated(_periodLength);\\n    }\\n\\n    function getBridgeNonce() public onlyBridge returns (uint256 _nonce) {\\n        transferNonce++;\\n        emit NewBridgeNonce(transferNonce);\\n        return transferNonce;\\n    }\\n\\n    function disableFastWithdraws() public onlyBridge {\\n        fastTransfersEnabled = false;\\n        emit FastWithdrawsDisabled();\\n    }\\n\\n    function setPositionClaimedOnMainChain(bytes32 _positionHash) public onlyBridge {\\n        positionClaimedOnMainChain[_positionHash] = true;\\n    }\\n\\n    function getPositionClaimedOnMainChain(bytes32 _positionHash) public view returns (bool _alreadyClaimed) {\\n        return positionClaimedOnMainChain[_positionHash];\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for spam protection\\n    // ----------------------------------------------------------------------------\\n\\n    function setLastRequestBlock(address _address) public onlyPlatform {\\n        lastRequestBlock[_address] = block.number;\\n    }\\n\\n    function getLastRequestBlock(address _address) public view returns(uint256 _lastRequestBlock) {\\n        return lastRequestBlock[_address];\\n    }\\n\\n    function setNumberOfRequests(address _address, uint256 _numberOfRequests) public onlyPlatform {\\n        numberOfRequests[_address] = _numberOfRequests;\\n    }\\n\\n    function increaseNumberOfRequests(address _address) public onlyPlatform{\\n        numberOfRequests[_address]++;\\n    }\\n\\n    function getNumberOfRequests(address _address) public view returns(uint256 _numberOfRequests) {\\n        return numberOfRequests[_address];\\n    }\\n\\n    function setNumberOfRequestsLimit(uint256 _numberOfRequestsLimit) public onlyPlatform {\\n        numberOfRequestsLimit = _numberOfRequestsLimit;\\n        emit NumberOfRequestsLimitUpdate(_numberOfRequestsLimit);\\n    }\\n\\n    function getNumberOfRequestsLimit() public view returns (uint256 _numberOfRequestsLimit) {\\n        return numberOfRequestsLimit;\\n    }\\n\\n    function setMainChainWithdrawLimit(uint256 _mainChainWithdrawLimit24) public onlyOwner {\\n        mainChainWithdrawLimit24 = _mainChainWithdrawLimit24;\\n        emit MainChainWithdrawLimitUpdate(_mainChainWithdrawLimit24);\\n    }\\n\\n    function getMainChainWithdrawLimit() public view returns (uint256 _mainChainWithdrawLimit24) {\\n        return mainChainWithdrawLimit24;\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for state access\\n    // ----------------------------------------------------------------------------\\n\\n    function grantAccess(address _address) public onlyOwner {\\n        stateAccess[_address] = true;\\n        emit StateAccessGranted(_address, block.number);\\n    }\\n\\n    function denyAccess(address _address) public onlyOwner {\\n        stateAccess[_address] = false;\\n        emit StateAccessDenied(_address, block.number);\\n    }\\n\\n    function getStateAccess(address _address) public view returns(bool _hasAccess) {\\n        return stateAccess[_address];\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for addresses that can transfer tokens (sidechain only)\\n    // ----------------------------------------------------------------------------\\n\\n    function enableTransfers(address _address) public onlyOwner {\\n        transferAllowed[_address] = true;\\n        emit TransfersEnabled(_address);\\n    }\\n\\n    function disableTransfers(address _address) public onlyOwner {\\n        transferAllowed[_address] = false;\\n        emit TransfersDisabled(_address);\\n    }\\n\\n    function getCanTransfer(address _address) public view returns(bool _hasAccess) {\\n        return transferAllowed[_address];\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Minting/burning/transfer of token\\n    // ----------------------------------------------------------------------------\\n\\n    function transfer(address _from, address _to, uint256 _token) public onlyPlatform notPaused {\\n        require(balances[_from] \\u003e= _token, \\\"MorpherState: Not enough token.\\\");\\n        balances[_from] = balances[_from].sub(_token);\\n        balances[_to] = balances[_to].add(_token);\\n        IMorpherToken(morpherToken).emitTransfer(_from, _to, _token);\\n        emit Transfer(_from, _to, _token);\\n        emit SetBalance(_from, balances[_from], getBalanceHash(_from, balances[_from]));\\n        emit SetBalance(_to, balances[_to], getBalanceHash(_to, balances[_to]));\\n    }\\n\\n    function mint(address _address, uint256 _token) public onlyPlatform notPaused {\\n        balances[_address] = balances[_address].add(_token);\\n        totalToken = totalToken.add(_token);\\n        updateTotalSupply();\\n        IMorpherToken(morpherToken).emitTransfer(address(0), _address, _token);\\n        emit Mint(_address, _token, totalToken);\\n        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\\n    }\\n\\n    function burn(address _address, uint256 _token) public onlyPlatform notPaused {\\n        require(balances[_address] \\u003e= _token, \\\"MorpherState: Not enough token.\\\");\\n        balances[_address] = balances[_address].sub(_token);\\n        totalToken = totalToken.sub(_token);\\n        updateTotalSupply();\\n        IMorpherToken(morpherToken).emitTransfer(_address, address(0), _token);\\n        emit Burn(_address, _token, totalToken);\\n        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for balance and token functions (ERC20)\\n    // ----------------------------------------------------------------------------\\n    function updateTotalSupply() private {\\n        totalSupply = totalToken.add(totalInPositions).add(totalOnOtherChain);\\n        emit NewTotalSupply(totalSupply);\\n    }\\n\\n    function setTotalInPositions(uint256 _totalInPositions) public onlyAdministrator {\\n        totalInPositions = _totalInPositions;\\n        updateTotalSupply();\\n        emit NewTotalInPositions(_totalInPositions);\\n    }\\n\\n    function setTotalOnOtherChain(uint256 _newTotalOnOtherChain) public onlySideChainOperator {\\n        totalOnOtherChain = _newTotalOnOtherChain;\\n        updateTotalSupply();\\n        emit NewTotalOnOtherChain(_newTotalOnOtherChain);\\n    }\\n\\n    function balanceOf(address _tokenOwner) public view returns (uint256 balance) {\\n        return balances[_tokenOwner];\\n    }\\n\\n    function setAllowance(address _from, address _spender, uint256 _tokens) public onlyPlatform {\\n        allowed[_from][_spender] = _tokens;\\n        emit SetAllowance(_from, _spender, _tokens);\\n    }\\n\\n    function getAllowance(address _tokenOwner, address spender) public view returns (uint256 remaining) {\\n        return allowed[_tokenOwner][spender];\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for platform roles\\n    // ----------------------------------------------------------------------------\\n\\n    function setGovernanceContract(address _newGovernanceContractAddress) public onlyOwner {\\n        morpherGovernance = _newGovernanceContractAddress;\\n        emit GovernanceChange(_newGovernanceContractAddress);\\n    }\\n\\n    function getGovernance() public view returns (address _governanceContract) {\\n        return morpherGovernance;\\n    }\\n\\n    function setMorpherBridge(address _newBridge) public onlyOwner {\\n        morpherBridge = _newBridge;\\n        emit BridgeChange(_newBridge);\\n    }\\n\\n    function getMorpherBridge() public view returns (address _currentBridge) {\\n        return morpherBridge;\\n    }\\n\\n    function setOracleContract(address _newOracleContract) public onlyGovernance {\\n        oracleContract = _newOracleContract;\\n        emit OracleChange(_newOracleContract);\\n    }\\n\\n    function getOracleContract() public view returns(address) {\\n        return oracleContract;\\n    }\\n\\n    function setTokenContract(address _newTokenContract) public onlyOwner {\\n        morpherToken = _newTokenContract;\\n        emit TokenChange(_newTokenContract);\\n    }\\n\\n    function getTokenContract() public view returns(address) {\\n        return morpherToken;\\n    }\\n\\n    function setAdministrator(address _newAdministrator) public onlyGovernance {\\n        administrator = _newAdministrator;\\n        emit AdministratorChange(_newAdministrator);\\n    }\\n\\n    function getAdministrator() public view returns(address) {\\n        return administrator;\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for platform operating rewards\\n    // ----------------------------------------------------------------------------\\n\\n    function setRewardAddress(address _newRewardsAddress) public onlyOwner {\\n        morpherRewards = _newRewardsAddress;\\n        emit RewardsChange(_newRewardsAddress, rewardBasisPoints);\\n    }\\n\\n    function setRewardBasisPoints(uint256 _newRewardBasisPoints) public onlyOwner {\\n        if (mainChain == true) {\\n            require(_newRewardBasisPoints \\u003c= 15000, \\\"MorpherState: Reward basis points need to be less or equal to 15000.\\\");\\n        } else {\\n            require(_newRewardBasisPoints == 0, \\\"MorpherState: Reward basis points can only be set on Ethereum.\\\");\\n        }\\n        rewardBasisPoints = _newRewardBasisPoints;\\n        emit RewardsChange(morpherRewards, _newRewardBasisPoints);\\n    }\\n\\n    function setLastRewardTime(uint256 _lastRewardTime) private {\\n        lastRewardTime = _lastRewardTime;\\n        emit LastRewardTime(_lastRewardTime);\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for platform administration\\n    // ----------------------------------------------------------------------------\\n\\n    function activateMarket(bytes32 _activateMarket) public onlyAdministrator {\\n        marketActive[_activateMarket] = true;\\n        emit MarketActivated(_activateMarket);\\n    }\\n\\n    function deActivateMarket(bytes32 _deActivateMarket) public onlyAdministrator {\\n        marketActive[_deActivateMarket] = false;\\n        emit MarketDeActivated(_deActivateMarket);\\n    }\\n\\n    function getMarketActive(bytes32 _marketId) public view returns(bool _active) {\\n        return marketActive[_marketId];\\n    }\\n\\n    function setMaximumLeverage(uint256 _newMaximumLeverage) public onlyAdministrator {\\n        require(_newMaximumLeverage \\u003e PRECISION, \\\"MorpherState: Leverage precision is 1e8\\\");\\n        maximumLeverage = _newMaximumLeverage;\\n        emit MaximumLeverageChange(_newMaximumLeverage);\\n    }\\n\\n    function getMaximumLeverage() public view returns(uint256 _maxLeverage) {\\n        return maximumLeverage;\\n    }\\n\\n    function pauseState() public onlyAdministrator {\\n        paused = true;\\n        emit StatePaused(msg.sender, true);\\n    }\\n\\n    function unPauseState() public onlyAdministrator {\\n        paused = false;\\n        emit StatePaused(msg.sender, false);\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter for side chain state\\n    // ----------------------------------------------------------------------------\\n\\n    function setSideChainMerkleRoot(bytes32 _sideChainMerkleRoot) public onlyBridge {\\n        sideChainMerkleRoot = _sideChainMerkleRoot;\\n        sideChainMerkleRootWrittenAtTime = now;\\n        payOperatingReward;\\n        emit SideChainMerkleRootUpdate(_sideChainMerkleRoot);\\n    }\\n\\n    function getSideChainMerkleRoot() public view returns(bytes32 _sideChainMerkleRoot) {\\n        return sideChainMerkleRoot;\\n    }\\n\\n    function setSideChainOperator(address _address) public onlyOwner {\\n        sideChainOperator = _address;\\n        emit NewSideChainOperator(_address);\\n    }\\n\\n    function getSideChainOperator() public view returns (address _address) {\\n        return sideChainOperator;\\n    }\\n\\n    function getSideChainMerkleRootWrittenAtTime() public view returns(uint256 _sideChainMerkleRoot) {\\n        return sideChainMerkleRootWrittenAtTime;\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Setter/Getter functions for portfolio\\n    // ----------------------------------------------------------------------------\\n\\n    function setPosition(\\n        address _address,\\n        bytes32 _marketId,\\n        uint256 _timeStamp,\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n    ) public onlyPlatform {\\n        portfolio[_address][_marketId].lastUpdated = _timeStamp;\\n        portfolio[_address][_marketId].longShares = _longShares;\\n        portfolio[_address][_marketId].shortShares = _shortShares;\\n        portfolio[_address][_marketId].meanEntryPrice = _meanEntryPrice;\\n        portfolio[_address][_marketId].meanEntrySpread = _meanEntrySpread;\\n        portfolio[_address][_marketId].meanEntryLeverage = _meanEntryLeverage;\\n        portfolio[_address][_marketId].liquidationPrice = _liquidationPrice;\\n        portfolio[_address][_marketId].positionHash = getPositionHash(\\n            _address,\\n            _marketId,\\n            _timeStamp,\\n            _longShares,\\n            _shortShares,\\n            _meanEntryPrice,\\n            _meanEntrySpread,\\n            _meanEntryLeverage,\\n            _liquidationPrice\\n        );\\n        if (_longShares \\u003e 0 || _shortShares \\u003e 0) {\\n            addExposureByMarket(_marketId, _address);\\n        } else {\\n            deleteExposureByMarket(_marketId, _address);\\n        }\\n        emit SetPosition(\\n            portfolio[_address][_marketId].positionHash,\\n            _address,\\n            _marketId,\\n            _timeStamp,\\n            _longShares,\\n            _shortShares,\\n            _meanEntryPrice,\\n            _meanEntrySpread,\\n            _meanEntryLeverage,\\n            _liquidationPrice\\n        );\\n    }\\n\\n    function getPosition(\\n        address _address,\\n        bytes32 _marketId\\n    ) public view returns (\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n    ) {\\n        return(\\n        portfolio[_address][_marketId].longShares,\\n        portfolio[_address][_marketId].shortShares,\\n        portfolio[_address][_marketId].meanEntryPrice,\\n        portfolio[_address][_marketId].meanEntrySpread,\\n        portfolio[_address][_marketId].meanEntryLeverage,\\n        portfolio[_address][_marketId].liquidationPrice\\n        );\\n    }\\n\\n    function getPositionHash(\\n        address _address,\\n        bytes32 _marketId,\\n        uint256 _timeStamp,\\n        uint256 _longShares,\\n        uint256 _shortShares,\\n        uint256 _meanEntryPrice,\\n        uint256 _meanEntrySpread,\\n        uint256 _meanEntryLeverage,\\n        uint256 _liquidationPrice\\n    ) public pure returns (bytes32 _hash) {\\n        return keccak256(\\n            abi.encodePacked(\\n                _address,\\n                _marketId,\\n                _timeStamp,\\n                _longShares,\\n                _shortShares,\\n                _meanEntryPrice,\\n                _meanEntrySpread,\\n                _meanEntryLeverage,\\n                _liquidationPrice\\n            )\\n        );\\n    }\\n\\n    function getBalanceHash(address _address, uint256 _balance) public pure returns (bytes32 _hash) {\\n        return keccak256(abi.encodePacked(_address, _balance));\\n    }\\n\\n    function getLastUpdated(address _address, bytes32 _marketId) public view returns (uint256 _lastUpdated) {\\n        return(portfolio[_address][_marketId].lastUpdated);\\n    }\\n\\n    function getLongShares(address _address, bytes32 _marketId) public view returns (uint256 _longShares) {\\n        return(portfolio[_address][_marketId].longShares);\\n    }\\n\\n    function getShortShares(address _address, bytes32 _marketId) public view returns (uint256 _shortShares) {\\n        return(portfolio[_address][_marketId].shortShares);\\n    }\\n\\n    function getMeanEntryPrice(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryPrice) {\\n        return(portfolio[_address][_marketId].meanEntryPrice);\\n    }\\n\\n    function getMeanEntrySpread(address _address, bytes32 _marketId) public view returns (uint256 _meanEntrySpread) {\\n        return(portfolio[_address][_marketId].meanEntrySpread);\\n    }\\n\\n    function getMeanEntryLeverage(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryLeverage) {\\n        return(portfolio[_address][_marketId].meanEntryLeverage);\\n    }\\n\\n    function getLiquidationPrice(address _address, bytes32 _marketId) public view returns (uint256 _liquidationPrice) {\\n        return(portfolio[_address][_marketId].liquidationPrice);\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Record positions by market by address. Needed for exposure aggregations\\n    // and spits and dividends.\\n    // ----------------------------------------------------------------------------\\n    function addExposureByMarket(bytes32 _symbol, address _address) private {\\n        // Address must not be already recored\\n        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\\n        if (_myExposureIndex == 0) {\\n            uint256 _maxMappingIndex = getMaxMappingIndex(_symbol).add(1);\\n            setMaxMappingIndex(_symbol, _maxMappingIndex);\\n            setExposureMapping(_symbol, _address, _maxMappingIndex);\\n        }\\n    }\\n\\n    function deleteExposureByMarket(bytes32 _symbol, address _address) private {\\n        // Get my index in mapping\\n        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\\n        // Get last element of mapping\\n        uint256 _lastIndex = getMaxMappingIndex(_symbol);\\n        address _lastAddress = getExposureMappingAddress(_symbol, _lastIndex);\\n        // If _myExposureIndex is greater than 0 (i.e. there is an exposure of that address on that market) delete it\\n        if (_myExposureIndex \\u003e 0) {\\n            // If _myExposureIndex is less than _lastIndex overwrite element at _myExposureIndex with element at _lastIndex in\\n            // deleted elements position.\\n            if (_myExposureIndex \\u003c _lastIndex) {\\n                setExposureMappingAddress(_symbol, _lastAddress, _myExposureIndex);\\n                setExposureMappingIndex(_symbol, _lastAddress, _myExposureIndex);\\n            }\\n            // Delete _lastIndex and _lastAddress element and reduce maxExposureIndex\\n            setExposureMappingAddress(_symbol, address(0), _lastIndex);\\n            setExposureMappingIndex(_symbol, _address, 0);\\n            // Shouldn\\u0027t happen, but check that not empty\\n            if (_lastIndex \\u003e 0) {\\n                setMaxMappingIndex(_symbol, _lastIndex.sub(1));\\n            }\\n        }\\n    }\\n\\n    // ----------------------------------------------------------------------------\\n    // Calculate and send operating reward\\n    // Every 24 hours the protocol mints rewardBasisPoints/(PRECISION) percent of the total\\n    // supply as reward for the protocol operator. The amount can not exceed 0.015% per\\n    // day.\\n    // ----------------------------------------------------------------------------\\n\\n    function payOperatingReward() public onlyMainChain {\\n        if (now \\u003e lastRewardTime.add(REWARDPERIOD)) {\\n            uint256 _reward = totalSupply.mul(rewardBasisPoints).div(PRECISION);\\n            setLastRewardTime(lastRewardTime.add(REWARDPERIOD));\\n            mint(morpherRewards, _reward);\\n            emit OperatingRewardMinted(morpherRewards, _reward);\\n        }\\n    }\\n}\\n\"},\"MorpherToken.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./MorpherState.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract MorpherToken is IERC20, Ownable {\\n\\n    MorpherState state;\\n    using SafeMath for uint256;\\n\\n    string public constant name     = \\\"Morpher\\\";\\n    string public constant symbol   = \\\"MPH\\\";\\n    uint8  public constant decimals = 18;\\n    \\n    modifier onlyState {\\n        require(msg.sender == address(state), \\\"ERC20: caller must be MorpherState contract.\\\");\\n        _;\\n    }\\n\\n    modifier canTransfer {\\n        require(state.mainChain() == true || state.getCanTransfer(msg.sender), \\\"ERC20: token transfers disabled on sidechain.\\\");\\n        _;\\n    }\\n    \\n    event LinkState(address _address);\\n\\n    // ------------------------------------------------------------------------\\n    // Constructor\\n    // ------------------------------------------------------------------------\\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\\n        setMorpherState(_stateAddress);\\n        transferOwnership(_coldStorageOwnerAddress);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Links Token Contract with State\\n    // ------------------------------------------------------------------------\\n    function setMorpherState(address _stateAddress) public onlyOwner {\\n        state = MorpherState(_stateAddress);\\n        emit LinkState(_stateAddress);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return state.totalSupply();\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address _account) public view returns (uint256) {\\n        return state.balanceOf(_account);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     * \\n     * Emits a {Transfer} event via emitTransfer called by MorpherState\\n     */\\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\\n        _transfer(msg.sender, _recipient, _amount);\\n        return true;\\n    }\\n\\n   /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address _owner, address _spender) public view returns (uint256) {\\n        return state.getAllowance(_owner, _spender);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address _spender, uint256 _amount) public returns (bool) {\\n        _approve(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `_sender` and `_recipient` cannot be the zero address.\\n     * - `_sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `_sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address _sender, address _recipient, uint256 amount) public returns (bool) {\\n        _transfer(_sender, _recipient, amount);\\n        _approve(_sender, msg.sender, state.getAllowance(_sender, msg.sender).sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `_spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\\n        _approve(msg.sender, _spender, state.getAllowance(msg.sender, _spender).add(_addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\\n        _approve(msg.sender, _spender,  state.getAllowance(msg.sender, _spender).sub(_subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Caller destroys `_amount` tokens permanently\\n     *\\n     * Emits a {Transfer} event to zero address called by MorpherState via emitTransfer.\\n     *\\n     * Requirements:\\n     *\\n     * - Caller must have token balance of at least `_amount`\\n     * \\n     */\\n     function burn(uint256 _amount) public returns (bool) {\\n        state.burn(msg.sender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Emits a {Transfer} event\\n     *\\n     * MorpherState emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - Caller must be MorpherState\\n     * \\n     */\\n     function emitTransfer(address _from, address _to, uint256 _amount) public onlyState {\\n        emit Transfer(_from, _to, _amount);\\n    }\\n\\n     /**\\n     * @dev Moves tokens `_amount` from `sender` to `_recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event via emitTransfer called by MorpherState\\n     *\\n     * Requirements:\\n     *\\n     * - `_sender` cannot be the zero address.\\n     * - `_recipient` cannot be the zero address.\\n     * - `_sender` must have a balance of at least `_amount`.\\n     */\\n    function _transfer(address _sender, address _recipient, uint256 _amount) canTransfer internal {\\n        require(_sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(_recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(state.balanceOf(_sender) \\u003e= _amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        state.transfer(_sender, _recipient, _amount);\\n    }\\n\\n    /**\\n     * @dev Sets `_amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\\n        require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(_spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        state.setAllowance(_owner, _spender, _amount);\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Don\\u0027t accept ETH\\n    // ------------------------------------------------------------------------\\n    function () external payable {\\n        revert(\\\"ERC20: You can\\u0027t deposit Ether here\\\");\\n    }\\n}\\n\"},\"MorpherTradeEngine.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./MorpherState.sol\\\";\\n\\n// ----------------------------------------------------------------------------------\\n// Tradeengine of the Morpher platform\\n// Creates and processes orders, and computes the state change of portfolio.\\n// Needs writing/reading access to/from Morpher State. Order objects are stored locally,\\n// portfolios are stored in state.\\n// ----------------------------------------------------------------------------------\\n\\ncontract MorpherTradeEngine is Ownable {\\n    MorpherState state;\\n    using SafeMath for uint256;\\n\\n// ----------------------------------------------------------------------------\\n// Precision of prices and leverage\\n// ----------------------------------------------------------------------------\\n    uint256 constant PRECISION = 10**8;\\n    uint256 public orderNonce;\\n    bytes32 public lastOrderId;\\n\\n// ----------------------------------------------------------------------------\\n// Order struct contains all order specific varibles. Variables are completed\\n// during processing of trade. State changes are saved in the order struct as\\n// well, since local variables would lead to stack to deep errors *sigh*.\\n// ----------------------------------------------------------------------------\\n    struct order {\\n        address userId;\\n        bool tradeAmountGivenInShares;\\n        bytes32 marketId;\\n        uint256 tradeAmount;\\n        bool tradeDirection; // true = long, false = short\\n        uint256 liquidationTimestamp;\\n        uint256 marketPrice;\\n        uint256 marketSpread;\\n        uint256 orderLeverage;\\n        uint256 timeStamp;\\n        uint256 longSharesOrder;\\n        uint256 shortSharesOrder;\\n        uint256 balanceDown;\\n        uint256 balanceUp;\\n        uint256 newLongShares;\\n        uint256 newShortShares;\\n        uint256 newMeanEntryPrice;\\n        uint256 newMeanEntrySpread;\\n        uint256 newMeanEntryLeverage;\\n        uint256 newLiquidationPrice;\\n    }\\n\\n    mapping(bytes32 =\\u003e order) private orders;\\n\\n// ----------------------------------------------------------------------------\\n// Events\\n// Order created/processed events are fired by MorpherOracle.\\n// ----------------------------------------------------------------------------\\n\\n    event PositionLiquidated(\\n        address indexed _address,\\n        bytes32 indexed _marketId,\\n        bool _longPosition,\\n        uint256 _timeStamp,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread\\n    );\\n\\n    event OrderCancelled(\\n        bytes32 indexed _orderId,\\n        address indexed _address\\n    );\\n\\n    event OrderIdRequested(\\n        bytes32 _orderId,\\n        address indexed _address,\\n        bytes32 indexed _marketId,\\n        bool _tradeAmountGivenInShares,\\n        uint256 _tradeAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage\\n    );\\n\\n    event OrderProcessed(\\n        bytes32 _orderId,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread,\\n        uint256 _liquidationTimestamp,\\n        uint256 _timeStamp,\\n        uint256 _newLongShares,\\n        uint256 _newShortShares,\\n        uint256 _newAverageEntry,\\n        uint256 _newAverageSpread,\\n        uint256 _newAverageLeverage,\\n        uint256 _liquidationPrice\\n    );\\n\\n    event PositionUpdated(\\n        address _userId,\\n        bytes32 _marketId,\\n        uint256 _timeStamp,\\n        uint256 _newLongShares,\\n        uint256 _newShortShares,\\n        uint256 _newMeanEntryPrice,\\n        uint256 _newMeanEntrySpread,\\n        uint256 _newMeanEntryLeverage,\\n        uint256 _newLiquidationPrice,\\n        uint256 _mint,\\n        uint256 _burn\\n    );\\n\\n    event LinkState(address _address);\\n\\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\\n        setMorpherState(_stateAddress);\\n        transferOwnership(_coldStorageOwnerAddress);\\n    }\\n\\n    modifier onlyOracle {\\n        require(msg.sender == state.getOracleContract(), \\\"MorpherTradeEngine: function can only be called by Oracle Contract.\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdministrator {\\n        require(msg.sender == getAdministrator(), \\\"MorpherTradeEngine: function can only be called by the Administrator.\\\");\\n        _;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Administrative functions\\n// Set state address, get administrator address\\n// ----------------------------------------------------------------------------\\n\\n    function setMorpherState(address _stateAddress) public onlyOwner {\\n        state = MorpherState(_stateAddress);\\n        emit LinkState(_stateAddress);\\n    }\\n\\n    function getAdministrator() public view returns(address _administrator) {\\n        return state.getAdministrator();\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// requestOrderId(address _address, bytes32 _marketId, bool _tradeAmountGivenInShares, uint256 _tradeAmount, bool _tradeDirection, uint256 _orderLeverage)\\n// Creates a new order object with unique orderId and assigns order information.\\n// Must be called by MorpherOracle contract.\\n// ----------------------------------------------------------------------------\\n\\n    function requestOrderId(\\n        address _address,\\n        bytes32 _marketId,\\n        bool _tradeAmountGivenInShares,\\n        uint256 _tradeAmount,\\n        bool _tradeDirection,\\n        uint256 _orderLeverage\\n        ) public onlyOracle returns (bytes32 _orderId) {\\n        require(_orderLeverage \\u003e= PRECISION, \\\"MorpherTradeEngine: leverage too small. Leverage precision is 1e8\\\");\\n        require(_orderLeverage \\u003c= state.getMaximumLeverage(), \\\"MorpherTradeEngine: leverage exceeds maximum allowed leverage.\\\");\\n        require(state.getMarketActive(_marketId) == true, \\\"MorpherTradeEngine: market unknown or currently not enabled for trading.\\\");\\n        require(state.getNumberOfRequests(_address) \\u003c= state.getNumberOfRequestsLimit() ||\\n            state.getLastRequestBlock(_address) \\u003c block.number,\\n            \\\"MorpherTradeEngine: request exceeded maximum permitted requests per block.\\\"\\n        );\\n        state.setLastRequestBlock(_address);\\n        state.increaseNumberOfRequests(_address);\\n        orderNonce++;\\n        _orderId = keccak256(\\n            abi.encodePacked(\\n                _address,\\n                block.number,\\n                _marketId,\\n                _tradeAmountGivenInShares,\\n                _tradeAmount,\\n                _tradeDirection,\\n                _orderLeverage,\\n                orderNonce\\n                )\\n            );\\n        lastOrderId = _orderId;\\n        orders[_orderId].userId = _address;\\n        orders[_orderId].marketId = _marketId;\\n        orders[_orderId].tradeAmountGivenInShares = _tradeAmountGivenInShares;\\n        orders[_orderId].tradeAmount = _tradeAmount;\\n        orders[_orderId].tradeDirection = _tradeDirection;\\n        orders[_orderId].orderLeverage = _orderLeverage;\\n        emit OrderIdRequested(\\n            _orderId,\\n            _address,\\n            _marketId,\\n            _tradeAmountGivenInShares,\\n            _tradeAmount,\\n            _tradeDirection,\\n            _orderLeverage\\n        );\\n        return _orderId;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// Getter functions for orders, shares, and positions\\n// ----------------------------------------------------------------------------\\n\\n    function getOrder(bytes32 _orderId) public view returns (\\n        address _userId,\\n        bytes32 _marketId,\\n        uint256 _tradeAmount,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread,\\n        uint256 _orderLeverage\\n        ) {\\n        return(\\n            orders[_orderId].userId,\\n            orders[_orderId].marketId,\\n            orders[_orderId].tradeAmount,\\n            orders[_orderId].marketPrice,\\n            orders[_orderId].marketSpread,\\n            orders[_orderId].orderLeverage\\n            );\\n    }\\n\\n    function getOrderShares(bytes32 _orderId) public view returns (\\n        uint256 _longSharesOrder,\\n        uint256 _shortSharesOrder,\\n        uint256 _tradeAmount,\\n        bool _tradeDirection,\\n        uint256 _balanceUp,\\n        uint256 _balanceDown) {\\n        return(\\n            orders[_orderId].longSharesOrder,\\n            orders[_orderId].shortSharesOrder,\\n            orders[_orderId].tradeAmount,\\n            orders[_orderId].tradeDirection,\\n            orders[_orderId].balanceUp,\\n            orders[_orderId].balanceDown\\n        );\\n    }\\n\\n    function getPosition(address _address, bytes32 _marketId) public view returns (\\n        uint256 _positionLongShares,\\n        uint256 _positionShortShares,\\n        uint256 _positionAveragePrice,\\n        uint256 _positionAverageSpread,\\n        uint256 _positionAverageLeverage,\\n        uint256 _liquidationPrice\\n        ) {\\n        return(\\n            state.getLongShares(_address, _marketId),\\n            state.getShortShares(_address, _marketId),\\n            state.getMeanEntryPrice(_address,_marketId),\\n            state.getMeanEntrySpread(_address,_marketId),\\n            state.getMeanEntryLeverage(_address,_marketId),\\n            state.getLiquidationPrice(_address,_marketId)\\n        );\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// liquidate(bytes32 _orderId)\\n// Checks for bankruptcy of position between its last update and now\\n// Time check is necessary to avoid two consecutive / unorderded liquidations\\n// ----------------------------------------------------------------------------\\n\\n    function liquidate(bytes32 _orderId) private {\\n        address _address = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n        uint256 _liquidationTimestamp = orders[_orderId].liquidationTimestamp;\\n        if (_liquidationTimestamp \\u003e state.getLastUpdated(_address, _marketId)) {\\n            if (state.getLongShares(_address,_marketId) \\u003e 0) {\\n                state.setPosition(\\n                    _address,\\n                    _marketId,\\n                    orders[_orderId].timeStamp,\\n                    0,\\n                    state.getShortShares(_address, _marketId),\\n                    0,\\n                    0,\\n                    PRECISION,\\n                    0);\\n                emit PositionLiquidated(\\n                    _address,\\n                    _marketId,\\n                    true,\\n                    orders[_orderId].timeStamp,\\n                    orders[_orderId].marketPrice,\\n                    orders[_orderId].marketSpread\\n                );\\n            }\\n            if (state.getShortShares(_address,_marketId) \\u003e 0) {\\n                state.setPosition(\\n                    _address,\\n                    _marketId,\\n                    orders[_orderId].timeStamp,\\n                    state.getLongShares(_address, _marketId),\\n                    0,\\n                    0,\\n                    0,\\n                    PRECISION,\\n                    0\\n                );\\n                emit PositionLiquidated(\\n                    _address,\\n                    _marketId,\\n                    false,\\n                    orders[_orderId].timeStamp,\\n                    orders[_orderId].marketPrice,\\n                    orders[_orderId].marketSpread\\n                );\\n            }\\n        }\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// processOrder(bytes32 _orderId, uint256 _marketPrice, uint256 _marketSpread, uint256 _liquidationTimestamp, uint256 _timeStamp)\\n// ProcessOrder receives the price/spread/liqidation information from the Oracle and\\n// triggers the processing of the order. If successful, processOrder updates the portfolio state.\\n// Liquidation time check is necessary to avoid two consecutive / unorderded liquidations\\n// ----------------------------------------------------------------------------\\n\\n    function processOrder(\\n        bytes32 _orderId,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread,\\n        uint256 _liquidationTimestamp,\\n        uint256 _timeStamp\\n        ) public onlyOracle returns (\\n            uint256 _newLongShares,\\n            uint256 _newShortShares,\\n            uint256 _newAverageEntry,\\n            uint256 _newAverageSpread,\\n            uint256 _newAverageLeverage,\\n            uint256 _liquidationPrice\\n        ) {\\n        require(orders[_orderId].userId != address(0), \\\"MorpherTradeEngine: unable to process, order has been deleted.\\\");\\n        require(_marketPrice \\u003e 0, \\\"MorpherTradeEngine: market priced at zero. Buy order cannot be processed.\\\");\\n        require(_marketPrice \\u003e= _marketSpread, \\\"MorpherTradeEngine: market price lower then market spread. Order cannot be processed.\\\");\\n        address _address = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n        require(state.getMarketActive(_marketId) == true, \\\"MorpherTradeEngine: market unknown or currently not enabled for trading.\\\");\\n        orders[_orderId].marketPrice = _marketPrice;\\n        orders[_orderId].marketSpread = _marketSpread;\\n        orders[_orderId].timeStamp = _timeStamp;\\n        orders[_orderId].liquidationTimestamp = _liquidationTimestamp;\\n\\n        // Check if previous position on that market was liquidated\\n        if (_liquidationTimestamp \\u003e state.getLastUpdated(_address, _marketId)) {\\n            liquidate(_orderId);\\n        }\\n\\n\\t\\tif (orders[_orderId].tradeAmount \\u003e 0)  {\\n            if (orders[_orderId].tradeDirection) {\\n                processBuyOrder(_orderId);\\n            } else {\\n                processSellOrder(_orderId);\\n\\t\\t    }\\n\\t\\t}\\t\\n\\n        delete orders[_orderId];\\n        emit OrderProcessed(\\n            _orderId,\\n            _marketPrice,\\n            _marketSpread,\\n            _liquidationTimestamp,\\n            _timeStamp,\\n            _newLongShares,\\n            _newShortShares,\\n            _newAverageEntry,\\n            _newAverageSpread,\\n            _newAverageLeverage,\\n            _liquidationPrice\\n        );\\n        return (\\n            state.getLongShares(_address, _marketId),\\n            state.getShortShares(_address, _marketId),\\n            state.getMeanEntryPrice(_address,_marketId),\\n            state.getMeanEntrySpread(_address,_marketId),\\n            state.getMeanEntryLeverage(_address,_marketId),\\n            state.getLiquidationPrice(_address,_marketId)\\n        );\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// function cancelOrder(bytes32 _orderId, address _address)\\n// Users or Administrator can delete pending orders before the callback went through\\n// ----------------------------------------------------------------------------\\n    function cancelOrder(bytes32 _orderId, address _address) public onlyOracle {\\n        require(_address == orders[_orderId].userId || _address == getAdministrator(), \\\"MorpherTradeEngine: only Administrator or user can cancel an order.\\\");\\n        require(orders[_orderId].userId != address(0), \\\"MorpherTradeEngine: unable to process, order does not exist.\\\");\\n        delete orders[_orderId];\\n        emit OrderCancelled(_orderId, _address);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// shortShareValue / longShareValue compute the value of a virtual future\\n// given current price/spread/leverage of the market and mean price/spread/leverage\\n// at the beginning of the trade\\n// ----------------------------------------------------------------------------\\n    function shortShareValue(\\n        uint256 _positionAveragePrice,\\n        uint256 _positionAverageLeverage,\\n        uint256 _liquidationPrice,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread,\\n        uint256 _orderLeverage,\\n        bool _sell\\n        ) public pure returns (uint256 _shareValue) {\\n\\n        uint256 _averagePrice = _positionAveragePrice;\\n        uint256 _averageLeverage = _positionAverageLeverage;\\n\\n        if (_positionAverageLeverage \\u003c PRECISION) {\\n            // Leverage can never be less than 1. Fail safe for empty positions, i.e. undefined _positionAverageLeverage\\n            _averageLeverage = PRECISION;\\n        }\\n        if (_sell == false) {\\n            // New short position\\n            // It costs marketPrice + marketSpread to build up a new short position\\n            _averagePrice = _marketPrice;\\n\\t        // This is the average Leverage\\n\\t        _averageLeverage = _orderLeverage;\\n        }\\n        if (\\n            _liquidationPrice \\u003c= _marketPrice\\n            ) {\\n\\t        // Position is worthless\\n            _shareValue = 0;\\n        } else {\\n            // The regular share value is 2x the entry price minus the current price for short positions.\\n            _shareValue = _averagePrice.mul((PRECISION.add(_averageLeverage))).div(PRECISION);\\n            _shareValue = _shareValue.sub(_marketPrice.mul(_averageLeverage).div(PRECISION));\\n            if (_sell == true) {\\n                // We have to reduce the share value by the average spread (i.e. the average expense to build up the position)\\n                // and reduce the value further by the spread for selling.\\n                _shareValue = _shareValue.sub(_marketSpread.mul(_averageLeverage).div(PRECISION));\\n            } else {\\n                // If a new short position is built up each share costs value + spread\\n                _shareValue = _shareValue.add(_marketSpread.mul(_orderLeverage).div(PRECISION));\\n            }\\n        }\\n        return _shareValue;\\n    }\\n\\n    function longShareValue(\\n        uint256 _positionAveragePrice,\\n        uint256 _positionAverageLeverage,\\n        uint256 _liquidationPrice,\\n        uint256 _marketPrice,\\n        uint256 _marketSpread,\\n        uint256 _orderLeverage,\\n        bool _sell\\n        ) public pure returns (uint256 _shareValue) {\\n\\n        uint256 _averagePrice = _positionAveragePrice;\\n        uint256 _averageLeverage = _positionAverageLeverage;\\n\\n        if (_positionAverageLeverage \\u003c PRECISION) {\\n            // Leverage can never be less than 1. Fail safe for empty positions, i.e. undefined _positionAverageLeverage\\n            _averageLeverage = PRECISION;\\n        }\\n        if (_sell == false) {\\n            // New long position\\n            // It costs marketPrice + marketSpread to build up a new long position\\n            _averagePrice = _marketPrice;\\n\\t        // This is the average Leverage\\n\\t        _averageLeverage = _orderLeverage;\\n        }\\n        if (\\n            _marketPrice \\u003c= _liquidationPrice\\n            ) {\\n\\t        // Position is worthless\\n            _shareValue = 0;\\n        } else {\\n            _shareValue = _averagePrice.mul(_averageLeverage.sub(PRECISION)).div(PRECISION);\\n            // The regular share value is market price times leverage minus entry price times entry leverage minus one.\\n            _shareValue = (_marketPrice.mul(_averageLeverage).div(PRECISION)).sub(_shareValue);\\n            if (_sell == true) {\\n                // We sell a long and have to correct the shareValue with the averageSpread and the currentSpread for selling.\\n                _shareValue = _shareValue.sub(_marketSpread.mul(_averageLeverage).div(PRECISION));\\n            } else {\\n                // We buy a new long position and have to pay the spread\\n                _shareValue = _shareValue.add(_marketSpread.mul(_orderLeverage).div(PRECISION));\\n            }\\n        }\\n        return _shareValue;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// processBuyOrder(bytes32 _orderId)\\n// Converts orders specified in virtual shares to orders specified in Morpher token\\n// and computes the number of short shares that are sold and long shares that are bought.\\n// long shares are bought only if the order amount exceeds all open short positions\\n// ----------------------------------------------------------------------------\\n\\n    function processBuyOrder(bytes32 _orderId) private {\\n        if (orders[_orderId].tradeAmountGivenInShares == false) {\\n            // Investment was specified in units of MPH\\n            if (orders[_orderId].tradeAmount \\u003c= state.getShortShares(\\n                        orders[_orderId].userId,\\n                        orders[_orderId].marketId\\n                    ).mul(\\n                        shortShareValue(\\n                            state.getMeanEntryPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                            state.getMeanEntryLeverage(orders[_orderId].userId, orders[_orderId].marketId),\\n                            state.getLiquidationPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                            orders[_orderId].marketPrice,\\n                            orders[_orderId].marketSpread,\\n                            PRECISION,\\n                            true\\n                    ))\\n                ) {\\n                // Partial closing of short position\\n                orders[_orderId].longSharesOrder = 0;\\n                orders[_orderId].shortSharesOrder = orders[_orderId].tradeAmount.div(shortShareValue(\\n                    state.getMeanEntryPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                    state.getMeanEntryLeverage(orders[_orderId].userId, orders[_orderId].marketId),\\n                    state.getLiquidationPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                    orders[_orderId].marketPrice,\\n                    orders[_orderId].marketSpread,\\n                    PRECISION,\\n                    true\\n                ));\\n            } else {\\n                // Closing of entire short position\\n                orders[_orderId].shortSharesOrder = state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId);\\n                orders[_orderId].longSharesOrder = orders[_orderId].tradeAmount.sub((\\n                    state.getShortShares(\\n                        orders[_orderId].userId,\\n                        orders[_orderId].marketId\\n                    ).mul(\\n                        shortShareValue(\\n                        state.getMeanEntryPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                        state.getMeanEntryLeverage(orders[_orderId].userId, orders[_orderId].marketId),\\n                        state.getLiquidationPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                        orders[_orderId].marketPrice,\\n                        orders[_orderId].marketSpread,\\n                        PRECISION,\\n                        true\\n                    ))\\n                ));\\n                orders[_orderId].longSharesOrder = orders[_orderId].longSharesOrder.div(\\n                    longShareValue(\\n                        orders[_orderId].marketPrice,\\n                        orders[_orderId].orderLeverage,\\n                        0,\\n                        orders[_orderId].marketPrice,\\n                        orders[_orderId].marketSpread,\\n                        orders[_orderId].orderLeverage,\\n                        false\\n                ));\\n            }\\n        } else {\\n            // Investment was specified in shares\\n            if (orders[_orderId].tradeAmount \\u003c= state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId)) {\\n                // Partial closing of short position\\n                orders[_orderId].longSharesOrder = 0;\\n                orders[_orderId].shortSharesOrder = orders[_orderId].tradeAmount;\\n            } else {\\n                // Closing of entire short position\\n                orders[_orderId].shortSharesOrder = state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId);\\n                orders[_orderId].longSharesOrder = orders[_orderId].tradeAmount.sub(\\n                    state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId)\\n                );\\n            }\\n        }\\n        // Investment equals number of shares now.\\n        if (orders[_orderId].shortSharesOrder \\u003e 0) {\\n            closeShort(_orderId);\\n        }\\n        if (orders[_orderId].longSharesOrder \\u003e 0) {\\n            openLong(_orderId);\\n        }\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// processSellOrder(bytes32 _orderId)\\n// Converts orders specified in virtual shares to orders specified in Morpher token\\n// and computes the number of long shares that are sold and short shares that are bought.\\n// short shares are bought only if the order amount exceeds all open long positions\\n// ----------------------------------------------------------------------------\\n\\n    function processSellOrder(bytes32 _orderId) private {\\n        if (orders[_orderId].tradeAmountGivenInShares == false) {\\n            // Investment was specified in units of MPH\\n            if (orders[_orderId].tradeAmount \\u003c= state.getLongShares(\\n                    orders[_orderId].userId,\\n                    orders[_orderId].marketId\\n                ).mul(\\n                    longShareValue(\\n                        state.getMeanEntryPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                        state.getMeanEntryLeverage(orders[_orderId].userId, orders[_orderId].marketId),\\n                        state.getLiquidationPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                        orders[_orderId].marketPrice,\\n                        orders[_orderId].marketSpread,\\n                        PRECISION,\\n                        true\\n                        ))) {\\n                // Partial closing of long position\\n                orders[_orderId].shortSharesOrder = 0;\\n                orders[_orderId].longSharesOrder = orders[_orderId].tradeAmount.div(\\n                    longShareValue(\\n                        state.getMeanEntryPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                        state.getMeanEntryLeverage(orders[_orderId].userId, orders[_orderId].marketId),\\n                        state.getLiquidationPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                        orders[_orderId].marketPrice,\\n                        orders[_orderId].marketSpread,\\n                        PRECISION,\\n                        true\\n                ));\\n            } else {\\n                // Closing of entire long position\\n                orders[_orderId].longSharesOrder = state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId);\\n                orders[_orderId].shortSharesOrder = orders[_orderId].tradeAmount.sub((\\n                    state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId\\n                ).mul(\\n                    longShareValue(\\n                        state.getMeanEntryPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                        state.getMeanEntryLeverage(orders[_orderId].userId,\\n                        orders[_orderId].marketId),\\n                        state.getLiquidationPrice(orders[_orderId].userId, orders[_orderId].marketId),\\n                        orders[_orderId].marketPrice,\\n                        orders[_orderId].marketSpread,\\n                        PRECISION,\\n                        true\\n                    ))\\n                ));\\n                orders[_orderId].shortSharesOrder = orders[_orderId].shortSharesOrder.div(\\n                    shortShareValue(\\n                        orders[_orderId].marketPrice,\\n                        orders[_orderId].orderLeverage,\\n                        orders[_orderId].marketPrice.mul(100),\\n                        orders[_orderId].marketPrice,\\n                        orders[_orderId].marketSpread,\\n                        orders[_orderId].orderLeverage,\\n                        false\\n                ));\\n            }\\n        } else {\\n            // Investment was specified in shares\\n            if (orders[_orderId].tradeAmount \\u003c= state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId)) {\\n                // Partial closing of long position\\n                orders[_orderId].shortSharesOrder = 0;\\n                orders[_orderId].longSharesOrder = orders[_orderId].tradeAmount;\\n            } else {\\n                // Closing of entire long position\\n                orders[_orderId].longSharesOrder = state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId);\\n                orders[_orderId].shortSharesOrder = orders[_orderId].tradeAmount.sub(\\n                    state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId)\\n                );\\n            }\\n        }\\n        // Investment equals number of shares now.\\n        if (orders[_orderId].longSharesOrder \\u003e 0) {\\n            closeLong(_orderId);\\n        }\\n        if (orders[_orderId].shortSharesOrder \\u003e 0) {\\n            openShort(_orderId);\\n        }\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// openLong(bytes32 _orderId)\\n// Opens a new long position and computes the new resulting average entry price/spread/leverage.\\n// Computation is broken down to several instructions for readability.\\n// ----------------------------------------------------------------------------\\n    function openLong(bytes32 _orderId) private {\\n        address _userId = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n\\n        uint256 _newMeanSpread;\\n        uint256 _newMeanLeverage;\\n\\n        // Existing position is virtually liquidated and reopened with current marketPrice\\n        // orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\\n        // _factorLongShares is a factor to adjust the existing longShares via virtual liqudiation and reopening at current market price\\n\\n        uint256 _factorLongShares = state.getMeanEntryLeverage(_userId, _marketId);\\n        if (_factorLongShares \\u003c PRECISION) {\\n            _factorLongShares = PRECISION;\\n        }\\n        _factorLongShares = _factorLongShares.sub(PRECISION);\\n        _factorLongShares = _factorLongShares.mul(state.getMeanEntryPrice(_userId, _marketId)).div(orders[_orderId].marketPrice);\\n        if (state.getMeanEntryLeverage(_userId, _marketId) \\u003e _factorLongShares) {\\n            _factorLongShares = state.getMeanEntryLeverage(_userId, _marketId).sub(_factorLongShares);\\n        } else {\\n            _factorLongShares = 0;\\n        }\\n\\n        uint256 _adjustedLongShares = _factorLongShares.mul(state.getLongShares(_userId, _marketId)).div(PRECISION);\\n\\n        // _newMeanLeverage is the weighted leverage of the existing position and the new position\\n        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId).mul(_adjustedLongShares);\\n        _newMeanLeverage = _newMeanLeverage.add(orders[_orderId].orderLeverage.mul(orders[_orderId].longSharesOrder));\\n        _newMeanLeverage = _newMeanLeverage.div(_adjustedLongShares.add(orders[_orderId].longSharesOrder));\\n\\n        // _newMeanSpread is the weighted spread of the existing position and the new position\\n        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId).mul(state.getLongShares(_userId, _marketId));\\n        _newMeanSpread = _newMeanSpread.add(orders[_orderId].marketSpread.mul(orders[_orderId].longSharesOrder));\\n        _newMeanSpread = _newMeanSpread.div(_adjustedLongShares.add(orders[_orderId].longSharesOrder));\\n\\n        orders[_orderId].balanceDown = orders[_orderId].longSharesOrder.mul(orders[_orderId].marketPrice).add(\\n            orders[_orderId].longSharesOrder.mul(orders[_orderId].marketSpread).mul(orders[_orderId].orderLeverage).div(PRECISION)\\n        );\\n        orders[_orderId].balanceUp = 0;\\n        orders[_orderId].newLongShares = _adjustedLongShares.add(orders[_orderId].longSharesOrder);\\n        orders[_orderId].newShortShares = state.getShortShares(_userId, _marketId);\\n        orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\\n\\n        setPositionInState(_orderId);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// closeLong(bytes32 _orderId)\\n// Closes an existing long position. Average entry price/spread/leverage do not change.\\n// ----------------------------------------------------------------------------\\n     function closeLong(bytes32 _orderId) private {\\n        address _userId = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n\\n        uint256 _newLongShares  = state.getLongShares(_userId, _marketId).sub(orders[_orderId].longSharesOrder);\\n        uint256 _balanceUp = orders[_orderId].longSharesOrder.mul(longShareValue(\\n            state.getMeanEntryPrice(_userId, _marketId),\\n            state.getMeanEntryLeverage(_userId, _marketId),\\n            state.getLiquidationPrice(_userId, _marketId),\\n            orders[_orderId].marketPrice, orders[_orderId].marketSpread,\\n            state.getMeanEntryLeverage(_userId, _marketId),\\n            true\\n        ));\\n\\n        uint256 _newMeanEntry;\\n        uint256 _newMeanSpread;\\n        uint256 _newMeanLeverage;\\n\\n        if (orders[_orderId].longSharesOrder == state.getLongShares(_userId, _marketId)) {\\n            _newMeanEntry = 0;\\n            _newMeanSpread = 0;\\n            _newMeanLeverage = PRECISION;\\n        } else {\\n            _newMeanEntry = state.getMeanEntryPrice(_userId, _marketId);\\n\\t        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId);\\n\\t        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId);\\n        }\\n\\n        orders[_orderId].balanceDown = 0;\\n        orders[_orderId].balanceUp = _balanceUp;\\n        orders[_orderId].newLongShares = _newLongShares;\\n        orders[_orderId].newShortShares = state.getShortShares(_userId, _marketId);\\n        orders[_orderId].newMeanEntryPrice = _newMeanEntry;\\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\\n\\n        setPositionInState(_orderId);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// closeShort(bytes32 _orderId)\\n// Closes an existing short position. Average entry price/spread/leverage do not change.\\n// ----------------------------------------------------------------------------\\n\\n    function closeShort(bytes32 _orderId) private {\\n        address _userId = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n\\n        uint256 _newMeanEntry;\\n        uint256 _newMeanSpread;\\n        uint256 _newMeanLeverage;\\n\\n        uint256 _newShortShares = state.getShortShares(_userId, _marketId).sub(orders[_orderId].shortSharesOrder);\\n        uint256 _balanceUp = orders[_orderId].shortSharesOrder.mul(\\n            shortShareValue(\\n                state.getMeanEntryPrice(_userId, _marketId),\\n                state.getMeanEntryLeverage(_userId, _marketId),\\n                state.getLiquidationPrice(_userId, _marketId),\\n                orders[_orderId].marketPrice,\\n                orders[_orderId].marketSpread,\\n                state.getMeanEntryLeverage(_userId, _marketId),\\n                true\\n        ));\\n\\n        if (orders[_orderId].shortSharesOrder == state.getShortShares(_userId, _marketId)) {\\n            _newMeanEntry = 0;\\n            _newMeanSpread = 0;\\n\\t        _newMeanLeverage = PRECISION;\\n        } else {\\n            _newMeanEntry = state.getMeanEntryPrice(_userId, _marketId);\\n\\t        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId);\\n\\t        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId);\\n        }\\n\\n        orders[_orderId].balanceDown = 0;\\n        orders[_orderId].balanceUp = _balanceUp;\\n        orders[_orderId].newLongShares = state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId);\\n        orders[_orderId].newShortShares = _newShortShares;\\n        orders[_orderId].newMeanEntryPrice = _newMeanEntry;\\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\\n\\n        setPositionInState(_orderId);\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// openShort(bytes32 _orderId)\\n// Opens a new short position and computes the new resulting average entry price/spread/leverage.\\n// Computation is broken down to several instructions for readability.\\n// ----------------------------------------------------------------------------\\n    function openShort(bytes32 _orderId) private {\\n        address _userId = orders[_orderId].userId;\\n        bytes32 _marketId = orders[_orderId].marketId;\\n\\n        uint256 _newMeanSpread;\\n        uint256 _newMeanLeverage;\\n        //\\n        // Existing position is virtually liquidated and reopened with current marketPrice\\n        // orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\\n        // _factorShortShares is a factor to adjust the existing shortShares via virtual liqudiation and reopening at current market price\\n\\n        uint256 _factorShortShares = state.getMeanEntryLeverage(_userId, _marketId);\\n        if (_factorShortShares \\u003c PRECISION) {\\n            _factorShortShares = PRECISION;\\n        }\\n        _factorShortShares = _factorShortShares.add(PRECISION);\\n        _factorShortShares = _factorShortShares.mul(state.getMeanEntryPrice(_userId, _marketId)).div(orders[_orderId].marketPrice);\\n        if (state.getMeanEntryLeverage(_userId, _marketId) \\u003c _factorShortShares) {\\n            _factorShortShares = _factorShortShares.sub(state.getMeanEntryLeverage(_userId, _marketId));\\n        } else {\\n            _factorShortShares = 0;\\n        }\\n\\n        uint256 _adjustedShortShares = _factorShortShares.mul(state.getShortShares(_userId, _marketId)).div(PRECISION);\\n\\n        // _newMeanLeverage is the weighted leverage of the existing position and the new position\\n        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId).mul(_adjustedShortShares);\\n        _newMeanLeverage = _newMeanLeverage.add(orders[_orderId].orderLeverage.mul(orders[_orderId].shortSharesOrder));\\n        _newMeanLeverage = _newMeanLeverage.div(_adjustedShortShares.add(orders[_orderId].shortSharesOrder));\\n\\n        // _newMeanSpread is the weighted spread of the existing position and the new position\\n        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId).mul(state.getShortShares(_userId, _marketId));\\n        _newMeanSpread = _newMeanSpread.add(orders[_orderId].marketSpread.mul(orders[_orderId].shortSharesOrder));\\n        _newMeanSpread = _newMeanSpread.div(_adjustedShortShares.add(orders[_orderId].shortSharesOrder));\\n\\n        orders[_orderId].balanceDown = orders[_orderId].shortSharesOrder.mul(orders[_orderId].marketPrice).add(\\n            orders[_orderId].shortSharesOrder.mul(orders[_orderId].marketSpread).mul(orders[_orderId].orderLeverage).div(PRECISION)\\n        );\\n        orders[_orderId].balanceUp = 0;\\n        orders[_orderId].newLongShares = state.getLongShares(_userId, _marketId);\\n        orders[_orderId].newShortShares = _adjustedShortShares.add(orders[_orderId].shortSharesOrder);\\n        orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\\n        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\\n        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\\n\\n        setPositionInState(_orderId);\\n    }\\n\\n    function computeLiquidationPrice(bytes32 _orderId) public returns(uint256 _liquidationPrice) {\\n        orders[_orderId].newLiquidationPrice = 0;\\n        if (orders[_orderId].newLongShares \\u003e 0) {\\n            orders[_orderId].newLiquidationPrice = getLiquidationPrice(orders[_orderId].newMeanEntryPrice, orders[_orderId].newMeanEntryLeverage, true);\\n        }\\n        if (orders[_orderId].newShortShares \\u003e 0) {\\n            orders[_orderId].newLiquidationPrice = getLiquidationPrice(orders[_orderId].newMeanEntryPrice, orders[_orderId].newMeanEntryLeverage, false);\\n        }\\n        return orders[_orderId].newLiquidationPrice;\\n    }\\n\\n    function getLiquidationPrice(uint256 _newMeanEntryPrice, uint256 _newMeanEntryLeverage, bool _long) public pure returns (uint256 _liquidiationPrice) {\\n        if (_long == true) {\\n            _liquidiationPrice = _newMeanEntryPrice.mul(_newMeanEntryLeverage.sub(PRECISION)).div(_newMeanEntryLeverage);\\n        } else {\\n            _liquidiationPrice = _newMeanEntryPrice.mul(_newMeanEntryLeverage.add(PRECISION)).div(_newMeanEntryLeverage);\\n        }\\n        return _liquidiationPrice;\\n    }\\n\\n// ----------------------------------------------------------------------------\\n// setPositionInState(bytes32 _orderId)\\n// Updates the portfolio in Morpher State. Called by closeLong/closeShort/openLong/openShort\\n// ----------------------------------------------------------------------------\\n    function setPositionInState(bytes32 _orderId) private {\\n        require(state.balanceOf(orders[_orderId].userId).add(orders[_orderId].balanceUp) \\u003e= orders[_orderId].balanceDown, \\\"MorpherTradeEngine: insufficient funds.\\\");\\n        computeLiquidationPrice(_orderId);\\n        // Net balanceUp and balanceDown\\n        if (orders[_orderId].balanceUp \\u003e orders[_orderId].balanceDown) {\\n            orders[_orderId].balanceUp.sub(orders[_orderId].balanceDown);\\n            orders[_orderId].balanceDown = 0;\\n        } else {\\n            orders[_orderId].balanceDown.sub(orders[_orderId].balanceUp);\\n            orders[_orderId].balanceUp = 0;\\n        }\\n        if (orders[_orderId].balanceUp \\u003e 0) {\\n            state.mint(orders[_orderId].userId, orders[_orderId].balanceUp);\\n        }\\n        if (orders[_orderId].balanceDown \\u003e 0) {\\n            state.burn(orders[_orderId].userId, orders[_orderId].balanceDown);\\n        }\\n        state.setPosition(\\n            orders[_orderId].userId,\\n            orders[_orderId].marketId,\\n            orders[_orderId].timeStamp,\\n            orders[_orderId].newLongShares,\\n            orders[_orderId].newShortShares,\\n            orders[_orderId].newMeanEntryPrice,\\n            orders[_orderId].newMeanEntrySpread,\\n            orders[_orderId].newMeanEntryLeverage,\\n            orders[_orderId].newLiquidationPrice\\n        );\\n        emit PositionUpdated(\\n            orders[_orderId].userId,\\n            orders[_orderId].marketId,\\n            orders[_orderId].timeStamp,\\n            orders[_orderId].newLongShares,\\n            orders[_orderId].newShortShares,\\n            orders[_orderId].newMeanEntryPrice,\\n            orders[_orderId].newMeanEntrySpread,\\n            orders[_orderId].newMeanEntryLeverage,\\n            orders[_orderId].newLiquidationPrice,\\n            orders[_orderId].balanceUp,\\n            orders[_orderId].balanceDown\\n        );\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address public _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller should be owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     * @notice Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: use renounce ownership instead.\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    // ------------------------------------------------------------------------\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\n    // ------------------------------------------------------------------------\\n    function transferAnyERC20Token(address _tokenAddress, uint256 _tokens) public onlyOwner returns (bool _success) {\\n        return IERC20(_tokenAddress).transfer(owner(), _tokens);\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.5.16;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_mainChain\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_sideChainOperator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_morpherTreasury\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"administratorAddress\",\"type\":\"address\"}],\"name\":\"AdministratorChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_bridgeAddress\",\"type\":\"address\"}],\"name\":\"BridgeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FastWithdrawsDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"governanceAddress\",\"type\":\"address\"}],\"name\":\"GovernanceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_periodLength\",\"type\":\"uint256\"}],\"name\":\"InactivityPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Last24HoursAmountWithdrawnReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardsTime\",\"type\":\"uint256\"}],\"name\":\"LastRewardTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LastWithdrawAt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"mainChainWithdrawLimit24\",\"type\":\"uint256\"}],\"name\":\"MainChainWithdrawLimitUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"activateMarket\",\"type\":\"bytes32\"}],\"name\":\"MarketActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"deActivateMarket\",\"type\":\"bytes32\"}],\"name\":\"MarketDeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"name\":\"MaximumLeverageChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_transferNonce\",\"type\":\"uint256\"}],\"name\":\"NewBridgeNonce\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sideChainOperator\",\"type\":\"address\"}],\"name\":\"NewSideChainOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalOnOtherChain\",\"type\":\"uint256\"}],\"name\":\"NewTotalInPositions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalOnOtherChain\",\"type\":\"uint256\"}],\"name\":\"NewTotalOnOtherChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalSupply\",\"type\":\"uint256\"}],\"name\":\"NewTotalSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_numberOfRequests\",\"type\":\"uint256\"}],\"name\":\"NumberOfRequestsLimitUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OperatingRewardMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleContract\",\"type\":\"address\"}],\"name\":\"OracleChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardsAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardsBasisPoints\",\"type\":\"uint256\"}],\"name\":\"RewardsChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_last24HoursAmountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lastWithdrawLimitReductionTime\",\"type\":\"uint256\"}],\"name\":\"RollingWithdrawnAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"SetAllowance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"balanceHash\",\"type\":\"bytes32\"}],\"name\":\"SetBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"positionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"longShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shortShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"meanEntryPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"meanEntrySpread\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"meanEntryLeverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidationPrice\",\"type\":\"uint256\"}],\"name\":\"SetPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sideChainMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"SideChainMerkleRootUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blackList\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"StateAccessDenied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whiteList\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"StateAccessGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"StatePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalTokenSent\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_tokenSentToLinkedChainHash\",\"type\":\"bytes32\"}],\"name\":\"TokenSentToLinkedChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenTransferredToOtherChain\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transferHash\",\"type\":\"bytes32\"}],\"name\":\"TokenTransferredToOtherChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"TransferredTokenClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blackList\",\"type\":\"address\"}],\"name\":\"TransfersDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whiteList\",\"type\":\"address\"}],\"name\":\"TransfersEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawLimitUpdated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_activateMarket\",\"type\":\"bytes32\"}],\"name\":\"activateMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"add24HoursWithdrawn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"administrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_deActivateMarket\",\"type\":\"bytes32\"}],\"name\":\"deActivateMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"denyAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableFastWithdraws\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"enableTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fastTransfersEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdministrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"getAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"getBalanceHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getBridgeNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getCanTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_hasAccess\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_mappingIndex\",\"type\":\"uint256\"}],\"name\":\"getExposureMappingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getExposureMappingIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_mappingIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_governanceContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLastRequestBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_lastRequestBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"getLastUpdated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_lastUpdated\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"getLiquidationPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidationPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"getLongShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_longShares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMainChainWithdrawLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_mainChainWithdrawLimit24\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"getMarketActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"getMaxMappingIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxMappingIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaximumLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxLeverage\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"getMeanEntryLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_meanEntryLeverage\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"getMeanEntryPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_meanEntryPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"getMeanEntrySpread\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_meanEntrySpread\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMorpherBridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_currentBridge\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getNumberOfRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfRequests\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfRequestsLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfRequestsLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"getPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_longShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shortShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_meanEntryPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_meanEntrySpread\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_meanEntryLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_positionHash\",\"type\":\"bytes32\"}],\"name\":\"getPositionClaimedOnMainChain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_alreadyClaimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_longShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shortShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_meanEntryPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_meanEntrySpread\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_meanEntryLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationPrice\",\"type\":\"uint256\"}],\"name\":\"getPositionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"}],\"name\":\"getShortShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_shortShares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSideChainMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_sideChainMerkleRoot\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSideChainMerkleRootWrittenAtTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_sideChainMerkleRoot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSideChainOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStateAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_hasAccess\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTokenClaimedOnThisChain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTokenSentToLinkedChain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTokenSentToLinkedChainTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeStamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"grantAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inactivityPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"increaseNumberOfRequests\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last24HoursAmountWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastWithdrawLimitReductionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainChain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainChainWithdrawLimit24\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"morpherBridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"morpherGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"morpherRewards\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"morpherToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfRequestsLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payOperatingReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetLast24HoursAmountWithdrawn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"set24HourWithdrawLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdministrator\",\"type\":\"address\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"setAllowance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"setExposureMapping\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"setExposureMappingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"setExposureMappingIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernanceContractAddress\",\"type\":\"address\"}],\"name\":\"setGovernanceContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_periodLength\",\"type\":\"uint256\"}],\"name\":\"setInactivityPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setLastRequestBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mainChainWithdrawLimit24\",\"type\":\"uint256\"}],\"name\":\"setMainChainWithdrawLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_maxMappingIndex\",\"type\":\"uint256\"}],\"name\":\"setMaxMappingIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaximumLeverage\",\"type\":\"uint256\"}],\"name\":\"setMaximumLeverage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newBridge\",\"type\":\"address\"}],\"name\":\"setMorpherBridge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfRequests\",\"type\":\"uint256\"}],\"name\":\"setNumberOfRequests\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfRequestsLimit\",\"type\":\"uint256\"}],\"name\":\"setNumberOfRequestsLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOracleContract\",\"type\":\"address\"}],\"name\":\"setOracleContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_longShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shortShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_meanEntryPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_meanEntrySpread\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_meanEntryLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationPrice\",\"type\":\"uint256\"}],\"name\":\"setPosition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_positionHash\",\"type\":\"bytes32\"}],\"name\":\"setPositionClaimedOnMainChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRewardsAddress\",\"type\":\"address\"}],\"name\":\"setRewardAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRewardBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setRewardBasisPoints\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_sideChainMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setSideChainMerkleRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setSideChainOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"setTokenClaimedOnThisChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTokenContract\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"setTokenSentToLinkedChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalInPositions\",\"type\":\"uint256\"}],\"name\":\"setTotalInPositions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTotalOnOtherChain\",\"type\":\"uint256\"}],\"name\":\"setTotalOnOtherChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sideChainMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sideChainMerkleRootWrittenAtTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sideChainOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInPositions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalOnOtherChain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unPauseState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"update24HoursWithdrawLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawLimit24Hours\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MorpherState","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000100000000000000000000000070dcdb66e128738189012dee12d7e13b377a1d3b000000000000000000000000e261d68bda5bd518598e31320ede6e1e2d53682f","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://160459360f99868cb32b4e506044eeea98d9c28ae8691a9461867be3f47ceaa7"}]}