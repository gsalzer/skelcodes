{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract InstaAccount {\r\n\r\n    // event LogCast(address indexed origin, address indexed sender, uint value);\r\n\r\n    // receive() external payable {}\r\n\r\n    //  /**\r\n    //  * @dev Delegate the calls to Connector And this function is ran by cast().\r\n    //  * @param _target Target to of Connector.\r\n    //  * @param _data CallData of function in Connector.\r\n    // */\r\n    // function spell(address _target, bytes memory _data) internal {\r\n    //     require(_target != address(0), \"target-invalid\");\r\n    //     assembly {\r\n    //         let succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 0)\r\n\r\n    //         switch iszero(succeeded)\r\n    //             case 1 {\r\n    //                 // throw if delegatecall failed\r\n    //                 let size := returndatasize()\r\n    //                 returndatacopy(0x00, 0x00, size)\r\n    //                 revert(0x00, size)\r\n    //             }\r\n    //     }\r\n    // }\r\n\r\n    // /**\r\n    //  * @dev This is the main function, Where all the different functions are called\r\n    //  * from Smart Account.\r\n    //  * @param _targets Array of Target(s) to of Connector.\r\n    //  * @param _datas Array of Calldata(S) of function.\r\n    // */\r\n    // function cast(\r\n    //     address[] calldata _targets,\r\n    //     bytes[] calldata _datas,\r\n    //     address _origin,\r\n    //     address check\r\n    // )\r\n    // external\r\n    // payable\r\n    // {\r\n    //     for (uint i = 0; i < _targets.length; i++) {\r\n    //         spell(_targets[i], _datas[i]);\r\n    //     }\r\n    //     if (check != address(0)) require(CheckInterface(check).isOk(), \"not-ok\");\r\n    //     emit LogCast(_origin, msg.sender, msg.value);\r\n    // }\r\n    \r\n    // function decode(\r\n    //     bytes calldata _datas\r\n    // )\r\n    // external pure\r\n    //  returns (\r\n    //     TokenInterface fromToken,\r\n    //     TokenInterface toToken,\r\n    //     uint256 fromTokenAmount,\r\n    //     uint256 minReturnAmount,\r\n    //     uint256 guaranteedAmount\r\n    // )\r\n    // {\r\n    //     bytes memory _data = _datas;\r\n    //     assembly {\r\n    //         // data := calldatacopy(_datas, 0, 1)\r\n    //         // sig := mload(add(_datas, add(0x20, 0)))\r\n    //         fromToken := mload(add(_data, 36))\r\n    //         toToken := mload(add(_data, 68))\r\n    //         fromTokenAmount := mload(add(_data, 100))\r\n    //         minReturnAmount := mload(add(_data, 132))\r\n    //         guaranteedAmount := mload(add(_data, 164))\r\n    //     }\r\n        \r\n    // }\r\n    \r\n    function callOneInch(\r\n        bytes memory _callData,\r\n        uint ethAmt,\r\n        address _target\r\n    )\r\n    public {\r\n        // solium-disable-next-line security/no-call-value\r\n        // (bool success, bytes memory data) = address(getOneSplitAddress()).call.value(ethAmt)(_callData);\r\n        // if (!success) revert(\"Failed\");\r\n        // address _target = getOneSplitAddress();\r\n        assembly {\r\n            let succeeded := call(gas(), _target, ethAmt, add(_callData, 0x20), mload(_callData), 0, 0)\r\n\r\n            switch iszero(succeeded)\r\n                case 1 {\r\n                    // throw if delegatecall failed\r\n                    let size := returndatasize()\r\n                    returndatacopy(0x00, 0x00, size)\r\n                    revert(0x00, size)\r\n                }\r\n        }\r\n        // buyAmt = data;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"ethAmt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"callOneInch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"InstaAccount","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://983c6dc54c5d58cc2484c978f2f6e2682eb0c480b24516ab6f6448b929a29379"}]}