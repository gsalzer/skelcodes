{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-06-05\r\n*/\r\n\r\n// File: contracts/common/Validating.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ninterface Validating {\r\n  modifier notZero(uint number) { require(number > 0, \"invalid 0 value\"); _; }\r\n  modifier notEmpty(string memory text) { require(bytes(text).length > 0, \"invalid empty string\"); _; }\r\n  modifier validAddress(address value) { require(value != address(0x0), \"invalid address\"); _; }\r\n}\r\n\r\n// File: contracts/external/BytesLib.sol\r\n\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    ) internal pure returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n            // The first word of the slice result is potentially a partial\r\n            // word read from the original array. To read it, we calculate\r\n            // the length of that partial word and start copying that many\r\n            // bytes into the array. The first word we copy will start with\r\n            // data we don't care about, but the last `lengthmod` bytes will\r\n            // land at the beginning of the contents of the new array. When\r\n            // we're done copying, we overwrite the full first word with\r\n            // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n            // The multiplication in the next line is necessary\r\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n            // the following copy loop was copying the origin's length\r\n            // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                // The multiplication in the next line has the same exact purpose\r\n                // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n            // update free-memory pointer\r\n            // allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            // if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\r\n        require(_bytes.length >= (_start + 8));\r\n        uint64 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\r\n        require(_bytes.length >= (_start + 12));\r\n        uint96 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\r\n        require(_bytes.length >= (_start + 16));\r\n        uint128 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n\r\n// File: contracts/external/SafeMath.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/**\r\n * @title Math provides arithmetic functions for uint type pairs.\r\n * You can safely `plus`, `minus`, `times`, and `divide` uint numbers without fear of integer overflow.\r\n * You can also find the `min` and `max` of two numbers.\r\n */\r\nlibrary SafeMath {\r\n\r\n  function min(uint x, uint y) internal pure returns (uint) { return x <= y ? x : y; }\r\n  function max(uint x, uint y) internal pure returns (uint) { return x >= y ? x : y; }\r\n\r\n\r\n  /** @dev adds two numbers, reverts on overflow */\r\n  function plus(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x, \"bad addition\"); }\r\n\r\n  /** @dev subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend) */\r\n  function minus(uint x, uint y) internal pure returns (uint z) { require((z = x - y) <= x, \"bad subtraction\"); }\r\n\r\n\r\n  /** @dev multiplies two numbers, reverts on overflow */\r\n  function times(uint x, uint y) internal pure returns (uint z) { require(y == 0 || (z = x * y) / y == x, \"bad multiplication\"); }\r\n\r\n  /** @dev divides two numbers and returns the remainder (unsigned integer modulo), reverts when dividing by zero */\r\n  function mod(uint x, uint y) internal pure returns (uint z) {\r\n    require(y != 0, \"bad modulo; using 0 as divisor\");\r\n    z = x % y;\r\n  }\r\n\r\n  /** @dev Integer division of two numbers truncating the quotient, reverts on division by zero */\r\n  function div(uint a, uint b) internal pure returns (uint c) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/external/Token.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/*\r\n * Abstract contract for the full ERC 20 Token standard\r\n * https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract Token {\r\n  /** This is a slight change to the ERC20 base standard.\r\n  function totalSupply() view returns (uint supply);\r\n  is replaced map:\r\n  uint public totalSupply;\r\n  This automatically creates a getter function for the totalSupply.\r\n  This is moved to the base contract since public getter functions are not\r\n  currently recognised as an implementation of the matching abstract\r\n  function by the compiler.\r\n  */\r\n  /// total amount of tokens\r\n  uint public totalSupply;\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) public view returns (uint balance);\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint _value) public returns (bool success);\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n\r\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of tokens to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint _value) public returns (bool success);\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/gluon/AppGovernance.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ninterface AppGovernance {\r\n  function approve(uint32 id) external;\r\n  function disapprove(uint32 id) external;\r\n  function activate(uint32 id) external;\r\n}\r\n\r\n// File: contracts/gluon/AppLogic.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/**\r\n  * @notice representing an app's in-and-out transfers of assets\r\n  * @dev an account/asset based app should implement its own bookkeeping\r\n  */\r\ninterface AppLogic {\r\n\r\n  /// @notice when an app proposal has been activated, Gluon will call this method on the previously active app version\r\n  /// @dev each app must implement, providing a future upgrade path, and call retire_() at the very end.\r\n  /// this is the chance for the previously active app version to migrate to the new version\r\n  /// i.e.: migrating data, deprecate prior behavior, releasing resources, etc.\r\n  function upgrade() external;\r\n\r\n  /// @dev once an asset has been deposited into the app's safe within Gluon, the app is given the chance to do\r\n  /// it's own per account/asset bookkeeping\r\n  ///\r\n  /// @param account any Ethereum address\r\n  /// @param asset any ERC20 token or ETH (represented by address 0x0)\r\n  /// @param quantity quantity of asset\r\n  function credit(address account, address asset, uint quantity) external;\r\n\r\n  /// @dev before an asset can be withdrawn from the app's safe within Gluon, the quantity and asset to withdraw must be\r\n  /// derived from `parameters`. if the app is account/asset based, it should take this opportunity to:\r\n  /// - also derive the owning account from `parameters`\r\n  /// - prove that the owning account indeed has the derived quantity of the derived asset\r\n  /// - do it's own per account/asset bookkeeping\r\n  /// notice that the derived account is not necessarily the same as the provided account; a classic usage example is\r\n  /// an account transfers assets across app (in which case the provided account would be the target app)\r\n  ///\r\n  /// @param account any Ethereum address to which `quantity` of `asset` would be transferred to\r\n  /// @param parameters a bytes-marshalled record containing all data needed for the app-specific logic\r\n  /// @return asset any ERC20 token or ETH (represented by address 0x0)\r\n  /// @return quantity quantity of asset\r\n  function debit(address account, bytes calldata parameters) external returns (address asset, uint quantity);\r\n}\r\n\r\n// File: contracts/gluon/AppState.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n/**\r\n  * @title representing an app's life-cycle\r\n  * @notice an app's life-cycle starts in the ON state, then it is either move to the final OFF state,\r\n  * or to the RETIRED state when it upgrades itself to its successor version.\r\n  */\r\ncontract AppState {\r\n\r\n  enum State { OFF, ON, RETIRED }\r\n  State public state = State.ON;\r\n  event Off();\r\n  event Retired();\r\n\r\n  /// @notice app must be active (when current)\r\n  modifier whenOn() { require(state == State.ON, \"must be on\"); _; }\r\n\r\n  /// @notice app must be halted\r\n  modifier whenOff() { require(state == State.OFF, \"must be off\"); _; }\r\n\r\n  /// @notice app must be retired (when no longer current, after being upgraded)\r\n  modifier whenRetired() { require(state == State.RETIRED, \"must be retired\"); _; }\r\n\r\n  /// @dev retire the app. this action is irreversible.\r\n  /// called during a normal upgrade operation. by the end of this call the approved proposal would be active.\r\n  function retire_() internal whenOn {\r\n    state = State.RETIRED;\r\n    emit Retired();\r\n  }\r\n\r\n  /// @notice halt the app. this action is irreversible.\r\n  /// (the only option at this point is have a proposal that will get to approval, then activated.)\r\n  /// should be called by an app-owner when the app has been compromised.\r\n  function switchOff_() internal whenOn {\r\n    state = State.OFF;\r\n    emit Off();\r\n  }\r\n\r\n  /// @notice app state is active, i.e: current & active\r\n  function isOn() external view returns (bool) { return state == State.ON; }\r\n\r\n}\r\n\r\n// File: contracts/gluon/GluonView.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ninterface GluonView {\r\n  function app(uint32 id) external view returns (address current, address proposal, uint activationBlock);\r\n  function current(uint32 id) external view returns (address);\r\n  function history(uint32 id) external view returns (address[] memory);\r\n  function getBalance(uint32 id, address asset) external view returns (uint);\r\n  function isAnyLogic(uint32 id, address logic) external view returns (bool);\r\n  function isAppOwner(uint32 id, address appOwner) external view returns (bool);\r\n  function proposals(address logic) external view returns (bool);\r\n  function totalAppsCount() external view returns(uint32);\r\n}\r\n\r\n// File: contracts/gluon/GluonCentric.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n/**\r\n  * @title the essentials of a side-chain app participating in Gluon-Plasma\r\n  * @dev both Logic & Data (if exists) contracts should inherit this contract\r\n  */\r\ncontract GluonCentric {\r\n\r\n  uint32 internal constant REGISTRY_INDEX = 0;\r\n  uint32 internal constant STAKE_INDEX = 1;\r\n\r\n  uint32 public id;\r\n  address public gluon;\r\n\r\n  /// @param id_ index of the app within gluon\r\n  /// @param gluon_ address of the Gluon contract\r\n  constructor(uint32 id_, address gluon_) public {\r\n    id = id_;\r\n    gluon = gluon_;\r\n  }\r\n\r\n  /// @notice requires the sender to be the currently active (latest) version of me (the app contract)\r\n  modifier onlyCurrentLogic { require(currentLogic() == msg.sender, \"invalid sender; must be current logic contract\"); _; }\r\n\r\n  /// @notice requires the sender must be gluon contract\r\n  modifier onlyGluon { require(gluon == msg.sender, \"invalid sender; must be gluon contract\"); _; }\r\n\r\n  /// @notice requires the sender must be my app owner\r\n  modifier onlyOwner { require(GluonView(gluon).isAppOwner(id, msg.sender), \"invalid sender; must be app owner\"); _; }\r\n\r\n  /// @return address the address of currently active (latest) version of me (the app contract)\r\n  function currentLogic() public view returns (address) { return GluonView(gluon).current(id); }\r\n\r\n}\r\n\r\n// File: contracts/gluon/GluonWallet.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ninterface GluonWallet {\r\n  function depositEther(uint32 id) external payable;\r\n  function depositToken(uint32 id, address token, uint quantity) external;\r\n  function withdraw(uint32 id, bytes calldata parameters) external;\r\n  function transfer(uint32 from, uint32 to, bytes calldata parameters) external;\r\n}\r\n\r\n// File: contracts/gluon/Upgrading.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\ncontract Upgrading {\r\n  address public upgradeOperator;\r\n\r\n  modifier onlyOwner { require(false, \"modifier onlyOwner must be implemented\"); _; }\r\n  modifier onlyUpgradeOperator { require(upgradeOperator == msg.sender, \"invalid sender; must be upgrade operator\"); _; }\r\n  function setUpgradeOperator(address upgradeOperator_) external onlyOwner { upgradeOperator = upgradeOperator_; }\r\n  function upgrade_(AppGovernance appGovernance, uint32 id) internal {\r\n    appGovernance.activate(id);\r\n    delete upgradeOperator;\r\n  }\r\n}\r\n\r\n// File: contracts/apps_history/registry/OldRegistry.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ninterface OldRegistry {\r\n  function contains(address apiKey) external view returns (bool);\r\n  function register(address apiKey) external;\r\n  function registerWithUserAgreement(address apiKey, bytes32 userAgreement) external;\r\n  function translate(address apiKey) external view returns (address);\r\n}\r\n\r\n// File: contracts/apps/registry/RegistryData.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\ncontract RegistryData is GluonCentric {\r\n\r\n  mapping(address => address) public accounts;\r\n\r\n  constructor(address gluon) GluonCentric(REGISTRY_INDEX, gluon) public { }\r\n\r\n  function addKey(address apiKey, address account) external onlyCurrentLogic {\r\n    accounts[apiKey] = account;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/apps/registry/RegistryLogic.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @title enabling Zero Knowledge API Keys as described in: https://blog.leverj.io/zero-knowledge-api-keys-43280cc93647\r\n  * @notice the Registry app consists of the RegistryLogic & RegistryData contracts.\r\n  * api-key registrations are held within RegistryData for an easier upgrade path.\r\n  * @dev although Registry enable account-based apps needing log-less logins, no app is required to use it.\r\n  */\r\ncontract RegistryLogic is Upgrading, Validating, AppLogic, AppState, GluonCentric {\r\n\r\n  RegistryData public data;\r\n  OldRegistry public old;\r\n\r\n  event Registered(address apiKey, address indexed account);\r\n\r\n  constructor(address gluon, address old_, address data_) GluonCentric(REGISTRY_INDEX, gluon) public {\r\n    data = RegistryData(data_);\r\n    old = OldRegistry(old_);\r\n  }\r\n\r\n  modifier isAbsent(address apiKey) { require(translate(apiKey) == address (0x0), \"api key already in use\"); _; }\r\n\r\n  /// @notice register an api-key on behalf of the sender\r\n  /// @dev irreversible operation; the apiKey->sender association cannot be broken or overwritten\r\n  /// (but further apiKey->sender associations can be provided)\r\n  ///\r\n  /// @param apiKey the account to be used to stand-in for the registering sender\r\n  function register(address apiKey) external whenOn validAddress(apiKey) isAbsent(apiKey) {\r\n    data.addKey(apiKey, msg.sender);\r\n    emit Registered(apiKey, msg.sender);\r\n  }\r\n\r\n  /// @notice retrieve the stand-in-for account\r\n  ///\r\n  /// @param apiKey the account to be used to stand-in for the registering sender\r\n  function translate(address apiKey) public view returns (address) {\r\n    address account = data.accounts(apiKey);\r\n    if (account == address(0x0)) account = old.translate(apiKey);\r\n    return account;\r\n  }\r\n\r\n  /**************************************************** AppLogic ****************************************************/\r\n\r\n  /// @notice upgrade the app to a new version; the approved proposal.\r\n  /// by the end of this call the approved proposal would be the current and active version of the app.\r\n  function upgrade() external onlyUpgradeOperator {\r\n    retire_();\r\n    upgrade_(AppGovernance(gluon), id);\r\n  }\r\n\r\n  function credit(address, address, uint) external { revert(\"not supported\"); }\r\n\r\n  function debit(address, bytes calldata) external returns (address, uint) { revert(\"not supported\"); }\r\n\r\n  /***************************************************** AppState *****************************************************/\r\n\r\n  /// @notice halt the app. this action is irreversible.\r\n  /// (the only option at this point is have a proposal that will get to approval, then activated.)\r\n  /// should be called by an app-owner when the app has been compromised.\r\n  ///\r\n  /// Note the constraint that all apps but Registry & Stake must be halted first!\r\n  function switchOff() external onlyOwner {\r\n    uint32 totalAppsCount = GluonView(gluon).totalAppsCount();\r\n    for (uint32 i = 2; i < totalAppsCount; i++) {\r\n      AppState appState = AppState(GluonView(gluon).current(i));\r\n      require(!appState.isOn(), \"One of the apps is still ON\");\r\n    }\r\n    switchOff_();\r\n  }\r\n\r\n  /********************************************************************************************************************/\r\n}\r\n\r\n// File: contracts/apps/stake/Governing.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ninterface Governing {\r\n  function deleteVoteTally(address proposal) external;\r\n  function activationInterval() external view returns (uint);\r\n}\r\n\r\n// File: contracts/apps/stake/Redeeming.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ninterface Redeeming {\r\n  function redeem(address account, uint quantity) external returns (uint toRestake, uint toStake, uint toWithdraw);\r\n}\r\n\r\n// File: contracts/apps/stake/StakeData.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\ncontract StakeData is GluonCentric {\r\n  using SafeMath for uint;\r\n\r\n  mapping(address => address[]) public accountToProposals;\r\n  mapping(address => bool[]) public accountToSides;\r\n  mapping(address => mapping(bool => uint)) public voteTally; /// proposal => side(true/false) => totalVotes\r\n  mapping(address => address) public accountLocation;         /// account => logic\r\n  mapping(address => uint) public balance;\r\n\r\n  constructor(address gluon) GluonCentric(STAKE_INDEX, gluon) public { }\r\n\r\n  function updateAccountLocation(address account, address logic) external onlyCurrentLogic { accountLocation[account] = logic; }\r\n\r\n  function updateBalance(address account, uint quantity) external onlyCurrentLogic { balance[account] = quantity; }\r\n\r\n  function voteAppUpgrade(address proposal, address account, bool side, uint quantity) external onlyCurrentLogic returns (uint, uint) {\r\n    uint index = getVoteIndex(account, proposal);\r\n    bool firstVote = index == accountToProposals[account].length;\r\n    require(firstVote || accountToSides[account][index] != side, \"cannot vote same side again\");\r\n    if (firstVote) {\r\n      accountToProposals[account].push(proposal);\r\n      accountToSides[account].push(side);\r\n    } else {\r\n      voteTally[proposal][!side] = voteTally[proposal][!side].minus(quantity);\r\n      accountToSides[account][index] = side;\r\n    }\r\n    voteTally[proposal][side] = voteTally[proposal][side].plus(quantity);\r\n    return getVoteTally(proposal);\r\n  }\r\n\r\n  function deleteVoteTally(address proposal) external onlyCurrentLogic {\r\n    voteTally[proposal][true] = voteTally[proposal][false] = 0;\r\n  }\r\n\r\n  function getVoteIndex(address account, address proposal) public view returns (uint) {\r\n    address[] memory proposals = accountToProposals[account];\r\n    for (uint i = 0; i < proposals.length; i++) {\r\n      if (proposals[i] == proposal) return i;\r\n    }\r\n    return proposals.length;\r\n  }\r\n\r\n  function getAllProposals(address account) external view returns (address[] memory proposals, bool[] memory sides) {\r\n    proposals = accountToProposals[account];\r\n    sides = accountToSides[account];\r\n  }\r\n\r\n  function removeResolvedProposals(address account) external onlyCurrentLogic {\r\n    if (accountToProposals[account].length == 0) return;\r\n    address[] storage allProposed = accountToProposals[account];\r\n    bool[] storage sides = accountToSides[account];\r\n    for (uint i = allProposed.length; i > 0; i--) {\r\n      if (!GluonView(gluon).proposals(allProposed[i - 1])) {\r\n        allProposed[i - 1] = allProposed[allProposed.length - 1];\r\n        allProposed.pop();\r\n        sides[i - 1] = sides[sides.length - 1];\r\n        sides.pop();\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateVotes(address proposal, bool side, uint quantity, bool increased) external onlyCurrentLogic returns (uint approvals, uint disapprovals) {\r\n    uint tally = voteTally[proposal][side];\r\n    voteTally[proposal][side] = increased ? tally.plus(quantity) : tally.minus(quantity);\r\n    return getVoteTally(proposal);\r\n  }\r\n\r\n  function getVoteTally(address proposal) public view returns (uint approvals, uint disapprovals) {\r\n    approvals = voteTally[proposal][true];\r\n    disapprovals = voteTally[proposal][false];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/apps/stake/StakeLogicV1.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @notice the Stake app consists of the StakeLogic & StakeData contracts.\r\n  * voting data and staked balances are held within StakeData for an easier upgrade path.\r\n  *\r\n  * staking LEV tokens allows for:\r\n  *  a. distribution of awards to stakers\r\n  *  b. governance of apps; as stakers can vote for or against proposals (proposed app upgrades)\r\n  */\r\ncontract StakeLogicV1 is Upgrading, Validating, AppLogic, AppState, GluonCentric, Governing, Redeeming {\r\n  using BytesLib for bytes;\r\n  using SafeMath for uint;\r\n  address constant private ETH = address(0x0);\r\n  bool initiated;\r\n  /// per stake interval data\r\n  struct Interval {\r\n    uint worth;\r\n    uint[] rewards;\r\n    uint start;\r\n    uint end;\r\n  }\r\n\r\n  /// account\r\n  struct UserStake {\r\n    uint intervalIndex;\r\n    uint quantity;\r\n    uint worth;\r\n  }\r\n\r\n  StakeData public data;\r\n  Token public LEV;\r\n  address[] public tokens;\r\n  uint[] public toBeDistributed;\r\n\r\n  uint public intervalSize;\r\n  uint public currentIntervalIndex;\r\n  uint public quorumPercentage;\r\n  uint public activationInterval;\r\n  mapping(uint => Interval) public intervals;\r\n  mapping(address => UserStake) public stakes;\r\n\r\n  event Staked(address indexed user, uint levs, uint start, uint end, uint intervalIndex);\r\n  event Restaked(address indexed user, uint levs, uint start, uint end, uint intervalIndex);\r\n  event Redeemed(address indexed user, uint levs, uint start, uint end, uint intervalIndex);\r\n  event Reward(address indexed user, address asset, uint reward, uint start, uint end, uint intervalIndex);\r\n  event NewInterval(uint start, uint end, uint intervalIndex);\r\n  event Voted(uint32 indexed appId, address indexed proposal, uint approvals, uint disapprovals, address account);\r\n  event VotingConcluded(uint32 indexed appId, address indexed proposal, uint approvals, uint disapprovals, bool result);\r\n\r\n  constructor(address gluon, address data_, address lev, address[] memory tokens_, address apiKey, uint intervalSize_, uint quorumPercentage_, uint activationInterval_)\r\n  GluonCentric(STAKE_INDEX, gluon)\r\n  public\r\n  validAddress(gluon)\r\n  validAddress(lev)\r\n  validAddress(apiKey)\r\n  notZero(intervalSize_)\r\n  notZero(activationInterval_)\r\n  {\r\n    data = StakeData(data_);\r\n    LEV = Token(lev);\r\n    tokens = tokens_;\r\n    for (uint i = 0; i < tokens.length; i++) {\r\n      toBeDistributed.push(0);\r\n    }\r\n    quorumPercentage = quorumPercentage_;\r\n    intervalSize = intervalSize_;\r\n    registerApiKey_(apiKey);\r\n    activationInterval = activationInterval_;\r\n  }\r\n\r\n  function() external payable {}\r\n\r\n  function governanceToken() external view returns (address) {return address(LEV);}\r\n\r\n  function init(uint intervalId) external onlyOwner {\r\n    require(initiated == false, \"already initiated\");\r\n    currentIntervalIndex = intervalId;\r\n    intervals[currentIntervalIndex].start = block.number;\r\n    intervals[currentIntervalIndex].end = block.number + intervalSize;\r\n    for (uint i = 0; i < tokens.length; i++) intervals[currentIntervalIndex].rewards.push(0);\r\n    initiated = true;\r\n  }\r\n\r\n  function setIntervalSize(uint intervalSize_) external notZero(intervalSize_) onlyOwner {\r\n    ensureInterval();\r\n    intervalSize = intervalSize_;\r\n  }\r\n\r\n  function addToken(address token) external validAddress(token) onlyOwner whenOn {\r\n    require(tokens.length < 50, \"Can not add more than 50 tokens\");\r\n    tokens.push(token);\r\n    toBeDistributed.push(0);\r\n    intervals[currentIntervalIndex].rewards.push(0);\r\n  }\r\n\r\n  /// @notice establish an interval if none exists\r\n  function ensureInterval() public whenOn {\r\n    if (intervals[currentIntervalIndex].end > block.number) return;\r\n\r\n    Interval storage interval = intervals[currentIntervalIndex];\r\n    for (uint i = 0; i < interval.rewards.length; i++) {\r\n      uint reward = interval.worth == 0 ? 0 : calculateIntervalReward(interval.start, interval.end, i);\r\n      toBeDistributed[i] = toBeDistributed[i].plus(reward);\r\n      interval.rewards[i] = reward;\r\n    }\r\n\r\n    uint diff = (block.number - interval.end) % intervalSize;\r\n    currentIntervalIndex += 1;\r\n    uint start = interval.end;\r\n    uint end = block.number - diff + intervalSize;\r\n    intervals[currentIntervalIndex].start = start;\r\n    intervals[currentIntervalIndex].end = end;\r\n    for (uint i = 0; i < tokens.length; i++) intervals[currentIntervalIndex].rewards.push(0);\r\n    emit NewInterval(start, end, currentIntervalIndex);\r\n  }\r\n\r\n  function restake(address account, uint quantity) private returns (uint, uint) {\r\n    Redeeming stakeLocation = Redeeming(data.accountLocation(account) == address(0x0) ? address(this) : data.accountLocation(account));\r\n    (uint toRestake, uint toStake, uint toWithdraw) = stakeLocation.redeem(account, quantity);\r\n    if (toRestake == 0) return (toStake, toWithdraw);\r\n\r\n    UserStake storage stake = stakes[account];\r\n    stake.quantity = toRestake;\r\n    Interval storage interval = intervals[currentIntervalIndex];\r\n    stake.intervalIndex = currentIntervalIndex;\r\n    stake.worth = stake.quantity.times(interval.end.minus(interval.start));\r\n    interval.worth = interval.worth.plus(stake.worth);\r\n    emit Restaked(account, stake.quantity, interval.start, interval.end, currentIntervalIndex);\r\n    return (toStake, toWithdraw);\r\n  }\r\n\r\n  function stake(address account, uint quantity) private whenOn returns (uint toStake, uint toWithdraw) {\r\n    ensureInterval();\r\n    (toStake, toWithdraw) = restake(account, quantity);\r\n    data.updateAccountLocation(account, address(this));\r\n    data.removeResolvedProposals(account);\r\n    if (toWithdraw > 0) {\r\n      updateVotes(account, toWithdraw, false);\r\n    }\r\n    if (toStake > 0) {\r\n      updateVotes(account, toStake, true);\r\n      stakeInCurrentPeriod(account, toStake);\r\n    }\r\n    data.updateBalance(account, quantity);\r\n  }\r\n\r\n  function stakeInCurrentPeriod(address account, uint quantity) private {\r\n    Interval storage interval = intervals[currentIntervalIndex];\r\n    stakes[account].intervalIndex = currentIntervalIndex;\r\n    uint worth = quantity.times(interval.end.minus(block.number));\r\n    stakes[account].worth = stakes[account].worth.plus(worth);\r\n    stakes[account].quantity = stakes[account].quantity.plus(quantity);\r\n    interval.worth = interval.worth.plus(worth);\r\n    emit Staked(account, quantity, interval.start, interval.end, currentIntervalIndex);\r\n  }\r\n\r\n  /// @notice calculate the reward for token for the interval: [`start`, `end`)\r\n  /// provided for on-going operational queries\r\n  function calculateIntervalReward(uint start, uint end, uint index) public view returns (uint) {\r\n    uint balance = tokens[index] == ETH ? address(this).balance : Token(tokens[index]).balanceOf(address(this));\r\n    return balance.minus(toBeDistributed[index]).times(end.minus(start)).div(block.number.minus(start));\r\n  }\r\n\r\n  function registerApiKey(address apiKey) public onlyOwner {registerApiKey_(apiKey);}\r\n\r\n  function registerApiKey_(address apiKey) private {\r\n    RegistryLogic registry = RegistryLogic(GluonView(gluon).current(REGISTRY_INDEX));\r\n    registry.register(apiKey);\r\n  }\r\n\r\n  function withdrawFromApp(uint32 appId, bytes memory withdrawData) public {\r\n    uint action = withdrawData.toUint(0);\r\n    require(action == 1 || action == 5, \"only assisted withdraw or exit on halt is allowed\");\r\n    GluonWallet(gluon).withdraw(appId, withdrawData);\r\n  }\r\n\r\n  function transferToLatestStakeAfterRetire() public whenRetired {\r\n    for (uint i = 0; i < tokens.length; i++) {\r\n      uint balance = tokens[i] == ETH ? address(this).balance : Token(tokens[i]).balanceOf(address(this));\r\n      uint quantity = balance.minus(toBeDistributed[i]);\r\n      transfer(tokens[i], currentLogic(), quantity);\r\n    }\r\n  }\r\n\r\n  /**************************************************** Redeeming *****************************************************/\r\n\r\n  /// @notice redeeming enables both withdrawing and restaking.\r\n  /// first, the quantities {toRestake, toStake, toWithdraw} are calculated from the last staked amount and the given quantity\r\n  /// to redeem, then `toWithdraw` will be transfer to the account, and `toRestake` will be staked in the current interval.\r\n  /// the calculated values are returned to calling functions for further processing.\r\n  ///\r\n  /// @param account the staking account\r\n  /// @param quantity how much to redeem\r\n  /// @return toRestake how much of the staked amount from previously staked interval will be carried over to current stake interval\r\n  /// @return toStake how much (beyond toRestake) will be staked for the remainder of the current interval\r\n  /// @return toWithdraw how much would no longer be staked and instead transferred back to the staker account\r\n  function redeem(address account, uint quantity) public onlyCurrentLogic returns (uint, uint, uint) {// (toRestake, toStake, toWithdraw)\r\n    UserStake memory userStake = stakes[account];\r\n    if (userStake.intervalIndex == 0) return (0, quantity, 0);\r\n    // non staked thus far, so stake quantity in-full\r\n\r\n    uint staked = userStake.quantity;\r\n    if (userStake.intervalIndex == currentIntervalIndex) {\r\n      require(quantity > staked, \"Can not reduce stake in the latest interval\");\r\n      return (0, quantity.minus(staked), 0);\r\n      // some is already staked, so stake the difference\r\n    }\r\n\r\n    // some is staked in previous interval\r\n    uint toWithdraw = staked > quantity ? staked.minus(quantity) : 0;\r\n    uint toRestake = staked.minus(toWithdraw);\r\n    // staker get previous staked amount carried over to current interval (minus the withdrawn amount)\r\n    uint toStake = quantity > staked ? quantity.minus(staked) : 0;\r\n    // staker get the extra amount (beyond what is already carried over) staked in the remainder of current interval\r\n\r\n    uint intervalIndex = userStake.intervalIndex;\r\n    Interval memory interval = intervals[intervalIndex];\r\n    uint worth = userStake.worth;\r\n    delete stakes[account];\r\n    distributeRewards(account, worth, interval, intervalIndex);\r\n    emit Redeemed(account, toWithdraw, interval.start, interval.end, intervalIndex);\r\n    return (toRestake, toStake, toWithdraw);\r\n  }\r\n\r\n  function distributeRewards(address account, uint worth, Interval memory interval, uint intervalIndex) private {\r\n    if (worth == 0) return;\r\n    for (uint i = 0; i < tokens.length; i++) {\r\n      uint reward = interval.rewards[i].times(worth).div(interval.worth);\r\n      if (reward == 0) continue;\r\n      toBeDistributed[i] = toBeDistributed[i].minus(reward);\r\n      transfer(tokens[i], account, reward);\r\n      emit Reward(account, tokens[i], reward, interval.start, interval.end, intervalIndex);\r\n    }\r\n  }\r\n\r\n  function transfer(address token, address to, uint quantity) private {\r\n    if (quantity == 0) return;\r\n    token == ETH ?\r\n    require(address(uint160(to)).send(quantity), \"failed to transfer ether\") : // explicit casting to `address payable`\r\n    transferTokensToAccountSecurely(Token(token), quantity, to);\r\n  }\r\n\r\n  function transferTokensToAccountSecurely(Token token, uint quantity, address to) private {\r\n    uint balanceBefore = token.balanceOf(to);\r\n    require(token.transfer(to, quantity), \"failure to transfer quantity from token\");\r\n    uint balanceAfter = token.balanceOf(to);\r\n    require(balanceAfter.minus(balanceBefore) == quantity, \"bad Token; transferFrom erroneously reported of successful transfer\");\r\n  }\r\n\r\n  function getTokens() public view returns (address[] memory){return tokens;}\r\n\r\n  function getToBeDistributed() public view returns (uint[] memory) {return toBeDistributed;}\r\n\r\n  function getInterval(uint intervalIndex) public view returns (uint worth, uint[] memory rewards, uint start, uint end){\r\n    Interval memory interval = intervals[intervalIndex];\r\n    worth = interval.worth;\r\n    rewards = interval.rewards;\r\n    start = interval.start;\r\n    end = interval.end;\r\n  }\r\n  /**************************************************** Governing ****************************************************/\r\n\r\n  /// @dev cleanup when deleting a proposal\r\n  function deleteVoteTally(address proposal) external onlyGluon {data.deleteVoteTally(proposal);}\r\n\r\n  /**************************************************** AppLogic ****************************************************/\r\n\r\n  /// @notice upgrade the app to a new version; the approved proposal.\r\n  /// by the end of this call the approved proposal would be the current and active version of the app.\r\n  function upgrade() external whenOn onlyUpgradeOperator {\r\n    intervals[currentIntervalIndex].end = block.number;\r\n    ensureInterval();\r\n    retire_();\r\n    upgrade_(AppGovernance(gluon), id);\r\n  }\r\n\r\n  function credit(address account, address asset, uint quantity) external whenOn onlyGluon {\r\n    require(asset == address(LEV), \"can only deposit lev tokens\");\r\n    stake(account, data.balance(account).plus(quantity));\r\n  }\r\n\r\n  function debit(address account, bytes calldata parameters) external whenOn onlyGluon returns (address asset, uint quantity) {\r\n    (asset, quantity) = abi.decode(parameters, (address, uint));\r\n    require(asset == address(LEV), \"can only withdraw lev tokens\");\r\n    stake(account, data.balance(account).minus(quantity));\r\n  }\r\n\r\n  /***************************************************** vote to upgrade ****************************************************/\r\n\r\n  /// @notice vote for the current app proposal\r\n  ///\r\n  /// @param appId the app the sender is voting for\r\n  /// @param side yay or nay: true => approve, false => disapprove\r\n  function voteAppUpgrade(uint32 appId, bool side) external whenOn {\r\n    (, address proposal, uint activationBlock) = GluonView(gluon).app(appId);\r\n    require(activationBlock > block.number, \"can not be voted\");\r\n    uint quantity = data.balance(msg.sender);\r\n    (uint approvals, uint disapprovals) = data.voteAppUpgrade(proposal, msg.sender, side, quantity);\r\n    emit Voted(appId, proposal, approvals, disapprovals, msg.sender);\r\n    concludeVoting(appId, proposal, approvals, disapprovals);\r\n  }\r\n\r\n  function updateVotes(address account, uint quantity, bool increased) private {\r\n    (address[] memory allProposed, bool[] memory sides) = data.getAllProposals(account);\r\n    for (uint i; i < allProposed.length; i++) {\r\n      uint32 appId = GluonCentric(allProposed[i]).id();\r\n      (,,uint activationBlock) = GluonView(gluon).app(appId);\r\n      if (block.number > activationBlock) continue;\r\n      (uint approvals, uint disapprovals) = data.updateVotes(allProposed[i], sides[i], quantity, increased);\r\n      emit Voted(appId, allProposed[i], approvals, disapprovals, msg.sender);\r\n      concludeVoting(appId, allProposed[i], approvals, disapprovals);\r\n    }\r\n  }\r\n\r\n  function concludeVoting(uint32 appId, address proposal, uint approvals, uint disapprovals) private {\r\n    if (approvals.plus(disapprovals) >= LEV.totalSupply().times(quorumPercentage).div(100)) {\r\n      if (approvals > disapprovals) {\r\n        AppGovernance(gluon).approve(appId);\r\n        emit VotingConcluded(appId, proposal, approvals, disapprovals, true);\r\n      } else {\r\n        AppGovernance(gluon).disapprove(appId);\r\n        emit VotingConcluded(appId, proposal, approvals, disapprovals, false);\r\n      }\r\n    }\r\n  }\r\n\r\n  /***************************************************** halting *****************************************************/\r\n\r\n  /// @notice halt the app. this action is irreversible.\r\n  /// (the only option at this point is have a proposal that will get to approval, then activated.)\r\n  /// should be called by an app-owner when the app has been compromised.\r\n  ///\r\n  /// Note the constraint that all apps but Registry & Stake must be halted first!\r\n  function switchOff() external onlyOwner {\r\n    uint32 totalAppsCount = GluonView(gluon).totalAppsCount();\r\n    for (uint32 appId = 2; appId < totalAppsCount; appId++) {\r\n      AppState appState = AppState(GluonView(gluon).current(appId));\r\n      require(!appState.isOn(), \"One of the apps is still ON\");\r\n    }\r\n    switchOff_();\r\n  }\r\n\r\n  /********************************************************************************************************************/\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gluon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"data_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lev\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"apiKey\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"intervalSize_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumPercentage_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activationInterval_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intervalIndex\",\"type\":\"uint256\"}],\"name\":\"NewInterval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Off\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"levs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intervalIndex\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"levs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intervalIndex\",\"type\":\"uint256\"}],\"name\":\"Restaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Retired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intervalIndex\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"levs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intervalIndex\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"appId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposal\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"approvals\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"disapprovals\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"appId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposal\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"approvals\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"disapprovals\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"VotingConcluded\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"LEV\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activationInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"calculateIntervalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"credit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentIntervalIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentLogic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"data\",\"outputs\":[{\"internalType\":\"contract StakeData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"debit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposal\",\"type\":\"address\"}],\"name\":\"deleteVoteTally\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ensureInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"intervalIndex\",\"type\":\"uint256\"}],\"name\":\"getInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"worth\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"rewards\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getToBeDistributed\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gluon\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governanceToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"intervalId\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intervalSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"intervals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"worth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quorumPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"apiKey\",\"type\":\"address\"}],\"name\":\"registerApiKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"intervalSize_\",\"type\":\"uint256\"}],\"name\":\"setIntervalSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"upgradeOperator_\",\"type\":\"address\"}],\"name\":\"setUpgradeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"intervalIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"worth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum AppState.State\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switchOff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"toBeDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferToLatestStakeAfterRetire\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"appId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"voteAppUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"appId\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"withdrawData\",\"type\":\"bytes\"}],\"name\":\"withdrawFromApp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakeLogicV1","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000075ace7a086ea0fb1a79e43cc6331ad053d8c67cb000000000000000000000000ab3ac436d66cbeedc734ed2c1562c3a213c9bc770000000000000000000000000f4ca92660efad97a9a70cb0fe969c755439772c00000000000000000000000000000000000000000000000000000000000001000000000000000000000000005ac6951e36d5a57e1c71896b4c6ebbd379750057000000000000000000000000000000000000000000000000000000000002a30000000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000002d00000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000006b175474e89094c44da98b954eedeac495271d0f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://221fbb92bc4ac0f5e5b8d8e2c3484cbab50f2aa8ffac9392cb96d543b7f3bbc0"}]}