{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.6.8;\r\n\r\n/*\r\n *\tHEXme.io contract - Get +20% bonus HEX on your ETH to HEX transforms!\r\n *\r\n *      _   _  _______   __                 _\r\n *     | | | ||  ___\\ \\ / /                (_)\r\n *     | |_| || |__  \\ V / _ __ ___   ___   _  ___\r\n *     |  _  ||  __| /   \\| '_ ` _ \\ / _ \\ | |/ _ \\\r\n *     | | | || |___/ /^\\ \\ | | | | |  __/_| | (_) |\r\n *     \\_| |_/\\____/\\/   \\/_| |_| |_|\\___(_)_|\\___/\r\n *\r\n *\r\n *  HEXme.io is truly & solely built, as a service, on top of the original HEX contract!\r\n *  That means it only uses HEX original function calls and simply wraps HEX as a service layer.\r\n *\r\n *  It enhances the HEX ecosystem and doesn't split it!\r\n *  Thus we DO NOT use an own obsolete token!\r\n *  DO NOT trade any token which is not HEX itself, if you want to use the HEX ecosystem,\r\n *  unless you clearly understand the risk of the actions you are taking!\r\n *\r\n *  Verify over trust!\r\n *\r\n *  READ COMPLETELY & CAREFULLY BEFORE YOU USE THIS CONTRACT!\r\n *  THERE IS NO ONE ELSE IN CHARGE OF YOUR ACTIONS THAN YOURSELF!\r\n *\r\n *  DISCLAIMER:\r\n *\r\n *  Use at your own risk. Verify the code you want to execute.\r\n *  You are solely responsible for your decisions.\r\n *  Don't consider things as financial advice, unless they're labeled as such.\r\n *  Be responsible, take only reasonable risks.\r\n *  DYOR! - Do your own research!\r\n *\r\n *  The HEX code, which HEXme is building on top of, cannot be changed.\r\n *  The HEXme code cannot be changed either.\r\n *  Nobody is in charge of any of these contracts!\r\n *\r\n *  The HEXme contract uses the original HEX contract at the given address:\r\n *      0x2b591e99afe9f32eaa6214f7b7629768c40eeb39\r\n *\r\n *  The HEXme contracts address is:\r\n *      0x34b64e63Bdca0A165bb93C7C356BDef8909ccbb5\r\n *\r\n *  However HEXme does have very little configuration abilities, which only can be executed by the so called ORIGIN_ADDR.\r\n *  Those configuration functions use the onlyOrigin modifier.\r\n *  They neither give the ORIGIN_ADDR or any other entity any power to switch off any functionalities of the HEXme contract,\r\n *  nor give they the ORIGIN_ADDR or any other entity the power to control any users funds at any given time and state.\r\n *\r\n *  HEXme has no off switch. Anyone can run the code at any given time and state.\r\n *\r\n *  HEXme offers its users the ability to enter ETH to a HEX AA Lobby and to receive, not just +10% bonus HEX, as they would\r\n *  do with any casual referral link on the original go.HEX.com page, but +20% bonus on top of the basic HEX/ETH ratio\r\n *  of any given lobbyDay.\r\n *  That means HEXme users get the best deal for their bucket than at any other given place,\r\n *  if they wanna transform ETH into HEX, using HEXs AA lobby system.\r\n *\r\n *  HEXme also offers an internal referral system, which pays the referring address at maximum of 6%\r\n *  of the referred users originally transformed HEX. Those 6% are subtracted from the marginShares,\r\n *  which the ORIGIN_ADDR would receive otherwise. The user will always get its userShares, which are initially set\r\n *  to 120% and cannot be reduced, whether it refers another address or not.\r\n *\r\n *  The referral system therefore is self sustainable and doesn't promise any returns that doesn't actually exist\r\n *  in the HEX smart contract. This means any funds can be payed out at any given time, when the user simply exits its\r\n *  open HEX LobbyDay via HEXme.\r\n *\r\n *  HOW TO USE:\r\n *\r\n *      - enterLobby()\r\n *          - Call this payable method with at least minimumEntryAmount of wei, which is defined in globals,\r\n *            to enter a Lobby via HEXme and to reserve your +20% bonus from the given days basic HEX/ETH ratio.\r\n *          - The minimumEntryAmount initially is set to 0.025 ETH and can only be between 0.01 ETH & 0.05 ETH.\r\n *      - enterLobbyWithReferrer(address referrer)\r\n *          - Equally as enterLobby() with the possibility to note a referrer address, which will receive another +6%\r\n *            bonus on top of the users +20%.\r\n *      - exitLobby(uint256 lobbyDay)\r\n *          - Exits the given lobbyDay, if the user (the sending address) has entered any ETH in that day, didn't exit\r\n *            it yet and the given lobbyDay already has closed.\r\n *          - The user will receive its userShares HEX (initially set to 120%, can't be reduced) of the basic ratio,\r\n *            of the given lobbyDays ratio.\r\n *          - If any referral address was noted by the user at any previous lobbyDay entry, via enterLobbyWithReferrer()\r\n *            now this referral address also receives its marginShares percentage of the basic HEX/ETH ratio on top.\r\n *      - exitLobbyOnBehalf(address userAddress, uint256 lobbyDay)\r\n *          - From HEXs day 345 on, also other incentivized users, which describes a users referrer or the ORIGIN_ADDR,\r\n *            can exit a lobbyDay on behalf of the user, to be able to receive their marginShares HEX before\r\n *            HEXs BIG_PAY_DAY, which is the contract day 352.\r\n *          - Before day 345 only the user itself, who entered a lobby day is able to exit it, once it has closed.\r\n *\r\n *  FURTHER INFORMATION:\r\n *\r\n *  What happens if someone sends ETH to HEXme:\r\n *      - If anyone sends ETH directly to HEXme, it will automatically be forwarded to the enterLobby() method and\r\n *        therefore will behave exactly as if the sender would had called the enterLobby() directly with the sent ETH amount.\r\n *        This means the user will be able to exit the lobbyDay at which he sent the ETH to HEXme, once it has closed.\r\n *        Simply by using the exitLobby(uint256 lobbyDay) method.\r\n *\r\n *  The so called configuration abilities solely break down to:\r\n *      - changeMinimumEntryAmount()\r\n *          - in the range from 0.01 ETH to 0.05 ETH. #noexpectation\r\n *      - raiseUserShares()\r\n *          - userShares only can go up. At maximum to 30% bonus.\r\n *          - This in return would reduce the marginShares.\r\n *          - It might be used to assure market competitiveness and stay attractive for HEXmes users.\r\n *          - Do not expect of this ever happening. #noexpectation\r\n *      - moveExitLobbyPointer()\r\n *          - This could be called to gas optimize HEXmes internal state behaviour for the users.\r\n *          - It doesn't affect the ability for any user to use HEXme at any given time, at any given state.\r\n *      - flushExceedingHEX()\r\n *          - If HEX externally got send to HEXme, whether on purpose or on accident,\r\n *            this method gives the ORIGIN_ADDR the ability to flush those externally added funds to itself.\r\n *          - It also assures, that HEXme always has covered its required HEX liquidity, needed to serve all users exits,\r\n *            who ever entered any lobbyDay via HEXme.\r\n *          - It solely flushes exceeding HEX on the contract, to the ORIGIN_ADDR, which weren't minted by any users entry.\r\n *          - The ORIGIN_ADDR can do whatever it does with the exceeding HEX, if it ever was to receive any.\r\n *          - It might be possible, that if sent accidentally, the ORIGIN_ADDR could also decide to send those funds\r\n *            back to the address, the HEX originated from. #noexpectation\r\n *      - flushERC20()\r\n *          - If any other ERC20 than HEX (determined by the HEX contracts address) might land on that contract,\r\n *            the ORIGIN_ADDR is free to flush those tokens to itself and to do whatever it does with those assets.\r\n *            #noexpectation\r\n *\r\n *  Another publicly callable method:\r\n *      - exitContractLobbyDay(uint256 lobbyDay, uint40 count)\r\n *          - This method simply internally exits a HEXme contracts LobbyDay from the original HEX contract,\r\n *            to provide a higher instant liquidity and therefore to lower the gas fees for users\r\n *            to exit their HEXme entries.\r\n *          - It doesn't change any behaviour of the contract and can be called by anyone who wants to optimize\r\n *            the HEXmes users gas costs.\r\n *            #noexpectation\r\n *\r\n *  HAVE NO EXPECTATIONS:\r\n *\r\n *  DO NOT HAVE ANY EXPECTATIONS FROM ANYONE REGARDING HEX/HEXME/ETHEREUM OR ANY OTHER ENTITY!\r\n *  IF YOU DECIDE TO USE THOSE OPEN SOURCE, PUBLICLY ACCESSIBLE SYSTEMS, IT IS SOLELY ON YOU TO KNOW WHAT YOU ARE DOING.\r\n *  THERE IS NO ONE TO CALL FOR HELP, IF YOU USE THOSE TRULY DECENTRALIZED SYSTEMS WRONGLY.\r\n *  YOU ARE FULLY AND SOLELY RESPONSIBLE FOR YOUR ACTIONS.\r\n *  TAKE CARE! AND ENJOY THE DECENTRALIZED WORLD OF TODAY!\r\n *\r\n *  BEST REGARDS,\r\n *  HEXme.io\r\n *\r\n */\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SM: ADD OVF\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SM: SUB OVF\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SM: MUL OVF\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SM: DIV/0\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SM: MOD 0\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/*\r\n *\tHEX interface of required functionalities\r\n */\r\n\r\ninterface IHEX {\r\n\r\n    struct DailyDataStore {\r\n        uint72 dayPayoutTotal;\r\n        uint72 dayStakeSharesTotal;\r\n        uint56 dayUnclaimedSatoshisTotal;\r\n    }\r\n\r\n    function currentDay() external view returns (uint256);\r\n\r\n    function globalInfo() external view returns (uint256[13] memory);\r\n\r\n    function dailyData(uint256 lobbyDay) external view returns\r\n        (uint72 dayPayoutTotal, uint72 dayStakeSharesTotal, uint56 dayUnclaimedSatoshisTotal);\r\n\r\n    struct XfLobbyEntryStore {\r\n        uint96 rawAmount;\r\n        address referrerAddr;\r\n    }\r\n\r\n    struct XfLobbyQueueStore {\r\n        uint40 headIndex;\r\n        uint40 tailIndex;\r\n        mapping(uint256 => XfLobbyEntryStore) entries;\r\n    }\r\n\r\n    function xfLobby(uint256 lobbyDay) external view returns (uint256 rawAmount);\r\n\r\n    function xfLobbyMembers(uint256 i, address _XfLobbyQueueStore) external view returns\r\n        (uint40 headIndex, uint40 tailIndex, uint96 rawAmount, address referrerAddr);\r\n\r\n    function xfLobbyEnter(address referrerAddr) external payable;\r\n\r\n    function xfLobbyExit(uint256 enterDay, uint256 count) external;\r\n\r\n    function dailyDataUpdate(uint256 beforeDay) external;\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// HEXme contract code:\r\n// We strongly suggest you, to verify the code you are executing!\r\n\r\ncontract HEXme {\r\n\r\n    // SAFEMATH:\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint40;\r\n\r\n    // CONSTANTS - HEX specific:\r\n\r\n    uint256 private constant HEARTS_PER_HEX = 10 ** uint256(8);\r\n    uint256 private constant HEARTS_PER_SATOSHI = HEARTS_PER_HEX / 1e8 * 1e4;\r\n    uint256 private constant WAAS_LOBBY_SEED_HEARTS = 1e9 * HEARTS_PER_HEX;\r\n\r\n    uint256 private constant CLAIM_PHASE_START_DAY = 1;\r\n    uint256 private constant CLAIM_PHASE_DAYS = 50 * 7;\r\n    uint256 private constant CLAIM_PHASE_END_DAY = CLAIM_PHASE_START_DAY + CLAIM_PHASE_DAYS;\r\n    uint256 private constant BIG_PAY_DAY = CLAIM_PHASE_END_DAY + 1;\r\n\r\n    // STATE VARIABLES - HEXme specific:\r\n\r\n    // HEX CONTRACT:\r\n    IHEX public constant HEX = IHEX(0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39);\r\n\r\n    // ORIGIN ADDRESS:\r\n    address public constant ORIGIN_ADDR = 0x63Cbc7d47dfFE12C2B57AD37b8458944ad4121Ee;\r\n\r\n    // SHARES:\r\n\r\n    uint256 constant private totalShares = 1320;\r\n    // 1000‰ representing the AAs basic ETH/HEX ratio\r\n    uint256 constant public basicShares = 1000;\r\n    // 1200‰ representing the users 200‰ bonus shares - 2x of the normal referee bonus\r\n    // it might increase if a higher competitiveness is desired for HEXme - 1300‰ hard cap - no expectations\r\n    uint256 public userShares = 1200;\r\n    // 60‰ representing the split in half margin shares, that go equally to the origin & the referrer (if exists)\r\n    // it might decrease counter accordingly to a possible user share increase - 10‰ min cap - no expectations\r\n    uint256 public marginShares = 60;\r\n\r\n    // GLOBALS:\r\n\r\n    struct GlobalsStore {\r\n        uint256 initDay;\r\n        uint256 exitLobbyPointer;\r\n        uint256 minimumEntryAmount;\r\n        uint256 totalContractsExitedHEX;\r\n        uint256 totalUsersExitedHEX;\r\n    }\r\n\r\n    GlobalsStore public globals;\r\n\r\n    struct HEXmeLobbyEntryQueueStore {\r\n        uint40 headIndex;\r\n        uint40 tailIndex;\r\n    }\r\n\r\n    // MAPPINGS:\r\n\r\n    // Day --> HEXme Lobby ETH amount\r\n    mapping(uint256 => uint256) public HEXmeLobbyETHperDay;\r\n    // Day --> HEXme Lobby HEX amount\r\n    mapping(uint256 => uint256) public HEXmeLobbyHEXperDay;\r\n    // Day --> HEXme Lobby ETH amount per entry\r\n    mapping(uint256 => uint256[]) public HEXmeLobbyETHperDayEntries;\r\n    // Address --> Day --> HEXme Users Lobby ETH amount\r\n    mapping(address => mapping(uint256 => uint256)) public HEXmeUsersLobbyETHperDay;\r\n    // Day --> LobbyQueueStore\r\n    mapping(uint256 => HEXmeLobbyEntryQueueStore) public HEXmeLobbyEntryQueue;\r\n\r\n    // user --> referrer\r\n    mapping(address => address) private referredForever;\r\n    // referee --> day since referral exists\r\n    mapping(address => uint256) private referredSince;\r\n\r\n    // EVENTS:\r\n\r\n    event EnteredLobby(uint256 lobbyDay, address indexed user, address indexed referrer, uint256 enteredETH);\r\n    event ExitedLobby(uint256 lobbyDay, address indexed user, address indexed referrer, uint256 usersHEX, uint256 referrersHEX, uint256 exitedETH);\r\n    event ExitedOnBehalf(uint256 lobbyDay, address indexed user, address indexed sender);\r\n    event NewReferral(address indexed referrer, address referee, uint256 currentDay);\r\n\r\n    event ContractFullyExitedLobbyDay(uint256 lobbyDay, uint256 currentDay);\r\n    event MovedExitLobbyPointer(uint256 from, uint256 to, uint256 currentDay);\r\n    event ChangedMinimumEntryAmount(uint256 from, uint256 to, uint256 currentDay);\r\n    event RaisedUserShares(uint256 userShares, uint256 marginShares, uint256 currentDay);\r\n    event FlushedExceedingHEX(uint256 exceedingHEX, uint256 currentDay);\r\n\r\n    // ONLY ORIGIN MODIFIER:\r\n\r\n    modifier onlyOrigin {\r\n        require(msg.sender == ORIGIN_ADDR, \"HEXme: only ORIGIN_ADDR\");\r\n        _;\r\n    }\r\n\r\n    constructor() public payable {\r\n        uint256 initBufferEntryAmount = 1000000000000000;\r\n        require(msg.value == initBufferEntryAmount);\r\n\r\n        globals.minimumEntryAmount = initBufferEntryAmount;\r\n        globals.initDay = HEX.currentDay();\r\n        globals.exitLobbyPointer = globals.initDay;\r\n\r\n        _enterLobby(address(0));\r\n\r\n        globals.minimumEntryAmount = 25000000000000000;\r\n    }\r\n\r\n    receive() external payable {\r\n        _enterLobby(ORIGIN_ADDR);\r\n    }\r\n\r\n    function enterLobby() external payable {\r\n        _enterLobby(address(0));\r\n    }\r\n\r\n    function enterLobbyWithReferrer(address referrer) external payable {\r\n        _enterLobby(referrer);\r\n    }\r\n\r\n    function _enterLobby(address referrer) private {\r\n        require(msg.value >= globals.minimumEntryAmount, \"HEXme: below minimumEntryAmount\");\r\n\r\n        HEX.xfLobbyEnter{value : msg.value}(address(this));\r\n\r\n        uint256 currentDay = HEX.currentDay();\r\n\r\n        _updateReferrer(referrer, currentDay);\r\n\r\n        HEXmeLobbyETHperDay[currentDay] += msg.value;\r\n        HEXmeUsersLobbyETHperDay[msg.sender][currentDay] += msg.value;\r\n        HEXmeLobbyETHperDayEntries[currentDay].push(msg.value);\r\n        HEXmeLobbyEntryQueue[currentDay].tailIndex++;\r\n\r\n        emit EnteredLobby(currentDay, msg.sender, referredForever[msg.sender], msg.value);\r\n    }\r\n\r\n    function _updateReferrer(address referrer, uint256 currentDay) private {\r\n        if (referrer != address(0) && referrer != msg.sender && !_isReferred(msg.sender)) {\r\n            referredForever[msg.sender] = referrer;\r\n            referredSince[msg.sender] = currentDay;\r\n            emit NewReferral(referrer, msg.sender, currentDay);\r\n        }\r\n    }\r\n\r\n    function _isReferred(address userAddress) private view returns (bool){\r\n        return (referredForever[userAddress] != address(0));\r\n    }\r\n\r\n    function exitLobby(uint256 lobbyDay) external {\r\n        uint256 currentDay = HEX.currentDay();\r\n        _exitLobby(msg.sender, lobbyDay, currentDay);\r\n    }\r\n\r\n    function exitLobbyOnBehalf(address userAddress, uint256 lobbyDay) external {\r\n        uint256 currentDay = HEX.currentDay();\r\n        require(\r\n            msg.sender == userAddress ||\r\n            (\r\n                (currentDay > CLAIM_PHASE_END_DAY.sub(7)) &&\r\n                (\r\n                    msg.sender == ORIGIN_ADDR ||\r\n                    (msg.sender == referredForever[userAddress] && lobbyDay >= referredSince[userAddress])\r\n                )\r\n            ),\r\n            \"HEXme: Only for incentivized users, from day 345 on\"\r\n        );\r\n        _exitLobby(userAddress, lobbyDay, currentDay);\r\n    }\r\n\r\n    function _exitLobby(address userAddress, uint256 lobbyDay, uint256 currentDay) private {\r\n        uint256 ETHtoExit = HEXmeUsersLobbyETHperDay[userAddress][lobbyDay];\r\n\r\n        require(lobbyDay < currentDay, \"HEXme: Day not complete\");\r\n        require(ETHtoExit > 0, \"HEXme: No entry from this user, this day\");\r\n\r\n        uint256 HEXtoExit = _getUsersHEXtoExit(userAddress, lobbyDay);\r\n        delete HEXmeUsersLobbyETHperDay[userAddress][lobbyDay];\r\n        globals.totalUsersExitedHEX += HEXtoExit;\r\n\r\n        _exitTillLiquidity(HEXtoExit, currentDay);\r\n        _payoutHEX(userAddress, HEXtoExit, ETHtoExit, lobbyDay);\r\n    }\r\n\r\n    function _getUsersHEXtoExit(address userAddress, uint256 lobbyDay) private returns (uint256 HEXtoExit){\r\n        _updateHEXmeLobbyHEXperDay(lobbyDay);\r\n        return ((HEXmeUsersLobbyETHperDay[userAddress][lobbyDay]\r\n            .mul(HEXmeLobbyHEXperDay[lobbyDay])).div(HEXmeLobbyETHperDay[lobbyDay]));\r\n    }\r\n\r\n    function _updateHEXmeLobbyHEXperDay(uint256 lobbyDay) private {\r\n        if (HEXmeLobbyHEXperDay[lobbyDay] == 0) {\r\n            uint256 HEXinLobby = _getHEXinLobby(lobbyDay);\r\n            if (HEXinLobby == 0) {\r\n                HEX.dailyDataUpdate(lobbyDay + 1);\r\n                HEXinLobby = _getHEXinLobby(lobbyDay);\r\n            }\r\n            uint256 basicHEXperDay =\r\n                (HEXinLobby.mul(HEXmeLobbyETHperDay[lobbyDay])).div(HEX.xfLobby(lobbyDay));\r\n                HEXmeLobbyHEXperDay[lobbyDay] = (basicHEXperDay.mul(totalShares)).div(basicShares);\r\n        }\r\n    }\r\n\r\n    function _getHEXinLobby(uint256 lobbyDay) private view returns (uint256 HEXinLobby){\r\n        if (lobbyDay >= 1) {\r\n            (,,uint256 dayUnclaimedSatoshisTotal) = HEX.dailyData(lobbyDay);\r\n            if (lobbyDay == HEX.currentDay()) {\r\n                dayUnclaimedSatoshisTotal = HEX.globalInfo()[7];\r\n            }\r\n            return dayUnclaimedSatoshisTotal * HEARTS_PER_SATOSHI / CLAIM_PHASE_DAYS;\r\n        } else {\r\n            // poor branch is never gonna see the daylight ;)\r\n            return WAAS_LOBBY_SEED_HEARTS;\r\n        }\r\n    }\r\n\r\n    function _exitTillLiquidity(uint256 liquidity, uint256 currentDay) private {\r\n        uint256 cachedExitLobbyPointer = globals.exitLobbyPointer;\r\n        uint40 cachedHeadIndex = HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex;\r\n\r\n        uint256 startIndex = HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex;\r\n        uint256 startLiquidity = HEX.balanceOf(address(this));\r\n        uint256 currentLiquidity = startLiquidity;\r\n\r\n        while (currentLiquidity < liquidity) {\r\n            if (cachedHeadIndex < HEXmeLobbyEntryQueue[cachedExitLobbyPointer].tailIndex) {\r\n                uint256 addedLiquidity =\r\n                    (HEXmeLobbyETHperDayEntries[cachedExitLobbyPointer][cachedHeadIndex]\r\n                    .mul(HEXmeLobbyHEXperDay[cachedExitLobbyPointer])).div(HEXmeLobbyETHperDay[cachedExitLobbyPointer]);\r\n\r\n                currentLiquidity = currentLiquidity.add(addedLiquidity);\r\n                cachedHeadIndex++;\r\n            } else {\r\n                if (cachedHeadIndex.sub(startIndex) > 0) {\r\n                    HEX.xfLobbyExit(cachedExitLobbyPointer, cachedHeadIndex.sub(startIndex));\r\n\r\n                    if (cachedHeadIndex == HEXmeLobbyEntryQueue[cachedExitLobbyPointer].tailIndex)\r\n                        emit ContractFullyExitedLobbyDay(cachedExitLobbyPointer, currentDay);\r\n                }\r\n\r\n                if(cachedHeadIndex != HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex)\r\n                    HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex = cachedHeadIndex;\r\n\r\n                cachedExitLobbyPointer++;\r\n\r\n                if (cachedExitLobbyPointer >= currentDay || cachedExitLobbyPointer >= CLAIM_PHASE_END_DAY)\r\n                    cachedExitLobbyPointer = globals.initDay;\r\n\r\n                cachedHeadIndex = HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex;\r\n                startIndex = cachedHeadIndex;\r\n            }\r\n        }\r\n\r\n        if (cachedHeadIndex.sub(startIndex) > 0) {\r\n            HEX.xfLobbyExit(cachedExitLobbyPointer, cachedHeadIndex.sub(startIndex));\r\n\r\n            if (cachedHeadIndex == HEXmeLobbyEntryQueue[cachedExitLobbyPointer].tailIndex)\r\n                emit ContractFullyExitedLobbyDay(cachedExitLobbyPointer, currentDay);\r\n        }\r\n\r\n        globals.totalContractsExitedHEX = globals.totalContractsExitedHEX.add(\r\n            HEX.balanceOf(address(this)).sub(startLiquidity));\r\n\r\n        if (HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex != cachedHeadIndex)\r\n            HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex = cachedHeadIndex;\r\n\r\n        if (globals.exitLobbyPointer != cachedExitLobbyPointer)\r\n            globals.exitLobbyPointer = cachedExitLobbyPointer;\r\n    }\r\n\r\n    function _payoutHEX(address userAddress, uint256 HEXtoExit, uint256 exitedETH, uint256 lobbyDay) private {\r\n        uint256 usersHEX = (HEXtoExit.mul(userShares)).div(totalShares);\r\n        uint256 marginHEX = HEXtoExit.sub(usersHEX);\r\n        uint256 referrersHEX = (_isReferred(userAddress) && lobbyDay >= referredSince[userAddress]) ?\r\n            (marginHEX.mul(marginShares)).div(totalShares.sub(userShares)) : 0;\r\n        uint256 originsHEX = marginHEX.sub(referrersHEX);\r\n\r\n        if (originsHEX > 0)\r\n            HEX.transfer(address(ORIGIN_ADDR), originsHEX);\r\n\r\n        if (referrersHEX > 0)\r\n            HEX.transfer(address(referredForever[userAddress]), referrersHEX);\r\n\r\n        if (usersHEX > 0)\r\n            HEX.transfer(userAddress, usersHEX);\r\n\r\n        emit ExitedLobby(lobbyDay, userAddress, referredForever[userAddress], usersHEX, referrersHEX, exitedETH);\r\n\r\n        if (msg.sender != userAddress)\r\n            emit ExitedOnBehalf(lobbyDay, userAddress, msg.sender);\r\n    }\r\n\r\n    function exitContractLobbyDay(uint256 lobbyDay, uint40 count) external {\r\n        uint256 startLiquidity = HEX.balanceOf(address(this));\r\n\r\n        HEX.xfLobbyExit(lobbyDay, count);\r\n\r\n        globals.totalContractsExitedHEX = globals.totalContractsExitedHEX.add(\r\n            HEX.balanceOf(address(this)).sub(startLiquidity));\r\n\r\n        if (count > 0)\r\n            HEXmeLobbyEntryQueue[lobbyDay].headIndex += count;\r\n        else\r\n            HEXmeLobbyEntryQueue[lobbyDay].headIndex = HEXmeLobbyEntryQueue[lobbyDay].tailIndex;\r\n\r\n        if (HEXmeLobbyEntryQueue[lobbyDay].headIndex == HEXmeLobbyEntryQueue[lobbyDay].tailIndex)\r\n            emit ContractFullyExitedLobbyDay(lobbyDay, HEX.currentDay());\r\n    }\r\n\r\n    function changeMinimumEntryAmount(uint256 newMinimumEntryAmount) external onlyOrigin {\r\n        require(10000000000000000 <= newMinimumEntryAmount && newMinimumEntryAmount <= 50000000000000000, \"HEXme: INV VAL\");\r\n\r\n        emit ChangedMinimumEntryAmount(globals.minimumEntryAmount, newMinimumEntryAmount, HEX.currentDay());\r\n\r\n        globals.minimumEntryAmount = newMinimumEntryAmount;\r\n    }\r\n\r\n    function raiseUserShares(uint256 newUserSharesInPerMill) external onlyOrigin {\r\n        require(newUserSharesInPerMill.add(20) <= totalShares, \"HEXme: 1300 CAP\");\r\n        require(newUserSharesInPerMill > userShares, \"HEXme: INCREASE\");\r\n\r\n        marginShares = (totalShares.sub(newUserSharesInPerMill)).div(2);\r\n        userShares = totalShares.sub(marginShares.mul(2));\r\n\r\n        emit RaisedUserShares(userShares, marginShares, HEX.currentDay());\r\n    }\r\n\r\n    function moveExitLobbyPointer(uint256 newLobbyPointerDay) external onlyOrigin {\r\n        require(newLobbyPointerDay >= globals.initDay && newLobbyPointerDay < HEX.currentDay(), \"HEXme: INV VAL\");\r\n\r\n        emit MovedExitLobbyPointer(globals.exitLobbyPointer, newLobbyPointerDay, HEX.currentDay());\r\n\r\n        globals.exitLobbyPointer = newLobbyPointerDay;\r\n    }\r\n\r\n    function flushExceedingHEX() external onlyOrigin {\r\n        uint256 currentLiquidity = HEX.balanceOf(address(this));\r\n        uint256 reservedLiquidity = globals.totalContractsExitedHEX.sub(globals.totalUsersExitedHEX);\r\n        uint256 exceedingLiquidity = (currentLiquidity.sub(reservedLiquidity)).sub(HEARTS_PER_HEX);\r\n\r\n        require(exceedingLiquidity > 0, \"HEXme: 0 Exceeding\");\r\n\r\n        HEX.transfer(ORIGIN_ADDR, exceedingLiquidity);\r\n        emit FlushedExceedingHEX(exceedingLiquidity, HEX.currentDay());\r\n    }\r\n\r\n    function flushERC20(IERC20 _token) external onlyOrigin {\r\n        require(_token.balanceOf(address(this)) > 0, \"HEXme: 0 BAL\");\r\n        require(address(_token) != address(HEX), \"HEXme: !HEX\");\r\n        _token.transfer(ORIGIN_ADDR, _token.balanceOf(address(this)));\r\n    }\r\n\r\n    // EXTERNAL VIEW HELPERS:\r\n\r\n    function getCurrentDay() external view returns (uint256) {\r\n        return HEX.currentDay();\r\n    }\r\n\r\n    function getHEXinLobby(uint256 lobbyDay) external view returns (uint256){\r\n        return _getHEXinLobby(lobbyDay);\r\n    }\r\n\r\n    function getHistoricLobby(bool getHEXInsteadETH) external view returns (uint256[] memory){\r\n        uint256 tillDay = HEX.currentDay();\r\n        tillDay = (tillDay <= CLAIM_PHASE_END_DAY) ? tillDay : CLAIM_PHASE_END_DAY;\r\n        uint256[] memory historicLobby = new uint256[](tillDay + 1);\r\n        for (uint256 i = 0; i <= tillDay; i++) {\r\n            if (getHEXInsteadETH)\r\n                historicLobby[i] = _getHEXinLobby(i);\r\n            else\r\n                historicLobby[i] = HEX.xfLobby(i);\r\n        }\r\n        return historicLobby;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentDay\",\"type\":\"uint256\"}],\"name\":\"ChangedMinimumEntryAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lobbyDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentDay\",\"type\":\"uint256\"}],\"name\":\"ContractFullyExitedLobbyDay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lobbyDay\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"enteredETH\",\"type\":\"uint256\"}],\"name\":\"EnteredLobby\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lobbyDay\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usersHEX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrersHEX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exitedETH\",\"type\":\"uint256\"}],\"name\":\"ExitedLobby\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lobbyDay\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ExitedOnBehalf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exceedingHEX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentDay\",\"type\":\"uint256\"}],\"name\":\"FlushedExceedingHEX\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentDay\",\"type\":\"uint256\"}],\"name\":\"MovedExitLobbyPointer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentDay\",\"type\":\"uint256\"}],\"name\":\"NewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marginShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentDay\",\"type\":\"uint256\"}],\"name\":\"RaisedUserShares\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HEX\",\"outputs\":[{\"internalType\":\"contract IHEX\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"HEXmeLobbyETHperDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"HEXmeLobbyETHperDayEntries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"HEXmeLobbyEntryQueue\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"headIndex\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"tailIndex\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"HEXmeLobbyHEXperDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"HEXmeUsersLobbyETHperDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORIGIN_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basicShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinimumEntryAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinimumEntryAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enterLobby\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"enterLobbyWithReferrer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lobbyDay\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"count\",\"type\":\"uint40\"}],\"name\":\"exitContractLobbyDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lobbyDay\",\"type\":\"uint256\"}],\"name\":\"exitLobby\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lobbyDay\",\"type\":\"uint256\"}],\"name\":\"exitLobbyOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"flushERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flushExceedingHEX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lobbyDay\",\"type\":\"uint256\"}],\"name\":\"getHEXinLobby\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"getHEXInsteadETH\",\"type\":\"bool\"}],\"name\":\"getHistoricLobby\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exitLobbyPointer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumEntryAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalContractsExitedHEX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUsersExitedHEX\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marginShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLobbyPointerDay\",\"type\":\"uint256\"}],\"name\":\"moveExitLobbyPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newUserSharesInPerMill\",\"type\":\"uint256\"}],\"name\":\"raiseUserShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"HEXme","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7bbd8bf5186ad05f1dc057fa916562f7f086cd33dd5d4d57529a334f6fad9aa3"}]}