{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.8; // optimization runs: 200, evm version: istanbul\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface BotCommanderV1Interface {\r\n  event DaiToEthLimitOrderProcessed(\r\n    address indexed smartWallet, uint256 daiGiven, uint256 etherReceived\r\n  );\r\n  event EthToDaiLimitOrderProcessed(\r\n    address indexed smartWallet, uint256 etherGiven, uint256 daiReceived\r\n  );\r\n  event RoleModified(Role indexed role, address account);\r\n  event RolePaused(Role indexed role);\r\n  event RoleUnpaused(Role indexed role);\r\n\r\n  enum Role {\r\n    BOT_COMMANDER,\r\n    PAUSER\r\n  }\r\n\r\n  struct RoleStatus {\r\n    address account;\r\n    bool paused;\r\n  }\r\n\r\n  struct DaiToEthArguments {\r\n    address payable smartWallet;\r\n    uint256 dDaiAmountToApprove;\r\n    uint256 daiUnderlyingAmountToGive; // lower than maximum for partial fills\r\n    uint256 maximumDaiUnderlyingAmountToGive;\r\n    uint256 maximumEthPriceToAccept; // represented as a mantissa (n * 10^18)\r\n    uint256 expiration;\r\n    bytes32 salt;\r\n    bytes approvalSignatures;\r\n    bytes executionSignatures;\r\n    address tradeTarget;\r\n    bytes tradeData;\r\n  }\r\n\r\n  function redeemDDaiAndProcessDaiToEthLimitOrder(\r\n    DaiToEthArguments calldata args\r\n  ) external returns (uint256 etherReceived);\r\n\r\n  struct EthToDaiArguments {\r\n    address smartWallet;\r\n    uint256 etherAmountToGive; // will be lower than maximum for partial fills\r\n    uint256 maximumEtherAmountToGive;\r\n    uint256 minimumEtherPriceToAccept; // represented as a mantissa (n * 10^18)\r\n    uint256 expiration;\r\n    bytes32 salt;\r\n    bytes approvalSignatures;\r\n    bytes executionSignatures;\r\n    address tradeTarget;\r\n    bytes tradeData;\r\n  }\r\n\r\n  function processEthToDaiLimitOrderAndMintDDai(\r\n    EthToDaiArguments calldata args\r\n  ) external returns (uint256 tokensReceived);\r\n\r\n  function cancelDaiToEthLimitOrder(\r\n    address smartWallet,\r\n    uint256 maximumDaiUnderlyingAmountToGive,\r\n    uint256 maximumEthPriceToAccept, // represented as a mantissa (n * 10^18)\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external returns (bool success);\r\n\r\n  function cancelEthToDaiLimitOrder(\r\n    address smartWallet,\r\n    uint256 maximumEtherAmountToGive,\r\n    uint256 minimumEtherPriceToAccept, // represented as a mantissa (n * 10^18)\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external returns (bool success);\r\n\r\n  function setRole(Role role, address account) external;\r\n\r\n  function removeRole(Role role) external;\r\n\r\n  function pause(Role role) external;\r\n\r\n  function unpause(Role role) external;\r\n\r\n  function isPaused(Role role) external view returns (bool paused);\r\n\r\n  function isRole(Role role) external view returns (bool hasRole);\r\n\r\n  function getMetaTransactionMessageHash(\r\n    bytes4 functionSelector,\r\n    bytes calldata arguments,\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external view returns (bytes32 messageHash, bool valid);\r\n\r\n  function getBotCommander() external view returns (address botCommander);\r\n\r\n  function getPauser() external view returns (address pauser);\r\n}\r\n\r\n\r\ninterface ERC1271Interface {\r\n  function isValidSignature(\r\n    bytes calldata data, bytes calldata signatures\r\n  ) external view returns (bytes4 magicValue);\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n  function transfer(address, uint256) external returns (bool);\r\n  function approve(address, uint256) external returns (bool);\r\n  function balanceOf(address) external view returns (uint256);\r\n  function allowance(address, address) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface DTokenInterface {\r\n  function mint(\r\n    uint256 underlyingToSupply\r\n  ) external returns (uint256 dTokensMinted);\r\n  function redeemUnderlying(\r\n    uint256 underlyingToReceive\r\n  ) external returns (uint256 dTokensBurned);\r\n  function transfer(address, uint256) external returns (bool);\r\n  function transferUnderlyingFrom(\r\n    address sender, address recipient, uint256 underlyingEquivalentAmount\r\n  ) external returns (bool success);\r\n  function modifyAllowanceViaMetaTransaction(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    bool increase,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external returns (bool success);\r\n\r\n  function getMetaTransactionMessageHash(\r\n    bytes4 functionSelector,\r\n    bytes calldata arguments,\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external view returns (bytes32 digest, bool valid);\r\n  function allowance(address, address) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface EtherizerV2Interface {\r\n  function transferFrom(\r\n    address from, address to, uint256 value\r\n  ) external returns (bool);\r\n  function modifyAllowanceViaMetaTransaction(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    bool increase,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes calldata signatures\r\n  ) external returns (bool success);\r\n\r\n  function getMetaTransactionMessageHash(\r\n    bytes4 functionSelector,\r\n    bytes calldata arguments,\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external view returns (bytes32 digest, bool valid);\r\n  function allowance(\r\n    address owner, address spender\r\n  ) external view returns (uint256 amount);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n\r\n    return a - b;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    return a / b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @notice Contract module which provides a basic access control mechanism,\r\n * where there is an account (an owner) that can be granted exclusive access\r\n * to specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n *\r\n * In order to transfer ownership, a recipient must be specified, at which point\r\n * the specified recipient can call `acceptOwnership` and take ownership.\r\n */\r\ncontract TwoStepOwnable {\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  address private _owner;\r\n\r\n  address private _newPotentialOwner;\r\n\r\n  /**\r\n   * @notice Initialize contract with transaction submitter as initial owner.\r\n   */\r\n  constructor() internal {\r\n    _owner = tx.origin;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows a new account (`newOwner`) to accept ownership.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    require(\r\n      newOwner != address(0),\r\n      \"TwoStepOwnable: new potential owner is the zero address.\"\r\n    );\r\n\r\n    _newPotentialOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @notice Cancel a transfer of ownership to a new account.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function cancelOwnershipTransfer() external onlyOwner {\r\n    delete _newPotentialOwner;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers ownership of the contract to the caller.\r\n   * Can only be called by a new potential owner set by the current owner.\r\n   */\r\n  function acceptOwnership() external {\r\n    require(\r\n      msg.sender == _newPotentialOwner,\r\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\r\n    );\r\n\r\n    delete _newPotentialOwner;\r\n\r\n    emit OwnershipTransferred(_owner, msg.sender);\r\n\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the current owner.\r\n   */\r\n  function owner() external view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title BotCommanderV1\r\n * @author 0age\r\n * @notice BotCommander is a contract for performing meta-transaction-enabled\r\n * limit orders against external automated money markets or other sources of\r\n * on-chain liquidity. V1 only supports trades between Dharma Dai and Ether â€”\r\n * Eth-to-dDai trades require that `triggerEtherTransfer` is implemented on\r\n * the account making the trade, and all trades require that they implement\r\n * the `isValidSignature` function specified by ERC-1271 for enabling\r\n * meta-transaction functionality.\r\n */\r\ncontract BotCommanderV1 is BotCommanderV1Interface, TwoStepOwnable {\r\n  using SafeMath for uint256;\r\n\r\n  // Maintain a role status mapping with assigned accounts and paused states.\r\n  mapping(uint256 => RoleStatus) private _roles;\r\n\r\n  // Maintain a mapping of invalid meta-transaction message hashes.\r\n  mapping (bytes32 => bool) private _invalidMetaTxHashes;\r\n\r\n  ERC20Interface internal constant _DAI = ERC20Interface(\r\n    0x6B175474E89094C44Da98b954EedeAC495271d0F\r\n  );\r\n\r\n  DTokenInterface internal constant _DDAI = DTokenInterface(\r\n    0x00000000001876eB1444c986fD502e618c587430\r\n  );\r\n\r\n  EtherizerV2Interface internal constant _ETH = EtherizerV2Interface(\r\n    0x723B51b72Ae89A3d0c2a2760f0458307a1Baa191\r\n  );\r\n\r\n  constructor() public {\r\n    // Approve dDai to transfer Dai on behalf of this contract in order to mint.\r\n    _DAI.approve(address(_DDAI), type(uint256).max);\r\n  }\r\n\r\n  receive() external payable {}\r\n\r\n  /**\r\n   * @notice Only callable by the bot commander or the owner. Enforces the\r\n   * expiration (or skips if it is set to zero), validates the execution\r\n   * signatures using ERC-1271 against the smart wallet, initiates an\r\n   * approval meta-transaction against Dharma Dai, pulls in the necessary\r\n   * Dharma Dai, redeems it for Dai, sets an allowance for the provided\r\n   * trade target, calls the trade target with the supplied trade data,\r\n   * ensures that the call was successful, calculates the required Ether\r\n   * that must be received back based on the specified Dai amount and price,\r\n   * ensures that at least that amount was returned, sends it to the smart\r\n   * wallet, and emits an event.\r\n   * @return etherReceived The amount of Ether received from the trade.\r\n   */\r\n  function redeemDDaiAndProcessDaiToEthLimitOrder(\r\n    DaiToEthArguments calldata args\r\n  ) external override onlyOwnerOr(Role.BOT_COMMANDER) returns (\r\n    uint256 etherReceived\r\n  ) {\r\n    _enforceExpiration(args.expiration);\r\n\r\n    // Construct the meta-transaction's \"context\" information and validate it.\r\n    bytes memory context = _constructContext(\r\n      this.redeemDDaiAndProcessDaiToEthLimitOrder.selector,\r\n      args.expiration,\r\n      args.salt,\r\n      abi.encode(\r\n        args.smartWallet,\r\n        args.maximumDaiUnderlyingAmountToGive,\r\n        args.maximumEthPriceToAccept\r\n      )\r\n    );\r\n    _validateMetaTransaction(\r\n      args.smartWallet, context, args.executionSignatures\r\n    );\r\n\r\n    // try call to `modifyAllowanceViaMetaTransaction` on dDai\r\n    _tryApprovalViaMetaTransaction(\r\n      address(_DDAI),\r\n      args.smartWallet,\r\n      args.dDaiAmountToApprove,\r\n      args.expiration,\r\n      args.salt,\r\n      args.approvalSignatures\r\n    );\r\n\r\n    // Make the transfer in.\r\n    bool ok = _DDAI.transferUnderlyingFrom(\r\n      args.smartWallet, address(this), args.daiUnderlyingAmountToGive\r\n    );\r\n    require(ok, \"Dharma Dai transfer in failed.\");\r\n\r\n    // redeem dDai for Dai\r\n    _DDAI.redeemUnderlying(args.daiUnderlyingAmountToGive);\r\n\r\n    // Ensure that target has allowance to transfer tokens.\r\n    if (_DAI.allowance(address(this), args.tradeTarget) != type(uint256).max) {\r\n      _DAI.approve(args.tradeTarget, type(uint256).max);\r\n    }\r\n\r\n    // Call into the provided target, providing data.\r\n    (ok,) = args.tradeTarget.call(args.tradeData);\r\n\r\n    // Revert with reason if the call was not successful.\r\n    _revertOnFailure(ok);\r\n\r\n    // Determine the total Ether balance of this contract.\r\n    etherReceived = address(this).balance;\r\n\r\n    // Determine minumum ether required based on given Dai and price.\r\n    uint256 etherExpected = (args.daiUnderlyingAmountToGive.mul(1e18)).div(\r\n      args.maximumEthPriceToAccept\r\n    );\r\n\r\n    // Ensure that enough Ether was received.\r\n    require(\r\n      etherReceived >= etherExpected,\r\n      \"Trade did not result in the expected amount of Ether.\"\r\n    );\r\n\r\n    // Transfer the Ether to the smart wallet and revert on failure.\r\n    (ok, ) = args.smartWallet.call{value: etherReceived}(\"\");\r\n\r\n     // Revert with reason if the call was not successful.\r\n    _revertOnFailure(ok);\r\n\r\n    emit DaiToEthLimitOrderProcessed(\r\n      args.smartWallet, args.daiUnderlyingAmountToGive, etherReceived\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Only callable by the bot commander or the owner. Enforces the\r\n   * expiration (or skips if it is set to zero), validates the execution\r\n   * signatures using ERC-1271 against the smart wallet, initiates an\r\n   * approval meta-transaction against EtherizerV2, pulls in the necessary\r\n   * Ether, calls the trade target with available ether and the supplied data,\r\n   * ensures that the call was successful, calculates the required Dai\r\n   * that must be received back based on the specified Ether amount and price,\r\n   * ensures that at least that amount was returned, mints Dharma Dai, sends it\r\n   * to the smart wallet, and emits an event.\r\n   * @return daiReceived The amount of Dai received from the trade.\r\n   */\r\n  function processEthToDaiLimitOrderAndMintDDai(\r\n    EthToDaiArguments calldata args\r\n  ) external override onlyOwnerOr(Role.BOT_COMMANDER) returns (\r\n    uint256 daiReceived\r\n  ) {\r\n    _enforceExpiration(args.expiration);\r\n\r\n    // Construct the meta-transaction's \"context\" information and validate it.\r\n    bytes memory context = _constructContext(\r\n      this.redeemDDaiAndProcessDaiToEthLimitOrder.selector,\r\n      args.expiration,\r\n      args.salt,\r\n      abi.encode(\r\n        args.smartWallet,\r\n        args.maximumEtherAmountToGive,\r\n        args.minimumEtherPriceToAccept\r\n      )\r\n    );\r\n    _validateMetaTransaction(\r\n      args.smartWallet, context, args.executionSignatures\r\n    );\r\n\r\n    // try call to `modifyAllowanceViaMetaTransaction` on dDai\r\n    _tryApprovalViaMetaTransaction(\r\n      address(_ETH),\r\n      args.smartWallet,\r\n      args.maximumEtherAmountToGive,\r\n      args.expiration,\r\n      args.salt,\r\n      args.approvalSignatures\r\n    );\r\n\r\n    // call `transferFrom` on Etherizer, moving funds in from smart wallet\r\n    bool ok = _ETH.transferFrom(\r\n        args.smartWallet, address(this), args.etherAmountToGive\r\n    );\r\n    require(ok, \"Ether transfer in failed.\");\r\n\r\n    // Call into the provided target, supplying ETH and data.\r\n    (ok,) = args.tradeTarget.call{value: address(this).balance}(args.tradeData);\r\n\r\n    // Revert with reason if the call was not successful.\r\n    _revertOnFailure(ok);\r\n\r\n    // Determine the total Dai balance of this contract.\r\n    daiReceived = _DAI.balanceOf(address(this));\r\n\r\n    // Determine expected amount of Dai based on minimum ether price supplied.\r\n    uint256 daiExpected = args.etherAmountToGive.mul(\r\n      args.minimumEtherPriceToAccept\r\n    ) / 1e18;\r\n\r\n    // Ensure that enough Dai was received.\r\n    require(\r\n      daiReceived >= daiExpected,\r\n      \"Trade did not result in the expected amount of Dai.\"\r\n    );\r\n\r\n    uint256 dDaiReceived = _DDAI.mint(daiReceived);\r\n\r\n    // Transfer the dDai to the caller and revert on failure.\r\n    ok = (_DDAI.transfer(msg.sender, dDaiReceived));\r\n    require(ok, \"Dharma Dai transfer out failed.\");\r\n\r\n    emit EthToDaiLimitOrderProcessed(\r\n      args.smartWallet, args.etherAmountToGive, daiReceived\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Cancels a potential Dai-to-Eth limit order. Only the smart wallet\r\n   * in question or the bot controller may call this.\r\n   * @param expiration uint256 A timestamp indicating how long the modification\r\n   * meta-transaction is valid for - a value of zero will signify no expiration.\r\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\r\n   * to the hash digest used to validate the signatures.\r\n   * @return success A boolean indicating whether the cancellation was\r\n   * successful.\r\n   */\r\n  function cancelDaiToEthLimitOrder(\r\n    address smartWallet,\r\n    uint256 maximumDaiUnderlyingAmountToGive,\r\n    uint256 maximumEthPriceToAccept, // represented as a mantissa (n * 10^18)\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external override returns (bool success) {\r\n    _enforceExpiration(expiration);\r\n    _enforceValidCanceller(smartWallet);\r\n\r\n    // Construct the meta-transaction's \"context\" information.\r\n    bytes memory context = _constructContext(\r\n      this.redeemDDaiAndProcessDaiToEthLimitOrder.selector,\r\n      expiration,\r\n      salt,\r\n      abi.encode(\r\n        smartWallet, maximumDaiUnderlyingAmountToGive, maximumEthPriceToAccept\r\n      )\r\n    );\r\n\r\n    // Construct the message hash using the provided context.\r\n    bytes32 messageHash = keccak256(context);\r\n\r\n    // Ensure message hash has not been used or cancelled and invalidate it.\r\n    require(\r\n      !_invalidMetaTxHashes[messageHash], \"Meta-transaction already invalid.\"\r\n    );\r\n    _invalidMetaTxHashes[messageHash] = true;\r\n\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Cancels a potential Dai-to-Eth limit order. Only the smart wallet\r\n   * in question or the bot controller may call this.\r\n   * @param expiration uint256 A timestamp indicating how long the modification\r\n   * meta-transaction is valid for - a value of zero will signify no expiration.\r\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\r\n   * to the hash digest used to validate the signatures.\r\n   * @return success A boolean indicating whether the cancellation was\r\n   * successful.\r\n   */\r\n  function cancelEthToDaiLimitOrder(\r\n    address smartWallet,\r\n    uint256 maximumEtherAmountToGive,\r\n    uint256 minimumEtherPriceToAccept, // represented as a mantissa (n * 10^18)\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external override returns (bool success) {\r\n    _enforceExpiration(expiration);\r\n\r\n    _enforceValidCanceller(smartWallet);\r\n\r\n    // Construct the meta-transaction's \"context\" information.\r\n    bytes memory context = _constructContext(\r\n      this.redeemDDaiAndProcessDaiToEthLimitOrder.selector,\r\n      expiration,\r\n      salt,\r\n      abi.encode(\r\n        smartWallet, maximumEtherAmountToGive, minimumEtherPriceToAccept\r\n      )\r\n    );\r\n\r\n    // Construct the message hash using the provided context.\r\n    bytes32 messageHash = keccak256(context);\r\n\r\n    // Ensure message hash has not been used or cancelled and invalidate it.\r\n    require(\r\n      !_invalidMetaTxHashes[messageHash], \"Meta-transaction already invalid.\"\r\n    );\r\n    _invalidMetaTxHashes[messageHash] = true;\r\n\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\r\n   * the owner or the designated pauser may call this function. Also, bear in\r\n   * mind that only the owner may unpause a role once paused.\r\n   * @param role The role to pause.\r\n   */\r\n  function pause(Role role) external override onlyOwnerOr(Role.PAUSER) {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n    require(!storedRoleStatus.paused, \"Role in question is already paused.\");\r\n    storedRoleStatus.paused = true;\r\n    emit RolePaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\r\n   * Only the owner may call this function.\r\n   * @param role The role to pause.\r\n   */\r\n  function unpause(Role role) external override onlyOwner {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n    require(storedRoleStatus.paused, \"Role in question is already unpaused.\");\r\n    storedRoleStatus.paused = false;\r\n    emit RoleUnpaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new account on a given role and emit a `RoleModified` event\r\n   * if the role holder has changed. Only the owner may call this function.\r\n   * @param role The role that the account will be set for.\r\n   * @param account The account to set as the designated role bearer.\r\n   */\r\n  function setRole(Role role, address account) external override onlyOwner {\r\n    require(account != address(0), \"Must supply an account.\");\r\n    _setRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove any current role bearer for a given role and emit a\r\n   * `RoleModified` event if a role holder was previously set. Only the owner\r\n   * may call this function.\r\n   * @param role The role that the account will be removed from.\r\n   */\r\n  function removeRole(Role role) external override onlyOwner {\r\n    _setRole(role, address(0));\r\n  }\r\n\r\n  /**\r\n   * @notice View function to determine a meta-transaction message hash, and to\r\n   * determine if it is still valid (i.e. it has not yet been used and is not\r\n   * expired). The returned message hash will need to be prefixed using EIP-191\r\n   * 0x45 and hashed again in order to generate a final digest for the required\r\n   * signature - in other words, the same procedure utilized by `eth_Sign`.\r\n   * @param functionSelector bytes4 The function selector for the given\r\n   * meta-transaction. There are two function selectors available for V1:\r\n   *  1. 0x03f9dae5: `redeemDDaiAndProcessDaiToEthLimitOrder`\r\n   *  2. 0x088263dd: `processEthToDaiLimitOrderAndMintDDai`\r\n   * @param arguments bytes The abi-encoded function arguments (aside from the\r\n   * `expiration`, `salt`, and `signatures` arguments) that should be supplied\r\n   * to the given function. There are three arguments for each function: the\r\n   * smart wallet address, the maximum amount that the wallet is willing to\r\n   * trade, and the limit price (denominated as the price in Dai for 1 Ether,\r\n   * multiplied by 10^18).\r\n   * @param expiration uint256 A timestamp indicating how long the given\r\n   * meta-transaction is valid for - a value of zero will signify no expiration.\r\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\r\n   * to the hash digest used to validate the signatures.\r\n   * @return messageHash The message hash corresponding to the meta-transaction.\r\n   */\r\n  function getMetaTransactionMessageHash(\r\n    bytes4 functionSelector,\r\n    bytes calldata arguments,\r\n    uint256 expiration,\r\n    bytes32 salt\r\n  ) external view override returns (bytes32 messageHash, bool valid) {\r\n    // Construct the meta-transaction's message hash based on relevant context.\r\n    messageHash = keccak256(\r\n      abi.encodePacked(\r\n        address(this), functionSelector, expiration, salt, arguments\r\n      )\r\n    );\r\n\r\n    // The meta-transaction is valid if it has not been used and is not expired.\r\n    valid = (\r\n      !_invalidMetaTxHashes[messageHash] && (\r\n        expiration == 0 || now <= expiration\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether or not the functionality\r\n   * associated with a given role is currently paused or not. The owner or the\r\n   * pauser may pause any given role (including the pauser itself), but only the\r\n   * owner may unpause functionality. Additionally, the owner may call paused\r\n   * functions directly.\r\n   * @param role The role to check the pause status on.\r\n   * @return paused A boolean to indicate if the functionality associated with\r\n   * the role in question is currently paused.\r\n   */\r\n  function isPaused(Role role) external view override returns (bool paused) {\r\n    paused = _isPaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether the caller is the current\r\n   * role holder.\r\n   * @param role The role to check for.\r\n   * @return hasRole A boolean indicating if the caller has the specified role.\r\n   */\r\n  function isRole(Role role) external view override returns (bool hasRole) {\r\n    hasRole = _isRole(role);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * bot commander role. The bot commander can execute and cancel limit orders.\r\n   * @return botCommander The address of the current bot commander, or the null\r\n   * address if none is set.\r\n   */\r\n  function getBotCommander() external view override returns (\r\n    address botCommander\r\n  ) {\r\n    botCommander = _roles[uint256(Role.BOT_COMMANDER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * pauser role. The pauser can pause any role from taking its standard action,\r\n   * though the owner will still be able to call the associated function in the\r\n   * interim and is the only entity able to unpause the given role once paused.\r\n   * @return pauser The address of the current pauser, or the null address if\r\n   * none is set.\r\n   */\r\n  function getPauser() external view override returns (address pauser) {\r\n    pauser = _roles[uint256(Role.PAUSER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to enforce that a given Meta-transaction\r\n   * has not been used before and that the signature is valid according\r\n   * to the owner (using ERC-1271).\r\n   * @param owner address The account originating the meta-transaction.\r\n   * @param context bytes Information about the meta-transaction.\r\n   * @param signatures bytes Signature or signatures used to validate\r\n   * the meta-transaction.\r\n   */\r\n  function _validateMetaTransaction(\r\n    address owner, bytes memory context, bytes memory signatures\r\n  ) private {\r\n    // Construct the message hash using the provided context.\r\n    bytes32 messageHash = keccak256(context);\r\n\r\n    // Ensure message hash has not been used or cancelled and invalidate it.\r\n    require(\r\n      !_invalidMetaTxHashes[messageHash], \"Meta-transaction no longer valid.\"\r\n    );\r\n    _invalidMetaTxHashes[messageHash] = true;\r\n\r\n    // Construct the digest to compare signatures against using EIP-191 0x45.\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\r\n    );\r\n\r\n    // Validate via ERC-1271 against the owner account.\r\n    bytes memory data = abi.encode(digest, context);\r\n    bytes4 magic = ERC1271Interface(owner).isValidSignature(data, signatures);\r\n    require(magic == bytes4(0x20c13b0b), \"Invalid signatures.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to set an approval, or to continue if a given\r\n   * meta-transaction has been used for an approval before but allowance is still\r\n   * set (for instance, by a griefer that has lifted it from calldata while the\r\n   * transaction is still in the mempool and used it to frontrun the call). If\r\n   * one of these steps fails, revert.\r\n   * @param ownerSmartWallet address The wallet of the owner.\r\n   * @param value uint256 The amount of dDai to approve.\r\n   * @param expiration uint256 The timestamp where the meta-transaction expires.\r\n   * @param salt bytes32 The salt associated with the meta-transaction.\r\n   * @param signatures bytes The signature or signatures associated with the\r\n   * meta-transaction.\r\n   */\r\n  function _tryApprovalViaMetaTransaction(\r\n    address approver,\r\n    address ownerSmartWallet,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes memory signatures\r\n  ) private {\r\n    // Attempt to modify the allowance.\r\n    (bool ok, bytes memory returnData) = approver.call(\r\n      abi.encodeWithSelector(\r\n        _DDAI.modifyAllowanceViaMetaTransaction.selector,\r\n        ownerSmartWallet,\r\n        address(this),\r\n        value,\r\n        true, // increase\r\n        expiration,\r\n        salt,\r\n        signatures\r\n      )\r\n    );\r\n\r\n    // Protect against griefing via frontrunning by handling specific reverts.\r\n    if (!ok) {\r\n      DTokenInterface approverContract = DTokenInterface(approver);\r\n      // Determine whether the meta-transaction in question has been used yet.\r\n      (, bool valid) = approverContract.getMetaTransactionMessageHash(\r\n        _DDAI.modifyAllowanceViaMetaTransaction.selector,\r\n        abi.encode(ownerSmartWallet, address(this), value, true),\r\n        expiration,\r\n        salt\r\n      );\r\n\r\n      // Revert with the original message if it has not been used.\r\n      if (valid) {\r\n        assembly { revert(add(32, returnData), mload(returnData)) }\r\n      }\r\n\r\n      // If it has been used, determine if there is still sufficient allowance.\r\n      uint256 allowance = approverContract.allowance(\r\n        ownerSmartWallet, address(this)\r\n      );\r\n\r\n      // Revert with the original message if allowance is insufficient.\r\n      if (allowance < value) {\r\n        assembly { revert(add(32, returnData), mload(returnData)) }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to set a new account on a given role and emit a\r\n   * `RoleModified` event if the role holder has changed.\r\n   * @param role The role that the account will be set for.\r\n   * @param account The account to set as the designated role bearer.\r\n   */\r\n  function _setRole(Role role, address account) private {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n\r\n    if (account != storedRoleStatus.account) {\r\n      storedRoleStatus.account = account;\r\n      emit RoleModified(role, account);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to check whether the caller is the current\r\n   * role holder.\r\n   * @param role The role to check for.\r\n   * @return hasRole A boolean indicating if the caller has the specified role.\r\n   */\r\n  function _isRole(Role role) private view returns (bool hasRole) {\r\n    hasRole = msg.sender == _roles[uint256(role)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to check whether the given role is paused or\r\n   * not.\r\n   * @param role The role to check for.\r\n   * @return paused A boolean indicating if the specified role is paused or not.\r\n   */\r\n  function _isPaused(Role role) private view returns (bool paused) {\r\n    paused = _roles[uint256(role)].paused;\r\n  }\r\n\r\n  function _constructContext(\r\n    bytes4 functionSelector,\r\n    uint256 expiration,\r\n    bytes32 salt,\r\n    bytes memory arguments\r\n  ) private view returns (bytes memory context) {\r\n    context = abi.encodePacked(\r\n      address(this), functionSelector, expiration, salt, arguments\r\n    );\r\n  }\r\n\r\n  function _enforceExpiration(uint256 expiration) private view {\r\n    require(\r\n      expiration == 0 || now <= expiration,\r\n      \"Execution meta-transaction expired.\"\r\n    );\r\n  }\r\n\r\n  function _enforceValidCanceller(address smartWallet) private view {\r\n    require(\r\n      msg.sender == smartWallet || msg.sender == _roles[uint256(\r\n        Role.BOT_COMMANDER\r\n      )].account,\r\n      \"Only wallet in question or bot commander role may cancel.\"\r\n    );\r\n  }\r\n\r\n  /// @notice pass along revert reasons on external calls.\r\n  function _revertOnFailure(bool ok) private pure {\r\n    if (!ok) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier that throws if called by any account other than the owner\r\n   * or the supplied role, or if the caller is not the owner and the role in\r\n   * question is paused.\r\n   * @param role The role to require unless the caller is the owner. Permitted\r\n   * roles are bot commander (0) and pauser (1).\r\n   */\r\n  modifier onlyOwnerOr(Role role) {\r\n    if (!isOwner()) {\r\n      require(_isRole(role), \"Caller does not have a required role.\");\r\n      require(!_isPaused(role), \"Role in question is currently paused.\");\r\n    }\r\n    _;\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiGiven\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"etherReceived\",\"type\":\"uint256\"}],\"name\":\"DaiToEthLimitOrderProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"etherGiven\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiReceived\",\"type\":\"uint256\"}],\"name\":\"EthToDaiLimitOrderProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum BotCommanderV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RoleModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum BotCommanderV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"RolePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum BotCommanderV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"RoleUnpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumDaiUnderlyingAmountToGive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumEthPriceToAccept\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"cancelDaiToEthLimitOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumEtherAmountToGive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumEtherPriceToAccept\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"cancelEthToDaiLimitOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBotCommander\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"botCommander\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"arguments\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getMetaTransactionMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pauser\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum BotCommanderV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum BotCommanderV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"isRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasRole\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum BotCommanderV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"etherAmountToGive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumEtherAmountToGive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumEtherPriceToAccept\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"approvalSignatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"executionSignatures\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"tradeTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct BotCommanderV1Interface.EthToDaiArguments\",\"name\":\"args\",\"type\":\"tuple\"}],\"name\":\"processEthToDaiLimitOrderAndMintDDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"daiReceived\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"smartWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dDaiAmountToApprove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daiUnderlyingAmountToGive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumDaiUnderlyingAmountToGive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumEthPriceToAccept\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"approvalSignatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"executionSignatures\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"tradeTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct BotCommanderV1Interface.DaiToEthArguments\",\"name\":\"args\",\"type\":\"tuple\"}],\"name\":\"redeemDDaiAndProcessDaiToEthLimitOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"etherReceived\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum BotCommanderV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"removeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum BotCommanderV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum BotCommanderV1Interface.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BotCommanderV1","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://76c3e84342684807a33a4b3fe78d578b732bda32b3ed36d2976946a4ac1c3bb6"}]}