{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n   \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n   \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract AntiScam{\r\n    \r\n    //--State variables\r\n    IERC20 contractAST;\r\n      uint rewardPool;\r\n     address owner;\r\n    // address public  activeCurator;\r\n     mapping (address=>bool) internal activeCurators;\r\n      uint public  dappCounter;\r\n    \r\n    //-- custom data type\r\n    enum  status{inconclusive,scammed,Legit, inRevote}\r\n    \r\n    struct dapp{\r\n        string name;\r\n        address contractAddress;\r\n        string uri;\r\n        uint id;\r\n        status dappStatus;\r\n        address representative;\r\n        uint upVotes;\r\n        uint downVotes;\r\n        bool isActive;\r\n        bool isLegit;\r\n        uint starTime;\r\n        string remarks;\r\n        address[] upvoters;\r\n        address[] downvoters;\r\n        \r\n        mapping(address=>bool)hasVoted;\r\n       \r\n        \r\n    }\r\n    // fees\r\n    uint listingFees;\r\n    uint votingFees;\r\n    uint defenderTostake;\r\n    uint exchangeRate;\r\n   \r\n    \r\n    //Eligibility and constraints\r\n    uint listingEligibility;\r\n    uint votingEligibility;\r\n    uint curatorEligibility;\r\n    uint defenderEligibility;\r\n     uint sessionDuration;// 2 hours converted into miliseconds\r\n    uint dailyCondtraint; \r\n    //--Data structures------\r\n     mapping  (uint=>dapp) internal dappsById;\r\n   //  mapping(address=>uint)public _ASTBalance;\r\n     mapping(address=>uint)public _SPTTstakeBalance;\r\n     mapping (address=>uint[])public JurorsList;\r\n     mapping (address=>uint[])public defenderList;\r\n     mapping (address=>uint)public spendingSPT;\r\n     mapping (address=>uint)public listingTime;\r\n     mapping (uint=>uint) public rewardPoolbyDappId;\r\n     uint  public generalReward;\r\n     address[] jurors;\r\n      address[]curators;\r\n     //dapp[] dapps;\r\n     \r\n     /*\r\n     constructor to set basic parameters\r\n     */\r\n   \r\n   constructor(address ast)public{\r\n       activeCurators[msg.sender]=true;\r\n       owner=msg.sender;\r\n       contractAST = IERC20(ast);// get instance of the AST token contract\r\n       //as discussed with client\r\n         listingFees=40;\r\n        votingFees=30;\r\n        defenderTostake=100;\r\n     exchangeRate=5;//5% deduction vice versa\r\n       \r\n    listingEligibility =1 ;\r\n     votingEligibility=1;\r\n      curatorEligibility=5;\r\n       sessionDuration= 7200000;// 2 hours converted into miliseconds\r\n     dailyCondtraint=24*60*60*1000;\r\n   }\r\n    // **************************** //\r\n    // *         Modifiers        * //\r\n    // **************************** //\r\n   modifier onlyOwner(address user){\r\n       require (user==owner,\"only owner can access\");\r\n       _;\r\n   }\r\n    modifier onlyCurator(address user){\r\n       require(activeCurators[user],\"only curator can access\");\r\n       _;\r\n   }\r\n    modifier onlyJuror(address juror) {\r\n        // bool result = false;\r\n        // for(uint i=0; i<jurors.length;i++){\r\n        //     if(jurors[i]==juror){\r\n        //         result=true;\r\n        //     }\r\n           \r\n        // }\r\n        //  require(result,\"Not a Juror\");\r\n         _;\r\n    }\r\n    \r\n    modifier votingeligibility(uint _id, address voter){\r\n        require(!dappsById[_id].hasVoted[voter],\"You have already voted on this token\");\r\n        require(netBalanceSTP(voter)>=votingFees);\r\n      uint time= now- dappsById[ _id].starTime;\r\n   //   require(time<sessionDuration,\"voting timeout\");\r\n        \r\n        _;\r\n    }\r\n\r\n      modifier curatorEligiblity(address curator, uint tokens) {\r\n    //   uint tokenBalance = contractAST.balanceOf(curator);\r\n    //   uint tokenSupply = contractAST.totalSupply();\r\n    //   uint requiredTokens= (5 * tokenSupply)/100;\r\n      \r\n    //      require(tokenBalance>=requiredTokens,\"donot have enough Tokens, please buy more tokens\");\r\n          _;\r\n    }\r\n    \r\n        modifier listerEligiblity(address lister, uint tokens) {\r\n    //   uint tokenBalance = contractAST.balanceOf(lister);\r\n    //   uint tokenSupply = contractAST.totalSupply();\r\n    //   uint requiredTokens= (1 * tokenSupply)/100;\r\n  //    uint time = now - listingTime[lister];\r\n  //    require( time>dailyCondtraint.\"only one listing per day allopwed\");\r\n   //      require(tokenBalance>=requiredTokens,\"donot have enough Tokens, please buy more tokens\");\r\n         _;\r\n    }\r\n    modifier canVote(address user){\r\n        uint tokenBalance=netBalanceSTP(user);\r\n        require(tokenBalance>=votingFees);\r\n        _;\r\n    }\r\n  \r\n        modifier eligibleToRevote(address defender, uint id) {\r\n      uint tokenBalance = netBalanceSTP(defender);\r\n      require(tokenBalance>=defenderEligibility, \"You defender dont have enough tokens\");\r\n      uint tokenSupply = contractAST.totalSupply();\r\n   //   uint requiredTokens= (1 * tokenSupply)/100;\r\n      \r\n        // require(tokenBalance>=requiredTokens,\"donot have enough Tokens, please buy more tokens\");\r\n         _;\r\n    }\r\n\r\n    function upvote(uint  _id)canVote(msg.sender)onlyJuror(msg.sender) public{\r\n        address _juror=msg.sender;\r\n        \r\n        dappsById[_id].upVotes++;\r\n         dappsById[_id].upvoters.push(_juror);\r\n         spendingSPT[_juror]+= votingFees;\r\n        \r\n    }\r\n    function downVote(uint  _id)canVote(msg.sender)onlyJuror(msg.sender) public{\r\n       address _juror=msg.sender;\r\n       \r\n        dappsById[_id].downVotes++;\r\n        dappsById[_id].downvoters.push(_juror);\r\n        spendingSPT[_juror]+= votingFees;\r\n    }\r\n    \r\n    function registerDapp(string memory _name,address _contractAddress,string memory _uri)public {\r\n       address lister= msg.sender;\r\n        dapp memory regDapp;\r\n        regDapp.name=_name;\r\n        regDapp.contractAddress=_contractAddress;\r\n        regDapp.uri=_uri;\r\n        regDapp.dappStatus=status.inconclusive;\r\n        regDapp.representative= lister;\r\n        regDapp.id= dappCounter;\r\n        dappsById[dappCounter]=regDapp;\r\n       \r\n       _SPTTstakeBalance[lister]-= listingFees;// deduct fees from stake and credit to reward pool\r\n       generalReward+= listingFees;\r\n         dappCounter++;// increment the counter\r\n        \r\n        \r\n        \r\n    }\r\n    /*\r\n    curator to approve Dapp for listing and assign jurors\r\n    */\r\n    function enlistForVoting(uint _id)onlyCurator(msg.sender) public{// only curator\r\n    dappsById[_id].isActive=true;\r\n        \r\n    }\r\n     /*\r\n    curator to mark Dapp as scammed\r\n    */\r\n    function markScam(uint _id)onlyCurator(msg.sender)  public {// only curator\r\naddress curator=msg.sender;\r\n        dappsById[_id].dappStatus=status.scammed;\r\n         dappsById[_id].isActive=false;\r\n       dappsById[_id].remarks =\" Marke dSpam by the Curator\";\r\n       generalReward-=listingFees;\r\n       _SPTTstakeBalance[curator]+=listingFees;\r\n    }\r\n    \r\n    \r\n        /*\r\n        juror to stake STT to register as juror\r\n    */\r\n    function registerJuror() public{\r\n        \r\n      address _juror=msg.sender;\r\n      \r\n      jurors.push(_juror);  \r\n    }\r\n      /*\r\n        juror to stake STT to register as juror\r\n    */\r\n    function registerCurator(uint _tokens) public{\r\n        \r\n    }\r\n    \r\n    function viewDAppById(uint _id) public view returns(uint id,string memory ,address ,string memory  uri,uint dappstatus,bool isActive, uint upVotes , uint downVotes,bool isLegit,string memory remarks, uint timestamp )  {\r\n        dapp memory getDapp= dappsById[_id];\r\n        \r\n        return (getDapp.id,getDapp.name,getDapp.contractAddress,getDapp.uri,uint(getDapp.dappStatus),getDapp.isActive,getDapp.upVotes,getDapp.downVotes,getDapp.isLegit, getDapp.remarks, getDapp.starTime);\r\n        \r\n    }\r\n    /*Swap AST with STT and stake the same.\r\n    */\r\n    function  swapAndstakeSPT(uint tokens)public {\r\n        address staker =msg.sender;\r\n    contractAST.transferFrom(staker,address(this),tokens);\r\n    \r\n    uint commission =(tokens * exchangeRate)/100;\r\n    \r\n    _SPTTstakeBalance[staker] +=(tokens-commission);\r\n\r\n    generalReward+=commission;// in AST\r\n    }\r\n    /* redeem the STT token\r\n    */\r\n     function  redeem(uint tokens)public {\r\n        address staker =msg.sender;\r\n        \r\n    uint commission =(tokens * exchangeRate)/100;\r\n    uint trasferableToken= (tokens-commission);\r\n    \r\n    _SPTTstakeBalance[staker] -=tokens;\r\n\r\ncontractAST.transfer(staker,trasferableToken);\r\n    generalReward+=commission;\r\n    }\r\n    \r\n    function stopVotingSession(uint  _id )onlyCurator(msg.sender) public{\r\n        bool isScam = (dappsById[_id].upVotes<dappsById[_id].downVotes)?true:false;\r\n       if(dappsById[_id].dappStatus==status.inRevote){\r\n           \r\n          defendantSettlement(_id,isScam);\r\n       }\r\n       jurorSettlement(_id,isScam);\r\n        dappsById[_id].isActive =false;\r\n        dappsById[_id].dappStatus=isScam?status.scammed:status.Legit;\r\n        \r\n    }\r\n    function  requestRevote(uint _id, string memory _remarks)public  eligibleToRevote(msg.sender,_id){\r\n        require(dappsById[_id].isActive==false, \"cant revote while voting is still in progress.\");\r\n        require(dappsById[_id].dappStatus==status.scammed,\"you can only defend scammed list\");\r\n        address defender= msg.sender;\r\n        \r\n         dappsById[_id].isActive=true;\r\n         dappsById[_id].dappStatus=status.inRevote;\r\n         dappsById[_id].remarks=_remarks;\r\n         dappsById[_id].representative= defender;\r\n         dappsById[_id].starTime= now;\r\n         \r\n    //    spendingSPT[defender]+=defenderTostake;\r\n        \r\n    }\r\n    function defendantSettlement(uint _id, bool isScam)internal {\r\n        address defender =dappsById[_id].representative;\r\n        if(isScam){\r\n            spendingSPT[defender]-=defenderTostake;\r\n            rewardPoolbyDappId[_id]+=defenderTostake;// transfer the penalty to reward pool\r\n        }else{\r\n                spendingSPT[defender]-=defenderTostake;// returning the spending\r\n            }\r\n        \r\n    }\r\n    function addCurator(address curator) onlyOwner(msg.sender)public{\r\n        activeCurators[curator]= true;\r\n    }\r\n    \r\n    function jurorSettlement(uint _id, bool isScam)internal{\r\n        // if scam then  winer is downvoters and loosers are upvoters\r\n        address[] memory  winners= isScam?dappsById[_id].downvoters:dappsById[_id].upvoters ;\r\n         address[] memory loosers= isScam?dappsById[_id].upvoters:dappsById[_id].downvoters ;\r\n        \r\n                  //-- settlement of loosing side(half voting is refunded half is penalized)\r\n          uint returnedvoting =votingFees/2;\r\nfor(uint i=0;i<loosers.length;i++){\r\n    spendingSPT[loosers[i]] -=returnedvoting;\r\n    _SPTTstakeBalance[loosers[i]]-= (votingFees-returnedvoting);\r\n    rewardPoolbyDappId[_id]+= (votingFees-returnedvoting);\r\n         \r\n}\r\n        //-- settlement of winning side(if won, no voting fees charged)\r\n        uint rewardperJuror= rewardPoolbyDappId[_id]/winners.length;\r\n           returnedvoting =votingFees;\r\nfor(uint i=0;i<winners.length;i++){\r\n    spendingSPT[winners[i]] -=returnedvoting;\r\n    _SPTTstakeBalance[winners[i]]-= (votingFees-returnedvoting);// no net fees is being charged from the staked STP\r\n    _SPTTstakeBalance[winners[i]]+= rewardperJuror;// rewarding the winning jurors, by crediting the STP\r\n         \r\n}\r\n        \r\n    }\r\n    function netBalanceSTP(address user)public view returns(uint){\r\n        uint balance =_SPTTstakeBalance[user] - spendingSPT[user];\r\n        return balance;\r\n    }\r\n\r\nfunction withdraw() onlyOwner(msg.sender)public{\r\n    uint balance=contractAST.balanceOf(address(this));\r\n    contractAST.transfer(owner,balance);\r\n}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ast\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"JurorsList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_SPTTstakeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"addCurator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dappCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"defenderList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"downVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"enlistForVoting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"generalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"listingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"markScam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"netBalanceSTP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"registerCurator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"registerDapp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"registerJuror\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_remarks\",\"type\":\"string\"}],\"name\":\"requestRevote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardPoolbyDappId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"spendingSPT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"stopVotingSession\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"swapAndstakeSPT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"upvote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"viewDAppById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"dappstatus\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"upVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"downVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLegit\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"remarks\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AntiScam","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a872e0a44bbd66c1486a756cb5bd3f0beec4e32e","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://acdf703083ee7231f86a6ef4698f8b6636053647f26ed6f5b1eab00f3ee49cd3"}]}