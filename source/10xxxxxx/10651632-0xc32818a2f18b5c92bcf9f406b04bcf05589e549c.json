{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n    ___     __     ____     __  __    ___ \r\n   /   |   / /    / __ \\   / / / /   /   |\r\n  / /| |  / /    / /_/ /  / /_/ /   / /| |\r\n / ___ | / /___ / ____/  / __  /   / ___ |\r\n/_/  |_|/_____//_/      /_/ /_/   /_/  |_|\r\n                                          \r\n\r\nhttps://thealphaproject.io/                                          \r\n*/\r\n\r\npragma solidity ^0.4.18;contract ALPHA { struct MemberInfo { uint userID; uint datereg; address referrer; address[] allReferrals; uint totalRewardBonus; uint bonusID; uint[] rewardBonusIDs; uint activeX3Levels; uint activeX4Levels; uint pendingIncomeID; mapping(uint => mapping(uint => mapping(uint => PendingIncome))) pendingIncome; mapping (uint => uint) pendingIncomeLevel; mapping (uint => uint) pendingIncomeMatrix; } struct AX3Info { uint datereg; bool isActive; uint enterred; mapping(uint => address[]) referrals; uint cycle; } struct AX4Info { uint datereg; bool missedIncome; bool isActive; uint enterred; uint cycle; address uplineposition; mapping(uint => address[]) accounts; mapping(uint => mapping(uint => address)) slotAddress; mapping(uint => mapping(address => uint)) source; } struct RewardBonus { bool isActive; uint amount; uint dateAdded; uint amountWithdrawn; } struct RewardInfo{ address account; uint totalDirect; uint bonusPrize; bool isWinner; } struct PendingIncome{ bool isActive; uint amount; uint dateAdded; } mapping(uint => address[]) rewardQualifiers; mapping(uint => address[]) rewardPoolWinners; mapping (address => MemberInfo) memberInfos; mapping(address => uint) public balance; mapping(address => uint) public x3balance; mapping(address => uint) public x4balance; mapping(uint => mapping(uint => AX3Info)) matrix3Infos; mapping(uint => mapping(uint => AX4Info)) matrix4Infos; mapping(uint => mapping(uint => RewardInfo)) rewardInfo; mapping(uint => mapping(uint => RewardBonus)) rewardBonus; address owner; uint public lastID = 2; uint public rewardPool; uint public rewardCycle; uint public TotalEthTransactions; uint public UnclaimeddProfit; constructor() public { owner = msg.sender; rewardCycle = 1; for(uint i=1; i<=12; i++){ if(i== 1){ newMember(owner, 1, address(0), i, false, 0, 0); }else{ newMember(owner, 1, address(0), i, true, 3, 0); newMember(owner, 1, address(0), i, true, 4, 0); } } } function registration(address uplineAddress) external payable { require(msg.value == 0.03 ether, \"registration starts at 0.03\"); uint packageLvl = 1; uint memberId = getUserId(msg.sender); require(memberId == 0, \"member is already registered.\"); uint uplineUserId = getUserId(uplineAddress); require(uplineUserId > 0, \"upline address not found\"); TotalEthTransactions += msg.value; uint _entry = msg.value; uint _x3Profit = _entry / 2; rewardPool += (_x3Profit * 5) / 100; memberId = lastID++; newMember(msg.sender, memberId, uplineAddress, packageLvl, false, 0, _x3Profit); address _referrerUpline = getUpline(uplineAddress); MemberInfo storage _uplineInfo = memberInfos[uplineAddress]; _uplineInfo.allReferrals.push(msg.sender); AX3Info storage _uplineMatrix3Info = matrix3Infos[uplineUserId][packageLvl]; _uplineMatrix3Info.referrals[_uplineMatrix3Info.cycle].push(msg.sender); addRewardQualifier(uplineAddress, uplineUserId); if(_uplineMatrix3Info.enterred == 2){ _uplineMatrix3Info.enterred = 0; _uplineMatrix3Info.cycle += 1; sendProfit(3, _referrerUpline, _x3Profit, packageLvl); }else{ _uplineMatrix3Info.enterred += 1; uplineAddress.transfer(_x3Profit); balance[uplineAddress] += _x3Profit; x3balance[uplineAddress] += _x3Profit; } processMatrix(uplineAddress, uplineUserId, msg.sender, packageLvl, _x3Profit); } uint memberId; function upgrade(uint256 matrix) external payable { require(matrix == 3 || matrix == 4,\"invalid matrix type\"); require(msg.value >= 0.03 ether, \"upgrade starts from 0.03 eth\"); memberId = getUserId(msg.sender); require(memberId > 0, \"register to level 1 first\"); uint packageLvl = getPackageLevel(msg.value); require(getActiveMatrix(matrix, msg.sender) == (packageLvl - 1), \"InvalidLevel Upgrade. Must be in sequence.\"); require(packageLvl > 1, \"invalid amount for the upgrade\"); bool hasPackage = matrix3Infos[memberId][packageLvl].isActive; if(matrix == 4){ hasPackage = matrix4Infos[memberId][packageLvl].isActive; } require(!hasPackage, \"you are already registered to this level\"); address _referrerAddress = getUpline(msg.sender); uint _referrerUserId = getUserId(_referrerAddress); releasePendingIncome(matrix, msg.sender, packageLvl); newMember(msg.sender, memberId, _referrerAddress, packageLvl, true, matrix, msg.value); if(matrix == 3){ uint _x3Profit = getX3Profit(packageLvl, msg.value, msg.sender); address _referrerUplineAddress = getUpline(_referrerAddress); AX3Info storage _referrerMatrix3Info = matrix3Infos[_referrerUserId][packageLvl]; _referrerMatrix3Info.referrals[_referrerMatrix3Info.cycle].push(msg.sender); addRewardQualifier(_referrerAddress, _referrerUserId); if(_referrerMatrix3Info.enterred == 2){ _referrerMatrix3Info.enterred = 0; _referrerMatrix3Info.cycle += 1; sendProfit(3, _referrerUplineAddress, _x3Profit, packageLvl); }else{ _referrerMatrix3Info.enterred += 1; sendProfit(3, _referrerAddress, _x3Profit, packageLvl); } }else{ uint _x4Profit = msg.value; rewardPool += (_x4Profit * 5) / 100; _referrerAddress = getActiveUpline(4, msg.sender, packageLvl - 1, packageLvl); _referrerUserId = getUserId(_referrerAddress); processMatrix(_referrerAddress , _referrerUserId, msg.sender, packageLvl, _x4Profit); } } function sendProfit(uint matrix, address _account, uint _profit, uint _packageLvl)internal{ if(_account != address(0)){ bool isLvlActive = isMatrixActive(matrix, _account, _packageLvl); if(isLvlActive || matrix == 4){ if(_account != address(0)){ _account.transfer(_profit); balance[_account] += _profit; if(matrix == 3){ x3balance[_account] += _profit; }else{ x4balance[_account] += _profit; } } else{ owner.transfer(_profit); balance[owner] += _profit; } }else{ UnclaimeddProfit += _profit; MissedIncome(matrix, _account, _profit, _packageLvl); } } else{ owner.transfer(_profit); balance[owner] += _profit; } } function AddRewardBonus(uint _memberId, uint _rewardBonusID, uint _rewardBonus)internal{ RewardBonus storage _uplineRewardBonus = rewardBonus[_memberId][_rewardBonusID]; _uplineRewardBonus.isActive = true; _uplineRewardBonus.amount = (_rewardBonus * 20) / 100; _uplineRewardBonus.dateAdded = now; } function getX3Profit(uint _packageLvl, uint _amount, address _newMember)internal returns (uint profit){ uint _x3profit = _amount; uint _rewardBack; if(_packageLvl >= 3 && _packageLvl <= 6){ _x3profit = (_amount * 75) / 100; _rewardBack = _amount - _x3profit; _newMember.transfer(_rewardBack); balance[_newMember] += _rewardBack; x3balance[_newMember] += _rewardBack; }else if(_packageLvl >= 7){ _rewardBack = (_amount * 50) / 100; _x3profit = _rewardBack; _newMember.transfer(_rewardBack); balance[_newMember] += _rewardBack; x3balance[_newMember] += _rewardBack; } return _x3profit; } function newMember(address _account, uint _memberId, address _uplineAddress, uint _packageLvl, bool isUpgrade, uint matrix, uint _packageAmount) internal{ MemberInfo storage _memberInfo = memberInfos[_account]; AX3Info storage _newMatrix3Info = matrix3Infos[_memberId][_packageLvl]; AX4Info storage _newMatrix4Info = matrix4Infos[_memberId][_packageLvl]; if(!isUpgrade){ AddRewardBonus(_memberId, 1, (_packageAmount)); _memberInfo.datereg = now; _memberInfo.totalRewardBonus += (_packageAmount * 20) / 100; _memberInfo.rewardBonusIDs.push(1); _memberInfo.referrer = _uplineAddress; _memberInfo.userID = _memberId; _memberInfo.bonusID = 2; _memberInfo.pendingIncomeID = 1; _newMatrix3Info.isActive = true; _newMatrix3Info.datereg = now; _memberInfo.activeX3Levels += 1; _newMatrix4Info.isActive = true; _newMatrix4Info.datereg = now; _memberInfo.activeX4Levels += 1; }else{ if(matrix == 3){ _newMatrix3Info.isActive = true; _newMatrix3Info.datereg = now; _memberInfo.activeX3Levels += 1; }else{ AddRewardBonus(_memberId, _memberInfo.bonusID, _packageAmount); _memberInfo.totalRewardBonus += (_packageAmount * 20) / 100; _memberInfo.rewardBonusIDs.push(_memberInfo.bonusID); _memberInfo.bonusID += 1; _newMatrix4Info.isActive = true; _newMatrix4Info.datereg = now; _newMatrix4Info.missedIncome = false; _memberInfo.activeX4Levels += 1; } } }function processMatrix(address _uplineAddress, uint _uplineUserId, address _newMember, uint _packageLvl, uint _giveProfit) internal { uint _x4Profit = (_giveProfit * 75) / 100; address _2ndUpline = getNetworkUpline(_uplineAddress, _packageLvl); AX4Info storage _uplineMatrix4Info = matrix4Infos[_uplineUserId][_packageLvl]; uint spillOverPosition = getX4AvailableSlot(_uplineAddress, _packageLvl, _uplineMatrix4Info.cycle); _uplineMatrix4Info.slotAddress[_uplineMatrix4Info.cycle][spillOverPosition] = _newMember; _uplineMatrix4Info.source[_uplineMatrix4Info.cycle][_newMember] = 1; _uplineMatrix4Info.accounts[_uplineMatrix4Info.cycle].push(_newMember); _uplineMatrix4Info.enterred += 1; uint getAccountPosition = 0; if(spillOverPosition == 3 || spillOverPosition == 4){ getAccountPosition = 1; }else if(spillOverPosition == 5 || spillOverPosition == 6){ getAccountPosition = 2; } if(getAccountPosition > 0){ address _x4DownlineAddress = _uplineMatrix4Info.slotAddress[_uplineMatrix4Info.cycle][getAccountPosition]; DownlineX4Matrix(_x4DownlineAddress, _packageLvl, _newMember, _uplineMatrix4Info.cycle); if(_uplineMatrix4Info.enterred <= 5){ sendProfit(4, _uplineAddress, _x4Profit, _packageLvl); }else{ uplineUpdateX4(_uplineAddress, _2ndUpline, _packageLvl, _giveProfit); } }else{ setUpline(_newMember, _uplineAddress, _packageLvl); nextUplineUpdateX4(_uplineAddress, _2ndUpline, _newMember, _packageLvl, _giveProfit, false); } } function nextUplineUpdateX4(address _downline, address _uplineAddress, address _newMember, uint _packageLvl, uint _giveProfit, bool isCycle)internal{ uint _uplineUserId = getUserId(_uplineAddress); AX4Info storage _2ndupline_Matrix4Info = matrix4Infos[_uplineUserId][_packageLvl]; uint cycle = _2ndupline_Matrix4Info.cycle; uint dlPosition = 0; uint _2ndUplineEnterPosition = _2ndupline_Matrix4Info.enterred; if(isCycle) { _2ndUplineEnterPosition = getX4AvailableSlot(_uplineAddress, _packageLvl, cycle); if(_2ndUplineEnterPosition == 3 || _2ndUplineEnterPosition == 4){ dlPosition = 1; }else if(_2ndUplineEnterPosition == 4 || _2ndUplineEnterPosition == 6){ dlPosition = 2; } } else{ if(_2ndUplineEnterPosition > 0){ if(getMatrix4SlotInfo(_uplineAddress, _packageLvl, cycle, 1) == _downline) { _2ndUplineEnterPosition = 3; if(getMatrix4SlotInfo(_uplineAddress, _packageLvl, cycle, 3) != address(0)){ _2ndUplineEnterPosition = 4; } dlPosition = 1; } else { dlPosition = 2; _2ndUplineEnterPosition = 5; if(getMatrix4SlotInfo(_uplineAddress, _packageLvl, cycle, 5) != address(0)){ _2ndUplineEnterPosition = 6; } } }else{ _2ndUplineEnterPosition = getX4AvailableSlot(_uplineAddress, _packageLvl, cycle); } } _2ndupline_Matrix4Info.slotAddress[cycle][_2ndUplineEnterPosition] = _newMember; _2ndupline_Matrix4Info.source[cycle][_newMember] = 3; _2ndupline_Matrix4Info.accounts[cycle].push(_newMember); _2ndupline_Matrix4Info.enterred += 1; if(isCycle){ if(dlPosition > 0){ address _x4DownlineAddress = _2ndupline_Matrix4Info.slotAddress[cycle][dlPosition]; DownlineX4Matrix(_x4DownlineAddress, _packageLvl, _newMember, cycle); } } if(_2ndupline_Matrix4Info.enterred == 6){ _2ndupline_Matrix4Info.enterred = 0; _2ndupline_Matrix4Info.cycle += 1; if(_giveProfit > 0){ sendProfit(4, _uplineAddress, (_giveProfit * 70) / 100, _packageLvl); disburseRefRewards(_uplineAddress, _giveProfit); MemberInfo storage _memberInfo = memberInfos[_uplineAddress]; AddRewardBonus(_uplineUserId, _memberInfo.bonusID, (_giveProfit * 20) / 100); _memberInfo.totalRewardBonus += (_giveProfit * 20) / 100; _memberInfo.rewardBonusIDs.push(1); _memberInfo.bonusID += 1; } address nxtUpline = getNetworkUpline(_uplineAddress, _packageLvl); if(nxtUpline != address(0)){ nextUplineUpdateX4(_uplineAddress, nxtUpline, _uplineAddress, _packageLvl,0, true); } }else{ if(_giveProfit > 0){ sendProfit(4, _uplineAddress, (_giveProfit * 75) / 100, _packageLvl); } } } function uplineUpdateX4(address _account, address _uplineAddress, uint _packageLvl, uint _giveProfit) internal{ uint userId = getUserId(_account); AX4Info storage _uplineMatrix4Info = matrix4Infos[userId][_packageLvl]; if(_uplineMatrix4Info.enterred >= 6){ _uplineMatrix4Info.enterred = 0; _uplineMatrix4Info.cycle += 1; uint _resetProfit = (_giveProfit * 70) / 100; sendProfit(4, _uplineAddress, _resetProfit, _packageLvl); disburseRefRewards(_account, _giveProfit); MemberInfo storage _memberInfo = memberInfos[_account]; AddRewardBonus(userId, _memberInfo.bonusID, (_giveProfit * 20) / 100); _memberInfo.totalRewardBonus += (_giveProfit * 20) / 100; _memberInfo.rewardBonusIDs.push(1); _memberInfo.bonusID += 1; if(_uplineAddress != address(0)){ nextUplineUpdateX4(_account, _uplineAddress, _account, _packageLvl, 0, true); } } } function DownlineX4Matrix(address account, uint _packageLvl, address _newMember, uint uplinecycle) internal{ setUpline(_newMember, account, _packageLvl); uint userId = getUserId(account); AX4Info storage _downline_Matrix4Info = matrix4Infos[userId][_packageLvl]; _downline_Matrix4Info.slotAddress[_downline_Matrix4Info.cycle][_downline_Matrix4Info.enterred + 1] = _newMember; _downline_Matrix4Info.source[_downline_Matrix4Info.cycle][_newMember] = 2; _downline_Matrix4Info.accounts[uplinecycle].push(_newMember); _downline_Matrix4Info.enterred += 1; } function setUpline(address newaccount, address uplineaccount, uint _packageLvl)internal{ uint _memberId = getUserId(newaccount); AX4Info storage _newMatrix4Info = matrix4Infos[_memberId][_packageLvl]; _newMatrix4Info.uplineposition = uplineaccount; } function getNetworkUpline(address account, uint _packageLvl)view public returns (address upline){ uint _memberId = getUserId(account); AX4Info storage _memberInfo = matrix4Infos[_memberId][_packageLvl]; return _memberInfo.uplineposition; } function MissedIncome(uint matrix, address account, uint income, uint _packageLvl)internal{ MemberInfo storage accountInfo = memberInfos[account]; accountInfo.pendingIncomeLevel[accountInfo.pendingIncomeID] = _packageLvl; accountInfo.pendingIncomeMatrix[accountInfo.pendingIncomeID] = matrix; PendingIncome storage _missedIncome = accountInfo.pendingIncome[matrix][_packageLvl][accountInfo.pendingIncomeID]; _missedIncome.amount = income; _missedIncome.dateAdded = now; _missedIncome.isActive = true; accountInfo.pendingIncomeID += 1; } function disburseRefRewards(address _account, uint _entry)internal{ address[] memory _allRefs = getAllReferrals(_account); uint _giveDlProfit = ((_entry * 5) / 100) / (_allRefs.length); for (uint i=0; i < _allRefs.length; i++) { _allRefs[i].transfer(_giveDlProfit); balance[_allRefs[i]] += _giveDlProfit; x4balance[_allRefs[i]] += _giveDlProfit; } } function getPackageLevel(uint _amount)pure internal returns(uint){ uint lvl = 0; if(_amount == 0.03 ether){ lvl = 2; }else if(_amount == 0.06 ether){ lvl = 3; }else if(_amount == 0.12 ether){ lvl = 4; }else if(_amount == 0.24 ether){ lvl = 5; }else if(_amount == 0.48 ether){ lvl = 6; }else if(_amount == 0.96 ether){ lvl = 7; }else if(_amount == 1.92 ether){ lvl = 8; }else if(_amount == 3.84 ether){ lvl = 9; }else if(_amount == 7.68 ether){ lvl = 10; }else if(_amount == 15.36 ether){ lvl = 11; }else if(_amount == 30.72 ether){ lvl = 12; } return lvl; } function addRewardQualifier(address account, uint accountId) internal{ RewardInfo storage _reward = rewardInfo[accountId][rewardCycle]; _reward.account = account; _reward.totalDirect += 1; if(!existInRewardList(account, rewardCycle)){ rewardQualifiers[rewardCycle].push(account); } } function getX4AvailableSlot(address _address, uint _packageLvl, uint _cycle)view public returns(uint){ for(uint i=1; i<=6; i++){ address account = getMatrix4SlotInfo(_address, _packageLvl, _cycle, i); if(account == address(0)){ return i; } } return 0; } function existInRewardList(address account, uint cycle)view internal returns (bool){ address[] memory rewardList = rewardQualifiers[cycle]; for (uint i = 0; i < rewardList.length; i++) { if (rewardList[i] == account) { return true; } } return false; } function getRewardQualifiers(uint _cycle) view public returns (address[] accounts){ return rewardQualifiers[_cycle]; } function getRewardPoolInfo(address _account, uint _cycle) view public returns (address account, uint totalDirect, uint bonusPrize, bool isWinner){ uint _userID = getUserId(_account); return (rewardInfo[_userID][_cycle].account, rewardInfo[_userID][_cycle].totalDirect, rewardInfo[_userID][_cycle].bonusPrize, rewardInfo[_userID][_cycle].isWinner); } function getAccountInfo(address _address) view public returns (uint userId, address directUpline, uint totalRewardBonus, uint BonusID, uint PendingIncomeID, uint registered) { return (memberInfos[_address].userID, memberInfos[_address].referrer, memberInfos[_address].totalRewardBonus, memberInfos[_address].bonusID, memberInfos[_address].pendingIncomeID, memberInfos[_address].datereg); } function getUserId(address _address) view public returns (uint userId) { if(_address == owner){ return 1; } return (memberInfos[_address].userID); } function getUpline(address _address) view public returns (address upline) { return (memberInfos[_address].referrer); } function getPendingIncomeID(address _address) view public returns (uint PendingID) { return (memberInfos[_address].pendingIncomeID); } function getPendingIncome(uint matrix, address _address, uint level, uint pendingId) view public returns (bool isactive, uint amount, uint totalHours) { PendingIncome storage pending = memberInfos[_address].pendingIncome[matrix][level][pendingId]; return (pending.isActive, pending.amount, ((now - pending.dateAdded) / 60) / 60); } function getPendingIncomeInfo(address account, uint pendingId) view public returns(uint matrix, uint package){ MemberInfo storage accountInfo = memberInfos[account]; return(accountInfo.pendingIncomeMatrix[pendingId], accountInfo.pendingIncomeLevel[pendingId]); } function getMatrix3Info(uint userId, uint level) view public returns (bool isactive, uint occupiedslots, uint cyclecount, uint datereg) { return (matrix3Infos[userId][level].isActive, matrix3Infos[userId][level].enterred, matrix3Infos[userId][level].cycle, matrix3Infos[userId][level].datereg); } function getMatrix3Referrals(address _address,uint level, uint cycle) view public returns (address[] referrals) { uint _memberId = getUserId(_address); return (matrix3Infos[_memberId][level].referrals[cycle]); } function getAllReferrals(address _address) view public returns (address[] referrals) { return (memberInfos[_address].allReferrals); } function getMatrix4Info(uint userId, uint level) view public returns (bool isactive, uint occupiedslots, uint cyclecount, bool missedIncome, uint datereg) { return (matrix4Infos[userId][level].isActive, matrix4Infos[userId][level].enterred, matrix4Infos[userId][level].cycle, matrix4Infos[userId][level].missedIncome, matrix4Infos[userId][level].datereg); } function isMatrixActive(uint matrix, address _address, uint level) view public returns (bool) { uint userId = getUserId(_address); if(matrix == 3){ return (matrix3Infos[userId][level].isActive); } return (matrix4Infos[userId][level].isActive); } function getMatrix4Referrals(address _address, uint level, uint cycle) view public returns (address[] referrals) { uint _memberId = getUserId(_address); AX4Info storage _matrix4Info = matrix4Infos[_memberId][level]; return _matrix4Info.accounts[cycle]; } function getMatrix4SlotInfo(address _address, uint level, uint cycle, uint position) view public returns (address account) { uint _memberId = getUserId(_address); AX4Info storage _matrix4Info = matrix4Infos[_memberId][level]; return _matrix4Info.slotAddress[cycle][position]; } function getMatrix4SourceType(uint _userID, address _address, uint level, uint cycle) view public returns (uint sourceType) { AX4Info storage _matrix4Info = matrix4Infos[_userID][level]; return _matrix4Info.source[cycle][_address]; } function getActiveMatrix(uint matrix, address _address) view public returns (uint lastlevel) { MemberInfo storage member = memberInfos[_address]; if(matrix == 3){ return member.activeX3Levels; } return member.activeX4Levels; } function getRewardBonusIDs(address _address) view public returns (uint[] RewardBonus_IDs) { return memberInfos[_address].rewardBonusIDs; } function getRewardBonusInfo(uint _userId, uint _rewardId) view public returns (bool isActive, uint Amount, uint DateAdded, uint withdrawnAmount) { RewardBonus storage _rewardBonus = rewardBonus[_userId][_rewardId]; return(_rewardBonus.isActive, _rewardBonus.amount, _rewardBonus.dateAdded, _rewardBonus.amountWithdrawn); } function getAvailableRewardBonus(uint _userId, uint _rewardId) view public returns (uint Balance) { RewardBonus storage _rewardBonus = rewardBonus[_userId][_rewardId]; if(_rewardBonus.isActive){ uint _totalMins = (((now - _rewardBonus.dateAdded) / 60)); if(_totalMins > 7200){ _totalMins = 7200; } uint _hourlyIncome = (_rewardBonus.amount / 7200); uint _totalIncome = _hourlyIncome * _totalMins; uint _balance = _totalIncome - _rewardBonus.amountWithdrawn; return _balance; } return 0; } function withdrawBonus(uint amount, uint rewardID)public{ uint _userId = getUserId(msg.sender); require(_userId > 0, \"invalid account\"); uint _balance = getAvailableRewardBonus(_userId, rewardID); require(_balance > 0,\"you don't have available balance\"); require(_balance >= amount, \"invalid amount to withdraw\"); RewardBonus storage _rewardBonus = rewardBonus[_userId][rewardID]; _rewardBonus.amountWithdrawn += amount; if(_rewardBonus.amount >= _rewardBonus.amountWithdrawn){ _rewardBonus.isActive = false; } msg.sender.transfer(amount); balance[msg.sender] += amount; x4balance[msg.sender] += amount; } function disburseRewardPool(address winner_1, address winner_2,address winner_3,address winner_4,address winner_5) public{ require(msg.sender == owner, \"invalid transaction\"); uint _dividend = rewardPool; uint _cycle = rewardCycle; rewardPoolWinners[_cycle].push(winner_1); rewardPoolWinners[_cycle].push(winner_2); rewardPoolWinners[_cycle].push(winner_3); rewardPoolWinners[_cycle].push(winner_4); rewardPoolWinners[_cycle].push(winner_5); uint percentage = 50; for(uint i=0; i<=4; i++){ if(i == 1){ percentage = 25; } else if(i == 2){ percentage = 15; } else if(i == 3){ percentage = 7; }if(i == 4){ percentage = 3; } address _winner = rewardPoolWinners[_cycle][i]; uint _userId = getUserId(_winner); uint _sendReward = (_dividend * percentage) / 100; RewardInfo storage reward1 = rewardInfo[_userId][_cycle]; reward1.isWinner = true; reward1.bonusPrize = _sendReward; _winner.transfer(_sendReward); balance[_winner] += _sendReward; x4balance[_winner] += _sendReward; } rewardCycle += 1; rewardPool = 0; } function getActiveUpline(uint matrix, address account, uint _networkLvl, uint _packageLvl) internal returns(address ){ bool _isUplineActiveBox = false; address _uplineAccount; uint _uplineUserId; while(_isUplineActiveBox != true){ if(matrix == 3){ _uplineAccount = getUpline(account); }else{ _uplineAccount = getNetworkUpline(account, _networkLvl); } if(_uplineAccount == address(0)){ _uplineAccount = owner; } if(_uplineAccount == owner){ _isUplineActiveBox = true; }else{ MemberInfo storage uplineInfox = memberInfos[_uplineAccount]; _uplineUserId = uplineInfox.userID; account = uplineInfox.referrer; if(matrix == 3){ _isUplineActiveBox = matrix3Infos[_uplineUserId][_packageLvl].isActive; }else{ _isUplineActiveBox = matrix4Infos[_uplineUserId][_packageLvl].isActive; if(_isUplineActiveBox == false){ AX4Info storage uplineX4 = matrix4Infos[_uplineUserId][_packageLvl]; uplineX4.missedIncome = true; } } } } return _uplineAccount; } function releasePendingIncome(uint matrix, address account, uint _packageLvl) internal{ MemberInfo storage accountInfo = memberInfos[account]; uint pendingId = accountInfo.pendingIncomeID;for(uint i=1; i< pendingId; i++){ PendingIncome storage _missedIncome = accountInfo.pendingIncome[matrix][_packageLvl][i]; if(_missedIncome.isActive){ uint timeDuration = ((now - _missedIncome.dateAdded) / 60) / 60; if(timeDuration < 24) { uint income = _missedIncome.amount; account.transfer(income); balance[account] += (income); x3balance[account] += (income); }else{ uint _income1 = (_missedIncome.amount * 30) / 100; uint _income2 = (_missedIncome.amount * 70) / 100; account.transfer(_income1); balance[account] += _income1; x3balance[account] += _income1; address _uplineAccount = getActiveUpline(matrix, account, _packageLvl, _packageLvl); _uplineAccount.transfer(_income2); balance[_uplineAccount] += _income2; x3balance[_uplineAccount] += _income2; } UnclaimeddProfit -= _missedIncome.amount; _missedIncome.isActive = false; } } }}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"uplineAddress\",\"type\":\"address\"}],\"name\":\"registration\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winner_1\",\"type\":\"address\"},{\"name\":\"winner_2\",\"type\":\"address\"},{\"name\":\"winner_3\",\"type\":\"address\"},{\"name\":\"winner_4\",\"type\":\"address\"},{\"name\":\"winner_5\",\"type\":\"address\"}],\"name\":\"disburseRewardPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"pendingId\",\"type\":\"uint256\"}],\"name\":\"getPendingIncomeInfo\",\"outputs\":[{\"name\":\"matrix\",\"type\":\"uint256\"},{\"name\":\"package\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserId\",\"outputs\":[{\"name\":\"userId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userId\",\"type\":\"uint256\"},{\"name\":\"_rewardId\",\"type\":\"uint256\"}],\"name\":\"getRewardBonusInfo\",\"outputs\":[{\"name\":\"isActive\",\"type\":\"bool\"},{\"name\":\"Amount\",\"type\":\"uint256\"},{\"name\":\"DateAdded\",\"type\":\"uint256\"},{\"name\":\"withdrawnAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"cycle\",\"type\":\"uint256\"},{\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"getMatrix4SlotInfo\",\"outputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matrix\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"cycle\",\"type\":\"uint256\"}],\"name\":\"getMatrix4Referrals\",\"outputs\":[{\"name\":\"referrals\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userId\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getMatrix4Info\",\"outputs\":[{\"name\":\"isactive\",\"type\":\"bool\"},{\"name\":\"occupiedslots\",\"type\":\"uint256\"},{\"name\":\"cyclecount\",\"type\":\"uint256\"},{\"name\":\"missedIncome\",\"type\":\"bool\"},{\"name\":\"datereg\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getRewardPoolInfo\",\"outputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"totalDirect\",\"type\":\"uint256\"},{\"name\":\"bonusPrize\",\"type\":\"uint256\"},{\"name\":\"isWinner\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardCycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matrix\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getActiveMatrix\",\"outputs\":[{\"name\":\"lastlevel\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"rewardID\",\"type\":\"uint256\"}],\"name\":\"withdrawBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAccountInfo\",\"outputs\":[{\"name\":\"userId\",\"type\":\"uint256\"},{\"name\":\"directUpline\",\"type\":\"address\"},{\"name\":\"totalRewardBonus\",\"type\":\"uint256\"},{\"name\":\"BonusID\",\"type\":\"uint256\"},{\"name\":\"PendingIncomeID\",\"type\":\"uint256\"},{\"name\":\"registered\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TotalEthTransactions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPendingIncomeID\",\"outputs\":[{\"name\":\"PendingID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"_packageLvl\",\"type\":\"uint256\"}],\"name\":\"getNetworkUpline\",\"outputs\":[{\"name\":\"upline\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userId\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getMatrix3Info\",\"outputs\":[{\"name\":\"isactive\",\"type\":\"bool\"},{\"name\":\"occupiedslots\",\"type\":\"uint256\"},{\"name\":\"cyclecount\",\"type\":\"uint256\"},{\"name\":\"datereg\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userId\",\"type\":\"uint256\"},{\"name\":\"_rewardId\",\"type\":\"uint256\"}],\"name\":\"getAvailableRewardBonus\",\"outputs\":[{\"name\":\"Balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRewardBonusIDs\",\"outputs\":[{\"name\":\"RewardBonus_IDs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAllReferrals\",\"outputs\":[{\"name\":\"referrals\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matrix\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"isMatrixActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"x4balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UnclaimeddProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_packageLvl\",\"type\":\"uint256\"},{\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getX4AvailableSlot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matrix\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"pendingId\",\"type\":\"uint256\"}],\"name\":\"getPendingIncome\",\"outputs\":[{\"name\":\"isactive\",\"type\":\"bool\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"totalHours\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userID\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"cycle\",\"type\":\"uint256\"}],\"name\":\"getMatrix4SourceType\",\"outputs\":[{\"name\":\"sourceType\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUpline\",\"outputs\":[{\"name\":\"upline\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"cycle\",\"type\":\"uint256\"}],\"name\":\"getMatrix3Referrals\",\"outputs\":[{\"name\":\"referrals\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getRewardQualifiers\",\"outputs\":[{\"name\":\"accounts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"x3balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ALPHA","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c3000e3eefae6c577d00002f1bf17d72bc4890d86f6bca09a802ac262396c800"}]}