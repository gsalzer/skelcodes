{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\n/**\r\n * @title TagRegistry\r\n * @dev Keeps the wine tags information groupped into batches.\r\n *   The contract stores only the basic info, plus a reference to IPFS file with detailed info.\r\n *   No modification is supposed to be done after registering any of the batches.\r\n */\r\ncontract TagRegistry {\r\n    /**\r\n     * @dev From which account the contract was registered.\r\n     * The only account that has full access to the data.\r\n     */\r\n    address private owner;\r\n\r\n    /**\r\n     * @dev A group of items with same set of features.\r\n     *   The actual information is stored in IPFS file storage,\r\n     *   here, we have only the references to the info.\r\n     */\r\n    struct Batch {\r\n        string ipfsSummaryHash;\r\n        string ipfsItemsHash;\r\n        address registeredBy;\r\n    }\r\n\r\n    /**\r\n     * @dev All the registered batches to find them later by ID or index.\r\n     */\r\n    mapping(bytes32 => Batch) batchesByIds;\r\n    bytes32[] batchIds;\r\n\r\n    /**\r\n     * @dev The owner can arbitrary allow (or deny) any account to register batches.\r\n     *     The expected registrars are producers of the products.\r\n     */\r\n    struct Registrar {\r\n        address ethAddress;\r\n        string name;\r\n        bool isActive;\r\n    }\r\n\r\n    /**\r\n     * @dev Producers may have their own accounts and register bathces on their own,\r\n     *   it increases credibility - producers themselves assert that the information is correct.\r\n     */\r\n    mapping(address => uint256) registrarIndexesByAddresses;\r\n    Registrar[] registrars;\r\n\r\n    /**\r\n     * @dev The public host to get the IPFS file following our stored file hash.\r\n     */\r\n    mapping(string => string) configParams;\r\n\r\n    event BatchRegistered(bytes32 batchId);\r\n    event RegistrarAdded(address ethAddress);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        addRegistrar(address(0), \"unused\", false);\r\n        addRegistrar(msg.sender, \"Contract Owner\", true);\r\n        configParams[\"ipfsHost\"] = \"https://gateway.ipfs.io/ipfs/\";\r\n        configParams[\"registeredBatchDescr\"] = \"The batch is blockchain-protected.\";\r\n        configParams[\"notRegisteredBatchDescr\"] = \"The batch is not registered!\";\r\n    }\r\n\r\n    /**\r\n     * @dev Requires a method to be called by owner only.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Access denied\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Requires a method to be called by owner any of the registered producers.\r\n     */\r\n    modifier onlyActiveRegistrar() {\r\n        uint256 registrarIndex = registrarIndexesByAddresses[msg.sender];\r\n        require(registrarIndex > 0, \"Access denied: Unknown registrar\");\r\n        require(\r\n            registrars[registrarIndex].isActive == true,\r\n            \"Access denied: inactive registrar\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev For consumers to validate the batch protection with public explorers (etherscan, or similar).\r\n     */\r\n    function getBatchInfo(string calldata batchId)\r\n        external\r\n        view\r\n        returns (\r\n            string memory description,\r\n            string memory summaryInfoLink,\r\n            string memory itemsInfoLink,\r\n            address registeredByAddress,\r\n            string memory registeredByName\r\n        )\r\n    {\r\n        require(bytes(batchId).length <= 32, \"Incorrect batch ID format\");\r\n\r\n        bytes32 batchIdBytes = stringToBytes32(batchId);\r\n        if (isBatchRegistered(batchIdBytes)) {\r\n            Batch memory batch = batchesByIds[batchIdBytes];\r\n            uint256 registrarIndex = registrarIndexesByAddresses[batch.registeredBy];\r\n            return (\r\n                configParams[\"registeredBatchDescr\"],\r\n                strConcat(configParams[\"ipfsHost\"], batch.ipfsSummaryHash),\r\n                strConcat(configParams[\"ipfsHost\"], batch.ipfsItemsHash),\r\n                batch.registeredBy,\r\n                registrars[registrarIndex].name\r\n            );\r\n        } else {\r\n            return (\r\n                configParams[\"notRegisteredBatchDescr\"],\r\n                \"\",\r\n                \"\",\r\n                address(0),\r\n                \"\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Used by the contract itself or by client scripts.\r\n     */\r\n    function isBatchRegistered(bytes32 batchId)\r\n        public\r\n        view\r\n        returns (bool isRegistered)\r\n    {\r\n        return bytes(batchesByIds[batchId].ipfsSummaryHash).length != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev To iterate the batches and check for item duplicates.\r\n     */\r\n    function getBatchesCount() public view returns (uint256 batchesCount) {\r\n        return batchIds.length;\r\n    }\r\n\r\n    /**\r\n     * @dev To check there are no item duplicates.\r\n     *   Each batch has a text file with item IDs related (SHA256 encrypted).\r\n     *   It gives the ability to automatically iterate the files and check for item duplicates.\r\n     */\r\n    function getBatchItemsLinkByIndex(uint256 batchIndex)\r\n        public\r\n        view\r\n        returns (string memory ipfsItemsHash)\r\n    {\r\n        require(\r\n            batchIndex < batchIds.length,\r\n            \"Attempt to access a non-existent Batch\"\r\n        );\r\n        return batchesByIds[batchIds[batchIndex]].ipfsItemsHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows specific account to register batches.\r\n     */\r\n    function addRegistrar(\r\n        address registrarAddress,\r\n        string memory registrarName,\r\n        bool isActive\r\n    ) public onlyOwner {\r\n        require(\r\n            bytes(registrarName).length > 0,\r\n            \"registrarName must not be blank\"\r\n        );\r\n\r\n        require(\r\n            registrarIndexesByAddresses[registrarAddress] == 0,\r\n            \"Registrar already exists\"\r\n        );\r\n\r\n        Registrar memory registrar = Registrar({\r\n            ethAddress: registrarAddress,\r\n            name: registrarName,\r\n            isActive: isActive\r\n        });\r\n\r\n        registrars.push(registrar);\r\n        uint256 registrarIndex = registrars.length - 1;\r\n        registrarIndexesByAddresses[registrarAddress] = registrarIndex;\r\n\r\n        emit RegistrarAdded(registrarAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Used to either update the name of the registrar (for case the producer brand name changes, or so),\r\n     *     or, it can be used to de-activate the registrar (e.g., disallow to register new batches).\r\n     * Providing blank registrarName leaves the name as it was before.\r\n     */\r\n    function updateRegistrar(\r\n        address registrarAddress,\r\n        string calldata registrarName,\r\n        bool isActive\r\n    ) external onlyOwner {\r\n        uint256 registrarIndex = registrarIndexesByAddresses[registrarAddress];\r\n        require(registrarIndex > 0, \"Registrar not found\");\r\n\r\n        Registrar storage registrar = registrars[registrarIndex];\r\n        if (bytes(registrarName).length > 0) {\r\n            registrar.name = registrarName;\r\n        }\r\n        registrar.isActive = isActive;\r\n    }\r\n\r\n    /**\r\n     * @dev Keeping the registrars public,\r\n     *   so anyone can check who is involved into the counterfeit-proof activity\r\n     */\r\n    function getRegistrarsCount()\r\n        public\r\n        view\r\n        returns (uint256 registrarsCount)\r\n    {\r\n        return registrars.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Keeping the registrars public,\r\n     *   so anyone can check who is involved into the counterfeit-proof activity\r\n     */\r\n    function getRegistrarByIndex(uint256 registrarIndex)\r\n        external\r\n        view\r\n        returns (address ethAddress, string memory name, bool isActive)\r\n    {\r\n        require(\r\n            registrarIndex < registrars.length,\r\n            \"Attempt to access a non-existent Registrar\"\r\n        );\r\n        Registrar memory registrar = registrars[registrarIndex];\r\n\r\n        return (registrar.ethAddress, registrar.name, registrar.isActive);\r\n    }\r\n\r\n    /**\r\n     * @dev Let's keep some flexibility for params that can change (like public IPFS URL)\r\n     */\r\n    function setConfigParam(\r\n        string calldata paramKey,\r\n        string calldata paramValue\r\n    ) external onlyOwner {\r\n        configParams[paramKey] = paramValue;\r\n    }\r\n\r\n    /**\r\n     * @dev For management purposes generaly.\r\n     */\r\n    function getConfigParam(string calldata paramKey)\r\n        external\r\n        view\r\n        onlyOwner\r\n        returns (string memory paramValue)\r\n    {\r\n        return configParams[paramKey];\r\n    }\r\n\r\n    /*\r\n     * @dev The stored batch information is immutable,\r\n     *   there is no interface to update or remove any of the registered batches.\r\n     *  The main information is kept in IPFS file storage, here we store only the references.\r\n     */\r\n    function registerBatch(\r\n        bytes32 batchId,\r\n        string calldata ipfsSummaryHash,\r\n        string calldata ipfsItemsHash\r\n    ) external onlyActiveRegistrar {\r\n        require(!isBatchRegistered(batchId), \"The batch is already registered\");\r\n\r\n        uint256 summLen = bytes(ipfsSummaryHash).length;\r\n        require(\r\n            summLen > 0 && summLen <= 128,\r\n            \"Incorrect IPFS Summary hash format\"\r\n        );\r\n\r\n        uint256 itemsLen = bytes(ipfsItemsHash).length;\r\n        require(\r\n            itemsLen > 0 && itemsLen <= 128,\r\n            \"Incorrect IPFS Items hash format\"\r\n        );\r\n\r\n        Batch memory batch = Batch({\r\n            ipfsSummaryHash: ipfsSummaryHash,\r\n            ipfsItemsHash: ipfsItemsHash,\r\n            registeredBy: msg.sender\r\n        });\r\n        batchesByIds[batchId] = batch;\r\n        batchIds.push(batchId);\r\n\r\n        emit BatchRegistered(batchId);\r\n    }\r\n\r\n    function strConcat(string memory s1, string memory s2)\r\n        internal\r\n        pure\r\n        returns (string memory resStr)\r\n    {\r\n        bytes memory bytesS1 = bytes(s1);\r\n        bytes memory bytesS2 = bytes(s2);\r\n        bytes memory res = new bytes(bytesS1.length + bytesS2.length);\r\n\r\n        uint256 k = 0;\r\n        uint256 i = 0;\r\n        for (i = 0; i < bytesS1.length; i++) res[k++] = bytesS1[i];\r\n        for (i = 0; i < bytesS2.length; i++) res[k++] = bytesS2[i];\r\n\r\n        return string(res);\r\n    }\r\n\r\n    function stringToBytes32(string memory source)\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"batchId\",\"type\":\"bytes32\"},{\"name\":\"ipfsSummaryHash\",\"type\":\"string\"},{\"name\":\"ipfsItemsHash\",\"type\":\"string\"}],\"name\":\"registerBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"batchId\",\"type\":\"bytes32\"}],\"name\":\"isBatchRegistered\",\"outputs\":[{\"name\":\"isRegistered\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"registrarAddress\",\"type\":\"address\"},{\"name\":\"registrarName\",\"type\":\"string\"},{\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"updateRegistrar\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"registrarIndex\",\"type\":\"uint256\"}],\"name\":\"getRegistrarByIndex\",\"outputs\":[{\"name\":\"ethAddress\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"isActive\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"paramKey\",\"type\":\"string\"}],\"name\":\"getConfigParam\",\"outputs\":[{\"name\":\"paramValue\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"batchIndex\",\"type\":\"uint256\"}],\"name\":\"getBatchItemsLinkByIndex\",\"outputs\":[{\"name\":\"ipfsItemsHash\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBatchesCount\",\"outputs\":[{\"name\":\"batchesCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRegistrarsCount\",\"outputs\":[{\"name\":\"registrarsCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"registrarAddress\",\"type\":\"address\"},{\"name\":\"registrarName\",\"type\":\"string\"},{\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"addRegistrar\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"batchId\",\"type\":\"string\"}],\"name\":\"getBatchInfo\",\"outputs\":[{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"summaryInfoLink\",\"type\":\"string\"},{\"name\":\"itemsInfoLink\",\"type\":\"string\"},{\"name\":\"registeredByAddress\",\"type\":\"address\"},{\"name\":\"registeredByName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"paramKey\",\"type\":\"string\"},{\"name\":\"paramValue\",\"type\":\"string\"}],\"name\":\"setConfigParam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"batchId\",\"type\":\"bytes32\"}],\"name\":\"BatchRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAddress\",\"type\":\"address\"}],\"name\":\"RegistrarAdded\",\"type\":\"event\"}]","ContractName":"TagRegistry","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://304cec94948f57db4e998be15eafa108a81e3dbd9d794c7d2381f99cc78f650a"}]}