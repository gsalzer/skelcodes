{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/bot/CustomOwned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\ncontract CustomOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    constructor () public { owner = msg.sender; }\r\n\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner && _newOwner != address(0), \"Unauthorized\");\r\n        emit OwnerUpdate(owner, _newOwner);\r\n        owner = _newOwner;\r\n        newOwner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"Invalid\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"Unauthorized\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n// File: contracts/token/interfaces/IERC20Token.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {this;}\r\n    function symbol() public view returns (string) {this;}\r\n    function decimals() public view returns (uint8) {this;}\r\n    function totalSupply() public view returns (uint256) {this;}\r\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/utility/interfaces/IOwned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {this;}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n// File: contracts/utility/interfaces/ITokenHolder.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ncontract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/converter/interfaces/IConverterAnchor.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Converter Anchor interface\r\n*/\r\ncontract IConverterAnchor is IOwned, ITokenHolder {\r\n}\r\n\r\n// File: contracts/token/interfaces/ISmartToken.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IConverterAnchor, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/IBancorNetwork.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Bancor Network interface\r\n*/\r\ncontract IBancorNetwork {\r\n    function convert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public returns (uint256);\r\n\r\n    function convertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function claimAndConvert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convertFor(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function claimAndConvertFor(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public returns (uint256);\r\n\r\n    function rateByPath(\r\n        IERC20Token[] _path,\r\n        uint256 _amount\r\n    ) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/utility/interfaces/IContractRegistry.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n// File: contracts/bot/ArbBot.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ArbBot is CustomOwned {\r\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\r\n\r\n    IERC20Token public tokenBNT;\r\n    IERC20Token public tokenUSDB;\r\n    IERC20Token public tokenDAI;\r\n    IERC20Token public tokenPEGUSD;\r\n\r\n    ISmartToken public relayUSDB;\r\n    ISmartToken public relayDAI;\r\n    ISmartToken public relayPEGUSD;\r\n\r\n    IContractRegistry public registry;\r\n\r\n    uint256 public tradeValue = 5 ether;\r\n    uint256 public threshold = 0;\r\n\r\n    constructor (\r\n        IERC20Token _tokenBNT,\r\n        IERC20Token _tokenDAI,\r\n        IERC20Token _tokenUSDB,\r\n        IERC20Token _tokenPEGUSD,\r\n        ISmartToken _relayUSDB,\r\n        ISmartToken _relayDAI,\r\n        ISmartToken _relayPEGUSD,\r\n        IContractRegistry _registry\r\n    ) public {\r\n        tokenBNT = _tokenBNT;\r\n        tokenDAI = _tokenDAI;\r\n        tokenUSDB = _tokenUSDB;\r\n        tokenPEGUSD = _tokenPEGUSD;\r\n\r\n        relayUSDB = _relayUSDB;\r\n        relayDAI = _relayDAI;\r\n        relayPEGUSD = _relayPEGUSD;\r\n\r\n        registry = _registry;\r\n    }\r\n\r\n    function generatePath (bool _isUSDB, bool _fromUSD) private view returns(IERC20Token[] memory) {\r\n        IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD;\r\n        ISmartToken relayUSD = (_isUSDB == true) ? relayUSDB : relayPEGUSD;\r\n\r\n        IERC20Token[] memory path = new IERC20Token[](5);\r\n        if(_fromUSD) {\r\n            path[0] = tokenUSD;\r\n            path[1] = IERC20Token(relayUSD);\r\n            path[2] = tokenBNT;\r\n            path[3] = IERC20Token(relayDAI);\r\n            path[4] = tokenDAI;\r\n        } else {\r\n            path[0] = tokenDAI;\r\n            path[1] = IERC20Token(relayDAI);\r\n            path[2] = tokenBNT;\r\n            path[3] = IERC20Token(relayUSD);\r\n            path[4] = tokenUSD;\r\n        }\r\n\r\n        return path;\r\n    }\r\n\r\n    function getReturnDAI (bool _isUSDB) public view returns(uint256) {\r\n        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));\r\n        return network.rateByPath(generatePath(_isUSDB, false), tradeValue);\r\n    }\r\n\r\n    function getReturnUSD (bool _isUSDB) public view returns(uint256) {\r\n        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));\r\n        return network.rateByPath(generatePath(_isUSDB, true), tradeValue);\r\n    }\r\n\r\n    function isReadyToTrade(bool _isUSDB) public view returns(bool) {\r\n        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));\r\n        uint256 returnUSD = network.rateByPath(generatePath(_isUSDB, true), tradeValue);\r\n        uint256 returnDAI = network.rateByPath(generatePath(_isUSDB, false), tradeValue);\r\n        if(returnDAI > tradeValue) {\r\n            return ((returnDAI - tradeValue) >= threshold);\r\n        } else {\r\n            if(returnUSD > tradeValue)\r\n                return ((returnUSD - tradeValue) >= threshold);\r\n            else\r\n                return false;\r\n        }\r\n    }\r\n\r\n    function testTrade(bool _isUSDB, bool _fromUSD) public ownerOnly returns(bool) {\r\n        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));\r\n        network.convertFor(generatePath(_isUSDB, _fromUSD), tradeValue, tradeValue, address(this));\r\n    }\r\n\r\n    function trade(bool _isUSDB) public returns(bool) {\r\n        IBancorNetwork network = IBancorNetwork(registry.addressOf(BANCOR_NETWORK));\r\n        uint256 returnUSD = network.rateByPath(generatePath(_isUSDB, true), tradeValue);\r\n        uint256 returnDAI = network.rateByPath(generatePath(_isUSDB, false), tradeValue);\r\n        IERC20Token tokenUSD = (_isUSDB == true) ? tokenUSDB : tokenPEGUSD;\r\n\r\n        if(returnDAI > tradeValue) {\r\n            require((returnDAI - tradeValue) >= threshold, 'Trade not yet available.');\r\n            require(tokenUSD.balanceOf(address(this)) >= tradeValue, 'Insufficient USD balance.');\r\n            network.convertFor(generatePath(_isUSDB, true), tradeValue, tradeValue, address(this));\r\n        } else {\r\n            require(returnUSD > tradeValue, 'Trade not yet available.');\r\n            require((returnUSD - tradeValue) >= threshold, 'Trade not yet available.');\r\n            require(tokenDAI.balanceOf(address(this)) >= tradeValue, 'Insufficient DAI balance.');\r\n            network.convertFor(generatePath(_isUSDB, false), tradeValue, tradeValue, address(this));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function unlockTokensConverter() public {\r\n        tokenUSDB.approve(address(relayUSDB.owner()), 0);\r\n        tokenUSDB.approve(address(relayUSDB.owner()), 1000000 ether);\r\n\r\n        tokenDAI.approve(address(relayDAI.owner()), 0);\r\n        tokenDAI.approve(address(relayDAI.owner()), 1000000 ether);\r\n\r\n        tokenPEGUSD.approve(address(relayPEGUSD.owner()), 0);\r\n        tokenPEGUSD.approve(address(relayPEGUSD.owner()), 1000000 ether);\r\n    }\r\n\r\n    function unlockTokensNetwork() public {\r\n        tokenUSDB.approve(address(relayUSDB.owner()), 0);\r\n        tokenUSDB.approve(address(relayUSDB.owner()), 1000000 ether);\r\n\r\n        tokenDAI.approve(address(relayDAI.owner()), 0);\r\n        tokenDAI.approve(address(relayDAI.owner()), 1000000 ether);\r\n\r\n        tokenPEGUSD.approve(address(relayPEGUSD.owner()), 0);\r\n        tokenPEGUSD.approve(address(relayPEGUSD.owner()), 1000000 ether);\r\n    }\r\n\r\n    function updateTradeValue(uint256 _tradeValue) public ownerOnly {\r\n        tradeValue = _tradeValue;\r\n    }\r\n\r\n    function updateThreshold(uint256 _threshold) public ownerOnly {\r\n        threshold = _threshold;\r\n    }\r\n\r\n    function updateRegistry(IContractRegistry _registry) public ownerOnly {\r\n        registry = _registry;\r\n    }\r\n\r\n    function updateTokens(\r\n        IERC20Token _tokenBNT,\r\n        IERC20Token _tokenDAI,\r\n        IERC20Token _tokenUSDB,\r\n        IERC20Token _tokenPEGUSD\r\n    ) public ownerOnly {\r\n        tokenBNT = _tokenBNT;\r\n        tokenDAI = _tokenDAI;\r\n        tokenUSDB = _tokenUSDB;\r\n        tokenPEGUSD = _tokenPEGUSD;\r\n    }\r\n\r\n    function updateRelays(\r\n        ISmartToken _relayUSDB,\r\n        ISmartToken _relayDAI,\r\n        ISmartToken _relayPEGUSD\r\n    ) public ownerOnly {\r\n        relayUSDB = _relayUSDB;\r\n        relayDAI = _relayDAI;\r\n        relayPEGUSD = _relayPEGUSD;\r\n    }\r\n\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public ownerOnly {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n\r\n    function() public payable {}\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayDAI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"updateRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_relayUSDB\",\"type\":\"address\"},{\"name\":\"_relayDAI\",\"type\":\"address\"},{\"name\":\"_relayPEGUSD\",\"type\":\"address\"}],\"name\":\"updateRelays\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isUSDB\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBNT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_isUSDB\",\"type\":\"bool\"}],\"name\":\"getReturnUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockTokensConverter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenBNT\",\"type\":\"address\"},{\"name\":\"_tokenDAI\",\"type\":\"address\"},{\"name\":\"_tokenUSDB\",\"type\":\"address\"},{\"name\":\"_tokenPEGUSD\",\"type\":\"address\"}],\"name\":\"updateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockTokensNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeValue\",\"type\":\"uint256\"}],\"name\":\"updateTradeValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayUSDB\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayPEGUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_isUSDB\",\"type\":\"bool\"}],\"name\":\"getReturnDAI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_isUSDB\",\"type\":\"bool\"}],\"name\":\"isReadyToTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPEGUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenDAI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"updateThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenUSDB\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isUSDB\",\"type\":\"bool\"},{\"name\":\"_fromUSD\",\"type\":\"bool\"}],\"name\":\"testTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenBNT\",\"type\":\"address\"},{\"name\":\"_tokenDAI\",\"type\":\"address\"},{\"name\":\"_tokenUSDB\",\"type\":\"address\"},{\"name\":\"_tokenPEGUSD\",\"type\":\"address\"},{\"name\":\"_relayUSDB\",\"type\":\"address\"},{\"name\":\"_relayDAI\",\"type\":\"address\"},{\"name\":\"_relayPEGUSD\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"ArbBot","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001f573d6fb3f13d689ff844b4ce37794d79a7ff1c0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000309627af60f0926daa6041b8279484312f2bf060000000000000000000000000a485bd50228440797abb4d4595161d7546811160000000000000000000000000d1146b08e8104eedba44a73b7bda1d102c6cedc9000000000000000000000000e5df055773bf9710053923599504831c7dbdd697000000000000000000000000607108c46bce4cf6f86698e9b46e3270a734fefe00000000000000000000000052ae12abe5d8bd778bd5397f99ca900624cfadd4","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://986e1a894e61d6e22c94fc8112b5981f476a31ef86c8a90d4f16623068fcbe82"}]}