{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        require(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        require(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        require(token.approve(spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n}\r\n\r\n// File: contracts/loopring/iface/IBrokerRegistry.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title IBrokerRegistry\r\n/// @dev A broker is an account that can submit orders on behalf of other\r\n///      accounts. When registering a broker, the owner can also specify a\r\n///      pre-deployed BrokerInterceptor to hook into the exchange smart contracts.\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract IBrokerRegistry {\r\n    event BrokerRegistered(\r\n        address owner,\r\n        address broker,\r\n        address interceptor\r\n    );\r\n\r\n    event BrokerUnregistered(\r\n        address owner,\r\n        address broker,\r\n        address interceptor\r\n    );\r\n\r\n    event AllBrokersUnregistered(\r\n        address owner\r\n    );\r\n\r\n    /// @dev   Validates if the broker was registered for the order owner and\r\n    ///        returns the possible BrokerInterceptor to be used.\r\n    /// @param owner The owner of the order\r\n    /// @param broker The broker of the order\r\n    /// @return True if the broker was registered for the owner\r\n    ///         and the BrokerInterceptor to use.\r\n    function getBroker(\r\n        address owner,\r\n        address broker\r\n        )\r\n        external\r\n        view\r\n        returns(\r\n            bool registered,\r\n            address interceptor\r\n        );\r\n\r\n    /// @dev   Gets all registered brokers for an owner.\r\n    /// @param owner The owner\r\n    /// @param start The start index of the list of brokers\r\n    /// @param count The number of brokers to return\r\n    /// @return The list of requested brokers and corresponding BrokerInterceptors\r\n    function getBrokers(\r\n        address owner,\r\n        uint    start,\r\n        uint    count\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory brokers,\r\n            address[] memory interceptors\r\n        );\r\n\r\n    /// @dev   Registers a broker for msg.sender and an optional\r\n    ///        corresponding BrokerInterceptor.\r\n    /// @param broker The broker to register\r\n    /// @param interceptor The optional BrokerInterceptor to use (0x0 allowed)\r\n    function registerBroker(\r\n        address broker,\r\n        address interceptor\r\n        )\r\n        external;\r\n\r\n    /// @dev   Unregisters a broker for msg.sender\r\n    /// @param broker The broker to unregister\r\n    function unregisterBroker(\r\n        address broker\r\n        )\r\n        external;\r\n\r\n    /// @dev   Unregisters all brokers for msg.sender\r\n    function unregisterAllBrokers(\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/iface/IBurnRateTable.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @title IBurnRateTable - A contract for managing burn rates for tokens\r\ncontract IBurnRateTable {\r\n\r\n    struct TokenData {\r\n        uint    tier;\r\n        uint    validUntil;\r\n    }\r\n\r\n    mapping(address => TokenData) public tokens;\r\n\r\n    uint public constant YEAR_TO_SECONDS = 31556952;\r\n\r\n    // Tiers\r\n    uint8 public constant TIER_4 = 0;\r\n    uint8 public constant TIER_3 = 1;\r\n    uint8 public constant TIER_2 = 2;\r\n    uint8 public constant TIER_1 = 3;\r\n\r\n    uint16 public constant BURN_BASE_PERCENTAGE           =                 100 * 10; // 100%\r\n\r\n    // Cost of upgrading the tier level of a token in a percentage of the total LRC supply\r\n    uint16 public constant TIER_UPGRADE_COST_PERCENTAGE   =                        1; // 0.1%\r\n\r\n    // Burn rates\r\n    // Matching\r\n    uint16 public constant BURN_MATCHING_TIER1            =                       25; // 2.5%\r\n    uint16 public constant BURN_MATCHING_TIER2            =                  15 * 10; //  15%\r\n    uint16 public constant BURN_MATCHING_TIER3            =                  30 * 10; //  30%\r\n    uint16 public constant BURN_MATCHING_TIER4            =                  50 * 10; //  50%\r\n    // P2P\r\n    uint16 public constant BURN_P2P_TIER1                 =                       25; // 2.5%\r\n    uint16 public constant BURN_P2P_TIER2                 =                  15 * 10; //  15%\r\n    uint16 public constant BURN_P2P_TIER3                 =                  30 * 10; //  30%\r\n    uint16 public constant BURN_P2P_TIER4                 =                  50 * 10; //  50%\r\n\r\n    event TokenTierUpgraded(\r\n        address indexed addr,\r\n        uint            tier\r\n    );\r\n\r\n    /// @dev   Returns the P2P and matching burn rate for the token.\r\n    /// @param token The token to get the burn rate for.\r\n    /// @return The burn rate. The P2P burn rate and matching burn rate\r\n    ///         are packed together in the lowest 4 bytes.\r\n    ///         (2 bytes P2P, 2 bytes matching)\r\n    function getBurnRate(\r\n        address token\r\n        )\r\n        external\r\n        view\r\n        returns (uint32 burnRate);\r\n\r\n    /// @dev   Returns the tier of a token.\r\n    /// @param token The token to get the token tier for.\r\n    /// @return The tier of the token\r\n    function getTokenTier(\r\n        address token\r\n        )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev   Upgrades the tier of a token. Before calling this function,\r\n    ///        msg.sender needs to approve this contract for the neccessary funds.\r\n    /// @param token The token to upgrade the tier for.\r\n    /// @return True if successful, false otherwise.\r\n    function upgradeTokenTier(\r\n        address token\r\n        )\r\n        external\r\n        returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/loopring/iface/IFeeHolder.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>\r\n/// @title IFeeHolder - A contract holding fees.\r\ncontract IFeeHolder {\r\n\r\n    event TokenWithdrawn(\r\n        address owner,\r\n        address token,\r\n        uint value\r\n    );\r\n\r\n    // A map of all fee balances\r\n    mapping(address => mapping(address => uint)) public feeBalances;\r\n\r\n    // A map of all the nonces for a withdrawTokenFor request\r\n    mapping(address => uint) public nonces;\r\n\r\n    /// @dev   Allows withdrawing the tokens to be burned by\r\n    ///        authorized contracts.\r\n    /// @param token The token to be used to burn buy and burn LRC\r\n    /// @param value The amount of tokens to withdraw\r\n    function withdrawBurned(\r\n        address token,\r\n        uint value\r\n        )\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @dev   Allows withdrawing the fee payments funds\r\n    ///        msg.sender is the recipient of the fee and the address\r\n    ///        to which the tokens will be sent.\r\n    /// @param token The token to withdraw\r\n    /// @param value The amount of tokens to withdraw\r\n    function withdrawToken(\r\n        address token,\r\n        uint value\r\n        )\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @dev   Allows withdrawing the fee payments funds by providing a\r\n    ///        a signature\r\n    function withdrawTokenFor(\r\n      address owner,\r\n      address token,\r\n      uint value,\r\n      address recipient,\r\n      uint feeValue,\r\n      address feeRecipient,\r\n      uint nonce,\r\n      bytes calldata signature\r\n      )\r\n      external\r\n      returns (bool success);\r\n\r\n    function batchAddFeeBalances(\r\n        bytes32[] calldata batch\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/iface/IOrderBook.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title IOrderBook\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>.\r\ncontract IOrderBook {\r\n    // The map of registered order hashes\r\n    mapping(bytes32 => bool) public orderSubmitted;\r\n\r\n    /// @dev  Event emitted when an order was successfully submitted\r\n    ///        orderHash      The hash of the order\r\n    ///        orderData      The data of the order as passed to submitOrder()\r\n    event OrderSubmitted(\r\n        bytes32 orderHash,\r\n        bytes   orderData\r\n    );\r\n\r\n    /// @dev   Submits an order to the on-chain order book.\r\n    ///        No signature is needed. The order can only be sumbitted by its\r\n    ///        owner or its broker (the owner can be the address of a contract).\r\n    /// @param orderData The data of the order. Contains all fields that are used\r\n    ///        for the order hash calculation.\r\n    ///        See OrderHelper.updateHash() for detailed information.\r\n    function submitOrder(\r\n        bytes calldata orderData\r\n        )\r\n        external\r\n        returns (bytes32);\r\n}\r\n\r\n// File: contracts/loopring/iface/IOrderRegistry.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title IOrderRegistry\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract IOrderRegistry {\r\n\r\n    /// @dev   Returns wether the order hash was registered in the registry.\r\n    /// @param broker The broker of the order\r\n    /// @param orderHash The hash of the order\r\n    /// @return True if the order hash was registered, else false.\r\n    function isOrderHashRegistered(\r\n        address broker,\r\n        bytes32 orderHash\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev   Registers an order in the registry.\r\n    ///        msg.sender needs to be the broker of the order.\r\n    /// @param orderHash The hash of the order\r\n    function registerOrderHash(\r\n        bytes32 orderHash\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/impl/BrokerData.sol\r\n\r\npragma solidity ^0.5.7;\r\n\r\nlibrary BrokerData {\r\n\r\n  struct BrokerOrder {\r\n    address owner;\r\n    bytes32 orderHash;\r\n    uint fillAmountB;\r\n    uint requestedAmountS;\r\n    uint requestedFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n  /**\r\n   * The request wraps all broker orders that share the following overall fields. The perspective on these fields is\r\n   * the orders that are passed in. Meaning, `tokenB` is the token being RECEIVED by each owner and `tokenS` is the\r\n   * token being SPENT by each owner. Lastly, `totalRequestedFeeAmount` is the total `feeAmountS` for all brokered\r\n   * orders. If the fees are in `tokenB`, then this amount is always 0.\r\n   */\r\n  struct BrokerApprovalRequest {\r\n    BrokerOrder[] orders;\r\n    address tokenS;\r\n    address tokenB;\r\n    address feeToken;\r\n    uint totalFillAmountB;\r\n    uint totalRequestedAmountS;\r\n    uint totalRequestedFeeAmount;\r\n  }\r\n\r\n  struct BrokerInterceptorReport {\r\n    address owner;\r\n    address broker;\r\n    bytes32 orderHash;\r\n    address tokenB;\r\n    address tokenS;\r\n    address feeToken;\r\n    uint fillAmountB;\r\n    uint spentAmountS;\r\n    uint spentFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/loopring/iface/ILoopringTradeDelegate.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/// @title ILoopringTradeDelegate\r\n/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\r\n/// versions of Loopring protocol to avoid ERC20 re-authorization.\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract ILoopringTradeDelegate {\r\n\r\n    function isTrustedSubmitter(address submitter) public view returns (bool);\r\n\r\n    function addTrustedSubmitter(address submitter) public;\r\n\r\n    function removeTrustedSubmitter(address submitter) public;\r\n\r\n    function batchTransfer(\r\n        bytes32[] calldata batch\r\n    ) external;\r\n\r\n    function brokerTransfer(\r\n        address token,\r\n        address broker,\r\n        address recipient,\r\n        uint amount\r\n    ) external;\r\n\r\n    function proxyBrokerRequestAllowance(\r\n        BrokerData.BrokerApprovalRequest memory request,\r\n        address broker\r\n    ) public returns (bool);\r\n\r\n\r\n    /// @dev Add a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function authorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    /// @dev Remove a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function deauthorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    function isAddressAuthorized(\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n\r\n    function suspend()\r\n        external;\r\n\r\n    function resume()\r\n        external;\r\n\r\n    function kill()\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/iface/ITradeHistory.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title ITradeHistory\r\n/// @dev Stores the trade history and cancelled data of orders\r\n/// @author Brecht Devos - <brecht@loopring.org>.\r\ncontract ITradeHistory {\r\n\r\n    // The following map is used to keep trace of order fill and cancellation\r\n    // history.\r\n    mapping (bytes32 => uint) public filled;\r\n\r\n    // This map is used to keep trace of order's cancellation history.\r\n    mapping (address => mapping (bytes32 => bool)) public cancelled;\r\n\r\n    // A map from a broker to its cutoff timestamp.\r\n    mapping (address => uint) public cutoffs;\r\n\r\n    // A map from a broker to its trading-pair cutoff timestamp.\r\n    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\r\n\r\n    // A map from a broker to an order owner to its cutoff timestamp.\r\n    mapping (address => mapping (address => uint)) public cutoffsOwner;\r\n\r\n    // A map from a broker to an order owner to its trading-pair cutoff timestamp.\r\n    mapping (address => mapping (address => mapping (bytes20 => uint))) public tradingPairCutoffsOwner;\r\n\r\n\r\n    function batchUpdateFilled(\r\n        bytes32[] calldata filledInfo\r\n        )\r\n        external;\r\n\r\n    function setCancelled(\r\n        address broker,\r\n        bytes32 orderHash\r\n        )\r\n        external;\r\n\r\n    function setCutoffs(\r\n        address broker,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setTradingPairCutoffs(\r\n        address broker,\r\n        bytes20 tokenPair,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setCutoffsOfOwner(\r\n        address broker,\r\n        address owner,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setTradingPairCutoffsOfOwner(\r\n        address broker,\r\n        address owner,\r\n        bytes20 tokenPair,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function batchGetFilledAndCheckCancelled(\r\n        bytes32[] calldata orderInfo\r\n        )\r\n        external\r\n        view\r\n        returns (uint[] memory fills);\r\n\r\n\r\n    /// @dev Add a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function authorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    /// @dev Remove a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function deauthorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    function isAddressAuthorized(\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n\r\n    function suspend()\r\n        external;\r\n\r\n    function resume()\r\n        external;\r\n\r\n    function kill()\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/impl/Data.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary Data {\r\n\r\n    enum TokenType { ERC20 }\r\n\r\n    struct Header {\r\n        uint version;\r\n        uint numOrders;\r\n        uint numRings;\r\n        uint numSpendables;\r\n    }\r\n\r\n    struct BrokerAction {\r\n        bytes32 hash;\r\n        address broker;\r\n        uint[] orderIndices;\r\n        uint numOrders;\r\n        uint[] transferIndices;\r\n        uint numTransfers;\r\n        address tokenS;\r\n        address tokenB;\r\n        address feeToken;\r\n        address delegate;\r\n    }\r\n\r\n    struct BrokerTransfer {\r\n        bytes32 hash;\r\n        address token;\r\n        uint amount;\r\n        address recipient;\r\n    }\r\n\r\n    struct Context {\r\n        address lrcTokenAddress;\r\n        ILoopringTradeDelegate delegate;\r\n        ITradeHistory   tradeHistory;\r\n        IBrokerRegistry orderBrokerRegistry;\r\n        IOrderRegistry  orderRegistry;\r\n        IFeeHolder feeHolder;\r\n        IOrderBook orderBook;\r\n        IBurnRateTable burnRateTable;\r\n        uint64 ringIndex;\r\n        uint feePercentageBase;\r\n        bytes32[] tokenBurnRates;\r\n        uint feeData;\r\n        uint feePtr;\r\n        uint transferData;\r\n        uint transferPtr;\r\n        BrokerData.BrokerOrder[] brokerOrders;\r\n        BrokerAction[] brokerActions;\r\n        BrokerTransfer[] brokerTransfers;\r\n        uint numBrokerOrders;\r\n        uint numBrokerActions;\r\n        uint numBrokerTransfers;\r\n    }\r\n\r\n    struct Mining {\r\n        // required fields\r\n        address feeRecipient;\r\n\r\n        // optional fields\r\n        address miner;\r\n        bytes   sig;\r\n\r\n        // computed fields\r\n        bytes32 hash;\r\n        address interceptor;\r\n    }\r\n\r\n    struct Spendable {\r\n        bool initialized;\r\n        uint amount;\r\n        uint reserved;\r\n    }\r\n\r\n    struct Order {\r\n        uint      version;\r\n\r\n        // required fields\r\n        address   owner;\r\n        address   tokenS;\r\n        address   tokenB;\r\n        uint      amountS;\r\n        uint      amountB;\r\n        uint      validSince;\r\n        Spendable tokenSpendableS;\r\n        Spendable tokenSpendableFee;\r\n\r\n        // optional fields\r\n        address   dualAuthAddr;\r\n        address   broker;\r\n        Spendable brokerSpendableS;\r\n        Spendable brokerSpendableFee;\r\n        address   orderInterceptor;\r\n        address   wallet;\r\n        uint      validUntil;\r\n        bytes     sig;\r\n        bytes     dualAuthSig;\r\n        bool      allOrNone;\r\n        address   feeToken;\r\n        uint      feeAmount;\r\n        int16     waiveFeePercentage;\r\n        uint16    tokenSFeePercentage;    // Pre-trading\r\n        uint16    tokenBFeePercentage;   // Post-trading\r\n        address   tokenRecipient;\r\n        uint16    walletSplitPercentage;\r\n\r\n        // computed fields\r\n        bool    P2P;\r\n        bytes32 hash;\r\n        address brokerInterceptor;\r\n        uint    filledAmountS;\r\n        uint    initialFilledAmountS;\r\n        bool    valid;\r\n\r\n        TokenType tokenTypeS;\r\n        TokenType tokenTypeB;\r\n        TokenType tokenTypeFee;\r\n        bytes32 trancheS;\r\n        bytes32 trancheB;\r\n        uint    maxPrimaryFillAmount;\r\n        bool    transferFirstAsMaker;\r\n        bytes   transferDataS;\r\n    }\r\n\r\n    struct Participation {\r\n        // required fields\r\n        Order order;\r\n\r\n        // computed fields\r\n        uint splitS;\r\n        uint feeAmount;\r\n        uint feeAmountS;\r\n        uint feeAmountB;\r\n        uint rebateFee;\r\n        uint rebateS;\r\n        uint rebateB;\r\n        uint fillAmountS;\r\n        uint fillAmountB;\r\n    }\r\n\r\n    struct Ring {\r\n        uint size;\r\n        Participation[] participations;\r\n        bytes32 hash;\r\n        uint minerFeesToOrdersPercentage;\r\n        bool valid;\r\n    }\r\n\r\n    struct RingIndices {\r\n        uint index0;\r\n        uint index1;\r\n    }\r\n\r\n    struct FeeContext {\r\n        Data.Ring ring;\r\n        Data.Context ctx;\r\n        address feeRecipient;\r\n        uint walletPercentage;\r\n        int16 waiveFeePercentage;\r\n        address owner;\r\n        address wallet;\r\n        bool P2P;\r\n    }\r\n\r\n//    struct SubmitRingsRequest {\r\n//        Data.Mining  mining;\r\n//        Data.Order[] orders;\r\n//        Data.RingIndices[]  ringIndices;\r\n//    }\r\n\r\n}\r\n\r\n// File: @dydxprotocol/solo/contracts/protocol/lib/Monetary.sol\r\n\r\n/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/**\r\n * @title Monetary\r\n * @author dYdX\r\n *\r\n * Library for types involving money\r\n */\r\nlibrary Monetary {\r\n\r\n    /*\r\n     * The price of a base-unit of an asset.\r\n     */\r\n    struct Price {\r\n        uint256 value;\r\n    }\r\n\r\n    /*\r\n     * Total value of an some amount of an asset. Equal to (price * amount).\r\n     */\r\n    struct Value {\r\n        uint256 value;\r\n    }\r\n}\r\n\r\n// File: @dydxprotocol/solo/contracts/protocol/lib/Require.sol\r\n\r\n/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/**\r\n * @title Require\r\n * @author dYdX\r\n *\r\n * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\r\n */\r\nlibrary Require {\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant ASCII_ZERO = 48; // '0'\r\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\r\n    uint256 constant ASCII_LOWER_EX = 120; // 'x'\r\n    bytes2 constant COLON = 0x3a20; // ': '\r\n    bytes2 constant COMMA = 0x2c20; // ', '\r\n    bytes2 constant LPAREN = 0x203c; // ' <'\r\n    byte constant RPAREN = 0x3e; // '>'\r\n    uint256 constant FOUR_BIT_MASK = 0xf;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function stringifyTruncated(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        // put the input bytes into the result\r\n        bytes memory result = abi.encodePacked(input);\r\n\r\n        // determine the length of the input by finding the location of the last non-zero byte\r\n        for (uint256 i = 32; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // find the last non-zero byte in order to determine the length\r\n            if (result[i] != 0) {\r\n                uint256 length = i + 1;\r\n\r\n                /* solium-disable-next-line security/no-inline-assembly */\r\n                assembly {\r\n                    mstore(result, length) // r.length = length;\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        // all bytes are zero\r\n        return new bytes(0);\r\n    }\r\n\r\n    function stringify(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (input == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        // get the final string length\r\n        uint256 j = input;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n\r\n        // allocate the string\r\n        bytes memory bstr = new bytes(length);\r\n\r\n        // populate the string starting with the least-significant character\r\n        j = input;\r\n        for (uint256 i = length; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // take last decimal digit\r\n            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\r\n\r\n            // remove the last decimal digit\r\n            j /= 10;\r\n        }\r\n\r\n        return bstr;\r\n    }\r\n\r\n    function stringify(\r\n        address input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // addresses are \"0x\" followed by 20 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(42);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[41 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[40 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function stringify(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // bytes32 are \"0x\" followed by 32 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(66);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[65 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[64 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function char(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (byte)\r\n    {\r\n        // return ASCII digit (0-9)\r\n        if (input < 10) {\r\n            return byte(uint8(input + ASCII_ZERO));\r\n        }\r\n\r\n        // return ASCII letter (a-f)\r\n        return byte(uint8(input + ASCII_RELATIVE_ZERO));\r\n    }\r\n}\r\n\r\n// File: @dydxprotocol/solo/contracts/protocol/lib/Math.sol\r\n\r\n/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Math\r\n * @author dYdX\r\n *\r\n * Library for non-standard Math functions\r\n */\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Math\";\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /*\r\n     * Return target * (numerator / denominator), but rounded up.\r\n     */\r\n    function getPartialRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    function to128(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint128)\r\n    {\r\n        uint128 result = uint128(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint128\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to96(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint96)\r\n    {\r\n        uint96 result = uint96(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint96\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to32(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        uint32 result = uint32(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint32\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n// File: @dydxprotocol/solo/contracts/protocol/lib/Types.sol\r\n\r\n/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Types\r\n * @author dYdX\r\n *\r\n * Library for interacting with the basic structs used in Solo\r\n */\r\nlibrary Types {\r\n    using Math for uint256;\r\n\r\n    // ============ AssetAmount ============\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Par (Principal Amount) ============\r\n\r\n    // Total borrow and supply values for a market\r\n    struct TotalPar {\r\n        uint128 borrow;\r\n        uint128 supply;\r\n    }\r\n\r\n    // Individual principal amount for an account\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    function zeroPar()\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: false,\r\n            value: 0\r\n        });\r\n    }\r\n\r\n    function sub(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        Par memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value).to128();\r\n        } else {\r\n            if (a.value >= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value).to128();\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value).to128();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: !a.sign,\r\n            value: a.value\r\n        });\r\n    }\r\n\r\n    function isNegative(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !a.sign && a.value > 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.sign && a.value > 0;\r\n    }\r\n\r\n    function isZero(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n\r\n    // ============ Wei (Token Amount) ============\r\n\r\n    // Individual token amount for an account\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n    function zeroWei()\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: false,\r\n            value: 0\r\n        });\r\n    }\r\n\r\n    function sub(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        Wei memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value);\r\n        } else {\r\n            if (a.value >= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value);\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: !a.sign,\r\n            value: a.value\r\n        });\r\n    }\r\n\r\n    function isNegative(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !a.sign && a.value > 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.sign && a.value > 0;\r\n    }\r\n\r\n    function isZero(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n}\r\n\r\n// File: contracts/dolomite-margin-protocol/external/ExternalDefinitions.sol\r\n\r\n/*\r\n * Copyright 2020 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n// ---------------------------------\r\n// Dolomite Direct Includes\r\n\r\ninterface IDepositContractRegistry {\r\n    function depositAddressOf(address owner) external view returns (address payable);\r\n\r\n    function operatorOf(address owner, address operator) external returns (bool);\r\n\r\n    function versionOf(address owner) external view returns (address);\r\n}\r\n\r\ninterface IDolomiteDirect {\r\n    function brokerMarginRequestApproval(address owner, address token, uint amount) external;\r\n}\r\n\r\n// ---------------------------------\r\n// Dydx Includes\r\n\r\nlibrary DydxTypes {\r\n    enum AssetDenomination {Wei, Par}\r\n    enum AssetReference {Delta, Target}\r\n\r\n    struct AssetAmount {\r\n        bool sign;\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n}\r\n\r\nlibrary DydxPosition {\r\n    struct Info {\r\n        address owner;\r\n        uint256 number;\r\n    }\r\n}\r\n\r\nlibrary DydxActions {\r\n    enum ActionType {Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call}\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        DydxTypes.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n}\r\n\r\ninterface IDyDxExchangeWrapper {\r\n    function exchange(\r\n        address tradeOriginator,\r\n        address receiver,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount,\r\n        bytes calldata orderData\r\n    ) external returns (uint256);\r\n\r\n    // Unused by our contract, does not need to be implemented\r\n    // function getExchangeCost(\r\n    //   address makerToken,\r\n    //   address takerToken,\r\n    //   uint256 desiredMakerToken,\r\n    //   bytes calldata orderData\r\n    // ) external view returns (uint256);\r\n}\r\n\r\ninterface IDyDxCallee {\r\n    function callFunction(address sender, DydxPosition.Info calldata accountInfo, bytes calldata data) external;\r\n}\r\n\r\ncontract IDyDxProtocol {\r\n    struct OperatorArg {\r\n        address operator;\r\n        bool trusted;\r\n    }\r\n\r\n    function operate(\r\n        DydxPosition.Info[] calldata accounts,\r\n        DydxActions.ActionArgs[] calldata actions\r\n    ) external;\r\n\r\n    function getNumMarkets() public view returns (uint256);\r\n\r\n    function getMarketTokenAddress(uint256 marketId) external view returns (address);\r\n\r\n    function getMarketPrice(uint256 marketId) external view returns (Monetary.Price memory);\r\n\r\n    function getAccountWei(DydxPosition.Info calldata account, uint256 marketId) external view returns (Types.Wei memory);\r\n}\r\n\r\n// ---------------------------------\r\n// Loopring Includes\r\n\r\nlibrary LoopringTypes {\r\n    struct BrokerApprovalRequest {\r\n        BrokerOrder[] orders;\r\n        address tokenS;\r\n        address tokenB;\r\n        address feeToken;\r\n        uint totalFillAmountB;\r\n        uint totalRequestedAmountS;\r\n        uint totalRequestedFeeAmount;\r\n    }\r\n\r\n    struct BrokerOrder {\r\n        address owner;\r\n        bytes32 orderHash;\r\n        uint fillAmountB;\r\n        uint requestedAmountS;\r\n        uint requestedFeeAmount;\r\n        address tokenRecipient;\r\n        bytes extraData;\r\n    }\r\n\r\n    struct BrokerInterceptorReport {\r\n        address owner;\r\n        address broker;\r\n        bytes32 orderHash;\r\n        address tokenB;\r\n        address tokenS;\r\n        address feeToken;\r\n        uint fillAmountB;\r\n        uint spentAmountS;\r\n        uint spentFeeAmount;\r\n        address tokenRecipient;\r\n        bytes extraData;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/LoopringTradeDelegateHelper.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.13;\r\n\r\n\r\n\r\nlibrary LoopringTradeDelegateHelper {\r\n\r\n    function transferTokenFrom(\r\n        ILoopringTradeDelegate self,\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bytes32[] memory transferData = new bytes32[](4);\r\n        transferData[0] = addressToBytes32(token);\r\n        transferData[1] = addressToBytes32(from);\r\n        transferData[2] = addressToBytes32(to);\r\n        transferData[3] = bytes32(amount);\r\n\r\n        self.batchTransfer(transferData);\r\n    }\r\n\r\n    function addressToBytes32(address addr) private pure returns (bytes32) {\r\n        return bytes32(uint256(addr));\r\n    }\r\n}\r\n\r\n// File: contracts/dolomite-margin-protocol/external/ExternalHelpers.sol\r\n\r\n/*\r\n * Copyright 2020 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\nlibrary Logger {\r\n    function revertAddress(address addr) internal pure {\r\n        revert(_addressToString(addr));\r\n    }\r\n\r\n    function revertUint(uint num) internal pure {\r\n        revert(_uintToString(num));\r\n    }\r\n\r\n    // -----------------------------\r\n\r\n    function _addressToString(address _addr) private pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(51);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2 + i * 2] = alphabet[uint(uint8(value[i + 12] >> 4))];\r\n            str[3 + i * 2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    function _uintToString(uint num) internal pure returns (string memory) {\r\n        if (num == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = num;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (num != 0) {\r\n            bstr[k--] = byte(uint8(48 + num % 10));\r\n            num /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n}\r\n\r\nlibrary DydxActionBuilder {\r\n\r\n    function Deposit(uint positionIndex, uint marketId, uint amount, address from)\r\n    internal\r\n    pure\r\n    returns (DydxActions.ActionArgs memory depositAction)\r\n    {\r\n        depositAction.actionType = DydxActions.ActionType.Deposit;\r\n        depositAction.accountId = positionIndex;\r\n        depositAction.primaryMarketId = marketId;\r\n        depositAction.otherAddress = from;\r\n        depositAction.amount = DydxTypes.AssetAmount({\r\n            sign : true,\r\n            denomination : DydxTypes.AssetDenomination.Wei,\r\n            ref : DydxTypes.AssetReference.Delta,\r\n            value : amount\r\n            });\r\n    }\r\n\r\n    // The only way to deposit a variable amount into dYdX during the execution of an \"operate\" call is\r\n    // to perform a \"sell\" action sending 0 wei and then the implementor of IExchangeWrapper returns the amount that\r\n    // will be deposited. The 1 wei is an unfortunate side effect, however it is a very negligible amount. If, in a\r\n    // future version of dYdX a DepositAll action is added, this would remove the need for this weird mechanic.\r\n    function DepositAll(uint positionIndex, uint marketId, uint burnMarketId, address controller, bytes32 orderHash)\r\n    internal\r\n    pure\r\n    returns (DydxActions.ActionArgs memory action)\r\n    {\r\n        action.actionType = DydxActions.ActionType.Sell;\r\n        action.accountId = positionIndex;\r\n        action.otherAddress = controller;\r\n        action.data = abi.encode(orderHash);\r\n        action.primaryMarketId = burnMarketId;\r\n        action.secondaryMarketId = marketId;\r\n        action.amount = DydxTypes.AssetAmount({\r\n            sign : false,\r\n            denomination : DydxTypes.AssetDenomination.Wei,\r\n            ref : DydxTypes.AssetReference.Delta,\r\n            value : 0\r\n            });\r\n    }\r\n\r\n    // ---------------------------------\r\n\r\n    function Withdraw(uint positionIndex, uint marketId, uint amount, address to)\r\n    internal\r\n    pure\r\n    returns (DydxActions.ActionArgs memory withdrawAction)\r\n    {\r\n        withdrawAction.actionType = DydxActions.ActionType.Withdraw;\r\n        withdrawAction.accountId = positionIndex;\r\n        withdrawAction.primaryMarketId = marketId;\r\n        withdrawAction.otherAddress = to;\r\n        withdrawAction.amount = DydxTypes.AssetAmount({\r\n            sign : false,\r\n            denomination : DydxTypes.AssetDenomination.Wei,\r\n            ref : DydxTypes.AssetReference.Delta,\r\n            value : amount\r\n            });\r\n    }\r\n\r\n    function WithdrawAll(uint positionIndex, uint marketId, address to)\r\n    internal\r\n    pure\r\n    returns (DydxActions.ActionArgs memory withdrawAction)\r\n    {\r\n        withdrawAction.actionType = DydxActions.ActionType.Withdraw;\r\n        withdrawAction.accountId = positionIndex;\r\n        withdrawAction.primaryMarketId = marketId;\r\n        withdrawAction.otherAddress = to;\r\n        withdrawAction.amount = DydxTypes.AssetAmount({\r\n            sign : true,\r\n            denomination : DydxTypes.AssetDenomination.Wei,\r\n            ref : DydxTypes.AssetReference.Target,\r\n            value : 0\r\n            });\r\n    }\r\n\r\n    // ---------------------------------\r\n\r\n    // function Liquidation() {\r\n\r\n    // }\r\n\r\n    // ---------------------------------\r\n\r\n    function SetExpiry(uint positionIndex, address expiry, uint marketId, uint expiryTime)\r\n    internal\r\n    pure\r\n    returns (DydxActions.ActionArgs memory)\r\n    {\r\n        return ExternalCall({\r\n            positionIndex : positionIndex,\r\n            callee : expiry,\r\n            data : abi.encode(marketId, expiryTime)\r\n            });\r\n    }\r\n\r\n    function LoopringSettlement(\r\n        bytes memory settlementData,\r\n        address settlementCaller,\r\n        uint positionIndex\r\n    )\r\n    internal\r\n    pure\r\n    returns (DydxActions.ActionArgs memory)\r\n    {\r\n        return ExternalCall({\r\n            positionIndex : positionIndex,\r\n            callee : settlementCaller,\r\n            data : settlementData\r\n            });\r\n    }\r\n\r\n    function ExternalCall(uint positionIndex, address callee, bytes memory data)\r\n    internal\r\n    pure\r\n    returns (DydxActions.ActionArgs memory callAction)\r\n    {\r\n        callAction.actionType = DydxActions.ActionType.Call;\r\n        callAction.accountId = positionIndex;\r\n        callAction.otherAddress = callee;\r\n        callAction.data = data;\r\n    }\r\n}\r\n\r\nlibrary LoopringOrderDecoder {\r\n\r\n    function decodeLoopringOrders(bytes memory ringData, uint[] memory indices) internal pure returns (Data.Order[] memory orders) {\r\n        uint numOrders = bytesToUint16(ringData, 2);\r\n        uint numRings = bytesToUint16(ringData, 4);\r\n        uint numSpendables = bytesToUint16(ringData, 6);\r\n\r\n        uint dataPtr;\r\n        assembly {dataPtr := ringData}\r\n        uint orderDataPtr = (dataPtr + 8) + 3 * 2;\r\n        uint ringDataPtr = orderDataPtr + (32 * numOrders) * 2;\r\n        uint dataBlobPtr = ringDataPtr + (numRings * 9) + 32;\r\n\r\n        // orders = new LoopringOrder[](indices.length);\r\n        orders = new Data.Order[](indices.length);\r\n\r\n        for (uint i = 0; i < indices.length; i++) {\r\n            orders[i] = _decodeLoopringOrderAtIndex(dataBlobPtr, orderDataPtr + 2, numSpendables, indices[i]);\r\n        }\r\n    }\r\n\r\n    // ----------------------------\r\n\r\n    function _decodeLoopringOrderAtIndex(uint data, uint tablesPtr, uint numSpendables, uint orderIndex) private pure returns (Data.Order memory order) {\r\n        tablesPtr += 64 * orderIndex;\r\n\r\n        uint offset;\r\n        bytes memory emptyBytes = new bytes(0);\r\n        address lrcTokenAddress = address(0);\r\n        Data.Spendable[] memory spendableList = new Data.Spendable[](numSpendables);\r\n        uint orderStructSize = 40 * 32;\r\n\r\n        assembly {\r\n            order := mload(0x40)\r\n            mstore(0x40, add(order, orderStructSize)) // Reserve memory for the order struct\r\n\r\n        // order.version\r\n            offset := and(mload(add(tablesPtr, 0)), 0xFFFF)\r\n            mstore(\r\n            add(order, 0),\r\n            offset\r\n            )\r\n\r\n        // order.owner\r\n            offset := mul(and(mload(add(tablesPtr, 2)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 32),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.tokenS\r\n            offset := mul(and(mload(add(tablesPtr, 4)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 64),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.tokenB\r\n            offset := mul(and(mload(add(tablesPtr, 6)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 96),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.amountS\r\n            offset := mul(and(mload(add(tablesPtr, 8)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 128),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // order.amountB\r\n            offset := mul(and(mload(add(tablesPtr, 10)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 160),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // order.validSince\r\n            offset := mul(and(mload(add(tablesPtr, 12)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 192),\r\n            and(mload(add(add(data, 4), offset)), 0xFFFFFFFF)\r\n            )\r\n\r\n        // order.tokenSpendableS\r\n            offset := and(mload(add(tablesPtr, 14)), 0xFFFF)\r\n        // Force the spendable index to 0 if it's invalid\r\n            offset := mul(offset, lt(offset, numSpendables))\r\n            mstore(\r\n            add(order, 224),\r\n            mload(add(spendableList, mul(add(offset, 1), 32)))\r\n            )\r\n\r\n        // order.tokenSpendableFee\r\n            offset := and(mload(add(tablesPtr, 16)), 0xFFFF)\r\n        // Force the spendable index to 0 if it's invalid\r\n            offset := mul(offset, lt(offset, numSpendables))\r\n            mstore(\r\n            add(order, 256),\r\n            mload(add(spendableList, mul(add(offset, 1), 32)))\r\n            )\r\n\r\n        // order.dualAuthAddr\r\n            offset := mul(and(mload(add(tablesPtr, 18)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 288),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.broker\r\n            offset := mul(and(mload(add(tablesPtr, 20)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 320),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.orderInterceptor\r\n            offset := mul(and(mload(add(tablesPtr, 22)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 416),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.wallet\r\n            offset := mul(and(mload(add(tablesPtr, 24)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 448),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.validUntil\r\n            offset := mul(and(mload(add(tablesPtr, 26)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 480),\r\n            and(mload(add(add(data, 4), offset)), 0xFFFFFFFF)\r\n            )\r\n\r\n        // Default to empty bytes array for value sig and dualAuthSig\r\n            mstore(add(data, 32), emptyBytes)\r\n\r\n        // order.sig\r\n            offset := mul(and(mload(add(tablesPtr, 28)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 512),\r\n            add(data, add(offset, 32))\r\n            )\r\n\r\n        // order.dualAuthSig\r\n            offset := mul(and(mload(add(tablesPtr, 30)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 544),\r\n            add(data, add(offset, 32))\r\n            )\r\n\r\n        // Restore default to 0\r\n            mstore(add(data, 32), 0)\r\n\r\n        // order.allOrNone\r\n            offset := and(mload(add(tablesPtr, 32)), 0xFFFF)\r\n            mstore(\r\n            add(order, 576),\r\n            gt(offset, 0)\r\n            )\r\n\r\n        // lrcTokenAddress is the default value for feeToken\r\n            mstore(add(data, 20), lrcTokenAddress)\r\n\r\n        // order.feeToken\r\n            offset := mul(and(mload(add(tablesPtr, 34)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 608),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // Restore default to 0\r\n            mstore(add(data, 20), 0)\r\n\r\n        // order.feeAmount\r\n            offset := mul(and(mload(add(tablesPtr, 36)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 640),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // order.waiveFeePercentage\r\n            offset := and(mload(add(tablesPtr, 38)), 0xFFFF)\r\n            mstore(\r\n            add(order, 672),\r\n            offset\r\n            )\r\n\r\n        // order.tokenSFeePercentage\r\n            offset := and(mload(add(tablesPtr, 40)), 0xFFFF)\r\n            mstore(\r\n            add(order, 704),\r\n            offset\r\n            )\r\n\r\n        // order.tokenBFeePercentage\r\n            offset := and(mload(add(tablesPtr, 42)), 0xFFFF)\r\n            mstore(\r\n            add(order, 736),\r\n            offset\r\n            )\r\n\r\n        // The owner is the default value of tokenRecipient\r\n        // order.owner\r\n            mstore(add(data, 20), mload(add(order, 32)))\r\n\r\n        // order.tokenRecipient\r\n            offset := mul(and(mload(add(tablesPtr, 44)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 768),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // Restore default to 0\r\n            mstore(add(data, 20), 0)\r\n\r\n        // order.walletSplitPercentage\r\n            offset := and(mload(add(tablesPtr, 46)), 0xFFFF)\r\n            mstore(\r\n            add(order, 800),\r\n            offset\r\n            )\r\n\r\n        // order.tokenTypeS\r\n            offset := and(mload(add(tablesPtr, 48)), 0xFFFF)\r\n            mstore(\r\n            add(order, 1024),\r\n            offset\r\n            )\r\n\r\n        // order.tokenTypeB\r\n            offset := and(mload(add(tablesPtr, 50)), 0xFFFF)\r\n            mstore(\r\n            add(order, 1056),\r\n            offset\r\n            )\r\n\r\n        // order.tokenTypeFee\r\n            offset := and(mload(add(tablesPtr, 52)), 0xFFFF)\r\n            mstore(\r\n            add(order, 1088),\r\n            offset\r\n            )\r\n\r\n        // order.trancheS\r\n            offset := mul(and(mload(add(tablesPtr, 54)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 1120),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // order.trancheB\r\n            offset := mul(and(mload(add(tablesPtr, 56)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 1152),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // Restore default to 0\r\n            mstore(add(data, 20), 0)\r\n\r\n        // order.maxPrimaryFillAmount\r\n            offset := mul(and(mload(add(tablesPtr, 58)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 1184),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // order.allOrNone\r\n            offset := and(mload(add(tablesPtr, 60)), 0xFFFF)\r\n            mstore(\r\n            add(order, 1216),\r\n            gt(offset, 0)\r\n            )\r\n\r\n        // Default to empty bytes array for transferDataS\r\n            mstore(add(data, 32), emptyBytes)\r\n\r\n        // order.transferDataS\r\n            offset := mul(and(mload(add(tablesPtr, 62)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 1248),\r\n            add(data, add(offset, 32))\r\n            )\r\n\r\n        // Restore default to 0\r\n            mstore(add(data, 32), 0)\r\n\r\n        // Set default  values\r\n            mstore(add(order, 832), 0)         // order.P2P\r\n            mstore(add(order, 864), 0)         // order.hash\r\n            mstore(add(order, 896), 0)         // order.brokerInterceptor\r\n            mstore(add(order, 928), 0)         // order.filledAmountS\r\n            mstore(add(order, 960), 0)         // order.initialFilledAmountS\r\n            mstore(add(order, 992), 1)         // order.valid\r\n\r\n        }\r\n    }\r\n\r\n    function bytesToUintX(bytes memory b, uint offset, uint numBytes) private pure returns (uint data) {\r\n        require(b.length >= offset + numBytes, \"INVALID_SIZE\");\r\n        assembly {data := mload(add(add(b, numBytes), offset))}\r\n    }\r\n\r\n    function bytesToUint16(bytes memory b, uint offset) private pure returns (uint16) {\r\n        return uint16(bytesToUintX(b, offset, 2) & 0xFFFF);\r\n    }\r\n}\r\n\r\n// File: contracts/dolomite-margin-protocol/helpers/DolomiteMarginReentrancyGuard.sol\r\n\r\n/*\r\n * Copyright 2020 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract DolomiteMarginReentrancyGuard {\r\n\r\n    uint256 private _guardCounter;\r\n\r\n    // Functions with this modifier can not be re-entered\r\n    // (sets counter to odd number when executing, even when finished)\r\n    modifier singleEntry {\r\n        _guardCounter += 1;\r\n        uint current = _guardCounter;\r\n        _;\r\n        require(current == _guardCounter, \"NO_ENTRY: Cannot re-enter contract\");\r\n        _guardCounter += 1;\r\n    }\r\n\r\n    // Functions with this modifier can only be called after entering a singleEntry function\r\n    modifier noEntry {\r\n        require(_guardCounter % 2 == 1, \"NO_ENTRY: Cannot enter a noEntry function\");\r\n        // counter must be odd number\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/loopring/lib/ERC20.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title ERC20 Token Interface\r\n/// @dev see https://github.com/ethereum/EIPs/issues/20\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract ERC20 {\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address who\r\n        )\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n        )\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 value\r\n        )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/loopring/lib/MathUint.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint {\r\n\r\n    function mul(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"INVALID_VALUE_MULTIPLY\");\r\n    }\r\n\r\n    function sub(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        require(b <= a, \"INVALID_VALUE_SUB\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"INVALID_VALUE_ADD\");\r\n    }\r\n\r\n    function hasRoundingError(\r\n        uint value,\r\n        uint numerator,\r\n        uint denominator\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint multiplied = mul(value, numerator);\r\n        uint remainder = multiplied % denominator;\r\n        // Return true if the rounding error is larger than 1%\r\n        return mul(remainder, 100) > multiplied;\r\n    }\r\n}\r\n\r\n// File: contracts/loopring/lib/BytesUtil.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title Utility Functions for bytes\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary BytesUtil {\r\n    function bytesToBytes32(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return bytes32(bytesToUintX(b, offset, 32));\r\n    }\r\n\r\n    function bytesToUint(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        return bytesToUintX(b, offset, 32);\r\n    }\r\n\r\n    function bytesToAddress(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        return address(bytesToUintX(b, offset, 20) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    }\r\n\r\n    function bytesToUint16(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint16)\r\n    {\r\n        return uint16(bytesToUintX(b, offset, 2) & 0xFFFF);\r\n    }\r\n\r\n    function bytesToUintX(\r\n        bytes memory b,\r\n        uint offset,\r\n        uint numBytes\r\n        )\r\n        private\r\n        pure\r\n        returns (uint data)\r\n    {\r\n        require(b.length >= offset + numBytes, \"INVALID_SIZE\");\r\n        assembly {\r\n            data := mload(add(add(b, numBytes), offset))\r\n        }\r\n    }\r\n\r\n    function subBytes(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes memory data)\r\n    {\r\n        require(b.length >= offset + 32, \"INVALID_SIZE\");\r\n        assembly {\r\n            data := add(add(b, 32), offset)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/loopring/lib/MultihashUtil.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n/// @title Utility Functions for Multihash signature verificaiton\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// For more information:\r\n///   - https://github.com/saurfang/ipfs-multihash-on-solidity\r\n///   - https://github.com/multiformats/multihash\r\n///   - https://github.com/multiformats/js-multihash\r\nlibrary MultihashUtil {\r\n\r\n    enum HashAlgorithm { Ethereum, EIP712 }\r\n\r\n    string public constant SIG_PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n    function verifySignature(\r\n        address signer,\r\n        bytes32 plaintext,\r\n        bytes memory multihash\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint length = multihash.length;\r\n        require(length >= 2, \"invalid multihash format\");\r\n        uint8 algorithm;\r\n        uint8 size;\r\n        assembly {\r\n            algorithm := mload(add(multihash, 1))\r\n            size := mload(add(multihash, 2))\r\n        }\r\n        require(length == (2 + size), \"bad multihash size\");\r\n\r\n        if (algorithm == uint8(HashAlgorithm.Ethereum)) {\r\n            require(signer != address(0x0), \"invalid signer address\");\r\n            require(size == 65, \"bad Ethereum multihash size\");\r\n            bytes32 hash;\r\n            uint8 v;\r\n            bytes32 r;\r\n            bytes32 s;\r\n            assembly {\r\n                let data := mload(0x40)\r\n                mstore(data, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // SIG_PREFIX\r\n                mstore(add(data, 28), plaintext)                                                 // plaintext\r\n                hash := keccak256(data, 60)                                                      // 28 + 32\r\n                // Extract v, r and s from the multihash data\r\n                v := mload(add(multihash, 3))\r\n                r := mload(add(multihash, 35))\r\n                s := mload(add(multihash, 67))\r\n            }\r\n            return signer == ecrecover(\r\n                hash,\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n        } else if (algorithm == uint8(HashAlgorithm.EIP712)) {\r\n            require(signer != address(0x0), \"invalid signer address\");\r\n            require(size == 65, \"bad EIP712 multihash size\");\r\n            uint8 v;\r\n            bytes32 r;\r\n            bytes32 s;\r\n            assembly {\r\n                // Extract v, r and s from the multihash data\r\n                v := mload(add(multihash, 3))\r\n                r := mload(add(multihash, 35))\r\n                s := mload(add(multihash, 67))\r\n            }\r\n            return signer == ecrecover(\r\n                plaintext,\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/loopring/iface/IBrokerDelegate.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\ninterface IBrokerDelegate {\r\n\r\n  /*\r\n   * Loopring requests an allowance be set on a given token for a specified amount. Order details\r\n   * are provided (tokenS, totalAmountS, tokenB, totalAmountB, orderTokenRecipient, extraOrderData)\r\n   * to aid in any calculations or on-chain exchange of assets that may be required. The last 4\r\n   * parameters concern the actual token approval being requested of the broker.\r\n   *\r\n   * @returns Whether or not onOrderFillReport should be called for orders using this broker\r\n   */\r\n  function brokerRequestAllowance(BrokerData.BrokerApprovalRequest calldata request) external returns (bool);\r\n\r\n  /*\r\n   * After Loopring performs all of the transfers necessary to complete all the submitted\r\n   * rings it will call this function for every order's brokerInterceptor (if set) passing\r\n   * along the final fill counts for tokenB, tokenS and feeToken. This allows actions to be\r\n   * performed on a per-order basis after all tokenS/feeToken funds have left the order owner's\r\n   * possession and the tokenB funds have been transferred to the order owner's intended recipient\r\n   */\r\n  function onOrderFillReport(BrokerData.BrokerInterceptorReport calldata fillReport) external;\r\n\r\n  /*\r\n   * Get the available token balance controlled by the broker on behalf of an address (owner)\r\n   */\r\n  function brokerBalanceOf(address owner, address token) external view returns (uint);\r\n}\r\n\r\n// File: contracts/loopring/helper/OrderHelper.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title OrderHelper\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\nlibrary OrderHelper {\r\n    using MathUint      for uint;\r\n\r\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\r\n    string constant internal EIP712_DOMAIN_NAME = \"Loopring Protocol\";\r\n    string constant internal EIP712_DOMAIN_VERSION = \"2\";\r\n    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(\r\n        abi.encodePacked(\r\n            \"EIP712Domain(\",\r\n            \"string name,\",\r\n            \"string version\",\r\n            \")\"\r\n        )\r\n    );\r\n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(\r\n        abi.encodePacked(\r\n            \"Order(\",\r\n            \"uint amountS,\",\r\n            \"uint amountB,\",\r\n            \"uint feeAmount,\",\r\n            \"uint validSince,\",\r\n            \"uint validUntil,\",\r\n            \"address owner,\",\r\n            \"address tokenS,\",\r\n            \"address tokenB,\",\r\n            \"address dualAuthAddr,\",\r\n            \"address broker,\",\r\n            \"address orderInterceptor,\",\r\n            \"address wallet,\",\r\n            \"address tokenRecipient,\",\r\n            \"address feeToken,\",\r\n            \"uint16 walletSplitPercentage,\",\r\n            \"uint16 tokenSFeePercentage,\",\r\n            \"uint16 tokenBFeePercentage,\",\r\n            \"bool allOrNone,\",\r\n            \"uint8 tokenTypeS,\",\r\n            \"uint8 tokenTypeB,\",\r\n            \"uint8 tokenTypeFee,\",\r\n            \"bytes32 trancheS,\",\r\n            \"bytes32 trancheB,\",\r\n            \"bytes transferDataS\",\r\n            \")\"\r\n        )\r\n    );\r\n    bytes32 constant internal EIP712_DOMAIN_HASH = keccak256(\r\n        abi.encodePacked(\r\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\r\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\r\n            keccak256(bytes(EIP712_DOMAIN_VERSION))\r\n        )\r\n    );\r\n\r\n    function updateHash(Data.Order memory order)\r\n        internal\r\n        pure\r\n    {\r\n        // Pre-calculated EIP712_ORDER_SCHEMA_HASH amd EIP712_DOMAIN_HASH because\r\n        // the solidity compiler doesn't correctly pre-calculate them for us.\r\n        bytes32 _EIP712_ORDER_SCHEMA_HASH = 0x40b942178d2a51f1f61934268590778feb8114db632db7d88537c98d2b05c5f2;\r\n        bytes32 _EIP712_DOMAIN_HASH = 0xaea25658c273c666156bd427f83a666135fcde6887a6c25fc1cd1562bc4f3f34;\r\n\r\n//         bytes32 message = keccak256(\r\n//             abi.encode(\r\n//                 EIP712_ORDER_SCHEMA_HASH,\r\n//                 order.amountS,\r\n//                 order.amountB,\r\n//                 order.feeAmount,\r\n//                 order.validSince,\r\n//                 order.validUntil,\r\n//                 order.owner,\r\n//                 order.tokenS,\r\n//                 order.tokenB,\r\n//                 order.dualAuthAddr,\r\n//                 order.broker,\r\n//                 order.orderInterceptor,\r\n//                 order.wallet,\r\n//                 order.tokenRecipient,\r\n//                 order.feeToken,\r\n//                 order.walletSplitPercentage,\r\n//                 order.tokenSFeePercentage,\r\n//                 order.tokenBFeePercentage,\r\n//                 order.allOrNone,\r\n//                 order.tokenTypeS,\r\n//                 order.tokenTypeB,\r\n//                 order.tokenTypeFee,\r\n//                 order.trancheS,\r\n//                 order.trancheB,\r\n//                 order.transferDataS\r\n//             )\r\n//         );\r\n//         order.hash = keccak256(\r\n//            abi.encodePacked(\r\n//                EIP191_HEADER,\r\n//                EIP712_DOMAIN_HASH,\r\n//                message\r\n//            )\r\n//        );\r\n\r\n        bytes32 hash;\r\n        assembly {\r\n            // Calculate the hash for transferDataS separately\r\n            let transferDataS := mload(add(order, 1248))         // order.transferDataS\r\n            let transferDataSHash := keccak256(add(transferDataS, 32), mload(transferDataS))\r\n\r\n            let ptr := mload(64)\r\n            mstore(add(ptr,   0), _EIP712_ORDER_SCHEMA_HASH)     // EIP712_ORDER_SCHEMA_HASH\r\n            mstore(add(ptr,  32), mload(add(order, 128)))        // order.amountS\r\n            mstore(add(ptr,  64), mload(add(order, 160)))        // order.amountB\r\n            mstore(add(ptr,  96), mload(add(order, 640)))        // order.feeAmount\r\n            mstore(add(ptr, 128), mload(add(order, 192)))        // order.validSince\r\n            mstore(add(ptr, 160), mload(add(order, 480)))        // order.validUntil\r\n            mstore(add(ptr, 192), mload(add(order,  32)))        // order.owner\r\n            mstore(add(ptr, 224), mload(add(order,  64)))        // order.tokenS\r\n            mstore(add(ptr, 256), mload(add(order,  96)))        // order.tokenB\r\n            mstore(add(ptr, 288), mload(add(order, 288)))        // order.dualAuthAddr\r\n            mstore(add(ptr, 320), mload(add(order, 320)))        // order.broker\r\n            mstore(add(ptr, 352), mload(add(order, 416)))        // order.orderInterceptor\r\n            mstore(add(ptr, 384), mload(add(order, 448)))        // order.wallet\r\n            mstore(add(ptr, 416), mload(add(order, 768)))        // order.tokenRecipient\r\n            mstore(add(ptr, 448), mload(add(order, 608)))        // order.feeToken\r\n            mstore(add(ptr, 480), mload(add(order, 800)))        // order.walletSplitPercentage\r\n            mstore(add(ptr, 512), mload(add(order, 704)))        // order.tokenSFeePercentage\r\n            mstore(add(ptr, 544), mload(add(order, 736)))        // order.tokenBFeePercentage\r\n            mstore(add(ptr, 576), mload(add(order, 576)))        // order.allOrNone\r\n            mstore(add(ptr, 608), mload(add(order, 1024)))       // order.tokenTypeS\r\n            mstore(add(ptr, 640), mload(add(order, 1056)))       // order.tokenTypeB\r\n            mstore(add(ptr, 672), mload(add(order, 1088)))       // order.tokenTypeFee\r\n            mstore(add(ptr, 704), mload(add(order, 1120)))       // order.trancheS\r\n            mstore(add(ptr, 736), mload(add(order, 1152)))       // order.trancheB\r\n            mstore(add(ptr, 768), transferDataSHash)             // keccak256(order.transferDataS)\r\n            let message := keccak256(ptr, 800)                   // 25 * 32\r\n\r\n            mstore(add(ptr,  0), 0x1901)                         // EIP191_HEADER\r\n            mstore(add(ptr, 32), _EIP712_DOMAIN_HASH)            // EIP712_DOMAIN_HASH\r\n            mstore(add(ptr, 64), message)                        // message\r\n            hash := keccak256(add(ptr, 30), 66)                  // 2 + 32 + 32\r\n        }\r\n\r\n        order.hash = hash;\r\n    }\r\n\r\n    function check(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        // If the order was already partially filled\r\n        // we don't have to check all of the infos and the signature again\r\n        if(order.filledAmountS == 0) {\r\n            validateAllInfo(order, ctx);\r\n            checkOwnerSignature(order, ctx);\r\n        } else {\r\n            validateUnstableInfo(order, ctx);\r\n        }\r\n\r\n        order.P2P = (order.tokenSFeePercentage > 0 || order.tokenBFeePercentage > 0);\r\n    }\r\n\r\n    function validateAllInfo(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        bool valid = true;\r\n        valid = valid && (order.version == 0); // unsupported order version\r\n        valid = valid && (order.owner != address(0x0)); // invalid order owner\r\n        valid = valid && (order.tokenS != address(0x0)); // invalid order tokenS\r\n        valid = valid && (order.tokenB != address(0x0)); // invalid order tokenB\r\n        valid = valid && (order.amountS != 0); // invalid order amountS\r\n        valid = valid && (order.amountB != 0); // invalid order amountB\r\n        valid = valid && (order.feeToken != address(0x0)); // invalid fee token\r\n\r\n        valid = valid && (order.tokenSFeePercentage < ctx.feePercentageBase); // invalid tokenS percentage\r\n        valid = valid && (order.tokenBFeePercentage < ctx.feePercentageBase); // invalid tokenB percentage\r\n        valid = valid && (order.walletSplitPercentage <= 100); // invalid wallet split percentage\r\n\r\n        // We only support ERC20 for now\r\n        valid = valid && (order.tokenTypeS == Data.TokenType.ERC20 && order.trancheS == 0x0);\r\n        valid = valid && (order.tokenTypeFee == Data.TokenType.ERC20);\r\n\r\n        // NOTICE: replaced to allow orders to specify market's primary token (to denote order side)\r\n        // valid = valid && (order.tokenTypeB == Data.TokenType.ERC20 && order.trancheB == 0x0);\r\n        valid = valid && (order.tokenTypeB == Data.TokenType.ERC20) && (\r\n            bytes32ToAddress(order.trancheB) == order.tokenB ||\r\n            bytes32ToAddress(order.trancheB) == order.tokenS\r\n        );\r\n\r\n        // NOTICE: commented to allow order.transferDataS to be used for dApps building on Loopring\r\n        // valid = valid && (order.transferDataS.length == 0);\r\n\r\n        valid = valid && (order.validSince <= (now + 300)); // order is too early to match\r\n\r\n        valid = valid && (!order.allOrNone); // We don't support allOrNone\r\n\r\n        require(valid, \"INVALID_STABLE_DATA\");\r\n\r\n        order.valid = order.valid && valid;\r\n\r\n        validateUnstableInfo(order, ctx);\r\n    }\r\n\r\n\r\n    function validateUnstableInfo(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        bool valid = true;\r\n        valid = valid && (order.validUntil == 0 || order.validUntil > now - 300);  // order is expired\r\n        valid = valid && (order.waiveFeePercentage <= int16(ctx.feePercentageBase)); // invalid waive percentage\r\n        valid = valid && (order.waiveFeePercentage >= -int16(ctx.feePercentageBase)); // invalid waive percentage\r\n        if (order.dualAuthAddr != address(0x0)) {\r\n            // if dualAuthAddr exists, dualAuthSig must be exist.\r\n            require(order.dualAuthSig.length > 0, \"MISSING_DUAL_AUTH_SIGNATURE\");\r\n        }\r\n        require(valid, \"INVALID_UNSTABLE_DATA\");\r\n        order.valid = order.valid && valid;\r\n    }\r\n\r\n\r\n    function isBuy(Data.Order memory order) internal pure returns (bool) {\r\n        return bytes32ToAddress(order.trancheB) == order.tokenB;\r\n    }\r\n\r\n    function checkOwnerSignature(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        if (order.sig.length == 0) {\r\n            bool registered = ctx.orderRegistry.isOrderHashRegistered(\r\n                order.owner,\r\n                order.hash\r\n            );\r\n\r\n            if (!registered) {\r\n                order.valid = order.valid && ctx.orderBook.orderSubmitted(order.hash);\r\n            }\r\n        } else {\r\n            require(order.valid, \"INVALID_ORDER_DATA\");\r\n            order.valid = order.valid && MultihashUtil.verifySignature(\r\n                order.owner,\r\n                order.hash,\r\n                order.sig\r\n            );\r\n            require(order.valid, \"INVALID_SIGNATURE\");\r\n        }\r\n    }\r\n\r\n    function checkDualAuthSignature(\r\n        Data.Order memory order,\r\n        bytes32 miningHash\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        if (order.dualAuthSig.length != 0) {\r\n            order.valid = order.valid && MultihashUtil.verifySignature(\r\n                order.dualAuthAddr,\r\n                miningHash,\r\n                order.dualAuthSig\r\n            );\r\n            require(order.valid, 'INVALID_DUAL_AUTH_SIGNATURE');\r\n        }\r\n    }\r\n\r\n    function getBrokerHash(Data.Order memory order) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(order.broker, order.tokenS, order.tokenB, order.feeToken));\r\n    }\r\n\r\n    function getSpendableS(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        return getSpendable(\r\n            order,\r\n            ctx.delegate,\r\n            order.tokenS,\r\n            order.owner,\r\n            order.tokenSpendableS\r\n        );\r\n    }\r\n\r\n    function getSpendableFee(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        return getSpendable(\r\n            order,\r\n            ctx.delegate,\r\n            order.feeToken,\r\n            order.owner,\r\n            order.tokenSpendableFee\r\n        );\r\n    }\r\n\r\n    function reserveAmountS(\r\n        Data.Order memory order,\r\n        uint amount\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        order.tokenSpendableS.reserved += amount;\r\n    }\r\n\r\n    function reserveAmountFee(\r\n        Data.Order memory order,\r\n        uint amount\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        order.tokenSpendableFee.reserved += amount;\r\n    }\r\n\r\n    function resetReservations(\r\n        Data.Order memory order\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        order.tokenSpendableS.reserved = 0;\r\n        order.tokenSpendableFee.reserved = 0;\r\n    }\r\n\r\n    /// @return Amount of ERC20 token that can be spent by this contract.\r\n    function getERC20Spendable(\r\n        Data.Order memory order,\r\n        ILoopringTradeDelegate delegate,\r\n        address tokenAddress,\r\n        address owner\r\n        )\r\n        private\r\n        view\r\n        returns (uint spendable)\r\n    {\r\n        if (order.broker == address(0x0)) {\r\n            ERC20 token = ERC20(tokenAddress);\r\n            spendable = token.allowance(\r\n                owner,\r\n                address(delegate)\r\n            );\r\n            if (spendable != 0) {\r\n                uint balance = token.balanceOf(owner);\r\n                spendable = (balance < spendable) ? balance : spendable;\r\n            }\r\n        } else {\r\n            IBrokerDelegate broker = IBrokerDelegate(order.broker);\r\n            spendable = broker.brokerBalanceOf(owner, tokenAddress);\r\n        }\r\n    }\r\n\r\n    function getSpendable(\r\n        Data.Order memory order,\r\n        ILoopringTradeDelegate delegate,\r\n        address tokenAddress,\r\n        address owner,\r\n        Data.Spendable memory tokenSpendable\r\n        )\r\n        private\r\n        view\r\n        returns (uint spendable)\r\n    {\r\n        if (!tokenSpendable.initialized) {\r\n            tokenSpendable.amount = getERC20Spendable(\r\n                order,\r\n                delegate,\r\n                tokenAddress,\r\n                owner\r\n            );\r\n            tokenSpendable.initialized = true;\r\n        }\r\n        spendable = tokenSpendable.amount.sub(tokenSpendable.reserved);\r\n    }\r\n\r\n    function bytes32ToAddress(bytes32 data) private pure returns (address) {\r\n        return address(uint160(uint256(data)));\r\n    }\r\n}\r\n\r\n// File: contracts/dolomite-margin-protocol/lib/Order.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n//import \"./Runtime.sol\";\r\n\r\nlibrary Order {\r\n\r\n    using OrderHelper for Data.Order;\r\n\r\n    struct Info {\r\n        address signer;\r\n        address tokenS;\r\n        address tokenB;\r\n        bytes32 orderHash;\r\n        bytes extraData;\r\n    }\r\n\r\n    struct TradeInfo {\r\n        bool isUsingDepositContract;\r\n        uint positionId;\r\n        uint expirationDays;\r\n        uint depositMarketId;\r\n        uint depositAmount;\r\n        ////////\r\n        address trader;\r\n        address signer;\r\n    }\r\n\r\n    function tradeInfo(Order.Info memory order, RunTime.Context memory ctx) internal view returns (Order.TradeInfo memory info) {\r\n    (\r\n        info.isUsingDepositContract,\r\n        info.positionId,\r\n        info.expirationDays,\r\n        info.depositMarketId,\r\n        info.depositAmount\r\n    ) = abi.decode(order.extraData, (bool, uint, uint, uint, uint));\r\n\r\n        info.trader = info.isUsingDepositContract\r\n        ? ctx.depositContractRegistry.depositAddressOf(order.signer)\r\n        : order.signer;\r\n\r\n        info.signer = order.signer;\r\n\r\n        return info;\r\n    }\r\n\r\n    function decodeRawOrders(bytes memory ringData, uint[] memory relevantOrderIndices)\r\n    internal\r\n    pure\r\n    returns (Order.Info[] memory orders)\r\n    {\r\n        orders = new Order.Info[](relevantOrderIndices.length);\r\n        Data.Order[] memory rawOrders = LoopringOrderDecoder.decodeLoopringOrders(ringData, relevantOrderIndices);\r\n\r\n        bytes memory emptyBytes = new bytes(0);\r\n        for (uint i = 0; i < orders.length; i++) {\r\n            rawOrders[i].updateHash();\r\n            orders[i] = Order.Info({\r\n                signer : rawOrders[i].owner,\r\n                tokenS : rawOrders[i].tokenS,\r\n                tokenB : rawOrders[i].tokenB,\r\n                orderHash : rawOrders[i].hash,\r\n                extraData : rawOrders[i].transferDataS\r\n                });\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/loopring/impl/ExchangeDeserializer.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n/// @title Deserializes the data passed to submitRings\r\n/// @author Daniel Wang - <daniel@loopring.org>,\r\nlibrary ExchangeDeserializer {\r\n    using BytesUtil     for bytes;\r\n\r\n    function deserializeRingIndices(\r\n        Data.Order[] memory orders,\r\n        Data.RingIndices[] memory ringIndices\r\n    ) internal\r\n        view returns (\r\n            Data.Ring[] memory rings\r\n        ) {\r\n        rings = new Data.Ring[](ringIndices.length);\r\n        for (uint i = 0; i < ringIndices.length; i++) {\r\n            rings[i].size = 2;\r\n            rings[i].participations = new Data.Participation[](2);\r\n\r\n            rings[i].participations[0] = Data.Participation({\r\n                order: orders[ringIndices[i].index0],\r\n                splitS: uint(0),\r\n                feeAmount: uint(0),\r\n                feeAmountS: uint(0),\r\n                feeAmountB: uint(0),\r\n                rebateFee: uint(0),\r\n                rebateS: uint(0),\r\n                rebateB: uint(0),\r\n                fillAmountS: uint(0),\r\n                fillAmountB: uint(0)\r\n            });\r\n\r\n            rings[i].participations[1] = Data.Participation({\r\n                order: orders[ringIndices[i].index1],\r\n                splitS: uint(0),\r\n                feeAmount: uint(0),\r\n                feeAmountS: uint(0),\r\n                feeAmountB: uint(0),\r\n                rebateFee: uint(0),\r\n                rebateS: uint(0),\r\n                rebateB: uint(0),\r\n                fillAmountS: uint(0),\r\n                fillAmountB: uint(0)\r\n            });\r\n\r\n            rings[i].hash = bytes32(0);\r\n            rings[i].minerFeesToOrdersPercentage = uint(0);\r\n            rings[i].valid = true;\r\n        }\r\n    }\r\n\r\n    function deserialize(\r\n        address lrcTokenAddress,\r\n        bytes memory data\r\n        )\r\n        internal\r\n        view\r\n        returns (\r\n            Data.Mining memory mining,\r\n            Data.Order[] memory orders,\r\n            Data.Ring[] memory rings\r\n        )\r\n    {\r\n        // Read the header\r\n        Data.Header memory header;\r\n        header.version = data.bytesToUint16(0);\r\n        header.numOrders = data.bytesToUint16(2);\r\n        header.numRings = data.bytesToUint16(4);\r\n        header.numSpendables = data.bytesToUint16(6);\r\n\r\n        // Validation\r\n        require(header.version == 0, \"Unsupported serialization format\");\r\n        require(header.numOrders > 0, \"Invalid number of orders\");\r\n        require(header.numRings > 0, \"Invalid number of rings\");\r\n        require(header.numSpendables > 0, \"Invalid number of spendables\");\r\n\r\n        // Calculate data pointers\r\n        uint dataPtr;\r\n        assembly {\r\n            dataPtr := data\r\n        }\r\n        uint miningDataPtr = dataPtr + 8;\r\n        uint orderDataPtr = miningDataPtr + 3 * 2;\r\n        uint ringDataPtr = orderDataPtr + (32 * header.numOrders) * 2;\r\n        uint dataBlobPtr = ringDataPtr + (header.numRings * 9) + 32;\r\n\r\n        // The data stream needs to be at least large enough for the\r\n        // header/mining/orders/rings data + 64 bytes of zeros in the data blob.\r\n        require(data.length >= (dataBlobPtr - dataPtr) + 32, \"Invalid input data\");\r\n\r\n        // Setup the rings\r\n        mining = setupMiningData(dataBlobPtr, miningDataPtr + 2);\r\n        orders = setupOrders(dataBlobPtr, orderDataPtr + 2, header.numOrders, header.numSpendables, lrcTokenAddress);\r\n        rings = assembleRings(ringDataPtr + 1, header.numRings, orders);\r\n    }\r\n\r\n    function setupMiningData(\r\n        uint data,\r\n        uint tablesPtr\r\n        )\r\n        internal\r\n        view\r\n        returns (Data.Mining memory mining)\r\n    {\r\n        bytes memory emptyBytes = new bytes(0);\r\n        uint offset;\r\n\r\n        assembly {\r\n            // Default to transaction origin for feeRecipient\r\n            mstore(add(data, 20), origin)\r\n\r\n            // mining.feeRecipient\r\n            offset := mul(and(mload(add(tablesPtr,  0)), 0xFFFF), 4)\r\n            mstore(\r\n                add(mining,   0),\r\n                mload(add(add(data, 20), offset))\r\n            )\r\n\r\n            // Restore default to 0\r\n            mstore(add(data, 20), 0)\r\n\r\n            // mining.miner\r\n            offset := mul(and(mload(add(tablesPtr,  2)), 0xFFFF), 4)\r\n            mstore(\r\n                add(mining,  32),\r\n                mload(add(add(data, 20), offset))\r\n            )\r\n\r\n            // Default to empty bytes array\r\n            mstore(add(data, 32), emptyBytes)\r\n\r\n            // mining.sig\r\n            offset := mul(and(mload(add(tablesPtr,  4)), 0xFFFF), 4)\r\n            mstore(\r\n                add(mining, 64),\r\n                add(data, add(offset, 32))\r\n            )\r\n\r\n            // Restore default to 0\r\n            mstore(add(data, 32), 0)\r\n        }\r\n    }\r\n\r\n    function setupOrders(\r\n        uint data,\r\n        uint tablesPtr,\r\n        uint numOrders,\r\n        uint numSpendables,\r\n        address lrcTokenAddress\r\n        )\r\n        internal\r\n        pure\r\n        returns (Data.Order[] memory orders)\r\n    {\r\n        bytes memory emptyBytes = new bytes(0);\r\n        uint orderStructSize = 40 * 32;\r\n        // Memory for orders length + numOrders order pointers\r\n        uint arrayDataSize = (1 + numOrders) * 32;\r\n        Data.Spendable[] memory spendableList = new Data.Spendable[](numSpendables);\r\n        uint offset;\r\n\r\n        assembly {\r\n            // Allocate memory for all orders\r\n            orders := mload(0x40)\r\n            mstore(add(orders, 0), numOrders)                       // orders.length\r\n            // Reserve the memory for the orders array\r\n            mstore(0x40, add(orders, add(arrayDataSize, mul(orderStructSize, numOrders))))\r\n\r\n            for { let i := 0 } lt(i, numOrders) { i := add(i, 1) } {\r\n                let order := add(orders, add(arrayDataSize, mul(orderStructSize, i)))\r\n\r\n                // Store the memory location of this order in the orders array\r\n                mstore(add(orders, mul(add(1, i), 32)), order)\r\n\r\n                // order.version\r\n                offset := and(mload(add(tablesPtr,  0)), 0xFFFF)\r\n                mstore(\r\n                    add(order,   0),\r\n                    offset\r\n                )\r\n\r\n                // order.owner\r\n                offset := mul(and(mload(add(tablesPtr,  2)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order,  32),\r\n                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                )\r\n\r\n                // order.tokenS\r\n                offset := mul(and(mload(add(tablesPtr,  4)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order,  64),\r\n                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                )\r\n\r\n                // order.tokenB\r\n                offset := mul(and(mload(add(tablesPtr,  6)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order,  96),\r\n                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                )\r\n\r\n                // order.amountS\r\n                offset := mul(and(mload(add(tablesPtr,  8)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 128),\r\n                    mload(add(add(data, 32), offset))\r\n                )\r\n\r\n                // order.amountB\r\n                offset := mul(and(mload(add(tablesPtr, 10)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 160),\r\n                    mload(add(add(data, 32), offset))\r\n                )\r\n\r\n                // order.validSince\r\n                offset := mul(and(mload(add(tablesPtr, 12)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 192),\r\n                    and(mload(add(add(data, 4), offset)), 0xFFFFFFFF)\r\n                )\r\n\r\n                // order.tokenSpendableS\r\n                offset := and(mload(add(tablesPtr, 14)), 0xFFFF)\r\n                // Force the spendable index to 0 if it's invalid\r\n                offset := mul(offset, lt(offset, numSpendables))\r\n                mstore(\r\n                    add(order, 224),\r\n                    mload(add(spendableList, mul(add(offset, 1), 32)))\r\n                )\r\n\r\n                // order.tokenSpendableFee\r\n                offset := and(mload(add(tablesPtr, 16)), 0xFFFF)\r\n                // Force the spendable index to 0 if it's invalid\r\n                offset := mul(offset, lt(offset, numSpendables))\r\n                mstore(\r\n                    add(order, 256),\r\n                    mload(add(spendableList, mul(add(offset, 1), 32)))\r\n                )\r\n\r\n                // order.dualAuthAddr\r\n                offset := mul(and(mload(add(tablesPtr, 18)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 288),\r\n                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                )\r\n\r\n                // order.broker\r\n                offset := mul(and(mload(add(tablesPtr, 20)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 320),\r\n                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                )\r\n\r\n                // order.orderInterceptor\r\n                offset := mul(and(mload(add(tablesPtr, 22)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 416),\r\n                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                )\r\n\r\n                // order.wallet\r\n                offset := mul(and(mload(add(tablesPtr, 24)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 448),\r\n                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                )\r\n\r\n                // order.validUntil\r\n                offset := mul(and(mload(add(tablesPtr, 26)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 480),\r\n                    and(mload(add(add(data,  4), offset)), 0xFFFFFFFF)\r\n                )\r\n\r\n                // Default to empty bytes array for value sig and dualAuthSig\r\n                mstore(add(data, 32), emptyBytes)\r\n\r\n                // order.sig\r\n                offset := mul(and(mload(add(tablesPtr, 28)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 512),\r\n                    add(data, add(offset, 32))\r\n                )\r\n\r\n                // order.dualAuthSig\r\n                offset := mul(and(mload(add(tablesPtr, 30)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 544),\r\n                    add(data, add(offset, 32))\r\n                )\r\n\r\n                // Restore default to 0\r\n                mstore(add(data, 32), 0)\r\n\r\n                // order.allOrNone\r\n                offset := and(mload(add(tablesPtr, 32)), 0xFFFF)\r\n                mstore(\r\n                    add(order, 576),\r\n                    gt(offset, 0)\r\n                )\r\n\r\n                // lrcTokenAddress is the default value for feeToken\r\n                mstore(add(data, 20), lrcTokenAddress)\r\n\r\n                // order.feeToken\r\n                offset := mul(and(mload(add(tablesPtr, 34)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 608),\r\n                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                )\r\n\r\n                // Restore default to 0\r\n                mstore(add(data, 20), 0)\r\n\r\n                // order.feeAmount\r\n                offset := mul(and(mload(add(tablesPtr, 36)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 640),\r\n                    mload(add(add(data, 32), offset))\r\n                )\r\n\r\n                // order.waiveFeePercentage\r\n                offset := and(mload(add(tablesPtr, 38)), 0xFFFF)\r\n                mstore(\r\n                    add(order, 672),\r\n                    offset\r\n                )\r\n\r\n                // order.tokenSFeePercentage\r\n                offset := and(mload(add(tablesPtr, 40)), 0xFFFF)\r\n                mstore(\r\n                    add(order, 704),\r\n                    offset\r\n                )\r\n\r\n                // order.tokenBFeePercentage\r\n                offset := and(mload(add(tablesPtr, 42)), 0xFFFF)\r\n                mstore(\r\n                    add(order, 736),\r\n                    offset\r\n                )\r\n\r\n                // The owner is the default value of tokenRecipient\r\n                mstore(add(data, 20), mload(add(order, 32)))                // order.owner\r\n\r\n                // order.tokenRecipient\r\n                offset := mul(and(mload(add(tablesPtr, 44)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 768),\r\n                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                )\r\n\r\n                // Restore default to 0\r\n                mstore(add(data, 20), 0)\r\n\r\n                // order.walletSplitPercentage\r\n                offset := and(mload(add(tablesPtr, 46)), 0xFFFF)\r\n                mstore(\r\n                    add(order, 800),\r\n                    offset\r\n                )\r\n\r\n                // order.tokenTypeS\r\n                offset := and(mload(add(tablesPtr, 48)), 0xFFFF)\r\n                mstore(\r\n                    add(order, 1024),\r\n                    offset\r\n                )\r\n\r\n                // order.tokenTypeB\r\n                offset := and(mload(add(tablesPtr, 50)), 0xFFFF)\r\n                mstore(\r\n                    add(order, 1056),\r\n                    offset\r\n                )\r\n\r\n                // order.tokenTypeFee\r\n                offset := and(mload(add(tablesPtr, 52)), 0xFFFF)\r\n                mstore(\r\n                    add(order, 1088),\r\n                    offset\r\n                )\r\n\r\n                // order.trancheS\r\n                offset := mul(and(mload(add(tablesPtr, 54)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 1120),\r\n                    mload(add(add(data, 32), offset))\r\n                )\r\n\r\n                // order.trancheB\r\n                offset := mul(and(mload(add(tablesPtr, 56)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 1152),\r\n                    mload(add(add(data, 32), offset))\r\n                )\r\n\r\n                // Restore default to 0\r\n                mstore(add(data, 20), 0)\r\n\r\n                // order.maxPrimaryFillAmount\r\n                offset := mul(and(mload(add(tablesPtr, 58)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 1184),\r\n                    mload(add(add(data, 32), offset))\r\n                )\r\n\r\n                // order.allOrNone\r\n                offset := and(mload(add(tablesPtr, 60)), 0xFFFF)\r\n                mstore(\r\n                    add(order, 1216),\r\n                    gt(offset, 0)\r\n                )\r\n\r\n                // Default to empty bytes array for transferDataS\r\n                mstore(add(data, 32), emptyBytes)\r\n\r\n                // order.transferDataS\r\n                offset := mul(and(mload(add(tablesPtr, 62)), 0xFFFF), 4)\r\n                mstore(\r\n                    add(order, 1248),\r\n                    add(data, add(offset, 32))\r\n                )\r\n\r\n                // Restore default to 0\r\n                mstore(add(data, 32), 0)\r\n\r\n                // Set default  values\r\n                mstore(add(order, 832), 0)         // order.P2P\r\n                mstore(add(order, 864), 0)         // order.hash\r\n                mstore(add(order, 896), 0)         // order.brokerInterceptor\r\n                mstore(add(order, 928), 0)         // order.filledAmountS\r\n                mstore(add(order, 960), 0)         // order.initialFilledAmountS\r\n                mstore(add(order, 992), 1)         // order.valid\r\n\r\n                // Advance to the next order\r\n                tablesPtr := add(tablesPtr, 64)\r\n            }\r\n        }\r\n    }\r\n\r\n    function assembleRings(\r\n        uint data,\r\n        uint numRings,\r\n        Data.Order[] memory orders\r\n        )\r\n        internal\r\n        pure\r\n        returns (Data.Ring[] memory rings)\r\n    {\r\n        uint ringsArrayDataSize = (1 + numRings) * 32;\r\n        uint ringStructSize = 5 * 32;\r\n        uint participationStructSize = 10 * 32;\r\n\r\n        assembly {\r\n            // Allocate memory for all rings\r\n            rings := mload(0x40)\r\n            mstore(add(rings, 0), numRings)                      // rings.length\r\n            // Reserve the memory for the rings array\r\n            mstore(0x40, add(rings, add(ringsArrayDataSize, mul(ringStructSize, numRings))))\r\n\r\n            for { let r := 0 } lt(r, numRings) { r := add(r, 1) } {\r\n                let ring := add(rings, add(ringsArrayDataSize, mul(ringStructSize, r)))\r\n\r\n                // Store the memory location of this ring in the rings array\r\n                mstore(add(rings, mul(add(r, 1), 32)), ring)\r\n\r\n                // Get the ring size\r\n                let ringSize := and(mload(data), 0xFF)\r\n                data := add(data, 1)\r\n\r\n                // require(ringsSize <= 8)\r\n                if gt(ringSize, 8) {\r\n                    revert(0, 0)\r\n                }\r\n\r\n                // Allocate memory for all participations\r\n                let participations := mload(0x40)\r\n                mstore(add(participations, 0), ringSize)         // participations.length\r\n                // Memory for participations length + ringSize participation pointers\r\n                let participationsData := add(participations, mul(add(1, ringSize), 32))\r\n                // Reserve the memory for the participations\r\n                mstore(0x40, add(participationsData, mul(participationStructSize, ringSize)))\r\n\r\n                // Initialize ring properties\r\n                mstore(add(ring,   0), ringSize)                 // ring.size\r\n                mstore(add(ring,  32), participations)           // ring.participations\r\n                mstore(add(ring,  64), 0)                        // ring.hash\r\n                mstore(add(ring,  96), 0)                        // ring.minerFeesToOrdersPercentage\r\n                mstore(add(ring, 128), 1)                        // ring.valid\r\n\r\n                for { let i := 0 } lt(i, ringSize) { i := add(i, 1) } {\r\n                    let participation := add(participationsData, mul(participationStructSize, i))\r\n\r\n                    // Store the memory location of this participation in the participations array\r\n                    mstore(add(participations, mul(add(i, 1), 32)), participation)\r\n\r\n                    // Get the order index\r\n                    let orderIndex := and(mload(data), 0xFF)\r\n                    // require(orderIndex < orders.length)\r\n                    if iszero(lt(orderIndex, mload(orders))) {\r\n                        revert(0, 0)\r\n                    }\r\n                    data := add(data, 1)\r\n\r\n                    // participation.order\r\n                    mstore(\r\n                        add(participation,   0),\r\n                        mload(add(orders, mul(add(orderIndex, 1), 32)))\r\n                    )\r\n\r\n                    // Set default values\r\n                    mstore(add(participation,  32), 0)          // participation.splitS\r\n                    mstore(add(participation,  64), 0)          // participation.feeAmount\r\n                    mstore(add(participation,  96), 0)          // participation.feeAmountS\r\n                    mstore(add(participation, 128), 0)          // participation.feeAmountB\r\n                    mstore(add(participation, 160), 0)          // participation.rebateFee\r\n                    mstore(add(participation, 192), 0)          // participation.rebateS\r\n                    mstore(add(participation, 224), 0)          // participation.rebateB\r\n                    mstore(add(participation, 256), 0)          // participation.fillAmountS\r\n                    mstore(add(participation, 288), 0)          // participation.fillAmountB\r\n                }\r\n\r\n                // Advance to the next ring\r\n                data := add(data, sub(8, ringSize))\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/dolomite-margin-protocol/lib/Runtime.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary RunTime {\r\n    struct OutgoingAllowanceTrigger {\r\n        address signer;\r\n        uint marketId;\r\n        uint amount;\r\n    }\r\n\r\n    struct TokenTransfer {\r\n        address from;\r\n        address to;\r\n        address token;\r\n        uint amount;\r\n        bool isUsingDepositContract;\r\n    }\r\n\r\n    struct Context {\r\n        address self;\r\n        IDepositContractRegistry depositContractRegistry;\r\n        address dydxExpiryContractAddress;\r\n        Order.Info[] orders;\r\n        address[] marketTokenAddress;\r\n        ////////\r\n        bytes32[] depositFlagTriggers;\r\n        TokenTransfer[] tokenTransfers;\r\n        OutgoingAllowanceTrigger[] setOutgoingAllowanceTriggers;\r\n        DydxPosition.Info[] dydxPositions;\r\n        DydxActions.ActionArgs[] dydxBeforeActions;\r\n        DydxActions.ActionArgs[] dydxAfterActions;\r\n        uint numDepositFlagTriggers;\r\n        uint numTokenTransfers;\r\n        uint numSetOutgoingAllowanceTriggers;\r\n        uint numDydxPositions;\r\n        uint numDydxBeforeActions;\r\n        uint numDydxAfterActions;\r\n    }\r\n\r\n    // ---------------------------------\r\n\r\n    function setDepositFlag(Context memory ctx, bytes32 orderHash) internal pure {\r\n        ctx.depositFlagTriggers[ctx.numDepositFlagTriggers] = orderHash;\r\n        ctx.numDepositFlagTriggers += 1;\r\n    }\r\n\r\n    function requireTokenTransfer(\r\n        Context memory ctx,\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint amount,\r\n        bool isUsingDepositContract\r\n    ) internal pure {\r\n        for (uint i = 0; i < ctx.numTokenTransfers; i++) {\r\n            TokenTransfer memory transfer = ctx.tokenTransfers[i];\r\n            if (transfer.from == from && transfer.to == to && transfer.token == token) {\r\n                transfer.amount += amount;\r\n                return;\r\n            }\r\n        }\r\n\r\n        ctx.tokenTransfers[ctx.numTokenTransfers] = TokenTransfer(from, to, token, amount, isUsingDepositContract);\r\n        ctx.numTokenTransfers += 1;\r\n    }\r\n\r\n    function registerPosition(\r\n        Context memory ctx,\r\n        address trader,\r\n        uint positionId\r\n    ) internal pure returns (uint) {\r\n        for (uint i = 0; i < ctx.numDydxPositions; i++) {\r\n            if (ctx.dydxPositions[i].owner == trader && ctx.dydxPositions[i].number == positionId) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        ctx.dydxPositions[ctx.numDydxPositions] = DydxPosition.Info(trader, positionId);\r\n        ctx.numDydxPositions += 1;\r\n        return ctx.numDydxPositions - 1;\r\n    }\r\n\r\n    function addBeforeAction(Context memory ctx, DydxActions.ActionArgs memory action) internal pure {\r\n        ctx.dydxBeforeActions[ctx.numDydxBeforeActions] = action;\r\n        ctx.numDydxBeforeActions += 1;\r\n    }\r\n\r\n    function addAfterAction(Context memory ctx, DydxActions.ActionArgs memory action) internal pure {\r\n        ctx.dydxAfterActions[ctx.numDydxAfterActions] = action;\r\n        ctx.numDydxAfterActions += 1;\r\n    }\r\n}\r\n\r\n// File: contracts/dolomite-margin-protocol/lib/Activity.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\nlibrary Activity {\r\n    using RunTime for RunTime.Context;\r\n    using Order for Order.Info;\r\n    using Activity for *;\r\n\r\n    struct ActivityArg {\r\n        Activity.Type activityType;\r\n        bytes encodedFields;\r\n    }\r\n\r\n    enum Type {Trade, Loan, Liquidation}\r\n    enum TradeMovementType {None, DepositAll, WithdrawAll}\r\n\r\n    struct Trade {\r\n        uint orderIndex;\r\n        uint marketIdS;\r\n        uint marketIdB;\r\n        uint fillAmountS;\r\n        TradeMovementType movementType;\r\n    }\r\n\r\n    struct Loan {\r\n        // TODO\r\n        uint orderIndex;\r\n    }\r\n\r\n    struct Liquidation {\r\n        uint orderIndex;\r\n        uint marketIdS;\r\n        uint marketIdB;\r\n        uint fillAmountB;\r\n        address profitReceiver;\r\n        address liquidOwner;\r\n        uint liquidPositionId;\r\n    }\r\n\r\n    function depositBalanceHash() internal pure returns (bytes32) {\r\n        return bytes32(0x1234567812345678123456781234567812345678123456781234567812345678);\r\n    }\r\n\r\n    function registerActivity(RunTime.Context memory ctx, Activity.Type activityType, bytes memory encodedFields) internal view {\r\n        if (activityType == Type.Trade) encodedFields._decodeTradeActivity()._generateTradeActions(ctx);\r\n        else if (activityType == Type.Loan) encodedFields._decodeLoanActivity()._generateLoanActions(ctx);\r\n        else if (activityType == Type.Liquidation) encodedFields._decodeLiquidationActivity()._generateLiquidationActions(ctx);\r\n    }\r\n\r\n    // ---------------------------------\r\n\r\n    function _decodeTradeActivity(bytes memory encoded) internal pure returns (Activity.Trade memory trade) {\r\n        return abi.decode(encoded, (Activity.Trade));\r\n    }\r\n\r\n    function _decodeLoanActivity(bytes memory encoded) internal pure returns (Activity.Loan memory loan) {\r\n        revert(\"NOT_IMPLEMENTED: Activity.Type.Loan is not yet supported\");\r\n    }\r\n\r\n    function _decodeLiquidationActivity(bytes memory encoded) internal pure returns (Activity.Liquidation memory liquidation) {\r\n        return abi.decode(encoded, (Activity.Liquidation));\r\n    }\r\n\r\n    // ---------------------------------\r\n\r\n    function _generateTradeActions(Activity.Trade memory trade, RunTime.Context memory ctx) internal view {\r\n        Order.Info memory order = ctx.orders[trade.orderIndex];\r\n        Order.TradeInfo memory tradeInfo = order.tradeInfo(ctx);\r\n\r\n        uint positionIndex = ctx.registerPosition(tradeInfo.trader, tradeInfo.positionId);\r\n\r\n        // Requirements for deposit of trader's collateral\r\n        if (trade.movementType == Activity.TradeMovementType.DepositAll) {\r\n            address depositToken = ctx.marketTokenAddress[tradeInfo.depositMarketId];\r\n            ctx.requireTokenTransfer(tradeInfo.signer, ctx.self, depositToken, tradeInfo.depositAmount, tradeInfo.isUsingDepositContract);\r\n            ctx.addBeforeAction(DydxActionBuilder.Deposit(positionIndex, tradeInfo.depositMarketId, tradeInfo.depositAmount, ctx.self));\r\n            ctx.setDepositFlag(order.orderHash);\r\n        }\r\n\r\n        // Actions for borrowing tokens to exchange and depositing what was received\r\n        ctx.addBeforeAction(DydxActionBuilder.Withdraw(positionIndex, trade.marketIdS, trade.fillAmountS, ctx.self));\r\n        ctx.addAfterAction(DydxActionBuilder.DepositAll({\r\n            positionIndex : positionIndex,\r\n            marketId : trade.marketIdB,\r\n            burnMarketId : trade.marketIdS,\r\n            controller : ctx.self,\r\n            orderHash : order.orderHash\r\n            }));\r\n\r\n        // Actions to withdraw the position's balances to the trader\r\n        if (trade.movementType == Activity.TradeMovementType.WithdrawAll) {\r\n            ctx.addAfterAction(DydxActionBuilder.WithdrawAll(positionIndex, trade.marketIdS, tradeInfo.trader));\r\n            ctx.addAfterAction(DydxActionBuilder.WithdrawAll(positionIndex, trade.marketIdB, tradeInfo.trader));\r\n        }\r\n\r\n        // Action for setting the expiration timestamp of the position\r\n        if (trade.movementType == Activity.TradeMovementType.DepositAll && tradeInfo.expirationDays > 0) {\r\n            uint expirationTime = block.timestamp + (tradeInfo.expirationDays * 60 * 60 * 24);\r\n            ctx.addAfterAction(DydxActionBuilder.SetExpiry(positionIndex, ctx.dydxExpiryContractAddress, trade.marketIdS, expirationTime));\r\n        }\r\n    }\r\n\r\n    function _generateLoanActions(Activity.Loan memory trade, RunTime.Context memory ctx) internal pure {/* TODO */}\r\n\r\n    function _generateLiquidationActions(Activity.Liquidation memory liquidation, RunTime.Context memory ctx) internal view {\r\n        // For liquidations, `primaryMarketId` is the owed market. `secondaryMarketId` is the market whose positive\r\n        // balance will be earned (plus the 5% spread). We buy into `marketIdB` using the collateral earned from\r\n        // `marketIdS`. In doing so, we will take on the debt owed by the liquid account and then sell off any positive\r\n        // balance (which is in secondaryMarketId) into the owed market (primaryMarketId), to clear out any debt.\r\n        // Whatever is left from this process is profit for the liquidator.\r\n        Order.Info memory order = ctx.orders[liquidation.orderIndex];\r\n\r\n        uint solidPositionTradeIndex = ctx.registerPosition(order.signer, 0);\r\n        uint solidPositionProfitIndex = ctx.registerPosition(liquidation.profitReceiver, 0);\r\n        uint liquidPositionIndex = ctx.registerPosition(liquidation.liquidOwner, liquidation.liquidPositionId);\r\n\r\n        DydxActions.ActionArgs memory liquidateAction;\r\n        liquidateAction.actionType = DydxActions.ActionType.Liquidate;\r\n        liquidateAction.accountId = solidPositionTradeIndex;\r\n        liquidateAction.otherAccountId = liquidPositionIndex;\r\n        liquidateAction.primaryMarketId = liquidation.marketIdB;\r\n        liquidateAction.secondaryMarketId = liquidation.marketIdS;\r\n        if (liquidation.fillAmountB == uint(- 1)) {\r\n            liquidateAction.amount = DydxTypes.AssetAmount({\r\n                sign : true,\r\n                denomination : DydxTypes.AssetDenomination.Wei,\r\n                ref : DydxTypes.AssetReference.Target,\r\n                value : 0\r\n                });\r\n        } else {\r\n            liquidateAction.amount = DydxTypes.AssetAmount({\r\n                sign : true,\r\n                denomination : DydxTypes.AssetDenomination.Wei,\r\n                ref : DydxTypes.AssetReference.Delta,\r\n                value : liquidation.fillAmountB\r\n                });\r\n        }\r\n        ctx.addBeforeAction(liquidateAction);\r\n\r\n        // Sell off the full positive balance (`marketIdS`) that was received from the liquidation.\r\n        ctx.addBeforeAction(DydxActionBuilder.WithdrawAll(solidPositionTradeIndex, liquidation.marketIdS, ctx.self));\r\n\r\n        // Deposit all received tokens from the sell (of marketIdS into marketIdB) into the account. This should\r\n        // make our negative balance positive. The new positive balance is now profit for the solid account.\r\n        ctx.addAfterAction(DydxActionBuilder.DepositAll({\r\n            positionIndex : solidPositionTradeIndex,\r\n            marketId : liquidation.marketIdB,\r\n            burnMarketId : liquidation.marketIdS,\r\n            controller : ctx.self,\r\n            orderHash : order.orderHash\r\n            }));\r\n\r\n        // Move the funds from trade index to the profit-taking one. This way, we only move positive balances into this\r\n        // account.\r\n        DydxActions.ActionArgs memory transferAction;\r\n        transferAction.actionType = DydxActions.ActionType.Transfer;\r\n        transferAction.accountId = solidPositionTradeIndex;\r\n        transferAction.otherAccountId = solidPositionProfitIndex;\r\n        transferAction.primaryMarketId = liquidation.marketIdB;\r\n        transferAction.amount = DydxTypes.AssetAmount({\r\n            sign : true,\r\n            denomination : DydxTypes.AssetDenomination.Wei,\r\n            ref : DydxTypes.AssetReference.Target,\r\n            value : 0\r\n            });\r\n        ctx.addAfterAction(transferAction);\r\n    }\r\n}\r\n\r\n// File: contracts/loopring/iface/IRingSubmitter.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title IRingSubmitter\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>\r\ncontract IRingSubmitter {\r\n    uint16  public constant FEE_PERCENTAGE_BASE = 1000;\r\n\r\n    /// @dev  Event emitted when a ring was successfully mined\r\n    ///        _ringIndex     The index of the ring\r\n    ///        _ringHash      The hash of the ring\r\n    ///        _feeRecipient  The recipient of the matching fee\r\n    ///        _fills         The info of the orders in the ring stored like:\r\n    ///                       [orderHash, owner, tokenS, amountS, split, feeAmount, feeAmountS, feeAmountB]\r\n    event RingMined(\r\n        uint            _ringIndex,\r\n        bytes32 indexed _ringHash,\r\n        address indexed _feeRecipient,\r\n        bytes           _fills\r\n    );\r\n\r\n    /// @dev   Event emitted when a ring was not successfully mined\r\n    ///         _ringHash  The hash of the ring\r\n    event InvalidRing(\r\n        bytes32 _ringHash\r\n    );\r\n\r\n    /// @dev   Event emitted when fee rebates are distributed (waiveFeePercentage < 0)\r\n    ///         _ringHash   The hash of the ring whose order(s) will receive the rebate\r\n    ///         _orderHash  The hash of the order that will receive the rebate\r\n    ///         _feeToken   The address of the token that will be paid to the _orderHash's owner\r\n    ///         _feeAmount  The amount to be paid to the owner\r\n    event DistributeFeeRebate(\r\n        bytes32 indexed _ringHash,\r\n        bytes32 indexed _orderHash,\r\n        address         _feeToken,\r\n        uint            _feeAmount\r\n    );\r\n\r\n//    /// @dev   Submit order-rings for validation and settlement.\r\n//    /// @param data ABI encoded struct containing ring data.\r\n//    function submitRings(\r\n//        Data.SubmitRingsRequest calldata data\r\n//    ) external;\r\n\r\n    /// @dev   Submit order-rings for validation and settlement.\r\n    /// @param data Packed data of all rings.\r\n    function submitRings(\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function delegateAddress() external returns (address);\r\n}\r\n\r\n// File: contracts/dolomite-margin-protocol/DolomiteMarginProtocol.sol\r\n\r\n/*\r\n * Copyright 2020 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.13;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * @title DolomiteMarginV2\r\n *\r\n * Allows Loopring v2.3 orders to trade on margin, loan funds with 0 collateral to perform \r\n * arbitrage and liquidate under-collateralized positions through the dYdX protocol.\r\n *\r\n * Users sign orders with the broker set to this contract, so orders must be submitted\r\n * through this contract, ensuring that margin orders can only be settled as margin orders.\r\n * Users also sign other information in the extraData (transferDataS) field of the order \r\n * which is used by this contract. The information provided by the relay is checked\r\n * against this information signed by the user, and is also verified by Loopring v2.3 and dYdX.\r\n */\r\ncontract DolomiteMarginProtocol is IDyDxCallee, IBrokerDelegate, IDyDxExchangeWrapper, DolomiteMarginReentrancyGuard, Ownable {\r\n    using Order for *;\r\n    using Activity for *;\r\n    using LoopringTradeDelegateHelper for ILoopringTradeDelegate;\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for *;\r\n\r\n    //        bytes32 public constant DEPOSIT_COLLATERAL_TYPE_HASH = keccak256(\"DepositCollateral(address signer,uint256 positionId,uint256 tokenId,uint256 amount,uint256 feeAmount,address feeRecipient,uint256 expiry,uint256 nonce)\");\r\n    bytes32 public constant DEPOSIT_COLLATERAL_TYPE_HASH = 0x3e5ecf67633bf55e5afafd4ed3ca3ce81df8fe6e1767e986edc5e247c0019d27;\r\n\r\n    //        bytes32 public constant WITHDRAW_COLLATERAL_TYPE_HASH = keccak256(\"WithdrawCollateral(address signer,uint256 positionId,uint256 tokenId,uint256 amount,uint256 feeAmount,address feeRecipient,uint256 expiry,uint256 nonce)\");\r\n    bytes32 public constant WITHDRAW_COLLATERAL_TYPE_HASH = 0xf4f01e4a789a88db3d7581d902fca290c3d0ef9a0974ee9c5f6ac11c86056e7e;\r\n\r\n    bytes32 public domainSeparator;\r\n\r\n    struct RelayParams {\r\n        uint[] relevantOrderIndices;\r\n        uint[] relevantMarketIds;\r\n        Activity.ActivityArg[] activityArgs;\r\n        address dustCollector;\r\n    }\r\n\r\n    address public DYDX_EXPIRY_ADDRESS;\r\n    IDyDxProtocol public DYDX_PROTOCOL;\r\n    IRingSubmitter public LOOPRING_PROTOCOL;\r\n    IDepositContractRegistry public DEPOSIT_CONTRACT_REGISTRY;\r\n    ILoopringTradeDelegate public TRADE_DELEGATE;\r\n\r\n    constructor(\r\n        address dydxProtocol,\r\n        address payable loopringProtocol,\r\n        address dydxExpiry,\r\n        address depositContractRegistry\r\n    ) public {\r\n        DYDX_PROTOCOL = IDyDxProtocol(dydxProtocol);\r\n        LOOPRING_PROTOCOL = IRingSubmitter(loopringProtocol);\r\n        TRADE_DELEGATE = ILoopringTradeDelegate(LOOPRING_PROTOCOL.delegateAddress());\r\n        DEPOSIT_CONTRACT_REGISTRY = IDepositContractRegistry(depositContractRegistry);\r\n        DYDX_EXPIRY_ADDRESS = dydxExpiry;\r\n\r\n        uint256 chainId;\r\n        assembly {chainId := chainid()}\r\n\r\n        domainSeparator = keccak256(abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                keccak256(bytes(\"Dolomite Margin\")),\r\n                keccak256(bytes(/* version */ \"1\")),\r\n                chainId,\r\n                address(this)\r\n            ));\r\n    }\r\n\r\n    // =================================\r\n\r\n    mapping(bytes32 => bool) private _orderHasDeposited;\r\n    mapping(bytes32 => mapping(address => uint)) private _runtimeIncomingAmount;\r\n    mapping(address => uint) private _nonces;\r\n\r\n    function nonceOf(address user) public view returns (uint) {\r\n        return _nonces[user];\r\n    }\r\n\r\n    function withdrawDust(address token) public onlyOwner {\r\n        IERC20(token).safeTransfer(owner(), IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function depositCollateral(uint positionId, uint tokenId, uint amount) public singleEntry {\r\n        TRADE_DELEGATE.transferTokenFrom(\r\n            DYDX_PROTOCOL.getMarketTokenAddress(tokenId),\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n\r\n        DydxPosition.Info[] memory infos = new DydxPosition.Info[](1);\r\n        infos[0] = DydxPosition.Info(msg.sender, positionId);\r\n\r\n        DydxActions.ActionArgs[] memory args = new DydxActions.ActionArgs[](1);\r\n        args[0] = DydxActionBuilder.Deposit(0, tokenId, amount, /* from */ address(this));\r\n\r\n        DYDX_PROTOCOL.operate(infos, args);\r\n    }\r\n\r\n    function withdrawCollateral(uint positionId, uint tokenId, uint amount) public singleEntry {\r\n        DydxPosition.Info[] memory infos = new DydxPosition.Info[](1);\r\n        infos[0] = DydxPosition.Info(msg.sender, positionId);\r\n\r\n        DydxActions.ActionArgs[] memory args = new DydxActions.ActionArgs[](1);\r\n        if (amount == uint(- 1)) {\r\n            args[0] = DydxActionBuilder.WithdrawAll(0, tokenId, msg.sender);\r\n        } else {\r\n            args[0] = DydxActionBuilder.Withdraw(0, tokenId, amount, msg.sender);\r\n        }\r\n\r\n        DYDX_PROTOCOL.operate(infos, args);\r\n    }\r\n\r\n    function depositCollateralViaGaslessRequest(\r\n        address signer,\r\n        uint positionId,\r\n        uint tokenId,\r\n        uint amount,\r\n        uint feeAmount,\r\n        address feeRecipient,\r\n        uint expiry,\r\n        uint nonce,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public singleEntry {\r\n        require(amount >= feeAmount, \"FEE_TOO_LARGE\");\r\n        validateGaslessRequest(\r\n            DEPOSIT_COLLATERAL_TYPE_HASH,\r\n            signer,\r\n            positionId,\r\n            tokenId,\r\n            amount,\r\n            feeAmount,\r\n            feeRecipient,\r\n            expiry,\r\n            nonce,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        // These functions were created to help avoid the infamous \"stack too deep\" error.\r\n        performDolomiteDirectDepositTransferIn(signer, tokenId, amount);\r\n        payFeesForDolomiteDirectDepositIfNecessary(feeAmount, feeRecipient, tokenId);\r\n        performDolomiteDirectDeposit(signer, positionId, tokenId, amount.sub(feeAmount));\r\n    }\r\n\r\n    function withdrawCollateralViaGaslessRequest(\r\n        address signer,\r\n        uint positionId,\r\n        uint tokenId,\r\n        uint amount,\r\n        uint feeAmount,\r\n        address feeRecipient,\r\n        uint expiry,\r\n        uint nonce,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public singleEntry {\r\n        require(amount >= feeAmount, \"FEE_TOO_LARGE\");\r\n        validateGaslessRequest(\r\n            WITHDRAW_COLLATERAL_TYPE_HASH,\r\n            signer,\r\n            positionId,\r\n            tokenId,\r\n            amount,\r\n            feeAmount,\r\n            feeRecipient,\r\n            expiry,\r\n            nonce,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        // This is function was created to help avoid the infamous \"stack too deep\" error.\r\n        performDolomiteDirectWithdraw(signer, positionId, tokenId, amount);\r\n        payFeesForDolomiteDirectWithdrawalIfNecessary(signer, feeAmount, feeRecipient, tokenId);\r\n    }\r\n\r\n    /*\r\n     * If orders in a Loopring settlement require interaction(s) with dYdX in order to\r\n     * trade on margin, loan money to perform arbitrage or perform liquidations, they can\r\n     * be submitted here. The orders that need dYdX are registered along with other relevant\r\n     * information in the RelayParams parameter by the relay.\r\n     */\r\n    function submitRingsThroughDyDx(\r\n        bytes memory ringData,\r\n        RelayParams memory params\r\n    ) public singleEntry {\r\n        Order.Info[] memory orders = ringData.decodeRawOrders(params.relevantOrderIndices);\r\n        submitRingsThroughDyDx(ringData, params, orders, /* isTypeSafe */ false);\r\n    }\r\n\r\n    /*\r\n     * If orders in a Loopring settlement require interaction(s) with dYdX in order to\r\n     * trade on margin, loan money to perform arbitrage or perform liquidations, they can\r\n     * be submitted here. The orders that need dYdX are registered along with other relevant\r\n     * information in the RelayParams parameter by the relay.\r\n     */\r\n    function submitRingsThroughDyDx(\r\n        bytes memory ringData,\r\n        RelayParams memory params,\r\n        Order.Info[] memory orders,\r\n        bool isTypeSafe\r\n    ) internal {\r\n        RunTime.Context memory ctx = _createRuntimeContext(orders, params);\r\n        _registerActivities(ctx, params.activityArgs);\r\n        _resolveDepositFlagTriggers(ctx);\r\n        _performTokenTransfers(ctx);\r\n\r\n        (\r\n        DydxPosition.Info[] memory positions,\r\n        DydxActions.ActionArgs[] memory actions\r\n        ) = _generateDydxPerformParams(ctx, ringData, isTypeSafe);\r\n\r\n        DYDX_PROTOCOL.operate(positions, actions);\r\n\r\n        _clearRuntime(ctx);\r\n    }\r\n\r\n    function _createRuntimeContext(Order.Info[] memory orders, RelayParams memory params)\r\n    internal\r\n    view\r\n    returns (RunTime.Context memory ctx)\r\n    {\r\n        uint numActivities = params.activityArgs.length;\r\n\r\n        uint totalNumMarkets = DYDX_PROTOCOL.getNumMarkets();\r\n        ctx.marketTokenAddress = new address[](totalNumMarkets);\r\n        for (uint i = 0; i < params.relevantMarketIds.length; i++) {\r\n            ctx.marketTokenAddress[params.relevantMarketIds[i]] = DYDX_PROTOCOL.getMarketTokenAddress(params.relevantMarketIds[i]);\r\n        }\r\n\r\n        ctx.self = address(this);\r\n        ctx.orders = orders;\r\n        ctx.depositContractRegistry = DEPOSIT_CONTRACT_REGISTRY;\r\n        ctx.dydxExpiryContractAddress = DYDX_EXPIRY_ADDRESS;\r\n        ctx.depositFlagTriggers = new bytes32[](numActivities);\r\n        ctx.tokenTransfers = new RunTime.TokenTransfer[](numActivities);\r\n        ctx.dydxPositions = new DydxPosition.Info[](numActivities * 3);\r\n        ctx.dydxBeforeActions = new DydxActions.ActionArgs[](numActivities * 3);\r\n        ctx.dydxAfterActions = new DydxActions.ActionArgs[](numActivities * 3);\r\n\r\n        return ctx;\r\n    }\r\n\r\n    function _registerActivities(RunTime.Context memory ctx, Activity.ActivityArg[] memory activityArgs) internal view {\r\n        for (uint i = 0; i < activityArgs.length; i++) {\r\n            Activity.ActivityArg memory arg = activityArgs[i];\r\n            ctx.registerActivity(arg.activityType, arg.encodedFields);\r\n        }\r\n    }\r\n\r\n    function _resolveDepositFlagTriggers(RunTime.Context memory ctx) internal {\r\n        for (uint i = 0; i < ctx.numDepositFlagTriggers; i++) {\r\n            bytes32 orderHash = ctx.depositFlagTriggers[i];\r\n            require(_orderHasDeposited[orderHash] == false, \"ORDER_DEPOSIT_REJECTED: deposit already performed\");\r\n            _orderHasDeposited[orderHash] = true;\r\n        }\r\n    }\r\n\r\n    function _performTokenTransfers(RunTime.Context memory ctx) internal {\r\n        for (uint i = 0; i < ctx.numTokenTransfers; i++) {\r\n            RunTime.TokenTransfer memory transfer = ctx.tokenTransfers[i];\r\n            if (transfer.isUsingDepositContract) {\r\n                IDolomiteDirect dolomiteDirect = IDolomiteDirect(DEPOSIT_CONTRACT_REGISTRY.versionOf(transfer.from));\r\n                dolomiteDirect.brokerMarginRequestApproval(\r\n                    transfer.from,\r\n                    transfer.token,\r\n                    transfer.amount\r\n                );\r\n                TRADE_DELEGATE.transferTokenFrom(\r\n                    transfer.token,\r\n                    address(dolomiteDirect),\r\n                    transfer.to,\r\n                    transfer.amount\r\n                );\r\n            } else {\r\n                TRADE_DELEGATE.transferTokenFrom(\r\n                    transfer.token,\r\n                    transfer.from,\r\n                    transfer.to,\r\n                    transfer.amount\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function _generateDydxPerformParams(RunTime.Context memory ctx, bytes memory ringData, bool isTypeSafe)\r\n    internal\r\n    pure\r\n    returns (DydxPosition.Info[] memory positions, DydxActions.ActionArgs[] memory actions)\r\n    {\r\n        positions = new DydxPosition.Info[](ctx.numDydxPositions + 1);\r\n        actions = new DydxActions.ActionArgs[](ctx.numDydxBeforeActions + ctx.numDydxAfterActions + 1);\r\n\r\n        // Trim positions array & insert before actions to beginning of actions array\r\n        for (uint i = 0; i < ctx.numDydxPositions; i++) positions[i] = ctx.dydxPositions[i];\r\n        for (uint j = 0; j < ctx.numDydxBeforeActions; j++) actions[j] = ctx.dydxBeforeActions[j];\r\n\r\n        // Insert Loopring settlement action after the \"before\" actions\r\n        positions[ctx.numDydxPositions] = DydxPosition.Info(ctx.self, 123456789);\r\n        actions[ctx.numDydxBeforeActions] = DydxActionBuilder.LoopringSettlement({\r\n            settlementData : abi.encode(isTypeSafe, ringData),\r\n            settlementCaller : ctx.self,\r\n            positionIndex : ctx.numDydxPositions\r\n            });\r\n\r\n        // Insert all of the after actions after Loopring settlement is to take place\r\n        for (uint k = 0; k < ctx.numDydxAfterActions; k++) {\r\n            actions[k + ctx.numDydxBeforeActions + 1] = ctx.dydxAfterActions[k];\r\n        }\r\n    }\r\n\r\n    function _clearRuntime(RunTime.Context memory ctx) internal {\r\n        for (uint i = 0; i < ctx.orders.length; i++) {\r\n            bytes32 orderHash = ctx.orders[i].orderHash;\r\n            for (uint j = 0; j < ctx.marketTokenAddress.length; j++) {\r\n                _runtimeIncomingAmount[orderHash][ctx.marketTokenAddress[j]] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // =================================\r\n    // Loopring Settlement & dYdX Action Callbacks\r\n\r\n    /*\r\n     * @Implements IDyDxCallee\r\n     *\r\n     * dYdX is instructed to perform all of the necessary actions for\r\n     * margin order settlement (and loan/liquidation settlement) to succeed.\r\n     * After all of these actions, an action is performed that calls this function,\r\n     * which performs trade settlement through Loopring v2.3\r\n     */\r\n    function callFunction(\r\n        address sender,\r\n        DydxPosition.Info memory accountInfo,\r\n        bytes memory data\r\n    ) public noEntry {\r\n        require(msg.sender == address(DYDX_PROTOCOL), \"INVALID_CALLER: IDyDxCallee caller must be dYdX protocol\");\r\n        (bool isTypeSafe, bytes memory ringData) = abi.decode(data, (bool, bytes));\r\n        if (isTypeSafe) {\r\n            revert(\"Submitting rings with type safety is not enabled!\");\r\n            //      LOOPRING_PROTOCOL.submitRings(abi.decode(ringData, (Data.SubmitRingsRequest)));\r\n        } else {\r\n            LOOPRING_PROTOCOL.submitRings(ringData);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @Implements ILoopringBrokerDelegate\r\n     *\r\n     * Loopring will request the available balance of the order owner if the broker. The amount of funds borrowed is\r\n     * baked into the size of the order. Thus, returning an actual balance is redundant.\r\n     */\r\n    function brokerBalanceOf(address user, address token) public view returns (uint) {\r\n        return uint(- 1);\r\n    }\r\n\r\n    /*\r\n     * @Implements ILoopringBrokerDelegate\r\n     *\r\n     * Loopring will then request approval to transfer the borrowed amount to settle the\r\n     * order with the borrowed funds. Loopring notifies this contract how much the order\r\n     * has been filled and requires that the funds are sent into itself (this). The exact\r\n     * amount of received tokens is stored for later use.\r\n     */\r\n    function brokerRequestAllowance(BrokerData.BrokerApprovalRequest memory request) public noEntry returns (bool) {\r\n        require(msg.sender == address(TRADE_DELEGATE), \"INVALID_CALLER: Caller of broker impl must be Loopring Delegate\");\r\n\r\n        for (uint i = 0; i < request.orders.length; i++) {\r\n            BrokerData.BrokerOrder memory order = request.orders[i];\r\n            require(order.tokenRecipient == address(this), \"INVALID_RECIPIENT: Token recipient must be set to margin protocol\");\r\n            require(order.requestedFeeAmount == 0, \"INVALID_ORDER_FEE: FeeToken must be in tokenB of Loopring order\");\r\n\r\n            _runtimeIncomingAmount[order.orderHash][request.tokenB] = order.fillAmountB;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function onOrderFillReport(BrokerData.BrokerInterceptorReport memory fillReport) public {\r\n        // No op - do nothing\r\n    }\r\n\r\n    /*\r\n     * @Implements IDyDxExchangeWrapper\r\n     *\r\n     * Neat \"hack\": if you want to orchestrate a deposit for an unknown amount\r\n     * you can use a SellAction to do it. Have dYdX \"sell\" 1 wei and, in the\r\n     * implementation of the IExchangeWrapper's exchange function, return an amount\r\n     * and it will be deposited into the dYdX position in full! 1 wei is burned unfortunately,\r\n     * but who really cares.\r\n     *\r\n     * That amount we \"stored for later use\" is returned so that all of the purchased tokens\r\n     * are deposited into dYdX in full.\r\n     */\r\n    function exchange(\r\n        address tradeOriginator,\r\n        address receiver,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount,\r\n        bytes memory orderData\r\n    ) public noEntry returns (uint256) {\r\n        require(msg.sender == address(DYDX_PROTOCOL), \"INVALID_EXCHANGE_CALLER\");\r\n        bytes32 orderHash = abi.decode(orderData, (bytes32));\r\n        return _runtimeIncomingAmount[orderHash][makerToken];\r\n    }\r\n\r\n    // =================================\r\n    // Administrative\r\n\r\n    function enableToken(address tokenAddress) public {\r\n        IERC20(tokenAddress).approve(address(TRADE_DELEGATE), uint(- 1));\r\n        IERC20(tokenAddress).approve(address(DYDX_PROTOCOL), uint(- 1));\r\n    }\r\n\r\n    function enableTokens(address[] calldata tokenAddresses) external {\r\n        for (uint i = 0; i < tokenAddresses.length; i++) {\r\n            enableToken(tokenAddresses[i]);\r\n        }\r\n    }\r\n\r\n    // =================================\r\n    // Private\r\n\r\n    function validateGaslessRequest(\r\n        bytes32 typeHash,\r\n        address signer,\r\n        uint positionId,\r\n        uint tokenId,\r\n        uint amount,\r\n        uint feeAmount,\r\n        address feeRecipient,\r\n        uint expiry,\r\n        uint nonce,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) private {\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                domainSeparator,\r\n                keccak256(abi.encode(typeHash, signer, positionId, tokenId, amount, feeAmount, feeRecipient, expiry, nonce))\r\n            )\r\n        );\r\n\r\n        require(signer == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\r\n        require(expiry == 0 || now <= expiry, \"REQUEST_EXPIRED\");\r\n        require(nonce == _nonces[signer], \"INVALID_NONCE\");\r\n        if (feeAmount > 0) {\r\n            require(feeRecipient != address(0x0), \"INVALID_FEE_ADDRESS\");\r\n        }\r\n\r\n        _nonces[signer] += 1;\r\n    }\r\n\r\n    function payFeesForDolomiteDirectDepositIfNecessary(\r\n        uint feeAmount,\r\n        address feeRecipient,\r\n        uint tokenId\r\n    ) private {\r\n        if (feeAmount > 0) {\r\n            require(feeRecipient != address(0x0), \"INVALID_FEE_RECIPIENT\");\r\n            address token = DYDX_PROTOCOL.getMarketTokenAddress(tokenId);\r\n            IERC20(token).safeTransfer(feeRecipient, feeAmount);\r\n        }\r\n    }\r\n\r\n    function performDolomiteDirectDepositTransferIn(\r\n        address signer,\r\n        uint tokenId,\r\n        uint amount\r\n    )\r\n    private {\r\n        IDolomiteDirect dolomiteDirect = IDolomiteDirect(DEPOSIT_CONTRACT_REGISTRY.versionOf(signer));\r\n        address token = DYDX_PROTOCOL.getMarketTokenAddress(tokenId);\r\n        dolomiteDirect.brokerMarginRequestApproval(signer, token, amount);\r\n        TRADE_DELEGATE.transferTokenFrom(\r\n            token,\r\n            address(dolomiteDirect),\r\n            address(this),\r\n            amount\r\n        );\r\n    }\r\n\r\n    function performDolomiteDirectDeposit(\r\n        address signer,\r\n        uint positionId,\r\n        uint tokenId,\r\n        uint amountLessFee\r\n    )\r\n    private {\r\n        address trader = DEPOSIT_CONTRACT_REGISTRY.depositAddressOf(signer);\r\n\r\n        DydxPosition.Info[] memory infos = new DydxPosition.Info[](1);\r\n        infos[0] = DydxPosition.Info(trader, positionId);\r\n\r\n        DydxActions.ActionArgs[] memory args = new DydxActions.ActionArgs[](1);\r\n        args[0] = DydxActionBuilder.Deposit(0, tokenId, amountLessFee, /* from */ address(this));\r\n\r\n        DYDX_PROTOCOL.operate(infos, args);\r\n    }\r\n\r\n    function performDolomiteDirectWithdraw(\r\n        address signer,\r\n        uint positionId,\r\n        uint tokenId,\r\n        uint amount\r\n    )\r\n    private {\r\n        address trader = DEPOSIT_CONTRACT_REGISTRY.depositAddressOf(signer);\r\n\r\n        DydxPosition.Info[] memory infos = new DydxPosition.Info[](1);\r\n        infos[0] = DydxPosition.Info(trader, positionId);\r\n\r\n        // We withdraw to the trader's deposit contract so we can later pull the fee, if there is one. Reason being,\r\n        // there may be leftover funds in this contract, so we cannot trust the values/balances presented in here.\r\n        // Therefore, it's best to just send it to the trader, and then pull what's needed afterward.\r\n        DydxActions.ActionArgs[] memory args = new DydxActions.ActionArgs[](1);\r\n        if (amount == uint(- 1)) {\r\n            args[0] = DydxActionBuilder.WithdrawAll(0, tokenId, trader);\r\n        } else {\r\n            args[0] = DydxActionBuilder.Withdraw(0, tokenId, amount, trader);\r\n        }\r\n\r\n        DYDX_PROTOCOL.operate(infos, args);\r\n    }\r\n\r\n    function payFeesForDolomiteDirectWithdrawalIfNecessary(\r\n        address signer,\r\n        uint feeAmount,\r\n        address feeRecipient,\r\n        uint tokenId\r\n    ) private {\r\n        if (feeAmount > 0) {\r\n            require(feeRecipient != address(0x0), \"INVALID_FEE_RECIPIENT\");\r\n\r\n            address dolomiteDirect = DEPOSIT_CONTRACT_REGISTRY.versionOf(signer);\r\n            address token = DYDX_PROTOCOL.getMarketTokenAddress(tokenId);\r\n\r\n            IDolomiteDirect(dolomiteDirect).brokerMarginRequestApproval(\r\n                signer,\r\n                token,\r\n                feeAmount\r\n            );\r\n            TRADE_DELEGATE.transferTokenFrom(\r\n                token,\r\n                dolomiteDirect,\r\n                feeRecipient,\r\n                feeAmount\r\n            );\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dydxProtocol\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"loopringProtocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dydxExpiry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"depositContractRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEPOSIT_COLLATERAL_TYPE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEPOSIT_CONTRACT_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IDepositContractRegistry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DYDX_EXPIRY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DYDX_PROTOCOL\",\"outputs\":[{\"internalType\":\"contract IDyDxProtocol\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOOPRING_PROTOCOL\",\"outputs\":[{\"internalType\":\"contract IRingSubmitter\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TRADE_DELEGATE\",\"outputs\":[{\"internalType\":\"contract ILoopringTradeDelegate\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAW_COLLATERAL_TYPE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"brokerBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedAmountS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct BrokerData.BrokerOrder[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenS\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalFillAmountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRequestedAmountS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRequestedFeeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BrokerData.BrokerApprovalRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"brokerRequestAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct DydxPosition.Info\",\"name\":\"accountInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositCollateralViaGaslessRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"enableToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"enableTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tradeOriginator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"makerToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedFillAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"nonceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"broker\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenS\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spentAmountS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spentFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct BrokerData.BrokerInterceptorReport\",\"name\":\"fillReport\",\"type\":\"tuple\"}],\"name\":\"onOrderFillReport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"ringData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"relevantOrderIndices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"relevantMarketIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"enum Activity.Type\",\"name\":\"activityType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"encodedFields\",\"type\":\"bytes\"}],\"internalType\":\"struct Activity.ActivityArg[]\",\"name\":\"activityArgs\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"dustCollector\",\"type\":\"address\"}],\"internalType\":\"struct DolomiteMarginProtocol.RelayParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"submitRingsThroughDyDx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"withdrawCollateralViaGaslessRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawDust\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DolomiteMarginProtocol","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001e0447b19bb6ecfdae1e4ae1694b0c3659614e4e000000000000000000000000c0b569ff46eea7bfbb130bd6d7af0a0a7f513c6f0000000000000000000000000ece224fbc24d40b446c6a94a142dc41fae76f2d000000000000000000000000ca8efcc93bca0bd89ad9bfffd050483dd80fdf07","EVMVersion":"istanbul","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4d8018bcd997e30a757d97b3ca745d68187a8ac56783e67362e67a0d50993823"}]}