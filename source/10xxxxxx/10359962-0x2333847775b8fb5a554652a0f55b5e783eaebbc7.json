{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\n\ncontract IERC20 {\n    function balanceOf(\n        address whom\n    )\n    external\n    view\n    returns (uint);\n\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n    public\n    returns (bool);\n\n\n\n    function decimals()\n    external\n    view\n    returns (uint);\n\n\n    function symbol()\n    external\n    view\n    returns (string);\n\n\n    function name()\n    external\n    view\n    returns (string);\n\n\n    function freezeTransfers()\n    external;\n\n\n    function unfreezeTransfers()\n    external;\n}\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITwoKeyAdmin {\n    function getDefaultIntegratorFeePercent() public view returns (uint);\n    function getDefaultNetworkTaxPercent() public view returns (uint);\n    function getTwoKeyRewardsReleaseDate() external view returns(uint);\n    function updateReceivedTokensAsModerator(uint amountOfTokens) public;\n    function updateReceivedTokensAsModeratorPPC(uint amountOfTokens, address campaignPlasma) public;\n    function addFeesCollectedInCurrency(string currency, uint amount) public payable;\n\n    function updateTokensReceivedFromDistributionFees(uint amountOfTokens) public;\n}\n\ncontract ITwoKeyCampaignValidator {\n    function isCampaignValidated(address campaign) public view returns (bool);\n    function validateAcquisitionCampaign(address campaign, string nonSingletonHash) public;\n    function validateDonationCampaign(address campaign, address donationConversionHandler, address donationLogicHandler, string nonSingletonHash) public;\n    function validateCPCCampaign(address campaign, string nonSingletonHash) public;\n}\n\ncontract ITwoKeyEventSource {\n\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n    function isAddressMaintainer(address _maintainer) public view returns (bool);\n    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n    function joined(address _campaign, address _from, address _to) external;\n    function rejected(address _campaign, address _converter) external;\n\n    function convertedAcquisition(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _baseTokens,\n        uint256 _bonusTokens,\n        uint256 _conversionAmount,\n        bool _isFiatConversion,\n        uint _conversionId\n    )\n    external;\n\n    function getTwoKeyDefaultNetworkTaxPercent()\n    public\n    view\n    returns (uint);\n\n    function convertedDonation(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _conversionAmount,\n        uint256 _conversionId\n    )\n    external;\n\n    function executed(\n        address _campaignAddress,\n        address _converterPlasmaAddress,\n        uint _conversionId,\n        uint tokens\n    )\n    external;\n\n    function tokensWithdrawnFromPurchasesHandler(\n        address campaignAddress,\n        uint _conversionID,\n        uint _tokensAmountWithdrawn\n    )\n    external;\n\n    function emitDebtEvent(\n        address _plasmaAddress,\n        uint _amount,\n        bool _isAddition,\n        string _currency\n    )\n    external;\n\n    function emitReceivedTokensToDeepFreezeTokenPool(\n        address _campaignAddress,\n        uint _amountOfTokens\n    )\n    public;\n\n    function emitReceivedTokensAsModerator(\n        address _campaignAddress,\n        uint _amountOfTokens\n    )\n    public;\n\n    function emitDAIReleasedAsIncome(\n        address _campaignContractAddress,\n        uint _amountOfDAI\n    )\n    public;\n\n    function emitEndedBudgetCampaign(\n        address campaignPlasmaAddress,\n        uint contractorLeftover,\n        uint moderatorEarningsDistributed\n    )\n    public;\n\n\n    function emitUserWithdrawnNetworkEarnings(\n        address user,\n        uint amountOfTokens\n    )\n    public;\n\n    function emitRebalancedRewards(\n        uint cycleId,\n        uint difference,\n        string action\n    )\n    public;\n}\n\ncontract ITwoKeyExchangeRateContract {\n    function getBaseToTargetRate(string _currency) public view returns (uint);\n    function getStableCoinTo2KEYQuota(address stableCoinAddress) public view returns (uint,uint);\n    function getStableCoinToUSDQuota(address stableCoin) public view returns (uint);\n}\n\ncontract ITwoKeyMaintainersRegistry {\n    function checkIsAddressMaintainer(address _sender) public view returns (bool);\n    function checkIsAddressCoreDev(address _sender) public view returns (bool);\n\n    function addMaintainers(address [] _maintainers) public;\n    function addCoreDevs(address [] _coreDevs) public;\n    function removeMaintainers(address [] _maintainers) public;\n    function removeCoreDevs(address [] _coreDevs) public;\n}\n\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestCampaignApprovedVersion(string campaignType) public view returns (string);\n}\n\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    * @param contractName is the name of the contract we added new version\n    */\n    event VersionAdded(string version, address implementation, string contractName);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ncontract IUpgradableExchange {\n\n    function buyRate2key() public view returns (uint);\n    function sellRate2key() public view returns (uint);\n\n    function buyTokensWithERC20(\n        uint amountOfTokens,\n        address tokenAddress\n    )\n    public\n    returns (uint,uint);\n\n    function buyTokens(\n        address _beneficiary\n    )\n    public\n    payable\n    returns (uint,uint);\n\n    function buyStableCoinWith2key(\n        uint _twoKeyUnits,\n        address _beneficiary\n    )\n    public\n    payable;\n\n    function report2KEYWithdrawnFromNetwork(\n        uint amountOfTokensWithdrawn\n    )\n    public;\n\n    function getEth2DaiAverageExchangeRatePerContract(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint);\n\n    function getContractId(\n        address _contractAddress\n    )\n    public\n    view\n    returns (uint);\n\n    function getEth2KeyAverageRatePerContract(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint);\n\n    function returnLeftoverAfterRebalancing(\n        uint amountOf2key\n    )\n    public;\n\n\n    function getMore2KeyTokensForRebalancing(\n        uint amountOf2KeyRequested\n    )\n    public\n    view\n    returns (uint);\n\n\n    function releaseAllDAIFromContractToReserve()\n    public;\n\n    function setKyberReserveInterfaceContractAddress(\n        address kyberReserveContractAddress\n    )\n    public;\n\n    function setSpreadWei(\n        uint newSpreadWei\n    )\n    public;\n\n    function withdrawDAIAvailableToFill2KEYReserve(\n        uint amountOfDAI\n    )\n    public\n    returns (uint);\n\n    function returnTokensBackToExchangeV1(\n        uint amountOfTokensToReturn\n    )\n    public;\n\n\n    function getMore2KeyTokensForRebalancingV1(\n        uint amountOfTokensRequested\n    )\n    public;\n}\n\ncontract ITwoKeyFeeManagerStorage is IStructuredStorage {\n\n}\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\ncontract ITwoKeySingletonUtils {\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    // Modifier to restrict method calls only to maintainers\n    modifier onlyMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressMaintainer(msg.sender));\n        _;\n    }\n\n    /**\n     * @notice Function to get any singleton contract proxy address from TwoKeySingletonRegistry contract\n     * @param contractName is the name of the contract we're looking for\n     */\n    function getAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getContractProxyAddress(contractName);\n    }\n\n    function getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getNonUpgradableContractAddress(contractName);\n    }\n}\n\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\n\ncontract TwoKeyFeeManager is Upgradeable, ITwoKeySingletonUtils {\n    /**\n     * This contract will store the fees and users registration debts\n     * Depending of user role, on some actions 2key.network will need to deduct\n     * users contribution amount / earnings / proceeds, in order to cover transactions\n     * paid by 2key.network for users registration\n     */\n    using SafeMath for *;\n\n    bool initialized;\n    ITwoKeyFeeManagerStorage PROXY_STORAGE_CONTRACT;\n\n    //Debt will be stored in ETH\n    string constant _userPlasmaToDebtInETH = \"userPlasmaToDebtInETH\";\n\n    //This refferrs only to registration debt\n    string constant _isDebtSubmitted = \"isDebtSubmitted\";\n    string constant _totalDebtsInETH = \"totalDebtsInETH\";\n\n    string constant _totalPaidInETH = \"totalPaidInETH\";\n    string constant _totalPaidInDAI = \"totalPaidInDAI\";\n    string constant _totalPaidIn2Key = \"totalPaidIn2Key\";\n\n    string constant _totalWithdrawnInETH = \"totalWithdrawnInETH\";\n    string constant _eth2KeyRateOnWhichDebtWasPaidPerCampaign = \"eth2KeyRateOnWhichDebtWasPaidPerCampaign\";\n\n    /**\n     * Modifier which will allow only completely verified and validated contracts to call some functions\n     */\n    modifier onlyAllowedContracts {\n        address twoKeyCampaignValidator = getAddressFromTwoKeySingletonRegistry(\"TwoKeyCampaignValidator\");\n        require(ITwoKeyCampaignValidator(twoKeyCampaignValidator).isCampaignValidated(msg.sender) == true);\n        _;\n    }\n\n    modifier onlyTwoKeyAdmin {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        require(msg.sender == twoKeyAdmin);\n        _;\n    }\n\n    function setInitialParams(\n        address _twoKeySingletonRegistry,\n        address _proxyStorage\n    )\n    public\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyFeeManagerStorage(_proxyStorage);\n\n        initialized = true;\n    }\n\n\n\n    function setDebtInternal(\n        address _plasmaAddress,\n        uint _registrationFee\n    )\n    internal\n    {\n        // Generate the key for debt\n        bytes32 keyHashForUserDebt = keccak256(_userPlasmaToDebtInETH, _plasmaAddress);\n\n        // Get current debt\n        uint currentDebt = PROXY_STORAGE_CONTRACT.getUint(keyHashForUserDebt);\n\n        // Add on current debt new debt\n        PROXY_STORAGE_CONTRACT.setUint(keyHashForUserDebt,currentDebt.add(_registrationFee));\n\n        //Get the key for the total debts in eth\n        bytes32 key = keccak256(_totalDebtsInETH);\n\n        //Get the total debts from storage contract and increase by _registrationFee\n        uint totalDebts = _registrationFee.add(PROXY_STORAGE_CONTRACT.getUint(key));\n\n        //Set new value for totalDebts\n        PROXY_STORAGE_CONTRACT.setUint(key, totalDebts);\n    }\n\n    /**\n     * @notice          Function which will be used to add additional debts for user\n     *                  such as re-registration, and probably more things in the future\n     *\n     * @param           _plasmaAddress is user plasma address\n     * @param           _debtAmount is the amount of debt we're adding to current debt\n     * @param           _debtType is selector which will restrict that same debt is submitted\n     *                  multiple times\n     */\n    function addDebtForUser(\n        address _plasmaAddress,\n        uint _debtAmount,\n        string _debtType\n    )\n    public\n    {\n        require(msg.sender == getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\"));\n\n        bytes32 keyHashForDebtType = keccak256(_plasmaAddress, _debtType);\n\n        require(PROXY_STORAGE_CONTRACT.getBool(keyHashForDebtType) == false);\n\n        PROXY_STORAGE_CONTRACT.setBool(keyHashForDebtType, true);\n\n        setDebtInternal(_plasmaAddress, _debtAmount);\n    }\n\n\n    /**\n     * @notice          Function which will submit registration fees\n     *                  It can be called only once par _address\n     * @param           _plasmaAddress is the address of the user\n     * @param           _registrationFee is the amount paid for the registration\n     */\n    function setRegistrationFeeForUser(\n        address _plasmaAddress,\n        uint _registrationFee\n    )\n    public\n    {\n        //Check that this function can be called only by TwoKeyEventSource\n        require(msg.sender == getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\"));\n\n        // Generate the key for the storage\n        bytes32 keyHashIsDebtSubmitted = keccak256(_isDebtSubmitted, _plasmaAddress);\n\n        //Check that for this user we have never submitted the debt in the past\n        require(PROXY_STORAGE_CONTRACT.getBool(keyHashIsDebtSubmitted) == false);\n\n        //Set that debt is submitted\n        PROXY_STORAGE_CONTRACT.setBool(keyHashIsDebtSubmitted, true);\n\n        setDebtInternal(_plasmaAddress, _registrationFee);\n    }\n\n    /**\n     * @notice          Function to check for the user if registration debt is submitted\n     * @param           _plasmaAddress is users plasma address\n     */\n    function isRegistrationDebtSubmittedForTheUser(\n        address _plasmaAddress\n    )\n    public\n    view\n    returns (bool)\n    {\n        bytes32 keyHashIsDebtSubmitted = keccak256(_isDebtSubmitted, _plasmaAddress);\n        return PROXY_STORAGE_CONTRACT.getBool(keyHashIsDebtSubmitted);\n    }\n\n    /**\n     * @notice          Function where maintainer can set debts per user\n     * @param           usersPlasmas is the array of user plasma addresses\n     * @param           fees is the array containing fees which 2key paid for user\n     * Only maintainer is eligible to call this function.\n     */\n    function setRegistrationFeesForUsers(\n        address [] usersPlasmas,\n        uint [] fees\n    )\n    public\n    onlyMaintainer\n    {\n        uint i = 0;\n        uint total = 0;\n        // Iterate through all addresses and store the registration fees paid for them\n        for(i = 0; i < usersPlasmas.length; i++) {\n            // Generate the key for the storage\n            bytes32 keyHashIsDebtSubmitted = keccak256(_isDebtSubmitted, usersPlasmas[i]);\n\n            //Check that for this user we have never submitted the debt in the past\n            require(PROXY_STORAGE_CONTRACT.getBool(keyHashIsDebtSubmitted) == false);\n\n            //Set that debt is submitted\n            PROXY_STORAGE_CONTRACT.setBool(keyHashIsDebtSubmitted, true);\n\n            PROXY_STORAGE_CONTRACT.setUint(keccak256(_userPlasmaToDebtInETH, usersPlasmas[i]), fees[i]);\n\n            total = total.add(fees[i]);\n        }\n\n        // Increase total debts\n        bytes32 key = keccak256(_totalDebtsInETH);\n        uint totalDebts = total.add(PROXY_STORAGE_CONTRACT.getUint(key));\n        PROXY_STORAGE_CONTRACT.setUint(key, totalDebts);\n    }\n\n\n\n    /**\n     * @notice          Getter where we can check how much ETH user owes to 2key.network for his registration\n     * @param           _userPlasma is user plasma address\n     */\n    function getDebtForUser(\n        address _userPlasma\n    )\n    public\n    view\n    returns (uint)\n    {\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(_userPlasmaToDebtInETH, _userPlasma));\n    }\n\n\n    /**\n     * @notice          Function to check if user has some debts and if yes, take them from _amount\n     * @param           _plasmaAddress is the plasma address of the user\n     * @param           _debtPaying is the part or full debt user is paying\n     */\n    function payDebtWhenConvertingOrWithdrawingProceeds(\n        address _plasmaAddress,\n        uint _debtPaying\n    )\n    public\n    payable\n    onlyAllowedContracts\n    {\n        bytes32 keyHashForDebt = keccak256(_userPlasmaToDebtInETH, _plasmaAddress);\n        uint totalDebtForUser = PROXY_STORAGE_CONTRACT.getUint(keyHashForDebt);\n\n        PROXY_STORAGE_CONTRACT.setUint(keyHashForDebt, totalDebtForUser.sub(_debtPaying));\n\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        ITwoKeyAdmin(twoKeyAdmin).addFeesCollectedInCurrency.value(msg.value)(\"ETH\", msg.value);\n\n        ITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\")).emitDebtEvent(\n            _plasmaAddress,\n            _debtPaying,\n            false,\n            \"ETH\"\n        );\n    }\n\n    function payDebtWithDAI(\n        address _plasmaAddress,\n        uint _totalDebtDAI,\n        uint _debtAmountPaidDAI\n    )\n    public\n    {\n        require(msg.sender == getAddressFromTwoKeySingletonRegistry(\"TwoKeyUpgradableExchange\"));\n\n        bytes32 keyHashForDebt = keccak256(_userPlasmaToDebtInETH, _plasmaAddress);\n        uint totalDebtForUser = PROXY_STORAGE_CONTRACT.getUint(keyHashForDebt);\n\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        ITwoKeyAdmin(twoKeyAdmin).addFeesCollectedInCurrency(\"DAI\", _debtAmountPaidDAI);\n\n        totalDebtForUser = totalDebtForUser.sub(totalDebtForUser.mul(_debtAmountPaidDAI.mul(10**18).div(_totalDebtDAI)).div(10**18));\n        PROXY_STORAGE_CONTRACT.setUint(keyHashForDebt, totalDebtForUser);\n\n\n        ITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\")).emitDebtEvent(\n            _plasmaAddress,\n            _debtAmountPaidDAI,\n            false,\n            \"DAI\"\n        );\n\n    }\n\n    function payDebtWith2KeyV2(\n        address _beneficiaryPublic,\n        address _plasmaAddress,\n        uint _amountOf2keyForRewards,\n        address _twoKeyEconomy\n    )\n    public\n    onlyAllowedContracts\n    {\n        address _twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        payDebtWith2KeyV2Internal(_beneficiaryPublic,_plasmaAddress,_amountOf2keyForRewards,_twoKeyEconomy,_twoKeyAdmin);\n    }\n\n    function payDebtWith2KeyV2(\n        address _beneficiaryPublic,\n        address _plasmaAddress,\n        uint _amountOf2keyForRewards,\n        address _twoKeyEconomy,\n        address _twoKeyAdmin\n    )\n    public\n    onlyAllowedContracts\n    {\n        payDebtWith2KeyV2Internal(_beneficiaryPublic,_plasmaAddress,_amountOf2keyForRewards,_twoKeyEconomy,_twoKeyAdmin);\n    }\n\n    function payDebtWith2KeyV2Internal(\n        address _beneficiaryPublic,\n        address _plasmaAddress,\n        uint _amountOf2keyForRewards,\n        address _twoKeyEconomy,\n        address _twoKeyAdmin\n    )\n    internal\n    {\n        uint usersDebtInEth = getDebtForUser(_plasmaAddress);\n        uint amountToPay = 0;\n\n        if(usersDebtInEth > 0) {\n\n            // Get Eth 2 2Key rate for this contract\n            uint ethTo2key = getEth2KeyRateOnWhichDebtWasPaidForCampaign(msg.sender);\n\n            // If Eth 2 2Key rate doesn't exist for this contract calculate it\n            if(ethTo2key == 0) {\n                ethTo2key = setEth2KeyRateOnWhichDebtGetsPaid(msg.sender);\n            }\n\n            // 2KEY / ETH\n            uint debtIn2Key = (usersDebtInEth.mul(ethTo2key)).div(10**18); // ETH * (2KEY / ETH) = 2KEY\n\n            // This is the initial amount he has to pay\n            amountToPay = debtIn2Key;\n\n            if (_amountOf2keyForRewards > debtIn2Key){\n                if(_amountOf2keyForRewards < 3 * debtIn2Key) {\n                    amountToPay = debtIn2Key / 2;\n                }\n            }\n            else {\n                amountToPay = _amountOf2keyForRewards / 4;\n            }\n\n            // Emit event that debt is paid it's inside this if because if there's no debt it will just continue and transfer all tokens to the influencer\n            ITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\")).emitDebtEvent(\n                _plasmaAddress,\n                amountToPay,\n                false,\n                \"2KEY\"\n            );\n\n\n            // Update if there's any leftover with debt\n            bytes32 keyHashForDebt = keccak256(_userPlasmaToDebtInETH, _plasmaAddress);\n            usersDebtInEth = usersDebtInEth.sub(usersDebtInEth.mul(amountToPay.mul(10**18).div(debtIn2Key)).div(10**18));\n            PROXY_STORAGE_CONTRACT.setUint(keyHashForDebt, usersDebtInEth);\n        }\n\n        ITwoKeyAdmin(_twoKeyAdmin).addFeesCollectedInCurrency(\"2KEY\", amountToPay);\n        // Take tokens from campaign contract\n        IERC20(_twoKeyEconomy).transferFrom(msg.sender, _twoKeyAdmin, amountToPay);\n        // Transfer tokens - debt to influencer\n        IERC20(_twoKeyEconomy).transferFrom(msg.sender, _beneficiaryPublic, _amountOf2keyForRewards.sub(amountToPay));\n    }\n\n\n\n    function calculateEth2KeyRate()\n    internal\n    view\n    returns (uint)\n    {\n        address upgradableExchange = getAddressFromTwoKeySingletonRegistry(\"TwoKeyUpgradableExchange\");\n        uint contractID = IUpgradableExchange(upgradableExchange).getContractId(msg.sender);\n        uint ethTo2key = IUpgradableExchange(upgradableExchange).getEth2KeyAverageRatePerContract(contractID);\n\n        // If there's no existing rate at the moment, compute it\n        if(ethTo2key == 0) {\n            //This means that budget for this campaign was added directly as 2KEY\n            /**\n             1 eth = 200$\n             1 2KEY = 0.06 $\n\n             200 = 0.06 * x\n             x = 200 / 0.06\n             x = 3333,333333333\n             1 eth = 3333,333333 2KEY\n             */\n            uint eth_usd = ITwoKeyExchangeRateContract(getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\")).\n            getBaseToTargetRate(\"USD\");\n\n            // get current 2key rate\n            uint twoKey_usd = IUpgradableExchange(upgradableExchange).sellRate2key();\n\n            // Compute rates at this particular moment\n            ethTo2key = eth_usd.mul(10**18).div(twoKey_usd);\n        }\n        return ethTo2key;\n    }\n\n\n\n    function payDebtWith2Key(\n        address _beneficiaryPublic,\n        address _plasmaAddress,\n        uint _amountOf2keyForRewards\n    )\n    public\n    onlyAllowedContracts\n    {\n        uint usersDebtInEth = getDebtForUser(_plasmaAddress);\n        uint amountToPay = 0;\n\n        if(usersDebtInEth > 0) {\n\n            // Get Eth 2 2Key rate for this contract\n            uint ethTo2key = getEth2KeyRateOnWhichDebtWasPaidForCampaign(msg.sender);\n\n            // If Eth 2 2Key rate doesn't exist for this contract calculate it\n            if(ethTo2key == 0) {\n                ethTo2key = setEth2KeyRateOnWhichDebtGetsPaid(msg.sender);\n            }\n\n            // 2KEY / ETH\n            uint debtIn2Key = (usersDebtInEth.mul(ethTo2key)).div(10**18); // ETH * (2KEY / ETH) = 2KEY\n\n            // This is the initial amount he has to pay\n            amountToPay = debtIn2Key;\n\n            if (_amountOf2keyForRewards > debtIn2Key){\n                if(_amountOf2keyForRewards < 3 * debtIn2Key) {\n                    amountToPay = debtIn2Key / 2;\n                }\n            }\n            else {\n                amountToPay = _amountOf2keyForRewards / 4;\n            }\n\n            // Emit event that debt is paid it's inside this if because if there's no debt it will just continue and transfer all tokens to the influencer\n            ITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\")).emitDebtEvent(\n                _plasmaAddress,\n                amountToPay,\n                false,\n                \"2KEY\"\n            );\n\n\n            // Get keyhash for debt\n            bytes32 keyHashForDebt = keccak256(_userPlasmaToDebtInETH, _plasmaAddress);\n\n            bytes32 keyHashTotalPaidIn2Key = keccak256(_totalPaidIn2Key);\n\n            // Set total paid in DAI\n            PROXY_STORAGE_CONTRACT.setUint(keyHashTotalPaidIn2Key, amountToPay.add(PROXY_STORAGE_CONTRACT.getUint(keyHashTotalPaidIn2Key)));\n\n            usersDebtInEth = usersDebtInEth - usersDebtInEth.mul(amountToPay.mul(10**18).div(debtIn2Key)).div(10**18);\n\n            PROXY_STORAGE_CONTRACT.setUint(keyHashForDebt, usersDebtInEth);\n        }\n\n        address twoKeyEconomy = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"TwoKeyEconomy\");\n        // Take tokens from campaign contract\n        IERC20(twoKeyEconomy).transferFrom(msg.sender, address(this), _amountOf2keyForRewards);\n        // Transfer tokens - debt to influencer\n        IERC20(twoKeyEconomy).transfer(_beneficiaryPublic, _amountOf2keyForRewards.sub(amountToPay));\n    }\n\n\n    function getEth2KeyRateOnWhichDebtWasPaidForCampaign(\n        address campaignAddress\n    )\n    public\n    view\n    returns (uint)\n    {\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(_eth2KeyRateOnWhichDebtWasPaidPerCampaign,campaignAddress));\n    }\n\n    function setEth2KeyRateOnWhichDebtGetsPaid(\n        address campaignAddress\n    )\n    internal\n    returns (uint)\n    {\n        uint rate = calculateEth2KeyRate();\n        PROXY_STORAGE_CONTRACT.setUint(keccak256(_eth2KeyRateOnWhichDebtWasPaidPerCampaign,campaignAddress), rate);\n        return rate;\n    }\n\n    /**\n     * @notice          Function to get status of the debts\n     */\n    function getDebtsSummary()\n    public\n    view\n    returns (uint,uint,uint,uint)\n    {\n        uint totalDebtsInEth = PROXY_STORAGE_CONTRACT.getUint(keccak256(_totalDebtsInETH));\n        uint totalPaidInEth = PROXY_STORAGE_CONTRACT.getUint(keccak256(_totalPaidInETH));\n        uint totalPaidInDAI = PROXY_STORAGE_CONTRACT.getUint(keccak256(_totalPaidInDAI));\n        uint totalPaidIn2Key = PROXY_STORAGE_CONTRACT.getUint(keccak256(_totalPaidIn2Key));\n\n        return (\n            totalDebtsInEth,\n            totalPaidInEth,\n            totalPaidInDAI,\n            totalPaidIn2Key\n        );\n    }\n\n\n    function withdrawEtherCollected()\n    public\n    onlyTwoKeyAdmin\n    returns (uint)\n    {\n        uint balance = address(this).balance;\n\n        bytes32 keyHash = keccak256(_totalWithdrawnInETH);\n        PROXY_STORAGE_CONTRACT.setUint(keyHash, balance.add(PROXY_STORAGE_CONTRACT.getUint(keyHash)));\n\n        (msg.sender).transfer(balance);\n\n        return balance;\n    }\n\n    function withdraw2KEYCollected()\n    public\n    onlyTwoKeyAdmin\n    returns (uint)\n    {\n        address twoKeyEconomy = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"TwoKeyEconomy\");\n        uint balance = IERC20(twoKeyEconomy).balanceOf(address(this));\n\n        IERC20(twoKeyEconomy).transfer(msg.sender, balance);\n        return balance;\n    }\n\n    function withdrawDAICollected(\n        address _dai\n    )\n    public\n    onlyTwoKeyAdmin\n    returns (uint)\n    {\n        uint balance = IERC20(_dai).balanceOf(address(this));\n\n        IERC20(_dai).transfer(msg.sender, balance);\n        return balance;\n    }\n\n}\n\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_twoKeySingletonRegistry\",\"type\":\"address\"},{\"name\":\"_proxyStorage\",\"type\":\"address\"}],\"name\":\"setInitialParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw2KEYCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaryPublic\",\"type\":\"address\"},{\"name\":\"_plasmaAddress\",\"type\":\"address\"},{\"name\":\"_amountOf2keyForRewards\",\"type\":\"uint256\"},{\"name\":\"_twoKeyEconomy\",\"type\":\"address\"},{\"name\":\"_twoKeyAdmin\",\"type\":\"address\"}],\"name\":\"payDebtWith2KeyV2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_plasmaAddress\",\"type\":\"address\"}],\"name\":\"isRegistrationDebtSubmittedForTheUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userPlasma\",\"type\":\"address\"}],\"name\":\"getDebtForUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dai\",\"type\":\"address\"}],\"name\":\"withdrawDAICollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEtherCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_KEY_SINGLETON_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignAddress\",\"type\":\"address\"}],\"name\":\"getEth2KeyRateOnWhichDebtWasPaidForCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usersPlasmas\",\"type\":\"address[]\"},{\"name\":\"fees\",\"type\":\"uint256[]\"}],\"name\":\"setRegistrationFeesForUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDebtsSummary\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_plasmaAddress\",\"type\":\"address\"},{\"name\":\"_debtPaying\",\"type\":\"uint256\"}],\"name\":\"payDebtWhenConvertingOrWithdrawingProceeds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_plasmaAddress\",\"type\":\"address\"},{\"name\":\"_debtAmount\",\"type\":\"uint256\"},{\"name\":\"_debtType\",\"type\":\"string\"}],\"name\":\"addDebtForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_plasmaAddress\",\"type\":\"address\"},{\"name\":\"_registrationFee\",\"type\":\"uint256\"}],\"name\":\"setRegistrationFeeForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_plasmaAddress\",\"type\":\"address\"},{\"name\":\"_totalDebtDAI\",\"type\":\"uint256\"},{\"name\":\"_debtAmountPaidDAI\",\"type\":\"uint256\"}],\"name\":\"payDebtWithDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaryPublic\",\"type\":\"address\"},{\"name\":\"_plasmaAddress\",\"type\":\"address\"},{\"name\":\"_amountOf2keyForRewards\",\"type\":\"uint256\"}],\"name\":\"payDebtWith2Key\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaryPublic\",\"type\":\"address\"},{\"name\":\"_plasmaAddress\",\"type\":\"address\"},{\"name\":\"_amountOf2keyForRewards\",\"type\":\"uint256\"},{\"name\":\"_twoKeyEconomy\",\"type\":\"address\"}],\"name\":\"payDebtWith2KeyV2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TwoKeyFeeManager","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}