{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-08-07\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n**/\r\nlibrary SafeMath{\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @dev Abstract contract for approveAndCall.\r\n**/\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\n/**\r\n * @title SiuCoin Token\r\n * @dev ERC20 contract utilizing ERC865-ish structure (3esmit's implementation with alterations).\r\n * @dev to allow users to pay Ethereum fees in tokens.\r\n**/\r\ncontract SiuCoin is Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    string public constant symbol = \"SIU\";\r\n    string public constant name = \"Siucoin\";\r\n    \r\n    uint8 public constant decimals = 18;\r\n    uint256 private _totalSupply = 1500000 * (10 ** 18);\r\n    \r\n    // Function sigs to be used within contract for signature recovery.\r\n    bytes4 internal constant transferSig = 0xa9059cbb;\r\n    bytes4 internal constant approveSig = 0x095ea7b3;\r\n    bytes4 internal constant increaseApprovalSig = 0xd73dd623;\r\n    bytes4 internal constant decreaseApprovalSig = 0x66188463;\r\n    bytes4 internal constant approveAndCallSig = 0xcae9ca51;\r\n    bytes4 internal constant revokeSignatureSig = 0xe40d89e5;\r\n\r\n    // Balances for each account\r\n    mapping(address => uint256) balances;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n    \r\n    // Keeps track of the last nonce sent from user. Used for delegated functions.\r\n    mapping (address => uint256) nonces;\r\n    \r\n    // Mapping of past used hashes: true if already used.\r\n    mapping (address => mapping (bytes => bool)) invalidSignatures;\r\n\r\n    // Mapping of finalized ERC865 standard sigs => our function sigs for future-proofing\r\n    mapping (bytes4 => bytes4) public standardSigs;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed from, address indexed spender, uint tokens);\r\n    event SignatureRedeemed(bytes _sig, address indexed from);\r\n    event Mint(address indexed to, uint256 amount);\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n       \r\n    constructor()\r\n      public\r\n    {\r\n        balances[0xDbCCd61648edFFD465A50a7929B9f7a278Fd7D56] = 1000000 ether;\r\n        balances[0xca1504e201d4Dc31691b70653EB7Dcb1691bc62B] = 500000 ether;\r\n    }\r\n    \r\n    \r\n        \r\n    function _burn(address _who, uint256 _value) onlyOwner public returns (bool) {\r\n            require(_value <= balances[_who]);\r\n            \r\n            balances[_who] = balances[_who].sub(_value);\r\n            _totalSupply = _totalSupply.sub(_value);\r\n            emit Burn(_who, _value);\r\n            emit Transfer(_who, address(0), _value);\r\n            \r\n            return true;\r\n    \r\n    }\r\n        \r\n    function _mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\r\n            _totalSupply = SafeMath.add(_totalSupply, _amount);\r\n            balances[_to] = balances[_to].add(_amount);\r\n            emit Mint(_to, _amount);\r\n            emit Transfer(0x0000000000000000000000000000000000000000, _to, _amount);\r\n            return true;\r\n        }\r\n    \r\n    /**\r\n     * @dev This code allows us to redirect pre-signed calls with different function selectors to our own.\r\n    **/\r\n    function () \r\n      public\r\n    {\r\n        bytes memory calldata = msg.data;\r\n        bytes4 new_selector = standardSigs[msg.sig];\r\n        require(new_selector != 0);\r\n        \r\n        assembly {\r\n           mstore(add(0x20, calldata), new_selector)\r\n        }\r\n        \r\n        require(address(this).delegatecall(calldata));\r\n        \r\n        assembly {\r\n            if iszero(eq(returndatasize, 0x20)) { revert(0, 0) }\r\n            returndatacopy(0, 0, returndatasize)\r\n            return(0, returndatasize)\r\n        }\r\n    }\r\n\r\n\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        require(_transfer(msg.sender, _to, _amount));\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\r\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount);\r\n\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        require(_transfer(_from, _to, _amount));\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        require(_approve(msg.sender, _spender, _amount));\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function increaseApproval(address _spender, uint256 _amount) \r\n      public\r\n    returns (bool success)\r\n    {\r\n        require(_increaseApproval(msg.sender, _spender, _amount));\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function decreaseApproval(address _spender, uint256 _amount) \r\n      public\r\n    returns (bool success)\r\n    {\r\n        require(_decreaseApproval(msg.sender, _spender, _amount));\r\n        return true;\r\n    }\r\n    \r\n    function approveAndCall(address _spender, uint256 _amount, bytes _data) \r\n      public\r\n    returns (bool success) \r\n    {\r\n        require(_approve(msg.sender, _spender, _amount));\r\n        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _data);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _amount)\r\n      internal\r\n    returns (bool success)\r\n    {\r\n        require (_to != address(0));\r\n        require(balances[_from] >= _amount);\r\n        \r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        \r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n    \r\n   \r\n    function _approve(address _owner, address _spender, uint256 _amount) \r\n      internal\r\n    returns (bool success)\r\n    {\r\n        allowed[_owner][_spender] = _amount;\r\n        emit Approval(_owner, _spender, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function _increaseApproval(address _owner, address _spender, uint256 _amount)\r\n      internal\r\n    returns (bool success)\r\n    {\r\n        allowed[_owner][_spender] = allowed[_owner][_spender].add(_amount);\r\n        emit Approval(_owner, _spender, allowed[_owner][_spender]);\r\n        return true;\r\n    }\r\n    \r\n    function _decreaseApproval(address _owner, address _spender, uint256 _amount)\r\n      internal\r\n    returns (bool success)\r\n    {\r\n        if (allowed[_owner][_spender] <= _amount) allowed[_owner][_spender] = 0;\r\n        else allowed[_owner][_spender] = allowed[_owner][_spender].sub(_amount);\r\n        \r\n        emit Approval(_owner, _spender, allowed[_owner][_spender]);\r\n        return true;\r\n    }\r\n    \r\n    function transferPreSigned(\r\n        bytes _signature,\r\n        address _to, \r\n        uint256 _value, \r\n        bytes _extraData,\r\n        uint256 _nonce) \r\n      public\r\n      validPayload(292)\r\n    returns (bool) \r\n    {\r\n        // Log starting gas left of transaction for later gas price calculations.\r\n\r\n        // Recover signer address from signature; ensure address is valid.\r\n        address from = recoverPreSigned(_signature, transferSig, _to, _value, _extraData, _nonce);\r\n        require(from != address(0));\r\n        \r\n        // Require the hash has not been used, declare it used, increment nonce.\r\n        require(!invalidSignatures[from][_signature]);\r\n        invalidSignatures[from][_signature] = true;\r\n        nonces[from]++;\r\n        \r\n        // Internal transfer.\r\n        require(_transfer(from, _to, _value));\r\n\r\n       \r\n        emit SignatureRedeemed(_signature, from);\r\n        return true;\r\n    }\r\n   \r\n    function approvePreSigned(\r\n        bytes _signature,\r\n        address _to, \r\n        uint256 _value, \r\n        bytes _extraData,\r\n        uint256 _nonce) \r\n      public\r\n      validPayload(292)\r\n    returns (bool) \r\n    {\r\n        address from = recoverPreSigned(_signature, approveSig, _to, _value, _extraData, _nonce);\r\n        require(from != address(0));\r\n        require(!invalidSignatures[from][_signature]);\r\n        \r\n        invalidSignatures[from][_signature] = true;\r\n        nonces[from]++;\r\n        \r\n        require(_approve(from, _to, _value));\r\n\r\n        \r\n        emit SignatureRedeemed(_signature, from);\r\n        return true;\r\n    }\r\n    \r\n  \r\n    function increaseApprovalPreSigned(\r\n        bytes _signature,\r\n        address _to, \r\n        uint256 _value, \r\n        bytes _extraData,\r\n        uint256 _nonce)\r\n      public\r\n      validPayload(292)\r\n    returns (bool) \r\n    {\r\n        address from = recoverPreSigned(_signature, increaseApprovalSig, _to, _value, _extraData, _nonce);\r\n        require(from != address(0));\r\n        require(!invalidSignatures[from][_signature]);\r\n        \r\n        invalidSignatures[from][_signature] = true;\r\n        nonces[from]++;\r\n        \r\n        require(_increaseApproval(from, _to, _value));\r\n\r\n        \r\n        emit SignatureRedeemed(_signature, from);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Added for the same reason as increaseApproval. Decreases to 0 if \"_value\" is greater than allowed.\r\n    **/\r\n    function decreaseApprovalPreSigned(\r\n        bytes _signature,\r\n        address _to, \r\n        uint256 _value, \r\n        bytes _extraData,\r\n\r\n        uint256 _nonce) \r\n      public\r\n      validPayload(292)\r\n    returns (bool) \r\n    {\r\n        \r\n        address from = recoverPreSigned(_signature, decreaseApprovalSig, _to, _value, _extraData, _nonce);\r\n        require(from != address(0));\r\n        require(!invalidSignatures[from][_signature]);\r\n        \r\n        invalidSignatures[from][_signature] = true;\r\n        nonces[from]++;\r\n        \r\n        require(_decreaseApproval(from, _to, _value));\r\n\r\n    \r\n        emit SignatureRedeemed(_signature, from);\r\n        return true;\r\n    }\r\n    \r\n    function approveAndCallPreSigned(\r\n        bytes _signature,\r\n        address _to, \r\n        uint256 _value,\r\n        bytes _extraData,\r\n        uint256 _nonce) \r\n      public\r\n      validPayload(356)\r\n    returns (bool) \r\n    {\r\n        address from = recoverPreSigned(_signature, approveAndCallSig, _to, _value, _extraData, _nonce);\r\n        require(from != address(0));\r\n        require(!invalidSignatures[from][_signature]);\r\n        \r\n        invalidSignatures[from][_signature] = true;\r\n        nonces[from]++;\r\n        \r\n        require(_approve(from, _to, _value));\r\n        ApproveAndCallFallBack(_to).receiveApproval(from, _value, address(this), _extraData);\r\n\r\n      \r\n        \r\n        emit SignatureRedeemed(_signature, from);\r\n        return true;\r\n    }\r\n\r\n    function revokeSignature(bytes _sigToRevoke)\r\n      public\r\n    returns (bool)\r\n    {\r\n        invalidSignatures[msg.sender][_sigToRevoke] = true;\r\n        \r\n        emit SignatureRedeemed(_sigToRevoke, msg.sender);\r\n        return true;\r\n    }\r\n    \r\n  \r\n    function revokeSignaturePreSigned(\r\n        bytes _signature,\r\n        bytes _sigToRevoke\r\n        )\r\n      public\r\n      validPayload(356)\r\n    returns (bool)\r\n    {\r\n        address from = recoverRevokeHash(_signature, _sigToRevoke);\r\n        require(!invalidSignatures[from][_signature]);\r\n        invalidSignatures[from][_signature] = true;\r\n        \r\n        invalidSignatures[from][_sigToRevoke] = true;\r\n        \r\n        \r\n        emit SignatureRedeemed(_signature, from);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function getRevokeHash(bytes _sigToRevoke)\r\n      public\r\n      pure\r\n    returns (bytes32 txHash)\r\n    {\r\n        return keccak256(revokeSignatureSig, _sigToRevoke);\r\n    }\r\n\r\n   \r\n    function recoverRevokeHash(bytes _signature, bytes _sigToRevoke)\r\n      public\r\n      pure\r\n    returns (address from)\r\n    {\r\n        return ecrecoverFromSig(getSignHash(getRevokeHash(_sigToRevoke)), _signature);\r\n    }\r\n    \r\n    function getPreSignedHash(\r\n        bytes4 _function,\r\n        address _to, \r\n        uint256 _value,\r\n        bytes _extraData,\r\n        uint256 _nonce)\r\n      public\r\n      view\r\n    returns (bytes32 txHash) \r\n    {\r\n        return keccak256(address(this), _function, _to, _value, _extraData, _nonce);\r\n    }\r\n    \r\n   \r\n    function recoverPreSigned(\r\n        bytes _sig,\r\n        bytes4 _function,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes _extraData,\r\n        uint256 _nonce) \r\n      public\r\n      view\r\n    returns (address recovered)\r\n    {\r\n        bytes32 hexdData = getPreSignedHash(_function, _to, _value, _extraData, _nonce);\r\n        return ecrecoverFromSig( keccak256(\"\\x19Ethereum Signed Message:\\n32\",hexdData), _sig);\r\n    }\r\n    \r\n    /**\r\n     * @dev Add signature prefix to hash for recovery à la ERC191.\r\n     * @param _hash The hashed transaction to add signature prefix to.\r\n    **/\r\n    function getSignHash(bytes32 _hash)\r\n      public\r\n      pure\r\n    returns (bytes32 signHash)\r\n    {\r\n        return keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash);\r\n    }\r\n\r\n    /**\r\n     * @dev Helps to reduce stack depth problems for delegations. Thank you to Bokky for this!\r\n     * @param hash The hash of signed data for the transaction.\r\n     * @param sig Contains r, s, and v for recovery of address from the hash.\r\n    **/\r\n    function ecrecoverFromSig(bytes32 hash, bytes sig) \r\n      public \r\n      pure \r\n    returns (address recoveredAddress) \r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (sig.length != 65) return address(0);\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            // Here we are loading the last 32 bytes. We exploit the fact that 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        // Albeit non-transactional signatures are not specified by the YP, one would expect it to match the YP range of [27, 28]\r\n        // geth uses [0, 1] and some clients have followed. This might change, see https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) {\r\n          v += 27;\r\n        }\r\n        if (v != 27 && v != 28) return address(0);\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Frontend queries to find the next nonce of the user so they can find the new nonce to send.\r\n     * @param _owner Address that will be sending the COIN.\r\n    **/\r\n    function getNonce(address _owner)\r\n      external\r\n      view\r\n    returns (uint256 nonce)\r\n    {\r\n        return nonces[_owner];\r\n    }\r\n    \r\n/** ****************************** Constants ******************************* **/\r\n    \r\n    /**\r\n     * @dev Return total supply of token.\r\n    **/\r\n    function totalSupply() \r\n      external\r\n      view \r\n     returns (uint256)\r\n    {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Return balance of a certain address.\r\n     * @param _owner The address whose balance we want to check.\r\n    **/\r\n    function balanceOf(address _owner)\r\n      external\r\n      view \r\n    returns (uint256) \r\n    {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    /**\r\n     * @dev Allowed amount for a user to spend of another's tokens.\r\n     * @param _owner The owner of the tokens approved to spend.\r\n     * @param _spender The address of the user allowed to spend the tokens.\r\n    **/\r\n    function allowance(address _owner, address _spender) \r\n      external\r\n      view \r\n    returns (uint256) \r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n/** ****************************** onlyOwner ******************************* **/\r\n    \r\n    /**\r\n     * @dev Allow the owner to take ERC20 tokens off of this contract if they are accidentally sent.\r\n    **/\r\n    function token_escape(address _tokenContract)\r\n      external\r\n      onlyOwner\r\n    {\r\n        SiuCoin lostToken = SiuCoin(_tokenContract);\r\n        \r\n        uint256 stuckTokens = lostToken.balanceOf(address(this));\r\n        lostToken.transfer(owner, stuckTokens);\r\n    }\r\n    \r\n    /**\r\n     * @dev Owner may set the standard sig to redirect to one of our pre-signed functions.\r\n     * @dev Added in order to prepare for the ERC865 standard function names to be different from ours.\r\n     * @param _standardSig The function signature of the finalized standard function.\r\n     * @param _ourSig The function signature of our implemented function.\r\n    **/\r\n    function updateStandard(bytes4 _standardSig, bytes4 _ourSig)\r\n      external\r\n      onlyOwner\r\n    returns (bool success)\r\n    {\r\n        // These 6 are the signatures of our pre-signed functions. Don't want the owner messin' around.\r\n        require(_ourSig == 0x1296830d || _ourSig == 0x617b390b || _ourSig == 0xadb8249e ||\r\n            _ourSig == 0x8be52783 || _ourSig == 0xc8d4b389 || _ourSig == 0xe391a7c4);\r\n        standardSigs[_standardSig] = _ourSig;\r\n        return true;\r\n    }\r\n    \r\n/** ***************************** Modifiers ******************************** **/\r\n    \r\n    modifier validPayload(uint _size) {\r\n        uint payload_size;\r\n        assembly {\r\n            payload_size := calldatasize\r\n        }\r\n        require(payload_size >= _size);\r\n        _;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sig\",\"type\":\"bytes\"},{\"name\":\"_function\",\"type\":\"bytes4\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"recoverPreSigned\",\"outputs\":[{\"name\":\"recovered\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"_burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"approvePreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_function\",\"type\":\"bytes4\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getPreSignedHash\",\"outputs\":[{\"name\":\"txHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"approveAndCallPreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"decreaseApprovalPreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"standardSigs\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"getSignHash\",\"outputs\":[{\"name\":\"signHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"increaseApprovalPreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_standardSig\",\"type\":\"bytes4\"},{\"name\":\"_ourSig\",\"type\":\"bytes4\"}],\"name\":\"updateStandard\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_sigToRevoke\",\"type\":\"bytes\"}],\"name\":\"revokeSignaturePreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sigToRevoke\",\"type\":\"bytes\"}],\"name\":\"revokeSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"token_escape\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"ecrecoverFromSig\",\"outputs\":[{\"name\":\"recoveredAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"transferPreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sigToRevoke\",\"type\":\"bytes\"}],\"name\":\"getRevokeHash\",\"outputs\":[{\"name\":\"txHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_sigToRevoke\",\"type\":\"bytes\"}],\"name\":\"recoverRevokeHash\",\"outputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sig\",\"type\":\"bytes\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"SignatureRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SiuCoin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0882df67435f8fa94190c85e70397a881f742e64dee6d752e6b8c6020d3f8b9b"}]}