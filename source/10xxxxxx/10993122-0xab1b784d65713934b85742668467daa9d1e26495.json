{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.9;\r\n\r\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n//::::::::::: @#::::::::::: @#:::::::::::: #@j:::::::::::::::::::::::::\r\n//::::::::::: ##::::::::::: @#:::::::::::: #@j:::::::::::::::::::::::::\r\n//::::::::::: ##::::::::::: @#:::::::::::: #@j:::::::::::::::::::::::::\r\n//::::: ########: ##:: ##:: DUTCh>: ihD%y: #@Whdqy:::::::::::::::::::::\r\n//::: ###... ###: ##:: ##:: @B... @@7...t: N@N.. R@K:::::::::::::::::::\r\n//::: ##::::: ##: ##:: ##:: @Q::: @Q.::::: N@j:: z@Q:::::::::::::::::::\r\n//:::: ##DuTCH##: .@QQ@@#:: hQQQh <R@QN@Q: N@j:: z@Q:::::::::::::::::::\r\n//::::::.......: =Q@y....:::....:::......::...:::...:::::::::::::::::::\r\n//:::::::::::::: h@W? sWAP@! 'DW;:::::: KK. ydSWAP@t: NNKNQBdt:::::::::\r\n//:::::::::::::: 'zqRqj*. L@R h@w: QQ: L@5 Q@... d@@: @@U... @Q::::::::\r\n//:::::::::::::::::...... Q@^ ^@@N@wt@BQ@ <@Q^::: @@: @@}::: @@:::::::: \r\n//:::::::::::::::::: U@@QKt... D@@L.. B@Q.. KDUTCH@Q: @@QQ#QQq:::::::::\r\n//:::::::::::::::::::.....::::::...:::...::::.......: @@!.....:::::::::\r\n//::::::::::::::::::::::::::::::::::::::::::::::::::: @@!::::::::::::::\r\n//::::::::::::::::::::::::::::::::::::::::::::::::::: @@!::::::::::::::\r\n//::::::::::::::01101100:01101111:01101111:01101011::::::::::::::::::::\r\n//:::::01100100:01100101:01100101:01110000:01111001:01110010:::::::::::\r\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n//\r\n// DutchSwap Auction V1.3\r\n//   Copyright (c) 2020 DutchSwap.com\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  \r\n// If not, see <https://github.com/deepyr/DutchSwap/>.\r\n//\r\n// The above copyright notice and this permission notice shall be\r\n// included in all copies or substantial portions of the Software.\r\n//\r\n// Authors:\r\n// * Adrian Guerrera / Deepyr Pty Ltd\r\n//\r\n// ---------------------------------------------------------------------\r\n// SPDX-License-Identifier: GPL-3.0-or-later                        \r\n// ---------------------------------------------------------------------\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    \r\n    function max(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a >= b ? a : b;\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a <= b ? a : b;\r\n    }\r\n}\r\n\r\ncontract DutchSwapAuction  {\r\n\r\n    using SafeMath for uint256;\r\n    /// @dev The placeholder ETH address.\r\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    uint256 public startDate;\r\n    uint256 public endDate;\r\n    uint256 public startPrice;\r\n    uint256 public minimumPrice;\r\n    uint256 public totalTokens;  // Amount to be sold\r\n    uint256 public priceDrop; // Price reduction from startPrice at endDate\r\n    uint256 public commitmentsTotal;\r\n    uint256 public tokenWithdrawn;  // the amount of auction tokens already withdrawn\r\n    bool private initialised;    // AG: should be private\r\n    bool public finalised;\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    address public auctionToken;\r\n    address public paymentCurrency;\r\n    address payable public wallet;  // Where the auction funds will get paid\r\n    mapping(address => uint256) public commitments;\r\n    mapping(address => uint256) public claimed;\r\n\r\n    event AddedCommitment(address addr, uint256 commitment, uint256 price);\r\n\r\n\r\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\r\n    /// @dev https://eips.ethereum.org/EIPS/eip-2200)\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED);          // ReentrancyGuard: reentrant call\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /// @dev Init function\r\n    function initDutchAuction(\r\n        address _funder,\r\n        address _token,\r\n        uint256 _totalTokens,\r\n        uint256 _startDate,\r\n        uint256 _endDate,\r\n        address _paymentCurrency,\r\n        uint256 _startPrice,\r\n        uint256 _minimumPrice,\r\n        address payable _wallet\r\n    )\r\n        external\r\n    {\r\n        require(!initialised);                // Already Initialised\r\n        require(_endDate > _startDate);       // End date earlier than start date\r\n\r\n        // Try and refactor to remove these requirements\r\n        // require(_startPrice > _minimumPrice); // Starting price lower than minimum price\r\n        require(_minimumPrice > 0);           // Minimum price must be greater than 0\r\n        \r\n        auctionToken = _token;\r\n        paymentCurrency = _paymentCurrency;\r\n\r\n        totalTokens = _totalTokens;\r\n        startDate = _startDate;\r\n        endDate = _endDate;\r\n        startPrice = _startPrice;\r\n        minimumPrice = _minimumPrice;\r\n        wallet = _wallet;\r\n        _status = _NOT_ENTERED;\r\n\r\n        uint256 numerator = startPrice.sub(minimumPrice);\r\n        uint256 denominator = endDate.sub(startDate);\r\n        priceDrop = numerator.div(denominator);\r\n\r\n        // There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\r\n        _safeTransferFrom(auctionToken, _funder, _totalTokens);\r\n        initialised = true;\r\n\r\n    }\r\n\r\n    // Dutch Auction Price Function\r\n    // ============================\r\n    //\r\n    // Start Price -----\r\n    //                   \\\r\n    //                    \\\r\n    //                     \\\r\n    //                      \\ ------------ Clearing Price\r\n    //                     / \\            = AmountRaised/TokenSupply\r\n    //      Token Price  --   \\\r\n    //                  /      \\\r\n    //                --        ----------- Minimum Price\r\n    // Amount raised /          End Time\r\n    //\r\n\r\n\r\n\r\n    /// @notice The average price of each token from all commitments. \r\n    function tokenPrice() public view returns (uint256) {\r\n        return commitmentsTotal.mul(1e18).div(totalTokens);\r\n    }\r\n\r\n      /// @notice Returns price during the auction \r\n    function priceFunction() public view returns (uint256) {\r\n        /// @dev Return Auction Price\r\n        if (block.timestamp <= startDate) {\r\n            return startPrice;\r\n        }\r\n        if (block.timestamp >= endDate) {\r\n            return minimumPrice;\r\n        }\r\n         return _currentPrice();\r\n    }\r\n\r\n    /// @notice The current clearing price of the Dutch auction\r\n    function clearingPrice() public view returns (uint256) {\r\n        /// @dev If auction successful, return tokenPrice\r\n        if (tokenPrice() > priceFunction()) {\r\n            return tokenPrice();\r\n        }\r\n        return priceFunction();\r\n    }\r\n\r\n    /// @notice How many tokens the user is able to claim\r\n    function tokensClaimable(address _user) public view returns (uint256) {\r\n        uint256 tokensAvailable = commitments[_user].mul(1e18).div(clearingPrice());\r\n        return tokensAvailable.sub(claimed[msg.sender]);\r\n    }\r\n\r\n    /// @notice Total amount of tokens committed at current auction price\r\n    function totalTokensCommitted() public view returns(uint256) {\r\n        return commitmentsTotal.mul(1e18).div(clearingPrice());\r\n    }\r\n\r\n    /// @notice Total amount of tokens remaining \r\n    function tokensRemaining() public view returns (uint256) {\r\n        uint256 totalCommitted = totalTokensCommitted();\r\n        if (totalCommitted >= totalTokens ) {\r\n            return 0;\r\n        } else {\r\n            return totalTokens.sub(totalCommitted);\r\n        }\r\n    }\r\n\r\n    /// @notice Returns price during the auction\r\n    function _currentPrice() private view returns (uint256) {\r\n        uint256 elapsed = block.timestamp.sub(startDate);\r\n        uint256 priceDiff = elapsed.mul(priceDrop);\r\n        return startPrice.sub(priceDiff);\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // Commit to buying tokens! \r\n    //--------------------------------------------------------\r\n\r\n    /// @notice Buy Tokens by committing ETH to this contract address \r\n    /// @dev Needs extra gas limit for additional state changes\r\n    receive () external payable {\r\n        commitEthFrom(msg.sender);\r\n    }\r\n\r\n    /// @dev Needs extra gas limit for additional state changes\r\n    function commitEth() public payable {\r\n        commitEthFrom(msg.sender);\r\n    }\r\n\r\n    /// @notice Commit ETH to buy tokens for any address \r\n    function commitEthFrom (address payable _from) public payable {\r\n        require(!finalised);                                    // Auction was cancelled\r\n        require(address(paymentCurrency) == ETH_ADDRESS);       // Payment currency is not ETH\r\n        // Get ETH able to be committed\r\n        uint256 ethToTransfer = calculateCommitment( msg.value);\r\n\r\n        // Accept ETH Payments\r\n        uint256 ethToRefund = msg.value.sub(ethToTransfer);\r\n        if (ethToTransfer > 0) {\r\n            _addCommitment(_from, ethToTransfer);\r\n        }\r\n        // Return any ETH to be refunded\r\n        if (ethToRefund > 0) {\r\n            _from.transfer(ethToRefund);\r\n        }\r\n    }\r\n\r\n    /// @notice Commit approved ERC20 tokens to buy tokens on sale\r\n    function commitTokens(uint256 _amount) public {\r\n        commitTokensFrom(msg.sender, _amount);\r\n    }\r\n\r\n    /// @dev Users must approve contract prior to committing tokens to auction\r\n    function commitTokensFrom(address _from, uint256 _amount) public nonReentrant {\r\n        require(!finalised);                                     // Auction was cancelled\r\n        require(address(paymentCurrency) != ETH_ADDRESS);          // Only token transfers\r\n        uint256 tokensToTransfer = calculateCommitment( _amount);\r\n        if (tokensToTransfer > 0) {\r\n            _safeTransferFrom(paymentCurrency, _from, tokensToTransfer);\r\n            _addCommitment(_from, tokensToTransfer);\r\n        }\r\n    }\r\n\r\n    /// @notice Returns the amout able to be committed during an auction\r\n    function calculateCommitment( uint256 _commitment) \r\n        public view returns (uint256 committed) \r\n    {\r\n        uint256 maxCommitment = totalTokens.mul(clearingPrice()).div(1e18);\r\n        if (commitmentsTotal.add(_commitment) > maxCommitment) {\r\n            return maxCommitment.sub(commitmentsTotal);\r\n        }\r\n        return _commitment;\r\n    }\r\n\r\n    /// @notice Commits to an amount during an auction\r\n    function _addCommitment(address _addr,  uint256 _commitment) internal {\r\n        require(block.timestamp >= startDate && block.timestamp <= endDate);  // Outside auction hours\r\n        commitments[_addr] = commitments[_addr].add(_commitment);\r\n        commitmentsTotal = commitmentsTotal.add(_commitment);\r\n        emit AddedCommitment(_addr, _commitment, _currentPrice());\r\n\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // Finalise Auction\r\n    //--------------------------------------------------------\r\n\r\n    /// @notice Successful if tokens sold equals totalTokens\r\n    function auctionSuccessful() public view returns (bool){\r\n        return tokenPrice() >= clearingPrice();\r\n    }\r\n\r\n    /// @notice Returns bool if successful or time has ended\r\n    /// @dev able to claim early if auction is successful\r\n    function auctionEnded() public view returns (bool){\r\n        return auctionSuccessful() || block.timestamp > endDate;\r\n    }\r\n\r\n    /// @notice Auction finishes successfully above the reserve\r\n    /// @dev Transfer contract funds to initialised wallet. \r\n    function finaliseAuction () public nonReentrant {\r\n        require(!finalised);                                  // Auction already finalised\r\n        if( auctionSuccessful() ) \r\n        {\r\n            /// @dev Successful auction\r\n            /// @dev Transfer contributed tokens to wallet.\r\n            _tokenPayment(paymentCurrency, wallet, commitmentsTotal);\r\n        }\r\n        else if ( commitmentsTotal == 0 )\r\n        {\r\n            /// @dev Cancelled Auction\r\n            /// @dev You can cancel the auction before it starts\r\n            require(block.timestamp <= startDate );            // Auction already started\r\n            _tokenPayment(auctionToken, wallet, totalTokens);\r\n        }\r\n        else\r\n        {\r\n            /// @dev Failed auction\r\n            /// @dev Return auction tokens back to wallet.\r\n            require(block.timestamp > endDate );               // Auction not yet finished\r\n            _tokenPayment(auctionToken, wallet, totalTokens);\r\n        }\r\n        finalised = true;\r\n    }\r\n\r\n    /// @notice Withdraw your tokens once the Auction has ended.\r\n    function withdrawTokens() public nonReentrant {\r\n        if( auctionSuccessful() ) \r\n        {\r\n            /// @dev Successful auction! Transfer claimed tokens.\r\n            /// @dev AG: Could be only > min to allow early withdraw\r\n            uint256 tokensToClaim = tokensClaimable(msg.sender);\r\n            require(tokensToClaim > 0 );                      // No tokens to claim\r\n            claimed[ msg.sender] = claimed[ msg.sender].add(tokensToClaim);\r\n            tokenWithdrawn = tokenWithdrawn.add(tokensToClaim);\r\n            _tokenPayment(auctionToken, msg.sender, tokensToClaim);\r\n        }\r\n        else \r\n        {\r\n            /// @dev Auction did not meet reserve price.\r\n            /// @dev Return committed funds back to user.\r\n            require(block.timestamp > endDate);               // Auction not yet finished\r\n            uint256 fundsCommitted = commitments[ msg.sender];\r\n            require(fundsCommitted > 0);                      // No funds committed\r\n\r\n            commitments[msg.sender] = 0;     // Stop multiple withdrawals and free some gas\r\n            _tokenPayment(paymentCurrency, msg.sender, fundsCommitted);       \r\n        }\r\n    }\r\n\r\n\r\n    //--------------------------------------------------------\r\n    // Helper Functions\r\n    //--------------------------------------------------------\r\n\r\n    // There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\r\n    // I'm trying to make it a habit to put external calls last (reentrancy)\r\n    // You can put this in an internal function if you like.\r\n    function _safeTransfer(address token, address to, uint256 amount) internal {\r\n        // solium-disable-next-line security/no-low-level-calls\r\n        (bool success, bytes memory data) = token.call(\r\n            // 0xa9059cbb = bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\r\n            abi.encodeWithSelector(0xa9059cbb, to, amount)\r\n        );\r\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 Transfer failed \r\n    }\r\n\r\n    function _safeTransferFrom(address token, address from, uint256 amount) internal {\r\n        // solium-disable-next-line security/no-low-level-calls\r\n        (bool success, bytes memory data) = token.call(\r\n            // 0x23b872dd = bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\r\n            abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\r\n        );\r\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 TransferFrom failed \r\n    }\r\n\r\n    /// @dev Helper function to handle both ETH and ERC20 payments\r\n    function _tokenPayment(address _token, address payable _to, uint256 _amount) internal {\r\n        if (address(_token) == ETH_ADDRESS) {\r\n            _to.transfer(_amount);\r\n        } else {\r\n            _safeTransfer(_token, _to, _amount);\r\n        }\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"AddedCommitment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"auctionEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionSuccessful\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commitment\",\"type\":\"uint256\"}],\"name\":\"calculateCommitment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"committed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commitEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"commitEthFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"commitTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"commitTokensFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commitmentsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finaliseAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalised\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_funder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_paymentCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumPrice\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"initDutchAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentCurrency\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceDrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFunction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"tokensClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensCommitted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DutchSwapAuction","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f62331508bd72160c239ff87426d2c8571d719c8656cee4456b8b41d614ac955"}]}