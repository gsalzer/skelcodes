{"status":"1","message":"OK","result":[{"SourceCode":"{\"BalancerRegistry.sol\":{\"content\":\"pragma solidity 0.5.15;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IBalancerPool.sol\\\";\\nimport \\\"./IBalancerFactory.sol\\\";\\n\\ncontract BalancerRegistry {\\n  uint constant BONE = 10**18;\\n  address public balancerFactoryAddress;\\n  mapping(uint =\\u003e address) poolLookup;\\n\\n  constructor(\\n    address _balancerFactoryAddress\\n  ) public {\\n    balancerFactoryAddress = _balancerFactoryAddress;\\n  }\\n\\n  function getPool(address tokenFrom, address tokenTo) public view returns (address) {\\n    uint key = calcKey(tokenFrom, tokenTo);\\n    return poolLookup[key];\\n  }\\n\\n  function addPool(address pool) public {\\n    if (!IBalancerFactory(balancerFactoryAddress).isBPool(pool)) return;\\n    if (!IBalancerPool(pool).isFinalized()) return;\\n    address[] memory tokens = IBalancerPool(pool).getCurrentTokens();\\n    for (uint i = 0; i \\u003c tokens.length - 1; ++i) {\\n      for (uint j = i + 1; j \\u003c tokens.length; ++j) {\\n        uint key = calcKey(tokens[i], tokens[j]);\\n        address incumbentPool = poolLookup[key];\\n        if (pool != incumbentPool) {\\n          if (incumbentPool == address(0)) {\\n            poolLookup[key] = pool;\\n          } else {\\n            uint scoreNew = scorePool(pool, tokens[i], tokens[j]);\\n            uint scoreOld = scorePool(incumbentPool, tokens[i], tokens[j]);\\n            if (scoreNew \\u003e scoreOld) {\\n              poolLookup[key] = pool;\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  function addPools(address[] calldata pools) external {\\n    for (uint i = 0; i \\u003c pools.length; ++i) {\\n      addPool(pools[i]);\\n    }\\n  }\\n\\n  function checkPool(address pool) public view returns (bool) {\\n    if (!IBalancerFactory(balancerFactoryAddress).isBPool(pool)) return false;\\n    if (!IBalancerPool(pool).isFinalized()) return false;\\n    address[] memory tokens = IBalancerPool(pool).getCurrentTokens();\\n    for (uint i = 0; i \\u003c tokens.length - 1; ++i) {\\n      for (uint j = i + 1; j \\u003c tokens.length; ++j) {\\n        uint key = calcKey(tokens[i], tokens[j]);\\n        address incumbentPool = poolLookup[key];\\n        if (pool != incumbentPool) {\\n          if (incumbentPool == address(0)) {\\n            return true;\\n          } else {\\n            uint scoreNew = scorePool(pool, tokens[i], tokens[j]);\\n            uint scoreOld = scorePool(incumbentPool, tokens[i], tokens[j]);\\n            if (scoreNew \\u003e scoreOld) {\\n              return true;\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function checkPools(address[] calldata pools) external view returns (address[] memory poolsUpdated) {\\n    address[] memory _poolsUpdated = new address[](pools.length);\\n    uint count = 0;\\n    for (uint i = 0; i \\u003c pools.length; ++i) {\\n      if (checkPool(pools[i])) {\\n        _poolsUpdated[count++] = pools[i];\\n      }\\n    }\\n    poolsUpdated = new address[](count);\\n    for (uint i = 0; i \\u003c count; ++i) {\\n      poolsUpdated[i] = _poolsUpdated[i];\\n    }\\n    return poolsUpdated;\\n  }\\n\\n  function scorePool(address pool, address token1, address token2) internal view returns (uint) {\\n    uint balance1 = IBalancerPool(pool).getBalance(token1);\\n    uint balance2 = IBalancerPool(pool).getBalance(token2);\\n    uint weight1 = IBalancerPool(pool).getDenormalizedWeight(token1);\\n    uint weight2 = IBalancerPool(pool).getDenormalizedWeight(token2);\\n    uint fee = IBalancerPool(pool).getSwapFee(); // BONE = 100%\\n    // Divide balances by weight factors to get liquidity values\\n    // Then divide by (the fee in %) + 1\\n    // So - 10% fee (i.e. BONE / 10) results in divide by 11\\n    //    - 1% fee (i.e. BONE / 100) results in divide by 2\\n    //    - 0% fee results in divide by 1 (no change)\\n    // Finally multiply the two results to get a score\\n    uint weightSum = weight1 + weight2;\\n    uint feePlusOne = fee + BONE / 100;\\n    return ((balance1 * weightSum / weight1) * (BONE / 100) / feePlusOne)\\n         * ((balance2 * weightSum / weight2) * (BONE / 100) / feePlusOne);\\n  }\\n\\n  function calcKey(address token1, address token2) internal pure returns (uint) {\\n    if (token1 \\u003c token2) {\\n      return (uint(token1) \\u003c\\u003c (256 - 160)) ^ uint(token2);\\n    } else {\\n      return (uint(token2) \\u003c\\u003c (256 - 160)) ^ uint(token1);\\n    }\\n  }\\n}\\n\"},\"IBalancerFactory.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\ninterface IBalancerFactory {\\n    function isBPool(address b)\\n        external view returns (bool);\\n}\\n\"},\"IBalancerPool.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\ninterface IBalancerPool {\\n    function isFinalized()\\n        external view returns (bool);\\n\\n    function getCurrentTokens()\\n        external view returns (address[] memory tokens);\\n\\n    function getSwapFee()\\n        external view returns (uint256);\\n\\n    function getDenormalizedWeight(address token)\\n        external view returns (uint256);\\n\\n    function getBalance(address token)\\n        external view returns (uint256);\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_balancerFactoryAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"addPools\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balancerFactoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"checkPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"checkPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"poolsUpdated\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BalancerRegistry","CompilerVersion":"v0.5.15+commit.6a57276f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009424b1412450d0f8fc2255faf6046b98213b76bd","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://39829b5a1929a0aeb4ff66c8ccfa091e8c758e3534057a3cf39e81c7c2da5072"}]}